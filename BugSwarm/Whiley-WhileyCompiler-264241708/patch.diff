diff --git a/src/main/java/wyc/io/WhileyFileLexer.java b/src/main/java/wyc/io/WhileyFileLexer.java
index 9be3b08b4..ee1828c8a 100755
--- a/src/main/java/wyc/io/WhileyFileLexer.java
+++ b/src/main/java/wyc/io/WhileyFileLexer.java
@@ -249,7 +249,12 @@ public Token scanOperator() {
 		case ';':
 			return new Token(Token.Kind.SemiColon, ";", pos++);
 		case ':':
-			return new Token(Token.Kind.Colon, ":", pos++);
+			if (pos + 1 < input.length() && input.charAt(pos + 1) == ':') {
+				pos += 2;
+				return new Token(Token.Kind.ColonColon, "::", pos - 2);
+			} else {
+				return new Token(Token.Kind.Colon, ":", pos++);
+			}
 		case '|':
 			if (pos + 1 < input.length() && input.charAt(pos + 1) == '|') {
 				pos += 2;
@@ -625,6 +630,7 @@ private void syntaxError(String msg, int index) {
 			Comma(","),
 			SemiColon(";"),
 			Colon(":"),
+			ColonColon("::"),
 			Ampersand("&"),
 			VerticalBar("|"),
 			LeftBrace("("),
diff --git a/src/main/java/wyc/io/WhileyFileParser.java b/src/main/java/wyc/io/WhileyFileParser.java
index 4f6e83153..3cf03e38d 100644
--- a/src/main/java/wyc/io/WhileyFileParser.java
+++ b/src/main/java/wyc/io/WhileyFileParser.java
@@ -151,10 +151,7 @@ private void parseImportDeclaration(WhileyFile wf) {
 		// Second, parse package string
 		Trie filter = Trie.ROOT.append(token.text);
 		token = null;
-		while ((token = tryAndMatch(true, Dot, DotDot)) != null) {
-			if (token.kind == DotDot) {
-				filter = filter.append("**");
-			}
+		while ((token = tryAndMatch(true, ColonColon)) != null) {
 			if (tryAndMatch(true, Star) != null) {
 				filter = filter.append("*");
 			} else {
@@ -2269,7 +2266,7 @@ private Expr parseAccessExpression(WhileyFile wf, EnclosingScope scope, boolean
 		Token token;
 
 		while ((token = tryAndMatchOnLine(LeftSquare)) != null
-				|| (token = tryAndMatch(terminated, Dot, MinusGreater)) != null) {
+				|| (token = tryAndMatch(terminated, Dot, MinusGreater, ColonColon)) != null) {
 			switch (token.kind) {
 			case LeftSquare:
 				// NOTE: expression guaranteed to be terminated by ']'.
@@ -2282,18 +2279,11 @@ private Expr parseAccessExpression(WhileyFile wf, EnclosingScope scope, boolean
 				lhs = new Expr.Dereference(lhs, sourceAttr(start, index - 1));
 				// Fall through
 			case Dot:
-				// At this point, we could have a field access, a package access
-				// or a method/function invocation. Therefore, we start by
+				// At this point, we could have a field access, or a
+				// method/function invocation. Therefore, we start by
 				// parsing the field access and then check whether or not its an
 				// invocation.
 				String name = match(Identifier).text;
-				// This indicates we have either a direct or indirect access or
-				// invocation. We can disambiguate between these two categories
-				// by examining what we have parsed already. A direct access or
-				// invocation requires a sequence of identifiers where the first
-				// is not a declared variable name.
-				Path.ID id = parsePossiblePathID(lhs, scope);
-
 				// First we have to see if it is a method invocation. We can
 				// have optional lifetime arguments in angle brackets.
 				boolean isInvocation = false;
@@ -2304,8 +2294,7 @@ private Expr parseAccessExpression(WhileyFile wf, EnclosingScope scope, boolean
 					// This one is a little tricky, as we need some lookahead
 					// effort. We want to see whether it is a method invocation
 					// with lifetime arguments. But "Identifier < ..." can also
-					// be a
-					// boolean expression!
+					// be a boolean expression!
 					int oldindex = index;
 					match(LeftAngle);
 					Token lifetime = tryAndMatch(terminated, RightAngle, Identifier, This, Star);
@@ -2320,34 +2309,42 @@ private Expr parseAccessExpression(WhileyFile wf, EnclosingScope scope, boolean
 					}
 				}
 				if (isInvocation) {
-					// This indicates a direct or indirect invocation. First,
+					// This indicates an indirect invocation. First,
 					// parse arguments to invocation
 					ArrayList<Expr> arguments = parseInvocationArguments(wf, scope);
-					// Second, determine what kind of invocation we have.
-					if (id == null) {
-						// This indicates we have an indirect invocation
-						lhs = new Expr.FieldAccess(lhs, name, sourceAttr(start, index - 1));
-						lhs = new Expr.AbstractIndirectInvoke(lhs, arguments, lifetimeArguments,
-								sourceAttr(start, index - 1));
-					} else {
-						// This indicates we have an direct invocation
-						lhs = new Expr.AbstractInvoke(name, id, arguments, lifetimeArguments,
-								sourceAttr(start, index - 1));
-					}
-
-				} else if (id != null) {
-					// Must be a qualified constant access
-					lhs = new Expr.ConstantAccess(name, id, sourceAttr(start, index - 1));
+					// Now construct indirect expression
+					lhs = new Expr.FieldAccess(lhs, name, sourceAttr(start, index - 1));
+					lhs = new Expr.AbstractIndirectInvoke(lhs, arguments, lifetimeArguments,
+							sourceAttr(start, index - 1));
 				} else {
 					// Must be a plain old field access.
 					lhs = new Expr.FieldAccess(lhs, name, sourceAttr(start, index - 1));
 				}
+				break;
+
+			case ColonColon:
+				// At this point, we have a qualified access.
+				index = start;
+				checkQualifiedAccess(lhs);
+				lhs = parseQualifiedAccess(wf, scope, terminated);
+				break;
 			}
 		}
 
 		return lhs;
 	}
 
+	private void checkQualifiedAccess(Expr src) {
+		// Check expression initially parse is valid qualified access
+		if (src instanceof Expr.LocalVariable) {
+			Expr.LocalVariable lv = (Expr.LocalVariable) src;
+		} else if (src instanceof Expr.ConstantAccess) {
+			Expr.ConstantAccess ca = (Expr.ConstantAccess) src;
+		} else {
+			syntaxError("expecting qualified name", src);
+		}
+	}
+
 	/**
 	 * Attempt to parse a possible module identifier. This will reflect a true
 	 * module identifier only if the root variable is not in the given
@@ -2360,24 +2357,27 @@ private Expr parseAccessExpression(WhileyFile wf, EnclosingScope scope, boolean
 	 *            indentation level.
 	 * @return
 	 */
-	private Path.ID parsePossiblePathID(Expr src, EnclosingScope scope) {
-		if (src instanceof Expr.LocalVariable) {
-			// this is a local variable, indicating that the we did not have
-			// a module identifier.
-			return null;
-		} else if (src instanceof Expr.ConstantAccess) {
-			Expr.ConstantAccess ca = (Expr.ConstantAccess) src;
-			return Trie.ROOT.append(ca.name);
-		} else if (src instanceof Expr.FieldAccess) {
-			Expr.FieldAccess ada = (Expr.FieldAccess) src;
-			Path.ID id = parsePossiblePathID(ada.src, scope);
-			if (id != null) {
-				return id.append(ada.name);
-			} else {
-				return null;
-			}
+	private Expr parseQualifiedAccess(WhileyFile wf, EnclosingScope scope, boolean terminated) {
+		int start = index;
+		// Parse all path components
+		Token token = match(Identifier);
+		Trie root = Trie.ROOT.append(token.text);
+		while ((token = tryAndMatchOnLine(ColonColon)) != null) {
+			Token identifier = match(Identifier);
+			root = root.append(identifier.text);
+		}
+		String name = root.last();
+		Trie path = root.parent();
+		// Third, decide what we've got.
+		if (tryAndMatch(terminated, LeftBrace) != null) {
+			// This indicates a direct invocation. First,
+			// parse arguments to invocation
+			ArrayList<Expr> arguments = parseInvocationArguments(wf, scope);
+			// This indicates we have an direct invocation
+			return new Expr.AbstractInvoke(name, path, arguments, null, sourceAttr(start, index - 1));
 		} else {
-			return null;
+			// Must be a qualified constant access
+			return new Expr.ConstantAccess(name, path, sourceAttr(start, index - 1));
 		}
 	}
 
@@ -4056,7 +4056,7 @@ private boolean mustParseAsExpr(Expr e) {
 		int start = index;
 		List<WyalFile.Identifier> components = new ArrayList<>();
 		components.add(parseIdentifier(scope));
-		while (tryAndMatch(false, Dot) != null) {
+		while (tryAndMatch(false, ColonColon) != null) {
 			components.add(parseIdentifier(scope));
 		}
 		WyalFile.Identifier[] ids = components.toArray(new WyalFile.Identifier[components.size()]);
diff --git a/src/main/java/wyil/util/type/TypeAlgorithms.java b/src/main/java/wyil/util/type/TypeAlgorithms.java
index 05b659f1a..ee23aaac6 100755
--- a/src/main/java/wyil/util/type/TypeAlgorithms.java
+++ b/src/main/java/wyil/util/type/TypeAlgorithms.java
@@ -86,7 +86,7 @@ public int compare(Automaton.State s1, Automaton.State s2) {
 				Boolean nid1 = (Boolean) s1.data;
 				Boolean nid2 = (Boolean) s2.data;
 				return nid1.toString().compareTo(nid2.toString());
-			} else if(s1.kind == TypeSystem.K_FUNCTION || s1.kind == TypeSystem.K_METHOD) {
+			} else if(s1.kind == TypeSystem.K_FUNCTION || s1.kind == TypeSystem.K_METHOD || s1.kind == TypeSystem.K_PROPERTY) {
 				TypeSystem.FunctionOrMethodState s1Data = (TypeSystem.FunctionOrMethodState) s1.data;
 				TypeSystem.FunctionOrMethodState s2Data = (TypeSystem.FunctionOrMethodState) s2.data;
 				return s1Data.compareTo(s2Data);
@@ -153,6 +153,7 @@ private static boolean isContractive(int index, BitSet contractives,
 		case TypeSystem.K_ARRAY:
 		case TypeSystem.K_FUNCTION:
 		case TypeSystem.K_METHOD:
+		case TypeSystem.K_PROPERTY:
 			return false;
 		}
 
@@ -254,6 +255,7 @@ private static Inhabitation getStateInhabitation(int index, Automaton automaton,
 		case TypeSystem.K_BYTE:
 		case TypeSystem.K_INT:
 		case TypeSystem.K_FUNCTION:
+		case TypeSystem.K_PROPERTY:
 		case TypeSystem.K_NOMINAL:
 		case TypeSystem.K_META:
 			return Inhabitation.SOME;
@@ -317,6 +319,7 @@ private static boolean setStateInhabitation(int index, Automaton automaton, BitS
 			case TypeSystem.K_REFERENCE:
 			case TypeSystem.K_RECORD:
 			case TypeSystem.K_FUNCTION:
+			case TypeSystem.K_PROPERTY:
 			case TypeSystem.K_METHOD:
 				inhabitationFlags.set(index, newValue == Inhabitation.SOME);
 				break;
@@ -479,6 +482,7 @@ private static boolean simplifyState(int index, Automaton automaton, BitSet inha
 		case TypeSystem.K_INT:
 		case TypeSystem.K_NOMINAL:
 		case TypeSystem.K_FUNCTION:
+		case TypeSystem.K_PROPERTY:
 		case TypeSystem.K_META:
 			return false;
 		case TypeSystem.K_NEGATION:
@@ -550,7 +554,7 @@ private static boolean simplifyCompound(int index, Automaton.State state, Automa
 
 		// Skip some children if the compound is a function
 		int numChildrenToCheck = children.length;
-		if (state.kind == TypeSystem.K_FUNCTION) {
+		if (state.kind == TypeSystem.K_FUNCTION && state.kind == TypeSystem.K_PROPERTY) {
 		  // Only check function parameters for now
 		  // TODO: Work out how to handle function return types properly
 			numChildrenToCheck = (Integer) state.data;
@@ -994,6 +998,7 @@ private static int intersectSameKind(int fromIndex, boolean fromSign, Automaton
 				return intersectUnions(fromIndex,fromSign,from,toIndex,toSign,to,allocations,states);
 			case TypeSystem.K_FUNCTION:
 			case TypeSystem.K_METHOD:
+			case TypeSystem.K_PROPERTY:
 				return intersectFunctionsOrMethods(fromIndex,fromSign,from,toIndex,toSign,to,allocations,states);
 			default: {
 				return intersectPrimitives(fromIndex,fromSign,from,toIndex,toSign,to,allocations,states);
@@ -2045,7 +2050,7 @@ private static int invert(int kind, boolean sign) {
 	 */
 	private static boolean flattenChildren(int index, Automaton.State state,
 			Automaton automaton) {
-		ArrayList<Integer> nchildren = new ArrayList<Integer>();
+		ArrayList<Integer> nchildren = new ArrayList<>();
 		int[] children = state.children;
 		final int kind = state.kind;
 
diff --git a/tests/invalid/Import_Invalid_1.whiley b/tests/invalid/Import_Invalid_1.whiley
index 18fc40df3..16faa5133 100644
--- a/tests/invalid/Import_Invalid_1.whiley
+++ b/tests/invalid/Import_Invalid_1.whiley
@@ -2,7 +2,7 @@
 function f(int x) -> int[]:
     return toString(x)
 
-import toString from whiley.lang.Any
+import toString from std::ascii
 
 function g(any x) -> int[]:
     return toString(x)
diff --git a/tests/valid/ConstrainedList_Valid_28.whiley b/tests/valid/ConstrainedList_Valid_28.whiley
index 739b6f176..a1687320f 100644
--- a/tests/valid/ConstrainedList_Valid_28.whiley
+++ b/tests/valid/ConstrainedList_Valid_28.whiley
@@ -1,5 +1,3 @@
-import whiley.lang.System
-
 // A recursive implementation of the lastIndexOf algorithm
 function lastIndexOf(int[] items, int item, int index) -> (int r)
 // Index is within bounds or one past length
diff --git a/tests/valid/FunctionRef_Valid_12.whiley b/tests/valid/FunctionRef_Valid_12.whiley
index 55f9f6a42..1801e2cf8 100644
--- a/tests/valid/FunctionRef_Valid_12.whiley
+++ b/tests/valid/FunctionRef_Valid_12.whiley
@@ -1,4 +1,3 @@
-import whiley.lang.*
 type SizeGetter is function(Sized) -> int
 type Sized is { SizeGetter getSize }
 
diff --git a/tests/valid/FunctionRef_Valid_13.whiley b/tests/valid/FunctionRef_Valid_13.whiley
index 5cc1361b1..e47ce25ce 100644
--- a/tests/valid/FunctionRef_Valid_13.whiley
+++ b/tests/valid/FunctionRef_Valid_13.whiley
@@ -1,4 +1,3 @@
-import whiley.lang.*
 type Sized is { int value }
 type SizeGetter is function(Sized) -> int
 type SizeSetter is function(Sized,int) -> Sized
diff --git a/tests/valid/Switch_Valid_4.whiley b/tests/valid/Switch_Valid_4.whiley
index d480d149f..d991a0001 100644
--- a/tests/valid/Switch_Valid_4.whiley
+++ b/tests/valid/Switch_Valid_4.whiley
@@ -12,7 +12,7 @@ function f(RGB c) -> int:
     switch c:
         case Red:
             return 123
-        case Switch_Valid_4.Blue:
+        case Switch_Valid_4::Blue:
             return 234
         default:
             return 456
