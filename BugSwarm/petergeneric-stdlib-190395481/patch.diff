diff --git a/azure/pom.xml b/azure/pom.xml
index 370b7dcbb3..17a0554587 100755
--- a/azure/pom.xml
+++ b/azure/pom.xml
@@ -5,7 +5,7 @@
 	<parent>
 		<artifactId>stdlib-parent</artifactId>
 		<groupId>com.peterphi.std</groupId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 
diff --git a/guice/common/pom.xml b/guice/common/pom.xml
index 2dca1ec262..549506a295 100755
--- a/guice/common/pom.xml
+++ b/guice/common/pom.xml
@@ -12,7 +12,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/apploader/GuiceProperties.java b/guice/common/src/main/java/com/peterphi/std/guice/apploader/GuiceProperties.java
index 0b5081023d..e3e98e93b7 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/apploader/GuiceProperties.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/apploader/GuiceProperties.java
@@ -202,7 +202,7 @@
 	//
 	// Guice Liquibase module
 	//
-	@Doc("The liquibase action to execute, should be one of LiquibaseAction - IGNORE/ASSERT_UPDATED/UPDATE/MARK_UPDATED (default ASSERT_UPDATED)")
+	@Doc("The liquibase action to execute, should be one of LiquibaseAction - IGNORE/ASSERT_UPDATED/UPDATE/MARK_UPDATED/GENERATE_CHANGELOG (default ASSERT_UPDATED)")
 	public static final java.lang.String LIQUIBASE_ACTION = "liquibase.action";
 
 	@Doc("The liquibase changelog file to use")
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/common/ClassScannerFactory.java b/guice/common/src/main/java/com/peterphi/std/guice/common/ClassScannerFactory.java
index 8e5824a281..a9ac1e1304 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/common/ClassScannerFactory.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/common/ClassScannerFactory.java
@@ -107,7 +107,8 @@ private static CompositeArchive getArchivesForPackage(final ClassLoader classloa
 				{
 					final URL url = urls.nextElement();
 
-					log.info("Found source: " + url);
+					if (log.isTraceEnabled())
+						log.trace("Found source: " + url);
 
 					if (url.getProtocol() != null && (url.getProtocol().equals("zip") || url.getProtocol().equals("jar")))
 						archives.add(new FilteredArchive(new JarArchive(classloader, url), new PrefixFilter(pkg)));
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/common/auth/iface/CurrentUser.java b/guice/common/src/main/java/com/peterphi/std/guice/common/auth/iface/CurrentUser.java
index 7b19f46db7..1638be383f 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/common/auth/iface/CurrentUser.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/common/auth/iface/CurrentUser.java
@@ -1,6 +1,7 @@
 package com.peterphi.std.guice.common.auth.iface;
 
 import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
 import org.joda.time.format.DateTimeFormat;
 import org.joda.time.format.DateTimeFormatter;
 
@@ -14,7 +15,10 @@
 
 public interface CurrentUser
 {
-	DateTimeFormatter DEFAULT_DATE_FORMAT = DateTimeFormat.forPattern("YYYY-MM-dd HH:mm:ss zzz").withZoneUTC();
+	String DEFAULT_DATE_FORMAT_STRING = "YYYY-MM-dd HH:mm:ss zzz";
+	String DEFAULT_TIMEZONE = "Europe/London";
+
+	DateTimeFormatter DEFAULT_DATE_FORMAT = DateTimeFormat.forPattern(DEFAULT_DATE_FORMAT_STRING).withZone(DateTimeZone.forID(DEFAULT_TIMEZONE));
 
 	/**
 	 * Special role string indicating that the user is logged in
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/common/serviceprops/ConfigurationPropertyRegistry.java b/guice/common/src/main/java/com/peterphi/std/guice/common/serviceprops/ConfigurationPropertyRegistry.java
index e2da459457..a0e225b320 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/common/serviceprops/ConfigurationPropertyRegistry.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/common/serviceprops/ConfigurationPropertyRegistry.java
@@ -50,18 +50,9 @@ public ConfigurationPropertyRegistry(final GuiceConfig configuration)
 		{
 			if (!properties.containsKey(site.getName()))
 			{
-				log.debug("Discovered new property: " + site.getName());
-
 				properties.put(site.getName(), new ConfigurationProperty(this, configuration, site.getName()));
 			}
 
-			log.trace("Discovered new binding for property " +
-			          site.getName() +
-			          " of type " +
-			          site.getType() +
-			          " in " +
-			          site.getOwner());
-
 			properties.get(site.getName()).add(site);
 		}
 	}
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQConstraints.java b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQConstraints.java
index 5e1026f78c..76f584e36e 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQConstraints.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQConstraints.java
@@ -34,11 +34,17 @@
 	public String toString()
 	{
 		return "WebQueryConstraints{" +
-		       "offset=" + offset +
-		       ", limit=" + limit +
-		       ", computeSize=" + computeSize +
-		       ", clazz='" + subclass + '\'' +
-		       ", constraints=" + constraints +
+		       "offset=" +
+		       offset +
+		       ", limit=" +
+		       limit +
+		       ", computeSize=" +
+		       computeSize +
+		       ", clazz='" +
+		       subclass +
+		       '\'' +
+		       ", constraints=" +
+		       constraints +
 		       '}';
 	}
 }
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQUriControlField.java b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQUriControlField.java
index cdbad62192..ddc45194be 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQUriControlField.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WQUriControlField.java
@@ -1,5 +1,9 @@
 package com.peterphi.std.guice.restclient.jaxb.webquery;
 
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
 /**
  * Special WebQuery fields and their wire representation in the Query String API
  */
@@ -18,6 +22,10 @@
 	 * Set to true to request the resultset size be computed
 	 */
 	COMPUTE_SIZE("_compute_size"),
+	/**
+	 * Set to true to request that the SQL prepared statements as a result of this query be recorded as part of the resultset
+	 */
+	LOG_SQL("_log_sql"),
 	/**
 	 * Set to some class to specify the subclass to return (for entities with type hierarchies)
 	 */
@@ -32,7 +40,17 @@
 	 * Set to <code>entity</code> (the default) or <code>id</code> to fetch back the entity or just the entity primary key. This
 	 * is handled after the query completes and the results are being serialised
 	 */
-	FETCH("_fetch");
+	FETCH("_fetch"),
+	/**
+	 * Controls which relationships are eagerly fetched during the database query. <strong>N.B. the more relationships that are
+	 * eagerly fetched the larger the db result set and therefore the slower the query will perform - strike a balance and take
+	 * account of the value of <code>expand</code></strong>
+	 */
+	DBFETCH("_dbfetch"),
+	/**
+	 * An optional name for the query, to allow server-side optimisation/hinting
+	 */
+	NAME("_name");
 
 	private final String name;
 
@@ -64,4 +82,15 @@ public static WQUriControlField getByName(final String fieldName)
 
 		throw new IllegalArgumentException("No core WebQueryField with name: " + fieldName);
 	}
+
+
+	/**
+	 * Return all the permitted names
+	 *
+	 * @return
+	 */
+	public static List<String> getAllNames()
+	{
+		return Arrays.asList(values()).stream().map(o -> o.getName()).collect(Collectors.toList());
+	}
 }
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WebQuery.java b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WebQuery.java
index b06f831fa2..25bc932d34 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WebQuery.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/restclient/jaxb/webquery/WebQuery.java
@@ -29,16 +29,33 @@
 public class WebQuery
 {
 	/**
-	 * What to fetch - the entity or the primary key
+	 * An optional name for the query, to allow server-side optimisation/hinting
+	 */
+	@XmlAttribute
+	public String name;
+
+	/**
+	 * What to fetch: should be "entity" or "id".
 	 */
 	@XmlAttribute
 	public String fetch = "entity";
+
+	/**
+	 * Comma-separated list of relations to fetch from the database as part of the query
+	 */
+	@XmlAttribute
+	public String dbfetch;
+
+
 	/**
 	 * What relationships to expand (by default, all relationships are expanded)
 	 */
 	@XmlAttribute
 	public String expand = "all";
 
+	@XmlAttribute
+	public boolean logSQL = false;
+
 	@XmlElement
 	public WQConstraints constraints = new WQConstraints();
 
@@ -89,14 +106,28 @@ public boolean isComputeSize()
 	}
 
 
+	public boolean isLogSQL()
+	{
+		return this.logSQL;
+	}
+
+
 	@Override
 	public String toString()
 	{
 		return "WebQuery{" +
-		       "fetch='" + fetch + '\'' +
-		       ", expand='" + expand + '\'' +
-		       ", constraints=" + constraintsToQueryFragment() +
-		       ", orderings=" + orderings +
+		       "fetch='" +
+		       fetch +
+		       '\'' +
+		       ", expand='" +
+		       expand +
+		       '\'' +
+		       ", constraints=" +
+		       constraintsToQueryFragment() +
+		       ", logSQL=" +
+		       logSQL +
+		       ", orderings=" +
+		       orderings +
 		       '}';
 	}
 
@@ -118,7 +149,10 @@ private String constraintsToQueryFragment()
 
 	public WebQuery subclass(String... subclasses)
 	{
-		this.constraints.subclass = String.join(",", subclasses);
+		if (subclasses == null || subclasses.length == 0)
+			this.constraints.subclass = null;
+		else
+			this.constraints.subclass = String.join(",", subclasses);
 
 		return this;
 	}
@@ -186,6 +220,32 @@ public WebQuery orderDesc(final String field)
 	}
 
 
+	public WebQuery logSQL(final boolean enabled)
+	{
+		this.logSQL = enabled;
+
+		return this;
+	}
+
+
+	public WebQuery dbfetch(final String... relations)
+	{
+		if (relations == null || relations.length == 0)
+			this.dbfetch = null;
+		else
+			this.dbfetch = StringUtils.join(relations, ',');
+
+		return this;
+	}
+
+
+	public WebQuery name(final String name)
+	{
+		this.name = name;
+
+		return this;
+	}
+
 	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 	// Constraints
 	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -454,6 +514,9 @@ public WebQuery decode(Map<String, List<String>> map)
 					case COMPUTE_SIZE:
 						def.computeSize(parseBoolean(entry.getValue().get(0)));
 						break;
+					case LOG_SQL:
+						def.logSQL(parseBoolean(entry.getValue().get(0)));
+						break;
 					case EXPAND:
 						def.expand(entry.getValue().toArray(new String[entry.getValue().size()]));
 						break;
@@ -461,11 +524,20 @@ public WebQuery decode(Map<String, List<String>> map)
 						def.orderings = entry.getValue().stream().map(WQOrder:: parseLegacy).collect(Collectors.toList());
 						break;
 					case FETCH:
-						// Ordinarily we'd expect a single value here, but allow for multiple values to be provied as a comma-separated list
-						def.fetch(entry.getValue().stream().collect(Collectors.joining(",")));
+						// Ordinarily we'd expect a single value here, but allow for multiple values to be provided as a comma-separated list
+						def.fetch = entry.getValue().stream().collect(Collectors.joining(","));
+						break;
+					case DBFETCH:
+						def.dbfetch = entry.getValue().stream().collect(Collectors.joining(","));
+						break;
+					case NAME:
+						def.name(entry.getValue().get(0));
 						break;
 					default:
-						throw new IllegalArgumentException("Unknown query field: " + specialField);
+						throw new IllegalArgumentException("Unknown query field: " +
+						                                   specialField +
+						                                   " expected one of " +
+						                                   WQUriControlField.getAllNames());
 				}
 			}
 			else
@@ -488,10 +560,11 @@ else if (entry.getValue().size() > 0)
 
 					group.operator = WQGroupType.OR;
 
-					group.constraints = entry.getValue()
-					                         .stream()
-					                         .map(value -> WQConstraint.decode(entry.getKey(), value))
-					                         .collect(Collectors.toList());
+					group.constraints = entry
+							                    .getValue()
+							                    .stream()
+							                    .map(value -> WQConstraint.decode(entry.getKey(), value))
+							                    .collect(Collectors.toList());
 
 					def.constraints.constraints.add(group);
 				}
@@ -505,10 +578,12 @@ else if (entry.getValue().size() > 0)
 
 	private static boolean parseBoolean(String value)
 	{
-		if (StringUtils.equalsIgnoreCase(value, "true") || StringUtils.equalsIgnoreCase(value, "yes") ||
+		if (StringUtils.equalsIgnoreCase(value, "true") ||
+		    StringUtils.equalsIgnoreCase(value, "yes") ||
 		    StringUtils.equalsIgnoreCase(value, "on"))
 			return true;
-		else if (StringUtils.equalsIgnoreCase(value, "false") || StringUtils.equalsIgnoreCase(value, "no") ||
+		else if (StringUtils.equalsIgnoreCase(value, "false") ||
+		         StringUtils.equalsIgnoreCase(value, "no") ||
 		         StringUtils.equalsIgnoreCase(value, "off"))
 			return false;
 		else
diff --git a/guice/common/src/main/java/com/peterphi/std/guice/restclient/resteasy/impl/ResteasyProxyClientFactoryImpl.java b/guice/common/src/main/java/com/peterphi/std/guice/restclient/resteasy/impl/ResteasyProxyClientFactoryImpl.java
index dbf4c6f06a..17bae28b82 100755
--- a/guice/common/src/main/java/com/peterphi/std/guice/restclient/resteasy/impl/ResteasyProxyClientFactoryImpl.java
+++ b/guice/common/src/main/java/com/peterphi/std/guice/restclient/resteasy/impl/ResteasyProxyClientFactoryImpl.java
@@ -1,6 +1,7 @@
 package com.peterphi.std.guice.restclient.resteasy.impl;
 
 import com.google.inject.Inject;
+import com.google.inject.Injector;
 import com.google.inject.Singleton;
 import com.google.inject.name.Named;
 import com.peterphi.std.annotation.Doc;
@@ -30,6 +31,9 @@
 	@Inject
 	GuiceConfig config;
 
+	@Inject
+	Injector guice;
+
 	@Inject(optional = true)
 	@Named("jaxrs.cookie-store")
 	@Doc("Whether default JAX-RS clients should maintain a cookie store (default false)")
@@ -105,10 +109,38 @@ private ResteasyWebTarget getWebTarget(final boolean defaultFastFail, final Stri
 		final String authType = config.get("service." + name + ".auth-type", GuiceConstants.JAXRS_CLIENT_AUTH_DEFAULT);
 		final boolean storeCookies = config.getBoolean("service." + name + ".cookie-store", defaultStoreCookies);
 		final String bearerToken = config.get("service." + name + ".bearer", null);
-		final Supplier<String> bearerSupplier = (bearerToken != null) ? () -> bearerToken : null; // Supply fixed token
+		final String bearerTokenClassName = config.get("service." + name + ".bearer-generator", null);
+
+
+		final Supplier<String> bearerSupplier;
+		{
+			if (bearerToken != null)
+			{
+				bearerSupplier = () -> bearerToken;
+			}
+			else if (bearerTokenClassName != null)
+			{
+				try
+				{
+					final Class<?> bearerClass = Class.forName(bearerTokenClassName);
+
+					final Object instance = guice.getInstance(bearerClass);
+
+					bearerSupplier = (Supplier<String>) instance;
+				}
+				catch (Throwable e)
+				{
+					throw new RuntimeException("Error trying to instantiate bearer-generator class " + bearerTokenClassName, e);
+				}
+			}
+			else
+			{
+				bearerSupplier = null;
+			}
+		}
 
 		final boolean preemptiveAuth;
-		if (bearerToken != null)
+		if (bearerSupplier != null)
 			preemptiveAuth = true; // force pre-emptive auth
 		else if (authType.equalsIgnoreCase(GuiceConstants.JAXRS_CLIENT_AUTH_DEFAULT))
 			preemptiveAuth = false;
@@ -243,12 +275,14 @@ else if (username != null || password != null || StringUtils.isNotEmpty(endpoint
 			credentials = null;
 		}
 
-		return clientFactory.getOrCreateClient(fastFail,
-		                                       scope,
-		                                       credentials,
-		                                       (credentials != null) && preemptiveAuth,
-		                                       storeCookies,
-		                                       null).target(endpoint);
+		return clientFactory
+				       .getOrCreateClient(fastFail,
+				                          scope,
+				                          credentials,
+				                          (credentials != null) && preemptiveAuth,
+				                          storeCookies,
+				                          null)
+				       .target(endpoint);
 	}
 
 
diff --git a/guice/freemarker/pom.xml b/guice/freemarker/pom.xml
index 788b5d0c7f..300aade59a 100755
--- a/guice/freemarker/pom.xml
+++ b/guice/freemarker/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-freemarker</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice freemarker webapp</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/guice/hibernate-testing/pom.xml b/guice/hibernate-testing/pom.xml
index fc473955ee..21b4d68bd7 100755
--- a/guice/hibernate-testing/pom.xml
+++ b/guice/hibernate-testing/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-hibernate-testing</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice hibernate testing support</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/guice/hibernate-testing/src/main/resources/com/peterphi/std/guice/hibernatetest/hsqldb-in-memory.properties b/guice/hibernate-testing/src/main/resources/com/peterphi/std/guice/hibernatetest/hsqldb-in-memory.properties
index f5bb786c28..41ba33db5c 100755
--- a/guice/hibernate-testing/src/main/resources/com/peterphi/std/guice/hibernatetest/hsqldb-in-memory.properties
+++ b/guice/hibernate-testing/src/main/resources/com/peterphi/std/guice/hibernatetest/hsqldb-in-memory.properties
@@ -7,6 +7,8 @@ hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.hbm2ddl.auto=create
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=true
 hibernate.current_session_context_class=thread
diff --git a/guice/hibernate/pom.xml b/guice/hibernate/pom.xml
index 27a1c8c860..5b54907c3c 100755
--- a/guice/hibernate/pom.xml
+++ b/guice/hibernate/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-hibernate</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice hibernate</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/database/annotation/Transactional.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/database/annotation/Transactional.java
index ea3df72a46..b1a3473963 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/database/annotation/Transactional.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/database/annotation/Transactional.java
@@ -27,7 +27,17 @@
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Transactional
 {
-	public boolean readOnly() default false;
+	boolean readOnly() default false;
+
+	/**
+	 * If true, will automatically retry 5 times (with backoff) if the method throws {@link org.hibernate.StaleStateException}, {@link
+	 * org.hibernate.exception.LockAcquisitionException} or {@link org.hibernate.exception.GenericJDBCException}
+	 *
+	 * @return
+	 */
+	boolean autoRetry() default true;
+
+	int autoRetryCount() default 5;
 
 	/**
 	 * A list of exceptions to rollback on, if thrown by the transactional method. These exceptions are propagated correctly after
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/database/dao/Dao.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/database/dao/Dao.java
index e11b9d4dd9..82bb6402ed 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/database/dao/Dao.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/database/dao/Dao.java
@@ -25,7 +25,17 @@
 	public Class<T> getEntityType();
 
 	/**
-	 * Execute a Dynamic query using the specified constraints, returning the result as a ConstrainedResultSet
+	 * Given a query, return the IDs of the matching entities, returning the result as a ConstrainedResultSet of this entity's id
+	 * type
+	 *
+	 * @param query
+	 *
+	 * @return
+	 */
+	ConstrainedResultSet<ID> findIdsByUriQuery(WebQuery query);
+
+	/**
+	 * Execute a Dynamic query using the specified constraints, returning the result as a ConstrainedResultSet of this entity type
 	 *
 	 * @param constraints
 	 * 		the constraints to apply
@@ -34,6 +44,7 @@
 	 */
 	ConstrainedResultSet<T> findByUriQuery(WebQuery constraints);
 
+
 	/**
 	 * Retrieve every object accessible through this DAO
 	 *
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/dao/HibernateDao.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/dao/HibernateDao.java
index 90e7b7099b..e00452c1be 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/dao/HibernateDao.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/dao/HibernateDao.java
@@ -9,11 +9,13 @@
 import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.database.dao.Dao;
 import com.peterphi.std.guice.hibernate.exception.ReadOnlyTransactionException;
+import com.peterphi.std.guice.hibernate.module.logging.HibernateObservingInterceptor;
+import com.peterphi.std.guice.hibernate.module.logging.HibernateSQLLogger;
 import com.peterphi.std.guice.hibernate.webquery.ConstrainedResultSet;
-import com.peterphi.std.guice.hibernate.webquery.impl.QCriteriaBuilder;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLBuilder;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLProjection;
 import com.peterphi.std.guice.hibernate.webquery.impl.QEntity;
 import com.peterphi.std.guice.hibernate.webquery.impl.QEntityFactory;
-import com.peterphi.std.guice.restclient.jaxb.webquery.WQOrder;
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
 import org.apache.commons.lang.StringUtils;
 import org.hibernate.Criteria;
@@ -22,15 +24,17 @@
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.criterion.CriteriaSpecification;
-import org.hibernate.criterion.Projections;
 import org.hibernate.criterion.Restrictions;
 
 import java.io.Serializable;
+import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
 /**
  * The default implementation of a Dao for Hibernate; often it is necessary to extend this to produce richer queries<br />
@@ -60,6 +64,9 @@
 	@Doc("If true then URI queries on @LargeTable annotated entities will result in a query to retrieve ids followed by a query to retrieve data. This provides a massive speedup with some databases (e.g. 43x with SQL Server) on large tables when using joins (default true)")
 	boolean performSeparateIdQueryForLargeTables = true;
 
+	@Inject
+	HibernateObservingInterceptor hibernateObserver;
+
 	protected Class<T> clazz;
 
 	protected boolean isLargeTable = false;
@@ -120,6 +127,7 @@ protected String idProperty()
 		return getListById(ids);
 	}
 
+
 	@Override
 	public List<T> getListById(final Collection<ID> ids)
 	{
@@ -264,7 +272,6 @@ protected Query createQuery(String hql)
 		return getSession().createQuery(hql);
 	}
 
-
 	/**
 	 * Execute a Criteria search, returning the results as a checked list
 	 *
@@ -361,9 +368,10 @@ else if (results.getList().size() == 1)
 	}
 
 
-	protected List<ID> getIdList(WebQuery query)
+	@Transactional(readOnly = true)
+	public List<ID> getIdList(WebQuery query)
 	{
-		return (List<ID>) findByUriQuery(query).getList();
+		return getIdList(toGetIdQuery(query));
 	}
 
 
@@ -420,55 +428,94 @@ protected SessionFactory getSessionFactory()
 	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 
+	@Override
+	public ConstrainedResultSet<ID> findIdsByUriQuery(final WebQuery query)
+	{
+		return findByUriQuery(query, q -> getIdList(query));
+	}
+
+
+	@Override
+	public ConstrainedResultSet<T> findByUriQuery(final WebQuery query)
+	{
+		return findByUriQuery(query, q -> getList(q));
+	}
+
+
 	/**
+	 * Execute a WebQuery as HQL, using the supplied function to turn the generated HQL into a List of some result type<br />
+	 * This implements logic (if requested by the WebQuery) for logging SQL as well as computing size of resultset. This allows
+	 * the projection (in Java) of the query results to a different Java class
+	 *
 	 * @param query
-	 * 		the criteria
+	 * @param resultSupplier
+	 * @param <X>
 	 *
 	 * @return
 	 */
 	@Transactional(readOnly = true)
-	@Override
-	public ConstrainedResultSet<T> findByUriQuery(final WebQuery query)
+	public <X> ConstrainedResultSet<X> findByUriQuery(final WebQuery query, Function<Query, List<X>> resultSupplier)
 	{
-		// Optionally execute the count query
-		final Long total;
-		if (query.constraints.computeSize)
-		{
-			// Re-run the query to obtain the size
-			final Criteria countCriteria = toRowCountCriteria(query);
-
-			final Number size = (Number) countCriteria.uniqueResult();
+		final HibernateSQLLogger statementLog;
 
-			total = size.longValue();
-		}
+		if (query.isLogSQL())
+			statementLog = hibernateObserver.startSQLLogger();
 		else
-		{
-			total = null;
-		}
+			statementLog = null;
 
 
-		// Now fetch back the data
-		final ConstrainedResultSet<T> resultset;
+		try
 		{
-			if (total == null || total > 0)
+			// Optionally execute the count query
+			final Long total;
+			if (query.constraints.computeSize)
 			{
-				final Criteria criteria = createCriteria(query);
+				// Re-run the query to obtain the size
+				final Query countQuery = toRowCountQuery(query);
 
-				final List<T> results = getList(criteria);
+				final Number size = (Number) countQuery.uniqueResult();
 
-				resultset = new ConstrainedResultSet<>(query, results);
+				total = size.longValue();
 			}
 			else
 			{
-				// We know there were no results because the collection size was computed
-				resultset = new ConstrainedResultSet<>(query, Collections.emptyList());
+				total = null;
 			}
-		}
 
-		resultset.setTotal(total);
 
+			// Now fetch back the data
+			final ConstrainedResultSet<X> resultset;
+			{
+				if (total == null || total > 0)
+				{
+					final Query criteria = createQuery(query);
+
+					final List<X> results = resultSupplier.apply(criteria);
+
+					resultset = new ConstrainedResultSet<>(query, results);
+				}
+				else
+				{
+					// We know there were no results because the collection size was computed
+					resultset = new ConstrainedResultSet<>(query, Collections.emptyList());
+				}
+			}
 
-		return resultset;
+			resultset.setTotal(total);
+
+			// If we have an active statement log then expose the statements that have been prepared
+			if (statementLog != null)
+			{
+				resultset.setSql(statementLog.getAllStatements());
+			}
+
+			return resultset;
+		}
+		finally
+		{
+			if (statementLog != null)
+				statementLog.close();
+		}
 	}
 
 
@@ -482,79 +529,126 @@ protected SessionFactory getSessionFactory()
 	 * @return
 	 */
 	@Transactional(readOnly = true)
-	protected Criteria createCriteria(WebQuery constraints)
+	protected Query createQuery(WebQuery constraints)
 	{
 		// Optionally treat large tables differently (works around a SQL Server performance issue)
+		// See documentation on toGetByIdCriteria for more detail
 		if (isLargeTable && performSeparateIdQueryForLargeTables)
-			return toGetByIdCriteria(constraints);
+			return toGetByIdQuery(constraints);
 		else
-			return toSimpleCriteria(constraints);
+			return toSimpleQuery(constraints);
 	}
 
 
-	protected Criteria toGetByIdCriteria(WebQuery constraints)
+	/**
+	 * SQL Server Performance Workaround
+	 * <p>
+	 * Given a normal query, execute the search component <strong>but not the data retrieval</strong>, instead retrieving only
+	 * the Primary Keys of the entities to return (paginated and in the correct order).
+	 * <p>
+	 * This is to side-step an issue in SQL Server where it expands all the joins against a large table into a temporary table
+	 * before then applying filtering to that temporary table (not applying any of the filters to the original table) - this
+	 * results in a massive temporary table being created and then almost immediately being filtered down to a very small number
+	 * of rows.
+	 * <p>
+	 * If the initial query is only asking for Primary Keys then SQL Server is able to optimise the query correctly. N.B. this
+	 * could also be implemented as a subquery to avoid a double-query however it'd be necessary to be able to convert a WebQuery
+	 * into a DetachedCriteria in order to do this (and support is not yet written for this)
+	 *
+	 * @param constraints
+	 *
+	 * @return
+	 */
+	protected Query toGetByIdQuery(WebQuery constraints)
 	{
 		// Retrieve the primary keys separately from the data
-		final List<ID> ids = toGetIdCriteria(constraints).list();
-
-		final Criteria criteria = createCriteria();
+		final Collection<ID> ids = getIds(constraints);
 
 		if (ids.size() > 0)
 		{
-			criteria.add(Restrictions.in(idProperty(), ids));
+			final HQLBuilder byIdBuilder = toCriteriaBuilder(constraints);
+
+			// N.B. we do not need the constraints / pagination because we have already evaluated them
+			byIdBuilder.clearConstraints();
+			byIdBuilder.clearPagination();
 
-			// Append joins, orders and discriminators (but not the constraints, we have already evaluated them)
-			toCriteriaBuilder(constraints).appendTo(criteria, false, false);
+			// Re-apply subclass constraints if defined
+			if (StringUtils.isNotEmpty(constraints.constraints.subclass))
+				byIdBuilder.addClassConstraint(Arrays.asList(constraints.constraints.subclass.split(",")));
 
-			return criteria;
+			// Add a custom constraint that the ID must be one of the values we've already determined
+			byIdBuilder.addIdInConstraint(ids);
+
+			return byIdBuilder.toHQL(this :: createQuery);
 		}
 		else
 		{
+			final HQLBuilder emptyQueryBuilder = toCriteriaBuilder(new WebQuery());
+
 			// There were no results for this query, hibernate can't handle Restrictions.in(empty) so we must make sure no results come back
-			criteria.add(Restrictions.sqlRestriction("(0=1)"));
+			emptyQueryBuilder.addAlwaysFalseConstraint();
 
 			// Hint that we don't want any results
-			criteria.setMaxResults(0);
+			emptyQueryBuilder.limit(0);
 
-			return criteria;
+			return emptyQueryBuilder.toHQL(this :: createQuery);
 		}
 	}
 
 
-	protected Criteria toGetIdCriteria(WebQuery constraints)
+	/**
+	 * Get a list of IDs matching a WebQuery
+	 *
+	 * @param constraints
+	 *
+	 * @return
+	 */
+	public Collection<ID> getIds(final WebQuery constraints)
 	{
-		final Criteria criteria = toSimpleCriteria(constraints);
+		final List ret = toGetIdQuery(constraints).list();
 
-		criteria.setProjection(Projections.id());
-
-		return criteria;
+		if (ret.isEmpty())
+			return Collections.emptyList(); // Empty list
+		else if (ret.get(0).getClass().isArray())
+		{
+			// In the case where there are ORDER BY statements and the database needs ORDER BYs to be SELECTed, we may be returned a bunch of data in addition to the IDs
+			// List of columns, we only care about the first column in each row
+			return (List<ID>) ret.stream().map(r -> Array.get(r, 0)).map(id -> (ID) id).collect(Collectors.toList());
+		}
+		else
+		{
+			// Simple list of IDs
+			return (List<ID>) ret;
+		}
 	}
 
 
-	protected Criteria toRowCountCriteria(WebQuery constraints)
+	protected Query toGetIdQuery(WebQuery query)
 	{
-		final Criteria criteria = toSimpleCriteria(constraints);
-
-		// Discount offset/limit
-		criteria.setFirstResult(0);
-		criteria.setMaxResults(Integer.MAX_VALUE);
+		// Encode the WebQuery and add the constraints
+		final HQLBuilder builder = toCriteriaBuilder(query);
 
-		// Request the row count
-		criteria.setProjection(Projections.rowCount());
+		builder.setProjection(HQLProjection.IDS);
 
-		return criteria;
+		return builder.toHQL(this :: createQuery);
 	}
 
-/*
-	protected DetachedCriteria toDetachedCriteria(WebQuery query)
-	{
-		final DetachedCriteria criteria = DetachedCriteria.forClass(getEntityType());
 
+	protected Query toRowCountQuery(WebQuery constraints)
+	{
 		// Encode the WebQuery and add the constraints
-		toCriteriaBuilder(query).appendTo(criteria);
+		final HQLBuilder builder = toCriteriaBuilder(constraints).clearPagination().clearOrder();
 
-		return criteria;
-	}*/
+		builder.setProjection(HQLProjection.COUNT);
+
+		Query hql = builder.toHQL(this :: createQuery);
+
+		// Discount offset/limit
+		hql.setFirstResult(0);
+		hql.setMaxResults(Integer.MAX_VALUE);
+
+		return hql;
+	}
 
 
 	/**
@@ -565,14 +659,12 @@ protected DetachedCriteria toDetachedCriteria(WebQuery query)
 	 *
 	 * @return
 	 */
-	protected Criteria toSimpleCriteria(WebQuery query)
+	protected Query toSimpleQuery(WebQuery query)
 	{
-		final Criteria criteria = createCriteria();
-
 		// Encode the WebQuery and add the constraints
-		toCriteriaBuilder(query).appendTo(criteria);
+		final HQLBuilder builder = toCriteriaBuilder(query);
 
-		return criteria;
+		return builder.toHQL(this :: createQuery);
 	}
 
 
@@ -583,18 +675,11 @@ protected Criteria toSimpleCriteria(WebQuery query)
 	 *
 	 * @return
 	 */
-	protected QCriteriaBuilder toCriteriaBuilder(final WebQuery query)
+	protected HQLBuilder toCriteriaBuilder(final WebQuery query)
 	{
-		final QCriteriaBuilder builder = new QCriteriaBuilder(getQEntity()).offset(query.getOffset()).limit(query.getLimit());
-
-		// Add the sort order
-		for (WQOrder order : query.orderings)
-			builder.addOrder(builder.getProperty(order.field), order.isAsc());
-
-		if (StringUtils.isNotBlank(query.constraints.subclass))
-			builder.addClass(Arrays.asList(query.constraints.subclass.split(",")));
+		HQLBuilder builder = new HQLBuilder(getQEntity());
 
-		builder.addConstraints(query.constraints.constraints);
+		builder.addWebQuery(query);
 
 		return builder;
 	}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateModule.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateModule.java
index 3ec6dd52bf..c0b6eeb472 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateModule.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateModule.java
@@ -10,6 +10,7 @@
 import com.peterphi.std.guice.common.serviceprops.composite.GuiceConfig;
 import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.module.ext.HibernateConfigurationValidator;
+import com.peterphi.std.guice.hibernate.module.logging.HibernateObservingInterceptor;
 import com.peterphi.std.guice.hibernate.usertype.DateUserType;
 import com.peterphi.std.guice.hibernate.usertype.JodaDateTimeUserType;
 import com.peterphi.std.guice.hibernate.usertype.JodaLocalDateUserType;
@@ -57,17 +58,18 @@ protected void configure()
 		bind(Session.class).toProvider(SessionProvider.class);
 		bind(Transaction.class).toProvider(TransactionProvider.class);
 
-		TransactionMethodInterceptor interceptor = new TransactionMethodInterceptor(getProvider(Session.class), registry);
+		TransactionMethodInterceptor txinterceptor = new TransactionMethodInterceptor(getProvider(Session.class), registry);
 
 		// handles @Transactional methods
-		binder().bindInterceptor(Matchers.any(), Matchers.annotatedWith(Transactional.class), interceptor);
+		binder().bindInterceptor(Matchers.any(), Matchers.annotatedWith(Transactional.class), txinterceptor);
 	}
 
 
 	@Provides
 	@Singleton
 	public Configuration getHibernateConfiguration(GuiceConfig guiceConfig,
-	                                               @Named(GuiceProperties.HIBERNATE_PROPERTIES) String propertyFileName)
+	                                               @Named(GuiceProperties.HIBERNATE_PROPERTIES) String propertyFileName,
+	                                               HibernateObservingInterceptor interceptor)
 	{
 		final Properties properties = extractHibernateProperties(guiceConfig, propertyFileName);
 
@@ -75,6 +77,10 @@ public Configuration getHibernateConfiguration(GuiceConfig guiceConfig,
 
 		// Set up the hibernate Configuration
 		Configuration config = new Configuration();
+
+		// Set up the interceptor
+		config.setInterceptor(interceptor.getInterceptor());
+
 		config.addProperties(properties);
 
 		configure(config);
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateSessionFactoryProvider.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateSessionFactoryProvider.java
index acae98dba5..82776c58fb 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateSessionFactoryProvider.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/HibernateSessionFactoryProvider.java
@@ -81,7 +81,7 @@ void runShutDownSQL()
 	{
 		if (StringUtils.isNotEmpty(shutdownSql))
 		{
-			sessionFactory.getCurrentSession().createSQLQuery(shutdownSql).executeUpdate();
+			sessionFactory.getCurrentSession().createNativeQuery(shutdownSql).executeUpdate();
 		}
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/TransactionMethodInterceptor.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/TransactionMethodInterceptor.java
index 12a82c75ed..ebc18b29bc 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/TransactionMethodInterceptor.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/TransactionMethodInterceptor.java
@@ -29,7 +29,10 @@
 import org.apache.log4j.Logger;
 import org.hibernate.FlushMode;
 import org.hibernate.Session;
+import org.hibernate.StaleStateException;
 import org.hibernate.Transaction;
+import org.hibernate.exception.GenericJDBCException;
+import org.hibernate.exception.LockAcquisitionException;
 import org.hibernate.resource.transaction.spi.TransactionStatus;
 
 import java.lang.reflect.Method;
@@ -64,13 +67,11 @@ public TransactionMethodInterceptor(Provider<Session> sessionProvider, MetricReg
 	@Override
 	public Object invoke(MethodInvocation invocation) throws Throwable
 	{
-		final Session session = sessionProvider.get();
-
 		Timer.Context callTimer = calls.time();
 
 		try
 		{
-			if (session.getTransaction().getStatus() == TransactionStatus.ACTIVE)
+			if (sessionProvider.get().getTransaction().getStatus() == TransactionStatus.ACTIVE)
 			{
 				// allow silent joining of enclosing transactional methods (NOTE: this ignores the current method's txn-al settings)
 				if (log.isTraceEnabled())
@@ -80,94 +81,142 @@ public Object invoke(MethodInvocation invocation) throws Throwable
 			}
 			else
 			{
-				if (log.isTraceEnabled())
-					log.trace("Creating new transaction to call " + invocation.getMethod().toGenericString());
-
 				final Transactional annotation = readAnnotation(invocation);
-				final boolean readOnly = annotation.readOnly();
 
-				// We are responsible for creating+closing the connection
-				Timer.Context ownerTimer = transactionStartedCalls.time();
-				try
+				// If we are allowed to auto-retry, first run the method with exception-catching retry behaviour
+				// After the max attempts for auto retry are exhausted we'll fall back on the non-retrying default behaviour
+				if (annotation.autoRetry())
 				{
-					// no transaction already started, so start one and enforce its semantics
-					final Transaction tx = session.beginTransaction();
+					// Try all but the last attempt
+					final int retries = Math.max(0, annotation.autoRetryCount() - 1);
 
-					if (readOnly)
-						makeReadOnly(session);
-					else
-						makeReadWrite(session);
+					// N.B. more aggressive than the @Retry annotation implements
+					long backoff = 1000;
+					final double multiplier = 1.5;
 
-					// Execute the method
-					final Object result;
-					try
+					for (int attempt = 0; attempt < retries; attempt++)
 					{
-						result = invocation.proceed();
-					}
-					catch (Exception e)
-					{
-						if (shouldRollback(annotation, e))
+						try
 						{
-							errorRollbacks.mark();
-
-							rollback(tx, e);
+							return createTransactionAndExecuteMethod(invocation, annotation);
 						}
-						else
+						catch (LockAcquisitionException | StaleStateException | GenericJDBCException e)
 						{
-							complete(tx, readOnly);
+							log.warn("@Transactional caught exception " + e.getClass().getSimpleName() + "; retrying...", e);
+
+							try
+							{
+								Thread.sleep(backoff);
+							}
+							catch (InterruptedException ie)
+							{
+								throw new RuntimeException("Interrupted while attempting a @Transactional retry!", ie);
+							}
+
+							// Increase backoff for the next exception
+							backoff *= multiplier;
 						}
-
-						// propagate the exception
-						throw e;
 					}
-					catch (Error e)
-					{
-						errorRollbacks.mark();
+				}
 
-						rollback(tx);
+				// Run without further retries
+				return createTransactionAndExecuteMethod(invocation, annotation);
+			}
+		}
+		finally
+		{
+			callTimer.stop();
+		}
+	}
 
-						// propagate the error
-						throw e;
-					}
 
-					// The method completed successfully, we can complete the the transaction
-					// we can't move into the above try block because it'll interfere with the do not move into try block as it interferes with the advised method's throwing semantics
-					RuntimeException commitException = null;
-					try
-					{
-						complete(tx, readOnly);
-					}
-					catch (RuntimeException e)
-					{
-						commitFailures.mark();
+	private Object createTransactionAndExecuteMethod(final MethodInvocation invocation,
+	                                                 final Transactional annotation) throws Throwable
+	{
+		if (log.isTraceEnabled())
+			log.trace("Creating new transaction to call " + invocation.getMethod().toGenericString());
 
-						rollback(tx);
 
-						commitException = e;
-					}
+		final boolean readOnly = annotation.readOnly();
 
-					// propagate anyway
-					if (commitException != null)
-						throw commitException;
+		// We are responsible for creating+closing the connection
+		Timer.Context ownerTimer = transactionStartedCalls.time();
 
-					// or return result
-					return result;
-				}
-				finally
+		final Session session = sessionProvider.get();
+		try
+		{
+			// no transaction already started, so start one and enforce its semantics
+			final Transaction tx = session.beginTransaction();
+
+			if (readOnly)
+				makeReadOnly(session);
+			else
+				makeReadWrite(session);
+
+			// Execute the method
+			final Object result;
+			try
+			{
+				result = invocation.proceed();
+			}
+			catch (Exception e)
+			{
+				if (shouldRollback(annotation, e))
 				{
-					ownerTimer.stop();
+					errorRollbacks.mark();
 
-					if (session.isOpen())
-					{
-						// Close the session
-						session.close();
-					}
+					rollback(tx, e);
+				}
+				else
+				{
+					complete(tx, readOnly);
 				}
+
+				// propagate the exception
+				throw e;
+			}
+			catch (Error e)
+			{
+				errorRollbacks.mark();
+
+				rollback(tx);
+
+				// propagate the error
+				throw e;
+			}
+
+			// The method completed successfully, we can complete the the transaction
+			// we can't move into the above try block because it'll interfere with the do not move into try block as it interferes with the advised method's throwing semantics
+			RuntimeException commitException = null;
+			try
+			{
+				complete(tx, readOnly);
+			}
+			catch (RuntimeException e)
+			{
+				commitFailures.mark();
+
+				rollback(tx);
+
+				commitException = e;
 			}
+
+			// propagate anyway
+			if (commitException != null)
+				throw commitException;
+
+			// or return result
+			return result;
 		}
 		finally
 		{
-			callTimer.stop();
+			ownerTimer.stop();
+
+			if (session.isOpen())
+			{
+				// Close the session
+				session.close();
+			}
 		}
 	}
 
@@ -180,6 +229,7 @@ public Object invoke(MethodInvocation invocation) throws Throwable
 	private void makeReadWrite(final Session session)
 	{
 		session.doWork(SetJDBCConnectionReadOnlyWork.READ_WRITE);
+		session.setHibernateFlushMode(FlushMode.AUTO);
 	}
 
 
@@ -191,7 +241,7 @@ private void makeReadWrite(final Session session)
 	private void makeReadOnly(final Session session)
 	{
 		session.setDefaultReadOnly(true);
-		session.setFlushMode(FlushMode.MANUAL);
+		session.setHibernateFlushMode(FlushMode.MANUAL);
 
 		// Make the Connection read only
 		session.doWork(SetJDBCConnectionReadOnlyWork.READ_ONLY);
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateObservingInterceptor.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateObservingInterceptor.java
new file mode 100755
index 0000000000..fa55de4198
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateObservingInterceptor.java
@@ -0,0 +1,134 @@
+package com.peterphi.std.guice.hibernate.module.logging;
+
+import com.google.inject.Singleton;
+import org.hibernate.EmptyInterceptor;
+import org.hibernate.Interceptor;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Consumer;
+
+/**
+ * Uses hibernate's {@link Interceptor} class behind the scenes to allow observers to hook into events (N.B. but not alter them)
+ */
+@Singleton
+public class HibernateObservingInterceptor
+{
+	private HibernateInterceptorImpl instance;
+
+	private ThreadLocal<List<Consumer<String>>> onPrepareStatementWatchers = new ThreadLocal<>();
+
+
+	public HibernateObservingInterceptor()
+	{
+		instance = new HibernateInterceptorImpl(this);
+	}
+
+
+	public Interceptor getInterceptor()
+	{
+		return instance;
+	}
+
+
+	private void onPrepareStatement(String sql)
+	{
+		final List<Consumer<String>> consumers = onPrepareStatementWatchers.get();
+
+		if (consumers != null)
+		{
+			for (Consumer<String> consumer : consumers)
+			{
+				consumer.accept(sql);
+			}
+		}
+	}
+
+
+	/**
+	 * Start a new logger which records SQL Prepared Statements created by Hibernate in this Thread. Must be closed (or treated as
+	 * autoclose)
+	 *
+	 * @return
+	 */
+	public HibernateSQLLogger startSQLLogger()
+	{
+		final HibernateSQLLogger logger = new HibernateSQLLogger(this);
+
+		logger.start();
+
+		return logger;
+	}
+
+
+	/**
+	 * Add an observer to <code>onPrepareStatement</code> calls made by the current Thread until {@link
+	 * #clearThreadLocalObservers()} is
+	 * called
+	 *
+	 * @param observer
+	 */
+	public void addThreadLocalSQLAuditor(Consumer<String> observer)
+	{
+		List<Consumer<String>> observers = onPrepareStatementWatchers.get();
+
+		if (observers == null)
+		{
+			observers = new CopyOnWriteArrayList<>();
+			onPrepareStatementWatchers.set(observers);
+		}
+
+		observers.add(observer);
+	}
+
+
+	/**
+	 * Remove a previously added observer for <code>onPrepareStatement</code> calls
+	 *
+	 * @param observer
+	 */
+	public void removeThreadLocalSQLAuditor(Consumer<String> observer)
+	{
+		List<Consumer<String>> observers = onPrepareStatementWatchers.get();
+
+		observers.remove(observer);
+
+		if (observers.isEmpty())
+			onPrepareStatementWatchers.remove();
+	}
+
+
+	/**
+	 * Clear any Thread Local observers
+	 */
+	public void clearThreadLocalObservers()
+	{
+		onPrepareStatementWatchers.remove();
+	}
+
+
+	/**
+	 * The hibernate interceptor; extends EmptyInterceptor because we are only observing
+	 */
+	private static class HibernateInterceptorImpl extends EmptyInterceptor
+	{
+		private final HibernateObservingInterceptor parent;
+
+
+		public HibernateInterceptorImpl(final HibernateObservingInterceptor parent)
+		{
+			this.parent = parent;
+		}
+
+
+		@Override
+		public String onPrepareStatement(String sql)
+		{
+			// Notify the observers
+			parent.onPrepareStatement(sql);
+
+			// Return unmodified
+			return sql;
+		}
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateSQLLogger.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateSQLLogger.java
new file mode 100755
index 0000000000..24b6d482fe
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/module/logging/HibernateSQLLogger.java
@@ -0,0 +1,67 @@
+package com.peterphi.std.guice.hibernate.module.logging;
+
+import org.apache.log4j.Logger;
+
+import java.io.Closeable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Consumer;
+
+/**
+ * Uses a Hibernate {@link org.hibernate.Interceptor} to intercept SQL Statement preparations as they happen on the local thread
+ */
+public class HibernateSQLLogger implements Closeable, AutoCloseable, Consumer<String>
+{
+	private static final Logger log = Logger.getLogger(HibernateSQLLogger.class);
+
+	private final List<String> statements = new ArrayList<>(0);
+	private final HibernateObservingInterceptor interceptor;
+
+
+	public HibernateSQLLogger(HibernateObservingInterceptor interceptor)
+	{
+		this.interceptor = interceptor;
+	}
+
+
+	public void start()
+	{
+		interceptor.addThreadLocalSQLAuditor(this);
+	}
+
+
+	@Override
+	public void accept(final String sql)
+	{
+		if (log.isTraceEnabled())
+			log.trace("Hibernate executing SQL: " + sql);
+
+		synchronized (statements)
+		{
+			statements.add(sql);
+		}
+	}
+
+
+	@Override
+	public void close()
+	{
+		interceptor.removeThreadLocalSQLAuditor(this);
+	}
+
+
+	/**
+	 * Return a read-only copy of the statements prepared since this logger was started and before the logger was stopped; if the
+	 * logger has not yet been stopped then it will return the statements prepared thus far
+	 *
+	 * @return
+	 */
+	public List<String> getAllStatements()
+	{
+		synchronized (statements)
+		{
+			return Collections.unmodifiableList(new ArrayList<>(statements));
+		}
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/DateUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/DateUserType.java
index 55b788e2e4..df8c4652a8 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/DateUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/DateUserType.java
@@ -1,7 +1,7 @@
 package com.peterphi.std.guice.hibernate.usertype;
 
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 import org.hibernate.usertype.UserVersionType;
 
@@ -60,7 +60,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public Object nullSafeGet(final ResultSet resultSet,
 	                          final String[] names,
-	                          final SessionImplementor session,
+	                          final SharedSessionContractImplementor session,
 	                          final Object owner) throws HibernateException, SQLException
 	{
 		final long timestamp = resultSet.getLong(names[0]);
@@ -76,12 +76,16 @@ public Object nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
 			statement.setNull(index, Types.BIGINT);
 		}
+		else if (value instanceof Long)
+		{
+			statement.setLong(index, (Long) value);
+		}
 		else
 		{
 			final long timestamp = ((Date) value).getTime();
@@ -130,14 +134,14 @@ public Object replace(final Object original, final Object target, final Object o
 
 
 	@Override
-	public Date seed(final SessionImplementor session)
+	public Date seed(final SharedSessionContractImplementor session)
 	{
 		return new Date();
 	}
 
 
 	@Override
-	public Date next(final Object current, final SessionImplementor session)
+	public Date next(final Object current, final SharedSessionContractImplementor session)
 	{
 		return seed(session);
 	}
@@ -148,4 +152,5 @@ public int compare(final Object a, final Object b)
 	{
 		return ((Date) a).compareTo((Date) b);
 	}
+
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaDateTimeUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaDateTimeUserType.java
index 29727f133c..eccbaf1c30 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaDateTimeUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaDateTimeUserType.java
@@ -1,7 +1,7 @@
 package com.peterphi.std.guice.hibernate.usertype;
 
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 import org.hibernate.usertype.UserVersionType;
 import org.joda.time.DateTime;
@@ -65,7 +65,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public DateTime nullSafeGet(final ResultSet resultSet,
 	                            final String[] names,
-	                            final SessionImplementor session,
+	                            final SharedSessionContractImplementor session,
 	                            final Object owner) throws HibernateException, SQLException
 	{
 		final long encoded = resultSet.getLong(names[0]);
@@ -83,12 +83,16 @@ public DateTime nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
 			statement.setNull(index, Types.BIGINT);
 		}
+		else if (value instanceof Long)
+		{
+			statement.setLong(index, (Long) value);
+		}
 		else
 		{
 			final long millis = ((DateTime) value).getMillis();
@@ -140,14 +144,14 @@ public DateTime replace(final Object original, final Object target, final Object
 
 
 	@Override
-	public DateTime seed(final SessionImplementor session)
+	public DateTime seed(final SharedSessionContractImplementor session)
 	{
 		return DateTime.now();
 	}
 
 
 	@Override
-	public DateTime next(final Object current, final SessionImplementor session)
+	public DateTime next(final Object current, final SharedSessionContractImplementor session)
 	{
 		return seed(session);
 	}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaLocalDateUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaLocalDateUserType.java
index b78705c5f2..2519fed765 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaLocalDateUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/JodaLocalDateUserType.java
@@ -1,7 +1,7 @@
 package com.peterphi.std.guice.hibernate.usertype;
 
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 import org.joda.time.LocalDate;
 
@@ -61,7 +61,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public LocalDate nullSafeGet(final ResultSet resultSet,
 	                             final String[] names,
-	                             final SessionImplementor session,
+	                             final SharedSessionContractImplementor session,
 	                             final Object owner) throws HibernateException, SQLException
 	{
 		final java.sql.Date encoded = resultSet.getDate(names[0]);
@@ -79,12 +79,16 @@ public LocalDate nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
 			statement.setNull(index, Types.DATE);
 		}
+		else if (value instanceof Long)
+		{
+			statement.setLong(index, (Long) value);
+		}
 		else
 		{
 			final long timestamp = ((LocalDate) value).toDateTimeAtStartOfDay().getMillis();
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/SampleCountUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/SampleCountUserType.java
index cf8774c458..0a878194c8 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/SampleCountUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/SampleCountUserType.java
@@ -3,7 +3,7 @@
 import com.peterphi.std.types.SampleCount;
 import com.peterphi.std.types.Timecode;
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 
 import java.io.Serializable;
@@ -60,7 +60,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public SampleCount nullSafeGet(final ResultSet resultSet,
 	                               final String[] names,
-	                               final SessionImplementor session,
+	                               final SharedSessionContractImplementor session,
 	                               final Object owner) throws HibernateException, SQLException
 	{
 		final String encoded = resultSet.getString(names[0]);
@@ -81,7 +81,7 @@ public SampleCount nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/StringDateTimeUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/StringDateTimeUserType.java
index 148ca17b9c..fb1ac33009 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/StringDateTimeUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/StringDateTimeUserType.java
@@ -1,7 +1,7 @@
 package com.peterphi.std.guice.hibernate.usertype;
 
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 import org.hibernate.usertype.UserVersionType;
 import org.joda.time.DateTime;
@@ -65,7 +65,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public DateTime nullSafeGet(final ResultSet resultSet,
 	                            final String[] names,
-	                            final SessionImplementor session,
+	                            final SharedSessionContractImplementor session,
 	                            final Object owner) throws HibernateException, SQLException
 	{
 		final String encoded = resultSet.getString(names[0]);
@@ -81,7 +81,7 @@ public DateTime nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
@@ -138,14 +138,14 @@ public DateTime replace(final Object original, final Object target, final Object
 
 
 	@Override
-	public DateTime seed(final SessionImplementor session)
+	public DateTime seed(final SharedSessionContractImplementor session)
 	{
 		return DateTime.now();
 	}
 
 
 	@Override
-	public DateTime next(final Object current, final SessionImplementor session)
+	public DateTime next(final Object current, final SharedSessionContractImplementor session)
 	{
 		return seed(session);
 	}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/TimecodeUserType.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/TimecodeUserType.java
index 244da0c043..13ecc4c41b 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/TimecodeUserType.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/usertype/TimecodeUserType.java
@@ -2,7 +2,7 @@
 
 import com.peterphi.std.types.Timecode;
 import org.hibernate.HibernateException;
-import org.hibernate.engine.spi.SessionImplementor;
+import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.hibernate.usertype.UserType;
 
 import java.io.Serializable;
@@ -60,7 +60,7 @@ public int hashCode(final Object x) throws HibernateException
 	@Override
 	public Timecode nullSafeGet(final ResultSet resultSet,
 	                            final String[] names,
-	                            final SessionImplementor session,
+	                            final SharedSessionContractImplementor session,
 	                            final Object owner) throws HibernateException, SQLException
 	{
 		final String encoded = resultSet.getString(names[0]);
@@ -76,7 +76,7 @@ public Timecode nullSafeGet(final ResultSet resultSet,
 	public void nullSafeSet(final PreparedStatement statement,
 	                        final Object value,
 	                        final int index,
-	                        final SessionImplementor session) throws HibernateException, SQLException
+	                        final SharedSessionContractImplementor session) throws HibernateException, SQLException
 	{
 		if (value == null)
 		{
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/ConstrainedResultSet.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/ConstrainedResultSet.java
index 53728aaf34..f47f60a1dd 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/ConstrainedResultSet.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/ConstrainedResultSet.java
@@ -2,12 +2,14 @@
 
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
 
+import java.util.Collections;
 import java.util.List;
 
 public class ConstrainedResultSet<T>
 {
 	protected /*final*/ ResultSetConstraint constraint;
 	protected /*final*/ WebQuery query;
+	protected List<String> sql = Collections.emptyList();
 	protected final List<T> list;
 
 	protected Long total;
@@ -92,4 +94,50 @@ public void setTotal(final Long total)
 	{
 		this.total = total;
 	}
+
+
+	public List<String> getSql()
+	{
+		return sql;
+	}
+
+
+	public void setSql(final List<String> sql)
+	{
+		this.sql = sql;
+	}
+
+
+	/**
+	 * When exactly one result is expected, returns that result or throws {@link IllegalArgumentException} if too many or too few
+	 * results were returned
+	 *
+	 * @return
+	 */
+	public T one()
+	{
+		final T obj = uniqueResult();
+
+		if (obj != null)
+			return obj;
+		else
+			throw new IllegalArgumentException("Asked for single result but resultset contained 0 results!");
+	}
+
+
+	/**
+	 * When a single result is expected, returns that result (or null if no results were returned). Throws an {@link
+	 * IllegalArgumentException} if more than one results were returned
+	 *
+	 * @return
+	 */
+	public T uniqueResult()
+	{
+		if (list == null || list.size() == 0)
+			return null;
+		else if (list.size() == 1)
+			return list.get(0);
+		else
+			throw new IllegalArgumentException("Asked for unique result but resultset contained " + list.size() + " results!");
+	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/HQLEncodingContext.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/HQLEncodingContext.java
new file mode 100755
index 0000000000..af2da09d28
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/HQLEncodingContext.java
@@ -0,0 +1,6 @@
+package com.peterphi.std.guice.hibernate.webquery;
+
+public interface HQLEncodingContext
+{
+	String createPropertyPlaceholder(final Object value);
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLBuilder.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLBuilder.java
new file mode 100755
index 0000000000..9f818e8354
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLBuilder.java
@@ -0,0 +1,620 @@
+package com.peterphi.std.guice.hibernate.webquery.impl;
+
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
+import com.peterphi.std.guice.hibernate.webquery.impl.functions.QFunctionFactory;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WQConstraint;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WQConstraintLine;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WQGroup;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WQOrder;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
+import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
+import org.hibernate.Criteria;
+import org.hibernate.Query;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public class HQLBuilder implements HQLEncodingContext
+{
+	public static final String ROOT_OBJECT_ALIAS = "mobj";
+
+	private static final Logger log = Logger.getLogger(HQLBuilder.class);
+
+	private QEntity entity;
+
+	/**
+	 * The joins for constraining things
+	 * N.B. Uses {@link LinkedHashMap} to maintain the insertion order (because joins can depend on subsequent joins)
+	 */
+	private final LinkedHashMap<QPath, HQLJoin> joins = new LinkedHashMap<>();
+	/**
+	 * The joins for the purpose of eager fetching relationships
+	 * N.B. Uses {@link LinkedHashMap} to maintain the insertion order (because joins can depend on subsequent joins)
+	 */
+	private final LinkedHashMap<QPath, HQLJoin> fetchJoins = new LinkedHashMap<>();
+	private final List<HQLFragment> conditions = new ArrayList<>();
+	private final List<HQLFragment> orders = new ArrayList<>();
+	private final List<HQLFragment> groupings = new ArrayList<>();
+
+	/**
+	 * Holds all the property aliases we have generated for fragments to use and the values that have been aliased to them
+	 */
+	private final Map<String, Object> aliases = new HashMap<>();
+
+	private final Map<String, String> expansions = new HashMap<>();
+
+	/**
+	 * A list of names for columns referenced by ORDER BY statements, to work around a bug in certain databases (primarily HSQLDB
+	 * in our experience) that don't permit a column to be referenced in an ORDER BY unless it is also referenced in a SELECT
+	 */
+	private final List<String> orderColumns = new ArrayList<>();
+
+	private Integer offset = 0;
+	private Integer limit = 200;
+
+	private HQLProjection projection = HQLProjection.ENTITIES;
+	private HQLFragment customHqlProjection = null;
+
+
+	public HQLBuilder(final QEntity entity)
+	{
+		this.entity = entity;
+
+		// Register the default {alias} fragment expansion (matching Hibernate's Criteria SQL fragment)
+		this.expansions.put("{alias}", ROOT_OBJECT_ALIAS);
+	}
+
+
+	public Query toHQL(Function<String, Query> supplier)
+	{
+		final String hql = toHQLString();
+
+		if (log.isTraceEnabled())
+			log.trace("Execute HQL: " + hql + " with vars: " + this.aliases);
+
+		try
+		{
+			final Query query = supplier.apply(hql);
+
+			configure(query);
+
+			return query;
+		}
+		catch (Throwable t)
+		{
+			log.error("Error preparing HQL statement '" + hql + "'", t);
+			throw t;
+		}
+	}
+
+
+	public String toHQLString()
+	{
+		StringBuilder sb = new StringBuilder();
+
+		// Add the SELECT
+		switch (projection)
+		{
+			case ENTITIES:
+			{
+				sb.append("SELECT {alias} ");
+
+				break;
+			}
+			case IDS:
+				final String idColumn = "{alias}.id";
+
+				if (orderColumns.size() == 0)
+				{
+					// No ORDER BY
+					// We can use DISTINCT here and know that the db will only return 1 value for each PK
+					sb.append("SELECT DISTINCT {alias}.id ");
+				}
+				else
+				{
+					// N.B. we use DISTINCT here but because we're selecting the ORDER BY columns
+					//      all the DISTINCT does is reduce the number of duplicates we'll get
+					sb.append("SELECT DISTINCT ");
+					sb.append(StringUtils.join(orderColumns, ','));
+					sb.append(", {alias}.id ");
+				}
+
+				break;
+			case COUNT:
+				sb.append("SELECT COUNT(DISTINCT {alias}.id) ");
+
+				// Pagination and ordering are meaningless for a COUNT(distinct id) query
+				clearPagination();
+				clearOrder();
+
+				break;
+			case CUSTOM_HQL:
+				sb.append(customHqlProjection.toHsqlString(expansions));
+
+				sb.append(' '); // Make sure there's a space after the user-supplied expression for chaining further statements
+
+				break;
+			default:
+				throw new IllegalArgumentException("Unknown projection: " + projection);
+		}
+
+		// List the primary table and primary entity alias
+		sb
+				.append("FROM ")
+				.append(entity.getEntityClass().getName())
+				.append(" {alias} "); // make sure we end on a space for chaining further statements
+
+
+		// Append the JOIN statements
+		{
+			if (!fetchJoins.isEmpty())
+			{
+				sb.append(fetchJoins
+						          .values()
+						          .stream()
+						          .map(c -> c.getJoinExpr().toHsqlString(expansions))
+						          .collect(Collectors.joining(" ")));
+				sb.append(' '); // make sure we end on a space for chaining further statements
+			}
+			
+			if (!joins.isEmpty())
+			{
+				sb.append(joins
+						          .values()
+						          .stream()
+						          .map(c -> c.getJoinExpr().toHsqlString(expansions))
+						          .collect(Collectors.joining(" ")));
+				sb.append(' '); // make sure we end on a space for chaining further statements
+			}
+		}
+
+		// Append the conditions
+		if (conditions.size() > 0)
+		{
+			sb.append("WHERE ");
+
+			if (conditions.size() > 0)
+			{
+				sb.append(conditions.stream().map(c -> c.toHsqlString(expansions)).collect(Collectors.joining(" AND ")));
+				sb.append(' '); // make sure we end on a space for chaining further statements
+			}
+		}
+
+		if (orders.size() > 0)
+		{
+			sb.append("ORDER BY ");
+
+			sb.append(orders.stream().map(c -> c.toHsqlString(expansions)).collect(Collectors.joining(", ")));
+
+			sb.append(' '); // make sure we end on a space for chaining further statements
+		}
+
+		if (groupings.size() > 0)
+		{
+			sb.append("GROUP BY ");
+
+			sb.append(groupings.stream().map(c -> c.toHsqlString(expansions)).collect(Collectors.joining(", ")));
+
+			sb.append(' '); // make sure we end on a space for chaining further statements
+		}
+
+		return HQLFragment.replace(sb.toString(), this.expansions);
+	}
+
+
+	public void configure(final Query query)
+	{
+		for (Map.Entry<String, Object> entry : aliases.entrySet())
+		{
+			final Object val = entry.getValue();
+
+			if (val instanceof Collection)
+				query.setParameterList(entry.getKey(), (Collection) val);
+			else
+				query.setParameter(entry.getKey(), val);
+		}
+
+		if (this.orderColumns.size() > 0 && (projection == HQLProjection.ENTITIES || projection == HQLProjection.IDS))
+			query.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
+		else if (projection == HQLProjection.ENTITIES && (fetchJoins.size() > 0 || joins.size() > 0))
+			query.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY); // If there are joins then we could end up with multiple root entities being returned (see HqlChildCountTest.testChildCriteria for example)
+
+		if (limit != null && limit > 0)
+			query.setMaxResults(limit);
+		if (offset != null && offset > 0)
+			query.setFirstResult(offset);
+	}
+
+
+	public HQLBuilder addClassConstraint(final List<String> values)
+	{
+		final List<Class<?>> classes = getClassesByDiscriminators(values);
+
+		QEntity commonParentClass = entity.getCommonSubclass(values);
+
+		if (commonParentClass != entity)
+		{
+			// All the discriminators share a common subclass, so allow the query to reference columns of that subclass
+			entity = commonParentClass;
+		}
+		else
+		{
+			// Multiple classes,
+			HQLFragment fragment = new HQLFragment("TYPE({alias}) IN " + createPropertyPlaceholder(classes));
+
+			this.conditions.add(fragment);
+		}
+
+		return this;
+	}
+
+
+	/**
+	 * Translates the set of string discriminators into entity classes
+	 *
+	 * @return
+	 */
+	private List<Class<?>> getClassesByDiscriminators(Collection<String> discriminators)
+	{
+		Map<String, Class<?>> entitiesByName = new HashMap<>();
+
+		// Prepare a Map of discriminator name -> entity class
+		for (QEntity child : entity.getSubEntities())
+		{
+			entitiesByName.put(child.getDiscriminatorValue(), child.getEntityClass());
+		}
+
+		// If the root class isn't abstract then add it to the list of possible discriminators too
+		if (!entity.isEntityClassAbstract())
+			entitiesByName.put(entity.getDiscriminatorValue(), entity.getEntityClass());
+
+		// Translate the discriminator string values to classes
+		List<Class<?>> classes = new ArrayList<>(discriminators.size());
+		for (String discriminator : discriminators)
+		{
+			final Class<?> clazz = entitiesByName.get(discriminator);
+
+			if (clazz != null)
+				classes.add(clazz);
+			else
+				throw new IllegalArgumentException("Invalid class discriminator '" +
+				                                   discriminator +
+				                                   "', expected one of: " +
+				                                   entitiesByName.keySet());
+		}
+
+		return classes;
+	}
+
+
+	public HQLBuilder clearPagination()
+	{
+		this.offset = null;
+		this.limit = null;
+
+		return this;
+	}
+
+
+	public HQLBuilder clearOrder()
+	{
+		this.orders.clear();
+		this.orderColumns.clear();
+
+		return this;
+	}
+
+
+	public HQLBuilder limit(Integer limit)
+	{
+		this.limit = limit;
+
+		return this;
+	}
+
+
+	public HQLBuilder offset(Integer offset)
+	{
+		this.offset = offset;
+
+		return this;
+	}
+
+
+	public void addConstraints(final List<WQConstraintLine> constraints)
+	{
+		for (QFunction function : parseConstraint(constraints))
+		{
+			conditions.add(function.encode(this));
+		}
+	}
+
+
+	private List<QFunction> parseConstraint(List<WQConstraintLine> constraints)
+	{
+		List<QFunction> list = new ArrayList<>(constraints.size());
+
+		for (WQConstraintLine line : constraints)
+		{
+			if (line instanceof WQConstraint)
+				list.add(parseConstraint((WQConstraint) line));
+			else
+				list.add(parseConstraint((WQGroup) line));
+		}
+
+		return list;
+	}
+
+
+	private QFunction parseConstraint(WQConstraint constraint)
+	{
+		return QFunctionFactory.getInstance(getProperty(constraint.field),
+		                                    constraint.function,
+		                                    constraint.value,
+		                                    constraint.value2,
+		                                    this :: getProperty);
+	}
+
+
+	private QFunction parseConstraint(WQGroup group)
+	{
+		List<QFunction> contents = parseConstraint(group.constraints);
+
+		switch (group.operator)
+		{
+			case AND:
+				return QFunctionFactory.and(contents);
+			case OR:
+				return QFunctionFactory.or(contents);
+			default:
+				throw new IllegalArgumentException("Unknown group operator: " + group.operator);
+		}
+	}
+
+
+	public HQLBuilder addOrder(QPropertyRef property, boolean asc)
+	{
+		final String column = property.toHqlPath();
+
+		if (asc)
+			orders.add(new HQLFragment(column + " ASC"));
+		else
+			orders.add(new HQLFragment(column + " DESC"));
+
+		this.orderColumns.add(column);
+
+		return this;
+	}
+
+
+	public HQLBuilder addOrderCustomHQL(HQLFragment... orderings)
+	{
+		Collections.addAll(orders, orderings);
+
+		return this;
+	}
+
+
+	public HQLBuilder addFragmentExpansion(final String expansionAlias, HQLFragment fragment)
+	{
+		final String hql = fragment.toHsqlString(this.expansions);
+
+		expansions.put("{" + expansionAlias + "}", hql);
+
+		return this;
+	}
+
+
+	public HQLBuilder addCustomGrouping(HQLFragment grouping)
+	{
+		this.groupings.add(grouping);
+
+		return this;
+	}
+
+
+	public QPropertyRef getProperty(final String path)
+	{
+		return new QPropertyRef(getPath(path, true));
+	}
+
+
+	/**
+	 * Creates a fetch join to the specified path, creating any necessary bridging fetch joins
+	 *
+	 * @param path
+	 */
+	public void createFetchJoin(final String path)
+	{
+		getPath(path, false);
+	}
+
+
+	/**
+	 * @param path
+	 * @param forConstraint
+	 * 		if true, sets up a JOIN that could be used for a constraint, otherwise sets up a join that is only useful for fetching
+	 * 		back data
+	 *
+	 * @return
+	 */
+	public QPath getPath(final String path, final boolean forConstraint)
+	{
+		final LinkedList<String> segments = new LinkedList<>(Arrays.asList(StringUtils.split(path, '.')));
+
+		QPath builtPath = null;
+
+		while (segments.size() > 0)
+		{
+			builtPath = QPath.parse(entity, builtPath, segments);
+
+			if (builtPath.getRelation() != null) // && builtPath.getRelation().isCollection())
+			{
+				final String alias = forConstraint ? createJoin(builtPath) : createFetchJoin(builtPath);
+
+				builtPath.setHsqlAlias(alias);
+			}
+		}
+
+		return builtPath;
+	}
+
+
+	private String createFetchJoin(final QPath path)
+	{
+		HQLJoin join = fetchJoins.get(path);
+
+		// Lazy-create the join if necessary
+		if (join == null)
+		{
+			final String alias = "fj" + fetchJoins.size();
+
+			join = new HQLJoin(path, alias, true);
+
+			fetchJoins.put(path, join);
+		}
+
+		return join.getAlias();
+	}
+
+
+	private String createJoin(final QPath path)
+	{
+		HQLJoin join = joins.get(path);
+
+		// Lazy-create the join if necessary
+		if (join == null)
+		{
+			final String alias = "j" + joins.size();
+
+			join = new HQLJoin(path, alias, false);
+
+			joins.put(path, join);
+		}
+
+		return join.getAlias();
+	}
+
+
+	@Override
+	public String createPropertyPlaceholder(final Object value)
+	{
+		final String name = "v" + aliases.size();
+
+		aliases.put(name, value);
+
+		return ":" + name;
+	}
+
+
+	public void addWebQuery(final WebQuery query)
+	{
+		// First, add the subclass discriminators
+		// This allows the query constraints to reference properties of the subclass (if there's a single subclass / they are all descended from the same class)
+		if (StringUtils.isNotEmpty(query.constraints.subclass))
+			addClassConstraint(Arrays.asList(query.constraints.subclass.split(",")));
+
+		addConstraints(query.constraints.constraints);
+
+		offset(query.getOffset());
+		limit(query.getLimit());
+
+		// Create fetch joins as requested by the user
+		if (StringUtils.isNotBlank(query.dbfetch))
+		{
+			for (String path : StringUtils.split(query.dbfetch, ','))
+			{
+				createFetchJoin(path);
+			}
+		}
+
+		if (query.orderings.size() > 0)
+		{
+			for (WQOrder ordering : query.orderings)
+			{
+				addOrder(getProperty(ordering.field), ordering.isAsc());
+			}
+		}
+	}
+
+
+	public HQLProjection getProjection()
+	{
+		return projection;
+	}
+
+
+	/**
+	 * Sets the projection to one of a set of predefined options. Note, you may not supply {@link HQLProjection#CUSTOM_HQL} to
+	 * this method, please use {@link #setProjectionCustomHQL(HQLFragment)} instead.
+	 *
+	 * @param projection
+	 */
+	public void setProjection(final HQLProjection projection)
+	{
+		if (projection == HQLProjection.CUSTOM_HQL)
+			throw new IllegalArgumentException("Must use setHqlProjection to set up a custom HQL projection");
+
+		this.projection = projection;
+	}
+
+
+	/**
+	 * Sets the projection to a custom fragment of HQL
+	 *
+	 * @param fragment
+	 */
+	public void setProjectionCustomHQL(final HQLFragment fragment)
+	{
+		this.projection = HQLProjection.CUSTOM_HQL;
+		this.customHqlProjection = fragment;
+	}
+
+
+	public HQLBuilder clearConstraints()
+	{
+		this.conditions.clear();
+		this.aliases.clear();
+
+		return this;
+	}
+
+
+	public void addCustomHQLConstraint(HQLFragment fragment)
+	{
+		if (fragment != null)
+			this.conditions.add(fragment);
+	}
+
+
+	/**
+	 * Add a constraint that will always fail, meaning the query will return no results
+	 */
+	public void addAlwaysFalseConstraint()
+	{
+		addCustomHQLConstraint(new HQLFragment("(0=1)"));
+	}
+
+
+	/**
+	 * Add a constraint that the id must be one of a collection of provided values
+	 *
+	 * @param ids
+	 * @param <ID>
+	 */
+	public <ID extends Serializable> void addIdInConstraint(final Collection<ID> ids)
+	{
+		addCustomHQLConstraint(new HQLFragment("{alias}.id IN " + createPropertyPlaceholder(ids)));
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLFragment.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLFragment.java
new file mode 100755
index 0000000000..ea6d69a20c
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLFragment.java
@@ -0,0 +1,53 @@
+package com.peterphi.std.guice.hibernate.webquery.impl;
+
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+public class HQLFragment
+{
+	private final String expr;
+
+
+	public HQLFragment(final String expr)
+	{
+		this.expr = expr;
+	}
+
+
+	public String toHsqlString(final Map<String, String> expansions)
+	{
+		return replace(expr, expansions);
+	}
+
+
+	public static HQLFragment combine(final List<HQLFragment> fragments,
+	                                  final String prefix,
+	                                  final String separator,
+	                                  final String suffix)
+	{
+		// Combine all the expressions
+		final String expr = prefix +
+		                    fragments
+				                    .stream()
+				                    .filter(f -> f != null)
+				                    .map(f -> f.expr)
+				                    .filter(f -> f != null)
+				                    .collect(Collectors.joining(separator)) + suffix;
+
+		return new HQLFragment(expr);
+	}
+
+
+	public static String replace(String hql, final Map<String, String> expansions)
+	{
+		// If there are fragments to expand, expand them
+		if (hql.indexOf('{') != -1)
+			for (Map.Entry<String, String> expansion : expansions.entrySet())
+			{
+				hql = hql.replace(expansion.getKey(), expansion.getValue());
+			}
+
+		return hql;
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLJoin.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLJoin.java
new file mode 100755
index 0000000000..a295a987f7
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLJoin.java
@@ -0,0 +1,38 @@
+package com.peterphi.std.guice.hibernate.webquery.impl;
+
+class HQLJoin
+{
+	private final QPath path;
+	private final String alias;
+	private final HQLFragment fragment;
+
+
+	public HQLJoin(final QPath path, final String alias, final boolean fetch)
+	{
+		this.path = path;
+		this.alias = alias;
+
+		if (fetch)
+			this.fragment = new HQLFragment("LEFT OUTER JOIN FETCH " + path.toHsqlPath() + " " + alias);
+		else
+			this.fragment = new HQLFragment("LEFT OUTER JOIN " + path.toHsqlPath() + " " + alias);
+	}
+
+
+	public QPath getPath()
+	{
+		return path;
+	}
+
+
+	public String getAlias()
+	{
+		return alias;
+	}
+
+
+	public HQLFragment getJoinExpr()
+	{
+		return fragment;
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLProjection.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLProjection.java
new file mode 100755
index 0000000000..40c9435b58
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/HQLProjection.java
@@ -0,0 +1,9 @@
+package com.peterphi.std.guice.hibernate.webquery.impl;
+
+public enum HQLProjection
+{
+	IDS,
+	COUNT,
+	ENTITIES,
+	CUSTOM_HQL;
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QCriteriaBuilder.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QCriteriaBuilder.java
deleted file mode 100755
index e30f108333..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QCriteriaBuilder.java
+++ /dev/null
@@ -1,295 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.functions.QFunctionFactory;
-import com.peterphi.std.guice.restclient.jaxb.webquery.WQConstraint;
-import com.peterphi.std.guice.restclient.jaxb.webquery.WQConstraintLine;
-import com.peterphi.std.guice.restclient.jaxb.webquery.WQGroup;
-import org.hibernate.Criteria;
-import org.hibernate.criterion.Disjunction;
-import org.hibernate.criterion.Restrictions;
-import org.hibernate.sql.JoinType;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Builds a Hibernate Criteria
- */
-public class QCriteriaBuilder
-{
-	private final QEntity entity;
-
-	private final Map<QPath, QJoin> joins = new HashMap<>();
-	private final List<QFunction> constraints = new ArrayList<>();
-	private final List<QOrder> order = new ArrayList<>();
-
-	private final List<String> discriminators = new ArrayList<>();
-
-	private int offset = 0;
-	private int limit = 200;
-
-
-	public QCriteriaBuilder(final QEntity entity)
-	{
-		this.entity = entity;
-	}
-
-
-	public QCriteriaBuilder limit(int limit)
-	{
-		this.limit = limit;
-
-		return this;
-	}
-
-
-	public QCriteriaBuilder offset(int offset)
-	{
-		this.offset = offset;
-
-		return this;
-	}
-
-
-	public void addConstraints(final List<WQConstraintLine> constraints)
-	{
-		this.constraints.addAll(parseConstraint(constraints));
-	}
-
-
-	private List<QFunction> parseConstraint(List<WQConstraintLine> constraints)
-	{
-		List<QFunction> list = new ArrayList<>(constraints.size());
-
-		for (WQConstraintLine line : constraints)
-		{
-			if (line instanceof WQConstraint)
-				list.add(parseConstraint((WQConstraint) line));
-			else
-				list.add(parseConstraint((WQGroup) line));
-		}
-
-		return list;
-	}
-
-
-	private QFunction parseConstraint(WQConstraint constraint)
-	{
-		return QFunctionFactory.getInstance(getProperty(constraint.field),
-		                                    constraint.function,
-		                                    constraint.value,
-		                                    constraint.value2,
-		                                    this :: getProperty);
-	}
-
-
-	private QFunction parseConstraint(WQGroup group)
-	{
-		List<QFunction> contents = parseConstraint(group.constraints);
-
-		switch (group.operator)
-		{
-			case AND:
-				return QFunctionFactory.and(contents);
-			case OR:
-				return QFunctionFactory.or(contents);
-			default:
-				throw new IllegalArgumentException("Unknown group operator: " + group.operator);
-		}
-	}
-
-
-	public void addClass(final List<String> values)
-	{
-		this.discriminators.addAll(values);
-	}
-
-
-	/**
-	 * Append the Criteria currently described by this object to the provided Criteria<br />
-	 * This method will also set the FirstResult and the MaxResults properties of the Criteria.
-	 *
-	 * @param criteria
-	 * 		the base criteria to use
-	 */
-	public void appendTo(Criteria criteria)
-	{
-		appendTo(criteria, true, true);
-	}
-
-
-	/**
-	 * @param criteria
-	 * 		the base criteria to use
-	 * @param includeConstraints
-	 * 		if true, the regular criteria will be added to the query (all non-discriminator constraints)
-	 * @param includePagination
-	 * 		if true, LIMIT and OFFSET will be set in the query
-	 */
-	public void appendTo(Criteria criteria, boolean includeConstraints, boolean includePagination)
-	{
-		appendJoins(criteria);
-
-		appendDiscriminators(criteria);
-
-		if (includeConstraints)
-		{
-			// Add the constraints
-			for (QFunction constraint : constraints)
-				criteria.add(constraint.encode());
-		}
-
-		appendOrder(criteria);
-
-		if (includePagination)
-		{
-			criteria.setFirstResult(offset);
-			criteria.setMaxResults(limit);
-		}
-	}
-
-
-	public void appendDiscriminators(Criteria criteria)
-	{
-		// Add the special discriminator value constraint
-		if (!discriminators.isEmpty())
-		{
-			// Translate the discriminators into classes
-			final List<Class<?>> classes = getClassesByDiscriminators(discriminators);
-
-			if (classes.size() == 1)
-			{
-				criteria.add(Restrictions.eq("class", classes.get(0)));
-			}
-			else
-			{
-				final Disjunction or = Restrictions.disjunction();
-
-				for (Class<?> clazz : classes)
-					or.add(Restrictions.eq("class", clazz));
-
-				criteria.add(or);
-			}
-		}
-	}
-
-
-	public void appendJoins(Criteria criteria)
-	{
-		// Set up the joins
-		for (QJoin join : joins.values())
-			criteria.createAlias(join.getPath().toString(), join.getAlias(), JoinType.LEFT_OUTER_JOIN);
-	}
-
-
-	public void appendOrder(Criteria criteria)
-	{
-		// Add the order
-		for (QOrder order : this.order)
-			criteria.addOrder(order.encode());
-	}
-
-
-	/**
-	 * Translates the set of string discriminators into entity classes
-	 *
-	 * @return
-	 */
-	private List<Class<?>> getClassesByDiscriminators(Collection<String> discriminators)
-	{
-		Map<String, Class<?>> entitiesByName = new HashMap<>();
-
-		// Prepare a Map of discriminator name -> entity class
-		for (QEntity child : entity.getSubEntities())
-		{
-			entitiesByName.put(child.getDiscriminatorValue(), child.getEntityClass());
-		}
-
-		// If the root class isn't abstract then add it to the list of possible discriminators too
-		if (!entity.isEntityClassAbstract())
-			entitiesByName.put(entity.getDiscriminatorValue(), entity.getEntityClass());
-
-		// Translate the discriminator string values to classes
-		List<Class<?>> classes = new ArrayList<>(discriminators.size());
-		for (String discriminator : discriminators)
-		{
-			final Class<?> clazz = entitiesByName.get(discriminator);
-
-			if (clazz != null)
-				classes.add(clazz);
-			else
-				throw new IllegalArgumentException("Invalid class discriminator '" +
-				                                   discriminator +
-				                                   "', expected one of: " +
-				                                   entitiesByName.keySet());
-		}
-
-		return classes;
-	}
-
-
-	public QCriteriaBuilder addOrder(QPropertyRef property, boolean asc)
-	{
-		if (asc)
-			order.add(new QOrder(property, true));
-		else
-			order.add(new QOrder(property, false));
-
-		return this;
-	}
-
-
-	public QPropertyRef getProperty(String path)
-	{
-		try
-		{
-			QPropertyPath propertyPath = entity.getPath(path).getPropertyPath();
-
-			final QJoin join = join(propertyPath.getPath());
-			final QProperty property = propertyPath.getProperty();
-
-			return new QPropertyRef(join, property);
-		}
-		catch (Exception e)
-		{
-			throw new IllegalArgumentException("Error building path for property " + path + ": " + e.getMessage(), e);
-		}
-	}
-
-
-	public QJoin join(QPath path)
-	{
-		if (path == null)
-			return null;
-
-		final QJoin parent;
-
-		if (joins.containsKey(path))
-		{
-			return joins.get(path);
-		}
-		else
-		{
-			parent = join(path.getParent());
-		}
-
-		final QJoin join = new QJoin(path,
-		                             path.toJoinAlias(),
-		                             parent != null ? parent.getEntity() : path.getRelation(0).getEntity());
-
-		joins.put(path, join);
-
-		return join;
-	}
-
-
-	public QJoin join(String path)
-	{
-		final QPropertyPathBuilder builder = entity.getPath(path);
-
-		return join(builder.getPath());
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntity.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntity.java
index 8c775754f5..e1e6115f07 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntity.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntity.java
@@ -1,23 +1,26 @@
 package com.peterphi.std.guice.hibernate.webquery.impl;
 
-import com.google.common.cache.Cache;
-import com.google.common.cache.CacheBuilder;
 import com.peterphi.std.guice.database.annotation.SearchFieldAlias;
 import com.peterphi.std.guice.restclient.jaxb.webqueryschema.WQEntitySchema;
 import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metadata.ClassMetadata;
-import org.hibernate.type.CollectionType;
-import org.hibernate.type.CompositeType;
-import org.hibernate.type.Type;
 
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.Entity;
 import javax.persistence.Table;
+import javax.persistence.metamodel.Attribute;
+import javax.persistence.metamodel.EmbeddableType;
+import javax.persistence.metamodel.EntityType;
+import javax.persistence.metamodel.PluralAttribute;
+import javax.persistence.metamodel.SingularAttribute;
+import javax.persistence.metamodel.Type;
 import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -25,6 +28,8 @@
 
 public class QEntity
 {
+	private static final Logger log = Logger.getLogger(QEntity.class);
+
 	private final Class<?> clazz;
 	private String name;
 
@@ -34,12 +39,6 @@
 
 	private List<QEntity> descendants = Collections.emptyList();
 
-	private final Cache<String, QPropertyPathBuilder> builderCache = CacheBuilder.newBuilder()
-	                                                                             .weakKeys()
-	                                                                             .weakValues()
-	                                                                             .initialCapacity(0)
-	                                                                             .build();
-
 
 	public QEntity(Class<?> clazz)
 	{
@@ -53,33 +52,55 @@ public QEntity(Class<?> clazz)
 	}
 
 
-	void parse(QEntityFactory entityFactory, ClassMetadata metadata, SessionFactoryImplementor sessionFactory)
+	void parse(QEntityFactory entityFactory, EntityType<?> metadata, SessionFactoryImplementor sessionFactory)
 	{
-		this.name = metadata.getEntityName();
+		this.name = metadata.getName();
 
-		final boolean[] nullability = metadata.getPropertyNullability();
-		final String[] names = metadata.getPropertyNames();
-		final Type[] types = metadata.getPropertyTypes();
+		for (Attribute<?, ?> attribute : metadata.getAttributes())
+		{
+			parseFields(entityFactory, sessionFactory, null, attribute);
+		}
 
 		// Parse top-level properties
-		parseFields(entityFactory, sessionFactory, null, nullability, names, types);
 
 		// Add identifier property
 		{
+			if (!metadata.hasSingleIdAttribute())
+				throw new IllegalArgumentException("@IdClass Entity not supported! " + metadata.getJavaType());
+
+			Type idType = metadata.getIdType();
+
+			switch (idType.getPersistenceType())
+			{
+				case BASIC:
+					break; // No action necessary, will be processed like a normal field
+				case EMBEDDABLE:
+				{
+					EmbeddableType<?> emb = (EmbeddableType<?>) idType;
+
+					parseEmbeddable(entityFactory, sessionFactory, "id", emb);
+					break;
+				}
+				default:
+					throw new IllegalArgumentException("Cannot handle id type: " + idType.getPersistenceType() + ": " + idType);
+			}
+/*
 			final String name = metadata.getIdentifierPropertyName();
 			final Type type = metadata.getIdentifierType();
 			final Class<?> clazz = type.getReturnedClass();
 
-			// Add an id property (N.B. may not work for embedded ids)
-			properties.put(name, new QProperty(this, null, name, clazz, false));
-
-			// If the identifier is a composite primary key then we should also add the composite fields
+			// If the identifier is a composite primary key then we should add the composite fields
 			if (type.isComponentType())
 			{
 				CompositeType composite = (CompositeType) type;
 
 				parseFields(entityFactory, sessionFactory, name, composite);
 			}
+			else
+			{
+				// The identifier is not a composite type, so just add the field directly
+				properties.put(name, new QProperty(this, null, name, clazz, false));
+			}*/
 		}
 
 		// Add field aliases defined on the class
@@ -98,78 +119,154 @@ void parse(QEntityFactory entityFactory, ClassMetadata metadata, SessionFactoryI
 	}
 
 
-	private void parseFields(final QEntityFactory entityFactory,
-	                         final SessionFactoryImplementor sessionFactory,
-	                         final String prefix,
-	                         final CompositeType composite)
+	public void parseEmbeddable(final QEntityFactory entityFactory,
+	                            final SessionFactoryImplementor sessionFactory,
+	                            final String prefix,
+	                            final EmbeddableType<?> type)
 	{
-		parseFields(entityFactory,
-		            sessionFactory,
-		            prefix,
-		            composite.getPropertyNullability(),
-		            composite.getPropertyNames(),
-		            composite.getSubtypes());
+		// Make sure the entity factory sees this embeddable
+		entityFactory.getEmbeddable(type.getJavaType(), type);
+
+		for (Attribute<?, ?> attribute : type.getAttributes())
+		{
+			parseFields(entityFactory, sessionFactory, prefix, attribute);
+		}
 	}
 
 
 	private void parseFields(final QEntityFactory entityFactory,
 	                         final SessionFactoryImplementor sessionFactory,
 	                         final String prefix,
-	                         final boolean[] nullability,
-	                         final String[] names,
-	                         final Type[] types)
+	                         final Attribute<?, ?> attribute)
 	{
-		for (int i = 0; i < names.length; i++)
+		final String name = attribute.getName();
+		//final javax.persistence.metamodel.Type<?> type;
+		final Class<?> clazz;
+		final boolean isCollection;
+		final boolean nullable;
+
+		// Transparently unwrap collections
+		if (attribute.isCollection())
 		{
-			final Type type;
-			final boolean isCollection;
+			isCollection = true;
+			nullable = false;
 
-			// Transparently unwrap collections
-			if (types[i].isCollectionType())
-			{
-				final CollectionType collectionType = (CollectionType) types[i];
-				type = collectionType.getElementType(sessionFactory);
+			//type = ((PluralAttribute<?, ?, ?>) attribute).getElementType();
+			clazz = ((PluralAttribute<?, ?, ?>) attribute).getElementType().getJavaType();
+		}
+		else
+		{
+			isCollection = false;
+			//type = attribute.getDeclaringType();
+			nullable = (attribute instanceof SingularAttribute) ? ((SingularAttribute) attribute).isOptional() : false;
+			clazz = attribute.getJavaType();
+		}
 
-				isCollection = true;
-			}
+		// TODO is it also meaningful to add the parent composite type as a field too?
+		// TODO if not we should have this as a separate if condition
+		if (attribute.getPersistentAttributeType() == Attribute.PersistentAttributeType.EMBEDDED && !isCollection)
+		{
+			final String newPrefix;
+
+			if (prefix != null)
+				newPrefix = prefix + ":" + name;
 			else
-			{
-				type = types[i];
-				isCollection = false;
-			}
+				newPrefix = name;
 
-			final String name = names[i];
-			final Class<?> clazz = type.getReturnedClass();
-			final boolean nullable = nullability[i];
+			SingularAttribute<?, ?> attr = (SingularAttribute<?, ?>) attribute;
+			EmbeddableType<?> ct = (EmbeddableType<?>) attr.getType();
 
-			// TODO is it also meaningful to add the parent composite type as a field too?
-			// TODO if not we should have this as a separate if condition
-			if (types[i].isComponentType())
+			parseEmbeddable(entityFactory, sessionFactory, prefix, ct);
+		}
+		else if (isCollection || attribute.isAssociation())
+		{
+			final QRelation relation;
+			if (attribute.getPersistentAttributeType() != Attribute.PersistentAttributeType.EMBEDDED &&
+			    attribute.getPersistentAttributeType() != Attribute.PersistentAttributeType.BASIC)
 			{
-				CompositeType composite = (CompositeType) types[i];
-
-				final String newPrefix;
-
-				if (prefix != null)
-					newPrefix = prefix + "." + name;
+				if (attribute.getPersistentAttributeType() != Attribute.PersistentAttributeType.ELEMENT_COLLECTION)
+				{
+					relation = new QRelation(this, prefix, name, entityFactory.get(clazz), nullable, isCollection);
+				}
 				else
-					newPrefix = name;
-
-				// This is a composite type, so add the composite types instead
-				parseFields(entityFactory, sessionFactory, newPrefix, composite);
+				{
+					PluralAttribute<?, ?, ?> plural = (PluralAttribute<?, ?, ?>) attribute;
+
+					if (plural.getElementType().getPersistenceType() == Type.PersistenceType.EMBEDDABLE)
+					{
+						final EmbeddableType<?> ct = (EmbeddableType<?>) plural.getElementType();
+
+						relation = new QRelation(this,
+						                         prefix,
+						                         name,
+						                         entityFactory.getEmbeddable(ct.getJavaType(), ct),
+						                         nullable,
+						                         isCollection);
+					}
+					else if (plural.getElementType().getPersistenceType() == Type.PersistenceType.BASIC)
+					{
+						// Ignore this altogether. We should probably come up with a way of querying this relationship in the future
+						relation = null;
+
+						log.debug("Ignoring BASIC ElementCollection " +
+						          plural.getCollectionType() +
+						          " of " +
+						          plural.getElementType().getJavaType() +
+						          " " +
+						          plural.getName());
+					}
+					else
+					{
+
+						throw new IllegalArgumentException("Cannot handle ElementCollection of " +
+						                                   plural.getElementType().getJavaType() +
+						                                   " - type " +
+						                                   plural.getElementType().getPersistenceType());
+					}
+				}
 			}
-			else if (type.isEntityType())
+			else if (isCollection && attribute.getPersistentAttributeType() == Attribute.PersistentAttributeType.EMBEDDED)
 			{
-				relations.put(name, new QRelation(this, prefix, name, entityFactory.get(clazz), nullable));
+				SingularAttribute<?, ?> attr = (SingularAttribute<?, ?>) attribute;
+				EmbeddableType<?> ct = (EmbeddableType<?>) attr.getType();
 
-				// Set up a special property to allow constraining the collection size
-				properties.put(name + ":size", new QSizeProperty(relations.get(name)));
+				relation = new QRelation(this, prefix, name, entityFactory.getEmbeddable(clazz, ct), nullable, isCollection);
 			}
 			else
 			{
-				properties.put(name, new QProperty(this, prefix, name, clazz, nullable));
+				log.warn("Unknown Collection type: " +
+				         attribute.getPersistentAttributeType() +
+				         " " +
+				         attribute +
+				         " with name " +
+				         name +
+				         " within " +
+				         clazz +
+				         " - ignoring");
+				relation = null;
+			}
+
+			if (relation != null)
+			{
+				relations.put(name, relation);
+
+				// Set up a special property to allow constraining the collection size
+				if (isCollection)
+					properties.put(name + ":size", new QSizeProperty(relations.get(name)));
 			}
 		}
+		else
+		{
+			final String newPrefix;
+
+			if (prefix != null)
+				newPrefix = prefix + ":" + name;
+			else
+				newPrefix = name;
+
+
+			properties.put(newPrefix, new QProperty(this, prefix, name, clazz, nullable));
+		}
 	}
 
 
@@ -222,9 +319,38 @@ public boolean hasProperty(String name)
 	}
 
 
-	public boolean hasAlias(String name)
+	/**
+	 * Modify a list of segments by replacing any defined alias on this entity. If there is no such destination alias then does
+	 * nothing<br />
+	 * This is designed to allow underlying database schema changes without changing the query API exposed to users
+	 *
+	 * @param segments
+	 * 		some path optionally including an aliased name (e.g. "asset.parentId")
+	 *
+	 * @return some new path (e.g. "asset.parent.id")
+	 */
+	public void fixupPathUsingAliases(final LinkedList<String> segments)
 	{
-		return aliases.containsKey(name);
+		if (aliases.isEmpty())
+			return; // No transformation necessary or possible
+
+		final String remainingPath = segments.stream().collect(Collectors.joining("."));
+
+		for (Map.Entry<String, String> entry : aliases.entrySet())
+		{
+			final String from = entry.getKey();
+			final String to = entry.getValue();
+
+			if (StringUtils.equals(remainingPath, from) || StringUtils.startsWith(remainingPath, from + "."))
+			{
+				final String newPath = to + remainingPath.substring(from.length());
+
+				segments.clear();
+				segments.addAll(Arrays.asList(StringUtils.split(newPath, '.')));
+
+				return;
+			}
+		}
 	}
 
 
@@ -250,88 +376,6 @@ public QProperty getProperty(String name)
 	}
 
 
-	public QPropertyPathBuilder getPath(final String path)
-	{
-		QPropertyPathBuilder cached = builderCache.getIfPresent(path);
-
-		if (cached == null)
-		{
-			final QPropertyPathBuilder builder = new QPropertyPathBuilder();
-
-			cached = getPath(builder, path);
-
-			builderCache.put(path, cached);
-		}
-
-		return cached;
-	}
-
-
-	public QPropertyPathBuilder getPath(final QPropertyPathBuilder builder, String path)
-	{
-		final int firstDot = path.indexOf('.');
-
-		final boolean terminal = (firstDot == -1);
-
-		final String head = terminal ? path : path.substring(0, firstDot);
-		final String tail = terminal ? null : path.substring(firstDot + 1);
-
-		if (hasAlias(head))
-		{
-			final String newPath;
-
-			if (terminal)
-				newPath = getAlias(head);
-			else
-				newPath = getAlias(head) + "." + tail;
-
-			return getPath(builder, newPath);
-		}
-		else if (hasProperty(head))
-		{
-			if (tail != null)
-				throw new IllegalArgumentException("Found property " + head + " but there are other path components: " + tail);
-
-			builder.append(getProperty(head));
-
-			return builder;
-		}
-		else if (hasRelation(head))
-		{
-			final QRelation relation = getRelation(head);
-
-			builder.append(getRelation(head));
-
-			return relation.getEntity().getPath(builder, tail);
-		}
-		else
-		{
-			final Set<String> expected = new HashSet<>(getPropertyNames());
-			expected.addAll(getRelationNames());
-			expected.addAll(getAliasNames());
-
-			throw new IllegalArgumentException("Relationship path error: got " +
-			                                   head +
-			                                   ", expected one of: " + expected);
-		}
-	}
-
-
-	/**
-	 * Retrieve the resolution of a defined alias on this entity. If there is no such destination alias then return null<br />
-	 * This is designed to allow underlying database schema changes without changing the query API exposed to users
-	 *
-	 * @param name
-	 * 		some aliased name (e.g. "assetId")
-	 *
-	 * @return some alias destination (e.g. "asset.id")
-	 */
-	public String getAlias(String name)
-	{
-		return aliases.get(name);
-	}
-
-
 	public QRelation getRelation(String name)
 	{
 		final QRelation relation = relations.get(name);
@@ -386,11 +430,57 @@ public boolean isEntityClassAbstract()
 	public String toString()
 	{
 		return "QEntity{" +
-		       "clazz=" + clazz +
-		       ", name='" + name + '\'' +
-		       ", properties=" + properties.values() +
-		       ", relations=" + relations.values() +
-		       ", aliases=" + aliases.values() +
+		       "clazz=" +
+		       clazz +
+		       ", name='" +
+		       name +
+		       '\'' +
+		       ", properties=" +
+		       properties.values() +
+		       ", relations=" +
+		       relations.values() +
+		       ", aliases=" +
+		       aliases.values() +
 		       '}';
 	}
+
+
+	public QEntity getSubEntity(final String discriminator)
+	{
+		if (StringUtils.equals(getDiscriminatorValue(), discriminator))
+			return this;
+		else
+			for (QEntity entity : getSubEntities())
+				if (StringUtils.equals(entity.getDiscriminatorValue(), discriminator))
+					return entity;
+
+		throw new IllegalArgumentException("Unknown subclass with discriminator: " + discriminator);
+	}
+
+
+	public QEntity getCommonSubclass(final List<String> discriminators)
+	{
+		Map<Class, QEntity> entities = discriminators
+				                               .stream()
+				                               .map(this :: getSubEntity)
+				                               .collect(Collectors.toMap(e -> e.clazz, e -> e));
+
+		Collection<Class> classes = entities.keySet();
+
+		for (Class potentialSuperclass : classes)
+		{
+			boolean suitableForAll = true;
+			for (Class test : classes)
+			{
+				suitableForAll = suitableForAll && test.isAssignableFrom(potentialSuperclass);
+			}
+
+			// If this is a suitable superclass for all classes we have tested then we have a winner!
+			if (suitableForAll)
+				return entities.get(potentialSuperclass);
+		}
+
+		// Found no more specific subclass
+		return this;
+	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntityFactory.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntityFactory.java
index 02edfacb01..b738e40f64 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntityFactory.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QEntityFactory.java
@@ -6,8 +6,9 @@
 import org.apache.log4j.Logger;
 import org.hibernate.SessionFactory;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metadata.ClassMetadata;
 
+import javax.persistence.metamodel.EmbeddableType;
+import javax.persistence.metamodel.EntityType;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -22,7 +23,7 @@
 
 	private final Map<Class<?>, QEntity> entities = new HashMap<>();
 	private final SessionFactoryImplementor sessionFactory;
-
+	private final Map<Class<?>, EmbeddableType<?>> embeddableTypeMap = new HashMap<>();
 
 	@Inject
 	public QEntityFactory(final SessionFactory sessionFactory)
@@ -30,12 +31,13 @@ public QEntityFactory(final SessionFactory sessionFactory)
 		this.sessionFactory = (SessionFactoryImplementor) sessionFactory;
 
 		if (log.isDebugEnabled())
-			log.debug("Known entities: " + sessionFactory.getAllClassMetadata().keySet());
+			log.debug("Known entities: " +
+			          sessionFactory.getMetamodel().getEntities().stream().map(e -> e.getName()).collect(Collectors.toList()));
 
 		// Pre-construct the QEntity instances for all known entities
-		for (ClassMetadata metadata : sessionFactory.getAllClassMetadata().values())
+		for (EntityType<?> entityType : sessionFactory.getMetamodel().getEntities())
 		{
-			final Class clazz = metadata.getMappedClass();
+			final Class clazz = entityType.getJavaType();
 
 			if (clazz != null && !Modifier.isAbstract(clazz.getModifiers()))
 				get(clazz);
@@ -47,9 +49,9 @@ public QEntityFactory(final SessionFactory sessionFactory)
 	{
 		List<QEntity> subclasses = new ArrayList<>();
 
-		for (ClassMetadata meta : sessionFactory.getAllClassMetadata().values())
+		for (EntityType<?> entityType : sessionFactory.getMetamodel().getEntities())
 		{
-			final Class<?> clazz = meta.getMappedClass();
+			final Class<?> clazz = entityType.getJavaType();
 
 			if (clazz != null && !Modifier.isAbstract(clazz.getModifiers()) && superclass.isAssignableFrom(clazz))
 				subclasses.add(get(clazz));
@@ -59,12 +61,17 @@ public QEntityFactory(final SessionFactory sessionFactory)
 	}
 
 
-	public QEntity get(Class<?> clazz)
+	public <T> QEntity get(Class<T> clazz)
 	{
 		if (!entities.containsKey(clazz))
 		{
 			log.debug("Begin create QEntity " + clazz);
-			final ClassMetadata metadata = sessionFactory.getClassMetadata(clazz);
+			final EntityType<T> metadata = sessionFactory.getMetamodel().entity(clazz);
+
+			if (metadata == null)
+				throw new IllegalArgumentException("Hibernate has no ClassMetadata for: " +
+				                                   clazz +
+				                                   " (should be following Embeddable codepath?)");
 
 			QEntity entity = new QEntity(clazz);
 			entities.put(clazz, entity);
@@ -78,6 +85,24 @@ public QEntity get(Class<?> clazz)
 	}
 
 
+	public QEntity getEmbeddable(final Class clazz, final EmbeddableType ct)
+	{
+		if (!entities.containsKey(clazz))
+		{
+			log.debug("Begin create QEntity " + clazz + " from EmbeddableType " + ct);
+
+			QEntity entity = new QEntity(clazz);
+			entities.put(clazz, entity);
+
+			entity.parseEmbeddable(this, sessionFactory,null, ct);
+
+			log.debug("End create QEntity " + clazz + " from EmbeddableType " + ct);
+		}
+
+		return entities.get(clazz);
+	}
+
+
 	public WQSchemas encode()
 	{
 		WQSchemas obj = new WQSchemas();
@@ -91,7 +116,7 @@ public WQSchemas encode()
 	public List<QEntity> getAll()
 	{
 		// Pre-emptively process all entities
-		sessionFactory.getAllClassMetadata().values().stream().map(ClassMetadata:: getMappedClass).forEach(this :: get);
+		sessionFactory.getMetamodel().getEntities().stream().map(EntityType:: getJavaType).forEach(this :: get);
 
 		return new ArrayList<>(entities.values());
 	}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QFunction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QFunction.java
index 7891b9a909..9f9ef015e2 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QFunction.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QFunction.java
@@ -1,8 +1,8 @@
 package com.peterphi.std.guice.hibernate.webquery.impl;
 
-import org.hibernate.criterion.Criterion;
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
 
 public interface QFunction
 {
-	public Criterion encode();
+	HQLFragment encode(HQLEncodingContext ctx);
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QJoin.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QJoin.java
deleted file mode 100755
index 47bb0f973e..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QJoin.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl;
-
-class QJoin
-{
-	private final QPath path;
-	private final String alias;
-	private final QEntity entity;
-
-
-	public QJoin(final QPath path, final String alias, final QEntity entity)
-	{
-		this.path = path;
-		this.alias = alias;
-		this.entity = entity;
-	}
-
-
-	public QPath getPath()
-	{
-		return path;
-	}
-
-
-	public String getAlias()
-	{
-		return alias;
-	}
-
-
-	public QEntity getEntity()
-	{
-		return entity;
-	}
-
-
-	@Override
-	public String toString()
-	{
-		return "QJoin{" +
-		       "path='" + path + '\'' +
-		       ", alias='" + alias + '\'' +
-		       ", entity=" + entity +
-		       '}';
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QOrder.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QOrder.java
index 5cd7a052af..9bc4d439eb 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QOrder.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QOrder.java
@@ -17,19 +17,9 @@ public QOrder(final QPropertyRef property, final boolean asc)
 
 	public Order encode()
 	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			if (asc)
-				return SizeOrder.asc(property.getName());
-			else
-				return SizeOrder.desc(property.getName());
-		}
+		if (asc)
+			return Order.asc(property.toHqlPath());
 		else
-		{
-			if (asc)
-				return Order.asc(property.getName());
-			else
-				return Order.desc(property.getName());
-		}
+			return Order.desc(property.toHqlPath());
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPath.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPath.java
index 318ec0e0b2..3256eb2171 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPath.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPath.java
@@ -1,109 +1,212 @@
 package com.peterphi.std.guice.hibernate.webquery.impl;
 
+import com.google.common.base.Objects;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
 
-public class QPath
+class QPath
 {
-	private final List<QRelation> components;
-	private final int depth;
+	private final QPath parent;
+	private final String name;
+	private final String alias;
+	private final QRelation relation;
+	private final QProperty property;
+
+	/**
+	 * Alias for collections
+	 */
+	private String hsqlAlias = null;
 
 
-	public QPath(final List<QRelation> components, final int depth)
+	public QPath(final QPath parent, final String name, final String alias, final QRelation relation, final QProperty property)
 	{
-		if (components.isEmpty())
-			throw new IllegalArgumentException("Must provide at least one component for a path!");
-		else if (depth > components.size())
-			throw new IllegalArgumentException("Depth must be <= component list size!");
+		this.parent = parent;
+		this.name = name;
+
+		if (alias == null && relation != null && relation.isCollection())
+			this.alias = UUID.randomUUID().toString(); // Generate a random alias name
+		else
+			this.alias = alias;
 
-		this.components = components;
-		this.depth = depth;
+		this.relation = relation;
+		this.property = property;
 	}
 
 
-	public QPath getParent()
+	public static QPath parse(final QEntity rootEntity, final QPath parent, final LinkedList<String> segments)
 	{
-		if (depth > 1)
-			return new QPath(this.components, depth - 1);
+		final QEntity entity;
+		if (parent == null)
+			entity = rootEntity;
 		else
-			return null;
+			entity = parent.getRelation().getEntity();
+
+		// Resolve any aliases at this entity level
+		entity.fixupPathUsingAliases(segments);
+
+		final String expr = segments.removeFirst();
+
+		final String name;
+		final String alias;
+		if (expr.indexOf('[') == -1)
+		{
+			name = expr;
+			alias = null;
+		}
+		else
+		{
+			// Should have a ] at the end of the expression
+			if (expr.indexOf(']') != expr.length() - 1)
+				throw new IllegalArgumentException("Expected segmentName[aliasName]! Got: " + expr);
+
+			name = expr.substring(0, expr.indexOf('['));
+			alias = expr.substring(expr.indexOf('[') + 1, expr.length() - 1);
+		}
+
+		if (entity.hasProperty(name))
+			return new QPath(parent, name, alias, null, entity.getProperty(name));
+		else if (entity.hasRelation(name))
+			return new QPath(parent, name, alias, entity.getRelation(name), null);
+		else
+		{
+			final Set<String> expected = new HashSet<>(entity.getPropertyNames());
+			expected.addAll(entity.getRelationNames());
+			expected.addAll(entity.getAliasNames());
+
+			throw new IllegalArgumentException("Relationship path error: got " +
+			                                   expr +
+			                                   "(converted to " +
+			                                   name +
+			                                   " with alias " +
+			                                   alias +
+			                                   "), expected one of: " +
+			                                   expected);
+		}
 	}
 
 
-	public QRelation getRelation(final int index)
+	public QPath getParent()
 	{
-		if (index > depth || index < 0)
-			throw new IllegalArgumentException("Illegal value for index: must be between 0 and " + depth);
-		else
-			return components.get(index);
+		return parent;
 	}
 
 
-	public String toJoinAlias()
+	public String getName()
 	{
-		return toString('_');
+		return name;
 	}
 
 
-	private String toString(char separator)
+	public String getAlias()
 	{
-		StringBuilder sb = new StringBuilder();
+		return alias;
+	}
 
-		for (int i = 0; i < depth; i++)
-		{
-			if (i != 0)
-				sb.append(separator);
 
-			sb.append(components.get(i).getName());
-		}
+	public QRelation getRelation()
+	{
+		return relation;
+	}
+
 
-		return sb.toString();
+	public QProperty getProperty()
+	{
+		return property;
 	}
 
 
-	@Override
-	public String toString()
+	public String getHsqlAlias()
 	{
-		if (depth == 1)
-			return components.get(0).getName();
-		else
-			return toString('.');
+		return hsqlAlias;
 	}
 
 
-	@Override
-	public int hashCode()
+	public void setHsqlAlias(final String hsqlAlias)
+	{
+		this.hsqlAlias = hsqlAlias;
+	}
+
+
+	public String toHsqlPath()
 	{
-		// Copied from AbstractList.hashCode
-		int hashCode = 1;
+		List<String> path = new ArrayList<>();
+
+		path.add(name);
 
-		for (int i = 0; i < depth; i++)
-			hashCode = 31 * hashCode + (components.get(i).hashCode());
+		QPath current = getParent();
 
-		return hashCode;
+		while (true)
+		{
+			if (current == null)
+			{
+				path.add("{alias}"); // root object
+				break;
+			}
+			if (current.getHsqlAlias() != null)
+			{
+				path.add(current.getHsqlAlias());
+				break;
+			}
+			else
+			{
+				path.add(current.getName());
+			}
+
+			current = current.getParent();
+		}
+
+		Collections.reverse(path);
+
+		return path.stream().collect(Collectors.joining("."));
 	}
 
 
 	@Override
-	public boolean equals(Object o)
+	public boolean equals(final Object o)
 	{
-		if (o == this)
+		if (this == o)
 			return true;
-		else if (!(o instanceof QPath))
+		if (o == null || getClass() != o.getClass())
 			return false;
-		else
-		{
-			QPath other = (QPath) o;
 
-			// Must have the same depth to be identical
-			if (other.depth != this.depth)
-				return false;
+		QPath qPath = (QPath) o;
 
-			for (int i = 0; i < depth; i++)
-				if (!other.components.get(i).equals(this.components.get(i)))
-					return false; // path mismatch
+		if (parent != null ? !parent.equals(qPath.parent) : qPath.parent != null)
+			return false;
+		if (name != null ? !name.equals(qPath.name) : qPath.name != null)
+			return false;
+		return alias != null ? alias.equals(qPath.alias) : qPath.alias == null;
+	}
 
-			// No mismatch encountered
-			return true;
-		}
+
+	@Override
+	public int hashCode()
+	{
+		int result = parent != null ? parent.hashCode() : 0;
+		result = 31 * result + (name != null ? name.hashCode() : 0);
+		result = 31 * result + (alias != null ? alias.hashCode() : 0);
+		return result;
+	}
+
+
+	@Override
+	public String toString()
+	{
+		return Objects
+				       .toStringHelper(this)
+				       .add("parent", parent)
+				       .add("name", name)
+				       .add("alias", alias)
+				       .add("relation", relation)
+				       .add("property", property)
+				       .add("hsqlAlias", hsqlAlias)
+				       .toString();
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QProperty.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QProperty.java
index 5f317793d3..a5591f7c3f 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QProperty.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QProperty.java
@@ -18,7 +18,7 @@ public QProperty(final QEntity entity, final String prefix, final String name, f
 		this.entity = entity;
 
 		if (prefix != null)
-			this.name = prefix + "." + name;
+			this.name = prefix + ":" + name;
 		else
 			this.name = name;
 
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPath.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPath.java
deleted file mode 100755
index d740d8e3cf..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPath.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl;
-
-public class QPropertyPath
-{
-	private final QPath path;
-	private final QProperty property;
-
-
-	public QPropertyPath(final QPath parent, final QProperty property)
-	{
-		this.path = parent;
-		this.property = property;
-	}
-
-
-	public QPath getPath()
-	{
-		return path;
-	}
-
-
-	public QProperty getProperty()
-	{
-		return property;
-	}
-
-
-	@Override
-	public String toString()
-	{
-		if (path != null)
-			return path.toString() + "." + property.getName();
-		else
-			return property.getName();
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPathBuilder.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPathBuilder.java
deleted file mode 100755
index 75f21bb265..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyPathBuilder.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class QPropertyPathBuilder
-{
-	private List<QRelation> path = new ArrayList<>();
-
-	private QProperty property;
-
-
-	public void append(QRelation relation)
-	{
-		if (property != null)
-			throw new IllegalStateException("Cannot append a relation path when a property has already been appended!");
-
-		path.add(relation);
-	}
-
-
-	public void append(QProperty property)
-	{
-		if (this.property != null)
-			throw new IllegalStateException("Cannot append a property twice! Already have " + this.property);
-
-		this.property = property;
-	}
-
-
-	public QPath getPath()
-	{
-		if (!path.isEmpty())
-			return new QPath(path, path.size());
-		else
-			return null;
-	}
-
-
-	public QPropertyPath getPropertyPath()
-	{
-		if (property == null)
-			throw new IllegalArgumentException("Expected property but path referred to a relation: " + path.toString());
-
-		return new QPropertyPath(getPath(), property);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyRef.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyRef.java
index 2bdde7f67c..1a62916b42 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyRef.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QPropertyRef.java
@@ -2,64 +2,48 @@
 
 public class QPropertyRef
 {
-	private final QJoin join;
-	private final QProperty property;
+	private final QPath path;
 
 
-	public QPropertyRef(final QJoin join, final QProperty property)
+	public QPropertyRef(final QPath path)
 	{
-		this.join = join;
-		this.property = property;
+		if (path.getProperty() == null)
+			throw new IllegalArgumentException("Must supply property path! Not " + path);
+
+		this.path = path;
 	}
 
 
-	public QJoin getJoin()
+	public QPath getPath()
 	{
-		return join;
+		return path;
 	}
 
 
 	public QProperty getProperty()
 	{
-		return property;
+		return path.getProperty();
 	}
 
 
 	public Object parseValue(String value)
 	{
-		return QTypeHelper.parse(property.getClazz(), value);
-	}
-
-
-	public String getName()
-	{
-		if (join != null)
-			return join.getAlias() + "." + property.getName();
-		else
-			return property.getName();
+		return QTypeHelper.parse(getProperty().getClazz(), value);
 	}
 
 
-	/**
-	 * Get a name that can be used in a SQLRestriction
-	 *
-	 * @return
-	 */
-	public String getSQLRestrictionName()
+	public String toHqlPath()
 	{
-		if (join != null)
-			return "{" + join.getAlias() + "}." + property.getName();
+		if (getProperty() instanceof QSizeProperty)
+			return ((QSizeProperty) getProperty()).toHqlPath(path);
 		else
-			return "{alias}." + property.getName();
+			return path.toHsqlPath().replace(':', '.'); // For composite primary keys, turn : into . (e.g. id:timestamp -> id.timestamp as HQL expects)
 	}
 
 
 	@Override
 	public String toString()
 	{
-		return "QPropertyRef{" +
-		       "join=" + join +
-		       ", property=" + property +
-		       '}';
+		return "QPropertyRef{" + path + '}';
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QRelation.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QRelation.java
index af46ce58f0..4be2f7c133 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QRelation.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QRelation.java
@@ -9,9 +9,10 @@
 	private final String name;
 	private final QEntity entity;
 	private final boolean nullable;
+	private final boolean collection;
 
 
-	public QRelation(final QEntity owner, final String prefix, final String name, final QEntity entity, final boolean nullable)
+	public QRelation(final QEntity owner, final String prefix, final String name, final QEntity entity, final boolean nullable, final boolean collection)
 	{
 		this.owner = owner;
 
@@ -22,6 +23,7 @@ public QRelation(final QEntity owner, final String prefix, final String name, fi
 
 		this.entity = entity;
 		this.nullable = nullable;
+		this.collection=collection;
 	}
 
 
@@ -69,6 +71,12 @@ public boolean isNullable()
 	}
 
 
+	public boolean isCollection()
+	{
+		return collection;
+	}
+
+
 	@Override
 	public String toString()
 	{
@@ -77,6 +85,7 @@ public String toString()
 		       ", name='" + name + '\'' +
 		       ", entity=" + entity.getName() +
 		       ", nullable=" + nullable +
+		       ", collection=" + collection+
 		       '}';
 	}
 
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QSizeProperty.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QSizeProperty.java
index 134b5b2cd1..1e0b8e8bf5 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QSizeProperty.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QSizeProperty.java
@@ -16,6 +16,16 @@ public QSizeProperty(final QRelation relation)
 	}
 
 
+	public String toHqlPath(final QPath path)
+	{
+		final String rawPath = path.toHsqlPath();
+
+		final String collectionPath = rawPath.replace(":size", "");
+
+		return "SIZE(" + collectionPath + ")";
+	}
+
+
 	public QRelation getRelation()
 	{
 		return relation;
@@ -26,11 +36,17 @@ public QRelation getRelation()
 	public String toString()
 	{
 		return "QSizeProperty{" +
-		       "relation.name=" + relation.getName() +
-		       ", entity.name=" + super.entity.getName() +
-		       ", name='" + super.name + '\'' +
-		       ", clazz=" + super.clazz +
-		       ", nullable=" + super.nullable +
+		       "relation.name=" +
+		       relation.getName() +
+		       ", entity.name=" +
+		       super.entity.getName() +
+		       ", name='" +
+		       super.name +
+		       '\'' +
+		       ", clazz=" +
+		       super.clazz +
+		       ", nullable=" +
+		       super.nullable +
 		       '}';
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QTypeHelper.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QTypeHelper.java
index 4f59b05025..2c69ebb100 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QTypeHelper.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/QTypeHelper.java
@@ -33,6 +33,10 @@ else if (clazz == Double.class || clazz == double.class)
 		{
 			return WQDataType.NUMERIC;
 		}
+		else if (clazz == Float.class || clazz == float.class)
+		{
+			return WQDataType.NUMERIC;
+		}
 		else if (clazz == Short.class || clazz == short.class)
 		{
 			return WQDataType.NUMERIC;
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/SizeOrder.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/SizeOrder.java
deleted file mode 100755
index a4bd19664e..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/SizeOrder.java
+++ /dev/null
@@ -1,111 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl;
-
-import org.hibernate.Criteria;
-import org.hibernate.NullPrecedence;
-import org.hibernate.criterion.CriteriaQuery;
-import org.hibernate.criterion.Order;
-import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.persister.collection.QueryableCollection;
-import org.hibernate.persister.entity.Loadable;
-import org.hibernate.sql.ConditionFragment;
-
-import java.io.Serializable;
-
-/**
- * Represents an ordering imposed upon the results of a Criteria
- *
- * @author Peter Wright
- * @see org.hibernate.criterion.SizeExpression
- */
-class SizeOrder extends Order implements Serializable
-{
-	/**
-	 * Ascending order
-	 *
-	 * @param propertyName
-	 * 		The property to order on
-	 *
-	 * @return The build Order instance
-	 */
-	public static SizeOrder asc(String propertyName)
-	{
-		return new SizeOrder(propertyName, true);
-	}
-
-
-	/**
-	 * Descending order.
-	 *
-	 * @param propertyName
-	 * 		The property to order on
-	 *
-	 * @return The build Order instance
-	 */
-	public static SizeOrder desc(String propertyName)
-	{
-		return new SizeOrder(propertyName, false);
-	}
-
-
-	/**
-	 * Constructor for Order.  Order instances are generally created by factory methods.
-	 *
-	 * @see #asc
-	 * @see #desc
-	 */
-	protected SizeOrder(String propertyName, boolean ascending)
-	{
-		super(propertyName, ascending);
-	}
-
-
-	/**
-	 * Render the SQL fragment
-	 *
-	 * @param criteria
-	 * 		The criteria
-	 * @param criteriaQuery
-	 * 		The overall query
-	 *
-	 * @return The ORDER BY fragment for this ordering
-	 *
-	 * @see org.hibernate.criterion.SizeExpression#toSqlString(Criteria, CriteriaQuery)
-	 */
-	@Override
-	public String toSqlString(Criteria criteria, CriteriaQuery criteriaQuery)
-	{
-		final SessionFactoryImplementor factory = criteriaQuery.getFactory();
-		final String propertyName = getPropertyName();
-
-		// The following logic is from SizeExpression
-		final String entityName = criteriaQuery.getEntityName(criteria, propertyName);
-		final String role = entityName + '.' + criteriaQuery.getPropertyName(propertyName);
-		final QueryableCollection cp = (QueryableCollection) criteriaQuery.getFactory().getCollectionPersister(role);
-
-		final String[] fk = cp.getKeyColumnNames();
-		final String[] pk = ((Loadable) cp.getOwnerEntityPersister()).getIdentifierColumnNames();
-
-		final ConditionFragment subQueryRestriction = new ConditionFragment().setTableAlias(criteriaQuery.getSQLAlias(criteria,
-		                                                                                                              propertyName))
-		                                                                     .setCondition(pk, fk);
-
-		final String expression = String.format("(select count(*) from %s where %s)",
-		                                        cp.getTableName(),
-		                                        subQueryRestriction.toFragmentString());
-
-		// Render an order element based on the size SQL expression
-		return factory.getDialect().renderOrderByElement(expression.toString(),
-		                                                 null,
-		                                                 isAscending() ? "asc" : "desc",
-		                                                 NullPrecedence.NONE);
-	}
-
-
-	@Override
-	public String toString()
-	{
-		return getPropertyName() +
-		       ".size " +
-		       (isAscending() ? "asc" : "desc");
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/AndGroup.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/AndGroup.java
deleted file mode 100755
index e4405d2275..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/AndGroup.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import org.hibernate.criterion.Conjunction;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-import java.util.List;
-
-class AndGroup implements QFunction
-{
-	private List<QFunction> constraints;
-
-
-	public AndGroup(List<QFunction> constraints)
-	{
-		this.constraints = constraints;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (constraints.isEmpty())
-			return null;
-		else if (constraints.size() == 1)
-			return constraints.get(0).encode();
-		else
-		{
-			final Conjunction and = Restrictions.conjunction();
-
-			for (QFunction constraint : constraints)
-			{
-				Criterion encoded = constraint.encode();
-
-				if (encoded != null)
-					and.add(encoded);
-			}
-
-
-			return and;
-		}
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Between.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Between.java
deleted file mode 100755
index 8c3af5c6d5..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Between.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.apache.commons.lang.StringUtils;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Between implements QFunction
-{
-	private final QPropertyRef property;
-
-	private final Object from;
-	private final Object to;
-
-
-	public Between(final QPropertyRef property, final String from, final String to)
-	{
-		if (StringUtils.isBlank(from) && StringUtils.isBlank(to))
-			throw new IllegalArgumentException("Must provide at least one anchor point for between!");
-
-		this.property = property;
-
-		if (StringUtils.isNotBlank(to))
-			this.to = property.parseValue(to);
-		else
-			this.to = null;
-
-		if (StringUtils.isNotBlank(from))
-			this.from = property.parseValue(from);
-		else
-			this.from = null;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		// Special-case constraints on size properties
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			// N.B. build from other primitives to take advantage of optimisations for > 0, < 1 etc.
-			if (from != null && to != null)
-				return Restrictions.and(Restrictions.sizeGe(property.getName(), (Integer) from),
-				                        Restrictions.sizeLe(property.getName(), (Integer) to));
-			else if (from != null)
-				return new Ge(property, from.toString()).encode();
-			else
-				return new Le(property, to.toString()).encode();
-		}
-		else
-		{
-			if (from != null && to != null)
-				return Restrictions.between(property.getName(), from, to);
-			else if (from != null)
-				return Restrictions.ge(property.getName(), from);
-			else
-				return Restrictions.le(property.getName(), to);
-		}
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryFunction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryFunction.java
new file mode 100755
index 0000000000..cc1bc99462
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryFunction.java
@@ -0,0 +1,28 @@
+package com.peterphi.std.guice.hibernate.webquery.impl.functions;
+
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLFragment;
+import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
+import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
+
+class BinaryFunction implements QFunction
+{
+	private final QPropertyRef property;
+	private final String operator;
+	private final Object value;
+
+
+	public BinaryFunction(final QPropertyRef property, final String operator, final String value)
+	{
+		this.property = property;
+		this.operator = operator;
+		this.value = property.parseValue(value);
+	}
+
+
+	@Override
+	public HQLFragment encode(final HQLEncodingContext ctx)
+	{
+		return new HQLFragment(property.toHqlPath() + " " + operator + " " + ctx.createPropertyPlaceholder(value));
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryPropertyFunction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryPropertyFunction.java
new file mode 100755
index 0000000000..e82e557a7c
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BinaryPropertyFunction.java
@@ -0,0 +1,31 @@
+package com.peterphi.std.guice.hibernate.webquery.impl.functions;
+
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLFragment;
+import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
+import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
+
+/**
+ * A {@link QFunction} that operates on two function references
+ */
+class BinaryPropertyFunction implements QFunction
+{
+	private final QPropertyRef property;
+	private final String operator;
+	private final QPropertyRef otherProperty;
+
+
+	public BinaryPropertyFunction(final QPropertyRef property, final String operator, final QPropertyRef otherProperty)
+	{
+		this.property = property;
+		this.operator = operator;
+		this.otherProperty = otherProperty;
+	}
+
+
+	@Override
+	public HQLFragment encode(final HQLEncodingContext ctx)
+	{
+		return new HQLFragment(property.toHqlPath() + " " + operator + " " + otherProperty.toHqlPath());
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Eq.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Eq.java
deleted file mode 100755
index 003adac8b7..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Eq.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Eq implements QFunction
-{
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Eq(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val == 0)
-				return Restrictions.isEmpty(property.getName());
-			else
-				return Restrictions.sizeEq(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.eq(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Ge.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Ge.java
deleted file mode 100755
index 1894062ba4..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Ge.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Ge implements QFunction
-{
-
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Ge(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val == 0)
-				return Restrictions.conjunction(); // N.B. size can only be positive so "0 or more" is meaningless
-			else if (val == 1)
-				return Restrictions.isNotEmpty(property.getName());
-			else
-				return Restrictions.sizeGe(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.ge(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/GroupFunction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/GroupFunction.java
new file mode 100755
index 0000000000..c934c7f730
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/GroupFunction.java
@@ -0,0 +1,69 @@
+package com.peterphi.std.guice.hibernate.webquery.impl.functions;
+
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLFragment;
+import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+class GroupFunction implements QFunction
+{
+	private final boolean and;
+	private List<QFunction> constraints;
+
+
+	public GroupFunction(final boolean and)
+	{
+		this(and, new ArrayList<>());
+	}
+
+
+	public GroupFunction(final boolean and, List<QFunction> constraints)
+	{
+		this.and = and;
+		this.constraints = constraints;
+	}
+
+
+	public GroupFunction add(QFunction function)
+	{
+		this.constraints.add(function);
+		return this;
+	}
+
+
+	@Override
+	public HQLFragment encode(HQLEncodingContext ctx)
+	{
+		if (constraints.isEmpty())
+			return null;
+		else if (constraints.size() == 1)
+			return constraints.get(0).encode(ctx);
+		else
+		{
+			final List<HQLFragment> fragments = constraints
+					                                     .stream()
+					                                     .filter(c -> c != null)
+					                                     .map(c -> c.encode(ctx))
+					                                     .collect(Collectors.toList());
+
+			final String separator = and ? " AND " : " OR ";
+
+			return HQLFragment.combine(fragments, "(", separator, ")");
+		}
+	}
+
+
+	public static GroupFunction and(List<QFunction> constraints)
+	{
+		return new GroupFunction(true, constraints);
+	}
+
+
+	public static GroupFunction or(List<QFunction> constraints)
+	{
+		return new GroupFunction(false, constraints);
+	}
+}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Gt.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Gt.java
deleted file mode 100755
index 149034054f..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Gt.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Gt implements QFunction
-{
-
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Gt(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val < 0)
-				return Restrictions.conjunction(); // N.B. size can only be positive so "0 or more" is meaningless
-			else if (val == 0)
-				return Restrictions.isNotEmpty(property.getName());
-			else
-				return Restrictions.sizeGt(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.gt(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNotNull.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNotNull.java
deleted file mode 100755
index 483a6188ce..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNotNull.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class IsNotNull implements QFunction
-{
-	private final QPropertyRef property;
-
-
-	public IsNotNull(final QPropertyRef property)
-	{
-		this.property = property;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		return Restrictions.isNotNull(property.getName());
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNull.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNull.java
deleted file mode 100755
index 295ae9ce95..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/IsNull.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class IsNull implements QFunction
-{
-	private final QPropertyRef property;
-
-
-	public IsNull(final QPropertyRef property)
-	{
-		this.property = property;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		return Restrictions.isNull(property.getName());
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Le.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Le.java
deleted file mode 100755
index f3b8714d2e..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Le.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Le implements QFunction
-{
-
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Le(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val == 0)
-				return Restrictions.isEmpty(property.getName());
-			else
-				return Restrictions.sizeLe(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.le(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Like.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Like.java
deleted file mode 100755
index 2e40bb8ee9..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Like.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Like implements QFunction
-{
-	private final QPropertyRef property;
-	private final String param;
-
-
-	public Like(final QPropertyRef property, final String param)
-	{
-		this.property = property;
-		this.param = param;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		return Restrictions.like(property.getName(), param);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Lt.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Lt.java
deleted file mode 100755
index 3767c014ba..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Lt.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Lt implements QFunction
-{
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Lt(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val == 1)
-				return Restrictions.isEmpty(property.getName());
-			else
-				return Restrictions.sizeLt(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.lt(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Neq.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Neq.java
deleted file mode 100755
index 88800f0156..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/Neq.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-class Neq implements QFunction
-{
-	private final QPropertyRef property;
-	private final Object value;
-
-
-	public Neq(final QPropertyRef property, final String value)
-	{
-		this.property = property;
-		this.value = property.parseValue(value);
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (property.getProperty() instanceof QSizeProperty)
-		{
-			final int val = (Integer) value;
-
-			if (val == 0)
-				return Restrictions.isNotEmpty(property.getName());
-			else
-				return Restrictions.sizeNe(property.getName(), (Integer) value);
-		}
-		else
-			return Restrictions.ne(property.getName(), value);
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/OrGroup.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/OrGroup.java
deleted file mode 100755
index 15bbe70ea5..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/OrGroup.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Junction;
-import org.hibernate.criterion.Restrictions;
-
-import java.util.List;
-
-class OrGroup implements QFunction
-{
-	private List<QFunction> constraints;
-
-
-	public OrGroup(List<QFunction> constraints)
-	{
-		this.constraints = constraints;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		if (constraints.isEmpty())
-			return null;
-		else if (constraints.size() == 1)
-			return constraints.get(0).encode();
-		else
-		{
-			final Junction or = Restrictions.disjunction();
-
-			for (QFunction constraint : constraints)
-			{
-				Criterion encoded = constraint.encode();
-
-				if (encoded != null)
-					or.add(encoded);
-			}
-
-
-			return or;
-		}
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/PropertyRestriction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/PropertyRestriction.java
deleted file mode 100755
index 2be869f943..0000000000
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/PropertyRestriction.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.restclient.jaxb.webquery.WQFunctionType;
-import org.hibernate.criterion.Criterion;
-import org.hibernate.criterion.Restrictions;
-
-/**
- * A {@link QFunction} that instructs hibernate that a property must have some value relative to another property (equals, not
- * equals, less than, greater than, etc.)
- */
-class PropertyRestriction implements QFunction
-{
-	private final QPropertyRef lhs;
-	private final WQFunctionType function;
-	private final QPropertyRef rhs;
-
-
-	/**
-	 * Construct a new PropertyRestriction encoding the expression <code>(lhs) (function) (rhs)</code>
-	 *
-	 * @param lhs
-	 * 		the left hand side property
-	 * @param function
-	 * 		the function
-	 * @param rhs
-	 * 		the right hand side property
-	 */
-	public PropertyRestriction(final QPropertyRef lhs, final WQFunctionType function, final QPropertyRef rhs)
-	{
-		if (!function.hasPropertyRefParam())
-			throw new IllegalArgumentException("Function passed to PropertyRestriction must have a property ref param! Not " +
-			                                   function);
-
-		this.lhs = lhs;
-		this.function = function;
-		this.rhs = rhs;
-	}
-
-
-	@Override
-	public Criterion encode()
-	{
-		switch (function)
-		{
-			case EQ_REF:
-				return Restrictions.eqProperty(lhs.getName(), rhs.getName());
-			case NEQ_REF:
-				return Restrictions.neProperty(lhs.getName(), rhs.getName());
-			case LE_REF:
-				return Restrictions.leProperty(lhs.getName(), rhs.getName());
-			case LT_REF:
-				return Restrictions.ltProperty(lhs.getName(), rhs.getName());
-			case GE_REF:
-				return Restrictions.geProperty(lhs.getName(), rhs.getName());
-			case GT_REF:
-				return Restrictions.gtProperty(lhs.getName(), rhs.getName());
-
-			default:
-				throw new IllegalArgumentException("No logic to encode " + toString() + "!");
-		}
-	}
-
-
-	@Override
-	public String toString()
-	{
-		return "PropertyRestriction{" + lhs + " " + function + " " + rhs + "}";
-	}
-}
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/QFunctionFactory.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/QFunctionFactory.java
index 84094c6b4d..0b53bfa29c 100755
--- a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/QFunctionFactory.java
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/QFunctionFactory.java
@@ -4,6 +4,7 @@
 import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
 import com.peterphi.std.guice.restclient.jaxb.webquery.WQFunctionType;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Function;
 
@@ -18,37 +19,50 @@ public static QFunction getInstance(QPropertyRef property,
 		switch (function)
 		{
 			case EQ:
-				return new Eq(property, param);
+				return new BinaryFunction(property, "=", param);
 			case NEQ:
-				return new Neq(property, param);
+				return new BinaryFunction(property, "!=", param);
 			case IS_NULL:
-				return new IsNull(property);
+				return new UnaryFunction(property, "IS NULL");
 			case NOT_NULL:
-				return new IsNotNull(property);
+				return new UnaryFunction(property, "IS NOT NULL");
 			case CONTAINS:
-				return new Like(property, "%" + param + "%");
+				return new BinaryFunction(property, "LIKE", "%" + param + "%");
 			case STARTS_WITH:
-				return new Like(property, param + "%");
+				return new BinaryFunction(property, "LIKE", param + "%");
 			case RANGE:
-				return new Between(property, param, param2);
+			{
+				// Encode as a composite >= and <=
+				GroupFunction and = GroupFunction.and(new ArrayList<>());
+
+				if (param != null)
+					and.add(new BinaryFunction(property, ">=", param));
+				if (param2 != null)
+					and.add(new BinaryFunction(property, "<=", param2));
+				return and;
+			}
 			case GE:
-				return new Ge(property, param);
+				return new BinaryFunction(property, ">=", param);
 			case GT:
-				return new Gt(property, param);
+				return new BinaryFunction(property, ">", param);
 			case LE:
-				return new Le(property, param);
+				return new BinaryFunction(property, "<=", param);
 			case LT:
-				return new Lt(property, param);
+				return new BinaryFunction(property, "<", param);
+
 			// Functions referencing a property (can't optimise these so use a PropertyRestriction)
 			case EQ_REF:
+				return new BinaryPropertyFunction(property, "=", propertyResolver.apply(param));
 			case NEQ_REF:
+				return new BinaryPropertyFunction(property, "!=", propertyResolver.apply(param));
 			case LE_REF:
+				return new BinaryPropertyFunction(property, "<=", propertyResolver.apply(param));
 			case LT_REF:
+				return new BinaryPropertyFunction(property, "<", propertyResolver.apply(param));
 			case GE_REF:
+				return new BinaryPropertyFunction(property, ">=", propertyResolver.apply(param));
 			case GT_REF:
-				QPropertyRef paramRef = propertyResolver.apply(param);
-
-				return new PropertyRestriction(property, function, paramRef);
+				return new BinaryPropertyFunction(property, ">", propertyResolver.apply(param));
 			default:
 				throw new IllegalArgumentException("No mapping for function: " + function);
 		}
@@ -57,12 +71,12 @@ public static QFunction getInstance(QPropertyRef property,
 
 	public static QFunction and(List<QFunction> constraints)
 	{
-		return new AndGroup(constraints);
+		return GroupFunction.and(constraints);
 	}
 
 
 	public static QFunction or(List<QFunction> constraints)
 	{
-		return new OrGroup(constraints);
+		return GroupFunction.or(constraints);
 	}
 }
diff --git a/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/UnaryFunction.java b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/UnaryFunction.java
new file mode 100755
index 0000000000..9ecf6e0d72
--- /dev/null
+++ b/guice/hibernate/src/main/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/UnaryFunction.java
@@ -0,0 +1,26 @@
+package com.peterphi.std.guice.hibernate.webquery.impl.functions;
+
+import com.peterphi.std.guice.hibernate.webquery.HQLEncodingContext;
+import com.peterphi.std.guice.hibernate.webquery.impl.HQLFragment;
+import com.peterphi.std.guice.hibernate.webquery.impl.QFunction;
+import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
+
+public class UnaryFunction implements QFunction
+{
+	private final QPropertyRef property;
+	private final String operator;
+
+
+	public UnaryFunction(final QPropertyRef property, final String operator)
+	{
+		this.property = property;
+		this.operator = operator;
+	}
+
+
+	@Override
+	public HQLFragment encode(final HQLEncodingContext ctx)
+	{
+		return new HQLFragment(property.toHqlPath() + " " + operator);
+	}
+}
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ChildEntity.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ChildEntity.java
index ce67e4155f..da3b81bfdb 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ChildEntity.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ChildEntity.java
@@ -1,5 +1,7 @@
 package com.peterphi.std.guice.hibernate.hqlchildcount;
 
+import com.google.common.base.Objects;
+
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
@@ -58,4 +60,11 @@ public void setFlag(final boolean flag)
 	{
 		this.flag = flag;
 	}
+
+
+	@Override
+	public String toString()
+	{
+		return Objects.toStringHelper(this).add("id", id).toString();
+	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/HqlChildCountTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/HqlChildCountTest.java
index ee82a54191..a7c507e47d 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/HqlChildCountTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/HqlChildCountTest.java
@@ -1,19 +1,22 @@
 package com.peterphi.std.guice.hibernate.hqlchildcount;
 
 import com.google.inject.Inject;
+import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.dao.HibernateDao;
+import com.peterphi.std.guice.hibernate.webquery.ConstrainedResultSet;
+import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
 import com.peterphi.std.guice.testing.GuiceUnit;
 import com.peterphi.std.guice.testing.com.peterphi.std.guice.testing.annotations.GuiceConfig;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.util.List;
+import java.util.stream.Collectors;
 
 import static org.junit.Assert.assertEquals;
 
 @RunWith(GuiceUnit.class)
-@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties",
-		            classPackages = ParentEntity.class)
+@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties", classPackages = ParentEntity.class)
 public class HqlChildCountTest
 {
 	@Inject
@@ -37,6 +40,121 @@ public void testEmptyDb() throws Exception
 	}
 
 
+	@Test
+	public void testChildCriteria() throws Exception
+	{
+		load();
+
+		criteria();
+	}
+
+
+	@Test
+	public void testChildHQL() throws Exception
+	{
+		load();
+
+		query();
+	}
+
+
+	//@Transactional
+	public void criteria()
+	{
+		final ConstrainedResultSet<ParentEntity> resultset = dao.findByUriQuery(new WebQuery()
+				                                                                        .dbfetch("children", "children.parent")
+				                                                                        .eq("children.flag", true)
+				                                                                        .logSQL(true));
+
+		System.out.println("SQL: " + resultset.getSql());
+		System.out.println("SQL Statements: " + resultset.getSql().size());
+
+		List<ParentEntity> results = resultset.getList();
+
+		System.out.println(results);
+
+		for (ParentEntity result : results)
+		{
+			System.out.println(result.getId() +
+			                   " - children " +
+			                   result.getChildren().stream().map(c -> c.getId().toString()).collect(Collectors.joining(",")));
+
+			assertEquals("each parent should have 3 children", 3, result.getChildren().size());
+		}
+
+		assertEquals("should be 2 parent entities", 2, results.size());
+	}
+
+
+	@Transactional
+	public void load()
+	{
+		{
+			// TODO populate db
+			ParentEntity p1 = new ParentEntity();
+			p1.setCapacity(2);
+			p1.setId(dao.save(p1));
+
+			ChildEntity c1 = new ChildEntity();
+			c1.setParent(p1);
+			c1.setFlag(true);
+			c1.setId(rDao.save(c1));
+
+			ChildEntity c2 = new ChildEntity();
+			c2.setParent(p1);
+			c2.setFlag(true);
+			c2.setId(rDao.save(c2));
+
+			ChildEntity c3 = new ChildEntity();
+			c3.setParent(p1);
+			c3.setFlag(false);
+			c3.setId(rDao.save(c3));
+		}
+
+
+		{
+			// TODO populate db
+			ParentEntity p2 = new ParentEntity();
+			p2.setCapacity(2);
+			p2.setId(dao.save(p2));
+
+			ChildEntity c1 = new ChildEntity();
+			c1.setParent(p2);
+			c1.setFlag(true);
+			c1.setId(rDao.save(c1));
+
+			ChildEntity c2 = new ChildEntity();
+			c2.setParent(p2);
+			c2.setFlag(true);
+			c2.setId(rDao.save(c2));
+
+			ChildEntity c3 = new ChildEntity();
+			c3.setParent(p2);
+			c3.setFlag(false);
+			c3.setId(rDao.save(c3));
+		}
+	}
+
+
+	@Transactional
+	public void query()
+	{
+
+		final List<ParentEntity> results = dao.getByQuery(
+				"SELECT DISTINCT parent FROM parent_entity parent JOIN FETCH parent.children children JOIN parent.children child WHERE child.flag = true");
+
+		for (ParentEntity result : results)
+		{
+			System.out.println(result.getId() +
+			                   " - children " +
+			                   result.getChildren().stream().map(c -> c.getId().toString()).collect(Collectors.joining(",")));
+			assertEquals(3, result.getChildren().size());
+		}
+
+		assertEquals(2, results.size());
+	}
+
+
 	@Test
 	public void testFilledDb() throws Exception
 	{
@@ -88,7 +206,10 @@ public void testFilledDb() throws Exception
 		}
 
 		// Now none should match again
-		ids = dao.getIdsByQuery("SELECT q.id FROM parent_entity q WHERE q.capacity > (SELECT COUNT(r.id) FROM child_entity r WHERE r.parent=q.id AND r.flag=true) AND (SELECT COUNT(r.id) FROM child_entity r WHERE r.parent=q.id AND r.flag=false) <> 0");
+
+		ids = dao.getIdsByQuery(
+				"SELECT q.id FROM parent_entity q WHERE q.capacity > (SELECT COUNT(r.id) FROM child_entity r WHERE r.parent=q.id AND r.flag=true) AND (SELECT COUNT(r.id) FROM child_entity r WHERE r.parent=q.id AND r.flag=false) <> 0");
+
 		assertEquals(0, ids.size());
 	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentDao.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentDao.java
index 792f7bb1b0..e83111316e 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentDao.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentDao.java
@@ -7,9 +7,16 @@
 
 public class ParentDao extends HibernateDao<ParentEntity, Long>
 {
-	@Transactional
+	@Transactional(readOnly = true)
 	public List<Long> getIdsByQuery(String query)
 	{
 		return getIdList(createQuery(query));
 	}
+
+
+	@Transactional(readOnly = true)
+	public List<ParentEntity> getByQuery(String query)
+	{
+		return (List<ParentEntity>) getList(createQuery(query));
+	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentEntity.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentEntity.java
index a7ad2d83bf..1900f72335 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentEntity.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/hqlchildcount/ParentEntity.java
@@ -1,5 +1,7 @@
 package com.peterphi.std.guice.hibernate.hqlchildcount;
 
+import com.google.common.base.Objects;
+
 import javax.persistence.CascadeType;
 import javax.persistence.Column;
 import javax.persistence.Entity;
@@ -8,7 +10,8 @@
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
-import java.util.List;
+import java.util.HashSet;
+import java.util.Set;
 
 @Entity(name = "parent_entity")
 class ParentEntity
@@ -21,7 +24,7 @@
 	private Integer capacity;
 
 	@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "parent")
-	private List<ChildEntity> children;
+	private Set<ChildEntity> children = new HashSet<>();
 
 
 	public Long getId()
@@ -48,14 +51,21 @@ public void setCapacity(final Integer capacity)
 	}
 
 
-	public List<ChildEntity> getChildren()
+	public Set<ChildEntity> getChildren()
 	{
 		return children;
 	}
 
 
-	public void setChildren(final List<ChildEntity> children)
+	public void setChildren(final Set<ChildEntity> children)
 	{
 		this.children = children;
 	}
+
+
+	@Override
+	public String toString()
+	{
+		return Objects.toStringHelper(this).add("id", id).toString();
+	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/largetable/LargeTableQueryTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/largetable/LargeTableQueryTest.java
index 84ffcc8601..41daa24cb6 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/largetable/LargeTableQueryTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/largetable/LargeTableQueryTest.java
@@ -9,11 +9,14 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+
 import static org.junit.Assert.assertEquals;
 
 @RunWith(GuiceUnit.class)
-@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties",
-		classPackages = LargeTableQueryTest.class)
+@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties", classPackages = LargeTableQueryTest.class)
 public class LargeTableQueryTest
 {
 	@Inject
@@ -44,6 +47,32 @@ public void testSearchWorks()
 	}
 
 
+	/**
+	 * Test that searching works with ordering
+	 */
+	@Test
+	@Transactional
+	public void testSearchWorksWithOrder()
+	{
+		dao.save(new LargeTableSimplePKEntity("Alice"));
+		dao.save(new LargeTableSimplePKEntity("Bob"));
+		dao.save(new LargeTableSimplePKEntity("Carol"));
+		dao.save(new LargeTableSimplePKEntity("Dave"));
+		dao.save(new LargeTableSimplePKEntity("Eve"));
+
+		// Now try a web query
+
+		List<LargeTableSimplePKEntity> list = dao
+				                                      .findByUriQuery(new WebQuery().contains("name", "l").orderDesc("name"))
+				                                      .getList();
+
+		List<String> expected = Arrays.asList("Carol", "Alice");
+		List<String> actual = list.stream().map(e -> e.name).collect(Collectors.toList());
+
+		assertEquals(expected, actual);
+	}
+
+
 	/**
 	 * Test that searching works even with a complex primary key
 	 */
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/DynamicQueryTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/DynamicQueryTest.java
index 68fc57e859..18f53de64f 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/DynamicQueryTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/DynamicQueryTest.java
@@ -1,17 +1,23 @@
 package com.peterphi.std.guice.hibernate.webquery;
 
 import com.google.inject.Inject;
+import com.google.inject.Provider;
 import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.dao.HibernateDao;
 import com.peterphi.std.guice.hibernate.webquery.impl.QEntityFactory;
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
 import com.peterphi.std.guice.testing.GuiceUnit;
 import com.peterphi.std.guice.testing.com.peterphi.std.guice.testing.annotations.GuiceConfig;
+import org.hibernate.SessionFactory;
 import org.joda.time.DateTime;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import javax.persistence.metamodel.Attribute;
+import javax.persistence.metamodel.EntityType;
+import javax.persistence.metamodel.ManagedType;
+import javax.persistence.metamodel.Metamodel;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -19,11 +25,11 @@
 import java.util.stream.Collectors;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 @RunWith(GuiceUnit.class)
-@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties",
-		classPackages = ParentEntity.class)
+@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties", classPackages = ParentEntity.class)
 public class DynamicQueryTest
 {
 	@Inject
@@ -38,11 +44,46 @@
 	@Inject
 	QEntityFactory entityFactory;
 
+	@Inject
+	Provider<SessionFactory> sessionFactoryProvider;
+
+	@Test
+	public void testMetaModel()
+	{
+		Metamodel model = sessionFactoryProvider.get().getMetamodel();
+
+		System.out.println(model.toString());
+
+		for (ManagedType<?> type : model.getManagedTypes())
+		{
+			System.out.println();
+			System.out.println();
+			System.out.println(type.getJavaType());
+			System.out.println("----------------------------");
+			for (Attribute<?, ?> attribute : type.getAttributes())
+			{
+				System.out.println(attribute.getName() +
+				                   " - " +
+				                   attribute.getPersistentAttributeType() +
+				                   " - " +
+				                   attribute.getJavaType());
+				System.out.println("\t" + attribute);
+			}
+
+			if (type instanceof EntityType) {
+				EntityType<?> entity = (EntityType<?>) type;
+				System.out.println(entity.getIdType().getPersistenceType());
+			}
+		}
+	}
 
 	@Transactional
 	@Before
 	public void clearDatabaseBeforeTest()
 	{
+		for (ChildEntity obj : childDao.getAll())
+			childDao.delete(obj);
+
 		for (ParentEntity obj : dao.getAll())
 			dao.delete(obj);
 
@@ -76,6 +117,19 @@ public void testNestedAssociatorConstraintWorks() throws Exception
 	}
 
 
+	/**
+	 * This does not work natively with HSQLDB because HSQLDB cannot perform an ORDER BY on a column that isn't SELECTed, so this
+	 * test confirms that WebQuery is able to implement it
+	 *
+	 * @throws Exception
+	 */
+	@Test
+	public void testOrderingByLazyAssociatedRelationThatIsNotSelectedWorks() throws Exception
+	{
+		dao.findByUriQuery(new WebQuery().orderAsc("otherObject.name"));
+	}
+
+
 	@Test
 	public void testAliasedNestedAssociatorConstraintWorks() throws Exception
 	{
@@ -103,6 +157,21 @@ public void testPropertyRefWorks() throws Exception
 	}
 
 
+	@Test
+	public void testDbFetchWorks() throws Exception
+	{
+		ParentEntity obj = new ParentEntity();
+		obj.setName("Name");
+		obj.setOtherObject(new ChildEntity());
+		obj.getOtherObject().setName("Name");
+
+		childDao.save(obj.getOtherObject());
+		dao.save(obj);
+
+		dao.findByUriQuery(new WebQuery().logSQL(true).dbfetch("otherObject.parent").eq("otherObject.parent.name", "x"));
+	}
+
+
 	@Test
 	public void testEqRefReturnsValue() throws Exception
 	{
@@ -145,6 +214,25 @@ public void testGetByUniquePropertyOnCollection() throws Exception
 	}
 
 
+	@Test
+	public void testGetByUniquePropertyWithAliasOnCollection() throws Exception
+	{
+		dao.getByUniqueProperty("children[r0].id", 1L);
+	}
+
+
+	@Test
+	public void testGetUsingPropertiesOfEmbeddedCollection() throws Exception
+	{
+		// Hibernate will throw if the property doesn't work
+		WebQuery q = new WebQuery();
+		q.eq("friends[r0].firstName", "Firstname");
+		q.eq("friends[r0].lastName", "Surname");
+
+		dao.findByUriQuery(q);
+	}
+
+
 	@Test
 	public void testNestedAssociatorConstraintWorksInGetByUniqueProperty() throws Exception
 	{
@@ -175,7 +263,7 @@ public void testGetByRelationIdIsNull() throws Exception
 	public void testDynamicQuerySeesManyToOneRelation() throws IllegalArgumentException
 	{
 		// Will throw an IllegalArgumentException if the "children" field is not parsed from the entity
-		dao.findByUriQuery(new WebQuery().eq("children.id", null));
+		dao.findByUriQuery(new WebQuery().isNull("children.id"));
 	}
 
 
@@ -194,13 +282,13 @@ public void testByBooleanField() throws Exception
 			dao.save(obj2);
 		}
 
-		assertEquals("deprecated=true matches 2 rows", 2, dao.findByUriQuery(new WebQuery().eq("deprecated", true))
-		                                                     .getList()
-		                                                     .size());
+		assertEquals("deprecated=true matches 2 rows",
+		             2,
+		             dao.findByUriQuery(new WebQuery().eq("deprecated", true)).getList().size());
 
-		assertEquals("deprecated=false matches nothing", 0, dao.findByUriQuery(new WebQuery().eq("deprecated", false))
-		                                                       .getList()
-		                                                       .size());
+		assertEquals("deprecated=false matches nothing",
+		             0,
+		             dao.findByUriQuery(new WebQuery().eq("deprecated", false)).getList().size());
 	}
 
 
@@ -219,6 +307,40 @@ public void testOrderAsc() throws Exception
 	}
 
 
+	@Test
+	public void testGetIdList() throws Exception
+	{
+		ParentEntity obj1 = new ParentEntity();
+		obj1.setName("Name1");
+		dao.save(obj1);
+
+		ParentEntity obj2 = new ParentEntity();
+		obj2.setName("Name2");
+		dao.save(obj2);
+
+		assertEquals(getIds(Arrays.asList(obj1, obj2)), dao.getIdList(new WebQuery().orderAsc("id").fetch("id")));
+	}
+
+
+	@Test
+	public void testLogSQL() throws Exception
+	{
+		ParentEntity obj1 = new ParentEntity();
+		obj1.setName("Name1");
+		dao.save(obj1);
+
+		ParentEntity obj2 = new ParentEntity();
+		obj2.setName("Name2");
+		dao.save(obj2);
+
+		final ConstrainedResultSet<ParentEntity> resultset = dao.findByUriQuery(new WebQuery().orderAsc("id").logSQL(true));
+
+		assertEquals(getIds(Arrays.asList(obj1, obj2)), getIds(resultset.getList())); // must have the right answer
+		assertNotNull(resultset.getSql());
+		assertEquals("Number of SQL statements executed", 3, resultset.getSql().size());
+	}
+
+
 	@Test
 	public void testOrderDesc() throws Exception
 	{
@@ -234,8 +356,13 @@ public void testOrderDesc() throws Exception
 	}
 
 
+	/**
+	 * Tests that computing size while applying ordering and limiting to the resultset still works
+	 *
+	 * @throws Exception
+	 */
 	@Test
-	public void testComputeSize() throws Exception
+	public void testComputeSizeWithOrder() throws Exception
 	{
 		{
 			ParentEntity obj1 = new ParentEntity();
@@ -245,13 +372,25 @@ public void testComputeSize() throws Exception
 			ParentEntity obj2 = new ParentEntity();
 			obj2.setName("Name2");
 			dao.save(obj2);
+
+			ParentEntity obj3 = new ParentEntity();
+			obj3.setName("Name3");
+			dao.save(obj3);
 		}
 
 
-		ConstrainedResultSet<ParentEntity> results = dao.findByUriQuery(new WebQuery().limit(1).computeSize(true));
+		ConstrainedResultSet<ParentEntity> results = dao.findByUriQuery(new WebQuery()
+				                                                                .computeSize(true)
+				                                                                .orderDesc("name")
+				                                                                .limit(2));
+
+		// Must have correct total size
+		assertEquals("must have computed total size", Long.valueOf(3), results.getTotal());
 
-		assertEquals(1, results.getList().size());
-		assertEquals(Long.valueOf(2), results.getTotal());
+		// Must still honour limit
+		assertEquals(2, results.getList().size());
+		assertEquals(Arrays.asList("Name3", "Name2"),
+		             results.getList().stream().map(e -> e.getName()).collect(Collectors.toList()));
 	}
 
 
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/HumanEmbeddedEntity.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/HumanEmbeddedEntity.java
new file mode 100755
index 0000000000..267a23c2ab
--- /dev/null
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/HumanEmbeddedEntity.java
@@ -0,0 +1,79 @@
+package com.peterphi.std.guice.hibernate.webquery;
+
+import javax.persistence.Column;
+import javax.persistence.Embeddable;
+
+@Embeddable
+public class HumanEmbeddedEntity
+{
+	private String sortName;
+	private String firstName;
+	private String lastName;
+	private String fullName;
+
+
+	public HumanEmbeddedEntity()
+	{
+	}
+
+
+	public HumanEmbeddedEntity(final String sortName, final String firstName, final String lastName, final String fullName)
+	{
+		this.sortName = sortName;
+		this.firstName = firstName;
+		this.lastName = lastName;
+		this.fullName = fullName;
+	}
+
+
+	@Column(name = "sort_name")
+	public String getSortName()
+	{
+		return sortName;
+	}
+
+
+	public void setSortName(final String sortName)
+	{
+		this.sortName = sortName;
+	}
+
+
+	@Column(name = "first_name")
+	public String getFirstName()
+	{
+		return firstName;
+	}
+
+
+	public void setFirstName(final String firstName)
+	{
+		this.firstName = firstName;
+	}
+
+
+	@Column(name = "last_name")
+	public String getLastName()
+	{
+		return lastName;
+	}
+
+
+	public void setLastName(final String lastName)
+	{
+		this.lastName = lastName;
+	}
+
+
+	@Column(name = "full_name")
+	public String getFullName()
+	{
+		return fullName;
+	}
+
+
+	public void setFullName(final String fullName)
+	{
+		this.fullName = fullName;
+	}
+}
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/ParentEntity.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/ParentEntity.java
index 80eb48476b..89f591c309 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/ParentEntity.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/ParentEntity.java
@@ -2,7 +2,9 @@
 
 import com.peterphi.std.guice.database.annotation.SearchFieldAlias;
 
+import javax.persistence.CollectionTable;
 import javax.persistence.Column;
+import javax.persistence.ElementCollection;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.GeneratedValue;
@@ -12,11 +14,13 @@
 import javax.persistence.Lob;
 import javax.persistence.ManyToOne;
 import javax.persistence.OneToMany;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Set;
 
 @Entity
-@SearchFieldAlias(name="otherObjectParentName", aliasOf = "otherObject.parent.name")
-@SearchFieldAlias(name="otherObjectParent", aliasOf = "otherObject.parent")
+@SearchFieldAlias(name = "otherObjectParentName", aliasOf = "otherObject.parent.name")
+@SearchFieldAlias(name = "otherObjectParent", aliasOf = "otherObject.parent")
 class ParentEntity
 {
 	@Id
@@ -33,13 +37,17 @@
 	@Lob
 	private byte[] someBytes = "some bytes".getBytes();
 
-	@ManyToOne(optional = true, fetch = FetchType.EAGER)
+	@ManyToOne(optional = true, fetch = FetchType.LAZY)
 	@JoinColumn(name = "other_object_id", nullable = true)
 	private ChildEntity otherObject;
 
 	@OneToMany(mappedBy = "parent")
 	private List<ChildEntity> children;
 
+	@ElementCollection(fetch = FetchType.EAGER)
+	@CollectionTable(name = "parent_friends", joinColumns = @JoinColumn(name = "parent_id"))
+	private Set<HumanEmbeddedEntity> friends = new HashSet<>();
+
 
 	public Long getId()
 	{
@@ -111,4 +119,16 @@ public void setChildren(final List<ChildEntity> children)
 	{
 		this.children = children;
 	}
+
+
+	public Set<HumanEmbeddedEntity> getFriends()
+	{
+		return friends;
+	}
+
+
+	public void setFriends(final Set<HumanEmbeddedEntity> friends)
+	{
+		this.friends = friends;
+	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/WebQueryTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/WebQueryTest.java
index 0a5f737741..9b2bf35d1e 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/WebQueryTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/WebQueryTest.java
@@ -1,22 +1,39 @@
 package com.peterphi.std.guice.hibernate.webquery;
 
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
+import org.jboss.resteasy.spi.ResteasyUriInfo;
 import org.junit.Test;
 
+import java.net.URI;
+
+import static org.junit.Assert.assertEquals;
+
 public class WebQueryTest
 {
 	@Test
-	public void testEncode()
+	public void testEncodeResultStable()
 	{
-		new WebQuery().orderDesc("id")
-		              .orderAsc("name")
-		              .orderAsc("name2")
-		              .limit(99)
-		              .computeSize(true)
-		              .or(g -> g.eq("id", 1)
-		                        .contains("id",
-		                                  "some_value"))
-		              .eq("name", "x")
-		              .encode();
+		WebQuery query = new WebQuery()
+				                 .orderDesc("id")
+				                 .orderAsc("name")
+				                 .orderAsc("name2")
+				                 .limit(99)
+				                 .computeSize(true)
+				                 .or(g -> g.eq("id", 1).contains("id", "some_value"))
+				                 .eq("name", "x");
+
+		assertEquals(
+				"{_compute_size=[true], _expand=[all], _fetch=[entity], _order=[id desc, name asc, name2 asc], _limit=[99], _offset=[0], name=[x], id=[1, _f_contains_some_value]}",
+				query.encode().toString());
+	}
+
+
+	@Test
+	public void testParseQueryStringToWebQuery()
+	{
+		WebQuery expected = new WebQuery().logSQL(true).eq("id", "123");
+		WebQuery actual = new WebQuery().decode(new ResteasyUriInfo(URI.create("http://example.com?_log_sql=true&id=123")));
+
+		assertEquals(expected.encode().toString(), actual.encode().toString());
 	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/DiscriminatorDynamicQueryTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/DiscriminatorDynamicQueryTest.java
index 08174d10cd..9b840c3882 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/DiscriminatorDynamicQueryTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/DiscriminatorDynamicQueryTest.java
@@ -9,12 +9,13 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import java.util.List;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 @RunWith(GuiceUnit.class)
-@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties",
-		            classPackages = MyBaseObject.class)
+@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties", classPackages = MyBaseObject.class)
 public class DiscriminatorDynamicQueryTest
 {
 	@Inject
@@ -36,6 +37,28 @@ public void testHibernateSubclassSupport()
 	}
 
 
+	/**
+	 * Tests that if we specify a subclass then the fields from that subclass become available (also true for a collection of
+	 * subclasses in a nested hierarchy, but that complex hierarchy is rarely used in the db so we don't have a test for it)
+	 */
+	@Test
+	public void testDiscriminatorInWebQueryAllowsUseOfSubclassFields()
+	{
+		MyChildObject1 a = new MyChildObject1();
+
+		MyChildObject2 b = new MyChildObject2();
+
+		a.id = dao.save(a);
+		b.id = dao.save(b);
+
+
+		final List<MyBaseObject> results = dao.findByUriQuery(new WebQuery().subclass("one").eq("someId", a.someId)).getList();
+
+		assertEquals("should match exactly 1 entity", 1, results.size());
+		assertEquals("should match the first child object stored", a.id, results.get(0).id);
+	}
+
+
 	@Test
 	public void testDiscriminatorInWebQuery()
 	{
@@ -47,10 +70,11 @@ public void testDiscriminatorInWebQuery()
 
 		{
 			// We'd get a org.hibernate.QueryException if Hibernate doesn't understand
-			ConstrainedResultSet<MyBaseObject> results = dao.findByUriQuery(new WebQuery().eq("id",
-			                                                                                  String.valueOf(a.id),
-			                                                                                  String.valueOf(b.id))
-			                                                                              .subclass("one"));
+			ConstrainedResultSet<MyBaseObject> results = dao.findByUriQuery(new WebQuery()
+					                                                                .eq("id",
+					                                                                    String.valueOf(a.id),
+					                                                                    String.valueOf(b.id))
+					                                                                .subclass("one"));
 
 			assertEquals("discriminator should match exactly one entity", 1, results.getList().size());
 			assertEquals(a.id, results.getList().get(0).id);
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/MyChildObject1.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/MyChildObject1.java
index beff0039f6..30b4852a5f 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/MyChildObject1.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/discriminatortest/MyChildObject1.java
@@ -1,10 +1,14 @@
 package com.peterphi.std.guice.hibernate.webquery.discriminatortest;
 
+import javax.persistence.Column;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.Entity;
+import java.util.UUID;
 
-@Entity(name="inherit_one")
+@Entity(name = "inherit_one")
 @DiscriminatorValue("one")
 class MyChildObject1 extends MyBaseObject
 {
+	@Column(nullable = true)
+	String someId = UUID.randomUUID().toString();
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/DynamicQueryEmbeddedPkTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/DynamicQueryEmbeddedPkTest.java
index 1bfd0ed2d9..9b439d343e 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/DynamicQueryEmbeddedPkTest.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/DynamicQueryEmbeddedPkTest.java
@@ -12,14 +12,12 @@
  * Tests searching for entities with Embedded primary keys
  */
 @RunWith(GuiceUnit.class)
-@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties",
-		            classPackages = EmbeddedPkEntity.class)
+@GuiceConfig(config = "hibernate-tests-in-memory-hsqldb.properties", classPackages = EmbeddedPkEntity.class)
 public class DynamicQueryEmbeddedPkTest
 {
 	@Inject
 	EmbeddedPkDaoImpl dao;
 
-
 	/**
 	 * Test that searching by timestamp alone works
 	 *
@@ -29,7 +27,7 @@
 	public void testSearchByTimestamp()
 	{
 		// We'll get an exception if the property isn't understood
-		dao.findByUriQuery(new WebQuery().eq("timestamp", 123));
+		dao.findByUriQuery(new WebQuery().eq("id:timestamp", 123));
 	}
 
 
@@ -44,7 +42,7 @@ public void testSearchByTimestamp()
 	public void testSearchByIdAndTimestamp()
 	{
 		// We'll get an exception if the property isn't understood
-		dao.findByUriQuery(new WebQuery().eq("id", 123).eq("timestamp", 123));
+		dao.findByUriQuery(new WebQuery().eq("id:id", 123).eq("id:timestamp", 123));
 	}
 
 
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/EmbeddedPkDaoImpl.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/EmbeddedPkDaoImpl.java
index e2309aee4c..c35f4f1338 100755
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/EmbeddedPkDaoImpl.java
+++ b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/embeddedpktest/EmbeddedPkDaoImpl.java
@@ -1,5 +1,6 @@
 package com.peterphi.std.guice.hibernate.webquery.embeddedpktest;
 
+import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.dao.HibernateDao;
 import org.hibernate.Criteria;
 import org.hibernate.criterion.Restrictions;
@@ -16,4 +17,11 @@
 
 		return getList(criteria);
 	}
+
+
+	@Transactional
+	public List<EmbeddedPkEntity> runQuery(String query)
+	{
+		return createQuery(query).list();
+	}
 }
diff --git a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BetweenTest.java b/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BetweenTest.java
deleted file mode 100755
index 29534b4ebc..0000000000
--- a/guice/hibernate/src/test/java/com/peterphi/std/guice/hibernate/webquery/impl/functions/BetweenTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-package com.peterphi.std.guice.hibernate.webquery.impl.functions;
-
-import com.peterphi.std.guice.hibernate.webquery.impl.QProperty;
-import com.peterphi.std.guice.hibernate.webquery.impl.QPropertyRef;
-import com.peterphi.std.guice.hibernate.webquery.impl.QRelation;
-import com.peterphi.std.guice.hibernate.webquery.impl.QSizeProperty;
-import org.hibernate.criterion.Criterion;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-public class BetweenTest
-{
-	@Test
-	public void testBinaryRange()
-	{
-		final QProperty prop = new QProperty(null, null, "x", Integer.class, false);
-		final QPropertyRef ref = new QPropertyRef(null, prop);
-
-		final Criterion criterion = new Between(ref, "1","2").encode();
-
-		assertEquals("x between 1 and 2", criterion.toString());
-	}
-
-
-	@Test
-	public void testBinarySizeRange()
-	{
-		final QRelation relation = new QRelation(null, null, "children", null, false);
-		final QSizeProperty prop = new QSizeProperty(relation);
-		final QPropertyRef ref = new QPropertyRef(null, prop);
-
-		final Criterion criterion = new Between(ref, "1","2").encode();
-
-		// N.B. the toString of size restrictions is incorrect due to HHH-9869 so this looks wrong
-		assertEquals("1<=children.size and 2>=children.size", criterion.toString());
-	}
-
-
-	@Test
-	public void testLeftOnlyRange()
-	{
-		final QProperty prop = new QProperty(null, null, "x", Integer.class, false);
-		final QPropertyRef ref = new QPropertyRef(null, prop);
-
-		final Criterion criterion = new Between(ref, "1","").encode();
-
-		assertEquals("x>=1", criterion.toString());
-	}
-
-
-	@Test
-	public void testRightOnlyRange()
-	{
-		final QProperty prop = new QProperty(null, null, "x", Integer.class, false);
-		final QPropertyRef ref = new QPropertyRef(null, prop);
-
-		final Criterion criterion = new Between(ref,"", "1").encode();
-
-		assertEquals("x<=1", criterion.toString());
-	}
-}
diff --git a/guice/hibernate/src/test/resources/hibernate-tests-in-memory-hsqldb.properties b/guice/hibernate/src/test/resources/hibernate-tests-in-memory-hsqldb.properties
index f3adbba56a..a18a13c035 100755
--- a/guice/hibernate/src/test/resources/hibernate-tests-in-memory-hsqldb.properties
+++ b/guice/hibernate/src/test/resources/hibernate-tests-in-memory-hsqldb.properties
@@ -7,6 +7,8 @@ hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.hbm2ddl.auto=create
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=true
 hibernate.current_session_context_class=thread
diff --git a/guice/liquibase/pom.xml b/guice/liquibase/pom.xml
index 1669eccdea..00435568b2 100755
--- a/guice/liquibase/pom.xml
+++ b/guice/liquibase/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-liquibase</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice liquibase support</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
@@ -28,7 +28,12 @@
 			<artifactId>stdlib-guice-webapp</artifactId>
 			<version>${project.version}</version>
 		</dependency>
-		
+		<dependency>
+			<groupId>com.peterphi.std.guice</groupId>
+			<artifactId>stdlib-guice-common</artifactId>
+			<version>${project.version}</version>
+		</dependency>
+
 		<dependency>
 			<groupId>javax.servlet</groupId>
 			<artifactId>javax.servlet-api</artifactId>
@@ -39,7 +44,7 @@
 		<dependency>
 			<groupId>org.liquibase</groupId>
 			<artifactId>liquibase-core</artifactId>
-			<version>3.4.1</version>
+			<version>3.5.3</version>
 		</dependency>
 
 
diff --git a/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/LiquibaseAction.java b/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/LiquibaseAction.java
index a490f2a62f..dcbe82d442 100755
--- a/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/LiquibaseAction.java
+++ b/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/LiquibaseAction.java
@@ -18,7 +18,12 @@
 	 * Mark that all pending changesets have been applied without actually executing any of their logic (this is "changeLogSync"
 	 * at the liquibase command-line)
 	 */
-	MARK_UPDATED;
+	MARK_UPDATED,
+
+	/**
+	 * Generate a changelog XML and dump it to stdout
+	 */
+	GENERATE_CHANGELOG;
 
 
 	public boolean isWriteAction()
diff --git a/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/hibernate/LiquibaseCore.java b/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/hibernate/LiquibaseCore.java
index d1fc4f4096..1962c9b3bb 100755
--- a/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/hibernate/LiquibaseCore.java
+++ b/guice/liquibase/src/main/java/com/peterphi/std/guice/liquibase/hibernate/LiquibaseCore.java
@@ -4,6 +4,7 @@
 import com.peterphi.std.guice.common.serviceprops.composite.GuiceConfig;
 import com.peterphi.std.guice.liquibase.LiquibaseAction;
 import com.peterphi.std.guice.liquibase.exception.LiquibaseChangesetsPending;
+import liquibase.CatalogAndSchema;
 import liquibase.Contexts;
 import liquibase.LabelExpression;
 import liquibase.Liquibase;
@@ -12,6 +13,9 @@
 import liquibase.database.Database;
 import liquibase.database.DatabaseFactory;
 import liquibase.database.jvm.JdbcConnection;
+import liquibase.diff.compare.CompareControl;
+import liquibase.diff.output.DiffOutputControl;
+import liquibase.diff.output.changelog.DiffToChangeLog;
 import liquibase.exception.LiquibaseException;
 import liquibase.logging.LogFactory;
 import liquibase.resource.ClassLoaderResourceAccessor;
@@ -25,6 +29,10 @@
 import javax.naming.InitialContext;
 import javax.naming.NamingException;
 import javax.sql.DataSource;
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;
@@ -131,7 +139,7 @@ public static void execute(final GuiceConfig applicationConfiguration,
 	private static void executeAction(InitialContext jndi,
 	                                  GuiceApplicationValueContainer config,
 	                                  Map<String, String> parameters,
-	                                  LiquibaseAction action) throws NamingException, SQLException, LiquibaseException
+	                                  LiquibaseAction action) throws NamingException, SQLException, LiquibaseException, IOException, ParserConfigurationException
 	{
 		// Make sure we don't execute any write actions if the database connection is set to read-only
 		// N.B. liquibase may create a databasechangeloglock / databasechangelog table if one does not already exist
@@ -144,7 +152,7 @@ private static void executeAction(InitialContext jndi,
 		}
 
 		// Fail if hbm2ddl is enabled (Hibernate should not be involved in schema management)
-		if (StringUtils.isNotEmpty(config.getValue(HIBERNATE_SCHEMA_MANAGEMENT)))
+		if (StringUtils.isNotEmpty(config.getValue(HIBERNATE_SCHEMA_MANAGEMENT)) && action != LiquibaseAction.GENERATE_CHANGELOG)
 		{
 			throw new RuntimeException("Liquibase is enabled but so is " +
 			                           HIBERNATE_SCHEMA_MANAGEMENT +
@@ -252,6 +260,21 @@ else if (changeLogFile == null)
 					// Mark all pending changesets as run
 					liquibase.changeLogSync(new Contexts(contexts), new LabelExpression(labels));
 					return;
+				case GENERATE_CHANGELOG:
+					CatalogAndSchema catalogueAndSchema = CatalogAndSchema.DEFAULT;
+					DiffToChangeLog writer = new DiffToChangeLog(new DiffOutputControl(false,
+					                                                                   false,
+					                                                                   false,
+					                                                                   new CompareControl.SchemaComparison[0]));
+
+					ByteArrayOutputStream bos = new ByteArrayOutputStream();
+					PrintStream pw = new PrintStream(bos);
+					liquibase.generateChangeLog(catalogueAndSchema, writer, pw);
+
+					System.out.println("********** GENERATED CHANGELOG START **********");
+					System.out.println(new String(bos.toByteArray()));
+					System.out.println("********** GENERATED CHANGELOG END **********");
+					break;
 				default:
 					throw new RuntimeException("Unknown liquibase action: " + action);
 			}
diff --git a/guice/liquibase/src/test/resources/liquibase-hibernate-tests-in-memory-hsqldb.properties b/guice/liquibase/src/test/resources/liquibase-hibernate-tests-in-memory-hsqldb.properties
index fb28a370d2..c73d504b0d 100755
--- a/guice/liquibase/src/test/resources/liquibase-hibernate-tests-in-memory-hsqldb.properties
+++ b/guice/liquibase/src/test/resources/liquibase-hibernate-tests-in-memory-hsqldb.properties
@@ -6,6 +6,8 @@ hibernate.connection.url=jdbc:hsqldb:mem:testdb
 hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=true
 hibernate.current_session_context_class=thread
diff --git a/guice/metrics/pom.xml b/guice/metrics/pom.xml
index 85a793b6b3..d9bd755049 100755
--- a/guice/metrics/pom.xml
+++ b/guice/metrics/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-metrics</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice metrics</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<properties>
diff --git a/guice/metrics/src/main/java/com/peterphi/std/guice/metrics/rest/impl/MetricSerialiser.java b/guice/metrics/src/main/java/com/peterphi/std/guice/metrics/rest/impl/MetricSerialiser.java
index 27630a3219..b24fbb87b7 100755
--- a/guice/metrics/src/main/java/com/peterphi/std/guice/metrics/rest/impl/MetricSerialiser.java
+++ b/guice/metrics/src/main/java/com/peterphi/std/guice/metrics/rest/impl/MetricSerialiser.java
@@ -18,7 +18,7 @@
 import java.util.Map;
 import java.util.SortedMap;
 
-class MetricSerialiser
+public class MetricSerialiser
 {
 	public MetricsHistogram serialise(String name, Histogram histo)
 	{
diff --git a/guice/pom.xml b/guice/pom.xml
index 325dec80a1..b067829355 100755
--- a/guice/pom.xml
+++ b/guice/pom.xml
@@ -4,7 +4,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-parent</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>pom</packaging>
 
 	<name>application framework guice modules parent</name>
@@ -13,7 +13,7 @@
 	<parent>
 		<groupId>com.peterphi.std</groupId>
 		<artifactId>stdlib-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencyManagement>
diff --git a/guice/testing/pom.xml b/guice/testing/pom.xml
index e59d4a9a3b..7ae5fa996f 100755
--- a/guice/testing/pom.xml
+++ b/guice/testing/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-testing</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice testing support</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/guice/webapp/pom.xml b/guice/webapp/pom.xml
index 759931c9ac..8f591dbd44 100755
--- a/guice/webapp/pom.xml
+++ b/guice/webapp/pom.xml
@@ -5,7 +5,7 @@
 
 	<groupId>com.peterphi.std.guice</groupId>
 	<artifactId>stdlib-guice-webapp</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>stdlib guice webapp</name>
@@ -14,7 +14,7 @@
 	<parent>
 		<groupId>com.peterphi.std.guice</groupId>
 		<artifactId>stdlib-guice-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
@@ -69,6 +69,11 @@
 				</exclusion>
 			</exclusions>
 		</dependency>
+		<dependency>
+			<groupId>org.jboss.logging</groupId>
+			<artifactId>jboss-logging</artifactId>
+			<version>3.3.0.Final</version>
+		</dependency>
 		<dependency>
 			<groupId>org.jboss.resteasy</groupId>
 			<artifactId>resteasy-jettison-provider</artifactId>
diff --git a/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/oauth2/OAuth2SessionRef.java b/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/oauth2/OAuth2SessionRef.java
index 2d810ee743..12d1760389 100755
--- a/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/oauth2/OAuth2SessionRef.java
+++ b/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/oauth2/OAuth2SessionRef.java
@@ -13,6 +13,7 @@
 
 import javax.ws.rs.core.UriBuilder;
 import java.net.URI;
+import java.util.Base64;
 
 /**
  * Holds the OAuth2 callback information for this session; will start unpopulated (see {@link #isValid()}) and then be populated
@@ -110,17 +111,38 @@ public URI getAuthFlowStartEndpoint(final String returnTo, final String scope)
 		builder.replaceQueryParam("response_type", "code");
 		builder.replaceQueryParam("client_id", clientId);
 		builder.replaceQueryParam("redirect_uri", getOwnCallbackUri());
-
 		if (scope != null)
 			builder.replaceQueryParam("scope", scope);
 
 		if (returnTo != null)
-			builder.replaceQueryParam("state", callbackNonce + " " + returnTo);
+			builder.replaceQueryParam("state", encodeState(callbackNonce + " " + returnTo));
 
 		return builder.build();
 	}
 
 
+	/**
+	 * Encode the state value into RFC $648 URL-safe base64
+	 * @param src
+	 * @return
+	 */
+	private String encodeState(final String src)
+	{
+		return Base64.getUrlEncoder().encodeToString(src.getBytes());
+	}
+
+
+	/**
+	 * Decode the state value (which should be encoded as RFC 4648 URL-safe base64)
+	 * @param src
+	 * @return
+	 */
+	private String decodeState(final String src)
+	{
+		return new String(Base64.getUrlDecoder().decode(src));
+	}
+
+
 	/**
 	 * Decode the state to retrieve the redirectTo value
 	 *
@@ -130,7 +152,7 @@ public URI getAuthFlowStartEndpoint(final String returnTo, final String scope)
 	 */
 	public URI getRedirectToFromState(final String state)
 	{
-		final String[] pieces = state.split(" ", 2);
+		final String[] pieces = decodeState(state).split(" ", 2);
 
 		if (!StringUtils.equals(callbackNonce, pieces[0]))
 			throw new IllegalArgumentException("WARNING: This service received an authorisation approval which it did not initiate, someone may be trying to compromise your account security");
diff --git a/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/userprovider/WebappAuthenticationModule.java b/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/userprovider/WebappAuthenticationModule.java
index 82a10a57eb..f19f5f2632 100755
--- a/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/userprovider/WebappAuthenticationModule.java
+++ b/guice/webapp/src/main/java/com/peterphi/std/guice/web/rest/auth/userprovider/WebappAuthenticationModule.java
@@ -67,6 +67,7 @@ protected void configure()
 	@SessionScoped
 	public CurrentUser getCurrentUser(Injector injector, HttpServletRequest request)
 	{
+
 		for (String providerName : providerNames)
 		{
 			final Provider<CurrentUser> provider = injector.getProvider(Key.get(CurrentUser.class, Names.named(providerName)));
diff --git a/pom.xml b/pom.xml
index 0e30a81320..97973d45ba 100755
--- a/pom.xml
+++ b/pom.xml
@@ -10,7 +10,7 @@
 
 	<groupId>com.peterphi.std</groupId>
 	<artifactId>stdlib-parent</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>pom</packaging>
 
 	<name>application framework parent</name>
@@ -46,7 +46,7 @@
 		<metrics.version>3.0.2</metrics.version>
 		<resteasy.version>3.0.19.Final</resteasy.version>
 		<javassist.version>3.19.0-GA</javassist.version>
-		<hibernate.version>5.0.2.Final</hibernate.version>
+		<hibernate.version>5.2.10.Final</hibernate.version>
 		<dbunit.version>2.5.1</dbunit.version>
 		<hsqldb.version>2.3.2</hsqldb.version>
 		<bouncycastle.version>1.55</bouncycastle.version>
diff --git a/release.sh b/release.sh
index 0cc3ad96f1..359369e5cb 100755
--- a/release.sh
+++ b/release.sh
@@ -195,7 +195,7 @@ echo ""
 
 
 # build and deploy the release
-$MVN -DperformRelease=true clean deploy || rollback_and_die_with "Build/Deploy failure. Release failed."
+$MVN -DperformRelease=true clean deploy -pl "!service-manager/host-agent, !service-manager/service-manager, !user-manager/service, !service-manager/configuration" || rollback_and_die_with "Build/Deploy failure. Release failed."
 
 # tag the release (N.B. should this be before perform the release?)
 git tag "v${RELEASE_VERSION}" || die_with "Failed to create tag ${RELEASE_VERSION}! Release has been deployed, however"
diff --git a/rules/pom.xml b/rules/pom.xml
index 6401b2284c..ec319dacec 100755
--- a/rules/pom.xml
+++ b/rules/pom.xml
@@ -5,7 +5,7 @@
 	<parent>
 		<artifactId>stdlib-parent</artifactId>
 		<groupId>com.peterphi.std</groupId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 	<modelVersion>4.0.0</modelVersion>
 
diff --git a/rules/src/main/java/com/peterphi/rules/daemon/RulesDaemon.java b/rules/src/main/java/com/peterphi/rules/daemon/RulesDaemon.java
index 97d67308fe..7ed78045e4 100755
--- a/rules/src/main/java/com/peterphi/rules/daemon/RulesDaemon.java
+++ b/rules/src/main/java/com/peterphi/rules/daemon/RulesDaemon.java
@@ -4,18 +4,13 @@
 import com.google.inject.Provider;
 import com.google.inject.name.Named;
 import com.peterphi.rules.RulesEngine;
-import com.peterphi.rules.types.RuleSet;
 import com.peterphi.rules.types.Rules;
 import com.peterphi.std.annotation.Doc;
-import com.peterphi.std.guice.common.daemon.GuiceDaemon;
 import com.peterphi.std.guice.common.daemon.GuiceRecurringDaemon;
 import com.peterphi.std.guice.common.lifecycle.GuiceLifecycleListener;
-import com.peterphi.std.guice.common.metrics.GuiceMetricNames;
 import com.peterphi.std.guice.common.serviceprops.composite.GuiceConfig;
 import com.peterphi.std.guice.common.serviceprops.composite.GuiceConfigChangeObserver;
-import com.peterphi.std.guice.common.serviceprops.jaxbref.JAXBResourceFactory;
 import com.peterphi.std.threading.Timeout;
-import ognl.OgnlException;
 
 /**
  * Created by bmcleod on 08/09/2016.
@@ -38,14 +33,18 @@
 	@Inject
 	GuiceConfig guiceConfig;
 
+	@Inject(optional = true)
+	@Named("daemon.RulesDaemon.enabled")
 	boolean enabled = true;
 
+
 	@Inject
 	protected RulesDaemon(@Named("rules.daemon.sleep.time") final Timeout sleepTime)
 	{
 		super(sleepTime);
 	}
 
+
 	@Override
 	public void postConstruct()
 	{
@@ -53,9 +52,13 @@ public void postConstruct()
 		guiceConfig.registerChangeObserver(this);
 	}
 
+
 	@Override
 	protected void execute() throws Exception
 	{
+		if (!enabled)
+			return; // We have been disabled
+
 		Rules rules = rulesProvider.get();
 		rulesEngine.run(rules, true);
 	}
diff --git a/service-manager/configuration/pom.xml b/service-manager/configuration/pom.xml
index 4d569ec169..bca3e7c0bc 100755
--- a/service-manager/configuration/pom.xml
+++ b/service-manager/configuration/pom.xml
@@ -10,7 +10,7 @@
 	<parent>
 		<groupId>com.peterphi.std.config</groupId>
 		<artifactId>service-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/service-manager/configuration/src/test/resources/hibernate-hsqldb-in-memory.properties b/service-manager/configuration/src/test/resources/hibernate-hsqldb-in-memory.properties
index b9a03ab878..67cd45a128 100755
--- a/service-manager/configuration/src/test/resources/hibernate-hsqldb-in-memory.properties
+++ b/service-manager/configuration/src/test/resources/hibernate-hsqldb-in-memory.properties
@@ -6,6 +6,8 @@ hibernate.connection.url=jdbc:hsqldb:mem:testdb
 hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=false
 hibernate.current_session_context_class=thread
diff --git a/service-manager/host-agent/pom.xml b/service-manager/host-agent/pom.xml
index 1b67cdb4ba..c512cc854c 100755
--- a/service-manager/host-agent/pom.xml
+++ b/service-manager/host-agent/pom.xml
@@ -10,7 +10,7 @@
 	<parent>
 		<groupId>com.peterphi.std.config</groupId>
 		<artifactId>service-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/service-manager/pom.xml b/service-manager/pom.xml
index 7e9ca3b6cf..1686c3dfc6 100755
--- a/service-manager/pom.xml
+++ b/service-manager/pom.xml
@@ -11,7 +11,7 @@
 	<parent>
 		<groupId>com.peterphi.std</groupId>
 		<artifactId>stdlib-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<modules>
diff --git a/service-manager/service-manager-api/pom.xml b/service-manager/service-manager-api/pom.xml
index 0a8e9dc729..b2771a491e 100755
--- a/service-manager/service-manager-api/pom.xml
+++ b/service-manager/service-manager-api/pom.xml
@@ -10,7 +10,7 @@
 	<parent>
 		<groupId>com.peterphi.std.config</groupId>
 		<artifactId>service-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/service-manager/service-manager/pom.xml b/service-manager/service-manager/pom.xml
index ea24468707..7d9e42de3e 100755
--- a/service-manager/service-manager/pom.xml
+++ b/service-manager/service-manager/pom.xml
@@ -11,7 +11,7 @@
 	<parent>
 		<groupId>com.peterphi.std.config</groupId>
 		<artifactId>service-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/service-manager/service-manager/src/main/java/com/peterphi/servicemanager/service/rest/impl/ServiceManagerRegistryRestServiceImpl.java b/service-manager/service-manager/src/main/java/com/peterphi/servicemanager/service/rest/impl/ServiceManagerRegistryRestServiceImpl.java
index 21c4b57827..a4a199a265 100755
--- a/service-manager/service-manager/src/main/java/com/peterphi/servicemanager/service/rest/impl/ServiceManagerRegistryRestServiceImpl.java
+++ b/service-manager/service-manager/src/main/java/com/peterphi/servicemanager/service/rest/impl/ServiceManagerRegistryRestServiceImpl.java
@@ -5,7 +5,6 @@
 import com.peterphi.servicemanager.service.db.dao.impl.ServiceInstanceDaoImpl;
 import com.peterphi.servicemanager.service.db.entity.ServiceInstanceEntity;
 import com.peterphi.std.guice.common.logging.rest.iface.ServiceManagerRegistryRestService;
-import com.peterphi.std.guice.common.retry.annotation.Retry;
 import com.peterphi.std.guice.database.annotation.Transactional;
 
 @Singleton
@@ -20,7 +19,6 @@
 
 	@Override
 	@Transactional
-	@Retry
 	public void register(final String instanceId, final String endpoint, final String managementToken, final String codeRevision)
 	{
 		ServiceInstanceEntity entity = dao.getById(instanceId);
diff --git a/service-manager/service-manager/src/test/resources/service-manager-hsqldb-in-memory.properties b/service-manager/service-manager/src/test/resources/service-manager-hsqldb-in-memory.properties
index fa28f54e16..a14c5794d8 100755
--- a/service-manager/service-manager/src/test/resources/service-manager-hsqldb-in-memory.properties
+++ b/service-manager/service-manager/src/test/resources/service-manager-hsqldb-in-memory.properties
@@ -7,6 +7,8 @@ hibernate.connection.url=jdbc:hsqldb:mem:testdb
 hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=false
 hibernate.current_session_context_class=thread
diff --git a/stdlib/pom.xml b/stdlib/pom.xml
index b1280f00e3..5cde444738 100755
--- a/stdlib/pom.xml
+++ b/stdlib/pom.xml
@@ -5,14 +5,14 @@
 	<groupId>com.peterphi.std</groupId>
 	<artifactId>stdlib</artifactId>
 	<packaging>jar</packaging>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<name>stdlib</name>
 	<description>Utility API</description>
 
 	<parent>
 		<groupId>com.peterphi.std</groupId>
 		<artifactId>stdlib-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
@@ -89,7 +89,7 @@
 		<dependency>
 			<groupId>org.eclipse.persistence</groupId>
 			<artifactId>org.eclipse.persistence.moxy</artifactId>
-			<version>2.6.2</version>
+			<version>2.6.4</version>
 		</dependency>
 	</dependencies>
 </project>
diff --git a/stdlib/src/main/java/com/peterphi/std/io/PropertyFile.java b/stdlib/src/main/java/com/peterphi/std/io/PropertyFile.java
index cd22de2b37..d2637c44ff 100755
--- a/stdlib/src/main/java/com/peterphi/std/io/PropertyFile.java
+++ b/stdlib/src/main/java/com/peterphi/std/io/PropertyFile.java
@@ -593,9 +593,6 @@ public void makeReadOnly()
 
 	public boolean containsKey(final String name)
 	{
-		if (log.isTraceEnabled())
-			log.trace("{containsKey} key=" + name);
-
 		return _contains(name);
 	}
 
@@ -608,14 +605,6 @@ public String get(final String name)
 
 	public String get(final String name, final String defaultValue)
 	{
-		if (log.isTraceEnabled())
-			log.trace("{get} key=" +
-			          name +
-			          "; default=" +
-			          defaultValue +
-			          "; storedValue=" +
-			          _get_core(name, null));
-
 		return _get(name, defaultValue);
 	}
 
@@ -800,9 +789,6 @@ else if (uri == null)
 
 	public String set(final String name, final String value)
 	{
-		if (log.isTraceEnabled())
-			log.trace("{set} key=" + name + "; value=" + value);
-
 		return _set(name, value);
 	}
 
@@ -835,9 +821,6 @@ public String set(final String name, final int value)
 
 	public void remove(final String name)
 	{
-		if (log.isTraceEnabled())
-			log.trace("{remove} key=" + name);
-
 		_rm(name);
 	}
 
diff --git a/stdlib/src/main/java/com/peterphi/std/types/Timebase.java b/stdlib/src/main/java/com/peterphi/std/types/Timebase.java
index 038bdc9c93..36b583feb9 100755
--- a/stdlib/src/main/java/com/peterphi/std/types/Timebase.java
+++ b/stdlib/src/main/java/com/peterphi/std/types/Timebase.java
@@ -87,6 +87,23 @@ public int getDenominator()
 	}
 
 
+	public boolean isIntegerRate()
+	{
+		if (numerator == 1)
+			return true;
+		else if (this.equals(NTSC))
+			return false;
+		else
+			return Math.ceil(getSamplesPerSecond()) == Math.floor(getSamplesPerSecond());
+	}
+
+
+	public boolean isDropFrame()
+	{
+		return !isIntegerRate();
+	}
+
+
 	/**
 	 * The number of samples each second
 	 *
@@ -99,13 +116,13 @@ public double getSamplesPerSecond()
 
 
 	/**
-	 * Samples per second, cast to an integer (accurate only if the numerator is 1)
+	 * Samples per second, cast to an integer (rounded in the case of fractional frames per second)
 	 *
 	 * @return
 	 */
 	public int getIntSamplesPerSecond()
 	{
-		return (int) getSamplesPerSecond();
+		return (int) Math.round(getSamplesPerSecond());
 	}
 
 
@@ -176,8 +193,8 @@ public long resample(final long samples, final Timebase oldRate, boolean failOnP
 		final double resampled = resample((double) samples, oldRate);
 		final double rounded = Math.round(resampled);
 
-		// Warn about any loss in precision
-		if (resampled != rounded)
+		// Warn about significant loss of precision
+		if (resampled != rounded && Math.abs(rounded - resampled) > 0.000001)
 		{
 			if (failOnPrecisionLoss)
 			{
@@ -199,7 +216,9 @@ public long resample(final long samples, final Timebase oldRate, boolean failOnP
 				         " to " +
 				         this +
 				         " produced " +
-				         resampled + " which will be rounded to " + rounded);
+				         resampled +
+				         " which will be rounded to " +
+				         rounded);
 			}
 		}
 
diff --git a/stdlib/src/main/java/com/peterphi/std/types/Timecode.java b/stdlib/src/main/java/com/peterphi/std/types/Timecode.java
index 87ec2ea308..4516fcf8fb 100755
--- a/stdlib/src/main/java/com/peterphi/std/types/Timecode.java
+++ b/stdlib/src/main/java/com/peterphi/std/types/Timecode.java
@@ -122,30 +122,41 @@ public long getDurationInFrames()
 	 */
 	public long getDurationInFrames(boolean allowDropFrameRemoval)
 	{
-		final double fps = this.timebase.getSamplesPerSecond();
+		final long totalFrames = getFrameNumber(hours + (days * 24),
+		                                        minutes,
+		                                        seconds,
+		                                        frames,
+		                                        dropFrame,
+		                                        timebase.getSamplesPerSecond());
 
-		double totalFrames = frames;
+		// Flip the sign if negative
+		if (negative)
+			return totalFrames * -1;
+		else
+			return totalFrames;
+	}
 
-		totalFrames += seconds * fps;
-		totalFrames += (minutes * 60) * fps;
-		totalFrames += (hours * 60 * 60) * fps;
-		totalFrames += (days * 24 * 60 * 60) * fps;
 
-		if (dropFrame && allowDropFrameRemoval)
-		{
-			// remove the drop frames
-			long totalMins = (hours * 60) + minutes;
-			long dropFrames = (totalMins * 2) - ((totalMins / 10) * 2);
-			totalFrames -= dropFrames;
-		}
+	static long getFrameNumber(final long hours,
+	                           final long minutes,
+	                           final long seconds,
+	                           final long frames,
+	                           final boolean dropFrame,
+	                           final double framerate)
+	{
+		//Code by David Heidelberger, adapted from Andrew Duncan
 
-		// Flip the sign if negative
-		if (negative)
-		{
-			totalFrames = totalFrames * -1;
-		}
+		long dropFrames = dropFrame ?
+		                  Math.round(framerate * .066666) :
+		                  0; //Number of drop frames is 6% of framerate rounded to nearest integer
+		long timeBase = Math.round(framerate); //We don't need the exact framerate anymore, we just need it rounded to nearest integer
 
-		return Math.round(totalFrames);
+		long hourFrames = timeBase * 60 * 60; //Number of frames per hour (non-drop)
+		long minuteFrames = timeBase * 60; //Number of frames per minute (non-drop)
+		long totalMinutes = (60 * hours) + minutes; //Total number of minutes
+		long frameNumber = ((hourFrames * hours) + (minuteFrames * minutes) + (timeBase * seconds) + frames) -
+		                   (dropFrames * (totalMinutes - (totalMinutes / 10)));
+		return frameNumber;
 	}
 
 
@@ -674,7 +685,7 @@ public String toString()
 	 */
 	public static final Timecode getInstance(long frameNumber, boolean dropFrame, Timebase timebase)
 	{
-		return TimecodeBuilder.fromFrames(frameNumber, dropFrame, timebase).build();
+		return TimecodeBuilder.fromFrames(frameNumber, timebase).withDropFrame(dropFrame).build();
 	}
 
 
diff --git a/stdlib/src/main/java/com/peterphi/std/types/TimecodeBuilder.java b/stdlib/src/main/java/com/peterphi/std/types/TimecodeBuilder.java
index ea482b5eab..b375aaa459 100755
--- a/stdlib/src/main/java/com/peterphi/std/types/TimecodeBuilder.java
+++ b/stdlib/src/main/java/com/peterphi/std/types/TimecodeBuilder.java
@@ -10,8 +10,6 @@
  */
 public class TimecodeBuilder
 {
-	private static final int DROP_FRAMES_PER_TEN_MIN = 9 * 2;
-
 	private boolean negative = false;
 	private long days = 0;
 	private long hours = 0;
@@ -19,7 +17,7 @@
 	private long seconds = 0;
 	private long frames = 0;
 	private Timebase rate = null;
-	private boolean dropFrame = false;
+	private Boolean dropFrame;
 
 
 	/**
@@ -31,14 +29,15 @@
 	 */
 	public TimecodeBuilder withTimecode(Timecode timecode)
 	{
-		return this.withNegative(timecode.isNegative())
-		           .withDays(timecode.getDaysPart())
-		           .withHours(timecode.getHoursPart())
-		           .withMinutes(timecode.getMinutesPart())
-		           .withSeconds(timecode.getSecondsPart())
-		           .withFrames(timecode.getFramesPart())
-		           .withDropFrame(timecode.isDropFrame())
-		           .withRate(timecode.getTimebase());
+		return this
+				       .withNegative(timecode.isNegative())
+				       .withDays(timecode.getDaysPart())
+				       .withHours(timecode.getHoursPart())
+				       .withMinutes(timecode.getMinutesPart())
+				       .withSeconds(timecode.getSecondsPart())
+				       .withFrames(timecode.getFramesPart())
+				       .withDropFrame(timecode.isDropFrame())
+				       .withRate(timecode.getTimebase());
 	}
 
 
@@ -59,13 +58,15 @@ public TimecodeBuilder withTime(LocalTime time)
 		return withTime(time, Timebase.HZ_25);
 	}
 
+
 	public TimecodeBuilder withTime(LocalTime time, Timebase timebase)
 	{
-		final Timecode baseTimecode = new TimecodeBuilder().withHours(time.getHourOfDay())
-		                                                   .withMinutes(time.getMinuteOfHour())
-		                                                   .withSeconds(time.getSecondOfMinute())
-		                                                   .withRate(timebase)
-		                                                   .build();
+		final Timecode baseTimecode = new TimecodeBuilder()
+				                              .withHours(time.getHourOfDay())
+				                              .withMinutes(time.getMinuteOfHour())
+				                              .withSeconds(time.getSecondOfMinute())
+				                              .withRate(timebase)
+				                              .build();
 
 		// Add the samples component (we can't just setFrames lest it round toa whole second)
 		final Timecode timecode = baseTimecode.add(new SampleCount(time.getMillisOfSecond(), Timebase.HZ_1000));
@@ -140,6 +141,8 @@ public TimecodeBuilder withRate(Timebase rate)
 	 */
 	public Timecode build()
 	{
+		final boolean dropFrame = (this.dropFrame != null) ? this.dropFrame.booleanValue() : getRate().isDropFrame();
+
 		return new Timecode(negative, days, hours, minutes, seconds, frames, rate, dropFrame);
 	}
 
@@ -191,7 +194,7 @@ public Timebase getRate()
 	}
 
 
-	public boolean isDropFrame()
+	public Boolean isDropFrame()
 	{
 		return dropFrame;
 	}
@@ -206,14 +209,22 @@ public boolean isDropFrame()
 	public String toString()
 	{
 		return "[TimecodeBuilder" +
-		       "negative=" + negative +
-		       ", days=" + days +
-		       ", hours=" + hours +
-		       ", minutes=" + minutes +
-		       ", seconds=" + seconds +
-		       ", frames=" + frames +
-		       ", rate=" + rate +
-		       ", dropFrame=" + dropFrame +
+		       "negative=" +
+		       negative +
+		       ", days=" +
+		       days +
+		       ", hours=" +
+		       hours +
+		       ", minutes=" +
+		       minutes +
+		       ", seconds=" +
+		       seconds +
+		       ", frames=" +
+		       frames +
+		       ", rate=" +
+		       rate +
+		       ", dropFrame=" +
+		       dropFrame +
 		       ']';
 	}
 
@@ -302,65 +313,76 @@ public static TimecodeBuilder fromSMPTE(String smpte)
 		final int seconds = Integer.parseInt(parts[i++]);
 		final int frames = Integer.parseInt(parts[i++]);
 
-		return new TimecodeBuilder().withNegative(negative)
-		                            .withDropFrame(dropFrame)
-		                            .withDays(days)
-		                            .withHours(hours)
-		                            .withMinutes(minutes)
-		                            .withSeconds(seconds)
-		                            .withFrames(frames);
+		return new TimecodeBuilder()
+				       .withNegative(negative)
+				       .withDropFrame(dropFrame)
+				       .withDays(days)
+				       .withHours(hours)
+				       .withMinutes(minutes)
+				       .withSeconds(seconds)
+				       .withFrames(frames);
 	}
 
 
 	public static TimecodeBuilder fromSamples(final SampleCount samples, final boolean dropFrame)
 	{
-		return fromFrames(samples.getSamples(), dropFrame, samples.getRate());
+		return fromFrames(samples.getSamples(), samples.getRate());
 	}
 
 
-	public static TimecodeBuilder fromFrames(final long signedFrameNumber, boolean dropFrame, final Timebase rate)
+	public static TimecodeBuilder fromFrames(final long signedFrameNumber, final Timebase rate)
 	{
-		final double fps = rate.getSamplesPerSecond();
 		final boolean negative = signedFrameNumber < 0;
 
 		// Now make it positive
 		long frameNumber = Math.abs(signedFrameNumber);
 
-		if (dropFrame)
-		{
-			// add in the number of drop frames, we can then treat the new value as a "non drop frame calc".
-			frameNumber = compensateForDropFrame(frameNumber, fps);
-		}
+		if (rate.isDropFrame())
+			frameNumber = compensateForDropFrame(frameNumber, rate.getSamplesPerSecond());
 
+		final int fps = rate.getIntSamplesPerSecond();
 		final long frames = Math.round(Math.floor((frameNumber % fps)));
 		final long seconds = Math.round(Math.floor((frameNumber / fps))) % 60;
 		final long minutes = (Math.round(Math.floor((frameNumber / fps))) / 60) % 60;
 		final long hours = ((Math.round(Math.floor((frameNumber / fps))) / 60) / 60) % 24;
 		final long days = (Math.round(Math.floor(((((frameNumber / fps) / 60) / 60) / 24))));
 
-		return new TimecodeBuilder().withNegative(negative)
-		                            .withDropFrame(dropFrame)
-		                            .withDays(days)
-		                            .withHours(hours)
-		                            .withMinutes(minutes)
-		                            .withSeconds(seconds)
-		                            .withFrames(frames)
-		                            .withRate(rate);
+		return new TimecodeBuilder()
+				       .withNegative(negative)
+				       .withDropFrame(rate.isDropFrame())
+				       .withDays(days)
+				       .withHours(hours)
+				       .withMinutes(minutes)
+				       .withSeconds(seconds)
+				       .withFrames(frames)
+				       .withRate(rate);
 	}
 
 
-	private static long compensateForDropFrame(final long frames, final double framesPerSecond)
+	/**
+	 * @param framenumber
+	 * @param framerate
+	 * 		should be 29.97, 59.94, or 23.976, otherwise the calculations will be off.
+	 *
+	 * @return a frame number that lets us use non-dropframe computations to extract time components
+	 */
+	static long compensateForDropFrame(final long framenumber, final double framerate)
 	{
-		// add in the number of drop frames, we can then treat the new value as a "non drop frame calc".
-		final double framesPerMin = (framesPerSecond * 60L);
-		final double framesPerTenMin = (framesPerMin * 10L) + DROP_FRAMES_PER_TEN_MIN;
+		//Code by David Heidelberger, adapted from Andrew Duncan
 
-		final long numberOfTenMinExtents = Math.round(Math.floor(frames / framesPerTenMin));
-		final long numberOfTrailingExtents = Math.round(Math.floor(((frames % framesPerTenMin) / framesPerMin)));
+		//Number of frames to drop on the minute marks is the nearest integer to 6% of the framerate
+		final long dropFrames = Math.round(framerate * .066666);
 
-		// add the number of drop frames
-		final long compensated = frames + (numberOfTenMinExtents * DROP_FRAMES_PER_TEN_MIN) + (numberOfTrailingExtents * 2);
+		final long framesPer10Minutes = Math.round(framerate * 60 * 10);
+		final long framesPerMinute = (Math.round(framerate) * 60) - dropFrames;
 
-		return compensated;
+		final long d = framenumber / framesPer10Minutes;
+		final long m = framenumber % framesPer10Minutes;
+
+		//In the original post, the next line read m>1, which only worked for 29.97. Jean-Baptiste Mardelle correctly pointed out that m should be compared to dropFrames.
+		if (m > dropFrames)
+			return framenumber + (dropFrames * 9 * d) + dropFrames * ((m - dropFrames) / framesPerMinute);
+		else
+			return framenumber + dropFrames * 9 * d;
 	}
 }
diff --git a/stdlib/src/test/java/com/peterphi/std/types/TimebaseTest.java b/stdlib/src/test/java/com/peterphi/std/types/TimebaseTest.java
index 29df83d760..c43afa0f21 100755
--- a/stdlib/src/test/java/com/peterphi/std/types/TimebaseTest.java
+++ b/stdlib/src/test/java/com/peterphi/std/types/TimebaseTest.java
@@ -14,6 +14,8 @@ public void testGetIntSamplesPerSecond() throws Exception
 		assertEquals(50, Timebase.HZ_50.getIntSamplesPerSecond());
 		assertEquals(25, new Timebase(2, 50).getIntSamplesPerSecond());
 		assertEquals(1000000, Timebase.HZ_1000000.getIntSamplesPerSecond());
+
+		assertEquals(30, Timebase.NTSC.getIntSamplesPerSecond());
 	}
 
 
diff --git a/stdlib/src/test/java/com/peterphi/std/types/TimecodeTest.java b/stdlib/src/test/java/com/peterphi/std/types/TimecodeTest.java
index 5c4c60337f..b9ecaface7 100755
--- a/stdlib/src/test/java/com/peterphi/std/types/TimecodeTest.java
+++ b/stdlib/src/test/java/com/peterphi/std/types/TimecodeTest.java
@@ -299,6 +299,7 @@ public void testToSMPTEString()
 		assertEquals("20:15:10:24", Timecode.valueOf("20:15:10:24@25").toSMPTEString());
 	}
 
+
 	@Test
 	public void testToEncodedString()
 	{
@@ -309,6 +310,7 @@ public void testToEncodedString()
 		assertEquals("20:15:10:24@25", Timecode.valueOf("20:15:10:24@25").toEncodedString());
 	}
 
+
 	@Test
 	public void testToEncodedStringWithDays()
 	{
@@ -330,4 +332,86 @@ public void testToISODurationWithFrames()
 		assertEquals("P01DT20H15M10S24F", Timecode.valueOf("01:20:15:10:24@25").toISODurationWithFrames(true));
 		assertEquals("P30DT20H15M10S24F", Timecode.valueOf("30:20:15:10:24@25").toISODurationWithFrames(true));
 	}
+
+
+	@Test
+	public void test107892FramesInDropFrameNTSCIsOneHourExactly()
+	{
+		final Timecode timecode = TimecodeBuilder.fromFrames(107892, Timebase.NTSC).build();
+
+		assertEquals("forwards: 107,892 frames of NTSC is 1 hour exactly", "01:00:00;00@30000:1001", timecode.toEncodedString());
+		assertEquals("backwards: one hour in NTSC is 107,892 frames", 107892, timecode.getDurationInFrames());
+		assertEquals("adding 1 NTSC frame to 1 hour in NTSC should yield 1h and 1 frame",
+		             "01:00:00;01@30000:1001",
+		             timecode.add(SampleCount.valueOf("1@NTSC")).toEncodedString());
+	}
+
+
+	@Test
+	public void testOneHourAndOneMinuteDropFrameNTSC()
+	{
+		final long oneHour = 107892;
+		final long frame1 = oneHour + 1800;
+		final long frame2 = oneHour + 1799;
+
+		final Timecode timecode1 = TimecodeBuilder.fromFrames(frame1, Timebase.NTSC).build();
+		final Timecode timecode2 = TimecodeBuilder.fromFrames(frame2, Timebase.NTSC).build();
+
+		// Make sure this results in the timecode we expect
+		assertEquals("forward conversion (1h 1m)", "01:01:00;02@30000:1001", timecode1.toEncodedString());
+		assertEquals("forward conversion (1h 59s 29 frames)", "01:00:59;29@30000:1001", timecode2.toEncodedString());
+
+		// Make sure the duration in frames is what we expect
+		assertEquals("backward conversion (1h 1m)", frame1, timecode1.getDurationInFrames());
+		assertEquals("backward conversion (1h 59s 29 frames)", frame2, timecode2.getDurationInFrames());
+	}
+
+
+	@Test
+	public void testOneHourOfTimeTimeToDropFrameNTSCTimecode() throws ResamplingException
+	{
+		SampleCount oneHourInMillis = SampleCount.seconds(Timebase.HZ_1000, 3600);
+		SampleCount ntscFrames = oneHourInMillis.resample(Timebase.NTSC);
+
+		Timecode timecode = TimecodeBuilder.fromSamples(ntscFrames, true).build();
+
+		assertEquals("01:00:00;00", timecode.toSMPTEString());
+	}
+
+
+	@Test
+	public void testCountingToTwoMinutesInDropFrameTimecode() throws ResamplingException
+	{
+		Timecode timecode = TimecodeBuilder.fromFrames(0, Timebase.NTSC).build();
+		final SampleCount oneFrame = new SampleCount(1, Timebase.NTSC);
+
+		for (int i = 0; i < 1800 * 2; i++)
+		{
+			timecode = timecode.add(oneFrame);
+		}
+
+		assertEquals("00:02:00;04", timecode.toSMPTEString());
+	}
+
+
+	@Test
+	public void testDropFrameNTSCParsing()
+	{
+		Timecode tc = Timecode.valueOf("01:23:45;06@NTSC");
+
+		final long expected = 150606;
+
+		assertEquals(expected, tc.getDurationInFrames());
+	}
+
+
+	@Test
+	public void testDateToDropFrameNTSCTimecode()
+	{
+		final long expected = 111884;
+		final Timecode tc = Timecode.valueOf("01:02:13;06@NTSC");
+
+		assertEquals("forward", expected, tc.getDurationInFrames());
+		assertEquals("backward", tc, Timecode.getInstance(expected, true, Timebase.NTSC));
+	}
 }
diff --git a/user-manager/api/pom.xml b/user-manager/api/pom.xml
index 62bd317502..0cfa171539 100755
--- a/user-manager/api/pom.xml
+++ b/user-manager/api/pom.xml
@@ -11,7 +11,7 @@
 	<parent>
 		<groupId>com.peterphi.user-manager</groupId>
 		<artifactId>user-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/user-manager/pom.xml b/user-manager/pom.xml
index 4a54f2b0c6..d6df1fb4bc 100755
--- a/user-manager/pom.xml
+++ b/user-manager/pom.xml
@@ -11,7 +11,7 @@
 	<parent>
 		<groupId>com.peterphi.std</groupId>
 		<artifactId>stdlib-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<modules>
diff --git a/user-manager/service/pom.xml b/user-manager/service/pom.xml
index cc19630fd4..5fe8fafa7a 100755
--- a/user-manager/service/pom.xml
+++ b/user-manager/service/pom.xml
@@ -10,7 +10,7 @@
 	<parent>
 		<groupId>com.peterphi.user-manager</groupId>
 		<artifactId>user-manager-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 	</parent>
 
 	<dependencies>
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/RoleDaoImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/RoleDaoImpl.java
index aedab8d04a..c6c1a23ad2 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/RoleDaoImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/RoleDaoImpl.java
@@ -1,5 +1,6 @@
 package com.peterphi.usermanager.db.dao.hibernate;
 
+import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.usermanager.db.entity.RoleEntity;
 import com.google.inject.Singleton;
 import com.peterphi.std.guice.hibernate.dao.HibernateDao;
@@ -7,4 +8,21 @@
 @Singleton
 public class RoleDaoImpl extends HibernateDao<RoleEntity, String>
 {
+	@Transactional
+	public RoleEntity getOrCreate(final String id, final String caption)
+	{
+		RoleEntity existing = getById(id);
+
+		if (existing == null)
+		{
+			existing = new RoleEntity();
+
+			existing.setId(id);
+			existing.setCaption(caption);
+
+			save(existing);
+		}
+
+		return existing;
+	}
 }
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/UserDaoImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/UserDaoImpl.java
index 74fe51ae65..7624dd32e5 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/UserDaoImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/db/dao/hibernate/UserDaoImpl.java
@@ -1,5 +1,6 @@
 package com.peterphi.usermanager.db.dao.hibernate;
 
+import com.peterphi.std.guice.common.auth.iface.CurrentUser;
 import com.peterphi.usermanager.db.entity.UserEntity;
 import com.google.inject.Singleton;
 import com.peterphi.std.crypto.BCrypt;
@@ -23,7 +24,7 @@ public UserEntity login(String email, String password)
 	{
 		final UserEntity account = getUserByEmail(email);
 
-		if (account != null)
+		if (account != null && account.isLocal())
 		{
 			final boolean correct = BCrypt.verify(account.getPassword(), password.toCharArray());
 
@@ -39,7 +40,15 @@ public UserEntity login(String email, String password)
 	}
 
 
-	protected UserEntity getUserByEmail(String email)
+	public boolean isUserLocal(final String email)
+	{
+		UserEntity record = getUserByEmail(email);
+
+		return (record != null && record.isLocal());
+	}
+
+
+	public UserEntity getUserByEmail(String email)
 	{
 		final Criteria criteria = createCriteria();
 
@@ -55,6 +64,9 @@ public void changePassword(final int id, final String newPassword)
 
 		if (account != null)
 		{
+			if (!account.isLocal())
+				throw new IllegalArgumentException("Cannot change password: user is authenticated by remote service!");
+
 			account.setPassword(hashPassword(newPassword));
 
 			update(account);
@@ -80,25 +92,21 @@ private String hashPassword(String password)
 
 
 	@Transactional
-	public int register(String name,
-	                    String email,
-	                    String password,
-	                    final String dateFormat,
-	                    final String timeZone)
+	public int register(String name, String email, String password, final String dateFormat, final String timeZone)
 	{
 		if (userExists(email))
-			throw new IllegalArgumentException("User with e-mail address " + email + " already exists!");
+			throw new IllegalArgumentException("User '" + email + "' already exists!");
 		if (password.isEmpty())
 			throw new IllegalArgumentException("Must supply a password!");
 
 		final UserEntity account = new UserEntity();
 
+		account.setLocal(true);
 		account.setName(name);
 		account.setEmail(email);
 		account.setPassword(hashPassword(password));
 		account.setDateFormat(dateFormat);
 		account.setTimeZone(timeZone);
-		account.setCreated(new DateTime());
 		account.setSessionReconnectKey(UUID.randomUUID().toString());
 
 		return save(account);
@@ -106,7 +114,27 @@ public int register(String name,
 
 
 	@Transactional
-	protected boolean userExists(String email)
+	public int registerRemote(final String username, final String fullName)
+	{
+		if (userExists(username))
+			throw new IllegalArgumentException("User '" + username + "' already exists!");
+
+		final UserEntity account = new UserEntity();
+		account.setLocal(false);
+		account.setEmail(username);
+		account.setName(fullName);
+		account.setPassword("NONE"); // Won't allow password logins anyway, but we also set a value that won't match any BCrypt hash
+		account.setSessionReconnectKey(null);
+
+		account.setTimeZone(CurrentUser.DEFAULT_TIMEZONE);
+		account.setDateFormat(CurrentUser.DEFAULT_DATE_FORMAT_STRING);
+
+		return save(account);
+	}
+
+
+	@Transactional
+	public boolean userExists(String email)
 	{
 		final UserEntity account = getUserByEmail(email);
 
@@ -119,6 +147,7 @@ public UserEntity loginBySessionReconnectKey(String key)
 	{
 		final Criteria criteria = createCriteria();
 
+		criteria.add(Restrictions.eq("local", true));
 		criteria.add(Restrictions.eq("sessionReconnectKey", key));
 
 		criteria.setMaxResults(1);
@@ -144,14 +173,22 @@ public void changeSessionReconnectKey(Integer id)
 
 		if (account != null)
 		{
-			account.setSessionReconnectKey(UUID.randomUUID().toString());
+			if (account.isLocal())
+				account.setSessionReconnectKey(UUID.randomUUID().toString());
+			else
+				account.setSessionReconnectKey(null);
+
 			update(account);
 		}
 	}
 
 
 	@Transactional
-	public UserEntity changeProfile(final int id, final String name, final String email, final String dateFormat, final String timeZone)
+	public UserEntity changeProfile(final int id,
+	                                final String name,
+	                                final String email,
+	                                final String dateFormat,
+	                                final String timeZone)
 	{
 		final UserEntity account = getById(id);
 
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/db/entity/UserEntity.java b/user-manager/service/src/main/java/com/peterphi/usermanager/db/entity/UserEntity.java
index f7ba8ae9aa..55795b3c8c 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/db/entity/UserEntity.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/db/entity/UserEntity.java
@@ -18,6 +18,8 @@
 {
 	private Integer id;
 
+	private boolean local = true;
+
 	/**
 	 * User's real name
 	 */
@@ -48,7 +50,7 @@
 	 */
 	private String sessionReconnectKey;
 
-	private DateTime created;
+	private DateTime created=DateTime.now();
 
 	private DateTime lastLogin;
 
@@ -68,6 +70,18 @@ public void setId(Integer id)
 		this.id = id;
 	}
 
+	@Column(name="is_local",nullable=false)
+	public boolean isLocal()
+	{
+		return local;
+	}
+
+
+	public void setLocal(final boolean local)
+	{
+		this.local = local;
+	}
+
 
 	@Column(length = 100, nullable = false)
 	public String getName()
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserAuthenticationService.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserAuthenticationService.java
index 302476d7cd..a0e9b3fa67 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserAuthenticationService.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserAuthenticationService.java
@@ -1,56 +1,16 @@
 package com.peterphi.usermanager.guice.authentication;
 
-import com.google.inject.Inject;
-import com.google.inject.Singleton;
 import com.peterphi.std.guice.database.annotation.Transactional;
-import com.peterphi.usermanager.db.dao.hibernate.UserDaoImpl;
 import com.peterphi.usermanager.db.entity.UserEntity;
-import org.apache.log4j.Logger;
 
-import java.util.stream.Collectors;
-
-@Singleton
-public class UserAuthenticationService
+public interface UserAuthenticationService
 {
-	private static final Logger log = Logger.getLogger(UserAuthenticationService.class);
-
-	@Inject
-	UserDaoImpl dao;
-
-
 	@Transactional
-	public UserEntity getById(final int id)
-	{
-		return ensureRolesFetched(dao.getById(id));
-	}
-
+	UserEntity getById(int id);
 
 	@Transactional
-	public UserEntity authenticate(String email, String password, final boolean basicAuth)
-	{
-		return ensureRolesFetched(dao.login(email, password));
-	}
-
-
-	/**
-	 * Make sure the roles have been fetched from the database
-	 *
-	 * @param user
-	 *
-	 * @return
-	 */
-	private UserEntity ensureRolesFetched(final UserEntity user)
-	{
-		if (user != null)
-			user.getRoles().stream().map(r -> r.getId()).collect(Collectors.toList());
-
-		return user;
-	}
-
+	UserEntity authenticate(String username, String password, boolean basicAuth);
 
 	@Transactional
-	public UserEntity authenticate(String sessionReconnectToken)
-	{
-		return ensureRolesFetched(dao.loginBySessionReconnectKey(sessionReconnectToken));
-	}
+	UserEntity authenticate(String sessionReconnectToken);
 }
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLogin.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLogin.java
index 782416ed59..5f80ac24ce 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLogin.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLogin.java
@@ -38,6 +38,8 @@ default boolean isAdmin()
 		return hasRole(ROLE_ADMIN);
 	}
 
+	boolean isLocal();
+
 	@Override
 	String getName();
 
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginImpl.java
index 8ccc4790b2..b985387ad3 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginImpl.java
@@ -18,6 +18,7 @@
 	private String name;
 	private String email;
 	private DateTimeFormatter dateFormatter = CurrentUser.DEFAULT_DATE_FORMAT;
+	private boolean local;
 
 	private Set<String> roles = Collections.emptySet();
 
@@ -44,6 +45,7 @@ public void reload(final UserEntity account)
 			name = "Anonymous";
 			email = "anonymous@localhost";
 			roles = Collections.emptySet();
+			local = true;
 
 			dateFormatter = CurrentUser.DEFAULT_DATE_FORMAT;
 		}
@@ -53,6 +55,7 @@ public void reload(final UserEntity account)
 			name = account.getName();
 			email = account.getEmail();
 			roles = account.getRoles().stream().map(r -> r.getId()).collect(Collectors.toSet());
+			local = account.isLocal();
 
 			dateFormatter = DateTimeFormat.forPattern(account.getDateFormat())
 			                              .withZone(DateTimeZone.forID(account.getTimeZone()));
@@ -60,6 +63,13 @@ public void reload(final UserEntity account)
 	}
 
 
+	@Override
+	public boolean isLocal()
+	{
+		return local;
+	}
+
+
 	@Override
 	public String getName()
 	{
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginModule.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginModule.java
index 0ac2dde29d..a1f950fd63 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginModule.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/UserLoginModule.java
@@ -1,13 +1,18 @@
 package com.peterphi.usermanager.guice.authentication;
 
-import com.peterphi.usermanager.guice.async.AsynchronousActionService;
 import com.google.inject.AbstractModule;
 import com.google.inject.Key;
+import com.google.inject.Provider;
 import com.google.inject.Provides;
+import com.google.inject.Singleton;
 import com.google.inject.name.Named;
 import com.google.inject.name.Names;
+import com.peterphi.std.annotation.Doc;
 import com.peterphi.std.guice.common.auth.iface.CurrentUser;
 import com.peterphi.std.guice.web.rest.scoping.SessionScoped;
+import com.peterphi.usermanager.guice.async.AsynchronousActionService;
+import com.peterphi.usermanager.guice.authentication.db.InternalUserAuthenticationServiceImpl;
+import com.peterphi.usermanager.guice.authentication.ldap.LocalAndLDAPAuthenticationService;
 
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpSession;
@@ -17,6 +22,9 @@
  */
 public class UserLoginModule extends AbstractModule
 {
+	@Doc("Authentication backend, defaults to internal, can be internal or ldap (if ldap, internal is checked first)")
+	public static final String AUTHENTICATION_BACKEND = "authentication-backend";
+
 	public static final String LOGIN_SESSION_ATTRIBUTE = "login";
 	public static final String JAXRS_SERVER_WEBAUTH_PROVIDER = "user-manager";
 
@@ -39,6 +47,21 @@ protected void configure()
 	}
 
 
+	@Provides
+	@Singleton
+	public UserAuthenticationService getUserAuthenticationService(@Named(AUTHENTICATION_BACKEND) String backend,
+	                                                              Provider<InternalUserAuthenticationServiceImpl> internalProvider,
+	                                                              Provider<LocalAndLDAPAuthenticationService> ldapProvider)
+	{
+		if (backend.equalsIgnoreCase("internal"))
+			return internalProvider.get();
+		else if (backend.equalsIgnoreCase("ldap"))
+			return ldapProvider.get();
+		else
+			throw new IllegalArgumentException("Unknown authentication backend: " + backend);
+	}
+
+
 	/**
 	 * Auto-cast the user manager's CurrentUser to a UserLogin
 	 *
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/db/InternalUserAuthenticationServiceImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/db/InternalUserAuthenticationServiceImpl.java
new file mode 100755
index 0000000000..03c36421b1
--- /dev/null
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/db/InternalUserAuthenticationServiceImpl.java
@@ -0,0 +1,58 @@
+package com.peterphi.usermanager.guice.authentication.db;
+
+import com.google.inject.Inject;
+import com.peterphi.std.guice.database.annotation.Transactional;
+import com.peterphi.usermanager.db.dao.hibernate.UserDaoImpl;
+import com.peterphi.usermanager.db.entity.UserEntity;
+import com.peterphi.usermanager.guice.authentication.UserAuthenticationService;
+import org.apache.log4j.Logger;
+
+import java.util.stream.Collectors;
+
+public class InternalUserAuthenticationServiceImpl implements UserAuthenticationService
+{
+	private static final Logger log = Logger.getLogger(InternalUserAuthenticationServiceImpl.class);
+
+	@Inject
+	UserDaoImpl dao;
+
+
+	@Override
+	@Transactional
+	public UserEntity getById(final int id)
+	{
+		return ensureRolesFetched(dao.getById(id));
+	}
+
+
+	@Override
+	@Transactional
+	public UserEntity authenticate(String username, String password, final boolean basicAuth)
+	{
+		return ensureRolesFetched(dao.login(username, password));
+	}
+
+
+	/**
+	 * Make sure the roles have been fetched from the database
+	 *
+	 * @param user
+	 *
+	 * @return
+	 */
+	private UserEntity ensureRolesFetched(final UserEntity user)
+	{
+		if (user != null)
+			user.getRoles().stream().map(r -> r.getId()).collect(Collectors.toList());
+
+		return user;
+	}
+
+
+	@Override
+	@Transactional
+	public UserEntity authenticate(String sessionReconnectToken)
+	{
+		return ensureRolesFetched(dao.loginBySessionReconnectKey(sessionReconnectToken));
+	}
+}
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPGroup.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPGroup.java
new file mode 100755
index 0000000000..ec46b894c4
--- /dev/null
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPGroup.java
@@ -0,0 +1,23 @@
+package com.peterphi.usermanager.guice.authentication.ldap;
+
+import com.google.common.base.Objects;
+
+public class LDAPGroup
+{
+	public final String id;
+	public final String dn;
+
+
+	public LDAPGroup(final String id, final String dn)
+	{
+		this.id = id;
+		this.dn = dn;
+	}
+
+
+	@Override
+	public String toString()
+	{
+		return Objects.toStringHelper(this).add("id", id).add("dn", dn).toString();
+	}
+}
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserAuthenticationService.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserAuthenticationService.java
new file mode 100755
index 0000000000..f0e85b7ab9
--- /dev/null
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserAuthenticationService.java
@@ -0,0 +1,243 @@
+package com.peterphi.usermanager.guice.authentication.ldap;
+
+import com.google.inject.Inject;
+import com.google.inject.name.Named;
+import com.peterphi.std.guice.database.annotation.Transactional;
+import com.peterphi.usermanager.db.dao.hibernate.RoleDaoImpl;
+import com.peterphi.usermanager.db.dao.hibernate.UserDaoImpl;
+import com.peterphi.usermanager.db.entity.RoleEntity;
+import com.peterphi.usermanager.db.entity.UserEntity;
+import com.peterphi.usermanager.guice.authentication.UserAuthenticationService;
+import org.joda.time.DateTime;
+
+import javax.naming.Context;
+import javax.naming.NamingEnumeration;
+import javax.naming.NamingException;
+import javax.naming.directory.Attributes;
+import javax.naming.directory.DirContext;
+import javax.naming.directory.InitialDirContext;
+import javax.naming.directory.SearchControls;
+import javax.naming.directory.SearchResult;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class LDAPUserAuthenticationService implements UserAuthenticationService
+{
+	@Inject
+	UserDaoImpl dao;
+
+	@Inject
+	RoleDaoImpl roleDao;
+
+	@Inject
+	@Named("ldap.domain")
+	public String domain;
+
+	@Inject
+	@Named("ldap.endpoint")
+	public String ldapEndpoint;
+
+	@Inject
+	@Named("ldap.search-base")
+	public String ldapSearchBase;
+
+	/**
+	 * Formatted with 1 argument, the username
+	 */
+	@Inject
+	@Named("ldap.filter")
+	public String ldapFilter;
+
+	/**
+	 * The find pattern to use on group DNs. e.g. <code>(?i)^cn=([^,]+),</code>
+	 */
+	@Inject
+	@Named("ldap.group-regex.find")
+	public String ldapGroupFind;
+
+	/**
+	 * The replacement pattern to use after the find pattern is executed - e.g. <code>$1</code> for the first capture group
+	 */
+	@Inject
+	@Named("ldap.group-regex.replace")
+	public String ldapGroupReplace;
+
+
+	@Override
+	@Transactional
+	public UserEntity getById(final int id)
+	{
+		return ensureRolesFetched(dao.getById(id));
+	}
+
+
+	/**
+	 * Make sure the roles have been fetched from the database
+	 *
+	 * @param user
+	 *
+	 * @return
+	 */
+	private UserEntity ensureRolesFetched(final UserEntity user)
+	{
+		if (user != null)
+			user.getRoles().stream().map(r -> r.getId()).collect(Collectors.toList());
+
+		return user;
+	}
+
+
+	@Override
+	@Transactional
+	public UserEntity authenticate(final String username, final String password, final boolean basicAuth)
+	{
+		// TODO Authenticate with LDAP and get user record
+		LDAPUserRecord record = ldapAuthenticate(username, password);
+
+		// Sync LDAP record into our database
+		UserEntity entity = ensureRolesFetched(registerOrUpdateUser(record));
+
+		// Update the last login timestamp
+		entity.setLastLogin(DateTime.now());
+		dao.update(entity);
+
+		return entity;
+	}
+
+
+	private UserEntity registerOrUpdateUser(final LDAPUserRecord ldap)
+	{
+		UserEntity existing = dao.getUserByEmail(ldap.username);
+
+		if (existing == null)
+		{
+			dao.registerRemote(ldap.username, ldap.fullName);
+
+			existing = dao.getUserByEmail(ldap.username);
+
+			assert (existing != null);
+		}
+
+		// Now sync the role information
+		setRoles(existing, ldap);
+
+		return existing;
+	}
+
+
+	private void setRoles(final UserEntity existing, final LDAPUserRecord ldap)
+	{
+		// First, figure out which roles are new by excluding those that have been removed + those that are unchanged
+		// At the same time, remove the roles the user no longer has
+		Set<String> noChange = new HashSet<>(); // PKs for roles with no change
+		{
+			Set<RoleEntity> toRemove = new HashSet<>(); // role entities to remove
+			for (RoleEntity roleEntity : existing.getRoles())
+			{
+				if (ldap.getRoleIds().contains(roleEntity.getId()))
+					noChange.add(roleEntity.getId()); // User still has this role
+				else
+				{
+					toRemove.add(roleEntity); // User no longer has this role
+					roleEntity.getMembers().remove(existing); // remove us from the role's membership list
+				}
+			}
+
+			// Remove the roles the user no longer has
+			existing.getRoles().removeAll(toRemove);
+		}
+
+		// Add the new roles (creating them if necessary)
+		for (LDAPGroup group : ldap.roles)
+		{
+			if (!noChange.contains(group.id))
+			{
+				RoleEntity role = roleDao.getOrCreate(group.id, "LDAP: " + group.dn);
+
+				role.getMembers().add(existing);
+				existing.getRoles().add(role);
+			}
+		}
+
+		dao.update(existing);
+	}
+
+
+	@Override
+	public UserEntity authenticate(final String sessionReconnectToken)
+	{
+		return null; // unsupported
+	}
+
+
+	private LDAPUserRecord ldapAuthenticate(final String username, final String password)
+	{
+		try
+		{
+			DirContext ldapContext = null;
+			try
+			{
+				Hashtable<String, String> ldapEnv = new Hashtable<>();
+				ldapEnv.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
+				ldapEnv.put(Context.PROVIDER_URL, ldapEndpoint);
+				ldapEnv.put(Context.SECURITY_AUTHENTICATION, "simple");
+				ldapEnv.put(Context.SECURITY_PRINCIPAL, username + "@" + domain);
+				ldapEnv.put(Context.SECURITY_CREDENTIALS, password);
+				ldapContext = new InitialDirContext(ldapEnv); // N.B. sometimes takes ~10 seconds
+
+				final NamingEnumeration<SearchResult> answer;
+				{
+					SearchControls search = new SearchControls();
+
+					search.setSearchScope(SearchControls.SUBTREE_SCOPE);
+					search.setReturningAttributes(new String[]{"name", "samAccountName", "memberOf"});
+
+					final String searchFilter = String.format(this.ldapFilter, username);
+
+					answer = ldapContext.search(ldapSearchBase, searchFilter, search);
+				}
+
+				while (answer.hasMoreElements())
+				{
+					SearchResult sr = answer.next();
+					Attributes attrs = sr.getAttributes();
+
+					final String name = attrs.get("name").get().toString();
+					final String actualUsername = attrs.get("samAccountName").get().toString();
+
+					List<LDAPGroup> groups = Collections
+							                         .list(attrs.get("memberOf").getAll())
+							                         .stream()
+							                         .map(o -> o.toString())
+							                         .map(this :: dnToLdapGroup)
+							                         .collect(Collectors.toList());
+
+					return new LDAPUserRecord(actualUsername, name, groups);
+				}
+
+				return null;
+			}
+			finally
+			{
+				if (ldapContext != null)
+					ldapContext.close();
+			}
+		}
+		catch (NamingException e)
+		{
+			throw new RuntimeException("Error accessing LDAP server", e);
+		}
+	}
+
+
+	private LDAPGroup dnToLdapGroup(final String dn)
+	{
+		final String id = dn.replaceAll(ldapGroupFind, ldapGroupReplace);
+
+		return new LDAPGroup(id, dn);
+	}
+}
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserRecord.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserRecord.java
new file mode 100755
index 0000000000..aa5a08bffb
--- /dev/null
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LDAPUserRecord.java
@@ -0,0 +1,30 @@
+package com.peterphi.usermanager.guice.authentication.ldap;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class LDAPUserRecord
+{
+	public final String username;
+	public final String fullName;
+	public final List<LDAPGroup> roles;
+	private final Set<String> roleIds;
+
+
+	public LDAPUserRecord(final String username, final String fullName, final List<LDAPGroup> roles)
+	{
+		this.username = username;
+		this.fullName = fullName;
+		this.roles = Collections.unmodifiableList(new ArrayList<>(roles));
+		this.roleIds = Collections.unmodifiableSet(this.roles.stream().map(g -> g.id).collect(Collectors.toSet()));
+	}
+
+
+	public Set<String> getRoleIds()
+	{
+		return this.roleIds;
+	}
+}
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LocalAndLDAPAuthenticationService.java b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LocalAndLDAPAuthenticationService.java
new file mode 100755
index 0000000000..77de72e9be
--- /dev/null
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/guice/authentication/ldap/LocalAndLDAPAuthenticationService.java
@@ -0,0 +1,50 @@
+package com.peterphi.usermanager.guice.authentication.ldap;
+
+import com.google.inject.Inject;
+import com.peterphi.std.guice.database.annotation.Transactional;
+import com.peterphi.usermanager.db.dao.hibernate.UserDaoImpl;
+import com.peterphi.usermanager.db.entity.UserEntity;
+import com.peterphi.usermanager.guice.authentication.UserAuthenticationService;
+import com.peterphi.usermanager.guice.authentication.db.InternalUserAuthenticationServiceImpl;
+
+public class LocalAndLDAPAuthenticationService implements UserAuthenticationService
+{
+	@Inject
+	UserDaoImpl dao;
+
+	@Inject
+	public InternalUserAuthenticationServiceImpl internal;
+
+	@Inject
+	LDAPUserAuthenticationService ldap;
+
+
+	@Override
+	public UserEntity getById(final int id)
+	{
+		return internal.getById(id);
+	}
+
+
+	@Override
+	@Transactional
+	public UserEntity authenticate(final String username, final String password, final boolean basicAuth)
+	{
+		if (dao.isUserLocal(username))
+			return internal.authenticate(username, password, basicAuth);
+		else
+			return ldap.authenticate(username, password, basicAuth);
+	}
+
+
+	@Override
+	public UserEntity authenticate(final String sessionReconnectToken)
+	{
+		final UserEntity entity = internal.authenticate(sessionReconnectToken);
+
+		if (entity != null)
+			return entity;
+		else
+			return ldap.authenticate(sessionReconnectToken);
+	}
+}
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/rest/impl/UserManagerOAuthServiceImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/rest/impl/UserManagerOAuthServiceImpl.java
index 5171b7b787..48ebcbc702 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/rest/impl/UserManagerOAuthServiceImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/rest/impl/UserManagerOAuthServiceImpl.java
@@ -162,7 +162,6 @@ public Response userMadeAuthDecision(final String responseType,
 
 
 	@Transactional
-	@Retry
 	public Response createSessionAndRedirect(final String responseType,
 	                                         final String clientId,
 	                                         final String redirectUri,
@@ -276,7 +275,6 @@ private String computeInitiatorInfo()
 
 	@Override
 	@Transactional
-	@Retry
 	@AuthConstraint(id = "oauth2server_token", skip = true)
 	public String getToken(final String grantType,
 	                       final String code,
@@ -335,7 +333,6 @@ public String getToken(final String grantType,
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	@AuthConstraint(id = "oauth2server_token_to_userinfo", skip = true)
 	public UserManagerUser get(final String token, final String clientId)
 	{
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/RoleUIServiceImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/RoleUIServiceImpl.java
index 28e54fe56c..1c2e79ff63 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/RoleUIServiceImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/RoleUIServiceImpl.java
@@ -3,7 +3,6 @@
 import com.google.inject.Inject;
 import com.google.inject.Singleton;
 import com.peterphi.std.guice.common.auth.annotations.AuthConstraint;
-import com.peterphi.std.guice.common.retry.annotation.Retry;
 import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.webquery.ConstrainedResultSet;
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
@@ -45,7 +44,6 @@
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String getRoles(UriInfo query)
 	{
 		ConstrainedResultSet<RoleEntity> resultset = dao.findByUriQuery(new WebQuery().orderAsc("id").decode(query));
@@ -62,7 +60,6 @@ public String getRoles(UriInfo query)
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String get(final String id)
 	{
 		TemplateCall call = templater.template("role");
@@ -83,7 +80,6 @@ public String get(final String id)
 
 	@Override
 	@Transactional
-	@Retry
 	public Response create(final String id, final String nonce, final String caption)
 	{
 		nonceStore.validate(NONCE_USE, nonce);
@@ -104,7 +100,6 @@ public Response create(final String id, final String nonce, final String caption
 
 	@Override
 	@Transactional
-	@Retry
 	public Response delete(final String id, final String nonce)
 	{
 		nonceStore.validate(NONCE_USE, nonce);
@@ -125,7 +120,6 @@ public Response delete(final String id, final String nonce)
 
 	@Override
 	@Transactional
-	@Retry
 	public Response changeCaption(final String id, final String nonce, final String caption)
 	{
 		nonceStore.validate(NONCE_USE, nonce);
@@ -145,7 +139,6 @@ public Response changeCaption(final String id, final String nonce, final String
 
 	@Override
 	@Transactional
-	@Retry
 	public Response changeMembers(final String id, final String nonce, final List<Integer> members)
 	{
 		nonceStore.validate(NONCE_USE, nonce);
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/ServiceUIServiceImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/ServiceUIServiceImpl.java
index e2f146babf..43f1a18e24 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/ServiceUIServiceImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/ServiceUIServiceImpl.java
@@ -49,7 +49,6 @@
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String getList(final UriInfo query)
 	{
 		final ConstrainedResultSet<OAuthServiceEntity> resultset = dao.findByUriQuery(new WebQuery().decode(query.getQueryParameters()));
@@ -66,7 +65,6 @@ public String getList(final UriInfo query)
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String get(final String id)
 	{
 		final OAuthServiceEntity entity = dao.getById(id);
@@ -86,7 +84,6 @@ public String get(final String id)
 
 	@Override
 	@Transactional
-	@Retry
 	public Response create(final String nonce, final String name, final String endpoints)
 	{
 		nonceStore.validate(NONCE_USE,nonce);
@@ -109,7 +106,6 @@ public Response create(final String nonce, final String name, final String endpo
 
 	@Override
 	@Transactional
-	@Retry
 	public Response disable(final String id, final String nonce)
 	{
 		nonceStore.validate(NONCE_USE,nonce);
@@ -133,7 +129,6 @@ else if (entity.getOwner().getId() != userProvider.get().getId() && !userProvide
 
 	@Override
 	@Transactional
-	@Retry
 	public Response setEndpoints(final String nonce, final String id, final String endpoints)
 	{
 		nonceStore.validate(NONCE_USE,nonce);
diff --git a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/UserUIServiceImpl.java b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/UserUIServiceImpl.java
index 8bb8410fb3..c4c6b3b661 100755
--- a/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/UserUIServiceImpl.java
+++ b/user-manager/service/src/main/java/com/peterphi/usermanager/ui/impl/UserUIServiceImpl.java
@@ -2,7 +2,6 @@
 
 import com.google.inject.Inject;
 import com.peterphi.std.guice.common.auth.annotations.AuthConstraint;
-import com.peterphi.std.guice.common.retry.annotation.Retry;
 import com.peterphi.std.guice.database.annotation.Transactional;
 import com.peterphi.std.guice.hibernate.webquery.ConstrainedResultSet;
 import com.peterphi.std.guice.restclient.jaxb.webquery.WebQuery;
@@ -65,7 +64,6 @@ public String getIndex()
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String getUsers(UriInfo query)
 	{
 		ConstrainedResultSet<UserEntity> resultset = accountDao.findByUriQuery(new WebQuery().orderAsc("id").decode(query));
@@ -82,7 +80,6 @@ public String getUsers(UriInfo query)
 
 	@Override
 	@Transactional(readOnly = true)
-	@Retry
 	public String getUserEdit(final int userId)
 	{
 		final int localUser = login.getId();
@@ -115,7 +112,6 @@ public String getUserEdit(final int userId)
 
 	@Override
 	@Transactional
-	@Retry
 	public Response editUserProfile(final int userId,
 	                                final String nonce,
 	                                final String dateFormat,
@@ -179,7 +175,6 @@ public Response editUserProfile(final int userId,
 
 	@Override
 	@Transactional
-	@Retry
 	@AuthConstraint(role = UserLogin.ROLE_ADMIN)
 	public Response deleteUser(final int userId, final String nonce)
 	{
@@ -206,7 +201,6 @@ public Response deleteUser(final int userId, final String nonce)
 
 	@Override
 	@Transactional
-	@Retry
 	public Response changePassword(final int userId,
 	                               final String nonce,
 	                               final String newPassword,
diff --git a/user-manager/service/src/main/resources/liquibase/000-Original.xml b/user-manager/service/src/main/resources/liquibase/000-Original.xml
index e86a332d7c..010f61d589 100755
--- a/user-manager/service/src/main/resources/liquibase/000-Original.xml
+++ b/user-manager/service/src/main/resources/liquibase/000-Original.xml
@@ -227,7 +227,7 @@
 		<!-- service.owner_id -->
 		<addForeignKeyConstraint baseColumnNames="owner_id" baseTableName="oauth_service"
 		                         constraintName="FK__oauth_service__user_id" deferrable="false"
-		                         initiallyDeferred="false"  onDelete="CASCADE" onUpdate="CASCADE" referencedColumnNames="id"
+		                         initiallyDeferred="false" onDelete="CASCADE" onUpdate="CASCADE" referencedColumnNames="id"
 		                         referencedTableName="user_account"/>
 		<!-- session_context.service_id -->
 		<addForeignKeyConstraint baseColumnNames="service_id" baseTableName="oauth_session_context"
@@ -246,4 +246,12 @@
 		                         referencedTableName="oauth_session_context"/>
 
 	</changeSet>
+
+	<changeSet author="peter@peterphi.com" id="create_user_is_local">
+		<addColumn tableName="user_account">
+			<column name="is_local" type="BOOLEAN" defaultValueBoolean="true">
+				<constraints nullable="false"/>
+			</column>
+		</addColumn>
+	</changeSet>
 </databaseChangeLog>
diff --git a/user-manager/service/src/main/resources/service.properties b/user-manager/service/src/main/resources/service.properties
index cac6f89b0c..e392eba248 100755
--- a/user-manager/service/src/main/resources/service.properties
+++ b/user-manager/service/src/main/resources/service.properties
@@ -25,3 +25,6 @@ authentication.allowAnonymousRegistration=true
 framework.webauth.provider=user-manager
 
 liquibase.changelog=/liquibase/changelog.xml
+
+# "internal" for internal only, ldap for internal and then ldap
+authentication-backend=internal
diff --git a/user-manager/service/src/main/webapp/WEB-INF/template/user_edit.html b/user-manager/service/src/main/webapp/WEB-INF/template/user_edit.html
index 1cd0c6c67a..24bb4ef64b 100755
--- a/user-manager/service/src/main/webapp/WEB-INF/template/user_edit.html
+++ b/user-manager/service/src/main/webapp/WEB-INF/template/user_edit.html
@@ -23,7 +23,7 @@
 	<h1 th:text="${user.email}"></h1>
 
 	<ul class="nav nav-pills">
-		<li th:if="${session.login.isAdmin() or (session.login.getId() == user.id)}"><a href="#chpassModal" data-toggle="modal">Change
+		<li th:if="${user.isLocal() and (session.login.isAdmin() or (session.login.getId() == user.id))}"><a href="#chpassModal" data-toggle="modal">Change
 			Password</a></li>
 		<li th:if="${session.login.isAdmin()}"><a href="#deluserModal" data-toggle="modal">Delete User</a></li>
 		<li th:if="${session.login.isAdmin()}"><a href="#impersonateModal" data-toggle="modal">Impersonate</a></li>
@@ -132,6 +132,15 @@ <h3 id="impersonateModalLabel">Impersonate</h3>
 			</div>
 		</div>
 
+		<!-- isLocal -->
+		<div class="control-group">
+			<label class="control-label" for="view_lastLogin">local user</label>
+
+			<div class="controls">
+				<input type="text" disabled="disabled" id="view_isLocal" th:value="${user.isLocal()}"/>
+			</div>
+		</div>
+
 		<!-- lastLogin -->
 		<div class="control-group">
 			<label class="control-label" for="view_lastLogin">last login</label>
@@ -217,7 +226,7 @@ <h3 id="impersonateModalLabel">Impersonate</h3>
 			<label class="control-label" for="input_roles">Roles</label>
 
 			<div class="controls">
-				<th:block th:if="${session.login.isAdmin()}">
+				<th:block th:if="${user.isLocal() and session.login.isAdmin()}">
 					<select th:readonly="${!session.login.isAdmin()}" multiple="multiple" id="input_roles" name="roles"
 					        class="chosen-select span10">
 						<option data-placeholder="Choose some roles (optional)" th:each="role: ${roles}" th:value="${role.id}"
@@ -225,7 +234,7 @@ <h3 id="impersonateModalLabel">Impersonate</h3>
 						        th:selected="${entityRoleIds.contains(role.id)}"></option>
 					</select>
 				</th:block>
-				<th:block th:unless="${session.login.isAdmin()}">
+				<th:block th:unless="${user.isLocal() and session.login.isAdmin()}">
 					<ul>
 						<li th:each="role: ${user.roles}" th:text="${role.caption}"></li>
 					</ul>
diff --git a/user-manager/service/src/test/resources/user-manager-hsqldb-in-memory.properties b/user-manager/service/src/test/resources/user-manager-hsqldb-in-memory.properties
index 3dd031d2d7..0e093a23ce 100755
--- a/user-manager/service/src/test/resources/user-manager-hsqldb-in-memory.properties
+++ b/user-manager/service/src/test/resources/user-manager-hsqldb-in-memory.properties
@@ -7,6 +7,8 @@ hibernate.connection.url=jdbc:hsqldb:mem:testdb
 hibernate.connection.username=sa
 hibernate.connection.password=
 hibernate.connection.readOnly=false
+# HSQLDB doesn't allow ORDER BY without listing the column in SELECT, so HQL generator needs to be aware of that
+hibernate.database-allows-order-by-without-select=false
 
 hibernate.show_sql=false
 hibernate.current_session_context_class=thread
diff --git a/util/carbon-client/pom.xml b/util/carbon-client/pom.xml
index f9a7bcce5f..4810751e67 100755
--- a/util/carbon-client/pom.xml
+++ b/util/carbon-client/pom.xml
@@ -6,14 +6,14 @@
 	<parent>
 		<groupId>com.peterphi.std</groupId>
 		<artifactId>stdlib-parent</artifactId>
-		<version>9.2.2-SNAPSHOT</version>
+		<version>9.4.11-SNAPSHOT</version>
 
 		<relativePath>../../</relativePath>
 	</parent>
 
 	<groupId>com.peterphi.std.util.carbon</groupId>
 	<artifactId>carbon-client</artifactId>
-	<version>9.2.2-SNAPSHOT</version>
+	<version>9.4.11-SNAPSHOT</version>
 	<packaging>jar</packaging>
 
 	<name>carbon client</name>
