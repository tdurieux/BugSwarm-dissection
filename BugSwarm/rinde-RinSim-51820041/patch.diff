diff --git a/core/.settings/org.eclipse.jdt.core.prefs b/core/.settings/org.eclipse.jdt.core.prefs
index 5c3a741c43..c67b070f4a 100755
--- a/core/.settings/org.eclipse.jdt.core.prefs
+++ b/core/.settings/org.eclipse.jdt.core.prefs
@@ -166,6 +166,7 @@ org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_lambda_body=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
@@ -211,6 +212,7 @@ org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do
 org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
@@ -258,6 +260,7 @@ org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=inser
 org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
 org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
 org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow=insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
@@ -335,6 +338,7 @@ org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do n
 org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow=insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
diff --git a/core/.settings/org.eclipse.jdt.ui.prefs b/core/.settings/org.eclipse.jdt.ui.prefs
index 229f093d4b..998139b8e2 100755
--- a/core/.settings/org.eclipse.jdt.ui.prefs
+++ b/core/.settings/org.eclipse.jdt.ui.prefs
@@ -11,10 +11,12 @@ cleanup.always_use_blocks=true
 cleanup.always_use_parentheses_in_expressions=false
 cleanup.always_use_this_for_non_static_field_access=false
 cleanup.always_use_this_for_non_static_method_access=false
+cleanup.convert_functional_interfaces=false
 cleanup.convert_to_enhanced_for_loop=false
 cleanup.correct_indentation=true
 cleanup.format_source_code=true
 cleanup.format_source_code_changes_only=false
+cleanup.insert_inferred_type_arguments=false
 cleanup.make_local_variable_final=true
 cleanup.make_parameters_final=false
 cleanup.make_private_fields_final=true
@@ -29,6 +31,7 @@ cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=tru
 cleanup.qualify_static_member_accesses_with_declaring_class=true
 cleanup.qualify_static_method_accesses_with_declaring_class=false
 cleanup.remove_private_constructors=true
+cleanup.remove_redundant_type_arguments=true
 cleanup.remove_trailing_whitespaces=true
 cleanup.remove_trailing_whitespaces_all=true
 cleanup.remove_trailing_whitespaces_ignore_empty=false
@@ -42,13 +45,16 @@ cleanup.remove_unused_private_methods=true
 cleanup.remove_unused_private_types=true
 cleanup.sort_members=false
 cleanup.sort_members_all=false
+cleanup.use_anonymous_class_creation=false
 cleanup.use_blocks=true
 cleanup.use_blocks_only_for_return_and_throw=false
+cleanup.use_lambda=true
 cleanup.use_parentheses_in_expressions=true
 cleanup.use_this_for_non_static_field_access=true
 cleanup.use_this_for_non_static_field_access_only_if_necessary=true
 cleanup.use_this_for_non_static_method_access=true
 cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+cleanup.use_type_arguments=false
 cleanup_profile=_Eclipse [rinde]
 cleanup_settings_version=2
 eclipse.preferences.version=1
@@ -72,10 +78,12 @@ sp_cleanup.always_use_blocks=true
 sp_cleanup.always_use_parentheses_in_expressions=false
 sp_cleanup.always_use_this_for_non_static_field_access=false
 sp_cleanup.always_use_this_for_non_static_method_access=false
+sp_cleanup.convert_functional_interfaces=false
 sp_cleanup.convert_to_enhanced_for_loop=false
-sp_cleanup.correct_indentation=true
+sp_cleanup.correct_indentation=false
 sp_cleanup.format_source_code=true
 sp_cleanup.format_source_code_changes_only=false
+sp_cleanup.insert_inferred_type_arguments=false
 sp_cleanup.make_local_variable_final=true
 sp_cleanup.make_parameters_final=false
 sp_cleanup.make_private_fields_final=true
@@ -91,6 +99,7 @@ sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=
 sp_cleanup.qualify_static_member_accesses_with_declaring_class=true
 sp_cleanup.qualify_static_method_accesses_with_declaring_class=false
 sp_cleanup.remove_private_constructors=true
+sp_cleanup.remove_redundant_type_arguments=false
 sp_cleanup.remove_trailing_whitespaces=true
 sp_cleanup.remove_trailing_whitespaces_all=true
 sp_cleanup.remove_trailing_whitespaces_ignore_empty=false
@@ -104,10 +113,13 @@ sp_cleanup.remove_unused_private_methods=true
 sp_cleanup.remove_unused_private_types=true
 sp_cleanup.sort_members=false
 sp_cleanup.sort_members_all=false
+sp_cleanup.use_anonymous_class_creation=false
 sp_cleanup.use_blocks=true
 sp_cleanup.use_blocks_only_for_return_and_throw=false
+sp_cleanup.use_lambda=false
 sp_cleanup.use_parentheses_in_expressions=true
 sp_cleanup.use_this_for_non_static_field_access=true
 sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=true
 sp_cleanup.use_this_for_non_static_method_access=true
 sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+sp_cleanup.use_type_arguments=false
diff --git a/core/pom.xml b/core/pom.xml
index 163281dd6e..923aa6408a 100755
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -24,14 +24,14 @@
 		<sonar.language>java</sonar.language>
 	</properties>
 
-	<build>
+	<!-- <build>
 		<plugins>
 			<plugin>
 				<groupId>com.googlecode.japi-checker</groupId>
 				<artifactId>japi-checker-maven-plugin</artifactId>
 			</plugin>
 		</plugins>
-	</build>
+	</build> -->
 
 	<dependencies>
 		<dependency>
diff --git a/core/src/main/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModel.java b/core/src/main/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModel.java
index 6c1509c2d5..d880939a49 100755
--- a/core/src/main/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModel.java
+++ b/core/src/main/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModel.java
@@ -17,38 +17,185 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Queue;
+import java.util.Set;
+
 import javax.measure.quantity.Length;
 import javax.measure.quantity.Velocity;
 import javax.measure.unit.NonSI;
 import javax.measure.unit.SI;
 import javax.measure.unit.Unit;
 
+import com.github.rinde.rinsim.core.TimeLapse;
+import com.github.rinde.rinsim.event.Event;
+import com.github.rinde.rinsim.event.Listener;
+import com.github.rinde.rinsim.geom.Connection;
 import com.github.rinde.rinsim.geom.ConnectionData;
 import com.github.rinde.rinsim.geom.ListenableGraph;
+import com.github.rinde.rinsim.geom.ListenableGraph.GraphEvent;
+import com.github.rinde.rinsim.geom.Point;
+import com.google.common.base.Optional;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.primitives.Doubles;
 
 /**
- * @author Rinde van Lon
  *
+ * For information about modifying the graph see {@link DynamicGraphRoadModel}.
+ * For creating instances see {@link #builder(ListenableGraph)}.
+ * @author Rinde van Lon
  */
 public class CollisionGraphRoadModel extends DynamicGraphRoadModel {
+  private final double minConnLength;
   private final double vehicleLength;
   private final double minDistance;
+  private final BiMap<Point, RoadUser> occupiedNodes;
 
-  CollisionGraphRoadModel(Builder builder) {
+  CollisionGraphRoadModel(Builder builder, double pMinConnLength) {
     super(builder.graph, builder.distanceUnit, builder.speedUnit);
     vehicleLength = builder.vehicleLength;
     minDistance = builder.minDistance;
+    minConnLength = pMinConnLength;
+    occupiedNodes = HashBiMap.create();
+    builder.graph.getEventAPI().addListener(
+        new ModificationChecker(minConnLength),
+        ListenableGraph.EventTypes.ADD_CONNECTION,
+        ListenableGraph.EventTypes.CHANGE_CONNECTION_DATA);
   }
 
+  @Override
+  protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
+      TimeLapse time) {
+
+    if (occupiedNodes.containsValue(object)) {
+      occupiedNodes.inverse().remove(object);
+    }
+    // it should be checked whether the road is clear
+
+    final MoveProgress mp = super.doFollowPath(object, path, time);
+
+    // detects if the new location of the object occupies a node
+    // objLocs.get(object)
+
+    return mp;
+  }
+
+  @Override
+  protected void checkIsValidMove(Loc objLoc, Point nextHop) {
+    super.checkIsValidMove(objLoc, nextHop);
+
+    final Point from = objLoc.isOnConnection() ? objLoc.conn.get().from()
+        : objLoc;
+    // check if there is a vehicle driving in the opposite direction
+    checkArgument(
+        !connMap.containsKey(Conn.create(nextHop, from)),
+        "Deadlock detected: there is a vehicle driving in the opposite direction on the same connection.");
+  }
+
+  // todo deadlock! -> move to checkIsValidMove ?
+  @Override
+  protected boolean containsObstacle(Loc objLoc, Point nextHop) {
+    if (occupiedNodes.containsKey(nextHop)) {
+      return true;
+    }
+    Collection<RoadUser> obstacles;
+    if (objLoc.isOnConnection()) {
+      final Connection<?> conn = objLoc.conn.get();
+      obstacles = connMap.get(Conn.create(conn.from(), conn.to()));
+    }
+    else {
+      obstacles = connMap.get(Conn.create(objLoc, nextHop));
+      // check if there is an obstacle in front of the current position
+      for (final RoadUser ru : obstacles) {
+        // objLocs.get(ru)
+      }
+    }
+    return obstacles.isEmpty();
+  }
+
+  @Override
+  @Deprecated
+  public void addObjectAtSamePosition(RoadUser newObj, RoadUser existingObj) {
+    throw new UnsupportedOperationException(
+        "Vehicles can not be added at the same position.");
+  }
+
+  public boolean isOccupied(Point node) {
+    return occupiedNodes.containsKey(node);
+  }
+
+  /**
+   * @return A read-only indeterministic ordered live view of all currently
+   *         occupied nodes in the graph.
+   */
+  public Set<Point> getOccupiedNodes() {
+    return Collections.unmodifiableSet(occupiedNodes.keySet());
+  }
+
+  /**
+   * @return The length of all vehicles. The length is expressed in the unit as
+   *         specified by {@link #getDistanceUnit()}.
+   */
+  public double getVehicleLength() {
+    return vehicleLength;
+  }
+
+  /**
+   * @return The minimum distance vehicles need to be apart from each other. The
+   *         length is expressed in the unit as specified by
+   *         {@link #getDistanceUnit()}.
+   */
+  public double getMinDistance() {
+    return minDistance;
+  }
+
+  /**
+   * @return The minimum length all connections need to have in the graph. The
+   *         length is expressed in the unit as specified by
+   *         {@link #getDistanceUnit()}.
+   */
+  public double getMinConnLength() {
+    return minConnLength;
+  }
+
+  /**
+   * Create a {@link Builder} for constructing {@link CollisionGraphRoadModel}
+   * instances.
+   * @param graph A {@link ListenableGraph}
+   * @return A new {@link Builder} instance.
+   */
   public static Builder builder(ListenableGraph<? extends ConnectionData> graph) {
     return new Builder(graph);
   }
 
-  public static class Builder {
+  /**
+   * A builder for constructing {@link CollisionGraphRoadModel} instances. Use
+   * {@link CollisionGraphRoadModel#builder(ListenableGraph)} for obtaining
+   * builder instances.
+   * @author Rinde van Lon
+   */
+  public static final class Builder {
+    /**
+     * The default distance unit: {@link SI#METER}.
+     */
     public static final Unit<Length> DEFAULT_DISTANCE_UNIT = SI.METER;
+
+    /**
+     * The default speed unit: {@link NonSI#KILOMETERS_PER_HOUR}.
+     */
     public static final Unit<Velocity> DEFAULT_SPEED_UNIT = NonSI.KILOMETERS_PER_HOUR;
+
+    /**
+     * The default vehicle length: <code>1</code>.
+     */
     public static final double DEFAULT_VEHICLE_LENGTH = 1;
-    public static final double DEFAULT_MIN_DISTANCE = 0.25;
+
+    /**
+     * The default minimum distance: <code>.25</code>.
+     */
+    public static final double DEFAULT_MIN_DISTANCE = .25;
 
     final ListenableGraph<? extends ConnectionData> graph;
     Unit<Length> distanceUnit;
@@ -64,31 +211,105 @@ public static Builder builder(ListenableGraph<? extends ConnectionData> graph) {
       minDistance = DEFAULT_MIN_DISTANCE;
     }
 
+    /**
+     * Sets the distance unit used to interpret all coordinates and distances,
+     * including those of the supplied {@link ListenableGraph}. The default
+     * value is {@link #DEFAULT_DISTANCE_UNIT}.
+     * @param unit The unit to set.
+     * @return This, as per the builder pattern.
+     */
     public Builder setDistanceUnit(Unit<Length> unit) {
       distanceUnit = unit;
       return this;
     }
 
+    /**
+     * Sets the speed unit used to interpret the speeds of all vehicles. The
+     * default value is {@link #DEFAULT_SPEED_UNIT}.
+     * @param unit The unit to set.
+     * @return This, as per the builder pattern.
+     */
     public Builder setSpeedUnit(Unit<Velocity> unit) {
       speedUnit = unit;
       return this;
     }
 
+    /**
+     * Sets the length of each vehicle added to the
+     * {@link CollisionGraphRoadModel} that will be constructed by this builder.
+     * The vehicle length must be a strictly positive number. The default value
+     * is {@link #DEFAULT_VEHICLE_LENGTH}.
+     * @param length A length expressed in the unit set by
+     *          {@link #setDistanceUnit(Unit)}.
+     * @return This, as per the builder pattern.
+     */
     public Builder setVehicleLength(double length) {
-      checkArgument(length > 0d);
+      checkArgument(length > 0d,
+          "Only positive vehicle lengths are allowed, found %s.", length);
+      checkArgument(Doubles.isFinite(length),
+          "%s is not a valid vehicle length.", length);
       vehicleLength = length;
       return this;
     }
 
+    /**
+     * Sets the minimum required distance between two vehicles. The minimum
+     * distance must be a positive number &le; to 2 * vehicle length. The
+     * default value is {@link #DEFAULT_MIN_DISTANCE}.
+     * @param dist A distance expressed in the unit set by
+     *          {@link #setDistanceUnit(Unit)}.
+     * @return This, as per the builder pattern.
+     */
     public Builder setMinDistance(double dist) {
-      checkArgument(dist > 0d);
+      checkArgument(dist >= 0d);
       minDistance = dist;
       return this;
     }
 
+    /**
+     * @return A new {@link CollisionGraphRoadModel} instance.
+     */
     public CollisionGraphRoadModel build() {
-      return new CollisionGraphRoadModel(this);
+      final double minConnLength = 2 * vehicleLength;
+      checkArgument(
+          minDistance <= minConnLength,
+          "Min distance must be smaller than 2 * vehicle length (%s), but is %s.",
+          vehicleLength, minDistance);
+      for (final Connection<? extends ConnectionData> conn : graph
+          .getConnections()) {
+        checkConnectionLength(minConnLength, conn.from(), conn.to(),
+            conn.data());
+      }
+      return new CollisionGraphRoadModel(this, minConnLength);
+    }
+  }
+
+  static void checkConnectionLength(double minConnLength,
+      Point from, Point to, Optional<? extends ConnectionData> connData) {
+    checkArgument(
+        Point.distance(from, to) >= minConnLength,
+        "Invalid graph: the minimum connection length is %s, connection %s->%s is too short.",
+        minConnLength, from, to);
+    if (connData.isPresent() && connData.get().getLength().isPresent()) {
+      checkArgument(
+          connData.get().getLength().get() >= minConnLength,
+          "Invalid graph: the minimum connection length is %s, connection %s->%s defines length data that is too short.",
+          connData.get().getLength(), from, to);
     }
+  }
+
+  static class ModificationChecker implements Listener {
+    private final double minConnLength;
 
+    ModificationChecker(double minLength) {
+      minConnLength = minLength;
+    }
+
+    @Override
+    public void handleEvent(Event e) {
+      final GraphEvent event = (GraphEvent) e;
+      checkConnectionLength(minConnLength, event.getFrom(), event.getTo(),
+          event.getConnData());
+    }
   }
 }
diff --git a/core/src/main/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModel.java b/core/src/main/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModel.java
index 6d436d55bc..e5c8780aca 100755
--- a/core/src/main/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModel.java
+++ b/core/src/main/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModel.java
@@ -18,7 +18,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 
-import java.util.Objects;
 import java.util.Queue;
 
 import javax.measure.quantity.Length;
@@ -101,9 +100,8 @@ public void addObjectAtSamePosition(RoadUser newObj, RoadUser existingObj) {
     super.addObjectAtSamePosition(newObj, existingObj);
     final Loc loc = objLocs.get(newObj);
     if (loc.isOnConnection()) {
-      final Connection<? extends ConnectionData> conn = Objects
-          .requireNonNull(loc.conn);
-      connMap.put(Conn.create(conn.from, conn.to), newObj);
+      final Connection<? extends ConnectionData> conn = loc.conn.get();
+      connMap.put(Conn.create(conn.from(), conn.to()), newObj);
     } else {
       posMap.put(loc, newObj);
     }
@@ -129,9 +127,8 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
       TimeLapse time) {
     final Loc prevLoc = objLocs.get(object);
     if (prevLoc.isOnConnection()) {
-      final Connection<? extends ConnectionData> conn = Objects
-          .requireNonNull(prevLoc.conn);
-      connMap.remove(Conn.create(conn.from, conn.to), object);
+      final Connection<? extends ConnectionData> conn = prevLoc.conn.get();
+      connMap.remove(Conn.create(conn.from(), conn.to()), object);
     } else {
       posMap.remove(prevLoc, object);
     }
@@ -139,9 +136,8 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
 
     final Loc newLoc = objLocs.get(object);
     if (newLoc.isOnConnection()) {
-      final Connection<? extends ConnectionData> conn = Objects
-          .requireNonNull(newLoc.conn);
-      connMap.put(Conn.create(conn.from, conn.to), object);
+      final Connection<? extends ConnectionData> conn = newLoc.conn.get();
+      connMap.put(Conn.create(conn.from(), conn.to()), object);
     } else {
       posMap.put(newLoc, object);
     }
@@ -171,9 +167,8 @@ public void removeObject(RoadUser object) {
         "RoadUser: %s does not exist.", object);
     final Loc prevLoc = objLocs.get(object);
     if (prevLoc.isOnConnection()) {
-      final Connection<? extends ConnectionData> conn = Objects
-          .requireNonNull(prevLoc.conn);
-      connMap.remove(Conn.create(conn.from, conn.to), object);
+      final Connection<? extends ConnectionData> conn = prevLoc.conn.get();
+      connMap.remove(Conn.create(conn.from(), conn.to()), object);
     } else {
       posMap.remove(prevLoc, object);
     }
diff --git a/core/src/main/java/com/github/rinde/rinsim/core/model/road/GraphRoadModel.java b/core/src/main/java/com/github/rinde/rinsim/core/model/road/GraphRoadModel.java
index c959f8f4da..4ac89b824d 100755
--- a/core/src/main/java/com/github/rinde/rinsim/core/model/road/GraphRoadModel.java
+++ b/core/src/main/java/com/github/rinde/rinsim/core/model/road/GraphRoadModel.java
@@ -41,6 +41,7 @@
 import com.github.rinde.rinsim.geom.Graph;
 import com.github.rinde.rinsim.geom.MultiAttributeData;
 import com.github.rinde.rinsim.geom.Point;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.math.DoubleMath;
 
@@ -120,6 +121,7 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
     final List<Point> travelledNodes = new ArrayList<Point>();
     while (time.hasTimeLeft() && !path.isEmpty()) {
       checkIsValidMove(tempLoc, path.peek());
+      final boolean containsObstacle = containsObstacle(tempLoc, path.peek());
 
       // speed in internal speed unit
       final double speed = getMaxSpeed(object, tempPos, path.peek());
@@ -130,7 +132,9 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
       final double connLength = toInternalDistConv
           .convert(computeConnectionLength(tempPos, path.peek()));
 
-      if (travelDistance >= connLength) {
+      if (containsObstacle) {
+
+      } else if (travelDistance >= connLength) {
         // jump to next vertex
         tempPos = path.remove();
         if (!(tempPos instanceof Loc)) {
@@ -147,16 +151,16 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
         } else {
           tempLoc = checkLocation(newLoc(tempPos));
         }
-
       } else {
         // distanceLeft < connLength
         newDis = travelDistance;
         time.consumeAll();
         traveled += travelDistance;
 
-        final Point from = isOnConnection(tempLoc) ? tempLoc.conn.from
+        final Point from = isOnConnection(tempLoc) ? tempLoc.conn.get().from()
             : tempLoc;
-        final Point peekTo = isOnConnection(path.peek()) ? ((Loc) path.peek()).conn.to
+        final Point peekTo = isOnConnection(path.peek()) ?
+            ((Loc) path.peek()).conn.get().to()
             : path.peek();
         final Connection<?> conn = graph.getConnection(from, peekTo);
         tempLoc = checkLocation(newLoc(conn, tempLoc.relativePos
@@ -175,17 +179,22 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
     return new MoveProgress(distTraveled, timeConsumed, travelledNodes);
   }
 
+  protected boolean containsObstacle(Loc objLoc, Point nextHop) {
+    return false;
+  }
+
   /**
    * Check if it is possible to move from <code>objLoc</code> to
    * <code>nextHop</code>.
    * @param objLoc The current location.
    * @param nextHop The destination node.
+   * @throws IllegalArgumentException if it the proposed move is invalid.
    */
   protected void checkIsValidMove(Loc objLoc, Point nextHop) {
     // in case we start from an edge and our next destination is to go to
     // the end of the current edge then its ok. Otherwise more checks are
     // required..
-    if (objLoc.isOnConnection() && !nextHop.equals(objLoc.conn.to)) {
+    if (objLoc.isOnConnection() && !nextHop.equals(objLoc.conn.get().to())) {
       // check if next destination is a MidPoint
       checkArgument(
           nextHop instanceof Loc,
@@ -206,9 +215,9 @@ else if (!objLoc.isOnConnection() && !nextHop.equals(objLoc)
       checkArgument(nextHop instanceof Loc,
           "Illegal path, first point should be directly connected to object location.");
       final Loc dest = (Loc) nextHop;
-      checkArgument(graph.hasConnection(objLoc, dest.conn.to),
+      checkArgument(graph.hasConnection(objLoc, dest.conn.get().to()),
           "Illegal path, first point is on an edge not connected to object location. ");
-      checkArgument(objLoc.equals(dest.conn.from),
+      checkArgument(objLoc.equals(dest.conn.get().from()),
           "Illegal path, first point is on a different edge.");
     }
   }
@@ -235,30 +244,20 @@ protected double computeConnectionLength(Point from, Point to) {
       return Math.abs(start.relativePos - end.relativePos);
     } else if (isOnConnection(from)) {
       final Loc start = (Loc) from;
-      checkArgument(start.conn.to.equals(to),
+      checkArgument(start.conn.get().to().equals(to),
           "from is not on a connection leading to 'to'");
       return start.connLength - start.relativePos;
     } else if (isOnConnection(to)) {
       final Loc end = (Loc) to;
-      checkArgument(end.conn.from.equals(from), "to is not connected to from");
+      checkArgument(end.conn.get().from().equals(from),
+          "to is not connected to from");
       return end.relativePos;
     } else {
       checkArgument(graph.hasConnection(from, to), "connection does not exist");
-      return getConnectionLength(graph.getConnection(from, to));
+      return graph.getConnection(from, to).getLength();
     }
   }
 
-  /**
-   * Retrieves the length of the specified connection if it is defined.
-   * @param conn The connection to check.
-   * @return The length.
-   */
-  protected static double getConnectionLength(Connection<?> conn) {
-    return conn.getData() == null || Double.isNaN(conn.getData().getLength()) ? Point
-        .distance(conn.from, conn.to)
-        : conn.getData().getLength();
-  }
-
   /**
    * Checks if the point is on a connection.
    * @param p The point to check.
@@ -279,7 +278,8 @@ protected Loc checkLocation(Loc l) {
     checkArgument(l.isOnConnection() || graph.containsNode(l),
         "Location points to non-existing vertex: %s.", l);
     checkArgument(
-        !l.isOnConnection() || graph.hasConnection(l.conn.from, l.conn.to),
+        !l.isOnConnection()
+            || graph.hasConnection(l.conn.get().from(), l.conn.get().to()),
         "Location points to non-existing connection: %s.", l.conn);
     return l;
   }
@@ -296,12 +296,16 @@ protected double getMaxSpeed(MovingRoadUser object, Point from, Point to) {
     final double objSpeed = toInternalSpeedConv.convert(object.getSpeed());
     if (!from.equals(to)) {
       final Connection<?> conn = getConnection(from, to);
-      if (conn.getData() instanceof MultiAttributeData) {
-        final MultiAttributeData maed = (MultiAttributeData) conn.getData();
-        @SuppressWarnings("null")
-        final double connSpeedLimit = maed.getMaxSpeed();
-        return Double.isNaN(connSpeedLimit) ? objSpeed : Math.min(
-            toInternalSpeedConv.convert(connSpeedLimit), objSpeed);
+      if (conn.data().isPresent()
+          && conn.data().get() instanceof MultiAttributeData) {
+        final MultiAttributeData maed = (MultiAttributeData) conn.data()
+            .get();
+
+        if (maed.getMaxSpeed().isPresent()) {
+          return Math.min(
+              toInternalSpeedConv.convert(maed.getMaxSpeed().get()), objSpeed);
+        }
+        return objSpeed;
       }
     }
     return objSpeed;
@@ -318,23 +322,23 @@ protected double getMaxSpeed(MovingRoadUser object, Point from, Point to) {
   protected Connection<?> getConnection(Point from, Point to) {
     final boolean fromIsOnConn = isOnConnection(from);
     final boolean toIsOnConn = isOnConnection(to);
-    Connection<?> conn = null;
+    Connection<?> conn;
     if (fromIsOnConn) {
       final Loc start = (Loc) from;
       if (toIsOnConn) {
         checkArgument(start.isOnSameConnection((Loc) to),
             "The specified points must be part of the same connection.");
       } else {
-        checkArgument(start.conn.to.equals(to),
+        checkArgument(start.conn.get().to().equals(to),
             "The specified points must be part of the same connection.");
       }
-      conn = start.conn;
+      conn = start.conn.get();
 
     } else if (toIsOnConn) {
       final Loc end = (Loc) to;
-      checkArgument(end.conn.from.equals(from),
+      checkArgument(end.conn.get().from().equals(from),
           "The specified points must be part of the same connection.");
-      conn = end.conn;
+      conn = end.conn.get();
     } else {
       checkArgument(graph.hasConnection(from, to),
           "The specified points must be part of an existing connection in the graph.");
@@ -348,13 +352,13 @@ protected double getMaxSpeed(MovingRoadUser object, Point from, Point to) {
     final List<Point> path = new ArrayList<Point>();
     Point start = from;
     if (isOnConnection(from)) {
-      start = ((Loc) from).conn.to;
+      start = ((Loc) from).conn.get().to();
       path.add(from);
     }
 
     Point end = to;
     if (isOnConnection(to)) {
-      end = ((Loc) to).conn.from;
+      end = ((Loc) to).conn.get().from();
     }
     path.addAll(doGetShortestPathTo(start, end));
     if (isOnConnection(to)) {
@@ -385,18 +389,18 @@ protected double getMaxSpeed(MovingRoadUser object, Point from, Point to) {
 
   /**
    * Retrieves the connection which the specified {@link RoadUser} is at. If the
-   * road user is at a vertex <code>null</code> is returned instead.
+   * road user is at a vertex {@link Optional#absent()} is returned instead.
    * @param obj The object which position is checked.
    * @return A {@link Connection} if <code>obj</code> is on one,
-   *         <code>null</code> otherwise.
+   *         {@link Optional#absent()} otherwise.
    */
-  @Nullable
-  public Connection<? extends ConnectionData> getConnection(RoadUser obj) {
+  public Optional<? extends Connection<?>> getConnection(RoadUser obj) {
     final Loc point = objLocs.get(obj);
     if (isOnConnection(point)) {
-      return graph.getConnection(point.conn.from, point.conn.to);
+      return Optional.of(graph
+          .getConnection(point.conn.get().from(), point.conn.get().to()));
     }
-    return null;
+    return Optional.absent();
   }
 
   /**
@@ -420,14 +424,15 @@ protected static Loc newLoc(Point p) {
    */
   protected static Loc newLoc(Connection<? extends ConnectionData> conn,
       double relativePos) {
-    final Point diff = Point.diff(conn.to, conn.from);
-    final double roadLength = getConnectionLength(conn);
+    final Point diff = Point.diff(conn.to(), conn.from());
+    final double roadLength = conn.getLength();
 
     final double perc = relativePos / roadLength;
     if (perc + DELTA >= 1) {
-      return new Loc(conn.to.x, conn.to.y, null, -1, 0);
+      return new Loc(conn.to().x, conn.to().y, null, -1, 0);
     }
-    return new Loc(conn.from.x + perc * diff.x, conn.from.y + perc * diff.y,
+    return new Loc(conn.from().x + perc * diff.x,
+        conn.from().y + perc * diff.y,
         conn, roadLength, relativePos);
   }
 
@@ -468,11 +473,9 @@ public Point getRandomPosition(RandomGenerator rnd) {
      */
     public final double relativePos;
     /**
-     * The {@link Connection} which this position is on, can be
-     * <code>null</code>.
+     * The {@link Connection} which this position is on if present.
      */
-    @Nullable
-    public final Connection<? extends ConnectionData> conn;
+    public final Optional<? extends Connection<?>> conn;
 
     Loc(double pX, double pY,
         @Nullable Connection<? extends ConnectionData> pConn,
@@ -480,14 +483,14 @@ public Point getRandomPosition(RandomGenerator rnd) {
       super(pX, pY);
       connLength = pConnLength;
       relativePos = pRelativePos;
-      conn = pConn;
+      conn = Optional.fromNullable(pConn);
     }
 
     /**
      * @return <code>true</code> if the position is on a connection.
      */
     public boolean isOnConnection() {
-      return conn != null;
+      return conn.isPresent();
     }
 
     /**
@@ -497,11 +500,7 @@ public boolean isOnConnection() {
      * @return <code>true</code> if both {@link Loc}s are on the same
      *         connection, <code>false</code> otherwise.
      */
-    @SuppressWarnings("null")
     public boolean isOnSameConnection(Loc l) {
-      if (!isOnConnection() || !l.isOnConnection()) {
-        return false;
-      }
       return conn.equals(l.conn);
     }
 
diff --git a/core/src/main/java/com/github/rinde/rinsim/serializers/DotGraphSerializer.java b/core/src/main/java/com/github/rinde/rinsim/serializers/DotGraphSerializer.java
index 4212b9bbac..c953556dd7 100755
--- a/core/src/main/java/com/github/rinde/rinsim/serializers/DotGraphSerializer.java
+++ b/core/src/main/java/com/github/rinde/rinsim/serializers/DotGraphSerializer.java
@@ -35,9 +35,9 @@
  * in dot format. The default implementation of the serializer for graphs with
  * edge length information can be obtained via calling
  * {@link DotGraphSerializer#getLengthGraphSerializer(SerializerFilter...)}
- * 
+ *
  * @author Bartosz Michalik
- * 
+ *
  */
 public class DotGraphSerializer<E extends ConnectionData> extends
     AbstractGraphSerializer<E> {
@@ -122,8 +122,9 @@ public void write(Graph<? extends E> graph, Writer writer) throws IOException {
     }
 
     for (final Connection<? extends E> entry : graph.getConnections()) {
-      string.append(serializer.serializeConnection(idMap.get(entry.from), idMap
-          .get(entry.to), entry));
+      string.append(serializer.serializeConnection(idMap.get(entry.from()),
+          idMap
+              .get(entry.to()), entry));
     }
     string.append('}');
     out.append(string);
@@ -134,7 +135,7 @@ public void write(Graph<? extends E> graph, Writer writer) throws IOException {
   /**
    * Used to serialize graphs
    * @author Bartosz Michalik
-   * 
+   *
    * @since 2.0
    */
   public static abstract class ConnectionSerializer<E extends ConnectionData> {
@@ -156,14 +157,15 @@ public String serializeConnection(int idFrom, int idTo,
       buffer.append(NODE_PREFIX).append(idFrom).append(" -> ")
           .append(NODE_PREFIX).append(idTo);
       buffer.append('[').append(DISTANCE).append("=\"")
-          .append(Math.round(conn.getData().getLength()) / 10d).append("\"]\n");
+          .append(Math.round(conn.data().get().getLength().get()) / 10d)
+          .append("\"]\n");
       return buffer.toString();
     }
 
     @Override
     public LengthData deserialize(String connection) {
       final double distance = Double.parseDouble(connection.split("\"")[1]);
-      return new LengthData(distance);
+      return LengthData.create(distance);
     }
   }
 
@@ -178,11 +180,10 @@ public String serializeConnection(int idFrom, int idTo,
       buffer.append(NODE_PREFIX).append(idFrom).append(" -> ")
           .append(NODE_PREFIX).append(idTo);
       buffer.append('[').append(DISTANCE).append("=\"")
-          .append(Math.round(conn.getData().getLength()) / 10d);
-      if (!Double.isNaN(conn.getData().getMaxSpeed())
-          && conn.getData().getMaxSpeed() > 0) {
+          .append(Math.round(conn.data().get().getLength().get()) / 10d);
+      if (conn.data().get().getMaxSpeed().isPresent()) {
         buffer.append("\", ").append(MAX_SPEED).append("=\"")
-            .append(conn.getData().getMaxSpeed());
+            .append(conn.data().get().getMaxSpeed().get());
       }
       buffer.append("\"]\n");
       return buffer.toString();
@@ -193,9 +194,14 @@ public MultiAttributeData deserialize(String connection) {
       final double distance = Double.parseDouble(connection.split("\"")[1]);
       try {
         final double maxSpeed = Double.parseDouble(connection.split("\"")[3]);
-        return new MultiAttributeData(distance, maxSpeed);
+        return MultiAttributeData.builder()
+            .setLength(distance)
+            .setMaxSpeed(maxSpeed)
+            .build();
       } catch (final Exception e) {
-        return new MultiAttributeData(distance);
+        return MultiAttributeData.builder()
+            .setLength(distance)
+            .build();
       }
     }
   }
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModelTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModelTest.java
index f0d6f34f91..a5808564af 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModelTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/CollisionGraphRoadModelTest.java
@@ -15,7 +15,6 @@
  */
 package com.github.rinde.rinsim.core.model.road;
 
-import static com.github.rinde.rinsim.core.TimeLapseFactory.hour;
 import static com.github.rinde.rinsim.core.TimeLapseFactory.ms;
 import static com.github.rinde.rinsim.geom.PointAssert.assertPointEquals;
 import static org.junit.Assert.assertEquals;
@@ -24,6 +23,7 @@
 import java.math.RoundingMode;
 
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import com.github.rinde.rinsim.core.TimeLapse;
@@ -35,8 +35,8 @@
 import com.google.common.math.DoubleMath;
 
 /**
+ * Tests for {@link CollisionGraphRoadModel}.
  * @author Rinde van Lon
- *
  */
 public class CollisionGraphRoadModelTest {
   @SuppressWarnings("null")
@@ -51,7 +51,7 @@
    */
   @Before
   public void setUp() {
-    graph = new ListenableGraph<>(new TableGraph<LengthData>(LengthData.EMPTY));
+    graph = new ListenableGraph<>(new TableGraph<LengthData>());
     model = CollisionGraphRoadModel.builder(graph).build();
     SW = new Point(0, 0);
     SE = new Point(10, 0);
@@ -81,10 +81,12 @@ public void testAddObjectAtSamePosition() {
   }
 
   /**
-   * Adding an object at the same position is not allowed.
+   * Adding an object to an occupied node is not allowed, but when the node is
+   * free it is allowed.
    */
+  @Ignore
   @Test
-  public void testAddObjectAtSamePos() {
+  public void testAddObject() {
     final MovingRoadUser agv1 = new TestRoadUser();
     final MovingRoadUser agv2 = new TestRoadUser();
     model.addObjectAt(agv1, SW);
@@ -95,8 +97,31 @@ public void testAddObjectAtSamePos() {
       fail = true;
     }
     assertTrue(fail);
+
+    // max distance to travel while still staying within node area
+    model.moveTo(agv1, NW, meter(0.9997222222));
+
+    fail = false;
+    try {
+      model.addObjectAt(agv2, SW);
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+
+    // exiting node area, adding to SW is allowed now
+    model.moveTo(agv1, NW, meter(0.0002777777778));
+    model.addObjectAt(agv2, SW);
+    assertEquals(SW, model.getPosition(agv2));
   }
 
+  /**
+   * Test for detection of a dead lock situation between two AGVs. The AGVs
+   * drive on the same connection from opposite ends. An
+   * {@link IllegalArgumentException} should be thrown at the moment the second
+   * AGV tries to enter the connection.
+   */
+  @Ignore
   @Test
   public void testDetectDeadLock() {
     final MovingRoadUser agv1 = new TestRoadUser();
@@ -104,18 +129,23 @@ public void testDetectDeadLock() {
     model.addObjectAt(agv1, SW);
     model.addObjectAt(agv2, NW);
 
-    model.moveTo(agv1, NW, hour(5));
+    model.moveTo(agv1, NW, meter(5));
     boolean fail = false;
     try {
-      model.moveTo(agv2, SW, hour(6));
+      model.moveTo(agv2, SW, meter(1));
     } catch (final IllegalArgumentException e) {
       fail = true;
     }
     assertTrue(fail);
   }
 
+  /**
+   * Test for checking that an AGV can not overtake another AGV on the same
+   * connection. The AGV that is behind should be forced to stay behind.
+   */
+  @Ignore
   @Test
-  public void testTailCollisionAvoidance() {
+  public void testHeadTailCollisionAvoidance() {
     final MovingRoadUser agv1 = new TestRoadUser();
     final MovingRoadUser agv2 = new TestRoadUser();
     model.addObjectAt(agv1, SW);
@@ -129,9 +159,213 @@ public void testTailCollisionAvoidance() {
         GraphRoadModel.DELTA);
     assertPointEquals(new Point(1.75, 0), model.getPosition(agv2),
         GraphRoadModel.DELTA);
+
+    // moving is not allowed
+    checkNoMovement(model.moveTo(agv2, SE, meter(20)));
+
+    // when the object is removed, moving is allowed
+    model.removeObject(agv1);
+    model.moveTo(agv2, SE, meter(20));
+    assertPointEquals(SE, model.getPosition(agv2), GraphRoadModel.DELTA);
+  }
+
+  /**
+   * Test for avoidance of a collision on a node. When one AGV comes near ( < of
+   * its length) a node, this node becomes blocked for any other node.
+   */
+  @Ignore
+  @Test
+  public void testNodeCollisionAvoidance() {
+    final Point X = new Point(0, -10);
+    model.getGraph().addConnection(SW, X);
+
+    final MovingRoadUser agv1 = new TestRoadUser();
+    final MovingRoadUser agv2 = new TestRoadUser();
+    model.addObjectAt(agv1, SE);
+    model.addObjectAt(agv2, NW);
+
+    // this represents the smallest travelable distance to come within the area
+    // of a node.
+    final TimeLapse tl = meter(9.0002777777778);
+    assertEquals(32401L, tl.getTimeLeft());
+    // agv1 is within the node area of SW now.
+    model.moveTo(agv1, SW, tl);
+    model.moveTo(agv2, SW, meter(10));
+
+    assertPointEquals(new Point(1, 0), model.getPosition(agv1),
+        GraphRoadModel.DELTA);
+    assertPointEquals(new Point(0, 1.25), model.getPosition(agv2),
+        GraphRoadModel.DELTA);
+
+    // moving agv2 is not allowed
+    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
+
+    // agv1 moves to center of node, moving agv2 is still not allowed
+    model.moveTo(agv1, SW, meter(1));
+    assertEquals(SW, model.getPosition(agv1));
+    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
+
+    // this represents the maximum distance to travel while still staying within
+    // the node's area, moving agv2 is still not allowed
+    final TimeLapse tl2 = meter(0.9997222222);
+    assertEquals(3599L, tl2.getTimeLeft());
+    model.moveTo(agv1, X, tl2);
+    checkNoMovement(model.moveTo(agv2, SW, meter(20)));
+
+    // this represents the distance to travel to get outside of the node's area,
+    // moving agv2 is now allowed
+    final TimeLapse tl3 = meter(0.0002777777778);
+    assertEquals(1L, tl3.getTimeLeft());
+    model.moveTo(agv1, X, tl3);
+    assertPointEquals(new Point(0, -1), model.getPosition(agv1),
+        GraphRoadModel.DELTA);
+    model.moveTo(agv2, SW, meter(2));
+    assertEquals(SW, model.getPosition(agv2));
+  }
+
+  /**
+   * Tests valid and invalid values for vehicleLength.
+   */
+  @Test
+  public void testBuilderVehicleLength() {
+    // vehicle length must be > 0
+    boolean fail = false;
+    try {
+      CollisionGraphRoadModel.builder(graph)
+          .setVehicleLength(0d);
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+
+    // vehicle length may not be infinite
+    fail = false;
+    try {
+      CollisionGraphRoadModel.builder(graph)
+          .setVehicleLength(Double.POSITIVE_INFINITY);
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+
+    final CollisionGraphRoadModel cgr1 = CollisionGraphRoadModel.builder(graph)
+        .setVehicleLength(5d)
+        .build();
+    assertEquals(5d, cgr1.getVehicleLength(), 0);
   }
 
+  /**
+   * Tests valid and invalid values for minDistance.
+   */
+  @Test
+  public void testBuilderMinDistance() {
+    assertEquals(0d, CollisionGraphRoadModel.builder(graph)
+        .setMinDistance(0d)
+        .build()
+        .getMinDistance(),
+        0);
+
+    assertEquals(2d, CollisionGraphRoadModel.builder(graph)
+        .setMinDistance(2d)
+        .build()
+        .getMinDistance(),
+        0);
+
+    // min distance may not be > 2 * vehicle length
+    boolean fail = false;
+    try {
+      CollisionGraphRoadModel.builder(graph)
+          .setMinDistance(2.000000001)
+          .build();
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+
+    // min distance may not be negative
+    fail = false;
+    try {
+      CollisionGraphRoadModel.builder(graph)
+          .setMinDistance(-1d);
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+  }
+
+  /**
+   * Some graphs are not compatible with {@link CollisionGraphRoadModel}.
+   */
+  @Test
+  public void testDetectInvalidConnAtConstruction() {
+    final ListenableGraph<?> g = new ListenableGraph<>(
+        new TableGraph<LengthData>());
+    // this connection is allowed:
+    g.addConnection(new Point(0, 0), new Point(2, 0));
+    // this connection is not allowed:
+    g.addConnection(new Point(0, 0), new Point(1.99, 0));
+    boolean fail = false;
+    try {
+      CollisionGraphRoadModel.builder(g)
+          .setVehicleLength(1d)
+          .setMinDistance(.25)
+          .build();
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+  }
+
+  /**
+   * Test the addition of a connection that is too short.
+   */
+  @Test
+  public void testDetectAddInvalidConnLive() {
+    final Point a = new Point(0, 0);
+    final Point b = new Point(2, 0);
+    model.getGraph().addConnection(a, b);
+    assertTrue(model.getGraph().hasConnection(a, b));
+
+    boolean fail = false;
+    try {
+      model.getGraph().addConnection(new Point(0, 0), new Point(1.99, 0));
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+  }
+
+  /**
+   * Test a change of a conn such that it becomes too short.
+   */
+  @Test
+  public void testDetectChangeConnInvalidLive() {
+    // this is allowed
+    graph.setConnectionData(SW, NW, LengthData.create(2d));
+
+    boolean fail = false;
+    try {
+      // this is too short
+      graph.setConnectionData(SW, NW, LengthData.create(1.99));
+    } catch (final IllegalArgumentException e) {
+      fail = true;
+    }
+    assertTrue(fail);
+  }
+
+  /**
+   * Helper function that constructs {@link TimeLapse} instances that allow
+   * traveling <code>n</code> meters.
+   * @param m
+   * @return
+   */
   static TimeLapse meter(double m) {
     return ms(DoubleMath.roundToLong(3600d * m, RoundingMode.HALF_UP));
   }
+
+  static void checkNoMovement(MoveProgress mp) {
+    assertTrue(mp.travelledNodes.isEmpty());
+    assertEquals(0L, mp.time.getValue().longValue());
+    assertEquals(0d, mp.distance.getValue().doubleValue(), 0);
+  }
 }
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/ConnectionTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/ConnectionTest.java
new file mode 100755
index 0000000000..c7b8672d31
--- /dev/null
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/ConnectionTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *         http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.rinde.rinsim.core.model.road;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Test;
+
+import com.github.rinde.rinsim.geom.Connection;
+import com.github.rinde.rinsim.geom.MultiAttributeData;
+import com.github.rinde.rinsim.geom.Point;
+
+/**
+ * @author Rinde van Lon
+ *
+ */
+public class ConnectionTest {
+  /**
+   * Tests correct implementation of get length.
+   */
+  @Test
+  public void testGetLength() {
+    final Point a = new Point(0, 0);
+    final Point b = new Point(10, 0);
+
+    assertEquals(10, Connection.create(a, b).getLength(), GraphRoadModel.DELTA);
+    final Connection<MultiAttributeData> conn =
+        Connection.create(a, b, MultiAttributeData.builder()
+            .setLength(12)
+            .setMaxSpeed(1d)
+            .build());
+    assertEquals(12, conn.getLength(), GraphRoadModel.DELTA);
+
+    final Connection<MultiAttributeData> conn2 =
+        Connection.create(a, b, MultiAttributeData.builder()
+            .setMaxSpeed(1d)
+            .build());
+    assertEquals(10, conn2.getLength(), GraphRoadModel.DELTA);
+  }
+}
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModelTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModelTest.java
index d91945ead1..1de155348e 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModelTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/DynamicGraphRoadModelTest.java
@@ -47,7 +47,7 @@
    */
   @Before
   public void setUp() {
-    graph = new ListenableGraph<>(new TableGraph<LengthData>(LengthData.EMPTY));
+    graph = new ListenableGraph<>(new TableGraph<LengthData>());
     model = new DynamicGraphRoadModel(graph);
     SW = new Point(0, 0);
     SE = new Point(10, 0);
@@ -87,10 +87,10 @@ public void testModifyGraphUpdateShortestPath() {
     // a new path is created, therefore the shortest path changes to: [cur -> SE
     // -> X -> SW]
     final Point X = new Point(5, 5);
-    graph.addConnection(SE, X, new LengthData(1d));
-    graph.addConnection(X, SE, new LengthData(1d));
-    graph.addConnection(X, SW, new LengthData(1d));
-    graph.addConnection(SW, X, new LengthData(1d));
+    graph.addConnection(SE, X, LengthData.create(1d));
+    graph.addConnection(X, SE, LengthData.create(1d));
+    graph.addConnection(X, SW, LengthData.create(1d));
+    graph.addConnection(SW, X, LengthData.create(1d));
 
     final MoveProgress mp2 = model.moveTo(tru, SW, hour(10));
 
@@ -104,7 +104,7 @@ public void testModifyGraphUpdateShortestPath() {
     model.moveTo(tru, SE, hour(1));
     // right now, the shortest path to SE is: [cur -> SW -> X -> SE].
 
-    graph.setConnectionData(SW, X, new LengthData(10d));
+    graph.setConnectionData(SW, X, LengthData.create(10d));
     // connection length is changed so new path becomes: [cur -> SW -> SE].
     final MoveProgress mp3 = model.moveTo(tru, SE, hour(18));
 
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/ForwardingRoadModelTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/ForwardingRoadModelTest.java
index 8e8d716992..0cd1518077 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/ForwardingRoadModelTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/ForwardingRoadModelTest.java
@@ -25,21 +25,20 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.github.rinde.rinsim.core.model.road.ForwardingRoadModel;
-import com.github.rinde.rinsim.core.model.road.GenericRoadModel;
-import com.github.rinde.rinsim.core.model.road.GraphRoadModel;
-import com.github.rinde.rinsim.core.model.road.PlaneRoadModel;
 import com.github.rinde.rinsim.geom.Graph;
+import com.github.rinde.rinsim.geom.MultimapGraph;
 import com.github.rinde.rinsim.geom.Point;
-import com.github.rinde.rinsim.geom.TestMultimapGraph;
 
 /**
- * @author Rinde van Lon 
- * 
+ * @author Rinde van Lon
+ *
  */
 @RunWith(Parameterized.class)
 public class ForwardingRoadModelTest extends
     AbstractRoadModelTest<GenericRoadModel> {
+  /**
+   * @return The configs to test.
+   */
   @Parameters
   public static Collection<Object[]> configs() {
     return Arrays.asList(new Object[][] //
@@ -67,7 +66,7 @@ public GenericRoadModel create(ForwardingRoadModelTest testClass) {
   }
 
   Graph<?> createGraph() {
-    final Graph<?> g = new TestMultimapGraph();
+    final Graph<?> g = new MultimapGraph<>();
     g.addConnection(SW, SE);
     g.addConnection(SE, NE);
     g.addConnection(NE, NW);
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/GraphRoadModelTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/GraphRoadModelTest.java
index fb4cc39cc1..97bf013168 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/GraphRoadModelTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/GraphRoadModelTest.java
@@ -19,7 +19,6 @@
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 import java.lang.reflect.InvocationTargetException;
@@ -51,8 +50,7 @@
 import com.github.rinde.rinsim.geom.MultiAttributeData;
 import com.github.rinde.rinsim.geom.MultimapGraph;
 import com.github.rinde.rinsim.geom.Point;
-import com.github.rinde.rinsim.geom.TestMultimapGraph;
-import com.github.rinde.rinsim.geom.TestTableGraph;
+import com.github.rinde.rinsim.geom.TableGraph;
 import com.google.common.base.Supplier;
 
 /**
@@ -77,26 +75,26 @@ public GraphRoadModelTest(Supplier<GraphRoadModel> supplier) {
         { new Supplier<GraphRoadModel>() {
           @Override
           public GraphRoadModel get() {
-            return new GraphRoadModel(new TestMultimapGraph());
+            return new GraphRoadModel(new MultimapGraph<>());
           }
         } },
         { new Supplier<GraphRoadModel>() {
           @Override
           public GraphRoadModel get() {
-            return new CachedGraphRoadModel(new TestMultimapGraph(),
+            return new CachedGraphRoadModel(new MultimapGraph<>(),
                 SI.KILOMETER, NonSI.KILOMETERS_PER_HOUR);
           }
         } },
         { new Supplier<GraphRoadModel>() {
           @Override
           public GraphRoadModel get() {
-            return new GraphRoadModel(new TestTableGraph());
+            return new GraphRoadModel(new TableGraph<>());
           }
         } },
         { new Supplier<GraphRoadModel>() {
           @Override
           public GraphRoadModel get() {
-            return new CachedGraphRoadModel(new TestTableGraph(),
+            return new CachedGraphRoadModel(new TableGraph<>(),
                 SI.KILOMETER, NonSI.KILOMETERS_PER_HOUR);
           }
         } },
@@ -104,7 +102,7 @@ public GraphRoadModel get() {
           @Override
           public GraphRoadModel get() {
             return new DynamicGraphRoadModel(new ListenableGraph<>(
-                new TestTableGraph()));
+                new TableGraph<>()));
           }
         } },
     });
@@ -113,8 +111,8 @@ public GraphRoadModel get() {
   @Override
   @Before
   public void setUp() throws InstantiationException, IllegalAccessException,
-  IllegalArgumentException, SecurityException, InvocationTargetException,
-  NoSuchMethodException {
+      IllegalArgumentException, SecurityException, InvocationTargetException,
+      NoSuchMethodException {
     model = supplier.get();
     graph = model.graph;
 
@@ -164,14 +162,14 @@ public void followLongPath() {
     final TestRoadUser ab = new TestRoadUser();
     model.addObjectAt(ab, A);
     model.followPath(ab, asPath(B), hour());
-    assertEquals(A, model.getConnection(ab).from);
-    assertEquals(B, model.getConnection(ab).to);
+    assertEquals(A, model.getConnection(ab).get().from());
+    assertEquals(B, model.getConnection(ab).get().to());
 
     final TestRoadUser bc = new TestRoadUser();
     model.addObjectAt(bc, B);
     model.followPath(bc, asPath(C), hour());
-    assertEquals(B, model.getConnection(bc).from);
-    assertEquals(C, model.getConnection(bc).to);
+    assertEquals(B, model.getConnection(bc).get().from());
+    assertEquals(C, model.getConnection(bc).get().to());
 
     final Queue<Point> path = asPath(SW, SE, NE, A, model.getPosition(ab), B,
         model.getPosition(bc), C);
@@ -190,7 +188,7 @@ public void followPathToMiddleAndBackFail() {
     final TestRoadUser middle = new TestRoadUser();
     model.addObjectAt(middle, SW);
     model.followPath(middle, asPath(SE), hour());
-    assertTrue(connectionEquals(model.getConnection(middle), SW, SE));
+    assertTrue(connectionEquals(model.getConnection(middle).get(), SW, SE));
 
     final TestRoadUser driver = new TestRoadUser();
     model.addObjectAt(driver, SW);
@@ -305,7 +303,7 @@ public void followPathHalfway1() {
     assertEquals(asList(new Point(5, 0), SE, NE), path2);
     model.followPath(agent2, path2, hour(10));
     assertEquals(new Point(10, 5), model.getPosition(agent2));
-    assertTrue(connectionEquals(model.getConnection(agent2), SE, NE));
+    assertTrue(connectionEquals(model.getConnection(agent2).get(), SE, NE));
 
     // coming from the front side, we have to turn around at p1
     final Queue<Point> path3 = new LinkedList<Point>(model.getShortestPathTo(
@@ -589,9 +587,9 @@ public void moveTo() {
   public void getConnectionTest() {
     final TestRoadUser driver = new TestRoadUser();
     model.addObjectAt(driver, SE);
-    assertNull(model.getConnection(driver));
+    assertFalse(model.getConnection(driver).isPresent());
     model.followPath(driver, asPath(NE), hour());
-    assertTrue(connectionEquals(model.getConnection(driver), SE, NE));
+    assertTrue(connectionEquals(model.getConnection(driver).get(), SE, NE));
   }
 
   @Test
@@ -599,7 +597,7 @@ public void getShortestPath() {
     final TestRoadUser driver = new TestRoadUser();
     model.addObjectAt(driver, SW);
     model.followPath(driver, asPath(SE), hour());
-    assertTrue(connectionEquals(model.getConnection(driver), SW, SE));
+    assertTrue(connectionEquals(model.getConnection(driver).get(), SW, SE));
 
     final List<Point> path = model.getShortestPathTo(driver, NE);
     assertEquals(asList(model.getPosition(driver), SE, NE), path);
@@ -650,21 +648,16 @@ public void locationConstructorFail() {
   @Test
   public void locationIsOnSameEdge() {
     ((Graph<MultiAttributeData>) graph).addConnection(SE, SW,
-        new MultiAttributeData(300));
+        MultiAttributeData.builder().setLength(300).build());
     ((Graph<MultiAttributeData>) graph).addConnection(NE, SW,
-        new MultiAttributeData(Double.NaN));
-
-    final Loc loc1 = GraphRoadModel.newLoc(new Connection<ConnectionData>(SW,
-        SE, null), 3);
-    final Loc loc2 = GraphRoadModel.newLoc(new Connection<ConnectionData>(SW,
-        SE, null), 1);
-    final Loc loc3 = GraphRoadModel.newLoc(new Connection<ConnectionData>(SE,
-        NE, null), 9.999999);
+        MultiAttributeData.builder().build());
+
+    final Loc loc1 = GraphRoadModel.newLoc(Connection.create(SW, SE), 3);
+    final Loc loc2 = GraphRoadModel.newLoc(Connection.create(SW, SE), 1);
+    final Loc loc3 = GraphRoadModel.newLoc(Connection.create(SE, NE), 9.999999);
     final Loc loc4 = GraphRoadModel.newLoc(SW);
-    final Loc loc5 = GraphRoadModel.newLoc(new Connection<ConnectionData>(SE,
-        SW, null), 1);
-    final Loc loc6 = GraphRoadModel.newLoc(new Connection<ConnectionData>(NE,
-        SW, null), 1);
+    final Loc loc5 = GraphRoadModel.newLoc(Connection.create(SE, SW), 1);
+    final Loc loc6 = GraphRoadModel.newLoc(Connection.create(NE, SW), 1);
 
     assertEquals(NE, loc3);
     assertTrue(loc1.isOnSameConnection(loc2));
@@ -691,23 +684,11 @@ public void checkLocationFail1() {
 
   @Test(expected = IllegalArgumentException.class)
   public void checkLocationFail2() {
-    final Loc l = GraphRoadModel.newLoc(new Connection<ConnectionData>(
-        new Point(-10, -10), new Point(100, 0), null), 1);
+    final Loc l = GraphRoadModel.newLoc(Connection.create(
+        new Point(-10, -10), new Point(100, 0)), 1);
     model.checkLocation(l);
   }
 
-  @Test
-  public void getConnectionLength() {
-    assertEquals(10,
-        GraphRoadModel.getConnectionLength(new Connection<ConnectionData>(NE,
-            NW, null)), EPSILON);
-    final Connection<MultiAttributeData> conn = new Connection<MultiAttributeData>(
-        NE, NW, new MultiAttributeData(12, 0d));
-    assertEquals(12, GraphRoadModel.getConnectionLength(conn), EPSILON);
-    conn.getData().put(MultiAttributeData.KEY_LENGTH, "this is not a number");
-    assertEquals(10, GraphRoadModel.getConnectionLength(conn), EPSILON);
-  }
-
   @Test(expected = IllegalArgumentException.class)
   public void getMaxSpeedFail4() {
     model.getMaxSpeed(new TestRoadUser(), new Point(1, 2), new Point(2, 1));
@@ -722,7 +703,7 @@ public void getMaxSpeed() {
     final Graph<LengthData> g = new MultimapGraph<LengthData>();
     final GraphRoadModel rm = new GraphRoadModel(g, SI.KILOMETER,
         NonSI.KILOMETERS_PER_HOUR);
-    g.addConnection(A, B, new LengthData(3));
+    g.addConnection(A, B, LengthData.create(3));
 
     final UnitConverter conv = NonSI.KILOMETERS_PER_HOUR
         .getConverterTo(AbstractRoadModel.INTERNAL_SPEED_UNIT);
@@ -731,12 +712,12 @@ public void getMaxSpeed() {
         rm.getMaxSpeed(new SpeedyRoadUser(10), A, B), EPSILON);
 
     ((Graph<MultiAttributeData>) graph).addConnection(SE, SW,
-        new MultiAttributeData(3, 5d));
+        MultiAttributeData.builder().setLength(3).setMaxSpeed(5d).build());
     assertEquals(conv.convert(5),
         model.getMaxSpeed(new SpeedyRoadUser(10), SE, SW), EPSILON);
 
     ((Graph<MultiAttributeData>) graph).addConnection(NE, SE,
-        new MultiAttributeData(3, Double.NaN));
+        MultiAttributeData.builder().setLength(3).build());
     assertEquals(conv.convert(10),
         model.getMaxSpeed(new SpeedyRoadUser(10), NE, SE), EPSILON);
   }
@@ -759,7 +740,7 @@ public void computeConnectionLength() {
         model.computeConnectionLength(new Point(1, 2), new Point(1, 2)),
         EPSILON);
     ((Graph<MultiAttributeData>) graph).addConnection(SE, SW,
-        new MultiAttributeData(5, 5d));
+        MultiAttributeData.builder().setLength(5).setMaxSpeed(5d).build());
 
     final TestRoadUser agent1 = new TestRoadUser();
     model.addObjectAt(agent1, SE);
@@ -852,8 +833,8 @@ public void addTruckTest() {
   // LinkedList<Point>(rs.getShortestPathTo(agent2, agent1)), 5);
   // }
 
-  static boolean connectionEquals(Connection<? extends ConnectionData> conn,
+  static boolean connectionEquals(Connection<?> conn,
       Point from, Point to) {
-    return conn.from.equals(from) && conn.to.equals(to);
+    return conn.from().equals(from) && conn.to().equals(to);
   }
 }
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/PathFinderTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/PathFinderTest.java
index 05643c625b..676fa15c00 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/PathFinderTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/PathFinderTest.java
@@ -36,18 +36,12 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.github.rinde.rinsim.core.TimeLapseFactory;
-import com.github.rinde.rinsim.core.model.road.GraphRoadModel;
-import com.github.rinde.rinsim.core.model.road.MoveProgress;
-import com.github.rinde.rinsim.core.model.road.MovingRoadUser;
-import com.github.rinde.rinsim.core.model.road.RoadModel;
-import com.github.rinde.rinsim.core.model.road.RoadModels;
-import com.github.rinde.rinsim.core.model.road.RoadUser;
 import com.github.rinde.rinsim.geom.Graph;
 import com.github.rinde.rinsim.geom.Graphs;
 import com.github.rinde.rinsim.geom.LengthData;
+import com.github.rinde.rinsim.geom.MultimapGraph;
 import com.github.rinde.rinsim.geom.Point;
-import com.github.rinde.rinsim.geom.TestMultimapGraph;
-import com.github.rinde.rinsim.geom.TestTableGraph;
+import com.github.rinde.rinsim.geom.TableGraph;
 import com.github.rinde.rinsim.util.TrivialRoadUser;
 import com.google.common.base.Predicate;
 import com.google.common.math.DoubleMath;
@@ -55,15 +49,15 @@
 /**
  * TODO this class should only be testing Graph classes. RoadModel related stuff
  * should be splitted
- * @author Rinde van Lon 
+ * @author Rinde van Lon
  */
 @RunWith(Parameterized.class)
 public class PathFinderTest {
 
   @Parameters
   public static Collection<Object[]> configs() {
-    return Arrays.asList(new Object[][] { { TestMultimapGraph.class },
-        { TestTableGraph.class } });
+    return Arrays.asList(new Object[][] { { MultimapGraph.class },
+        { TableGraph.class } });
   }
 
   public PathFinderTest(Class<? extends Graph<LengthData>> clazz) {
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/PointsEqualityTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/PointsEqualityTest.java
index 8f229ce0fb..78d537f07e 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/PointsEqualityTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/PointsEqualityTest.java
@@ -28,12 +28,11 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import com.github.rinde.rinsim.geom.Connection;
-import com.github.rinde.rinsim.geom.ConnectionData;
 import com.github.rinde.rinsim.geom.Graph;
 import com.github.rinde.rinsim.geom.LengthData;
+import com.github.rinde.rinsim.geom.MultimapGraph;
 import com.github.rinde.rinsim.geom.Point;
-import com.github.rinde.rinsim.geom.TestMultimapGraph;
-import com.github.rinde.rinsim.geom.TestTableGraph;
+import com.github.rinde.rinsim.geom.TableGraph;
 
 /**
  * Test whether points are value objects
@@ -46,8 +45,8 @@
 
   @Parameters
   public static Collection<Object[]> configs() {
-    return Arrays.asList(new Object[][] { { new TestMultimapGraph() },
-        { new TestTableGraph() } });
+    return Arrays.asList(new Object[][] { { new MultimapGraph() },
+        { new TableGraph() } });
   }
 
   private final Graph<LengthData> graph;
@@ -71,8 +70,9 @@ public void pointsEqual() {
   @Test
   public void midPointsEqual() {
     final GraphRoadModel.Loc p1 = GraphRoadModel.newLoc(new Point(0.2, 10000));
-    final Connection<?> conn = new Connection<ConnectionData>(new Point(0.2,
-        10000), new Point(0.2, 10000), null);
+    final Connection<?> conn = Connection.create(
+        new Point(0.2, 10000),
+        new Point(0.2, 10000));
     final GraphRoadModel.Loc p2 = GraphRoadModel.newLoc(conn, 10);
 
     assertEquals(p1, p1);
diff --git a/core/src/test/java/com/github/rinde/rinsim/core/model/road/SpeedLimitsTest.java b/core/src/test/java/com/github/rinde/rinsim/core/model/road/SpeedLimitsTest.java
index 0efd58f583..25cc7da70a 100755
--- a/core/src/test/java/com/github/rinde/rinsim/core/model/road/SpeedLimitsTest.java
+++ b/core/src/test/java/com/github/rinde/rinsim/core/model/road/SpeedLimitsTest.java
@@ -41,23 +41,17 @@
 
 import com.github.rinde.rinsim.core.TimeLapse;
 import com.github.rinde.rinsim.core.TimeLapseFactory;
-import com.github.rinde.rinsim.core.model.road.AbstractRoadModel;
-import com.github.rinde.rinsim.core.model.road.CachedGraphRoadModel;
-import com.github.rinde.rinsim.core.model.road.GraphRoadModel;
-import com.github.rinde.rinsim.core.model.road.MoveProgress;
-import com.github.rinde.rinsim.core.model.road.MovingRoadUser;
-import com.github.rinde.rinsim.core.model.road.RoadModel;
 import com.github.rinde.rinsim.geom.Graph;
 import com.github.rinde.rinsim.geom.MultiAttributeData;
+import com.github.rinde.rinsim.geom.MultimapGraph;
 import com.github.rinde.rinsim.geom.Point;
-import com.github.rinde.rinsim.geom.TestMultimapGraph;
-import com.github.rinde.rinsim.geom.TestTableGraph;
+import com.github.rinde.rinsim.geom.TableGraph;
 import com.google.common.math.DoubleMath;
 
 /**
  * Test for graph with speed limits
- * @author Bartosz Michalik 
- * 
+ * @author Bartosz Michalik
+ *
  */
 @RunWith(Parameterized.class)
 public class SpeedLimitsTest {
@@ -85,14 +79,14 @@ public SpeedLimitsTest(Class<? extends Graph<MultiAttributeData>> pGraphType,
     final double five = 5;
     final double twoAndHalf = 2.5;
     return Arrays.asList(new Object[][] {
-        { TestMultimapGraph.class, GraphRoadModel.class, five },
-        { TestMultimapGraph.class, CachedGraphRoadModel.class, five },
-        { TestMultimapGraph.class, GraphRoadModel.class, twoAndHalf },
-        { TestMultimapGraph.class, CachedGraphRoadModel.class, twoAndHalf },
-        { TestTableGraph.class, GraphRoadModel.class, five },
-        { TestTableGraph.class, CachedGraphRoadModel.class, five },
-        { TestTableGraph.class, GraphRoadModel.class, twoAndHalf },
-        { TestTableGraph.class, CachedGraphRoadModel.class, twoAndHalf } });
+        { MultimapGraph.class, GraphRoadModel.class, five },
+        { MultimapGraph.class, CachedGraphRoadModel.class, five },
+        { MultimapGraph.class, GraphRoadModel.class, twoAndHalf },
+        { MultimapGraph.class, CachedGraphRoadModel.class, twoAndHalf },
+        { TableGraph.class, GraphRoadModel.class, five },
+        { TableGraph.class, CachedGraphRoadModel.class, five },
+        { TableGraph.class, GraphRoadModel.class, twoAndHalf },
+        { TableGraph.class, CachedGraphRoadModel.class, twoAndHalf } });
   }
 
   @Before
@@ -115,17 +109,29 @@ public void setUp() throws InstantiationException, IllegalAccessException,
     graph.addConnection(A, B);
 
     // length 10 speed 2.5
-    graph.addConnection(B, C, new MultiAttributeData(10d, 2.5));
+    graph.addConnection(B, C, MultiAttributeData.builder()
+        .setLength(10)
+        .setMaxSpeed(2.5)
+        .build());
     graph.addConnection(C, B); // length Math.sqr(10^2 + 10^2)
 
     // length 10 speed 10
-    graph.addConnection(B, D, new MultiAttributeData(10d, 10));
+    graph.addConnection(B, D, MultiAttributeData.builder()
+        .setLength(10d)
+        .setMaxSpeed(10)
+        .build());
 
     graph.addConnection(C, D); // length 10
 
     // length 12 speed 1
-    graph.addConnection(D, C, new MultiAttributeData(12, 1));
-    graph.addConnection(D, E, new MultiAttributeData(5, 7));
+    graph.addConnection(D, C, MultiAttributeData.builder()
+        .setLength(12)
+        .setMaxSpeed(1)
+        .build());
+    graph.addConnection(D, E, MultiAttributeData.builder()
+        .setLength(5)
+        .setMaxSpeed(7)
+        .build());
 
     final Set<Point> points = graph.getNodes();
     assertEquals(5, points.size());
@@ -146,7 +152,7 @@ public void setUp() throws InstantiationException, IllegalAccessException,
 
   @Test
   public void followPathAllAtOnce() {
-    final int timeNeeded = DoubleMath.roundToInt((pathLength / speed) * 1.5,
+    final int timeNeeded = DoubleMath.roundToInt(pathLength / speed * 1.5,
         RoundingMode.CEILING);
     final TimeLapse timeLapse = TimeLapseFactory.create(NonSI.HOUR, 0,
         timeNeeded);
diff --git a/example/pom.xml b/example/pom.xml
index 44a9337163..59d7f41f70 100755
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -62,6 +62,10 @@
 			<groupId>com.github.rinde</groupId>
 			<artifactId>rinsim-pdptw</artifactId>
 		</dependency>
+		<dependency>
+			<groupId>com.google.guava</groupId>
+			<artifactId>guava</artifactId>
+		</dependency>
 		<dependency>
 			<groupId>ch.qos.logback</groupId>
 			<artifactId>logback-classic</artifactId>
diff --git a/example/src/main/java/com/github/rinde/rinsim/examples/demo/factory/BlockingGraphRoadModel.java b/example/src/main/java/com/github/rinde/rinsim/examples/demo/factory/BlockingGraphRoadModel.java
index 72456b848b..0fb64f9e07 100755
--- a/example/src/main/java/com/github/rinde/rinsim/examples/demo/factory/BlockingGraphRoadModel.java
+++ b/example/src/main/java/com/github/rinde/rinsim/examples/demo/factory/BlockingGraphRoadModel.java
@@ -15,7 +15,6 @@
  */
 package com.github.rinde.rinsim.examples.demo.factory;
 
-import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.newArrayList;
 import static com.google.common.collect.Lists.newLinkedList;
 import static com.google.common.collect.Sets.newLinkedHashSet;
@@ -41,8 +40,8 @@
 import com.google.common.collect.Multimap;
 
 /**
- * @author Rinde van Lon 
- * 
+ * @author Rinde van Lon
+ *
  */
 public class BlockingGraphRoadModel extends GraphRoadModel {
 
@@ -85,10 +84,9 @@ protected MoveProgress doFollowPath(MovingRoadUser object, Queue<Point> path,
     }
     final Loc newLoc = objLocs.get(object);
     if (newLoc.isOnConnection()) {
-      final Connection<?> conn = newLoc.conn;
-      checkNotNull(conn);
-      blockedNodes.add(conn.to);
-      vehicleBlocks.put(object, conn.to);
+      final Connection<?> conn = newLoc.conn.get();
+      blockedNodes.add(conn.to());
+      vehicleBlocks.put(object, conn.to());
     } else {
       blockedNodes.add(getPosition(object));
       vehicleBlocks.put(object, getPosition(object));
diff --git a/geom/.classpath b/geom/.classpath
index f619a5369d..ad1af188b7 100755
--- a/geom/.classpath
+++ b/geom/.classpath
@@ -22,5 +22,11 @@
 			<attribute name="maven.pomderived" value="true"/>
 		</attributes>
 	</classpathentry>
+	<classpathentry kind="src" path="target/generated-sources/annotations">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry kind="output" path="target/classes"/>
 </classpath>
diff --git a/geom/.factorypath b/geom/.factorypath
new file mode 100755
index 0000000000..6ba77e0b6f
--- /dev/null
+++ b/geom/.factorypath
@@ -0,0 +1,14 @@
+<factorypath>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/guava/guava/18.0/guava-18.0.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/code/findbugs/jsr305/3.0.0/jsr305-3.0.0.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/org/apache/commons/commons-math3/3.3/commons-math3-3.3.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/auto/value/auto-value/1.0/auto-value-1.0.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/org/inferred/freebuilder/1.0-rc3/freebuilder-1.0-rc3.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/auto/service/auto-service/1.0-rc2/auto-service-1.0-rc2.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/auto/auto-common/0.3/auto-common-0.3.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/com/google/gwt/gwt-user/2.6.1/gwt-user-2.6.1.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/javax/validation/validation-api/1.0.0.GA/validation-api-1.0.0.GA.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/javax/validation/validation-api/1.0.0.GA/validation-api-1.0.0.GA-sources.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/org/json/json/20090211/json-20090211.jar" enabled="true" runInBatchMode="false"/>
+    <factorypathentry kind="VARJAR" id="M2_REPO/org/jvnet/sorcerer/sorcerer-javac/0.8/sorcerer-javac-0.8.jar" enabled="true" runInBatchMode="false"/>
+</factorypath>
diff --git a/geom/.gitignore b/geom/.gitignore
new file mode 100755
index 0000000000..c71ea97aba
--- /dev/null
+++ b/geom/.gitignore
@@ -0,0 +1 @@
+/.apt_generated/
diff --git a/geom/.settings/org.eclipse.jdt.apt.core.prefs b/geom/.settings/org.eclipse.jdt.apt.core.prefs
index d4313d4b25..bb1138ce3e 100755
--- a/geom/.settings/org.eclipse.jdt.apt.core.prefs
+++ b/geom/.settings/org.eclipse.jdt.apt.core.prefs
@@ -1,2 +1,4 @@
 eclipse.preferences.version=1
-org.eclipse.jdt.apt.aptEnabled=false
+org.eclipse.jdt.apt.aptEnabled=true
+org.eclipse.jdt.apt.genSrcDir=target/generated-sources/annotations
+org.eclipse.jdt.apt.reconcileEnabled=true
diff --git a/geom/.settings/org.eclipse.jdt.core.prefs b/geom/.settings/org.eclipse.jdt.core.prefs
index e2548c02d5..cc472c7a78 100755
--- a/geom/.settings/org.eclipse.jdt.core.prefs
+++ b/geom/.settings/org.eclipse.jdt.core.prefs
@@ -111,7 +111,7 @@ org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
 org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
 org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
 org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
-org.eclipse.jdt.core.compiler.processAnnotations=disabled
+org.eclipse.jdt.core.compiler.processAnnotations=enabled
 org.eclipse.jdt.core.compiler.source=1.7
 org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
 org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=16
diff --git a/geom/.settings/org.eclipse.jdt.ui.prefs b/geom/.settings/org.eclipse.jdt.ui.prefs
index 0a53119f3f..ed5adca1ed 100755
--- a/geom/.settings/org.eclipse.jdt.ui.prefs
+++ b/geom/.settings/org.eclipse.jdt.ui.prefs
@@ -68,10 +68,12 @@ sp_cleanup.always_use_blocks=true
 sp_cleanup.always_use_parentheses_in_expressions=false
 sp_cleanup.always_use_this_for_non_static_field_access=false
 sp_cleanup.always_use_this_for_non_static_method_access=false
+sp_cleanup.convert_functional_interfaces=false
 sp_cleanup.convert_to_enhanced_for_loop=false
 sp_cleanup.correct_indentation=false
 sp_cleanup.format_source_code=true
 sp_cleanup.format_source_code_changes_only=false
+sp_cleanup.insert_inferred_type_arguments=false
 sp_cleanup.make_local_variable_final=false
 sp_cleanup.make_parameters_final=false
 sp_cleanup.make_private_fields_final=true
@@ -87,6 +89,7 @@ sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=
 sp_cleanup.qualify_static_member_accesses_with_declaring_class=false
 sp_cleanup.qualify_static_method_accesses_with_declaring_class=false
 sp_cleanup.remove_private_constructors=true
+sp_cleanup.remove_redundant_type_arguments=false
 sp_cleanup.remove_trailing_whitespaces=false
 sp_cleanup.remove_trailing_whitespaces_all=true
 sp_cleanup.remove_trailing_whitespaces_ignore_empty=false
@@ -100,10 +103,13 @@ sp_cleanup.remove_unused_private_methods=true
 sp_cleanup.remove_unused_private_types=true
 sp_cleanup.sort_members=false
 sp_cleanup.sort_members_all=false
+sp_cleanup.use_anonymous_class_creation=false
 sp_cleanup.use_blocks=false
 sp_cleanup.use_blocks_only_for_return_and_throw=false
+sp_cleanup.use_lambda=false
 sp_cleanup.use_parentheses_in_expressions=false
 sp_cleanup.use_this_for_non_static_field_access=false
 sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=true
 sp_cleanup.use_this_for_non_static_method_access=false
 sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+sp_cleanup.use_type_arguments=false
diff --git a/geom/pom.xml b/geom/pom.xml
index 7eb058ac8f..07becebb30 100755
--- a/geom/pom.xml
+++ b/geom/pom.xml
@@ -1,4 +1,5 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
 	<modelVersion>4.0.0</modelVersion>
 	<parent>
 		<groupId>com.github.rinde</groupId>
@@ -23,13 +24,11 @@
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 		<sonar.language>java</sonar.language>
 	</properties>
-	
+
 	<build>
 		<plugins>
-			<!-- <plugin>
-				<groupId>com.googlecode.japi-checker</groupId>
-				<artifactId>japi-checker-maven-plugin</artifactId>
-			</plugin>-->
+			<!-- <plugin> <groupId>com.googlecode.japi-checker</groupId> <artifactId>japi-checker-maven-plugin</artifactId> 
+				</plugin> -->
 		</plugins>
 	</build>
 
@@ -60,5 +59,15 @@
 			<artifactId>rinsim-test-util</artifactId>
 			<type>test-jar</type>
 		</dependency>
+		<dependency>
+			<groupId>com.google.auto.value</groupId>
+			<artifactId>auto-value</artifactId>
+			<scope>provided</scope>
+		</dependency>
+		<dependency>
+			<groupId>org.inferred</groupId>
+			<artifactId>freebuilder</artifactId>
+			<optional>true</optional>
+		</dependency>
 	</dependencies>
 </project>
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/AbstractGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/AbstractGraph.java
index ea5acd5057..a0af9bd23c 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/AbstractGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/AbstractGraph.java
@@ -24,6 +24,8 @@
 
 import org.apache.commons.math3.random.RandomGenerator;
 
+import com.google.common.base.Optional;
+
 /**
  * Abstract graph implementation providing basic implementations of several
  * graph functions.
@@ -41,38 +43,24 @@ public AbstractGraph() {
     super();
   }
 
-  @SuppressWarnings("null")
   @Override
   public double connectionLength(Point from, Point to) {
     checkArgument(hasConnection(from, to),
         "Can not get connection length from a non-existing connection.");
-    @Nullable
-    final E connData = connectionData(from, to);
-    return !isEmptyConnectionData(connData) ? connData.getLength() : Point
-        .distance(from, to);
-  }
-
-  /**
-   * Determines whether a connection data is 'empty'. Default only
-   * <code>null</code> is considered as an empty connection data. This can be
-   * overridden to include a specific instance of connection data to be the
-   * 'empty' instance.
-   * @param connData The connection data to check.
-   * @return <code>true</code> if the specified connection data is considered
-   *         empty, <code>false</code> otherwise.
-   */
-  protected boolean isEmptyConnectionData(@Nullable E connData) {
-    return connData == null;
+    final Optional<E> connData = connectionData(from, to);
+    return connData.isPresent() && connData.get().getLength().isPresent()
+        ? connData.get().getLength().get()
+        : Point.distance(from, to);
   }
 
   @Override
   public void addConnection(Point from, Point to) {
-    addConnection(from, to, null);
+    addConnection(from, to, Optional.<E> absent());
   }
 
   @Override
   public void addConnection(Connection<E> c) {
-    addConnection(c.from, c.to, c.getData());
+    addConnection(c.from(), c.to(), c.data());
   }
 
   @Override
@@ -88,7 +76,17 @@ public void merge(Graph<E> other) {
   }
 
   @Override
-  public void addConnection(Point from, Point to, @Nullable E connData) {
+  public void addConnection(Point from, Point to, E connData) {
+    addConnection(from, to, Optional.of(connData));
+  }
+
+  /**
+   * Adds a connection.
+   * @param from Start of the connection.
+   * @param to End of the connection.
+   * @param connData The connection data wrapped in an optional.
+   */
+  protected void addConnection(Point from, Point to, Optional<E> connData) {
     checkArgument(!from.equals(to),
         "A connection cannot be circular: %s -> %s ", from, to);
     checkArgument(!hasConnection(from, to),
@@ -105,7 +103,7 @@ public void addConnection(Point from, Point to, @Nullable E connData) {
    * @param connData The data to be associated to the connection.
    */
   protected abstract void doAddConnection(Point from, Point to,
-      @Nullable E connData);
+      Optional<E> connData);
 
   @Override
   public boolean equals(@Nullable Object other) {
@@ -133,7 +131,45 @@ public Point getRandomNode(RandomGenerator generator) {
   public Connection<E> getConnection(Point from, Point to) {
     checkArgument(hasConnection(from, to), "%s -> %s is not a connection.",
         from, to);
-    return new Connection<>(from, to, connectionData(from, to));
+    return Connection.create(from, to, connectionData(from, to));
+  }
+
+  @Override
+  public Optional<E> setConnectionData(Point from, Point to, E connData) {
+    return changeConnectionData(from, to, Optional.of(connData));
   }
 
+  @Override
+  public Optional<E> removeConnectionData(Point from, Point to) {
+    return changeConnectionData(from, to, Optional.<E> absent());
+  }
+
+  /**
+   * Change connection data. Precondition: connection from -&gt; to exists.
+   * @param from Start point of connection.
+   * @param to End point of connection.
+   * @param connData The edge data used for the connection.
+   * @return old edge data or {@link Optional#absent()} if there was no edge
+   *         data.
+   * @throws IllegalArgumentException if the connection between the nodes does
+   *           not exist.
+   */
+  protected Optional<E> changeConnectionData(Point from, Point to,
+      Optional<E> connData) {
+    checkArgument(hasConnection(from, to),
+        "The connection %s->%s does not exist.", from, to);
+    return doChangeConnectionData(from, to, connData);
+  }
+
+  /**
+   * Change connection data. It can be assumed that the connection exists.
+   * @param from Start point of connection.
+   * @param to End point of connection.
+   * @param connData The edge data used for the connection.
+   * @return old edge data or {@link Optional#absent()} if there was no edge
+   *         data.
+   */
+  protected abstract Optional<E> doChangeConnectionData(Point from, Point to,
+      Optional<E> connData);
+
 }
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/Connection.java b/geom/src/main/java/com/github/rinde/rinsim/geom/Connection.java
index 79e507a850..01aecb075c 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/Connection.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/Connection.java
@@ -15,96 +15,85 @@
  */
 package com.github.rinde.rinsim.geom;
 
-import javax.annotation.Nullable;
-
-import com.google.common.base.MoreObjects;
-import com.google.common.base.Objects;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
 
 /**
- * Class representing a directed connection (link/edge) in a graph.
+ * Immutable value object representing a directed connection (link/edge) in a
+ * graph.
  * @param <E> Type of {@link ConnectionData} that is used. This data object can
  *          be used to add additional information to the connection.
  * @since 2.0
  * @author Bartosz Michalik
  * @author Rinde van Lon
  */
-public class Connection<E extends ConnectionData> {
+@AutoValue
+public abstract class Connection<E extends ConnectionData> {
+
+  Connection() {}
+
   /**
-   * The starting point of the connection.
+   * @return The starting point of the connection.
    */
-  public final Point from;
+  public abstract Point from();
 
   /**
-   * The end point of the connection.
+   * @return The end point of the connection.
    */
-  public final Point to;
-
-  @Nullable
-  private E data;
-  private final int hashCode;
+  public abstract Point to();
 
   /**
-   * Instantiates a new connection.
-   * @param pFrom The starting point of the connection.
-   * @param pTo The end point of the connection.
-   * @param pData The data that is associated to this connection.
+   * @return The data associated to this connection wrapped in an
+   *         {@link Optional}.
    */
-  public Connection(Point pFrom, Point pTo, @Nullable E pData) {
-    this.from = pFrom;
-    this.to = pTo;
-    this.data = pData;
+  public abstract Optional<E> data();
 
-    if (pData != null) {
-      hashCode = Objects.hashCode(from, to, data);
-    } else {
-      hashCode = Objects.hashCode(from, to);
+  /**
+   * @return The length of this connection as specified by the data or
+   *         alternatively by the euclidean distance between the two points.
+   */
+  public double getLength() {
+    if (data().isPresent() && data().get().getLength().isPresent()) {
+      return data().get().getLength().get();
     }
+    return Point.distance(from(), to());
   }
 
   /**
-   * Sets the data associated to this connection to the specified value.
-   * @param pData The new data to be associated to this connection.
+   * Create a new connection without any connection data associated to it.
+   * @param from The starting point of the connection.
+   * @param to The end point of the connection.
+   * @param <E> The type of {@link ConnectionData}.
+   * @return A new {@link Connection} instance.
    */
-  public void setData(@Nullable E pData) {
-    this.data = pData;
+  public static <E extends ConnectionData> Connection<E> create(Point from,
+      Point to) {
+    return create(from, to, Optional.<E> absent());
   }
 
   /**
-   * @return The data that is associated to this connection.
+   * Create a new connection.
+   * @param from The starting point of the connection.
+   * @param to The end point of the connection.
+   * @param data The data associated to the connection.
+   * @param <E> The type of {@link ConnectionData}.
+   * @return A new {@link Connection} instance.
    */
-  @Nullable
-  public E getData() {
-    return data;
-  }
-
-  @Override
-  public int hashCode() {
-    return hashCode;
+  public static <E extends ConnectionData> Connection<E> create(Point from,
+      Point to, E data) {
+    return create(from, to, Optional.of(data));
   }
 
-  @Override
-  public boolean equals(@Nullable Object obj) {
-    if (!(obj instanceof Connection)) {
-      return false;
-    }
-    @SuppressWarnings("rawtypes")
-    final Connection other = (Connection) obj;
-    if (!from.equals(other.from)) {
-      return false;
-    }
-    if (!to.equals(other.to)) {
-      return false;
-    }
-    final E d = data;
-    if (d == null) {
-      return other.data == null;
-    }
-    return d.equals(other.getData());
-  }
-
-  @Override
-  public String toString() {
-    return MoreObjects.toStringHelper(this).add("from", from).add("to", to)
-        .add("data", data).omitNullValues().toString();
+  /**
+   * Create a new connection.
+   * @param from The starting point of the connection.
+   * @param to The end point of the connection.
+   * @param data The data associated to the connection.
+   * @param <E> The type of {@link ConnectionData}.
+   * @return A new {@link Connection} instance.
+   */
+  public static <E extends ConnectionData> Connection<E> create(Point from,
+      Point to, Optional<E> data) {
+    return new AutoValue_Connection<>(from, to, data);
   }
 }
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/ConnectionData.java b/geom/src/main/java/com/github/rinde/rinsim/geom/ConnectionData.java
index a11fc0e69e..a581e916b5 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/ConnectionData.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/ConnectionData.java
@@ -15,19 +15,22 @@
  */
 package com.github.rinde.rinsim.geom;
 
+import com.google.common.base.Optional;
+
 /**
  * Simple interface to represent data associated to a {@link Connection} in a
- * {@link Graph}.
- * @author Bartosz Michalik 
- * @author Rinde van Lon 
+ * {@link Graph}. All implementations <b>must</b> be immutable.
+ * @author Bartosz Michalik
+ * @author Rinde van Lon
  * @since 2.0
  */
 public interface ConnectionData {
 
   /**
    * This method can be implemented to override the default length (euclidean
-   * distance).
+   * distance). If {@link Optional#absent()} is returned the default length of
+   * the connection will be used as specified by the used {@link Graph}.
    * @return The length of the {@link Connection}.
    */
-  double getLength();
+  Optional<Double> getLength();
 }
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/ForwardingGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/ForwardingGraph.java
index b46fcffe60..e779ed1dde 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/ForwardingGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/ForwardingGraph.java
@@ -23,6 +23,8 @@
 
 import org.apache.commons.math3.random.RandomGenerator;
 
+import com.google.common.base.Optional;
+
 /**
  * {@link Graph} implementation that forwards all calls to another graph. This
  * is a helper class for creating graph decorators, subclasses only need to
@@ -72,9 +74,8 @@ public boolean hasConnection(Point from, Point to) {
     return delegate.getConnection(from, to);
   }
 
-  @Nullable
   @Override
-  public E connectionData(Point from, Point to) {
+  public Optional<E> connectionData(Point from, Point to) {
     return delegate.connectionData(from, to);
   }
 
@@ -104,7 +105,7 @@ public int getNumberOfNodes() {
   }
 
   @Override
-  public void addConnection(Point from, Point to, @Nullable E edgeData) {
+  public void addConnection(Point from, Point to, E edgeData) {
     delegate.addConnection(from, to, edgeData);
   }
 
@@ -118,12 +119,16 @@ public void addConnection(Connection<E> connection) {
     delegate.addConnection(connection);
   }
 
-  @Nullable
   @Override
-  public E setConnectionData(Point from, Point to, @Nullable E edgeData) {
+  public Optional<E> setConnectionData(Point from, Point to, E edgeData) {
     return delegate.setConnectionData(from, to, edgeData);
   }
 
+  @Override
+  public Optional<E> removeConnectionData(Point from, Point to) {
+    return delegate.removeConnectionData(from, to);
+  }
+
   @Override
   public void addConnections(Iterable<? extends Connection<E>> connections) {
     delegate.addConnections(connections);
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/Graph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/Graph.java
index c1a31c0292..e34851a1de 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/Graph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/Graph.java
@@ -19,21 +19,19 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.annotation.Nullable;
-
 import org.apache.commons.math3.random.RandomGenerator;
 
+import com.google.common.base.Optional;
+
 /**
  * Common interface for graphs (V,E). Vertices are called <code>nodes</code>
- * which are represented as {@link Point}s and edges are represented by
+ * which are represented as {@link Point}s and connections are represented by
  * {@link Connection}s. Graphs are directed.
  * 
- * TODO should be split up in an ImmutableGraph and Graph. Graphs should be
- * created using the builder pattern?
- * 
  * @author Rinde van Lon
- * @author Bartosz Michalik - added edge data handling
- * @param <E> The type of {@link ConnectionData} that is used in the edges.
+ * @author Bartosz Michalik - added connection data handling
+ * @param <E> The type of {@link ConnectionData} that is used in the
+ *          connections.
  * @since 1.0
  */
 public interface Graph<E extends ConnectionData> {
@@ -81,11 +79,10 @@
    * Get the data associated with connection.
    * @param from Start of connection
    * @param to End of connection
-   * @return connection data or <code>null</code> if there is no data or
+   * @return connection data or {@link Optional#absent()} if there is no data or
    *         connection does not exists.
    */
-  @Nullable
-  E connectionData(Point from, Point to);
+  Optional<E> connectionData(Point from, Point to);
 
   /**
    * Computes the length of the connection between <code>from</code> and
@@ -121,10 +118,10 @@
    * Add connection to the graph.
    * @param from starting node
    * @param to end node
-   * @param edgeData data associated with the edge
+   * @param connectionData data associated with the connection
    * @throws IllegalArgumentException if the connection already exists.
    */
-  void addConnection(Point from, Point to, @Nullable E edgeData);
+  void addConnection(Point from, Point to, E connectionData);
 
   /**
    * Add a connection to the graph.
@@ -143,15 +140,26 @@
 
   /**
    * Set connection data. Precondition: connection from -&gt; to exists.
-   * @param from Start point of connection
-   * @param to End point of connection
-   * @param edgeData The edge data used for the connection
-   * @return old edge data or <code>null</code> if there was no edge
+   * @param from Start point of connection.
+   * @param to End point of connection.
+   * @param connectionData The connection data used for the connection.
+   * @return old connection data or {@link Optional#absent()} if there was no
+   *         connection data.
+   * @throws IllegalArgumentException when the connection between nodes do not
+   *           exist.
+   */
+  Optional<E> setConnectionData(Point from, Point to, E connectionData);
+
+  /**
+   * Remove connection data. Precondition: connection from -&gt; to exists.
+   * @param from Start point of connection.
+   * @param to End point of connection.
+   * @return old connection data or {@link Optional#absent()} if there was no
+   *         connection data.
    * @throws IllegalArgumentException when the connection between nodes do not
-   *           exists
+   *           exist.
    */
-  @Nullable
-  E setConnectionData(Point from, Point to, @Nullable E edgeData);
+  Optional<E> removeConnectionData(Point from, Point to);
 
   /**
    * Adds connections to the graph.
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/Graphs.java b/geom/src/main/java/com/github/rinde/rinsim/geom/Graphs.java
index 6fd69eb3e8..2fceec4a98 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/Graphs.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/Graphs.java
@@ -35,6 +35,7 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
+import com.google.common.base.Optional;
 
 /**
  * Utility class containing many methods for working with graphs.
@@ -90,34 +91,6 @@ private Graphs() {}
     return new UnmodifiableGraph<>(graph);
   }
 
-  /**
-   * Returns an unmodifiable view on the specified {@link Connection}.
-   * @param conn A connection.
-   * @param <E> The type of connection data.
-   * @return An unmodifiable view on the connection.
-   */
-  public static <E extends ConnectionData> Connection<E> unmodifiableConnection(
-      Connection<E> conn) {
-    return new UnmodifiableConnection<>(conn);
-  }
-
-  /**
-   * Returns an unmodifiable view on the specified {@link ConnectionData}.
-   * @param connData Connection data.
-   * @param <E> The type of connection data.
-   * @return An unmodifiable view on the connection data.
-   */
-  @SuppressWarnings("unchecked")
-  @Nullable
-  public static <E extends ConnectionData> E unmodifiableConnectionData(
-      @Nullable E connData) {
-    if (connData instanceof MultiAttributeData) {
-      return (E) new UnmodifiableMultiAttributeEdgeData(
-          (MultiAttributeData) connData);
-    }
-    return connData;
-  }
-
   /**
    * Basic equals method.
    * @param g1 A graph.
@@ -130,23 +103,7 @@ public static boolean equal(Graph<?> g1, @Nullable Object other) {
       return false;
     }
     Graph<?> g2 = (Graph<?>) other;
-    if (g1.getNumberOfNodes() != g2.getNumberOfNodes()) {
-      return false;
-    }
-    if (g1.getNumberOfConnections() != g2.getNumberOfConnections()) {
-      return false;
-    }
-    for (final Connection<?> g1conn : g1.getConnections()) {
-      if (!g2.hasConnection(g1conn.from, g1conn.to)) {
-        return false;
-      }
-      final ConnectionData g2connEdgeData = g2.connectionData(g1conn.from,
-          g1conn.to);
-      if (!Objects.equal(g1conn.getData(), g2connEdgeData)) {
-        return false;
-      }
-    }
-    return true;
+    return Objects.equal(g1.getConnections(), g2.getConnections());
   }
 
   /**
@@ -401,99 +358,6 @@ public int hashCode() {
     }
   }
 
-  private static class UnmodifiableMultiAttributeEdgeData extends
-      MultiAttributeData {
-
-    private final MultiAttributeData original;
-
-    UnmodifiableMultiAttributeEdgeData(MultiAttributeData pOriginal) {
-      super(-1);
-      original = pOriginal;
-    }
-
-    @Override
-    public double getLength() {
-      return original.getLength();
-    }
-
-    @Override
-    public double getMaxSpeed() {
-      return original.getMaxSpeed();
-    }
-
-    @Override
-    public Map<String, Object> getAttributes() {
-      return original.getAttributes();
-    }
-
-    @Nullable
-    @Override
-    public <E> E get(String key, Class<E> type) {
-      return original.get(key, type);
-    }
-
-    @Override
-    public double setMaxSpeed(double maxSpeed) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public <E> void put(String key, E value) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      return original.equals(obj);
-    }
-
-    @Override
-    public int hashCode() {
-      return original.hashCode();
-    }
-
-  }
-
-  private static final class UnmodifiableConnection<E extends ConnectionData>
-      extends Connection<E> {
-    private final Connection<E> original;
-
-    UnmodifiableConnection(Connection<E> c) {
-      super(c.from, c.to, null);
-      original = c;
-    }
-
-    @Override
-    public void setData(@Nullable E data) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    @Nullable
-    public E getData() {
-      final E d = original.getData();
-      if (d == null) {
-        return null;
-      }
-      return Graphs.unmodifiableConnectionData(d);
-    }
-
-    @Override
-    public boolean equals(@Nullable Object obj) {
-      return original.equals(obj);
-    }
-
-    @Override
-    public int hashCode() {
-      return original.hashCode();
-    }
-
-    @Override
-    public String toString() {
-      return original.toString();
-    }
-  }
-
   private static class UnmodifiableGraph<E extends ConnectionData> extends
       ForwardingGraph<E> {
 
@@ -515,12 +379,7 @@ public String toString() {
 
     @Override
     public List<Connection<E>> getConnections() {
-      final List<Connection<E>> conn = delegate.getConnections();
-      final List<Connection<E>> unmodConn = new ArrayList<>();
-      for (final Connection<E> c : conn) {
-        unmodConn.add(unmodifiableConnection(c));
-      }
-      return Collections.unmodifiableList(unmodConn);
+      return Collections.unmodifiableList(delegate.getConnections());
     }
 
     @Override
@@ -553,12 +412,6 @@ public void removeConnection(Point from, Point to) {
       throw new UnsupportedOperationException();
     }
 
-    @Nullable
-    @Override
-    public E connectionData(Point from, Point to) {
-      return unmodifiableConnectionData(delegate.connectionData(from, to));
-    }
-
     @Override
     public void addConnection(Point from, Point to, @Nullable E edgeData) {
       throw new UnsupportedOperationException();
@@ -570,14 +423,13 @@ public void addConnection(Connection<E> connection) {
     }
 
     @Override
-    @Nullable
-    public E setConnectionData(Point from, Point to, @Nullable E edgeData) {
+    public Optional<E> setConnectionData(Point from, Point to, E edgeData) {
       throw new UnsupportedOperationException();
     }
 
     @Override
-    public Connection<E> getConnection(Point from, Point to) {
-      return unmodifiableConnection(delegate.getConnection(from, to));
+    public Optional<E> removeConnectionData(Point from, Point to) {
+      throw new UnsupportedOperationException();
     }
   }
 
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/LengthData.java b/geom/src/main/java/com/github/rinde/rinsim/geom/LengthData.java
index 4db93afad3..c7c163b676 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/LengthData.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/LengthData.java
@@ -15,52 +15,56 @@
  */
 package com.github.rinde.rinsim.geom;
 
-import javax.annotation.Nullable;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.primitives.Doubles;
 
 /**
- * Simple implementation of {@link ConnectionData}, allowing to specify the
- * length of a connection.
- * @author Bartosz Michalik 
- * @author Rinde van Lon 
+ * Simple immutable implementation of {@link ConnectionData}, allowing to
+ * specify the length of a connection.
+ * @author Bartosz Michalik
+ * @author Rinde van Lon
  */
-public class LengthData implements ConnectionData {
+@AutoValue
+public abstract class LengthData implements ConnectionData {
 
-  /**
-   * Represents an empty value for usage in a {@link TableGraph}.
-   */
-  public static final LengthData EMPTY = new LengthData(Double.NaN);
+  private static final LengthData EMPTY_LENGTH_DATA = create(Optional
+      .<Double> absent());
 
-  private final double length;
-
-  /**
-   * Instantiate a new instance using the specified length.
-   * @param pLength The length of the connection.
-   */
-  public LengthData(double pLength) {
-    length = pLength;
-  }
+  LengthData() {}
 
   @Override
-  public double getLength() {
-    return length;
-  }
+  public abstract Optional<Double> getLength();
 
-  @Override
-  public int hashCode() {
-    return Double.valueOf(length).hashCode();
+  /**
+   * @return A {@link LengthData} instance that does not specify a length.
+   */
+  public static LengthData empty() {
+    return EMPTY_LENGTH_DATA;
   }
 
-  @Override
-  public boolean equals(@Nullable Object obj) {
-    if (obj instanceof LengthData) {
-      return Double.compare(length, ((LengthData) obj).length) == 0;
+  /**
+   * Create a new {@link LengthData} instance using the specified length.
+   * @param length The length of the connection.
+   * @return A new instance.
+   */
+  public static LengthData create(Optional<Double> length) {
+    if (length.isPresent()) {
+      checkArgument(length.get() >= 0d && Doubles.isFinite(length.get()),
+          "Only positive values are allowed for length, it is: %s.",
+          length.get());
     }
-    return false;
+    return new AutoValue_LengthData(length);
   }
 
-  @Override
-  public String toString() {
-    return Double.toString(length);
+  /**
+   * Create a new {@link LengthData} instance using the specified length.
+   * @param length The length of the connection.
+   * @return A new instance.
+   */
+  public static LengthData create(double length) {
+    return create(Optional.of(length));
   }
-
 }
diff --git a/geom/src/test/java/com/github/rinde/rinsim/geom/TestTableGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/LinkedHashMapFactory.java
similarity index 68%
rename from geom/src/test/java/com/github/rinde/rinsim/geom/TestTableGraph.java
rename to geom/src/main/java/com/github/rinde/rinsim/geom/LinkedHashMapFactory.java
index aa3c47741a..1d0e302d3b 100755
--- a/geom/src/test/java/com/github/rinde/rinsim/geom/TestTableGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/LinkedHashMapFactory.java
@@ -1,27 +1,31 @@
-/*
- * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *         http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.rinde.rinsim.geom;
-
-import com.github.rinde.rinsim.geom.MultiAttributeData;
-import com.github.rinde.rinsim.geom.TableGraph;
-
-public class TestTableGraph extends TableGraph<MultiAttributeData> {
-
-	public TestTableGraph() {
-		super(MultiAttributeData.EMPTY);
-	}
-
-}
+/*
+ * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *         http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.github.rinde.rinsim.geom;
+
+import static com.google.common.collect.Maps.newLinkedHashMap;
+
+import java.util.Map;
+
+import com.google.common.base.Supplier;
+
+final class LinkedHashMapFactory<E> implements Supplier<Map<Point, E>> {
+  LinkedHashMapFactory() {}
+
+  @Override
+  public Map<Point, E> get() {
+    return newLinkedHashMap();
+  }
+}
\ No newline at end of file
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/ListenableGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/ListenableGraph.java
index 52bbfec257..c68fe68ad0 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/ListenableGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/ListenableGraph.java
@@ -17,7 +17,6 @@
 
 import static com.google.common.collect.Lists.newArrayList;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
@@ -28,6 +27,7 @@
 import com.github.rinde.rinsim.event.EventAPI;
 import com.github.rinde.rinsim.event.EventDispatcher;
 import com.google.common.base.MoreObjects;
+import com.google.common.base.Optional;
 
 /**
  * An observable decorator for {@link Graph} instances. This implementation
@@ -89,39 +89,30 @@ public EventAPI getEventAPI() {
     return eventDispatcher.getPublicEventAPI();
   }
 
-  @Override
-  public Connection<E> getConnection(Point from, Point to) {
-    return Graphs.unmodifiableConnection(delegate.getConnection(from, to));
-  }
-
   @Override
   public List<Connection<E>> getConnections() {
-    List<Connection<E>> unmod = new ArrayList<>();
-    for (Connection<E> c : delegate.getConnections()) {
-      unmod.add(Graphs.unmodifiableConnection(c));
-    }
-    return Collections.unmodifiableList(unmod);
+    return Collections.unmodifiableList(delegate.getConnections());
   }
 
   @Override
-  public void addConnection(Point from, Point to, @Nullable E edgeData) {
-    delegate.addConnection(from, to, edgeData);
+  public void addConnection(Point from, Point to, E connData) {
+    delegate.addConnection(from, to, connData);
     eventDispatcher.dispatchEvent(new GraphEvent(EventTypes.ADD_CONNECTION,
-        this, from, to, edgeData));
+        this, from, to, Optional.fromNullable(connData)));
   }
 
   @Override
   public void addConnection(Point from, Point to) {
     delegate.addConnection(from, to);
     eventDispatcher.dispatchEvent(new GraphEvent(EventTypes.ADD_CONNECTION,
-        this, from, to, null));
+        this, from, to, Optional.<ConnectionData> absent()));
   }
 
   @Override
   public void addConnection(Connection<E> connection) {
     delegate.addConnection(connection);
     eventDispatcher.dispatchEvent(new GraphEvent(EventTypes.ADD_CONNECTION,
-        this, connection.from, connection.to, connection.getData()));
+        this, connection.from(), connection.to(), connection.data()));
   }
 
   @Override
@@ -132,11 +123,20 @@ public void addConnections(Iterable<? extends Connection<E>> connections) {
   }
 
   @Override
-  @Nullable
-  public E setConnectionData(Point from, Point to, @Nullable E connectionData) {
-    E val = delegate.setConnectionData(from, to, connectionData);
+  public Optional<E> setConnectionData(Point from, Point to, E connectionData) {
+    Optional<E> val = delegate.setConnectionData(from, to, connectionData);
+    eventDispatcher.dispatchEvent(new GraphEvent(
+        EventTypes.CHANGE_CONNECTION_DATA, this, from, to, Optional
+            .of(connectionData)));
+    return val;
+  }
+
+  @Override
+  public Optional<E> removeConnectionData(Point from, Point to) {
+    Optional<E> val = delegate.removeConnectionData(from, to);
     eventDispatcher.dispatchEvent(new GraphEvent(
-        EventTypes.CHANGE_CONNECTION_DATA, this, from, to, connectionData));
+        EventTypes.CHANGE_CONNECTION_DATA, this, from, to, Optional
+            .<ConnectionData> absent()));
     return val;
   }
 
@@ -156,7 +156,7 @@ public void removeNode(Point node) {
     // notify listeners
     for (Connection<?> c : removedConnections) {
       eventDispatcher.dispatchEvent(new GraphEvent(
-          EventTypes.REMOVE_CONNECTION, this, c.from, c.to, c.getData()));
+          EventTypes.REMOVE_CONNECTION, this, c.from(), c.to(), c.data()));
     }
   }
 
@@ -166,8 +166,8 @@ public void removeConnection(Point from, Point to) {
     delegate.removeConnection(from, to);
     eventDispatcher
         .dispatchEvent(new GraphEvent(
-            EventTypes.REMOVE_CONNECTION, this, conn.from, conn.to, conn
-                .getData()));
+            EventTypes.REMOVE_CONNECTION, this, conn.from(), conn.to(), conn
+                .data()));
   }
 
   @Override
@@ -184,10 +184,10 @@ public void merge(Graph<E> other) {
   public static final class GraphEvent extends Event {
     private final Point from;
     private final Point to;
-    private final @Nullable Object connData;
+    private final Optional<? extends ConnectionData> connData;
 
     GraphEvent(Enum<?> type, ListenableGraph<?> issuer, Point from,
-        Point to, @Nullable Object connData) {
+        Point to, Optional<? extends ConnectionData> connData) {
       super(type, issuer);
       this.from = from;
       this.to = to;
@@ -211,7 +211,7 @@ public Point getTo() {
     /**
      * @return The data of the connection that is changed.
      */
-    public @Nullable Object getConnData() {
+    public Optional<? extends ConnectionData> getConnData() {
       return connData;
     }
 
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/MultiAttributeData.java b/geom/src/main/java/com/github/rinde/rinsim/geom/MultiAttributeData.java
index 8b1cd702fc..0c96bf6578 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/MultiAttributeData.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/MultiAttributeData.java
@@ -15,11 +15,15 @@
  */
 package com.github.rinde.rinsim.geom;
 
-import java.util.Collections;
+import static com.google.common.base.Preconditions.checkArgument;
+
 import java.util.HashMap;
-import java.util.Map;
 
-import javax.annotation.Nullable;
+import org.inferred.freebuilder.FreeBuilder;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.primitives.Doubles;
 
 /**
  * {@link ConnectionData} implementation which allows to associate multiple
@@ -30,144 +34,53 @@
  * @author Rinde van Lon
  * @since 2.0
  */
-public class MultiAttributeData implements ConnectionData {
-
-  /**
-   * Represents an empty value for usage in {@link TableGraph}.
-   */
-  public static final MultiAttributeData EMPTY = new MultiAttributeData(0);
-  static {
-    EMPTY.attributes.clear();
-  }
+@FreeBuilder
+public abstract class MultiAttributeData implements ConnectionData {
 
-  /**
-   * Key for length of a connection.
-   */
-  public static final String KEY_LENGTH = "data.length";
-
-  /**
-   * Key for maximum speed of a connection.
-   */
-  public static final String KEY_MAX_SPEED = "data.max.speed";
+  MultiAttributeData() {}
 
-  private final Map<String, Object> attributes;
-
-  /**
-   * New instance only using a single attribute: length.
-   * @param length The length to set.
-   */
-  public MultiAttributeData(double length) {
-    attributes = new HashMap<>();
-    attributes.put(KEY_LENGTH, length);
-  }
-
-  /**
-   * New instance using both length and maximum speed attributes.
-   * @param length The length of the connection.
-   * @param maxSpeed The maximum speed for the connection.
-   */
-  public MultiAttributeData(double length, double maxSpeed) {
-    attributes = new HashMap<>();
-    attributes.put(KEY_LENGTH, length);
-    attributes.put(KEY_MAX_SPEED, maxSpeed);
-  }
-
-  /**
-   * 
-   * @return Length of the connection. If the length is not specified the
-   *         {@link Double#NaN} value is returned
-   * @see com.github.rinde.rinsim.geom.ConnectionData#getLength()
-   */
   @Override
-  public double getLength() {
-    final Object l = attributes.get(KEY_LENGTH);
-    if (l instanceof Double) {
-      return (Double) l;
-    }
-    return Double.NaN;
-  }
+  public abstract Optional<Double> getLength();
 
   /**
    * Returns max speed defined for a connection. If the max speed is not
-   * specified the {@link Double#NaN} value is returned
+   * specified {@link Optional#absent()} is returned.
    * @return The max speed.
-   * @see com.github.rinde.rinsim.geom.ConnectionData#getLength()
    */
-  public double getMaxSpeed() {
-    final Object l = attributes.get(KEY_MAX_SPEED);
-    if (l instanceof Double) {
-      return (Double) l;
-    }
-    return Double.NaN;
-  }
+  public abstract Optional<Double> getMaxSpeed();
 
   /**
-   * Set max speed.
-   * @param maxSpeed The new speed.
-   * @return old max speed or {@link Double#NaN}.
+   * @return All attributes that are defined in this object.
    */
-  public double setMaxSpeed(double maxSpeed) {
-    final Object l = attributes.put(KEY_MAX_SPEED, maxSpeed);
-    if (l instanceof Double) {
-      return (Double) l;
-    }
-    return Double.NaN;
-  }
+  public abstract ImmutableMap<String, Object> getAttributes();
 
   /**
-   * Add an attribute. Note: this can override existing attributes.
-   * @param key A string used as key.
-   * @param value The value associated with <code>key</code>.
-   * @param <E> The type of value.
+   * @return A new {@link Builder} instance for creating
+   *         {@link MultiAttributeData} instances.
    */
-  public <E> void put(String key, E value) {
-    attributes.put(key, value);
+  public static Builder builder() {
+    return new Builder();
   }
 
   /**
-   * Retrieve an attribute.
-   * @param key The key to use.
-   * @param type The type of object that needs to be retrieved.
-   * @param <E> The type.
-   * @return An object associated to the key or <code>null</code> if it does not
-   *         exist.
+   * A builder for creating {@link MultiAttributeData} instances.
+   * @author Rinde van Lon
    */
-  @SuppressWarnings("unchecked")
-  @Nullable
-  public <E> E get(String key, Class<E> type) {
-    final Object r = attributes.get(key);
-    if (r != null && type.isAssignableFrom(r.getClass())) {
-      return (E) r;
+  public static class Builder extends MultiAttributeData_Builder {
+    Builder() {}
+
+    @Override
+    public Builder setLength(double length) {
+      checkArgument(length >= 0d && Doubles.isFinite(length),
+          "Expected positive value for length but found %s.", length);
+      return super.setLength(length);
     }
-    return null;
-  }
-
-  /**
-   * @return Unmodifiable view on the attributes.
-   */
-  public Map<String, Object> getAttributes() {
-    return Collections.unmodifiableMap(attributes);
-  }
-
-  @Override
-  public int hashCode() {
-    return attributes.hashCode();
-  }
 
-  @Override
-  public boolean equals(@Nullable Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj == null) {
-      return false;
-    }
-    if (!(obj instanceof MultiAttributeData)) {
-      return false;
+    @Override
+    public Builder setMaxSpeed(double speed) {
+      checkArgument(speed > 0d && Doubles.isFinite(speed),
+          "Expected positive value for maxSpeed but found %s.", speed);
+      return super.setMaxSpeed(speed);
     }
-
-    final MultiAttributeData other = (MultiAttributeData) obj;
-    return attributes.equals(other.getAttributes());
   }
-
 }
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/MultimapGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/MultimapGraph.java
index 5235f037f7..450e30f89a 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/MultimapGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/MultimapGraph.java
@@ -19,8 +19,8 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -30,9 +30,13 @@
 import javax.annotation.Nullable;
 
 import com.google.common.base.Objects;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Multimaps;
+import com.google.common.collect.Table;
+import com.google.common.collect.Tables;
 
 /**
  * Multimap-based implementation of a graph.
@@ -41,18 +45,15 @@
  * @param <E> The type of {@link ConnectionData} that is used in the edges.
  */
 public class MultimapGraph<E extends ConnectionData> extends AbstractGraph<E> {
-
-  private final Multimap<Point, Point> data;
-  private final Map<Connection<E>, E> edgeData;
+  private final Multimap<Point, Point> multimap;
+  private final Table<Point, Point, Connection<E>> lazyConnectionTable;
   private final Set<Point> deadEndNodes;
 
   /**
    * Create a new empty graph.
    */
   public MultimapGraph() {
-    data = LinkedHashMultimap.create();
-    this.edgeData = new HashMap<>();
-    deadEndNodes = new LinkedHashSet<>();
+    this(LinkedHashMultimap.<Point, Point> create());
   }
 
   /**
@@ -60,73 +61,77 @@ public MultimapGraph() {
    * @param map The multimap that is copied into this new graph.
    */
   public MultimapGraph(Multimap<Point, Point> map) {
-    this.data = LinkedHashMultimap.create(map);
-    this.edgeData = new HashMap<>();
-    this.deadEndNodes = new HashSet<>();
-    deadEndNodes.addAll(data.values());
-    deadEndNodes.removeAll(data.keySet());
+    multimap = LinkedHashMultimap.create(map);
+    lazyConnectionTable = Tables.newCustomTable(
+        new LinkedHashMap<Point, Map<Point, Connection<E>>>(),
+        new LinkedHashMapFactory<Connection<E>>());
+    deadEndNodes = new HashSet<>();
+    deadEndNodes.addAll(multimap.values());
+    deadEndNodes.removeAll(multimap.keySet());
   }
 
   @Override
   public boolean containsNode(Point node) {
-    return data.containsKey(node) || deadEndNodes.contains(node);
+    return multimap.containsKey(node) || deadEndNodes.contains(node);
   }
 
   @Override
   public Collection<Point> getOutgoingConnections(Point node) {
-    return data.get(node);
+    return multimap.get(node);
   }
 
   @Override
   public boolean hasConnection(Point from, Point to) {
-    return data.containsEntry(from, to);
+    return multimap.containsEntry(from, to);
   }
 
   @Override
   public int getNumberOfConnections() {
-    return data.size();
+    return multimap.size();
   }
 
   @Override
   public int getNumberOfNodes() {
-    return data.keySet().size() + deadEndNodes.size();
+    return multimap.keySet().size() + deadEndNodes.size();
   }
 
   @Override
-  @Nullable
-  public E setConnectionData(Point from, Point to, @Nullable E connData) {
-    if (!hasConnection(from, to)) {
-      throw new IllegalArgumentException("the connection " + from + " -> " + to
-          + "does not exist");
+  protected Optional<E> doChangeConnectionData(Point from, Point to,
+      Optional<E> connData) {
+    Optional<E> dat;
+    if (lazyConnectionTable.contains(from, to)) {
+      dat = lazyConnectionTable.get(from, to).data();
+    } else {
+      dat = Optional.absent();
     }
-    return this.edgeData.put(new Connection<E>(from, to, null), connData);
+    lazyConnectionTable.put(from, to, Connection.create(from, to, connData));
+    return dat;
   }
 
-  @Nullable
   @Override
-  public E connectionData(Point from, Point to) {
-    return edgeData.get(new Connection<E>(from, to, null));
+  public Optional<E> connectionData(Point from, Point to) {
+    if (lazyConnectionTable.contains(from, to)) {
+      return lazyConnectionTable.get(from, to).data();
+    }
+    return Optional.absent();
   }
 
   @Override
   public Set<Point> getNodes() {
-    final Set<Point> nodes = new LinkedHashSet<>(data.keySet());
+    final Set<Point> nodes = new LinkedHashSet<>(multimap.keySet());
     nodes.addAll(deadEndNodes);
     return nodes;
   }
 
   @Override
   public List<Connection<E>> getConnections() {
-    final List<Connection<E>> res = new ArrayList<>(
-        edgeData.size());
-    for (final Entry<Point, Point> p : data.entries()) {
-      final Connection<E> connection = new Connection<>(p.getKey(),
-          p.getValue(), null);
-      final E eD = edgeData.get(connection);
-      connection.setData(eD);
-      res.add(connection);
+    for (final Entry<Point, Point> p : multimap.entries()) {
+      if (!lazyConnectionTable.contains(p.getKey(), p.getValue())) {
+        lazyConnectionTable.put(p.getKey(), p.getValue(),
+            Connection.<E> create(p.getKey(), p.getValue()));
+      }
     }
-    return res;
+    return ImmutableList.copyOf(lazyConnectionTable.values());
   }
 
   /**
@@ -134,12 +139,12 @@ public E connectionData(Point from, Point to) {
    * @return The view on the multimap.
    */
   public Multimap<Point, Point> getMultimap() {
-    return Multimaps.unmodifiableMultimap(data);
+    return Multimaps.unmodifiableMultimap(multimap);
   }
 
   @Override
   public boolean isEmpty() {
-    return data.isEmpty();
+    return multimap.isEmpty();
   }
 
   /**
@@ -149,7 +154,7 @@ public boolean isEmpty() {
   @Override
   public Collection<Point> getIncomingConnections(Point node) {
     final Set<Point> set = new LinkedHashSet<>();
-    for (final Entry<Point, Point> entry : data.entries()) {
+    for (final Entry<Point, Point> entry : multimap.entries()) {
       if (entry.getValue().equals(node)) {
         set.add(entry.getKey());
       }
@@ -182,20 +187,20 @@ public void removeNode(Point node) {
   public void removeConnection(Point from, Point to) {
     checkArgument(hasConnection(from, to),
         "Can not remove non-existing connection: %s -> %s", from, to);
-    data.remove(from, to);
+    multimap.remove(from, to);
     removeData(from, to);
-    if (!data.containsKey(to)) {
+    if (!multimap.containsKey(to)) {
       deadEndNodes.add(to);
     }
   }
 
   private void removeData(Point from, Point to) {
-    edgeData.remove(new Connection<>(from, to, null));
+    lazyConnectionTable.remove(from, to);
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(data, deadEndNodes, edgeData);
+    return Objects.hashCode(multimap, deadEndNodes, lazyConnectionTable);
   }
 
   @Override
@@ -204,14 +209,15 @@ public boolean equals(@Nullable Object o) {
   }
 
   @Override
-  protected void doAddConnection(Point from, Point to, @Nullable E connData) {
-    data.put(from, to);
+  protected void doAddConnection(Point from, Point to, Optional<E> connData) {
+    multimap.put(from, to);
     deadEndNodes.remove(from);
-    if (!data.containsKey(to)) {
+    if (!multimap.containsKey(to)) {
       deadEndNodes.add(to);
     }
-    if (connData != null) {
-      this.edgeData.put(new Connection<E>(from, to, null), connData);
+    if (connData.isPresent()) {
+      this.lazyConnectionTable.put(from, to,
+          Connection.create(from, to, connData));
     }
   }
 }
diff --git a/geom/src/main/java/com/github/rinde/rinsim/geom/TableGraph.java b/geom/src/main/java/com/github/rinde/rinsim/geom/TableGraph.java
index fac2349fbe..5538224bb0 100755
--- a/geom/src/main/java/com/github/rinde/rinsim/geom/TableGraph.java
+++ b/geom/src/main/java/com/github/rinde/rinsim/geom/TableGraph.java
@@ -16,13 +16,9 @@
 package com.github.rinde.rinsim.geom;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.Maps.newLinkedHashMap;
 
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -30,9 +26,10 @@
 import javax.annotation.Nullable;
 
 import com.google.common.base.Objects;
-import com.google.common.base.Supplier;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Table;
-import com.google.common.collect.Table.Cell;
 import com.google.common.collect.Tables;
 
 /**
@@ -44,25 +41,23 @@
  */
 public class TableGraph<E extends ConnectionData> extends AbstractGraph<E> {
 
-  private final Table<Point, Point, E> data;
-  private final E empty;
+  private final Table<Point, Point, Connection<E>> data;
 
   /**
    * Create a new empty graph.
-   * @param emptyValue A special connection data instance that is used as the
-   *          'empty' instance.
    */
-  public TableGraph(E emptyValue) {
-    data = Tables.newCustomTable(new LinkedHashMap<Point, Map<Point, E>>(),
-        new Factory<E>());
-    empty = emptyValue;
+  public TableGraph() {
+    data = Tables.newCustomTable(
+        new LinkedHashMap<Point, Map<Point, Connection<E>>>(),
+        new LinkedHashMapFactory<Connection<E>>());
   }
 
   @Override
   public Set<Point> getNodes() {
-    final Set<Point> nodes = new LinkedHashSet<>(data.rowKeySet());
-    nodes.addAll(data.columnKeySet());
-    return Collections.unmodifiableSet(nodes);
+    return ImmutableSet.<Point> builder()
+        .addAll(data.rowKeySet())
+        .addAll(data.columnKeySet())
+        .build();
   }
 
   @Override
@@ -109,22 +104,11 @@ public void removeConnection(Point from, Point to) {
       throw new IllegalArgumentException(
           "Can not remove non-existing connection: " + from + " -> " + to);
     }
-
   }
 
   @Override
   public List<Connection<E>> getConnections() {
-    final List<Connection<E>> connections = new ArrayList<>();
-    for (final Cell<Point, Point, E> cell : data.cellSet()) {
-      if (empty.equals(cell.getValue())) {
-        connections.add(new Connection<E>(cell.getRowKey(),
-            cell.getColumnKey(), null));
-      } else {
-        connections.add(new Connection<>(cell.getRowKey(),
-            cell.getColumnKey(), cell.getValue()));
-      }
-    }
-    return connections;
+    return ImmutableList.copyOf(data.values());
   }
 
   @Override
@@ -132,74 +116,39 @@ public boolean isEmpty() {
     return data.isEmpty();
   }
 
-  @Override
-  protected boolean isEmptyConnectionData(@Nullable E connData) {
-    return super.isEmptyConnectionData(connData) || empty.equals(connData);
-  }
-
   @Override
   public Connection<E> getConnection(Point from, Point to) {
     checkArgument(hasConnection(from, to), "%s -> %s is not a connection",
         from, to);
-    return new Connection<>(from, to, connectionData(from, to));
+    return data.get(from, to);
   }
 
-  @Nullable
   @Override
-  public E connectionData(Point from, Point to) {
-    final E e = data.get(from, to);
-    if (empty.equals(e)) {
-      return null;
+  public Optional<E> connectionData(Point from, Point to) {
+    if (data.contains(from, to)) {
+      return data.get(from, to).data();
     }
-    return e;
+    return Optional.absent();
   }
 
   @Override
-  protected void doAddConnection(Point from, Point to, @Nullable E edgeData) {
-    if (edgeData == null) {
-      data.put(from, to, empty);
-    } else {
-      data.put(from, to, edgeData);
-    }
+  protected void doAddConnection(Point from, Point to, Optional<E> edgeData) {
+    data.put(from, to, Connection.create(from, to, edgeData));
   }
 
-  @Nullable
   @Override
-  public E setConnectionData(Point from, Point to, @Nullable E edgeData) {
-    if (hasConnection(from, to)) {
-      E e;
-      if (edgeData == null) {
-        e = data.put(from, to, empty);
-      } else {
-        e = data.put(from, to, edgeData);
-      }
-
-      if (empty.equals(e)) {
-        return null;
-      }
-      return e;
-    }
-    throw new IllegalArgumentException(
-        "Can not get connection length from a non-existing connection.");
+  protected Optional<E> doChangeConnectionData(Point from, Point to,
+      Optional<E> edgeData) {
+    return data.put(from, to, Connection.create(from, to, edgeData)).data();
   }
 
   @Override
   public int hashCode() {
-    return Objects.hashCode(data, empty);
+    return Objects.hashCode(data);
   }
 
   @Override
   public boolean equals(@Nullable Object o) {
     return super.equals(o);
   }
-
-  private static final class Factory<E> implements Supplier<Map<Point, E>> {
-    Factory() {}
-
-    @Override
-    public Map<Point, E> get() {
-      return newLinkedHashMap();
-    }
-  }
-
 }
diff --git a/geom/src/test/java/com/github/rinde/rinsim/geom/ConnectionTest.java b/geom/src/test/java/com/github/rinde/rinsim/geom/ConnectionTest.java
deleted file mode 100755
index fe0235bb5c..0000000000
--- a/geom/src/test/java/com/github/rinde/rinsim/geom/ConnectionTest.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *         http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.rinde.rinsim.geom;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-import org.junit.Test;
-
-/**
- * @author Rinde van Lon (rinde.vanlon@cs.kuleuven.be)
- * 
- */
-public class ConnectionTest {
-
-  private static final double DELTA = 0.0001;
-
-  @Test
-  public void unmodifiableConnection() {
-    final Connection<LengthData> original = new Connection<>(
-        new Point(2, 2), new Point(3, 3), null);
-    final Connection<LengthData> unmod = Graphs
-        .unmodifiableConnection(original);
-
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-    original.setData(new LengthData(300));
-
-    assertFalse(original.getData().equals(null));
-
-    assertEquals(original.getData(), unmod.getData());
-    assertEquals(original.getData().hashCode(), unmod.getData().hashCode());
-    assertEquals(original.getData().getLength(), unmod.getData().getLength(),
-        DELTA);
-    assertEquals(original.hashCode(), unmod.hashCode());
-    assertEquals(original.toString(), unmod.toString());
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-
-    original.setData(null);
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-  }
-
-  @Test
-  public void unmodifiableMultiAttributeEdgeData() {
-    final Connection<MultiAttributeData> original = new Connection<>(
-        new Point(2, 2), new Point(3, 3), null);
-    final Connection<MultiAttributeData> unmod = Graphs
-        .unmodifiableConnection(original);
-
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-    original.setData(new MultiAttributeData(10, 20d));
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-
-    original.getData().put("test", Arrays.asList(1, 2, 3));
-    assertEquals(unmod, original);
-    assertEquals(original, unmod);
-    assertEquals(Arrays.asList(1, 2, 3), unmod.getData()
-        .get("test", Object.class));
-    assertEquals(Arrays.asList(1, 2, 3), unmod.getData()
-        .get("test", List.class));
-    assertNull(unmod.getData().get("test", Map.class));
-    assertNull(unmod.getData().get("test2", Map.class));
-
-    assertEquals(original.getData().getLength(), unmod.getData().getLength(),
-        DELTA);
-    // both are null
-    assertEquals(original.getData().getMaxSpeed(), unmod.getData()
-        .getMaxSpeed(), DELTA);
-
-    assertTrue(original.getData().equals(unmod.getData()));
-    assertTrue(unmod.getData().equals(unmod.getData()));
-    assertEquals(unmod.getData().hashCode(), unmod.getData().hashCode());
-    assertEquals(original.hashCode(), unmod.hashCode());
-
-    original.getData().put(MultiAttributeData.KEY_LENGTH, new Object());
-    assertEquals(original, unmod);
-    original.getData().put(MultiAttributeData.KEY_MAX_SPEED, new Object());
-    assertEquals(original, unmod);
-
-    assertTrue(Double.isNaN(original.getData().getMaxSpeed()));
-    assertTrue(Double.isNaN(original.getData().getLength()));
-
-    assertTrue(Double.isNaN(original.getData().setMaxSpeed(100)));
-    assertEquals(100d, original.getData().setMaxSpeed(200), DELTA);
-
-    assertEquals(original, unmod);
-  }
-
-  @Test(expected = UnsupportedOperationException.class)
-  public void unmodMultiAttED() {
-    Graphs.unmodifiableConnectionData(new MultiAttributeData(10, 20d))
-        .setMaxSpeed(-1);
-  }
-
-  @Test(expected = UnsupportedOperationException.class)
-  public void unmodMultiAttED2() {
-    Graphs.unmodifiableConnectionData(new MultiAttributeData(10, 20d))
-        .put("", null);
-  }
-
-  @Test
-  public void equalsTest() {
-    final Connection<LengthData> c1 = new Connection<LengthData>(
-        new Point(2, 2), new Point(3, 3), null);
-    final Connection<LengthData> c2 = new Connection<LengthData>(
-        new Point(2, 2), new Point(2, 3), null);
-    final Connection<LengthData> c3 = new Connection<LengthData>(
-        new Point(3, 2), new Point(2, 3), null);
-    final Connection<LengthData> c4 = new Connection<LengthData>(
-        new Point(2, 2), new Point(3, 3), new LengthData(30));
-    assertFalse(c1.equals(new Object()));
-    assertFalse(c1.equals(c2));
-    assertFalse(c1.equals(c3));
-    assertFalse(c1.equals(c4));
-  }
-
-  @Test(expected = UnsupportedOperationException.class)
-  public void unmodifiableConnSetEdgeData() {
-    Graphs.unmodifiableConnection(new Connection<LengthData>(new Point(2, 2),
-        new Point(3, 3), null)).setData(null);
-  }
-}
diff --git a/geom/src/test/java/com/github/rinde/rinsim/geom/GraphsTest.java b/geom/src/test/java/com/github/rinde/rinsim/geom/GraphsTest.java
index 4100dfb79e..3dc378fe9b 100755
--- a/geom/src/test/java/com/github/rinde/rinsim/geom/GraphsTest.java
+++ b/geom/src/test/java/com/github/rinde/rinsim/geom/GraphsTest.java
@@ -19,8 +19,6 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -59,8 +57,8 @@ public GraphsTest(Class<? extends Graph<LengthData>> c) {
 
   @Parameters
   public static Collection<Object[]> configs() {
-    return Arrays.asList(new Object[][] { { TestMultimapGraph.class },
-        { TestTableGraph.class } });
+    return Arrays.asList(new Object[][] { { MultimapGraph.class },
+        { TableGraph.class } });
   }
 
   @Before
@@ -130,8 +128,8 @@ public void shortestPathConnData() {
     assertEquals(asList(a, b),
         Graphs.shortestPathEuclideanDistance(graph, a, b));
 
-    graph.setConnectionData(a, c, new LengthData(1d));
-    graph.setConnectionData(c, b, new LengthData(1d));
+    graph.setConnectionData(a, c, LengthData.create(1d));
+    graph.setConnectionData(c, b, LengthData.create(1d));
 
     assertEquals(asList(a, c, b),
         Graphs.shortestPathEuclideanDistance(graph, a, b));
@@ -173,8 +171,8 @@ public void connectionOrder() {
 
     final List<Connection<LengthData>> connections = graph.getConnections();
     for (int i = 1; i < points.size(); i++) {
-      assertSame(connections.get(i - 1).from, points.get(i - 1));
-      assertSame(connections.get(i - 1).to, points.get(i));
+      assertSame(connections.get(i - 1).from(), points.get(i - 1));
+      assertSame(connections.get(i - 1).to(), points.get(i));
     }
   }
 
@@ -242,25 +240,22 @@ public void connectionLengthFail() {
   }
 
   @Test
-  public void edgeDataUsage() {
+  public void connDataUsage() {
     final Point A = new Point(0, 0), B = new Point(0, 1), C = new Point(1, 0);
 
     graph.addConnection(A, B);
-    graph.addConnection(new Connection<LengthData>(B, A, new LengthData(1.5)));
-    graph.addConnection(B, C, new LengthData(2));
-    graph.addConnection(A, C, new LengthData(Double.NaN)); // explicit
-    // empty
-    // value
+    graph.addConnection(Connection.create(B, A, LengthData.create(1.5)));
+    graph.addConnection(B, C, LengthData.create(2));
+    // explicit empty value
+    graph.addConnection(A, C, LengthData.empty());
 
-    assertNull("existing but empty", graph.connectionData(A, B));
-    assertNull("non existing", graph.connectionData(C, A));
-    // assertNull("explicit null A->C", graph.connectionData(A, C)); //
-    // works only for TableGraph
+    assertFalse("existing but empty", graph.connectionData(A, B).isPresent());
+    assertFalse("non existing", graph.connectionData(C, A).isPresent());
 
-    assertNotNull("existing B->A", graph.connectionData(B, A));
-    assertNotNull("existing B->C", graph.connectionData(B, C));
+    assertTrue("existing B->A", graph.connectionData(B, A).isPresent());
+    assertTrue("existing B->C", graph.connectionData(B, C).isPresent());
 
-    // use of the edge data
+    // use of the connection data
     assertEquals(1, graph.connectionLength(A, B), DELTA);
     assertEquals(1.5, graph.connectionLength(B, A), DELTA);
     assertEquals(2, graph.connectionLength(B, C), DELTA);
@@ -284,11 +279,11 @@ public void equalsTest() {
     Graphs.addBiPath(graph, N, E, S, W, N);
     assertEquals(graph, graph);
 
-    final Graph<LengthData> g1 = new TableGraph<LengthData>(LengthData.EMPTY);
+    final Graph<LengthData> g1 = new TableGraph<>();
     g1.merge(graph);
     assertEquals(g1, graph);
 
-    final Graph<LengthData> g2 = new MultimapGraph<LengthData>();
+    final Graph<LengthData> g2 = new MultimapGraph<>();
     g2.merge(graph);
     assertEquals(g2, graph);
     assertEquals(g1, g2);
@@ -304,16 +299,16 @@ public void equalsTest() {
     assertFalse(g1.equals(graph));
 
     graph.removeConnection(N, E);
-    graph.addConnection(N, E, new LengthData(10));
+    graph.addConnection(N, E, LengthData.create(10));
     assertFalse(g1.equals(graph));
     assertFalse(graph.equals(g1));
 
-    final Graph<LengthData> g3 = new TableGraph<LengthData>(LengthData.EMPTY);
+    final Graph<LengthData> g3 = new TableGraph<>();
     g3.merge(graph);
     assertEquals(graph, g3);
 
     g3.removeConnection(N, E);
-    g3.addConnection(N, E, new LengthData(9));
+    g3.addConnection(N, E, LengthData.create(9));
     assertFalse(g3.equals(graph));
 
     assertFalse(g2.equals(graph));
@@ -396,8 +391,8 @@ public void unmodifiable() {
     }
 
     for (final Connection<LengthData> c : g.getConnections()) {
-      assertEquals(graph.connectionLength(c.from, c.to),
-          g.connectionLength(c.from, c.to), DELTA);
+      assertEquals(graph.connectionLength(c.from(), c.to()),
+          g.connectionLength(c.from(), c.to()), DELTA);
     }
   }
 
@@ -473,10 +468,10 @@ public void testMultimapGraphConstructor() {
     }
     Graphs.addBiPath(graph, path.toArray(new Point[path.size()]));
 
-    final MultimapGraph<LengthData> testGraph = new MultimapGraph<LengthData>();
+    final MultimapGraph<LengthData> testGraph = new MultimapGraph<>();
     testGraph.merge(graph);
 
-    final MultimapGraph<LengthData> newGraph = new MultimapGraph<LengthData>(
+    final MultimapGraph<LengthData> newGraph = new MultimapGraph<>(
         testGraph.getMultimap());
 
     assertEquals(testGraph.getMultimap(), newGraph.getMultimap());
@@ -490,16 +485,10 @@ public void setEdgeData() {
     final Point W = new Point(-5, 0);
 
     Graphs.addBiPath(graph, N, E, S, W, N);
-    assertNull(graph.setConnectionData(N, E, new LengthData(100)));
-    assertEquals(new LengthData(100), graph.setConnectionData(N, E, null));
-    if (graph instanceof TableGraph) {
-
-    }
-  }
-
-  @Test(expected = IllegalArgumentException.class)
-  public void setNonExistingEdgeData() {
-    graph.setConnectionData(new Point(1, 1), new Point(2, 3), null);
+    assertFalse(graph.setConnectionData(N, E, LengthData.create(100))
+        .isPresent());
+    assertEquals(LengthData.create(100),
+        graph.removeConnectionData(N, E).get());
   }
 
   @Test
@@ -520,16 +509,6 @@ public void removeNode() {
     assertEquals(4, graph.getConnections().size());
   }
 
-  @Test
-  public void isEmptyConnectionData() {
-    final AbstractGraph<?> g = (AbstractGraph<?>) graph;
-    assertTrue(g.isEmptyConnectionData(null));
-
-    final TableGraph<MultiAttributeData> tg = new TableGraph<MultiAttributeData>(
-        MultiAttributeData.EMPTY);
-    assertTrue(tg.isEmptyConnectionData(MultiAttributeData.EMPTY));
-  }
-
   @Test
   public void getRandomNodeImpossible() {
 
diff --git a/geom/src/test/java/com/github/rinde/rinsim/geom/ListenableGraphTest.java b/geom/src/test/java/com/github/rinde/rinsim/geom/ListenableGraphTest.java
index c54a954891..471564d189 100755
--- a/geom/src/test/java/com/github/rinde/rinsim/geom/ListenableGraphTest.java
+++ b/geom/src/test/java/com/github/rinde/rinsim/geom/ListenableGraphTest.java
@@ -32,6 +32,7 @@
 import com.github.rinde.rinsim.event.ListenerEventHistory;
 import com.github.rinde.rinsim.geom.ListenableGraph.EventTypes;
 import com.github.rinde.rinsim.geom.ListenableGraph.GraphEvent;
+import com.google.common.base.Optional;
 
 /**
  * Tests for {@link ListenableGraph}.
@@ -59,13 +60,13 @@ public void testModifications() {
     graph.addConnection(a, b);
     assertEquals(asList(ADD_CONNECTION), history.getEventTypeHistory());
 
-    graph.addConnection(b, a, null);
+    graph.addConnection(b, a, LengthData.create(2));
     assertEquals(asList(ADD_CONNECTION, ADD_CONNECTION),
         history.getEventTypeHistory());
 
     graph.addConnections(Arrays.<Connection<LengthData>> asList(
-        new Connection<>(a, d, new LengthData(10d)),
-        new Connection<>(d, e, new LengthData(7d))));
+        Connection.create(a, d, LengthData.create(10d)),
+        Connection.create(d, e, LengthData.create(7d))));
     assertEquals(
         asList(ADD_CONNECTION, ADD_CONNECTION, ADD_CONNECTION, ADD_CONNECTION),
         history.getEventTypeHistory());
@@ -76,7 +77,7 @@ public void testModifications() {
             REMOVE_CONNECTION),
         history.getEventTypeHistory());
 
-    graph.setConnectionData(a, d, new LengthData(16d));
+    graph.setConnectionData(a, d, LengthData.create(16d));
     assertEquals(
         asList(ADD_CONNECTION, ADD_CONNECTION, ADD_CONNECTION, ADD_CONNECTION,
             REMOVE_CONNECTION, CHANGE_CONNECTION_DATA),
@@ -117,32 +118,14 @@ public void testMerge() {
         history.getEventTypeHistory());
 
     assertEquals(2, history.getHistory().size());
-    assertEquals(new GraphEvent(ADD_CONNECTION, graph1, a, c, null), history
-        .getHistory().get(0));
-    assertEquals(new GraphEvent(ADD_CONNECTION, graph1, c, a, null), history
-        .getHistory().get(1));
-  }
-
-  /**
-   * Tests that modifications can not be applied directly to a connection.
-   */
-  @Test(expected = UnsupportedOperationException.class)
-  public void testUnmodifiableConnection() {
-    ListenableGraph<LengthData> graph = new ListenableGraph<>(
-        new MultimapGraph<LengthData>());
-    graph.addConnection(a, b);
-    graph.getConnection(a, b).setData(null);
-  }
-
-  /**
-   * Tests that modifications can not be applied directly to a connection.
-   */
-  @Test(expected = UnsupportedOperationException.class)
-  public void testUnmodifiableConnections() {
-    ListenableGraph<LengthData> graph = new ListenableGraph<>(
-        new MultimapGraph<LengthData>());
-    graph.addConnection(a, b);
-    graph.getConnections().iterator().next().setData(null);
+    assertEquals(
+        new GraphEvent(ADD_CONNECTION, graph1, a, c,
+            Optional.<ConnectionData> absent()), history
+            .getHistory().get(0));
+    assertEquals(
+        new GraphEvent(ADD_CONNECTION, graph1, c, a,
+            Optional.<ConnectionData> absent()), history
+            .getHistory().get(1));
   }
 
   static class GraphModificationChecker implements Listener {
@@ -153,13 +136,13 @@ public void handleEvent(Event e) {
       if (e.getEventType() == ADD_CONNECTION) {
         assertTrue(ge.getGraph().hasConnection(ge.getFrom(), ge.getTo()));
         assertEquals(ge.getConnData(),
-            ge.getGraph().getConnection(ge.getFrom(), ge.getTo()).getData());
+            ge.getGraph().getConnection(ge.getFrom(), ge.getTo()).data());
       } else if (e.getEventType() == REMOVE_CONNECTION) {
         assertFalse(ge.getGraph().hasConnection(ge.getFrom(), ge.getTo()));
       } else if (e.getEventType() == CHANGE_CONNECTION_DATA) {
         assertTrue(ge.getGraph().hasConnection(ge.getFrom(), ge.getTo()));
         assertEquals(ge.getConnData(),
-            ge.getGraph().getConnection(ge.getFrom(), ge.getTo()).getData());
+            ge.getGraph().getConnection(ge.getFrom(), ge.getTo()).data());
       }
 
     }
diff --git a/geom/src/test/java/com/github/rinde/rinsim/geom/TestMultimapGraph.java b/geom/src/test/java/com/github/rinde/rinsim/geom/TestMultimapGraph.java
deleted file mode 100755
index 7b8edc960a..0000000000
--- a/geom/src/test/java/com/github/rinde/rinsim/geom/TestMultimapGraph.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2011-2014 Rinde van Lon, iMinds DistriNet, KU Leuven
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *         http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.github.rinde.rinsim.geom;
-
-import com.github.rinde.rinsim.geom.MultiAttributeData;
-import com.github.rinde.rinsim.geom.MultimapGraph;
-
-public class TestMultimapGraph extends MultimapGraph<MultiAttributeData> {
-
-}
diff --git a/pom.xml b/pom.xml
index 75f78ea894..9427f13daf 100755
--- a/pom.xml
+++ b/pom.xml
@@ -485,6 +485,12 @@
 				<version>1.0</version>
 				<scope>provided</scope>
 			</dependency>
+			<dependency>
+				<groupId>org.inferred</groupId>
+				<artifactId>freebuilder</artifactId>
+				<version>1.0-rc3</version>
+				<optional>true</optional>
+			</dependency>
 			<dependency>
 				<groupId>com.github.rinde</groupId>
 				<artifactId>rinsim-event</artifactId>
diff --git a/ui/.settings/org.eclipse.jdt.core.prefs b/ui/.settings/org.eclipse.jdt.core.prefs
index 683cfd02fd..19e656f584 100755
--- a/ui/.settings/org.eclipse.jdt.core.prefs
+++ b/ui/.settings/org.eclipse.jdt.core.prefs
@@ -166,13 +166,14 @@ org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_lambda_body=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
 org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
 org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=true
 org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
 org.eclipse.jdt.core.formatter.comment.format_block_comments=true
-org.eclipse.jdt.core.formatter.comment.format_header=true
+org.eclipse.jdt.core.formatter.comment.format_header=false
 org.eclipse.jdt.core.formatter.comment.format_html=true
 org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
 org.eclipse.jdt.core.formatter.comment.format_line_comments=true
@@ -211,6 +212,7 @@ org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do
 org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_label=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
 org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
@@ -258,6 +260,7 @@ org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=inser
 org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
 org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
 org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow=insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
@@ -335,6 +338,7 @@ org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do n
 org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow=insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
 org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
diff --git a/ui/.settings/org.eclipse.jdt.ui.prefs b/ui/.settings/org.eclipse.jdt.ui.prefs
index 229f093d4b..998139b8e2 100755
--- a/ui/.settings/org.eclipse.jdt.ui.prefs
+++ b/ui/.settings/org.eclipse.jdt.ui.prefs
@@ -11,10 +11,12 @@ cleanup.always_use_blocks=true
 cleanup.always_use_parentheses_in_expressions=false
 cleanup.always_use_this_for_non_static_field_access=false
 cleanup.always_use_this_for_non_static_method_access=false
+cleanup.convert_functional_interfaces=false
 cleanup.convert_to_enhanced_for_loop=false
 cleanup.correct_indentation=true
 cleanup.format_source_code=true
 cleanup.format_source_code_changes_only=false
+cleanup.insert_inferred_type_arguments=false
 cleanup.make_local_variable_final=true
 cleanup.make_parameters_final=false
 cleanup.make_private_fields_final=true
@@ -29,6 +31,7 @@ cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=tru
 cleanup.qualify_static_member_accesses_with_declaring_class=true
 cleanup.qualify_static_method_accesses_with_declaring_class=false
 cleanup.remove_private_constructors=true
+cleanup.remove_redundant_type_arguments=true
 cleanup.remove_trailing_whitespaces=true
 cleanup.remove_trailing_whitespaces_all=true
 cleanup.remove_trailing_whitespaces_ignore_empty=false
@@ -42,13 +45,16 @@ cleanup.remove_unused_private_methods=true
 cleanup.remove_unused_private_types=true
 cleanup.sort_members=false
 cleanup.sort_members_all=false
+cleanup.use_anonymous_class_creation=false
 cleanup.use_blocks=true
 cleanup.use_blocks_only_for_return_and_throw=false
+cleanup.use_lambda=true
 cleanup.use_parentheses_in_expressions=true
 cleanup.use_this_for_non_static_field_access=true
 cleanup.use_this_for_non_static_field_access_only_if_necessary=true
 cleanup.use_this_for_non_static_method_access=true
 cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+cleanup.use_type_arguments=false
 cleanup_profile=_Eclipse [rinde]
 cleanup_settings_version=2
 eclipse.preferences.version=1
@@ -72,10 +78,12 @@ sp_cleanup.always_use_blocks=true
 sp_cleanup.always_use_parentheses_in_expressions=false
 sp_cleanup.always_use_this_for_non_static_field_access=false
 sp_cleanup.always_use_this_for_non_static_method_access=false
+sp_cleanup.convert_functional_interfaces=false
 sp_cleanup.convert_to_enhanced_for_loop=false
-sp_cleanup.correct_indentation=true
+sp_cleanup.correct_indentation=false
 sp_cleanup.format_source_code=true
 sp_cleanup.format_source_code_changes_only=false
+sp_cleanup.insert_inferred_type_arguments=false
 sp_cleanup.make_local_variable_final=true
 sp_cleanup.make_parameters_final=false
 sp_cleanup.make_private_fields_final=true
@@ -91,6 +99,7 @@ sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=
 sp_cleanup.qualify_static_member_accesses_with_declaring_class=true
 sp_cleanup.qualify_static_method_accesses_with_declaring_class=false
 sp_cleanup.remove_private_constructors=true
+sp_cleanup.remove_redundant_type_arguments=false
 sp_cleanup.remove_trailing_whitespaces=true
 sp_cleanup.remove_trailing_whitespaces_all=true
 sp_cleanup.remove_trailing_whitespaces_ignore_empty=false
@@ -104,10 +113,13 @@ sp_cleanup.remove_unused_private_methods=true
 sp_cleanup.remove_unused_private_types=true
 sp_cleanup.sort_members=false
 sp_cleanup.sort_members_all=false
+sp_cleanup.use_anonymous_class_creation=false
 sp_cleanup.use_blocks=true
 sp_cleanup.use_blocks_only_for_return_and_throw=false
+sp_cleanup.use_lambda=false
 sp_cleanup.use_parentheses_in_expressions=true
 sp_cleanup.use_this_for_non_static_field_access=true
 sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=true
 sp_cleanup.use_this_for_non_static_method_access=true
 sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+sp_cleanup.use_type_arguments=false
diff --git a/ui/src/main/java/com/github/rinde/rinsim/ui/renderers/GraphRoadModelRenderer.java b/ui/src/main/java/com/github/rinde/rinsim/ui/renderers/GraphRoadModelRenderer.java
index a4b5459f57..828d336384 100755
--- a/ui/src/main/java/com/github/rinde/rinsim/ui/renderers/GraphRoadModelRenderer.java
+++ b/ui/src/main/java/com/github/rinde/rinsim/ui/renderers/GraphRoadModelRenderer.java
@@ -33,9 +33,9 @@
 import com.google.common.base.Optional;
 
 /**
- * 
+ *
  * @author Rinde van Lon (rinde.vanlon@cs.kuleuven.be)
- * 
+ *
  */
 public final class GraphRoadModelRenderer implements ModelRenderer {
 
@@ -87,11 +87,11 @@ public void renderStatic(GC gc, ViewPort vp) {
     }
 
     for (final Connection<? extends ConnectionData> e : graph.getConnections()) {
-      final int x1 = vp.toCoordX(e.from.x);
-      final int y1 = vp.toCoordY(e.from.y);
+      final int x1 = vp.toCoordX(e.from().x);
+      final int y1 = vp.toCoordY(e.from().y);
 
-      final int x2 = vp.toCoordX(e.to.x);
-      final int y2 = vp.toCoordY(e.to.y);
+      final int x2 = vp.toCoordX(e.to().x);
+      final int y2 = vp.toCoordY(e.to().y);
       gc.setForeground(gc.getDevice().getSystemColor(SWT.COLOR_GRAY));
       gc.drawLine(x1, y1, x2, y2);
 
