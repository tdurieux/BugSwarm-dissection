diff --git a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
index c5f22c559b..f7822c71a8 100755
--- a/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
+++ b/retrofit-converters/jackson/src/main/java/retrofit/converter/JacksonConverter.java
@@ -4,13 +4,11 @@
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * A {@link Converter} which uses Jackson for reading and writing entities.
@@ -18,7 +16,7 @@
  * @author Kai Waldron (kaiwaldron@gmail.com)
  */
 public class JacksonConverter implements Converter {
-  private static final MediaType MIME_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
 
   private final ObjectMapper objectMapper;
 
@@ -30,31 +28,26 @@ public JacksonConverter(ObjectMapper objectMapper) {
     this.objectMapper = objectMapper;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
-    InputStream in = null;
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
       JavaType javaType = objectMapper.getTypeFactory().constructType(type);
-      in = body.in();
-      return objectMapper.readValue(in, javaType);
+      return objectMapper.readValue(is, javaType);
     } finally {
       try {
-        if (in != null) {
-          in.close();
-        }
+        is.close();
       } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     try {
       JavaType javaType = objectMapper.getTypeFactory().constructType(type);
       String json = objectMapper.writerWithType(javaType).writeValueAsString(object);
-      return new TypedByteArray(json.getBytes("UTF-8"), MIME_TYPE);
+      return RequestBody.create(MEDIA_TYPE, json);
     } catch (JsonProcessingException e) {
-      throw new AssertionError(e);
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError(e);
+      throw new RuntimeException(e);
     }
   }
 }
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
index 32f0d5c710..4114ba0758 100755
--- a/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/converter/JacksonConverterTest.java
@@ -4,53 +4,54 @@
 import com.fasterxml.jackson.databind.JsonMappingException;
 import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
 import com.squareup.okhttp.MediaType;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterTest {
-  private static final MediaType MIME_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
   private static final MyObject OBJECT = new MyObject("hello world", 10);
   private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
 
   private final JacksonConverter converter = new JacksonConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput typedOutput = converter.toBody(OBJECT, MyObject.class);
-    assertThat(typedOutput.mediaType()).isEqualTo(MIME_TYPE);
-    assertThat(asString(typedOutput)).isEqualTo(JSON);
+    RequestBody body = converter.toBody(OBJECT, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(JSON);
   }
 
   @Test public void deserialize() throws Exception {
-    TypedInput input = new TypedByteArray(JSON.getBytes(), MIME_TYPE);
-    MyObject result = (MyObject) converter.fromBody(input, MyObject.class);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
     assertThat(result).isEqualTo(OBJECT);
   }
 
   @Test public void deserializeWrongValue() throws Exception {
-    TypedInput input = new TypedByteArray("{\"foo\":\"bar\"}".getBytes(), MIME_TYPE);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
     try {
-      converter.fromBody(input, MyObject.class);
+      converter.fromBody(body, MyObject.class);
     } catch (UnrecognizedPropertyException ignored) {
     }
   }
 
   @Test public void deserializeWrongClass() throws Exception {
-    TypedInput input = new TypedByteArray(JSON.getBytes(), MIME_TYPE);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
     try {
-      converter.fromBody(input, String.class);
+      converter.fromBody(body, String.class);
     } catch (JsonMappingException ignored) {
     }
   }
 
-  private String asString(TypedOutput typedOutput) throws Exception {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    typedOutput.writeTo(bytes);
-    return new String(bytes.toByteArray());
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 
   static class MyObject {
diff --git a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
index 503e0146d4..b9270c44ec 100755
--- a/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
+++ b/retrofit-converters/protobuf/src/main/java/retrofit/converter/ProtoConverter.java
@@ -3,20 +3,19 @@
 
 import com.google.protobuf.AbstractMessageLite;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers. */
 public class ProtoConverter implements Converter {
-  private static final MediaType MIME_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -25,25 +24,31 @@
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     }
 
+    InputStream is = body.byteStream();
     try {
       Method parseFrom = c.getMethod("parseFrom", InputStream.class);
-      return parseFrom.invoke(null, body.in());
+      return parseFrom.invoke(null, is);
     } catch (InvocationTargetException e) {
       throw new RuntimeException(c.getName() + ".parseFrom() failed", e.getCause());
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException("Expected a protobuf message but was " + c.getName());
     } catch (IllegalAccessException e) {
       throw new AssertionError();
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof AbstractMessageLite)) {
       throw new IllegalArgumentException(
           "Expected a protobuf message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((AbstractMessageLite) object).toByteArray();
-    return new TypedByteArray(bytes, MIME_TYPE);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
index fcc40ad557..99bcc58f5a 100755
--- a/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/converter/ProtoConverterTest.java
@@ -1,16 +1,16 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.squareup.okhttp.MediaType;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -20,22 +20,22 @@
   private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
   private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
 
-  private final ProtoConverter protoConverter = new ProtoConverter();
+  private final ProtoConverter converter = new ProtoConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = protoConverter.toBody(PROTO, Phone.class);
-    assertThat(protoBytes.mediaType().toString()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(ENCODED_PROTO)));
+    RequestBody body = converter.toBody(PROTO, Phone.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = protoConverter.fromBody(decodeBase64(ENCODED_PROTO), Phone.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
@@ -44,7 +44,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
+      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
@@ -53,24 +53,21 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      protoConverter.fromBody(decodeBase64("////"), Phone.class);
+      converter.fromBody(protoResponse("////"), Phone.class);
       fail();
     } catch (RuntimeException expected) {
       assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
     }
   }
 
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
+        encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, MediaType.parse("application/x-protobuf"));
-  }
-
-  private static TypedByteArray decodeBase64(String base64, MediaType mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(BaseEncoding.base64().decode(base64), mime);
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
index 4c5c0b6a59..93374412ca 100755
--- a/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/converter/SimpleXMLConverter.java
@@ -1,17 +1,15 @@
 package retrofit.converter;
 
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.OutputStreamWriter;
 import java.lang.reflect.Type;
-
-import org.simpleframework.xml.core.Persister;
 import org.simpleframework.xml.Serializer;
-
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
+import org.simpleframework.xml.core.Persister;
 
 /**
  * A {@link Converter} which uses SimpleXML for reading and writing entities.
@@ -21,7 +19,8 @@
 public class SimpleXMLConverter implements Converter {
   private static final boolean DEFAULT_STRICT = true;
   private static final String CHARSET = "UTF-8";
-  private static final MediaType MIME_TYPE = MediaType.parse("application/xml; charset=" + CHARSET);
+  private static final MediaType MEDIA_TYPE =
+      MediaType.parse("application/xml; charset=" + CHARSET);
 
   private final Serializer serializer;
 
@@ -44,35 +43,34 @@ public SimpleXMLConverter(Serializer serializer, boolean strict) {
     this.strict = strict;
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
+    InputStream is = body.byteStream();
     try {
-      return serializer.read((Class<?>) type, body.in(), strict);
+      return serializer.read((Class<?>) type, is, strict);
     } catch (IOException e) {
       throw e;
     } catch (Exception e) {
       throw new RuntimeException(e);
+    } finally {
+      try {
+        is.close();
+      } catch (IOException ignored) {
+      }
     }
   }
 
-  @Override public TypedOutput toBody(Object source, Type type) {
-    OutputStreamWriter osw = null;
-
+  @Override public RequestBody toBody(Object source, Type type) {
+    byte[] bytes;
     try {
       ByteArrayOutputStream bos = new ByteArrayOutputStream();
-      osw = new OutputStreamWriter(bos, CHARSET);
+      OutputStreamWriter osw = new OutputStreamWriter(bos, CHARSET);
       serializer.write(source, osw);
       osw.flush();
-      return new TypedByteArray(bos.toByteArray(), MIME_TYPE);
+      bytes = bos.toByteArray();
     } catch (Exception e) {
       throw new AssertionError(e);
-    } finally {
-      try {
-        if (osw != null) {
-          osw.close();
-        }
-      } catch (IOException ignored) {
-      }
     }
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 
   public boolean isStrict() {
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
index 1cd21e65e1..3da7ee8877 100755
--- a/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/converter/SimpleXMLConverterTest.java
@@ -1,7 +1,12 @@
 package retrofit.converter;
 
 import com.squareup.okhttp.MediaType;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
+import org.junit.Before;
 import org.junit.Test;
 import org.simpleframework.xml.Default;
 import org.simpleframework.xml.DefaultType;
@@ -10,63 +15,55 @@
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class SimpleXMLConverterTest {
-	private static final MediaType MIME_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+	private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+	private static final MyObject OBJ = new MyObject("hello world", 10);
+  private static final String XML =
+      "<my-object><message>hello world</message><count>10</count></my-object>";
 
-	private final MyObject obj = new MyObject("hello world", 10);
-	private final String objAsXML = String.format(
-			"<my-object><message>%s</message><count>%d</count></my-object>",
-			obj.getMessage(), obj.getCount());
-	private final Converter converter = initConverter();
+	private Converter converter;
 
-	private static Converter initConverter() {
+	@Before public void setUp() {
 		Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
 		Persister persister = new Persister(format);
-		return new SimpleXMLConverter(persister);
+		converter = new SimpleXMLConverter(persister);
 	}
 
-	@Test
-	public void serialize() throws Exception {
-		final TypedOutput typedOutput = converter.toBody(obj, MyObject.class);
-		assertThat(typedOutput.mediaType()).isEqualTo(MIME_TYPE);
-		assertThat(asString(typedOutput)).isEqualTo(objAsXML);
+	@Test public void serialize() throws Exception {
+		RequestBody body = converter.toBody(OBJ, MyObject.class);
+		assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+		assertBody(body).isEqualTo(XML);
 	}
 
-	@Test
-	public void deserialize() throws Exception {
-		final TypedInput input = new TypedByteArray(objAsXML.getBytes(), MIME_TYPE);
-		final MyObject result = (MyObject) converter.fromBody(input,
-				MyObject.class);
-		assertThat(result).isEqualTo(obj);
+	@Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+		MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+		assertThat(result).isEqualTo(OBJ);
 	}
 
 	@Test public void deserializeWrongValue() throws Exception {
-		final TypedInput input = new TypedByteArray("<myObject><foo/><bar/></myObject>".getBytes(),
-        MIME_TYPE);
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
     try {
-      converter.fromBody(input, MyObject.class);
+      converter.fromBody(body, MyObject.class);
     } catch (RuntimeException ignored) {
     }
 	}
 
-	@Test
-	public void deserializeWrongClass() throws Exception {
-		final TypedInput input = new TypedByteArray(objAsXML.getBytes(), MIME_TYPE);
-		Object result = converter.fromBody(input, String.class);
+	@Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+		Object result = converter.fromBody(body, String.class);
 		assertThat(result).isNull();
 	}
 
-	private String asString(TypedOutput typedOutput) throws Exception {
-		final ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-		typedOutput.writeTo(bytes);
-		return new String(bytes.toByteArray());
-	}
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
+      throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
 
 	@Default(value = DefaultType.FIELD)
 	static class MyObject {
diff --git a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
index 55ff186017..af3ea1941e 100755
--- a/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
+++ b/retrofit-converters/wire/src/main/java/retrofit/converter/WireConverter.java
@@ -2,18 +2,17 @@
 package retrofit.converter;
 
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.wire.Message;
 import com.squareup.wire.Wire;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /** A {@link Converter} that reads and writes protocol buffers using Wire. */
 public class WireConverter implements Converter {
-  private static final MediaType MIME_TYPE = MediaType.parse("application/x-protobuf");
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/x-protobuf");
 
   private final Wire wire;
 
@@ -28,7 +27,7 @@ public WireConverter(Wire wire) {
   }
 
   @SuppressWarnings("unchecked") //
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     if (!(type instanceof Class<?>)) {
       throw new IllegalArgumentException("Expected a raw Class<?> but was " + type);
     }
@@ -37,27 +36,24 @@ public WireConverter(Wire wire) {
       throw new IllegalArgumentException("Expected a proto message but was " + c.getName());
     }
 
-    InputStream in = null;
+    InputStream in = body.byteStream();
     try {
-      in = body.in();
       return wire.parseFrom(in, (Class<Message>) c);
     } finally {
-      if (in != null) {
-        try {
-          in.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        in.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     if (!(object instanceof Message)) {
       throw new IllegalArgumentException(
           "Expected a proto message but was " + (object != null ? object.getClass().getName()
               : "null"));
     }
     byte[] bytes = ((Message) object).toByteArray();
-    return new TypedByteArray(bytes, MIME_TYPE);
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 }
diff --git a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
index 9a34822a3f..cc719fcbbb 100755
--- a/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/converter/WireConverterTest.java
@@ -1,16 +1,15 @@
 // Copyright 2013 Square, Inc.
 package retrofit.converter;
 
-import com.google.common.io.BaseEncoding;
 import com.squareup.okhttp.MediaType;
-import com.squareup.wire.Wire;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import okio.Buffer;
+import okio.ByteString;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.mime.TypedByteArray;
-import retrofit.mime.TypedOutput;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
@@ -18,24 +17,24 @@
 public final class WireConverterTest {
   private static final Person PROTO =
       new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
-  private static final String PROTO_ENCODED = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
+  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
 
-  private WireConverter converter = new WireConverter(new Wire());
+  private final WireConverter converter = new WireConverter();
 
   @Test public void serialize() throws Exception {
-    TypedOutput protoBytes = converter.toBody(PROTO, Person.class);
-    assertThat(protoBytes.mediaType().toString()).isEqualTo("application/x-protobuf");
-    assertThat(bytesOf(protoBytes)).isEqualTo(bytesOf(decodeBase64(PROTO_ENCODED)));
+    RequestBody body = converter.toBody(PROTO, Person.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
   @Test public void deserialize() throws Exception {
-    Object proto = converter.fromBody(decodeBase64(PROTO_ENCODED), Person.class);
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
     assertThat(proto).isEqualTo(PROTO);
   }
 
   @Test public void deserializeWrongClass() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED), String.class);
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
@@ -44,7 +43,7 @@
 
   @Test public void deserializeWrongType() throws Exception {
     try {
-      converter.fromBody(decodeBase64(PROTO_ENCODED),
+      converter.fromBody(protoResponse(ENCODED_PROTO),
           ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
@@ -54,23 +53,20 @@
 
   @Test public void deserializeWrongValue() throws Exception {
     try {
-      converter.fromBody(decodeBase64("////"), Person.class);
+      converter.fromBody(protoResponse("////"), Person.class);
       fail();
     } catch (IOException ignored) {
     }
   }
 
-  private static byte[] bytesOf(TypedOutput protoBytes) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    protoBytes.writeTo(bytes);
-    return bytes.toByteArray();
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
+        ByteString.decodeBase64(encodedProto).toByteArray());
   }
 
-  private static TypedByteArray decodeBase64(String base64) throws UnsupportedEncodingException {
-    return decodeBase64(base64, MediaType.parse("application/x-protobuf"));
-  }
-
-  private static TypedByteArray decodeBase64(String base64, MediaType mime) throws UnsupportedEncodingException {
-    return new TypedByteArray(BaseEncoding.base64().decode(base64), mime);
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
index 9aef75bc90..03f1194e90 100755
--- a/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
+++ b/retrofit-mock/src/main/java/retrofit/MockResponseBody.java
@@ -3,7 +3,6 @@
 
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.ResponseBody;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -39,9 +38,9 @@
 
   private synchronized void initBytes() throws IOException {
     if (bytes == null) {
-      ByteArrayOutputStream out = new ByteArrayOutputStream();
-      converter.toBody(body, body.getClass()).writeTo(out);
-      bytes = out.toByteArray();
+      Buffer buffer = new Buffer();
+      converter.toBody(body, body.getClass()).writeTo(buffer);
+      bytes = buffer.readByteArray();
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
index 79f7b08b46..db7c14d63b 100755
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -1,116 +1,47 @@
 package retrofit;
 
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
-import retrofit.mime.TypedInput;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ForwardingSource;
+import okio.Okio;
 
-class ExceptionCatchingRequestBody implements TypedInput {
-  private final TypedInput delegate;
-  private final ExceptionCatchingInputStream delegateStream;
+class ExceptionCatchingRequestBody extends ResponseBody {
+  private final ResponseBody delegate;
+  private IOException thrownException;
 
-  ExceptionCatchingRequestBody(TypedInput delegate) throws IOException {
+  ExceptionCatchingRequestBody(ResponseBody delegate) {
     this.delegate = delegate;
-    this.delegateStream = new ExceptionCatchingInputStream(delegate.in());
   }
 
-  @Override public MediaType mediaType() {
-    return delegate.mediaType();
+  @Override public MediaType contentType() {
+    return delegate.contentType();
   }
 
-  @Override public long length() {
-    return delegate.length();
+  @Override public long contentLength() {
+    return delegate.contentLength();
   }
 
-  @Override public InputStream in() throws IOException {
-    return delegateStream;
+  @Override public BufferedSource source() {
+    return Okio.buffer(new ForwardingSource(delegate.source()) {
+      @Override public long read(Buffer sink, long byteCount) throws IOException {
+        try {
+          return super.read(sink, byteCount);
+        } catch (IOException e) {
+          thrownException = e;
+          throw e;
+        }
+      }
+    });
   }
 
   IOException getThrownException() {
-    return delegateStream.thrownException;
+    return thrownException;
   }
 
   boolean threwException() {
-    return delegateStream.thrownException != null;
-  }
-
-  private static class ExceptionCatchingInputStream extends InputStream {
-    private final InputStream delegate;
-    private IOException thrownException;
-
-    ExceptionCatchingInputStream(InputStream delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public int read() throws IOException {
-      try {
-        return delegate.read();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer) throws IOException {
-      try {
-        return delegate.read(buffer);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int length) throws IOException {
-      try {
-        return delegate.read(buffer, offset, length);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public long skip(long byteCount) throws IOException {
-      try {
-        return delegate.skip(byteCount);
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public int available() throws IOException {
-      try {
-        return delegate.available();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public void close() throws IOException {
-      try {
-        delegate.close();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public synchronized void mark(int readLimit) {
-      delegate.mark(readLimit);
-    }
-
-    @Override public synchronized void reset() throws IOException {
-      try {
-        delegate.reset();
-      } catch (IOException e) {
-        thrownException = e;
-        throw e;
-      }
-    }
-
-    @Override public boolean markSupported() {
-      return delegate.markSupported();
-    }
+    return thrownException != null;
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 8720f524d3..ba15b5a2da 100755
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -18,26 +18,20 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
 import java.net.URLEncoder;
 import java.util.Map;
+import okio.BufferedSink;
 import retrofit.converter.Converter;
 import retrofit.http.Body;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
+import retrofit.http.Header;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
-import retrofit.mime.FormUrlEncodedTypedOutput;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 
 final class RequestBuilder implements RequestInterceptor.RequestFacade {
   private static final Headers NO_HEADERS = Headers.of();
@@ -48,9 +42,7 @@
   private final boolean async;
   private final String apiUrl;
 
-  private final FormUrlEncodedTypedOutput formBody;
-  private final MultipartTypedOutput multipartBody;
-  private TypedOutput body;
+  private RequestBody body;
 
   private String relativeUrl;
   private StringBuilder queryParams;
@@ -76,26 +68,6 @@
     if (requestQuery != null) {
       queryParams = new StringBuilder().append('?').append(requestQuery);
     }
-
-    switch (methodInfo.requestType) {
-      case FORM_URL_ENCODED:
-        formBody = new FormUrlEncodedTypedOutput();
-        multipartBody = null;
-        body = formBody;
-        break;
-      case MULTIPART:
-        formBody = null;
-        multipartBody = new MultipartTypedOutput();
-        body = multipartBody;
-        break;
-      case SIMPLE:
-        formBody = null;
-        multipartBody = null;
-        // If present, 'body' will be set in 'setArguments' call.
-        break;
-      default:
-        throw new IllegalArgumentException("Unknown request type: " + methodInfo.requestType);
-    }
   }
 
   @Override public void addHeader(String name, String value) {
@@ -248,9 +220,9 @@ void setArguments(Object[] args) {
           QueryMap queryMap = (QueryMap) annotation;
           addQueryParamMap(i, (Map<?, ?>) value, queryMap.encodeNames(), queryMap.encodeValues());
         }
-      } else if (annotationType == retrofit.http.Header.class) {
+      } else if (annotationType == Header.class) {
         if (value != null) { // Skip null values.
-          String name = ((retrofit.http.Header) annotation).value();
+          String name = ((Header) annotation).value();
           if (value instanceof Iterable) {
             for (Object iterableValue : (Iterable<?>) value) {
               if (iterableValue != null) { // Skip null values.
@@ -268,90 +240,93 @@ void setArguments(Object[] args) {
             addHeader(name, value.toString());
           }
         }
-      } else if (annotationType == Field.class) {
-        if (value != null) { // Skip null values.
-          Field field = (Field) annotation;
-          String name = field.value();
-          boolean encodeName = field.encodeName();
-          boolean encodeValue = field.encodeValue();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
-              }
-            }
-          } else {
-            formBody.addField(name, encodeName, value.toString(), encodeValue);
-          }
-        }
-      } else if (annotationType == FieldMap.class) {
-        if (value != null) { // Skip null values.
-          FieldMap fieldMap = (FieldMap) annotation;
-          boolean encodeNames = fieldMap.encodeNames();
-          boolean encodeValues = fieldMap.encodeValues();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " field map contained null key.");
-            }
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
-                  encodeValues);
-            }
-          }
-        }
-      } else if (annotationType == Part.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Part) annotation).value();
-          String transferEncoding = ((Part) annotation).encoding();
-          if (value instanceof TypedOutput) {
-            multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
-          } else if (value instanceof String) {
-            multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
-          } else {
-            multipartBody.addPart(name, transferEncoding,
-                converter.toBody(value, value.getClass()));
-          }
-        }
-      } else if (annotationType == PartMap.class) {
-        if (value != null) { // Skip null values.
-          String transferEncoding = ((PartMap) annotation).encoding();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " part map contained null key.");
-            }
-            String entryName = entryKey.toString();
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              if (entryValue instanceof TypedOutput) {
-                multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
-              } else if (entryValue instanceof String) {
-                multipartBody.addPart(entryName, transferEncoding,
-                    new TypedString((String) entryValue));
-              } else {
-                multipartBody.addPart(entryName, transferEncoding,
-                    converter.toBody(entryValue, entryValue.getClass()));
-              }
-            }
-          }
-        }
+      // TODO bring back form url encoding!
+      //} else if (annotationType == Field.class) {
+      //  if (value != null) { // Skip null values.
+      //    Field field = (Field) annotation;
+      //    String name = field.value();
+      //    boolean encodeName = field.encodeName();
+      //    boolean encodeValue = field.encodeValue();
+      //    if (value instanceof Iterable) {
+      //      for (Object iterableValue : (Iterable<?>) value) {
+      //        if (iterableValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, iterableValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else if (value.getClass().isArray()) {
+      //      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+      //        Object arrayValue = Array.get(value, x);
+      //        if (arrayValue != null) { // Skip null values.
+      //          formBody.addField(name, encodeName, arrayValue.toString(), encodeValue);
+      //        }
+      //      }
+      //    } else {
+      //      formBody.addField(name, encodeName, value.toString(), encodeValue);
+      //    }
+      //  }
+      //} else if (annotationType == FieldMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    FieldMap fieldMap = (FieldMap) annotation;
+      //    boolean encodeNames = fieldMap.encodeNames();
+      //    boolean encodeValues = fieldMap.encodeValues();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " field map contained null key.");
+      //      }
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        formBody.addField(entryKey.toString(), encodeNames, entryValue.toString(),
+      //            encodeValues);
+      //      }
+      //    }
+      //  }
+      // TODO bring back multipart!
+      //} else if (annotationType == Part.class) {
+      //  if (value != null) { // Skip null values.
+      //    String name = ((Part) annotation).value();
+      //    String transferEncoding = ((Part) annotation).encoding();
+      //    if (value instanceof RequestBody) {
+      //      multipartBody.addPart((RequestBody) value);
+      //      multipartBody.addPart(name, transferEncoding, (TypedOutput) value);
+      //    } else if (value instanceof String) {
+      //      multipartBody.addPart(name, transferEncoding, new TypedString((String) value));
+      //    } else {
+      //      multipartBody.addPart(name, transferEncoding,
+      //          converter.toBody(value, value.getClass()));
+      //    }
+      //  }
+      //} else if (annotationType == PartMap.class) {
+      //  if (value != null) { // Skip null values.
+      //    String transferEncoding = ((PartMap) annotation).encoding();
+      //    for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+      //      Object entryKey = entry.getKey();
+      //      if (entryKey == null) {
+      //        throw new IllegalArgumentException(
+      //            "Parameter #" + (i + 1) + " part map contained null key.");
+      //      }
+      //      String entryName = entryKey.toString();
+      //      Object entryValue = entry.getValue();
+      //      if (entryValue != null) { // Skip null values.
+      //        if (entryValue instanceof TypedOutput) {
+      //          multipartBody.addPart(entryName, transferEncoding, (TypedOutput) entryValue);
+      //        } else if (entryValue instanceof String) {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              new TypedString((String) entryValue));
+      //        } else {
+      //          multipartBody.addPart(entryName, transferEncoding,
+      //              converter.toBody(entryValue, entryValue.getClass()));
+      //        }
+      //      }
+      //    }
+      //  }
       } else if (annotationType == Body.class) {
         if (value == null) {
           throw new IllegalArgumentException("Body parameter value must not be null.");
         }
-        if (value instanceof TypedOutput) {
-          body = (TypedOutput) value;
+        if (value instanceof RequestBody) {
+          body = (RequestBody) value;
         } else {
           body = converter.toBody(value, value.getClass());
         }
@@ -363,9 +338,9 @@ void setArguments(Object[] args) {
   }
 
   Request build() {
-    if (multipartBody != null && multipartBody.getPartCount() == 0) {
-      throw new IllegalStateException("Multipart requests must contain at least one part.");
-    }
+    //if (multipartBody != null && multipartBody.getPartCount() == 0) {
+    //  throw new IllegalStateException("Multipart requests must contain at least one part.");
+    //}
 
     String apiUrl = this.apiUrl;
     StringBuilder url = new StringBuilder(apiUrl);
@@ -381,11 +356,11 @@ Request build() {
       url.append(queryParams);
     }
 
-    TypedOutput body = this.body;
+    RequestBody body = this.body;
     Headers.Builder headerBuilder = this.headers;
     if (contentTypeHeader != null) {
       if (body != null) {
-        body = new MediaTypeOverridingTypedOutput(body, contentTypeHeader);
+        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
       } else {
         if (headerBuilder == null) {
           headerBuilder = new Headers.Builder();
@@ -398,34 +373,30 @@ Request build() {
 
     return new Request.Builder()
         .url(url.toString())
-        .method(requestMethod, Utils.typedOutputToBody(body))
+        .method(requestMethod, body)
         .headers(headers)
         .build();
   }
 
-  private static class MediaTypeOverridingTypedOutput implements TypedOutput {
-    private final TypedOutput delegate;
+  private static class MediaTypeOverridingRequestBody extends RequestBody {
+    private final RequestBody delegate;
     private final MediaType mediaType;
 
-    MediaTypeOverridingTypedOutput(TypedOutput delegate, String mediaType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
       this.delegate = delegate;
       this.mediaType = MediaType.parse(mediaType);
     }
 
-    @Override public String fileName() {
-      return delegate.fileName();
-    }
-
-    @Override public MediaType mediaType() {
+    @Override public MediaType contentType() {
       return mediaType;
     }
 
-    @Override public long length() {
-      return delegate.length();
+    @Override public long contentLength() throws IOException {
+      return delegate.contentLength();
     }
 
-    @Override public void writeTo(OutputStream out) throws IOException {
-      delegate.writeTo(out);
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      delegate.writeTo(sink);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/RestAdapter.java b/retrofit/src/main/java/retrofit/RestAdapter.java
index 4261a9d84d..8ced3ef0b2 100755
--- a/retrofit/src/main/java/retrofit/RestAdapter.java
+++ b/retrofit/src/main/java/retrofit/RestAdapter.java
@@ -31,8 +31,6 @@
 import java.util.concurrent.atomic.AtomicReference;
 import retrofit.converter.Converter;
 import retrofit.http.Header;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Adapts a Java interface to a REST API.
@@ -293,8 +291,7 @@ private void handleAsyncResponseBody(Request request, Response response, Type ty
         return;
       }
 
-      TypedInput bodyInput = Utils.typedInputFromBody(body);
-      ExceptionCatchingTypedInput wrapped = new ExceptionCatchingTypedInput(bodyInput);
+      ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(body);
       try {
         Object convert = converter.fromBody(wrapped, type);
         callResponse(callback, convert, response);
diff --git a/retrofit/src/main/java/retrofit/RestMethodInfo.java b/retrofit/src/main/java/retrofit/RestMethodInfo.java
index a45749b84c..cdc45159b9 100755
--- a/retrofit/src/main/java/retrofit/RestMethodInfo.java
+++ b/retrofit/src/main/java/retrofit/RestMethodInfo.java
@@ -142,12 +142,14 @@ private void parseMethodAnnotations() {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.MULTIPART;
+        throw new UnsupportedOperationException("Multipart shall return!");
+        //requestType = RequestType.MULTIPART;
       } else if (annotationType == FormUrlEncoded.class) {
         if (requestType != RequestType.SIMPLE) {
           throw methodError("Only one encoding annotation is allowed.");
         }
-        requestType = RequestType.FORM_URL_ENCODED;
+        throw new UnsupportedOperationException("Form URL encoding shall return!");
+        //requestType = RequestType.FORM_URL_ENCODED;
       } else if (annotationType == Streaming.class) {
         if (responseObjectType != Response.class) {
           throw methodError(
diff --git a/retrofit/src/main/java/retrofit/RetrofitError.java b/retrofit/src/main/java/retrofit/RetrofitError.java
index 4e20f548c1..dfaecfe0ad 100755
--- a/retrofit/src/main/java/retrofit/RetrofitError.java
+++ b/retrofit/src/main/java/retrofit/RetrofitError.java
@@ -16,10 +16,10 @@
 package retrofit;
 
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
 import retrofit.converter.Converter;
-import retrofit.mime.TypedInput;
 
 public class RetrofitError extends RuntimeException {
   public static RetrofitError networkError(String url, IOException exception) {
@@ -117,7 +117,7 @@ public Object getBodyAs(Type type) {
     if (response == null) {
       return null;
     }
-    TypedInput body = Utils.typedInputFromBody(response.body());
+    ResponseBody body = response.body();
     if (body == null) {
       return null;
     }
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 33c7b20660..1b9f9ddb49 100755
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -17,18 +17,13 @@
 package retrofit;
 
 import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.concurrent.Executor;
 import okio.Buffer;
-import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Source;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 final class Utils {
   static <T> T checkNotNull(T object, String message, Object... args) {
@@ -79,40 +74,6 @@ static Response readBodyToBytesIfNecessary(Response response) throws IOException
     }
   }
 
-  static RequestBody typedOutputToBody(final TypedOutput body) {
-    if (body == null) return null;
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return body.mediaType();
-      }
-
-      @Override public long contentLength() throws IOException {
-        return body.length();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        body.writeTo(sink.outputStream());
-      }
-    };
-  }
-
-  static TypedInput typedInputFromBody(final ResponseBody body) {
-    if (body == null) return null;
-    return new TypedInput() {
-      @Override public MediaType mediaType() {
-        return body.contentType();
-      }
-
-      @Override public long length() {
-        return body.contentLength();
-      }
-
-      @Override public InputStream in() throws IOException {
-        return body.byteStream();
-      }
-    };
-  }
-
   static class SynchronousExecutor implements Executor {
     @Override public void execute(Runnable runnable) {
       runnable.run();
diff --git a/retrofit/src/main/java/retrofit/converter/Converter.java b/retrofit/src/main/java/retrofit/converter/Converter.java
index f038978edf..8c93f9934c 100755
--- a/retrofit/src/main/java/retrofit/converter/Converter.java
+++ b/retrofit/src/main/java/retrofit/converter/Converter.java
@@ -15,10 +15,10 @@
  */
 package retrofit.converter;
 
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * Arbiter for converting objects to and from their representation in HTTP.
@@ -31,7 +31,7 @@
    * @param type Target object type.
    * @return Instance of {@code type} which will be cast by the caller.
    */
-  Object fromBody(TypedInput body, Type type) throws IOException;
+  Object fromBody(ResponseBody body, Type type) throws IOException;
 
   /**
    * Convert an object to an appropriate representation for HTTP transport.
@@ -39,5 +39,5 @@
    * @param object Object instance to convert.
    * @return Representation of the specified object as bytes.
    */
-  TypedOutput toBody(Object object, Type type);
+  RequestBody toBody(Object object, Type type);
 }
diff --git a/retrofit/src/main/java/retrofit/converter/GsonConverter.java b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
index cc2dc2a1fb..746194dca2 100755
--- a/retrofit/src/main/java/retrofit/converter/GsonConverter.java
+++ b/retrofit/src/main/java/retrofit/converter/GsonConverter.java
@@ -17,13 +17,13 @@
 
 import com.google.gson.Gson;
 import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.OutputStream;
 import java.lang.reflect.Type;
 import java.nio.charset.Charset;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedOutput;
 
 /**
  * A {@link Converter} which uses GSON for serialization and deserialization of entities.
@@ -31,6 +31,7 @@
 public class GsonConverter implements Converter {
   private final Gson gson;
   private final Charset charset;
+  private final MediaType mediaType;
 
   /**
    * Create an instance using a default {@link Gson} instance for conversion. Encoding to JSON and
@@ -55,55 +56,28 @@ public GsonConverter(Gson gson) {
   public GsonConverter(Gson gson, Charset charset) {
     this.gson = gson;
     this.charset = charset;
+    this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
   }
 
-  @Override public Object fromBody(TypedInput body, Type type) throws IOException {
+  @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     Charset charset = this.charset;
-    if (body.mediaType() != null) {
-      charset = body.mediaType().charset(charset);
+    if (body.contentType() != null) {
+      charset = body.contentType().charset(charset);
     }
-    InputStreamReader isr = null;
+
+    InputStream is = body.byteStream();
     try {
-      isr = new InputStreamReader(body.in(), charset);
-      return gson.fromJson(isr, type);
+      return gson.fromJson(new InputStreamReader(is, charset), type);
     } finally {
-      if (isr != null) {
-        try {
-          isr.close();
-        } catch (IOException ignored) {
-        }
+      try {
+        is.close();
+      } catch (IOException ignored) {
       }
     }
   }
 
-  @Override public TypedOutput toBody(Object object, Type type) {
+  @Override public RequestBody toBody(Object object, Type type) {
     String json = gson.toJson(object, type);
-    return new JsonTypedOutput(json.getBytes(charset), charset);
-  }
-
-  private static class JsonTypedOutput implements TypedOutput {
-    private final byte[] jsonBytes;
-    private final MediaType mediaType;
-
-    JsonTypedOutput(byte[] jsonBytes, Charset charset) {
-      this.jsonBytes = jsonBytes;
-      this.mediaType = MediaType.parse("application/json; charset=" + charset.name());
-    }
-
-    @Override public String fileName() {
-      return null;
-    }
-
-    @Override public MediaType mediaType() {
-      return mediaType;
-    }
-
-    @Override public long length() {
-      return jsonBytes.length;
-    }
-
-    @Override public void writeTo(OutputStream out) throws IOException {
-      out.write(jsonBytes);
-    }
+    return RequestBody.create(mediaType, json);
   }
 }
diff --git a/retrofit/src/main/java/retrofit/http/Part.java b/retrofit/src/main/java/retrofit/http/Part.java
index 2e7de11663..e4f26800c8 100755
--- a/retrofit/src/main/java/retrofit/http/Part.java
+++ b/retrofit/src/main/java/retrofit/http/Part.java
@@ -21,7 +21,6 @@
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static retrofit.mime.MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING;
 
 /**
  * Denotes a single part of a multi-part request.
@@ -55,5 +54,5 @@
 public @interface Part {
   String value();
   /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default DEFAULT_TRANSFER_ENCODING;
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/main/java/retrofit/http/PartMap.java b/retrofit/src/main/java/retrofit/http/PartMap.java
index d8fb9942b0..83aaebb827 100755
--- a/retrofit/src/main/java/retrofit/http/PartMap.java
+++ b/retrofit/src/main/java/retrofit/http/PartMap.java
@@ -21,7 +21,6 @@
 
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static retrofit.mime.MultipartTypedOutput.DEFAULT_TRANSFER_ENCODING;
 
 /**
  * Denotes name and value parts of a multi-part request
@@ -51,5 +50,5 @@
 @Retention(RUNTIME)
 public @interface PartMap {
   /** The {@code Content-Transfer-Encoding} of this part. */
-  String encoding() default DEFAULT_TRANSFER_ENCODING;
+  String encoding() default "binary";
 }
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index e983fe4e69..bd74aff236 100755
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -2,6 +2,7 @@
 package retrofit;
 
 import com.google.gson.Gson;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
@@ -23,11 +24,10 @@
 import retrofit.http.DELETE;
 import retrofit.http.Field;
 import retrofit.http.FieldMap;
-import retrofit.http.FormUrlEncoded;
 import retrofit.http.GET;
 import retrofit.http.HEAD;
+import retrofit.http.Header;
 import retrofit.http.Headers;
-import retrofit.http.Multipart;
 import retrofit.http.PATCH;
 import retrofit.http.POST;
 import retrofit.http.PUT;
@@ -38,8 +38,6 @@
 import retrofit.http.QueryMap;
 import retrofit.http.RestMethod;
 import retrofit.http.Streaming;
-import retrofit.mime.TypedInput;
-import retrofit.mime.TypedString;
 import rx.Observable;
 
 import static java.lang.annotation.ElementType.METHOD;
@@ -104,50 +102,51 @@ Response method() {
   @Test public void custom2Method() {
     class Example {
       @CUSTOM2("/foo") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
 
-    Request request = buildRequest(Example.class, new TypedString("hi"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("CUSTOM2");
     assertThat(request.urlString()).isEqualTo("http://example.com/foo");
     assertBody(request.body(), "hi");
   }
 
-  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {
-    class Example {
-      @Multipart //
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-    }
-  }
-
-  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
-    class Example {
-      @FormUrlEncoded //
-      @Multipart //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
-    }
-  }
+  //@Test public void onlyOneEncodingIsAllowedMultipartFirst() {
+  //  class Example {
+  //    @Multipart //
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
+  //
+  //@Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
+  //  }
+  //}
 
   @Test public void invalidPathParam() throws Exception {
     class Example {
@@ -380,38 +379,38 @@ Response method(@PartMap Map<String, String> params) {
     }
   }
 
-  @Test public void multipartFailsOnNonBodyMethod() {
-    class Example {
-      @Multipart //
-      @GET("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void multipartFailsWithNoParts() {
-    class Example {
-      @Multipart //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
-    }
-  }
+  //@Test public void multipartFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @Multipart //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void multipartFailsWithNoParts() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
+  //  }
+  //}
 
   @Test public void implicitFormEncodingByFieldForbidden() {
     class Example {
@@ -445,38 +444,38 @@ Response method(@FieldMap Map<String, String> a) {
     }
   }
 
-  @Test public void formEncodingFailsOnNonBodyMethod() {
-    class Example {
-      @FormUrlEncoded //
-      @GET("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
-    }
-  }
-
-  @Test public void formEncodingFailsWithNoParts() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method() {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
-    }
-  }
+  //@Test public void formEncodingFailsOnNonBodyMethod() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @GET("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
+  //  }
+  //}
+  //
+  //@Test public void formEncodingFailsWithNoParts() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method() {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
+  //  }
+  //}
 
   @Test public void headersFailWhenEmptyOnMethod() {
     class Example {
@@ -607,22 +606,22 @@ Response method(@Body int o1, @Body int o2) {
     }
   }
 
-  @Test public void bodyInNonBodyRequest() {
-    class Example {
-      @Multipart //
-      @PUT("/") //
-      Response method(@Part("one") int o1, @Body int o2) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
-    }
-  }
+  //@Test public void bodyInNonBodyRequest() {
+  //  class Example {
+  //    @Multipart //
+  //    @PUT("/") //
+  //    Response method(@Part("one") int o1, @Body int o2) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage(
+  //        "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
+  //  }
+  //}
 
   @Test public void get() {
     class Example {
@@ -669,11 +668,12 @@ Response method() {
   @Test public void post() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
@@ -683,11 +683,12 @@ Response method(@Body TypedInput body) {
   @Test public void put() {
     class Example {
       @PUT("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PUT");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
@@ -697,11 +698,12 @@ Response method(@Body TypedInput body) {
   @Test public void patch() {
     class Example {
       @PATCH("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("PATCH");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
@@ -1214,11 +1216,12 @@ Response method(@Body Object body) {
   @Test public void bodyTypedInput() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("hi"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.method()).isEqualTo("POST");
     assertThat(request.headers().size()).isZero();
     assertThat(request.urlString()).isEqualTo("http://example.com/foo/bar/");
@@ -1228,7 +1231,7 @@ Response method(@Body TypedInput body) {
   @Test public void bodyRequired() {
     class Example {
       @POST("/foo/bar/") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
@@ -1379,27 +1382,27 @@ Response method(@Path("ping") String ping, @Body Object body, @Path("kit") Strin
   //      .contains("Content-Transfer-Encoding: 8-bit")
   //      .endsWith("\r\nkat");
   //}
-
-  @Test public void multipartPartMapRejectsNullKeys() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@PartMap Map<String, Object> parts) {
-        return null;
-      }
-    }
-
-    Map<String, Object> params = new LinkedHashMap<String, Object>();
-    params.put("ping", "pong");
-    params.put(null, "kat");
-
-    try {
-      buildRequest(Example.class, params);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 part map contained null key.");
-    }
-  }
+  //
+  //@Test public void multipartPartMapRejectsNullKeys() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@PartMap Map<String, Object> parts) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> params = new LinkedHashMap<String, Object>();
+  //  params.put("ping", "pong");
+  //  params.put(null, "kat");
+  //
+  //  try {
+  //    buildRequest(Example.class, params);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 part map contained null key.");
+  //  }
+  //}
   //
   //@Test public void multipartNullRemovesPart() {
   //  class Example {
@@ -1423,203 +1426,203 @@ Response method(@PartMap Map<String, Object> parts) {
   //  String one = new String(iterator.next(), UTF_8);
   //  assertThat(one).contains("name=\"ping\"").endsWith("\r\npong");
   //}
-
-  @Test public void multipartPartOptional() {
-    class Example {
-      @Multipart //
-      @POST("/foo/bar/") //
-      Response method(@Part("ping") TypedInput ping) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class, new Object[] { null });
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
-    }
-  }
-
-  @Test public void simpleFormEncoded() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") String foo, @Field("ping") String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", "pong");
-    assertBody(request.body(), "foo=bar&ping=pong");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field(value = "na+me", encodeName = false) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba r");
-    assertBody(request.body(), "na+me=ba+r");
-  }
-
-  @Test public void formEncodedWithEncodedValueFieldParam() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field(value = "na me", encodeValue = false) String foo) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "ba+r");
-    assertBody(request.body(), "na+me=ba+r");
-  }
-
-  @Test public void formEncodedFieldOptional() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") String foo, @Field("ping") String ping,
-          @Field("kit") String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "bar", null, "kat");
-    assertBody(request.body(), "foo=bar&kit=kat");
-  }
-
-  @Test public void formEncodedFieldList() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedFieldArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three" };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
-  }
-
-  @Test public void formEncodedFieldPrimitiveArray() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3 };
-    Request request = buildRequest(Example.class, values, "kat");
-    assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
-  }
-
-  @Test public void formEncodedWithEncodedNameFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("k+it", "k at");
-    fieldMap.put("pin+g", "po ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  }
-
-  @Test public void formEncodedWithEncodedValueFieldParamMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("k it", "k+at");
-    fieldMap.put("pin g", "po+ng");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
-  }
-
-  @Test public void formEncodedFieldMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/foo") //
-      Response method(@FieldMap Map<String, Object> fieldMap) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-    fieldMap.put("ping", "pong");
-
-    Request request = buildRequest(Example.class, fieldMap);
-    assertBody(request.body(), "kit=kat&ping=pong");
-  }
-
-  @Test public void fieldMapRejectsNullKeys() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method(@FieldMap Map<String, Object> a) {
-        return null;
-      }
-    }
-
-    Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
-    fieldMap.put("kit", "kat");
-    fieldMap.put("foo", null);
-    fieldMap.put(null, "pong");
-
-    try {
-      buildRequest(Example.class, fieldMap);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Parameter #1 field map contained null key.");
-    }
-  }
-
-  @Test public void fieldMapMustBeAMap() {
-    class Example {
-      @FormUrlEncoded //
-      @POST("/") //
-      Response method(@FieldMap List<String> a) {
-        return null;
-      }
-    }
-    try {
-      buildRequest(Example.class);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
-    }
-  }
+  //
+  //@Test public void multipartPartOptional() {
+  //  class Example {
+  //    @Multipart //
+  //    @POST("/foo/bar/") //
+  //    Response method(@Part("ping") RequestBody ping) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class, new Object[] { null });
+  //    fail();
+  //  } catch (IllegalStateException e) {
+  //    assertThat(e.getMessage()).isEqualTo("Multipart requests must contain at least one part.");
+  //  }
+  //}
+  //
+  //@Test public void simpleFormEncoded() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", "pong");
+  //  assertBody(request.body(), "foo=bar&ping=pong");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na+me", encodeName = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParam() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field(value = "na me", encodeValue = false) String foo) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "ba+r");
+  //  assertBody(request.body(), "na+me=ba+r");
+  //}
+  //
+  //@Test public void formEncodedFieldOptional() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") String foo, @Field("ping") String ping,
+  //        @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //  Request request = buildRequest(Example.class, "bar", null, "kat");
+  //  assertBody(request.body(), "foo=bar&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldList() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") List<Object> fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  List<Object> values = Arrays.<Object>asList("foo", "bar", null, 3);
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=foo&foo=bar&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") Object[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Object[] values = { 1, 2, null, "three" };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=three&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedFieldPrimitiveArray() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@Field("foo") int[] fields, @Field("kit") String kit) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  int[] values = { 1, 2, 3 };
+  //  Request request = buildRequest(Example.class, values, "kat");
+  //  assertBody(request.body(), "foo=1&foo=2&foo=3&kit=kat");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedNameFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeNames = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k+it", "k at");
+  //  fieldMap.put("pin+g", "po ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedWithEncodedValueFieldParamMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap(encodeValues = false) Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("k it", "k+at");
+  //  fieldMap.put("pin g", "po+ng");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "k+it=k+at&pin+g=po+ng");
+  //}
+  //
+  //@Test public void formEncodedFieldMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/foo") //
+  //    Response method(@FieldMap Map<String, Object> fieldMap) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put("ping", "pong");
+  //
+  //  Request request = buildRequest(Example.class, fieldMap);
+  //  assertBody(request.body(), "kit=kat&ping=pong");
+  //}
+  //
+  //@Test public void fieldMapRejectsNullKeys() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap Map<String, Object> a) {
+  //      return null;
+  //    }
+  //  }
+  //
+  //  Map<String, Object> fieldMap = new LinkedHashMap<String, Object>();
+  //  fieldMap.put("kit", "kat");
+  //  fieldMap.put("foo", null);
+  //  fieldMap.put(null, "pong");
+  //
+  //  try {
+  //    buildRequest(Example.class, fieldMap);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Parameter #1 field map contained null key.");
+  //  }
+  //}
+  //
+  //@Test public void fieldMapMustBeAMap() {
+  //  class Example {
+  //    @FormUrlEncoded //
+  //    @POST("/") //
+  //    Response method(@FieldMap List<String> a) {
+  //      return null;
+  //    }
+  //  }
+  //  try {
+  //    buildRequest(Example.class);
+  //    fail();
+  //  } catch (IllegalArgumentException e) {
+  //    assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
+  //  }
+  //}
 
   @Test public void simpleHeaders() {
     class Example {
@@ -1692,7 +1695,7 @@ Response method() {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@retrofit.http.Header("fizz") String fizz) {
+      Response method(@Header("fizz") String fizz) {
         return null;
       }
     }
@@ -1715,7 +1718,7 @@ Response method(@retrofit.http.Header("fizz") String fizz) {
   @Test public void headerParamToString() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("kit") BigInteger kit) {
+      Response method(@Header("kit") BigInteger kit) {
         return null;
       }
     }
@@ -1732,7 +1735,7 @@ Response method(@retrofit.http.Header("kit") BigInteger kit) {
     class Example {
       @GET("/foo/bar/") //
       @Headers("ping: pong") //
-      Response method(@retrofit.http.Header("kit") String kit) {
+      Response method(@Header("kit") String kit) {
         return null;
       }
     }
@@ -1749,7 +1752,7 @@ Response method(@retrofit.http.Header("kit") String kit) {
   @Test public void headerParamList() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("foo") List<String> kit) {
+      Response method(@Header("foo") List<String> kit) {
         return null;
       }
     }
@@ -1765,7 +1768,7 @@ Response method(@retrofit.http.Header("foo") List<String> kit) {
   @Test public void headerParamArray() {
     class Example {
       @GET("/foo/bar/") //
-      Response method(@retrofit.http.Header("foo") String[] kit) {
+      Response method(@Header("foo") String[] kit) {
         return null;
       }
     }
@@ -1782,11 +1785,12 @@ Response method(@retrofit.http.Header("foo") String[] kit) {
     class Example {
       @POST("/") //
       @Headers("Content-Type: text/not-plain") //
-      Response method(@Body TypedInput body) {
+      Response method(@Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, new TypedString("Plain"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "hi");
+    Request request = buildRequest(Example.class, body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
@@ -1821,12 +1825,12 @@ Response method() {
   @Test public void contentTypeParameterHeaderOverrides() {
     class Example {
       @POST("/") //
-      Response method(@retrofit.http.Header("Content-Type") String contentType,
-          @Body TypedInput body) {
+      Response method(@Header("Content-Type") String contentType, @Body RequestBody body) {
         return null;
       }
     }
-    Request request = buildRequest(Example.class, "text/not-plain", new TypedString("Plain"));
+    RequestBody body = RequestBody.create(MediaType.parse("text/plain"), "Plain");
+    Request request = buildRequest(Example.class, "text/not-plain", body);
     assertThat(request.body().contentType().toString()).isEqualTo("text/not-plain");
   }
 
diff --git a/retrofit/src/test/java/retrofit/TestingUtils.java b/retrofit/src/test/java/retrofit/TestingUtils.java
index 2ad42be65d..cc65e72f62 100755
--- a/retrofit/src/test/java/retrofit/TestingUtils.java
+++ b/retrofit/src/test/java/retrofit/TestingUtils.java
@@ -1,14 +1,7 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
-import java.io.IOException;
 import java.lang.reflect.Method;
-import java.util.Map;
-import retrofit.mime.MimeHelper;
-import retrofit.mime.MultipartTypedOutput;
-import retrofit.mime.TypedOutput;
-
-import static org.assertj.core.api.Assertions.assertThat;
 
 public final class TestingUtils {
   public static Method onlyMethod(Class c) {
@@ -18,16 +11,4 @@ public static Method onlyMethod(Class c) {
     }
     throw new IllegalArgumentException("More than one method declared.");
   }
-
-  public static TypedOutput createMultipart(Map<String, TypedOutput> parts) {
-    MultipartTypedOutput typedOutput = MimeHelper.newMultipart("foobarbaz");
-    for (Map.Entry<String, TypedOutput> part : parts.entrySet()) {
-      typedOutput.addPart(part.getKey(), part.getValue());
-    }
-    return typedOutput;
-  }
-
-  public static void assertBytes(byte[] bytes, String expected) throws IOException {
-    assertThat(new String(bytes, "UTF-8")).isEqualTo(expected);
-  }
 }
diff --git a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
index 9a81b13e50..98c10c93b7 100755
--- a/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
+++ b/retrofit/src/test/java/retrofit/converter/GsonConverterTest.java
@@ -7,14 +7,17 @@
 import com.google.gson.JsonObject;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import java.io.ByteArrayOutputStream;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Before;
 import org.junit.Test;
-import retrofit.mime.TypedOutput;
-import retrofit.mime.TypedString;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 
 public final class GsonConverterTest {
@@ -51,25 +54,25 @@
   }
 
   @Test public void serialization() throws IOException {
-    TypedOutput output = converter.toBody(new Impl("value"), Impl.class);
-    assertJson("{\"theName\":\"value\"}", output);
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
   }
 
   @Test public void serializationTypeUsed() throws IOException {
-    TypedOutput output = converter.toBody(new Impl("value"), Example.class);
-    assertJson("{\"name\":\"value\"}", output);
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
   }
 
   @Test public void deserialization() throws IOException {
-    TypedString json = new TypedString("{\"theName\":\"value\"}");
-    Impl impl = (Impl) converter.fromBody(json, Impl.class);
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
     assertEquals("value", impl.getName());
   }
 
-  private void assertJson(String expected, TypedOutput output) throws IOException {
-    ByteArrayOutputStream baos = new ByteArrayOutputStream();
-    output.writeTo(baos);
-    String json = new String(baos.toByteArray(), "UTF-8");
-    assertEquals(expected, json);
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 }
