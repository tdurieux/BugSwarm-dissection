diff --git a/CHANGELOG b/CHANGELOG
index a626017d7..582d81993 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,6 +1,14 @@
 RELEASE NOTES
 -------------
-Release Name: v2.2.4 build 1519abc0ae2b from v2.2 branch
+Release Name: v2.x build XXXXXXXXXXXX from master branch
+
+Bug fixes:
+ - XXXX
+
+Enhancements:
+ - XXXX
+
+From Release: v2.2.4 build 1519abc0ae2b from v2.2 branch
 
 Bug fixes:
  - Fix module with optional connected port having the wrong size
diff --git a/dev-requirements.txt b/dev-requirements.txt
index 9a4311b5b..fa6f9aadc 100644
--- a/dev-requirements.txt
+++ b/dev-requirements.txt
@@ -1,3 +1,4 @@
+autopep8
 backports.ssl_match_hostname
 certifi
 docutils
diff --git a/doc/internal/Makefile b/doc/internal/Makefile
new file mode 100644
index 000000000..5ac85a7b1
--- /dev/null
+++ b/doc/internal/Makefile
@@ -0,0 +1,192 @@
+# Makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = _build
+
+# User-friendly check for sphinx-build
+ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
+$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
+endif
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+# the i18n builder cannot share the environment and doctrees with the others
+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest coverage gettext
+
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  applehelp  to make an Apple Help Book"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  texinfo    to make Texinfo files"
+	@echo "  info       to make Texinfo files and run them through makeinfo"
+	@echo "  gettext    to make PO message catalogs"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  xml        to make Docutils-native XML files"
+	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
+	@echo "  coverage   to run coverage check of the documentation (if enabled)"
+
+clean:
+	rm -rf $(BUILDDIR)/*
+
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/VisTrails.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/VisTrails.qhc"
+
+applehelp:
+	$(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
+	@echo
+	@echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
+	@echo "N.B. You won't be able to view it unless you put it in" \
+	      "~/Library/Documentation/Help or install it in your application" \
+	      "bundle."
+
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/VisTrails"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/VisTrails"
+	@echo "# devhelp"
+
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+latexpdfja:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through platex and dvipdfmx..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+texinfo:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo
+	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
+	@echo "Run \`make' in that directory to run these through makeinfo" \
+	      "(use \`make info' here to do that automatically)."
+
+info:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo "Running Texinfo files through makeinfo..."
+	make -C $(BUILDDIR)/texinfo info
+	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
+
+gettext:
+	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
+	@echo
+	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
+
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
+
+coverage:
+	$(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
+	@echo "Testing of coverage in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/coverage/python.txt."
+
+xml:
+	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
+	@echo
+	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."
+
+pseudoxml:
+	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
+	@echo
+	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
diff --git a/doc/internal/_static/custom.css b/doc/internal/_static/custom.css
new file mode 100644
index 000000000..fe4c2c5a0
--- /dev/null
+++ b/doc/internal/_static/custom.css
@@ -0,0 +1,6 @@
+@import url("classic.css");
+
+div.admonition-todo {
+    background-color: #eee;
+    border: 1px solid #ccc;
+}
diff --git a/doc/internal/architecture.rst b/doc/internal/architecture.rst
new file mode 100644
index 000000000..7d8660730
--- /dev/null
+++ b/doc/internal/architecture.rst
@@ -0,0 +1,118 @@
+Project architecture and concepts
+*********************************
+
+VisTrails is made of multiple components. This page gives a high-level overview of what they are, and links to relevant pages of the documentation.
+
+..  _concept-database:
+
+Database
+--------
+
+The database layer is responsible for reading and writing objects to the disk. It is composed of the :mod:`vistrails.core.db` and :mod:`vistrails.db` packages.
+
+The currect objects and their relationships are described in a schema, from which the system generates Python classes and code to load or save them from either XML files (with ElementTree) or an SQL database (with MySQLdb, soon to be replaced with SQLAlchemy). There is one set of specs, DB classes and loading/saving routines for each version of the schema (e.g. :mod:`vistrails.db.versions.v1_0_3`), along with code to translate from one version to the other.
+
+Note that a ``.vt`` file is just a ZIP file that contains the XML vistrail and provenance log (along with optional data, such as subworkflows, version thumbnails, ...).
+
+Objects loaded from the database eventually gets converted to core classes by assigning their ``__class__`` attribute, at which point they gain all the methods defined there.
+
+..  _concept-registry:
+
+Module registry
+---------------
+
+The :class:`~vistrails.core.modules.module_registry.ModuleRegistry` contains the list of all the modules currently available, in the form of :class:`~vistrails.core.modules.module_descriptor.ModuleDescriptor` objects. These contain the module identifier, name and namespace of the module, the input and output ports, the parent module if any, and also optional things like the constant widget and configuration widget class (see :ref:`widgets`) and fringe shape for the pipeline view. They also have a direct reference to the :class:`~vistrails.core.modules.vistrails_module.Module` subclass in the defining package that the interpreter will instanciate for execution (see :ref:`concept-interpreter`).
+
+The module registry also sends some signals when modules get added or removed, which are used to update the module palette in the UI.
+
+..  todo::
+
+    Possible future directions: allow packages to provide a list of packages (for the palette), but to provide modules lazily. This would make packages that dynamically generate modules a lot faster, because they would only need to generate all the modules upfront (or at all).
+
+    :issue:`1117`
+
+..  _concept-packagemngr:
+
+Package manager
+---------------
+
+The :class:`~vistrails.core.packagemanager.PackageManager` contains the list of available and enabled packages. Available packages are obtained by listing the ``vistrails/packages`` and ``.vistrails/userpackages`` directories. It handles dependencies between packages, and uses an :func:`__import__` override to discover the Python modules imported by each package; this is used to reload them automatically when the packages that imported them is reloaded.
+
+..  todo::
+
+    The __import__ override is a bit insane and it might be worth disabling it completely, and simply reloading packages under the package's codepath when "reload" is clicked.
+
+    If this is kept, it should be fixed to use an actual full graph at the package manager level, since multiple packages might depend on the same library and the current logic will fail to see that.
+
+    :issue:`959`
+
+..  _concept-application:
+
+Application
+-----------
+
+The application logic is contained in two application classes: :class:`~vistrails.core.application.VistrailsCoreApplication`, used in non-graphical mode, for example through the :ref:`concept-api`, and :class:`vistrails.gui.application.VistrailsApplicationSingleton` which is a :class:`QtGui.QApplication`.
+
+The application handles startup and configuration, notification delivery, output modes (see :ref:`output_modules`), jobs (see :ref:`jobs`), logging, and loading and saving vistrails (creating controllers from the database objects, or handing them out to the database layer).
+
+The graphical application handles the single-instance mode (communicating with the main instance over shared memory, if a second one is opened) and setting the default application with the OS.
+
+..  _concept-packages:
+
+Packages and modules
+--------------------
+
+Packages are the name of the plugins in VisTrails that provide modules. Each package usually wraps a library or provide related functionalities. They are loaded by the package manager and are wrapped by :class:`vistrails.core.modules.package.Package`.
+
+A VisTrails Package is a Python module or package in a location where the package manager will find it (either ``vistrails/packages`` or ``.vistrails/userpackages``). See :ref:`packages`.
+
+..  _concept-interpreter:
+
+The interpreter
+---------------
+
+The interpreter takes a :class:`~vistrails.core.vistrail.pipeline.Pipeline` and executes it, by creating the :class:`~vistrails.core.modules.vistrails_module.Module` objects defined by packages from the pipeline :class:`~vistrails.core.vistrail.module.Module` and connecting them. Currently, the execution strategy is very simple: the sink modules's update() methods are called by the interpreter, and they recursively call their upstream's update() methods before doing their compute() logic.
+
+Instanciated modules are also kept in a global cache, the *persistent pipeline*, keyed on their subpipeline signature (a hash computed recursively for a module and its upstream).
+
+..  todo::
+
+    This strategy is very limited as it is completely local. It makes it difficult to add "smart" logic to get us towards better caching, parallel execution, ... We are considering rewriting the interpreter and building into it the looping/streaming, group and parallel execution code, using the opportunity to improve caching, persistence and job submission.
+
+..  _concept-controller:
+
+Vistrail and VistrailController
+-------------------------------
+
+:class:`~vistrails.core.vistrail.vistrail.Vistrail` represents a full tree of pipeline versions. It is a project in the VisTrails application. There are no pipeline descriptions in a Vistrail, only actions which add/remove modules and connections from an empty pipeline (and annotations).
+
+a Vistrail is wrapped in :class:`~vistrails.core.vistrail.controller.VistrailController` (or the GUI version: :class:`~vistrails.gui.vistrail_controller.VistrailController`) that provide all the pipeline manipulation logic. It has a notion of current pipeline which is efficiently changed by actions when moving around the version tree, and provides methods to create such actions. It also handles upgrading versions when needed (see :ref:`upgrades`) and interactions with subworkflows.
+
+..  _concept-ui:
+
+User interface
+--------------
+
+The user interface lives in :mod:`vistrails.gui`. It is based on PyQt4 and allows the user to display and manipulate versions and pipelines through a VistrailController.
+
+In graphical mode, most visualizations end up in the spreadsheet, which is implemented as a package.
+
+..  _concept-log:
+
+Provenance log
+--------------
+
+When a pipeline is executed, structured information from each module is appended to an XML file called the provenance log. Each module gets its own entry, with information such as time, status (executed, up to date in the cache, exception info), plus "annotations" from modules.
+
+..  todo::
+
+    This provenance information should be made available to modules so they can reuse a past context exactly.
+
+    :issue:`548`
+
+..  _concept-api:
+
+High-level API
+--------------
+
+A high-level API, directly importable under :mod:`vistrails`, makes it possible to use VisTrails workflows from scripts or other applications. It automatically builds an application when first used, provides easy-to-use wrappers for VistrailController and friends, and integration with the IPython notebook. See :mod:`vistrails.core.api`.
diff --git a/doc/internal/conf.py b/doc/internal/conf.py
new file mode 100644
index 000000000..a5df031f1
--- /dev/null
+++ b/doc/internal/conf.py
@@ -0,0 +1,301 @@
+# -*- coding: utf-8 -*-
+#
+# VisTrails documentation build configuration file, created by
+# sphinx-quickstart on Tue Aug  4 14:43:21 2015.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys
+import os
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+sys.path.insert(0, os.path.abspath('../..'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.intersphinx',
+    'sphinx.ext.todo',
+    'sphinx.ext.coverage',
+    'sphinx.ext.ifconfig',
+    'sphinx_issues',
+]
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+# source_suffix = ['.rst', '.md']
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'VisTrails'
+copyright = u'2015, New York University'
+author = u'New York University'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = '2.2'
+# The full version, including alpha/beta/rc tags.
+release = '2.2.2'
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+highlight_language = 'Python'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = True
+
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'classic'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+html_style = 'custom.css'
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'
+#html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# Now only 'ja' uses this config value
+#html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+#html_search_scorer = 'scorer.js'
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'VisTrailsdoc'
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+
+# Latex figure (float) alignment
+#'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+  (master_doc, 'VisTrails.tex', u'VisTrails Documentation',
+   author, 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'vistrails', u'VisTrails Documentation',
+     [author], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  (master_doc, 'VisTrails', u'VisTrails Documentation',
+   author, 'VisTrails', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
+
+
+# Example configuration for intersphinx: refer to the Python standard library.
+intersphinx_mapping = {'https://docs.python.org/': None}
+
+# sphinx-issues link
+issues_uri = 'https://github.com/VisTrails/VisTrails/issues/{issue}'
diff --git a/doc/internal/configuration.rst b/doc/internal/configuration.rst
new file mode 100644
index 000000000..b4f7e94b2
--- /dev/null
+++ b/doc/internal/configuration.rst
@@ -0,0 +1,7 @@
+..  _configuration:
+
+Configuration and Startup
+*************************
+
+..  autoclass:: vistrails.core.configuration.ConfigurationObject
+    :members:
diff --git a/doc/internal/index.rst b/doc/internal/index.rst
new file mode 100644
index 000000000..be80e0529
--- /dev/null
+++ b/doc/internal/index.rst
@@ -0,0 +1,38 @@
+VisTrails documentation
+***********************
+
+Welcome to VisTrails' documentation!
+
+VisTrails is an open-source scientific workflow and provenance management system written in Python, that supports data exploration and visualization.
+
+This document is meant to be the internal documentation of the project, giving pointers on how the code is organized and the main design concepts. If you are a user, check out the users' guide distributed with your version of VisTrails instead (or `here <http://www.vistrails.org/usersguide/dev/html/>`__).
+
+Contents
+--------
+
+..  toctree::
+    :maxdepth: 2
+
+    architecture
+    packages
+    registry
+    widgets
+    configuration
+    interpreter
+    output_modules
+    upgrades
+    jobs
+
+Links
+-----
+
+* `Project homepage <http://www.vistrails.org/>`__
+* `GitHub repository <https://github.com/VisTrails/VisTrails>`__
+* `Users' guide <http://www.vistrails.org/usersguide/dev/html/>`__
+
+Indices and tables
+------------------
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
diff --git a/doc/internal/interpreter.rst b/doc/internal/interpreter.rst
new file mode 100644
index 000000000..9e4c998d9
--- /dev/null
+++ b/doc/internal/interpreter.rst
@@ -0,0 +1,4 @@
+..  _interpreter:
+
+Pipeline Execution and the Interpreter
+**************************************
diff --git a/doc/internal/jobs.rst b/doc/internal/jobs.rst
new file mode 100644
index 000000000..1812c0072
--- /dev/null
+++ b/doc/internal/jobs.rst
@@ -0,0 +1,50 @@
+..  _jobs:
+
+Job submission
+**************
+
+Job submission is a method for executing external jobs asynchronously and in parallel. The execution engine in VisTrails is currently sequential, but multiple modules can execute in parallel by signaling that the results will be available later; this is done by throwing :class:`~vistrails.core.modules.vistrails_module.ModuleSuspended`, with enough info for VisTrails to retrieve the result later. The job can then continue executing in the background, and VisTrails can resume the workflow execution once the long-running jobs have finished.
+
+When a module suspends, the interpreter will continue to execute other branches until only suspended modules are left. At this point the execution stops, but can be resumed later.
+
+The Job Monitor
+---------------
+
+The interpreter records all suspended modules in the :class:`~vistrails.core.vistrail.job.JobMonitor`. The Job Monitor keeps track of all running jobs (with their module-supplied handle) and completed jobs and stores this information with the vistrail. It can check for completion of jobs using the handles.
+
+An improvement to just raising :class:`~vistrails.core.modules.vistrails_module.ModuleSuspended` is to use the JobMonitor directly. This lets you access the job state and do things like: check if the job is running (:meth:`~vistrails.core.vistrail.job.JobMonitor.getJob`), if not start the job (:meth:`~vistrails.core.vistrail.job.JobMonitor.addJob`), ask if the user wants to wait for the job to complete or suspend (JobMonitor.checkJob), check if job has completed and get results (:meth:`~vistrails.core.vistrail.job.JobMonitor.getCache`).
+
+Creating jobs with JobMixin
+---------------------------
+
+:class:`~vistrails.core.vistrail.job.JobMixin` is a helper mixin class that handles the job logic while providing you with template methods where the functionality for specific jobs should be implemented. Its main advantage is that it will not execute the upstream of already running jobs, and provides the basic framework for easily re-using the already started or completed job. This is usually the best way to implement jobs.
+
+The Job Monitor GUI
+-------------------
+
+When executing a workflow with jobs in the VisTrails GUI, running and completed jobs will be shown in the Job Monitor GUI (:class:`~vistrails.gui.job_monitor.QJobView`). It contains a tree with vistrails/workflows/jobs. The jobs are put in a logical order using module names and submodule order (if jobs are part of groups or list executions). From here jobs can be deleted or force-checked.
+
+Automatic job execution
+-----------------------
+
+Jobs can be executed in two modes, which can be toggled in the Job Monitor GUI. Either automatically: jobs will be suspended, polled, and resumed automatically without human intervention; or manually: the user will be asked before suspending workflow execution, and asked again to resume when jobs have finished. The user can then decide to run everything automatically or decide to resume the workflow execution at a later time.
+
+Job Polling
+-----------
+
+The job monitor will check jobs at a specified interval that can be set in the Job Monitor GUI. This is done by a handle class provided by either :class:`~vistrails.core.modules.vistrails_module.ModuleSuspended` or :class:`~vistrails.core.vistrail.job.JobMixin`. The job should implement the handle with a ``finished()`` method that knows how to check the job. The handle can also be used for other things like killing the job, or fetch job state information like standard output.
+
+How executions are monitored by JobMonitor
+------------------------------------------
+
+For jobs to be monitored, a controller or a JobMonitor needs to be passed to the interpreter. Also, a current workflow needs to be set by calling :meth:`~vistrails.core.vistrail.job.JobMonitor.startWorkflow`. This is because executions can execute subworkflows as sub-executions, but we only want to monitor it at the top level as a single wortkflow. After execution completes :meth:`~vistrails.core.vistrail.job.JobMonitor.finishWorkflow` is called which will update the tree and check the final state of the execution.
+
+Job Monitor execution lock
+--------------------------
+
+Since the execution uses a current workflow to record the jobs to only one execution can be running at the same time. This is enforced by setting and clearing :meth:`~vistrails.gui.job_monitor.QJobView.updating_now`. TODO: It should be possible to get rid of this by passing the job_monitor and the current workflow to the interpreter recursively.
+
+Job Types
+---------
+
+Jobs are typically tied to a workflow version in the vistrail. But jobs can also be tied to Parameter Explorations and Mashups. Currently, such jobs cannot be resumed automatically and need to be re-executed manually. Jobs will be shared between workflows. Deleting a job in one workflow will delete it from all workflows where it is used.
diff --git a/doc/internal/make.bat b/doc/internal/make.bat
new file mode 100644
index 000000000..f330a0e56
--- /dev/null
+++ b/doc/internal/make.bat
@@ -0,0 +1,263 @@
+@ECHO OFF
+
+REM Command file for Sphinx documentation
+
+if "%SPHINXBUILD%" == "" (
+	set SPHINXBUILD=sphinx-build
+)
+set BUILDDIR=_build
+set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
+set I18NSPHINXOPTS=%SPHINXOPTS% .
+if NOT "%PAPER%" == "" (
+	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
+	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
+)
+
+if "%1" == "" goto help
+
+if "%1" == "help" (
+	:help
+	echo.Please use `make ^<target^>` where ^<target^> is one of
+	echo.  html       to make standalone HTML files
+	echo.  dirhtml    to make HTML files named index.html in directories
+	echo.  singlehtml to make a single large HTML file
+	echo.  pickle     to make pickle files
+	echo.  json       to make JSON files
+	echo.  htmlhelp   to make HTML files and a HTML help project
+	echo.  qthelp     to make HTML files and a qthelp project
+	echo.  devhelp    to make HTML files and a Devhelp project
+	echo.  epub       to make an epub
+	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
+	echo.  text       to make text files
+	echo.  man        to make manual pages
+	echo.  texinfo    to make Texinfo files
+	echo.  gettext    to make PO message catalogs
+	echo.  changes    to make an overview over all changed/added/deprecated items
+	echo.  xml        to make Docutils-native XML files
+	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
+	echo.  linkcheck  to check all external links for integrity
+	echo.  doctest    to run all doctests embedded in the documentation if enabled
+	echo.  coverage   to run coverage check of the documentation if enabled
+	goto end
+)
+
+if "%1" == "clean" (
+	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
+	del /q /s %BUILDDIR%\*
+	goto end
+)
+
+
+REM Check if sphinx-build is available and fallback to Python version if any
+%SPHINXBUILD% 2> nul
+if errorlevel 9009 goto sphinx_python
+goto sphinx_ok
+
+:sphinx_python
+
+set SPHINXBUILD=python -m sphinx.__init__
+%SPHINXBUILD% 2> nul
+if errorlevel 9009 (
+	echo.
+	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
+	echo.installed, then set the SPHINXBUILD environment variable to point
+	echo.to the full path of the 'sphinx-build' executable. Alternatively you
+	echo.may add the Sphinx directory to PATH.
+	echo.
+	echo.If you don't have Sphinx installed, grab it from
+	echo.http://sphinx-doc.org/
+	exit /b 1
+)
+
+:sphinx_ok
+
+
+if "%1" == "html" (
+	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
+	goto end
+)
+
+if "%1" == "dirhtml" (
+	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
+	goto end
+)
+
+if "%1" == "singlehtml" (
+	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
+	goto end
+)
+
+if "%1" == "pickle" (
+	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the pickle files.
+	goto end
+)
+
+if "%1" == "json" (
+	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can process the JSON files.
+	goto end
+)
+
+if "%1" == "htmlhelp" (
+	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run HTML Help Workshop with the ^
+.hhp project file in %BUILDDIR%/htmlhelp.
+	goto end
+)
+
+if "%1" == "qthelp" (
+	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; now you can run "qcollectiongenerator" with the ^
+.qhcp project file in %BUILDDIR%/qthelp, like this:
+	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\VisTrails.qhcp
+	echo.To view the help file:
+	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\VisTrails.ghc
+	goto end
+)
+
+if "%1" == "devhelp" (
+	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished.
+	goto end
+)
+
+if "%1" == "epub" (
+	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The epub file is in %BUILDDIR%/epub.
+	goto end
+)
+
+if "%1" == "latex" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "latexpdf" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	cd %BUILDDIR%/latex
+	make all-pdf
+	cd %~dp0
+	echo.
+	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "latexpdfja" (
+	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
+	cd %BUILDDIR%/latex
+	make all-pdf-ja
+	cd %~dp0
+	echo.
+	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
+	goto end
+)
+
+if "%1" == "text" (
+	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The text files are in %BUILDDIR%/text.
+	goto end
+)
+
+if "%1" == "man" (
+	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The manual pages are in %BUILDDIR%/man.
+	goto end
+)
+
+if "%1" == "texinfo" (
+	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
+	goto end
+)
+
+if "%1" == "gettext" (
+	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
+	goto end
+)
+
+if "%1" == "changes" (
+	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.The overview file is in %BUILDDIR%/changes.
+	goto end
+)
+
+if "%1" == "linkcheck" (
+	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Link check complete; look for any errors in the above output ^
+or in %BUILDDIR%/linkcheck/output.txt.
+	goto end
+)
+
+if "%1" == "doctest" (
+	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of doctests in the sources finished, look at the ^
+results in %BUILDDIR%/doctest/output.txt.
+	goto end
+)
+
+if "%1" == "coverage" (
+	%SPHINXBUILD% -b coverage %ALLSPHINXOPTS% %BUILDDIR%/coverage
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Testing of coverage in the sources finished, look at the ^
+results in %BUILDDIR%/coverage/python.txt.
+	goto end
+)
+
+if "%1" == "xml" (
+	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The XML files are in %BUILDDIR%/xml.
+	goto end
+)
+
+if "%1" == "pseudoxml" (
+	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
+	if errorlevel 1 exit /b 1
+	echo.
+	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
+	goto end
+)
+
+:end
diff --git a/doc/internal/output_modules.rst b/doc/internal/output_modules.rst
new file mode 100644
index 000000000..f83ee720d
--- /dev/null
+++ b/doc/internal/output_modules.rst
@@ -0,0 +1,12 @@
+..  _output_modules:
+
+Output modules
+**************
+
+DOCTODO
+
+..  autoclass:: vistrails.core.modules.output_modules.OutputModule
+    :members:
+
+..  autoclass:: vistrails.core.modules.output_modules.OutputMode
+    :members:
diff --git a/doc/internal/packages.rst b/doc/internal/packages.rst
new file mode 100644
index 000000000..39cff85bd
--- /dev/null
+++ b/doc/internal/packages.rst
@@ -0,0 +1,76 @@
+VisTrails Packages
+******************
+
+..  _packages:
+
+Packages
+--------
+
+Packages are the name of the plugins in VisTrails that provide modules. Each package usually wraps a library or provide related functionalities. They are loaded by the package manager and are wrapped by :class:`vistrails.core.modules.package.Package`.
+
+A VisTrails Package is a Python module or package in a location where the package manager will find it (either ``vistrails/packages`` or ``.vistrails/userpackages``). It is either a single module or a directory with the following structure::
+
+    my_codepath
+    |-- __init__.py
+    |-- init.py
+    +-- ...
+
+``my_codepath`` is referred to as "codepath" in the code; concatenated with the "prefix", it gives the argument passed to import to load the package (set as :attr:`~vistrails.core.modules.packages.Package._module`).
+
+``my_codepath.__init__`` has to exist for the directory to be importable. If ``my_codepath.init`` exists, it will be loaded as :attr:`~vistrails.core.modules.packages.Package._module` when the module is enabled instead of ``my_codepath``; this allows the bulk of the code (the part that usually has Python dependencies) to be separate from the package root, in which we find a bunch of functions and constants that are used by VisTrails before the package is enabled.
+
+The package should contain (in ``__init__.py``) the following:
+
+* ``name``: a human-readable name for the package, displayed in dialogs
+* ``identifier``: a unique identifier for the package, used to refer to it everywhere (for dependency links in other packages, and in serialized workflows)
+* ``version``: a version number (see :ref:`upgrades`)
+
+It can also optionally have the following:
+
+* ``configuration``: A :class:`~vistrails.core.configuration.ConfigurationObject` holding the configuration of this package, that will be persisted to ``.vistrails``. It is currently injected in ``init`` and you can thus use it without importing it, but it's good practice to import it from somewhere anyway (at the very least, it makes IDE not report it as undefined reference).
+* ``package_dependencies``: A simple function that returns a list of package identifiers this package depends on. It will not be possible to enable this package if they are not available. The package manager will also make sure they are enabled first, so cyclic dependencies are not possible here.
+* ``package_requirements``: A function that checks that the other requirements are met. For example, a VisTrails package wrapping a library might want to check that the library is importable there, to give out a clean error message to the user if it isn't (and optionally, grab it automatically with the bundle system; use :func:`vistrails.core.requirements.require_python_module` in there for example).
+* ``can_handle_identifier`` DOCTODO
+* ``can_handle_vt_file`` DOCTODO
+
+..  autofunction:: vistrails.core.requirements.require_python_module
+
+..  autofunction:: vistrails.core.requirements.require_executable
+
+The ``my_codepath.init`` (if separate, else ``my_codepath``) module is can contain the following:
+
+* ``initialize``: The "entry point" of the package, called when initializing. Registers :class:`~vistrails.core.modules.vistrails_module.Module`s with the :class:`~vistrails.core.modules.module_registry.ModuleRegistry` (after generating them dynamically, for example; else ``_modules`` might be more convenient).
+* ``_modules``: A list of :class:`~vistrails.core.modules.vistrails_module.Module` subclasses to register with the module registry automatically. It can also be a dict mapping a namespace to a list of modules. A module can also be replaced with a tuple ``(ModuleClass, options)`` where ``options`` is a dict with the module's settings.
+* ``contextMenuName``: The single entry of the context menu shown when right-clicking a module in the module palette. The module name (or package name) is the only argument. ``callContextMenu`` is called with the same argument if the user clicks the menu entry.
+* ``callContextMenu``: Callback for the context menu. The module name (or package name) is the only argument.
+* ``handle_module_upgrade_request`` DOCTODO
+* ``handle_all_errors`` DOCTODO
+* ``handle_missing_module`` DOCTODO
+* ``loadVistrailFileHook`` DOCTODO
+* ``saveVistrailFileHook`` DOCTODO
+
+..  todo::
+
+    Right now, ``contextMenuName()`` only allows package creator to display a one-element context menu.
+
+    :issue:`1115`
+
+..  autoclass:: vistrails.core.modules.package.Package
+    :members:
+
+..  autoclass:: vistrails.core.packagemanager.PackageManager
+    :members:
+
+..  _modules:
+
+Modules
+-------
+
+Package register modules with VisTrails. These are the boxes that can be assembled in pipelines and run code when executing.
+
+A module is simply a subclass of :class:`~vistrails.core.modules.vistrails_module.Module`. It represents both a **datatype** (e.g., the type of a port or a connection) and a **computation unit** (e.g. a box in the pipeline view, with ports from and to which you draw connections). Modules can use single-inheritance, which will inherit the ports from the parent unless they are overridden. It is possible to connect one port to a port of a parent type. The special type `Variant` can connect to and from any other type.
+
+Note that the type of a port, which is a Module, is different from the actual type of Python objects that are passed on the connection. In fact, `Module` instances are not passed on connections anymore since they cause problems (they have references to the pipeline, the interpreter, ... which make them very unsafe to serialize). For example, an SQLAlchemy Connection object is passed on `DBConnection` ports, the figure number is passed unwrapped on `MplFigure` ports, and either numpy arrays or Python `list`s are passed on `List` ports. The association between a `Module` and the actual type passed on connections is just convention, although VisTrails will check it in specific cases (such as when one end of the connection is a `Variant` port) by calling :func:`~vistrails.core.modules.vistrails_module.Module.validate` on the value.
+
+..  autoclass:: vistrails.core.modules.vistrails_module.Module
+    :members:
diff --git a/doc/internal/registry.rst b/doc/internal/registry.rst
new file mode 100644
index 000000000..79dd54423
--- /dev/null
+++ b/doc/internal/registry.rst
@@ -0,0 +1,10 @@
+..  _module-registry:
+
+Module Registry
+***************
+
+..  autoclass:: vistrails.core.modules.module_registry.ModuleRegistry
+    :members:
+
+..  autoclass:: vistrails.core.modules.module_descriptor.ModuleDescriptor
+    :members:
diff --git a/doc/internal/requirements.txt b/doc/internal/requirements.txt
new file mode 100644
index 000000000..a29a9d7f3
--- /dev/null
+++ b/doc/internal/requirements.txt
@@ -0,0 +1 @@
+sphinx-issues
diff --git a/doc/internal/upgrades.rst b/doc/internal/upgrades.rst
new file mode 100644
index 000000000..c49ed6f36
--- /dev/null
+++ b/doc/internal/upgrades.rst
@@ -0,0 +1,27 @@
+..  _upgrades:
+
+Pipeline upgrades
+*****************
+
+The upgrade mechanism allows VisTrails to deal with workflow written with older versions of packages.
+
+Each package has, in addition to its identifier, a version number. The package's version number is written alongside the package and module names in serialized workflows; when it is loaded, the package will have a chance to replace this old module, else VisTrails will just bump the version number of the module. If the module has changed, and the connections that appear in the workflow don't match the port names or signature that the current package declares, the pipeline will be invalid and the user will have to fix it manually.
+
+A package can upgrade older modules using a function `handle_module_upgrade_request()` in its ``init`` module. That function takes the controller, module id and current pipeline, and performs actions to fix that module. Packages usually use :class:`~vistrails.core.upgradeworkflow.UpgradeWorkflowHandler` to do this, for example by passing a remap object to :func:`~vistrails.core.upgradeworkflow.UpgradeWorkflowHandler.remap_module`.
+
+..  autoclass:: vistrails.core.upgradeworkflow.UpgradeWorkflowHandler
+    :members:
+
+The controller triggers the upgrade of a version when it gets selected. Since each version has to be upgraded separately, the upgrade will be created (so the pipeline can be shown) but will not be flushed to the vistrail unless another change is made (based on that upgraded version) or the pipeline is executed.
+
+..  todo::
+
+    There are currently some issues with how the controller keeps these unflushed upgrades.
+
+    :issue:`907`
+
+..  todo::
+
+    Upgrades should be triggered when necessary during diff, query, subworkflow update, parameter exploration.
+
+    :issue:`695,1054,1071,1087`
diff --git a/doc/internal/widgets.rst b/doc/internal/widgets.rst
new file mode 100644
index 000000000..bfab77c6e
--- /dev/null
+++ b/doc/internal/widgets.rst
@@ -0,0 +1,6 @@
+..  _widgets:
+
+Module widgets
+**************
+
+DOCTODO: configuration widgets, constant widgets
diff --git a/doc/usersguide/conf.py b/doc/usersguide/conf.py
index 4bb713df3..9a73d8b5d 100644
--- a/doc/usersguide/conf.py
+++ b/doc/usersguide/conf.py
@@ -3,7 +3,8 @@
 # VisTrails documentation build configuration file, created by
 # sphinx-quickstart on Mon Feb  7 21:06:44 2011.
 #
-# This file is execfile()d with the current directory set to its containing dir.
+# This file is execfile()d with the current directory set to its
+# containing dir.
 #
 # Note that not all possible configuration values are present in this
 # autogenerated file.
@@ -11,47 +12,68 @@
 # All configuration values have a default; values that are commented out
 # serve to show the default.
 
-import sys, os
+import sys
+import os
 
 # If extensions (or modules to document with autodoc) are in another directory,
 # add these directories to sys.path here. If the directory is relative to the
 # documentation root, use os.path.abspath to make it absolute, like shown here.
-sys.path.append(os.path.abspath('../..'))
-
-# -- General configuration -----------------------------------------------------
-
-# Add any Sphinx extension module names here, as strings. They can be extensions
-# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
-extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo', 'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.ifconfig', 'sphinx.ext.extlinks', 'sphinxarg.ext']
+sys.path.insert(0, os.path.abspath('../..'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.doctest',
+    'sphinx.ext.intersphinx',
+    'sphinx.ext.todo',
+    'sphinx.ext.coverage',
+    'sphinx.ext.pngmath',
+    'sphinx.ext.ifconfig',
+    'sphinx.ext.extlinks',
+    'sphinxarg.ext',
+]
 
 # Add any paths that contain templates here, relative to this directory.
 templates_path = ['_templates']
 
-# The suffix of source filenames.
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+# source_suffix = ['.rst', '.md']
 source_suffix = '.rst'
 
 # The encoding of source files.
-#source_encoding = 'utf-8'
+#source_encoding = 'utf-8-sig'
 
 # The master toctree document.
 master_doc = 'index'
 
 # General information about the project.
 project = u'VisTrails'
-copyright = u'2014, NYU Poly'
+copyright = u'2015, New York University'
+author = u'New York University'
 
 # The version info for the project you're documenting, acts as replacement for
 # |version| and |release|, also used in various other places throughout the
 # built documents.
 #
 # The short X.Y version.
-version = '2.2'
+version = 'master'
 # The full version, including alpha/beta/rc tags.
-release = '2.2.4'
+release = '2.x'
 
 # The language for content autogenerated by Sphinx. Refer to documentation
 # for a list of supported languages.
-#language = None
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
 
 # There are two options for replacing |today|: either, you set today to some
 # non-false value, then it is used:
@@ -59,14 +81,12 @@
 # Else, today_fmt is used as the format for a strftime call.
 #today_fmt = '%B %d, %Y'
 
-# List of documents that shouldn't be included in the build.
-#unused_docs = []
-
-# List of directories, relative to source directory, that shouldn't be searched
-# for source files.
-exclude_trees = ['_build']
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
 
-# The reST default role (used for this markup: `text`) to use for all documents.
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
 #default_role = None
 
 # If true, '()' will be appended to :func: etc. cross-reference text.
@@ -86,14 +106,20 @@
 # A list of ignored prefixes for module index sorting.
 #modindex_common_prefix = []
 
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = False
+
 extlinks = {'vtl': ('http://www.vistrails.org/usersguide/v2.2/examples/%sl',
                     '')}
 
-# -- Options for HTML output ---------------------------------------------------
+# -- Options for HTML output ----------------------------------------------
 
-# The theme to use for HTML and HTML Help pages.  Major themes that come with
-# Sphinx are currently 'default' and 'sphinxdoc'.
-html_theme = 'default'
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'classic'
 
 # Theme options are theme-specific and customize the look and feel of a theme
 # further.  For a list of options available for each theme, see the
@@ -119,13 +145,16 @@
 # pixels large.
 #html_favicon = None
 
-html_style = "mystyle.css"
-
 # Add any paths that contain custom static files (such as style sheets) here,
 # relative to this directory. They are copied after the builtin static files,
 # so a file named "default.css" will overwrite the builtin "default.css".
 html_static_path = ['_static']
 
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
 # If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
 # using the given strftime format.
 #html_last_updated_fmt = '%b %d, %Y'
@@ -142,7 +171,7 @@
 #html_additional_pages = {}
 
 # If false, no module index is generated.
-#html_use_modindex = True
+#html_domain_indices = True
 
 # If false, no index is generated.
 #html_use_index = True
@@ -153,31 +182,60 @@
 # If true, links to the reST sources are added to the pages.
 #html_show_sourcelink = True
 
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
 # If true, an OpenSearch description file will be output, and all pages will
 # contain a <link> tag referring to it.  The value of this option must be the
 # base URL from which the finished HTML is served.
 #html_use_opensearch = ''
 
-# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
-#html_file_suffix = ''
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'
+#html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# Now only 'ja' uses this config value
+#html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+#html_search_scorer = 'scorer.js'
 
 # Output file base name for HTML help builder.
 htmlhelp_basename = 'VisTrailsdoc'
 
 
-# -- Options for LaTeX output --------------------------------------------------
+# -- Options for LaTeX output ---------------------------------------------
 
-# The paper size ('letter' or 'a4').
-#latex_paper_size = 'letter'
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
 
 # The font size ('10pt', '11pt' or '12pt').
-#latex_font_size = '10pt'
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+
+# Latex figure (float) alignment
+#'figure_align': 'htbp',
+}
 
 # Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title, author, documentclass [howto/manual]).
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
 latex_documents = [
-  ('index', 'VisTrails.tex', u'VisTrails Documentation',
-   u'NYU Poly', 'manual'),
+  (master_doc, 'VisTrails.tex', u'VisTrails Documentation',
+   author, 'manual'),
 ]
 
 # The name of an image file (relative to this directory) to place at the top of
@@ -188,18 +246,59 @@
 # not chapters.
 latex_use_parts = True
 
-# Additional stuff for the LaTeX preamble.
-#latex_preamble = ''
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
 
 # Documents to append as an appendix to all manuals.
 #latex_appendices = []
 
 # If false, no module index is generated.
-#latex_use_modindex = True
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'vistrails', u'VisTrails Documentation',
+     [author], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  (master_doc, 'VisTrails', u'VisTrails Documentation',
+   author, 'VisTrails', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
 
 
 # Example configuration for intersphinx: refer to the Python standard library.
-intersphinx_mapping = {'http://docs.python.org/': None}
+intersphinx_mapping = {'https://docs.python.org/': None}
+
 
 rst_epilog = """
 .. |vistrails| replace:: VisTrails
diff --git a/doc/usersguide/packages.rst b/doc/usersguide/packages.rst
index 60cf393d4..eb5315942 100644
--- a/doc/usersguide/packages.rst
+++ b/doc/usersguide/packages.rst
@@ -847,6 +847,33 @@ In addition, VisTrails 2.1 introduced new port configuration arguments :py:attr:
 .. index::
    pair: ports; shape
 
+Union types
+^^^^^^^^^^^
+
+The supported types of an input port is its module type, and its subclasses. Sometimes it is useful to define a port that supports multiple types, e.g., both ``Float`` and ``String``. You could creating a new module type that accepted both floats and strings, but it would not be possible to make it accept both Float and String types, because you can only inherit from one of them.
+
+VisTrails solves this by defining ports as belonging to the same union. The GUI will show all ports with the same union name as the same port. When you create a union type function or show it as a port you will be prompted to select which type you want to use.
+
+Below is an example defining a module with a union port called ``myunion``. The union port will consist of the ports ``myunionFloat`` and ``myunionString``, but it will be shown in the GUI as a single port ``myunion``. Note that you should set ``optional`` to ``True`` for all union ports, otherwise you will not be able to change the type of the visible port.  In the compute method you will need to check for values on both ports manually, usually to fetch the value from whichever port has been set. 
+
+.. code-block:: python
+    :linenos:
+
+    class MyModule(Module):
+        """ A module with union ports
+
+        """
+        _input_ports = [IPort("myunionFloat", "basic:Float",
+                              optional=True, union='myunion'),
+                        IPort("myunionString", "basic:String",
+                              optional=True, union='myunion')]
+
+     def compute(self):
+	 if self.has_input('myunionFloat'):
+             value = self.get_input('myunionFloat')
+	 else:
+             value = self.get_input('myunionString')
+
 Shape
 ^^^^^
 
diff --git a/examples/api/ipython-notebook.ipynb b/examples/api/ipython-notebook.ipynb
index ed022675c..a9a0bbcda 100644
--- a/examples/api/ipython-notebook.ipynb
+++ b/examples/api/ipython-notebook.ipynb
@@ -1,1363 +1,1646 @@
-{
- "metadata": {
-  "name": "",
-  "signature": "sha256:60187fe17c0a32826b5856d40a5920f473bfc630c413d515bbfeb9180885a128"
- },
- "nbformat": 3,
- "nbformat_minor": 0,
- "worksheets": [
-  {
-   "cells": [
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "# Sets up import path, if you're running from the source distrib\n",
-      "import os, sys\n",
-      "sys.path.append(os.path.join(os.getcwd(), '../..'))"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 1
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "import traceback"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 2
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "# VisTrails API example\n",
-      "\n",
-      "This notebook showcases the new API. Inlined are some comments and explanations."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "import vistrails as vt"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 3
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "The new API is exposed under the top-level `vistrails` package. The moment you use one of the API functions, like `load_vistrail()`, it will create an application and load the same configuration that the VisTrails application uses (although it will automatically enable packages the moment you need them)."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vt.ipython_mode(True)"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 4
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "This explicitely requests IPythonMode to be enabled on output modules, so that pipeline executions will put results on the notebook (similarly to `%matplotlib inline` for matplotlib plots)."
-     ]
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "## `Vistrail`s and `Pipeline`s\n",
-      "\n",
-      "You can get a `Vistrail` through `load_vistrail()`."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vistrail = vt.load_vistrail('simplemath.vt')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 5
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "A `Vistrail` is a whole version tree, where each version is a different pipeline. From it we can get `Pipeline`s, but it is also stateful (i.e. has a current version); this is useful for editing (creating new versions from the current one). It also provides the interface that `Pipeline` has, implicitely acting on the `current_pipeline`.\n",
-      "\n",
-      "If GraphViz is available, `Vistrail` and `Pipeline` will be rendered in the IPython notebook."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vistrail"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"158pt\" height=\"116pt\"\r\n",
-        " viewBox=\"0.00 0.00 158.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 155,-112 155,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 28 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>28</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-18\" rx=\"75.0904\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"75\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added annotation</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;28 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;28</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M75,-71.6966C75,-63.9827 75,-54.7125 75,-46.1124\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"78.5001,-46.1043 75,-36.1043 71.5001,-46.1044 78.5001,-46.1043\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: simplemath.vt, version -1, not changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 6,
-       "text": [
-        "<Vistrail: simplemath.vt, version -1, not changed>"
-       ]
-      }
-     ],
-     "prompt_number": 6
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vistrail.select_latest_version()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 7
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vistrail"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"158pt\" height=\"116pt\"\r\n",
-        " viewBox=\"0.00 0.00 158.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 155,-112 155,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 28 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>28</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"red\" cx=\"75\" cy=\"-18\" rx=\"75.0904\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"75\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added annotation</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;28 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;28</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M75,-71.6966C75,-63.9827 75,-54.7125 75,-46.1124\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"78.5001,-46.1043 75,-36.1043 71.5001,-46.1044 78.5001,-46.1043\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: simplemath.vt, version 28, not changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 8,
-       "text": [
-        "<Vistrail: simplemath.vt, version 37, not changed>"
-       ]
-      }
-     ],
-     "prompt_number": 8
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "vistrail.get_pipeline(2)"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
-        "<svg width=\"102pt\" height=\"44pt\"\r\n",
-        " viewBox=\"0.00 0.00 102.00 44.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 40)\">\r\n",
-        "<title>_anonymous_0</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-40 99,-40 99,5 -4,5\"/>\r\n",
-        "<!-- module0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-7 8,-28 87,-28 87,-7 8,-7\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"8,-7 8,-28 87,-28 87,-7 8,-7\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"11.5\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">PythonCalc</text>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Pipeline: 1 modules, 0 connections&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 9,
-       "text": [
-        "<Pipeline: 1 modules, 0 connections>"
-       ]
-      }
-     ],
-     "prompt_number": 9
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "# Packages\n",
-      "\n",
-      "Only `basic_modules` (and `abstractions`?) are loaded on initialization, so that using the API stays fast. A package might be auto-enabled when it is requested, which is efficient and convenient.\n",
-      "\n",
-      "Note that `load_package()` only accepts package identifiers."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tabledata = vt.load_package('org.vistrails.vistrails.tabledata')\n",
-      "tabledata"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 10,
-       "text": [
-        "<Package: org.vistrails.vistrails.tabledata, 23 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 10
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "You can get `Module`s from the package using the dot or bracket syntax. These modules are \"dangling\" modules, not yet instanciated in a specific pipeline/vistrail.\n",
-      "\n",
-      "These will be useful once editing pipelines is added to the API."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tabledata.convert"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 11,
-       "text": [
-        "<Namespace convert of package org.vistrails.vistrails.tabledata>"
-       ]
-      }
-     ],
-     "prompt_number": 11
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "from vistrails.core.modules.module_registry import MissingModule\n",
-      "try:\n",
-      "    tabledata['convert']  # can't get namespaces this way, use a dot\n",
-      "except MissingModule:\n",
-      "    pass\n",
-      "else:\n",
-      "    assert False"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 12
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tabledata.BuildTable, tabledata['BuildTable']"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 13,
-       "text": [
-        "(<Module class 'BuildTable' from org.vistrails.vistrails.tabledata>,\n",
-        " <Module class 'BuildTable' from org.vistrails.vistrails.tabledata>)"
-       ]
-      }
-     ],
-     "prompt_number": 13
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tabledata.read.CSVFile, tabledata['read|CSVFile']"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 14,
-       "text": [
-        "(<Module class 'CSVFile' from org.vistrails.vistrails.tabledata>,\n",
-        " <Module class 'CSVFile' from org.vistrails.vistrails.tabledata>)"
-       ]
-      }
-     ],
-     "prompt_number": 14
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "# Pipeline manipulation\n",
-      "\n",
-      "Unfortunately this is not yet available, stay tuned!"
-     ]
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "# Execution\n",
-      "\n",
-      "In addition to executing a `Pipeline` or `Vistrail`, you can easily pass values in on InputPort modules (to use subworkflows as Python functions) and get results out (either on OutputPort modules or any port of any module).\n",
-      "\n",
-      "Execution returns a `Results` object from which you can get all of this. In addition, output modules (such as matplotlib's MplFigureOutput) will output to the IPython notebook if possible."
-     ]
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "## Gets output"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "outputs = vt.load_vistrail('outputs.vt')\n",
-      "outputs.select_version(1)\n",
-      "outputs"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"154pt\" height=\"188pt\"\r\n",
-        " viewBox=\"0.00 0.00 154.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 151,-184 151,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 1 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>1</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"red\" cx=\"73\" cy=\"-90\" rx=\"64.4914\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"73\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added module</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;1 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;1</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M73,-143.697C73,-135.983 73,-126.712 73,-118.112\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-118.104 73,-108.104 69.5001,-118.104 76.5001,-118.104\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 5 -->\r\n",
-        "<g id=\"node3\" class=\"node\"><title>5</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-18\" rx=\"73.1654\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"73\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added parameter</text>\r\n",
-        "</g>\r\n",
-        "<!-- 1&#45;&gt;5 -->\r\n",
-        "<g id=\"edge4\" class=\"edge\"><title>1&#45;&gt;5</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M73,-71.6966C73,-63.9827 73,-54.7125 73,-46.1124\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-46.1043 73,-36.1043 69.5001,-46.1044 76.5001,-46.1043\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: outputs.vt, version 1, not changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 15,
-       "text": [
-        "<Vistrail: outputs.vt, version 1, not changed>"
-       ]
-      }
-     ],
-     "prompt_number": 15
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "# Errors\n",
-      "try:\n",
-      "    result = outputs.execute()\n",
-      "except vt.ExecutionErrors:\n",
-      "    traceback.print_exc()\n",
-      "else:\n",
-      "    assert False"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "output_type": "stream",
-       "stream": "stderr",
-       "text": [
-        "Traceback (most recent call last):\n",
-        "  File \"<ipython-input-16-979bf6416e43>\", line 3, in <module>\n",
-        "    result = outputs.execute()\n",
-        "  File \"/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/api.py\", line 259, in execute\n",
-        "    return self.current_pipeline.execute(*args, **kwargs)\n",
-        "  File \"/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/api.py\", line 482, in execute\n",
-        "    raise ExecutionErrors(self, result)\n",
-        "ExecutionErrors: Pipeline execution failed: 1 error:\n",
-        "0: Missing value from port value\n"
-       ]
-      }
-     ],
-     "prompt_number": 16
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "# Results\n",
-      "outputs.select_latest_version()\n",
-      "result = outputs.execute()\n",
-      "result"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 17,
-       "text": [
-        "<ExecutionResult: 2 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 17
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "outputs"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"154pt\" height=\"116pt\"\r\n",
-        " viewBox=\"0.00 0.00 154.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 151,-112 151,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 5 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>5</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"red\" cx=\"73\" cy=\"-18\" rx=\"73.1654\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"73\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added parameter</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;5 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;5</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M73,-71.6966C73,-63.9827 73,-54.7125 73,-46.1124\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-46.1043 73,-36.1043 69.5001,-46.1044 76.5001,-46.1043\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: outputs.vt, version 5, changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 18,
-       "text": [
-        "<Vistrail: outputs.vt, version 5, changed>"
-       ]
-      }
-     ],
-     "prompt_number": 18
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "outputs.current_pipeline"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
-        "<svg width=\"102pt\" height=\"152pt\"\r\n",
-        " viewBox=\"0.00 0.00 102.00 152.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 148)\">\r\n",
-        "<title>_anonymous_0</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-148 99,-148 99,5 -4,5\"/>\r\n",
-        "<!-- module0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"24,-118 24,-139 69,-139 69,-118 24,-118\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"24,-118 24,-139 69,-139 69,-118 24,-118\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"27.5\" y=\"-125.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">String</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"26,-96 26,-116 67,-116 67,-96 26,-96\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"32\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
-        "</g>\r\n",
-        "<!-- module1 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>module1</title>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"10,-26 10,-47 84,-47 84,-26 10,-26\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"13.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-4 8,-24 86,-24 86,-4 8,-4\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"8,-4 8,-24 86,-24 86,-4 8,-4\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"12\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
-        "</g>\r\n",
-        "<!-- module0&#45;&gt;module1 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>module0:out0&#45;&gt;module1:in0</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M47,-95C47,-78.0278 47,-71.398 47,-58.3042\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"50.5001,-58 47,-48 43.5001,-58 50.5001,-58\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Pipeline: 2 modules, 1 connections; outputs: msg&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 19,
-       "text": [
-        "<Pipeline: 2 modules, 1 connections; outputs: msg>"
-       ]
-      }
-     ],
-     "prompt_number": 19
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "This gets the value on any output port of any module (no need to insert OutputPort or GenericOutput modules, if you know how to find the module):"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "result.module_output(0)"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 20,
-       "text": [
-        "{'self': <vistrails.core.modules.basic_modules.String at 0x5bd7bb0>,\n",
-        " 'value': 'Hello, world',\n",
-        " 'value_as_string': 'Hello, world'}"
-       ]
-      }
-     ],
-     "prompt_number": 20
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "This gets the value passed to an OutputPort module, using the OutputPort's name:"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "result.output_port('msg')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 21,
-       "text": [
-        "'Hello, world'"
-       ]
-      }
-     ],
-     "prompt_number": 21
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "## Sets inputs"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "pipeline = vistrail.current_pipeline\n",
-      "pipeline"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
-        "<svg width=\"247pt\" height=\"266pt\"\r\n",
-        " viewBox=\"0.00 0.00 247.00 266.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 262)\">\r\n",
-        "<title>_anonymous_0</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-262 244,-262 244,5 -4,5\"/>\r\n",
-        "<!-- module0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"18,-140 18,-161 61,-161 61,-140 18,-140\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"21.5\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value2</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"61,-140 61,-161 103,-161 103,-140 61,-140\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"64\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value1</text>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"16,-118 16,-138 105,-138 105,-118 16,-118\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"16,-118 16,-138 105,-138 105,-118 16,-118\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"56\" y=\"-124.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">+</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"18,-96 18,-116 103,-116 103,-96 18,-96\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"46\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
-        "</g>\r\n",
-        "<!-- module4 -->\r\n",
-        "<g id=\"node5\" class=\"node\"><title>module4</title>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"24,-26 24,-47 98,-47 98,-26 24,-26\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"27.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"22,-4 22,-24 100,-24 100,-4 22,-4\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"22,-4 22,-24 100,-24 100,-4 22,-4\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"26\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
-        "</g>\r\n",
-        "<!-- module0&#45;&gt;module4 -->\r\n",
-        "<g id=\"edge10\" class=\"edge\"><title>module0:out0&#45;&gt;module4:in0</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M61,-95C61,-78.0278 61,-71.398 61,-58.3042\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"64.5001,-58 61,-48 57.5001,-58 64.5001,-58\"/>\r\n",
-        "</g>\r\n",
-        "<!-- module1 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>module1</title>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"153,-232 153,-253 231,-253 231,-232 153,-232\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"153,-232 153,-253 231,-253 231,-232 153,-232\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"160\" y=\"-239.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">First input</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"155,-210 155,-230 229,-230 229,-210 155,-210\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"158.5\" y=\"-216.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
-        "</g>\r\n",
-        "<!-- module1&#45;&gt;module0 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>module1:out0&#45;&gt;module0:in1</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M154,-220C138.171,-220 127.099,-171.783 112.83,-155.962\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"114.432,-152.848 104,-151 111.003,-158.95 114.432,-152.848\"/>\r\n",
-        "</g>\r\n",
-        "<!-- module3 -->\r\n",
-        "<g id=\"node4\" class=\"node\"><title>module3</title>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"141,-140 141,-161 184,-161 184,-140 141,-140\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"144.5\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value2</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"184,-140 184,-161 226,-161 226,-140 184,-140\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"187\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value1</text>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"139,-118 139,-138 228,-138 228,-118 139,-118\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"139,-118 139,-138 228,-138 228,-118 139,-118\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"179.5\" y=\"-124.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">*</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"141,-96 141,-116 226,-116 226,-96 141,-96\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"169\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
-        "</g>\r\n",
-        "<!-- module1&#45;&gt;module3 -->\r\n",
-        "<g id=\"edge6\" class=\"edge\"><title>module1:out0&#45;&gt;module3:in1</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M192,-209C192,-191.221 200.748,-185.568 203.892,-172.147\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"207.393,-172.321 205,-162 200.435,-171.561 207.393,-172.321\"/>\r\n",
-        "</g>\r\n",
-        "<!-- module2 -->\r\n",
-        "<g id=\"node3\" class=\"node\"><title>module2</title>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-232 8,-253 94,-253 94,-232 8,-232\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"8,-232 8,-253 94,-253 94,-232 8,-232\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"11.5\" y=\"-239.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Second input</text>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"10,-210 10,-230 92,-230 92,-210 10,-210\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"17.5\" y=\"-216.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
-        "</g>\r\n",
-        "<!-- module2&#45;&gt;module0 -->\r\n",
-        "<g id=\"edge4\" class=\"edge\"><title>module2:out0&#45;&gt;module0:in0</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M51,-209C51,-191.315 42.925,-185.525 40.0231,-172.115\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"43.4887,-171.597 39,-162 36.5243,-172.301 43.4887,-171.597\"/>\r\n",
-        "</g>\r\n",
-        "<!-- module2&#45;&gt;module3 -->\r\n",
-        "<g id=\"edge8\" class=\"edge\"><title>module2:out0&#45;&gt;module3:in0</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M93,-220C108.364,-220 117.79,-172.68 131.113,-156.414\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"133.281,-159.192 140,-151 129.639,-153.214 133.281,-159.192\"/>\r\n",
-        "</g>\r\n",
-        "<!-- module5 -->\r\n",
-        "<g id=\"node6\" class=\"node\"><title>module5</title>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"147,-26 147,-47 221,-47 221,-26 147,-26\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"150.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
-        "<polygon fill=\"grey\" stroke=\"grey\" points=\"145,-4 145,-24 223,-24 223,-4 145,-4\"/>\r\n",
-        "<polygon fill=\"none\" stroke=\"black\" points=\"145,-4 145,-24 223,-24 223,-4 145,-4\"/>\r\n",
-        "<text text-anchor=\"start\" x=\"149\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
-        "</g>\r\n",
-        "<!-- module3&#45;&gt;module5 -->\r\n",
-        "<g id=\"edge12\" class=\"edge\"><title>module3:out0&#45;&gt;module5:in0</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M184,-95C184,-78.0278 184,-71.398 184,-58.3042\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"187.5,-58 184,-48 180.5,-58 187.5,-58\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Pipeline: 6 modules, 6 connections; inputs: in_a, in_b; outputs: out_times, out_plus&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 22,
-       "text": [
-        "<Pipeline: 6 modules, 6 connections; inputs: in_a, in_b; outputs: out_times, out_plus>"
-       ]
-      }
-     ],
-     "prompt_number": 22
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "in_a = pipeline.get_input('in_a')\n",
-      "assert (in_a == pipeline.get_module('First input')) is True\n",
-      "in_a"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 23,
-       "text": [
-        "<Module 'InputPort' from org.vistrails.vistrails.basic, id 1, name \"First input\">"
-       ]
-      }
-     ],
-     "prompt_number": 23
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "We need to provide value to this workflow, for its two InputPort modules. Input can be supplied to `execute()` in two ways:\n",
-      "* either by using `module_obj == value`, where module_obj is a module obtained from the pipeline, using `get_input()` or `get_module()`;\n",
-      "* or by using `module_name=value`, where module_name is the name set on an InputPort module\n",
-      "\n",
-      "Note that, to Python, `module_obj` is a variable and must be bound to a value (of type Module), whereas module_name is a keyword-parameter name."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "result = pipeline.execute(in_a == 2, in_b=4)"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 24
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "result.output_port('out_times'), result.output_port('out_plus')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 25,
-       "text": [
-        "(8.0, 6.0)"
-       ]
-      }
-     ],
-     "prompt_number": 25
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "## Other example"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im = vt.load_vistrail('imagemagick.vt')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 26
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im.select_version('read')\n",
-      "im"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"143pt\" height=\"188pt\"\r\n",
-        " viewBox=\"0.00 0.00 143.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 140,-184 140,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 6 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>6</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"red\" cx=\"65\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"65\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">read</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;6 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;6</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M65,-143.697C65,-135.983 65,-126.712 65,-118.112\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"68.5001,-118.104 65,-108.104 61.5001,-118.104 68.5001,-118.104\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 14 -->\r\n",
-        "<g id=\"node3\" class=\"node\"><title>14</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"27\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">blur</text>\r\n",
-        "</g>\r\n",
-        "<!-- 6&#45;&gt;14 -->\r\n",
-        "<g id=\"edge4\" class=\"edge\"><title>6&#45;&gt;14</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M56.1865,-72.7646C51.5823,-64.2831 45.845,-53.7144 40.6786,-44.1974\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"43.6126,-42.266 35.7657,-35.1473 37.4607,-45.6057 43.6126,-42.266\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 21 -->\r\n",
-        "<g id=\"node4\" class=\"node\"><title>21</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"104\" cy=\"-18\" rx=\"31.2735\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"104\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">edges</text>\r\n",
-        "</g>\r\n",
-        "<!-- 6&#45;&gt;21 -->\r\n",
-        "<g id=\"edge6\" class=\"edge\"><title>6&#45;&gt;21</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M74.0454,-72.7646C78.7033,-64.4043 84.4911,-54.0159 89.7338,-44.6059\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"92.9232,-46.0726 94.7328,-35.6334 86.8083,-42.6656 92.9232,-46.0726\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: imagemagick.vt, version 6 (tag read), not changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 27,
-       "text": [
-        "<Vistrail: imagemagick.vt, version 6 (tag read), not changed>"
-       ]
-      }
-     ],
-     "prompt_number": 27
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "Note that if you print a File value, IPython will try to render it."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im.execute().output_port('result')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "png": "iVBORw0KGgoAAAANSUhEUgAAAIcAAACHCAYAAAA850oKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAK\nTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQ\nWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec\n5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28A\nAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0\nST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaO\nWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHi\nwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryM\nAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0l\nYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHi\nNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYA\nQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6c\nwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBie\nwhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1c\nQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqO\nY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hM\nWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgoh\nJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSU\nEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/p\ndLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Y\nb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7O\nUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsb\ndi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W\n7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83\nMDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxr\nPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW\n2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1\nU27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd\n8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H0\n8PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+H\nvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsG\nLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjg\n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\nAABJRU5ErkJggg==\n",
-       "prompt_number": 28,
-       "text": [
-        "PathObject('vistrails_logo.png')"
-       ]
-      }
-     ],
-     "prompt_number": 28
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im.select_version('blur')\n",
-      "im"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
-        "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
-        " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
-        "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
-        " -->\r\n",
-        "<!-- Title: G Pages: 1 -->\r\n",
-        "<svg width=\"143pt\" height=\"188pt\"\r\n",
-        " viewBox=\"0.00 0.00 143.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
-        "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
-        "<title>G</title>\r\n",
-        "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 140,-184 140,5 -4,5\"/>\r\n",
-        "<!-- 0 -->\r\n",
-        "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 6 -->\r\n",
-        "<g id=\"node2\" class=\"node\"><title>6</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"65\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">read</text>\r\n",
-        "</g>\r\n",
-        "<!-- 0&#45;&gt;6 -->\r\n",
-        "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;6</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M65,-143.697C65,-135.983 65,-126.712 65,-118.112\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"68.5001,-118.104 65,-108.104 61.5001,-118.104 68.5001,-118.104\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 14 -->\r\n",
-        "<g id=\"node3\" class=\"node\"><title>14</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"red\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"27\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">blur</text>\r\n",
-        "</g>\r\n",
-        "<!-- 6&#45;&gt;14 -->\r\n",
-        "<g id=\"edge4\" class=\"edge\"><title>6&#45;&gt;14</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M56.1865,-72.7646C51.5823,-64.2831 45.845,-53.7144 40.6786,-44.1974\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"43.6126,-42.266 35.7657,-35.1473 37.4607,-45.6057 43.6126,-42.266\"/>\r\n",
-        "</g>\r\n",
-        "<!-- 21 -->\r\n",
-        "<g id=\"node4\" class=\"node\"><title>21</title>\r\n",
-        "<ellipse fill=\"none\" stroke=\"black\" cx=\"104\" cy=\"-18\" rx=\"31.2735\" ry=\"18\"/>\r\n",
-        "<text text-anchor=\"middle\" x=\"104\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">edges</text>\r\n",
-        "</g>\r\n",
-        "<!-- 6&#45;&gt;21 -->\r\n",
-        "<g id=\"edge6\" class=\"edge\"><title>6&#45;&gt;21</title>\r\n",
-        "<path fill=\"none\" stroke=\"black\" d=\"M74.0454,-72.7646C78.7033,-64.4043 84.4911,-54.0159 89.7338,-44.6059\"/>\r\n",
-        "<polygon fill=\"black\" stroke=\"black\" points=\"92.9232,-46.0726 94.7328,-35.6334 86.8083,-42.6656 92.9232,-46.0726\"/>\r\n",
-        "</g>\r\n",
-        "</g>\r\n",
-        "</svg>\r\n",
-        "<pre>&lt;Vistrail: imagemagick.vt, version 14 (tag blur), changed&gt;</pre>"
-       ],
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 29,
-       "text": [
-        "<Vistrail: imagemagick.vt, version 14 (tag blur), changed>"
-       ]
-      }
-     ],
-     "prompt_number": 29
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im.execute().output_port('result')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "png": "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\n",
-       "prompt_number": 30,
-       "text": [
-        "PathObject('/tmp/vt_tmpA0IiHV/vt_tmpnA__3c.png')"
-       ]
-      }
-     ],
-     "prompt_number": 30
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "im.select_version('edges')\n",
-      "im.execute().output_port('result')"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "png": "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\n",
-       "prompt_number": 31,
-       "text": [
-        "PathObject('/tmp/vt_tmpA0IiHV/vt_tmp7kISgw.png')"
-       ]
-      }
-     ],
-     "prompt_number": 31
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "## Output mode"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "mpl = vt.load_vistrail('../matplotlib/pie_ex1.vt')\n",
-      "mpl.select_latest_version()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 32
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "This workflow uses MplFigureOutput, which outputs to the IPython notebook if available (and since the spreadsheet is not running)."
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "mpl.execute()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "output_type": "stream",
-       "stream": "stderr",
-       "text": [
-        "WARNING:vistrails.logger:/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/modules/vistrails_module.py, line 1724\n",
-        "UserWarning: A Module instance was used as data: module=MplFigure, port=self, object=<vistrails.packages.matplotlib.bases.MplFigure object at 0x7f8b4028ef10>\n",
-        "  UserWarning)\n",
-        "\n"
-       ]
-      },
-      {
-       "metadata": {},
-       "output_type": "display_data",
-       "png": "iVBORw0KGgoAAAANSUhEUgAAAoAAAAH0CAYAAACtlpxpAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz\nAAAPYQAAD2EBqD+naQAAIABJREFUeJzs3Xd4VuXhxvHvOSeMhEAYAgEVREEQEZTlQHGgiAJurVtU\nQDaKuFulra1otdpaS0WqOFBEVH7gAkVAUKaAyJaNkARCTGIGGeec3x9vcFTIfN8877g/18WFtpjc\ntpjcnnE/1rx583xEREREJGbYpgOIiIiISPVSARQRERGJMSqAIiIiIjFGBVBEREQkxqgAioiIiMQY\nFUARERGRGKMCKCIiIhJjVABFREREYowKoIiIiEiMUQEUERERiTEqgCIiIiIxRgVQREREJMaoAIqI\niIjEGBVAERERkRijAigiIiISY1QARURERGKMCqCIiIhIjFEBFBEREYkxKoAiIiIiMUYFUERERCTG\nqACKiIiIxBgVQBEREZEYowIoIiIiEmNUAEVERERijAqgiIiISIxRARQRERGJMSqAIiIiIjFGBVBE\nREQkxqgAioiIiMQYFUARERGRGKMCKCIiIhJjVABFREREYowKoIiIiEiMUQEUERERiTEqgCIiIiIx\nRgVQREREJMaoAIqIiIjEGBVAERERkRijAigiIiISY1QARURERGKMCqCIiIhIjFEBFBEREYkxKoAi\nIiIiMUYFUERERCTGqACKiIiIxBgVQBEREZEYowIoIiIiEmNUAEVERERijAqgiIiISIxRARQRERGJ\nMSqAIiIiIjFGBVBEREQkxqgAioiIiMQYFUARERGRGKMCKCIiIhJjVABFREREYkyc6QAiIuXlui55\neXnk5uaSk5Pz049Df37o54MHDwb189auXZvExETq1Knzq58P/ahTpw4JCQk4jhPUzysiEioqgCJi\nRHFxMfv37yc1NZW0tDQyMzN/VeJycnLIzsnmx5wfyc3JJTc3l4L8giN+PKuGhV3bxqpt4df0g5rV\nKrTwD/p4Bz38oiN/7NoJtUlISKBOYh3qJtalXmK9X5XExMRE6tevT9OmTUlOTqZx48bExenLsIhU\nP33lEZGQKCgoIC0tjbS0tJ9KXlpaGntT95KSmkLmgUx8/+cyZde2seNtqA1eLQ+vlge1gSZACwJ/\nXBuo9Ys//sWf+3E+Lm7o/8aKgYNAQcnPB3/+84MHD3Lw4EEyDmYE/vsfwE61sQtsOAhevod30Pvp\n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\nf+dovcu6C8jPAAAAAElFTkSuQmCC\n",
-       "text": [
-        "<matplotlib.figure.Figure at 0x60e9bb0>"
-       ]
-      },
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 33,
-       "text": [
-        "<ExecutionResult: 3 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 33
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "richtext = vt.load_vistrail('out_html.xml')\n",
-      "richtext.select_latest_version()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 34
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "This one uses RichTextOutput:"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "richtext.execute()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "this is a <strong>test</strong> hehe"
-       ],
-       "metadata": {},
-       "output_type": "display_data",
-       "text": [
-        "<IPython.core.display.HTML at 0x5f9e850>"
-       ]
-      },
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 35,
-       "text": [
-        "<ExecutionResult: 2 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 35
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tbl = vt.load_vistrail('table.xml')\n",
-      "tbl.select_latest_version()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 36
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "TableOutput:"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "tbl.execute()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "html": [
-        "<!DOCTYPE html>\n",
-        "<html>\n",
-        "  <head>\n",
-        "    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" />\n",
-        "    <title>Exported table</title>\n",
-        "    <style type=\"text/css\">\n",
-        "table { border-collapse: collapse; }\n",
-        "td, th { border: 1px solid black; }\n",
-        "    </style>\n",
-        "  </head>\n",
-        "  <body>\n",
-        "    <table>\n",
-        "<tr>\n",
-        "  <th>a</th>\n",
-        "  <th>b</th>\n",
-        "</tr>\n",
-        "<tr>\n",
-        "  <td>1</td>\n",
-        "  <td>4</td>\n",
-        "</tr>\n",
-        "<tr>\n",
-        "  <td>2</td>\n",
-        "  <td>5</td>\n",
-        "</tr>\n",
-        "<tr>\n",
-        "  <td>3</td>\n",
-        "  <td>6</td>\n",
-        "</tr>\n",
-        "    </table>\n",
-        "  </body>\n",
-        "</html>\n"
-       ],
-       "metadata": {},
-       "output_type": "display_data",
-       "text": [
-        "<IPython.core.display.HTML at 0x5faf530>"
-       ]
-      },
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 37,
-       "text": [
-        "<ExecutionResult: 2 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 37
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "render = vt.load_vistrail('brain_output.xml')\n",
-      "render.select_latest_version()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [],
-     "prompt_number": 38
-    },
-    {
-     "cell_type": "markdown",
-     "metadata": {},
-     "source": [
-      "And vtkRendererOutput:"
-     ]
-    },
-    {
-     "cell_type": "code",
-     "collapsed": false,
-     "input": [
-      "render.execute()"
-     ],
-     "language": "python",
-     "metadata": {},
-     "outputs": [
-      {
-       "metadata": {
-        "png": {
-         "height": 480,
-         "width": 640
-        }
-       },
-       "output_type": "display_data",
-       "png": "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\nAElFTkSuQmCC\n",
-       "text": [
-        "<IPython.core.display.Image at 0x12f7c7d0>"
-       ]
-      },
-      {
-       "metadata": {},
-       "output_type": "pyout",
-       "prompt_number": 38,
-       "text": [
-        "<ExecutionResult: 16 modules>"
-       ]
-      }
-     ],
-     "prompt_number": 39
-    }
-   ],
-   "metadata": {}
-  }
- ]
-}
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "# Sets up import path, if you're running from the source distrib\n",
+    "import os, sys\n",
+    "sys.path.append(os.path.join(os.getcwd(), '../..'))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "import traceback"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "# VisTrails API example\n",
+    "\n",
+    "This notebook showcases the new API. Inlined are some comments and explanations."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "import vistrails as vt"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "The new API is exposed under the top-level `vistrails` package. The moment you use one of the API functions, like `load_vistrail()`, it will create an application and load the same configuration that the VisTrails application uses (although it will automatically enable packages the moment you need them)."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 4,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "vt.ipython_mode(True)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "This explicitely requests IPythonMode to be enabled on output modules, so that pipeline executions will put results on the notebook (similarly to `%matplotlib inline` for matplotlib plots)."
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## `Vistrail`s and `Pipeline`s\n",
+    "\n",
+    "You can get a `Vistrail` through `load_vistrail()`."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 5,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "vistrail = vt.load_vistrail('simplemath.vt')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "A `Vistrail` is a whole version tree, where each version is a different pipeline. From it we can get `Pipeline`s, but it is also stateful (i.e. has a current version); this is useful for editing (creating new versions from the current one). It also provides the interface that `Pipeline` has, implicitely acting on the `current_pipeline`.\n",
+    "\n",
+    "If GraphViz is available, `Vistrail` and `Pipeline` will be rendered in the IPython notebook."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"158pt\" height=\"116pt\"\r\n",
+       " viewBox=\"0.00 0.00 158.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 155,-112 155,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 28 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>28</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-18\" rx=\"75.0904\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"75\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added annotation</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;28 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;28</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M75,-71.6966C75,-63.9827 75,-54.7125 75,-46.1124\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"78.5001,-46.1043 75,-36.1043 71.5001,-46.1044 78.5001,-46.1043\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: simplemath.vt, version -1, not changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: simplemath.vt, version -1, not changed>"
+      ]
+     },
+     "execution_count": 6,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "vistrail"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 7,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "vistrail.select_latest_version()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 8,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"158pt\" height=\"116pt\"\r\n",
+       " viewBox=\"0.00 0.00 158.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 155,-112 155,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"75\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 28 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>28</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"red\" cx=\"75\" cy=\"-18\" rx=\"75.0904\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"75\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added annotation</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;28 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;28</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M75,-71.6966C75,-63.9827 75,-54.7125 75,-46.1124\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"78.5001,-46.1043 75,-36.1043 71.5001,-46.1044 78.5001,-46.1043\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: simplemath.vt, version 28, not changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: simplemath.vt, version 37, not changed>"
+      ]
+     },
+     "execution_count": 8,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "vistrail"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 9,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
+       "<svg width=\"102pt\" height=\"44pt\"\r\n",
+       " viewBox=\"0.00 0.00 102.00 44.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 40)\">\r\n",
+       "<title>_anonymous_0</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-40 99,-40 99,5 -4,5\"/>\r\n",
+       "<!-- module0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-7 8,-28 87,-28 87,-7 8,-7\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"8,-7 8,-28 87,-28 87,-7 8,-7\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"11.5\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">PythonCalc</text>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Pipeline: 1 modules, 0 connections&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Pipeline: 1 modules, 0 connections>"
+      ]
+     },
+     "execution_count": 9,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "vistrail.get_pipeline(2)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "# Packages\n",
+    "\n",
+    "Only `basic_modules` (and `abstractions`?) are loaded on initialization, so that using the API stays fast. A package might be auto-enabled when it is requested, which is efficient and convenient.\n",
+    "\n",
+    "Note that `load_package()` only accepts package identifiers."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 10,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<Package: org.vistrails.vistrails.tabledata, 23 modules>"
+      ]
+     },
+     "execution_count": 10,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "tabledata = vt.load_package('org.vistrails.vistrails.tabledata')\n",
+    "tabledata"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "You can get `Module`s from the package using the dot or bracket syntax. These modules are \"dangling\" modules, not yet instanciated in a specific pipeline/vistrail.\n",
+    "\n",
+    "These will be useful once editing pipelines is added to the API."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<Namespace convert of package org.vistrails.vistrails.tabledata>"
+      ]
+     },
+     "execution_count": 11,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "tabledata.convert"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 12,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "from vistrails.core.modules.module_registry import MissingModule\n",
+    "try:\n",
+    "    tabledata['convert']  # can't get namespaces this way, use a dot\n",
+    "except MissingModule:\n",
+    "    pass\n",
+    "else:\n",
+    "    assert False"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 13,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(<Module class 'BuildTable' from org.vistrails.vistrails.tabledata>,\n",
+       " <Module class 'BuildTable' from org.vistrails.vistrails.tabledata>)"
+      ]
+     },
+     "execution_count": 13,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "tabledata.BuildTable, tabledata['BuildTable']"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 14,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(<Module class 'CSVFile' from org.vistrails.vistrails.tabledata>,\n",
+       " <Module class 'CSVFile' from org.vistrails.vistrails.tabledata>)"
+      ]
+     },
+     "execution_count": 14,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "tabledata.read.CSVFile, tabledata['read|CSVFile']"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "# Execution\n",
+    "\n",
+    "In addition to executing a `Pipeline` or `Vistrail`, you can easily pass values in on InputPort modules (to use subworkflows as Python functions) and get results out (either on OutputPort modules or any port of any module).\n",
+    "\n",
+    "Execution returns a `Results` object from which you can get all of this. In addition, output modules (such as matplotlib's MplFigureOutput) will output to the IPython notebook if possible."
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## Gets output"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 15,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"154pt\" height=\"188pt\"\r\n",
+       " viewBox=\"0.00 0.00 154.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 151,-184 151,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 1 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>1</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"red\" cx=\"73\" cy=\"-90\" rx=\"64.4914\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"73\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added module</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;1 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;1</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M73,-143.697C73,-135.983 73,-126.712 73,-118.112\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-118.104 73,-108.104 69.5001,-118.104 76.5001,-118.104\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 5 -->\r\n",
+       "<g id=\"node3\" class=\"node\"><title>5</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-18\" rx=\"73.1654\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"73\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added parameter</text>\r\n",
+       "</g>\r\n",
+       "<!-- 1&#45;&gt;5 -->\r\n",
+       "<g id=\"edge4\" class=\"edge\"><title>1&#45;&gt;5</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M73,-71.6966C73,-63.9827 73,-54.7125 73,-46.1124\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-46.1043 73,-36.1043 69.5001,-46.1044 76.5001,-46.1043\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: outputs.vt, version 1, not changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: outputs.vt, version 1, not changed>"
+      ]
+     },
+     "execution_count": 15,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "outputs = vt.load_vistrail('outputs.vt')\n",
+    "outputs.select_version(1)\n",
+    "outputs"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 16,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "Traceback (most recent call last):\n",
+      "  File \"<ipython-input-16-979bf6416e43>\", line 3, in <module>\n",
+      "    result = outputs.execute()\n",
+      "  File \"/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/api.py\", line 259, in execute\n",
+      "    return self.current_pipeline.execute(*args, **kwargs)\n",
+      "  File \"/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/api.py\", line 482, in execute\n",
+      "    raise ExecutionErrors(self, result)\n",
+      "ExecutionErrors: Pipeline execution failed: 1 error:\n",
+      "0: Missing value from port value\n"
+     ]
+    }
+   ],
+   "source": [
+    "# Errors\n",
+    "try:\n",
+    "    result = outputs.execute()\n",
+    "except vt.ExecutionErrors:\n",
+    "    traceback.print_exc()\n",
+    "else:\n",
+    "    assert False"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 17,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 2 modules>"
+      ]
+     },
+     "execution_count": 17,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "# Results\n",
+    "outputs.select_latest_version()\n",
+    "result = outputs.execute()\n",
+    "result"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 18,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"154pt\" height=\"116pt\"\r\n",
+       " viewBox=\"0.00 0.00 154.00 116.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 112)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-112 151,-112 151,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"73\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 5 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>5</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"red\" cx=\"73\" cy=\"-18\" rx=\"73.1654\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"73\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Added parameter</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;5 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;5</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M73,-71.6966C73,-63.9827 73,-54.7125 73,-46.1124\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"76.5001,-46.1043 73,-36.1043 69.5001,-46.1044 76.5001,-46.1043\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: outputs.vt, version 5, changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: outputs.vt, version 5, changed>"
+      ]
+     },
+     "execution_count": 18,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "outputs"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 19,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
+       "<svg width=\"102pt\" height=\"152pt\"\r\n",
+       " viewBox=\"0.00 0.00 102.00 152.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 148)\">\r\n",
+       "<title>_anonymous_0</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-148 99,-148 99,5 -4,5\"/>\r\n",
+       "<!-- module0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"24,-118 24,-139 69,-139 69,-118 24,-118\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"24,-118 24,-139 69,-139 69,-118 24,-118\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"27.5\" y=\"-125.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">String</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"26,-96 26,-116 67,-116 67,-96 26,-96\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"32\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
+       "</g>\r\n",
+       "<!-- module1 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>module1</title>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"10,-26 10,-47 84,-47 84,-26 10,-26\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"13.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-4 8,-24 86,-24 86,-4 8,-4\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"8,-4 8,-24 86,-24 86,-4 8,-4\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"12\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
+       "</g>\r\n",
+       "<!-- module0&#45;&gt;module1 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>module0:out0&#45;&gt;module1:in0</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M47,-95C47,-78.0278 47,-71.398 47,-58.3042\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"50.5001,-58 47,-48 43.5001,-58 50.5001,-58\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Pipeline: 2 modules, 1 connections; outputs: msg&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Pipeline: 2 modules, 1 connections; outputs: msg>"
+      ]
+     },
+     "execution_count": 19,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "outputs.current_pipeline"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "This gets the value on any output port of any module (no need to insert OutputPort or GenericOutput modules, if you know how to find the module):"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 20,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "{'self': <vistrails.core.modules.basic_modules.String at 0x5bd7bb0>,\n",
+       " 'value': 'Hello, world',\n",
+       " 'value_as_string': 'Hello, world'}"
+      ]
+     },
+     "execution_count": 20,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "result.module_output(0)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "This gets the value passed to an OutputPort module, using the OutputPort's name:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 21,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "'Hello, world'"
+      ]
+     },
+     "execution_count": 21,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "result.output_port('msg')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## Sets inputs"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 22,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: _anonymous_0 Pages: 1 -->\r\n",
+       "<svg width=\"247pt\" height=\"266pt\"\r\n",
+       " viewBox=\"0.00 0.00 247.00 266.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 262)\">\r\n",
+       "<title>_anonymous_0</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-262 244,-262 244,5 -4,5\"/>\r\n",
+       "<!-- module0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>module0</title>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"18,-140 18,-161 61,-161 61,-140 18,-140\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"21.5\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value2</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"61,-140 61,-161 103,-161 103,-140 61,-140\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"64\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value1</text>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"16,-118 16,-138 105,-138 105,-118 16,-118\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"16,-118 16,-138 105,-138 105,-118 16,-118\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"56\" y=\"-124.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">+</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"18,-96 18,-116 103,-116 103,-96 18,-96\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"46\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
+       "</g>\r\n",
+       "<!-- module4 -->\r\n",
+       "<g id=\"node5\" class=\"node\"><title>module4</title>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"24,-26 24,-47 98,-47 98,-26 24,-26\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"27.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"22,-4 22,-24 100,-24 100,-4 22,-4\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"22,-4 22,-24 100,-24 100,-4 22,-4\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"26\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
+       "</g>\r\n",
+       "<!-- module0&#45;&gt;module4 -->\r\n",
+       "<g id=\"edge10\" class=\"edge\"><title>module0:out0&#45;&gt;module4:in0</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M61,-95C61,-78.0278 61,-71.398 61,-58.3042\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"64.5001,-58 61,-48 57.5001,-58 64.5001,-58\"/>\r\n",
+       "</g>\r\n",
+       "<!-- module1 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>module1</title>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"153,-232 153,-253 231,-253 231,-232 153,-232\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"153,-232 153,-253 231,-253 231,-232 153,-232\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"160\" y=\"-239.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">First input</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"155,-210 155,-230 229,-230 229,-210 155,-210\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"158.5\" y=\"-216.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
+       "</g>\r\n",
+       "<!-- module1&#45;&gt;module0 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>module1:out0&#45;&gt;module0:in1</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M154,-220C138.171,-220 127.099,-171.783 112.83,-155.962\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"114.432,-152.848 104,-151 111.003,-158.95 114.432,-152.848\"/>\r\n",
+       "</g>\r\n",
+       "<!-- module3 -->\r\n",
+       "<g id=\"node4\" class=\"node\"><title>module3</title>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"141,-140 141,-161 184,-161 184,-140 141,-140\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"144.5\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value2</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"184,-140 184,-161 226,-161 226,-140 184,-140\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"187\" y=\"-147.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value1</text>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"139,-118 139,-138 228,-138 228,-118 139,-118\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"139,-118 139,-138 228,-138 228,-118 139,-118\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"179.5\" y=\"-124.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">*</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"141,-96 141,-116 226,-116 226,-96 141,-96\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"169\" y=\"-102.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">value</text>\r\n",
+       "</g>\r\n",
+       "<!-- module1&#45;&gt;module3 -->\r\n",
+       "<g id=\"edge6\" class=\"edge\"><title>module1:out0&#45;&gt;module3:in1</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M192,-209C192,-191.221 200.748,-185.568 203.892,-172.147\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"207.393,-172.321 205,-162 200.435,-171.561 207.393,-172.321\"/>\r\n",
+       "</g>\r\n",
+       "<!-- module2 -->\r\n",
+       "<g id=\"node3\" class=\"node\"><title>module2</title>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"8,-232 8,-253 94,-253 94,-232 8,-232\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"8,-232 8,-253 94,-253 94,-232 8,-232\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"11.5\" y=\"-239.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">Second input</text>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"10,-210 10,-230 92,-230 92,-210 10,-210\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"17.5\" y=\"-216.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
+       "</g>\r\n",
+       "<!-- module2&#45;&gt;module0 -->\r\n",
+       "<g id=\"edge4\" class=\"edge\"><title>module2:out0&#45;&gt;module0:in0</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M51,-209C51,-191.315 42.925,-185.525 40.0231,-172.115\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"43.4887,-171.597 39,-162 36.5243,-172.301 43.4887,-171.597\"/>\r\n",
+       "</g>\r\n",
+       "<!-- module2&#45;&gt;module3 -->\r\n",
+       "<g id=\"edge8\" class=\"edge\"><title>module2:out0&#45;&gt;module3:in0</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M93,-220C108.364,-220 117.79,-172.68 131.113,-156.414\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"133.281,-159.192 140,-151 129.639,-153.214 133.281,-159.192\"/>\r\n",
+       "</g>\r\n",
+       "<!-- module5 -->\r\n",
+       "<g id=\"node6\" class=\"node\"><title>module5</title>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"147,-26 147,-47 221,-47 221,-26 147,-26\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"150.5\" y=\"-33.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">InternalPipe</text>\r\n",
+       "<polygon fill=\"grey\" stroke=\"grey\" points=\"145,-4 145,-24 223,-24 223,-4 145,-4\"/>\r\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"145,-4 145,-24 223,-24 223,-4 145,-4\"/>\r\n",
+       "<text text-anchor=\"start\" x=\"149\" y=\"-10.8\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">OutputPort</text>\r\n",
+       "</g>\r\n",
+       "<!-- module3&#45;&gt;module5 -->\r\n",
+       "<g id=\"edge12\" class=\"edge\"><title>module3:out0&#45;&gt;module5:in0</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M184,-95C184,-78.0278 184,-71.398 184,-58.3042\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"187.5,-58 184,-48 180.5,-58 187.5,-58\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Pipeline: 6 modules, 6 connections; inputs: in_a, in_b; outputs: out_times, out_plus&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Pipeline: 6 modules, 6 connections; inputs: in_a, in_b; outputs: out_times, out_plus>"
+      ]
+     },
+     "execution_count": 22,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "pipeline = vistrail.current_pipeline\n",
+    "pipeline"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 23,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<Module 'InputPort' from org.vistrails.vistrails.basic, id 1, name \"First input\">"
+      ]
+     },
+     "execution_count": 23,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "in_a = pipeline.get_input('in_a')\n",
+    "assert (in_a == pipeline.get_module('First input')) is True\n",
+    "in_a"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "We need to provide value to this workflow, for its two InputPort modules. Input can be supplied to `execute()` in two ways:\n",
+    "* either by using `module_obj == value`, where module_obj is a module obtained from the pipeline, using `get_input()` or `get_module()`;\n",
+    "* or by using `module_name=value`, where module_name is the name set on an InputPort module\n",
+    "\n",
+    "Note that, to Python, `module_obj` is a variable and must be bound to a value (of type Module), whereas module_name is a keyword-parameter name."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 24,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "result = pipeline.execute(in_a == 2, in_b=4)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 25,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "(8.0, 6.0)"
+      ]
+     },
+     "execution_count": 25,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "result.output_port('out_times'), result.output_port('out_plus')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## Other example"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 26,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "im = vt.load_vistrail('imagemagick.vt')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 27,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"143pt\" height=\"188pt\"\r\n",
+       " viewBox=\"0.00 0.00 143.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 140,-184 140,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 6 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>6</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"red\" cx=\"65\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"65\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">read</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;6 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;6</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M65,-143.697C65,-135.983 65,-126.712 65,-118.112\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"68.5001,-118.104 65,-108.104 61.5001,-118.104 68.5001,-118.104\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 14 -->\r\n",
+       "<g id=\"node3\" class=\"node\"><title>14</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"27\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">blur</text>\r\n",
+       "</g>\r\n",
+       "<!-- 6&#45;&gt;14 -->\r\n",
+       "<g id=\"edge4\" class=\"edge\"><title>6&#45;&gt;14</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M56.1865,-72.7646C51.5823,-64.2831 45.845,-53.7144 40.6786,-44.1974\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"43.6126,-42.266 35.7657,-35.1473 37.4607,-45.6057 43.6126,-42.266\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 21 -->\r\n",
+       "<g id=\"node4\" class=\"node\"><title>21</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"104\" cy=\"-18\" rx=\"31.2735\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"104\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">edges</text>\r\n",
+       "</g>\r\n",
+       "<!-- 6&#45;&gt;21 -->\r\n",
+       "<g id=\"edge6\" class=\"edge\"><title>6&#45;&gt;21</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M74.0454,-72.7646C78.7033,-64.4043 84.4911,-54.0159 89.7338,-44.6059\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"92.9232,-46.0726 94.7328,-35.6334 86.8083,-42.6656 92.9232,-46.0726\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: imagemagick.vt, version 6 (tag read), not changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: imagemagick.vt, version 6 (tag read), not changed>"
+      ]
+     },
+     "execution_count": 27,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "im.select_version('read')\n",
+    "im"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "Note that if you print a File value, IPython will try to render it."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 28,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIcAAACHCAYAAAA850oKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAK\nTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQ\nWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec\n5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28A\nAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0\nST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaO\nWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHi\nwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryM\nAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0l\nYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHi\nNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYA\nQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6c\nwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBie\nwhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1c\nQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqO\nY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hM\nWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgoh\nJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSU\nEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/p\ndLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Y\nb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7O\nUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsb\ndi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W\n7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83\nMDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxr\nPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW\n2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1\nU27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd\n8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H0\n8PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+H\nvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsG\nLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjg\n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\nAABJRU5ErkJggg==\n",
+      "text/plain": [
+       "PathObject('vistrails_logo.png')"
+      ]
+     },
+     "execution_count": 28,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "im.execute().output_port('result')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 29,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\r\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\r\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n",
+       "<!-- Generated by graphviz version 2.28.0 (20110507.0327)\r\n",
+       " -->\r\n",
+       "<!-- Title: G Pages: 1 -->\r\n",
+       "<svg width=\"143pt\" height=\"188pt\"\r\n",
+       " viewBox=\"0.00 0.00 143.00 188.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n",
+       "<g id=\"graph1\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 184)\">\r\n",
+       "<title>G</title>\r\n",
+       "<polygon fill=\"white\" stroke=\"white\" points=\"-4,5 -4,-184 140,-184 140,5 -4,5\"/>\r\n",
+       "<!-- 0 -->\r\n",
+       "<g id=\"node1\" class=\"node\"><title>0</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-162\" rx=\"27\" ry=\"18\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 6 -->\r\n",
+       "<g id=\"node2\" class=\"node\"><title>6</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"65\" cy=\"-90\" rx=\"27\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"65\" y=\"-86.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">read</text>\r\n",
+       "</g>\r\n",
+       "<!-- 0&#45;&gt;6 -->\r\n",
+       "<g id=\"edge2\" class=\"edge\"><title>0&#45;&gt;6</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M65,-143.697C65,-135.983 65,-126.712 65,-118.112\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"68.5001,-118.104 65,-108.104 61.5001,-118.104 68.5001,-118.104\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 14 -->\r\n",
+       "<g id=\"node3\" class=\"node\"><title>14</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"red\" cx=\"27\" cy=\"-18\" rx=\"27\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"27\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">blur</text>\r\n",
+       "</g>\r\n",
+       "<!-- 6&#45;&gt;14 -->\r\n",
+       "<g id=\"edge4\" class=\"edge\"><title>6&#45;&gt;14</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M56.1865,-72.7646C51.5823,-64.2831 45.845,-53.7144 40.6786,-44.1974\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"43.6126,-42.266 35.7657,-35.1473 37.4607,-45.6057 43.6126,-42.266\"/>\r\n",
+       "</g>\r\n",
+       "<!-- 21 -->\r\n",
+       "<g id=\"node4\" class=\"node\"><title>21</title>\r\n",
+       "<ellipse fill=\"none\" stroke=\"black\" cx=\"104\" cy=\"-18\" rx=\"31.2735\" ry=\"18\"/>\r\n",
+       "<text text-anchor=\"middle\" x=\"104\" y=\"-14.3\" font-family=\"Times New Roman,serif\" font-size=\"14.00\">edges</text>\r\n",
+       "</g>\r\n",
+       "<!-- 6&#45;&gt;21 -->\r\n",
+       "<g id=\"edge6\" class=\"edge\"><title>6&#45;&gt;21</title>\r\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M74.0454,-72.7646C78.7033,-64.4043 84.4911,-54.0159 89.7338,-44.6059\"/>\r\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"92.9232,-46.0726 94.7328,-35.6334 86.8083,-42.6656 92.9232,-46.0726\"/>\r\n",
+       "</g>\r\n",
+       "</g>\r\n",
+       "</svg>\r\n",
+       "<pre>&lt;Vistrail: imagemagick.vt, version 14 (tag blur), changed&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Vistrail: imagemagick.vt, version 14 (tag blur), changed>"
+      ]
+     },
+     "execution_count": 29,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "im.select_version('blur')\n",
+    "im"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 30,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "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\n",
+      "text/plain": [
+       "PathObject('/tmp/vt_tmpA0IiHV/vt_tmpnA__3c.png')"
+      ]
+     },
+     "execution_count": 30,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "im.execute().output_port('result')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 31,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "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\n",
+      "text/plain": [
+       "PathObject('/tmp/vt_tmpA0IiHV/vt_tmp7kISgw.png')"
+      ]
+     },
+     "execution_count": 31,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "im.select_version('edges')\n",
+    "im.execute().output_port('result')"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "## Output mode"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 32,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "mpl = vt.load_vistrail('../matplotlib/pie_ex1.vt')\n",
+    "mpl.select_latest_version()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "This workflow uses MplFigureOutput, which outputs to the IPython notebook if available (and since the spreadsheet is not running)."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 33,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "name": "stderr",
+     "output_type": "stream",
+     "text": [
+      "WARNING:vistrails.logger:/home/remram/Documents/programming/dat/vistrails/examples/api/../../vistrails/core/modules/vistrails_module.py, line 1724\n",
+      "UserWarning: A Module instance was used as data: module=MplFigure, port=self, object=<vistrails.packages.matplotlib.bases.MplFigure object at 0x7f8b4028ef10>\n",
+      "  UserWarning)\n",
+      "\n"
+     ]
+    },
+    {
+     "data": {
+      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAoAAAAH0CAYAAACtlpxpAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz\nAAAPYQAAD2EBqD+naQAAIABJREFUeJzs3Xd4VuXhxvHvOSeMhEAYAgEVREEQEZTlQHGgiAJurVtU\nQDaKuFulra1otdpaS0WqOFBEVH7gAkVAUKaAyJaNkARCTGIGGeec3x9vcFTIfN8877g/18WFtpjc\ntpjcnnE/1rx583xEREREJGbYpgOIiIiISPVSARQRERGJMSqAIiIiIjFGBVBEREQkxqgAioiIiMQY\nFUARERGRGKMCKCIiIhJjVABFREREYowKoIiIiEiMUQEUERERiTEqgCIiIiIxRgVQREREJMaoAIqI\niIjEGBVAERERkRijAigiIiISY1QARURERGKMCqCIiIhIjFEBFBEREYkxKoAiIiIiMUYFUERERCTG\nqACKiIiIxBgVQBEREZEYowIoIiIiEmNUAEVERERijAqgiIiISIxRARQRERGJMSqAIiIiIjFGBVBE\nREQkxqgAioiIiMQYFUARERGRGKMCKCIiIhJjVABFREREYowKoIiIiEiMUQEUERERiTEqgCIiIiIx\nRgVQREREJMaoAIqIiIjEGBVAERERkRijAigiIiISY1QARURERGKMCqCIiIhIjFEBFBEREYkxKoAi\nIiIiMUYFUERERCTGqACKiIiIxBgVQBEREZEYowIoIiIiEmNUAEVERERijAqgiIiISIxRARQRERGJ\nMSqAIiIiIjFGBVBEREQkxqgAioiIiMQYFUARERGRGKMCKCIiIhJjVABFREREYkyc6QAiIuXlui55\neXnk5uaSk5Pz049Df37o54MHDwb189auXZvExETq1Knzq58P/ahTpw4JCQk4jhPUzysiEioqgCJi\nRHFxMfv37yc1NZW0tDQyMzN/VeJycnLIzsnmx5wfyc3JJTc3l4L8giN+PKuGhV3bxqpt4df0g5rV\nKrTwD/p4Bz38oiN/7NoJtUlISKBOYh3qJtalXmK9X5XExMRE6tevT9OmTUlOTqZx48bExenLsIhU\nP33lEZGQKCgoIC0tjbS0tJ9KXlpaGntT95KSmkLmgUx8/+cyZde2seNtqA1eLQ+vlge1gSZACwJ/\nXBuo9Ys//sWf+3E+Lm7o/8aKgYNAQcnPB3/+84MHD3Lw4EEyDmYE/vsfwE61sQtsOAhevod30Pvp\n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\nf+dovcu6C8jPAAAAAElFTkSuQmCC\n",
+      "text/plain": [
+       "<matplotlib.figure.Figure at 0x60e9bb0>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    },
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 3 modules>"
+      ]
+     },
+     "execution_count": 33,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "mpl.execute()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 34,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "richtext = vt.load_vistrail('out_html.xml')\n",
+    "richtext.select_latest_version()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "This one uses RichTextOutput:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 35,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "this is a <strong>test</strong> hehe"
+      ],
+      "text/plain": [
+       "<IPython.core.display.HTML at 0x5f9e850>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    },
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 2 modules>"
+      ]
+     },
+     "execution_count": 35,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "richtext.execute()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 36,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "tbl = vt.load_vistrail('table.xml')\n",
+    "tbl.select_latest_version()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "TableOutput:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 37,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<!DOCTYPE html>\n",
+       "<html>\n",
+       "  <head>\n",
+       "    <meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" />\n",
+       "    <title>Exported table</title>\n",
+       "    <style type=\"text/css\">\n",
+       "table { border-collapse: collapse; }\n",
+       "td, th { border: 1px solid black; }\n",
+       "    </style>\n",
+       "  </head>\n",
+       "  <body>\n",
+       "    <table>\n",
+       "<tr>\n",
+       "  <th>a</th>\n",
+       "  <th>b</th>\n",
+       "</tr>\n",
+       "<tr>\n",
+       "  <td>1</td>\n",
+       "  <td>4</td>\n",
+       "</tr>\n",
+       "<tr>\n",
+       "  <td>2</td>\n",
+       "  <td>5</td>\n",
+       "</tr>\n",
+       "<tr>\n",
+       "  <td>3</td>\n",
+       "  <td>6</td>\n",
+       "</tr>\n",
+       "    </table>\n",
+       "  </body>\n",
+       "</html>\n"
+      ],
+      "text/plain": [
+       "<IPython.core.display.HTML at 0x5faf530>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    },
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 2 modules>"
+      ]
+     },
+     "execution_count": 37,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "tbl.execute()"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 38,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "render = vt.load_vistrail('brain_output.xml')\n",
+    "render.select_latest_version()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "And vtkRendererOutput:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 39,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "image/png": "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\nAElFTkSuQmCC\n",
+      "text/plain": [
+       "<IPython.core.display.Image at 0x12f7c7d0>"
+      ]
+     },
+     "metadata": {
+      "image/png": {
+       "height": 480,
+       "width": 640
+      }
+     },
+     "output_type": "display_data"
+    },
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 16 modules>"
+      ]
+     },
+     "execution_count": 38,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "render.execute()"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "# Pipeline manipulation\n",
+    "\n",
+    "The API wrapper doesn't currently provide easier methods to manipulate pipelines. This is mainly because these operations need all of the VisTrails concepts anyway.\n",
+    "\n",
+    "You can however call the controller methods on vistrail.controller directly, using modules obtained through `load_package()`."
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 39,
+   "metadata": {
+    "collapsed": true
+   },
+   "outputs": [],
+   "source": [
+    "import urllib2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 40,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [],
+   "source": [
+    "basic = vt.load_package('org.vistrails.vistrails.basic')\n",
+    "pythoncalc = vt.load_package('org.vistrails.vistrails.pythoncalc')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 41,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "<vistrails.core.vistrail.connection.Connection at 0x1046a0fd0>"
+      ]
+     },
+     "execution_count": 41,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "new_vistrail = vt.Vistrail()\n",
+    "\n",
+    "# Simple Integer constant\n",
+    "data = new_vistrail.controller.add_module_from_descriptor(basic.Integer.descriptor)\n",
+    "new_vistrail.controller.update_function(data, 'value', ['8'])\n",
+    "\n",
+    "# PythonSource module\n",
+    "pythonblock = new_vistrail.controller.add_module_from_descriptor(basic.PythonSource.descriptor)\n",
+    "new_vistrail.controller.update_ports(pythonblock.id,\n",
+    "                                      [],\n",
+    "                                      [('output', 'computed_number', 'org.vistrails.vistrails.basic:Float')])\n",
+    "new_vistrail.controller.update_function(pythonblock, 'source', [urllib2.quote(r\"\"\"\\\n",
+    "number = 211856436.75\n",
+    "while number > 10.0:\n",
+    "    number /= 7.0\n",
+    "computed_number = number\n",
+    "\"\"\")])\n",
+    "\n",
+    "# Python calc that multiply inputs\n",
+    "multiply = new_vistrail.controller.add_module_from_descriptor(pythoncalc.PythonCalc.descriptor)\n",
+    "new_vistrail.controller.update_function(multiply, 'op', ['*'])\n",
+    "\n",
+    "# StandardOutput, here it will print to the notebook\n",
+    "output = new_vistrail.controller.add_module_from_descriptor(basic.StandardOutput.descriptor)\n",
+    "\n",
+    "# Add connections\n",
+    "new_vistrail.controller.add_connection(data.id, 'value', multiply.id, 'value1')\n",
+    "new_vistrail.controller.add_connection(pythonblock.id, 'computed_number', multiply.id, 'value2')\n",
+    "new_vistrail.controller.add_connection(multiply.id, 'value', output.id, 'value')"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 42,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "11"
+      ]
+     },
+     "execution_count": 42,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "new_vistrail.current_version"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 43,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "data": {
+      "text/html": [
+       "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n",
+       "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\"\n",
+       " \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n",
+       "<!-- Generated by graphviz version 2.38.0 (20140413.2041)\n",
+       " -->\n",
+       "<!-- Title: %3 Pages: 1 -->\n",
+       "<svg width=\"224pt\" height=\"267pt\"\n",
+       " viewBox=\"0.00 0.00 223.50 267.00\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n",
+       "<g id=\"graph0\" class=\"graph\" transform=\"scale(1 1) rotate(0) translate(4 263)\">\n",
+       "<title>%3</title>\n",
+       "<polygon fill=\"white\" stroke=\"none\" points=\"-4,4 -4,-263 219.5,-263 219.5,4 -4,4\"/>\n",
+       "<!-- module0 -->\n",
+       "<g id=\"node1\" class=\"node\"><title>module0</title>\n",
+       "<polygon fill=\"grey\" stroke=\"none\" points=\"157.5,-234 157.5,-255 207.5,-255 207.5,-234 157.5,-234\"/>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"157.5,-234 157.5,-255 207.5,-255 207.5,-234 157.5,-234\"/>\n",
+       "<text text-anchor=\"start\" x=\"160.5\" y=\"-241.8\" font-family=\"Times,serif\" font-weight=\"bold\" font-size=\"14.00\">Integer</text>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"159.5,-211 159.5,-232 205.5,-232 205.5,-211 159.5,-211\"/>\n",
+       "<text text-anchor=\"start\" x=\"167\" y=\"-217.8\" font-family=\"Times,serif\" font-size=\"14.00\">value</text>\n",
+       "</g>\n",
+       "<!-- module2 -->\n",
+       "<g id=\"node3\" class=\"node\"><title>module2</title>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"80.5,-141.5 80.5,-162.5 124.5,-162.5 124.5,-141.5 80.5,-141.5\"/>\n",
+       "<text text-anchor=\"start\" x=\"83.5\" y=\"-148.3\" font-family=\"Times,serif\" font-size=\"14.00\">value2</text>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"124.5,-141.5 124.5,-162.5 168.5,-162.5 168.5,-141.5 124.5,-141.5\"/>\n",
+       "<text text-anchor=\"start\" x=\"127.5\" y=\"-148.3\" font-family=\"Times,serif\" font-size=\"14.00\">value1</text>\n",
+       "<polygon fill=\"grey\" stroke=\"none\" points=\"78.5,-118.5 78.5,-139.5 170.5,-139.5 170.5,-118.5 78.5,-118.5\"/>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"78.5,-118.5 78.5,-139.5 170.5,-139.5 170.5,-118.5 78.5,-118.5\"/>\n",
+       "<text text-anchor=\"start\" x=\"89\" y=\"-126.3\" font-family=\"Times,serif\" font-weight=\"bold\" font-size=\"14.00\">PythonCalc</text>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"80.5,-95.5 80.5,-116.5 168.5,-116.5 168.5,-95.5 80.5,-95.5\"/>\n",
+       "<text text-anchor=\"start\" x=\"109\" y=\"-102.3\" font-family=\"Times,serif\" font-size=\"14.00\">value</text>\n",
+       "</g>\n",
+       "<!-- module0&#45;&gt;module2 -->\n",
+       "<g id=\"edge1\" class=\"edge\"><title>module0:out0&#45;&gt;module2:in1</title>\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M158.5,-221C135.759,-221 143.531,-197.178 145.913,-173.781\"/>\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"149.424,-173.683 146.5,-163.5 142.436,-173.284 149.424,-173.683\"/>\n",
+       "</g>\n",
+       "<!-- module1 -->\n",
+       "<g id=\"node2\" class=\"node\"><title>module1</title>\n",
+       "<polygon fill=\"grey\" stroke=\"none\" points=\"8.5,-234 8.5,-255 123.5,-255 123.5,-234 8.5,-234\"/>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"8.5,-234 8.5,-255 123.5,-255 123.5,-234 8.5,-234\"/>\n",
+       "<text text-anchor=\"start\" x=\"23.5\" y=\"-241.8\" font-family=\"Times,serif\" font-weight=\"bold\" font-size=\"14.00\">PythonSource</text>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"10.5,-211 10.5,-232 121.5,-232 121.5,-211 10.5,-211\"/>\n",
+       "<text text-anchor=\"start\" x=\"13.5\" y=\"-217.8\" font-family=\"Times,serif\" font-size=\"14.00\">computed_number</text>\n",
+       "</g>\n",
+       "<!-- module1&#45;&gt;module2 -->\n",
+       "<g id=\"edge2\" class=\"edge\"><title>module1:out0&#45;&gt;module2:in0</title>\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M122.5,-221C129.625,-221 123.234,-211.911 121.5,-205 117.527,-189.167 107.645,-185.079 103.937,-173.516\"/>\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"107.384,-172.902 102.5,-163.5 100.455,-173.896 107.384,-172.902\"/>\n",
+       "</g>\n",
+       "<!-- module3 -->\n",
+       "<g id=\"node4\" class=\"node\"><title>module3</title>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"73.5,-27 73.5,-48 175.5,-48 175.5,-27 73.5,-27\"/>\n",
+       "<text text-anchor=\"start\" x=\"109\" y=\"-33.8\" font-family=\"Times,serif\" font-size=\"14.00\">value</text>\n",
+       "<polygon fill=\"grey\" stroke=\"none\" points=\"71.5,-4 71.5,-25 177.5,-25 177.5,-4 71.5,-4\"/>\n",
+       "<polygon fill=\"none\" stroke=\"black\" points=\"71.5,-4 71.5,-25 177.5,-25 177.5,-4 71.5,-4\"/>\n",
+       "<text text-anchor=\"start\" x=\"74.5\" y=\"-11.8\" font-family=\"Times,serif\" font-weight=\"bold\" font-size=\"14.00\">StandardOutput</text>\n",
+       "</g>\n",
+       "<!-- module2&#45;&gt;module3 -->\n",
+       "<g id=\"edge3\" class=\"edge\"><title>module2:out0&#45;&gt;module3:in0</title>\n",
+       "<path fill=\"none\" stroke=\"black\" d=\"M124.5,-94.5C124.5,-78.2274 124.5,-71.7756 124.5,-59.3393\"/>\n",
+       "<polygon fill=\"black\" stroke=\"black\" points=\"128,-59 124.5,-49 121,-59 128,-59\"/>\n",
+       "</g>\n",
+       "</g>\n",
+       "</svg>\n",
+       "<pre>&lt;Pipeline: 4 modules, 3 connections&gt;</pre>"
+      ],
+      "text/plain": [
+       "<Pipeline: 4 modules, 3 connections>"
+      ]
+     },
+     "execution_count": 43,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "new_vistrail.current_pipeline"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 44,
+   "metadata": {
+    "collapsed": false
+   },
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "42.0\n"
+     ]
+    },
+    {
+     "data": {
+      "text/plain": [
+       "<ExecutionResult: 4 modules>"
+      ]
+     },
+     "execution_count": 44,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "new_vistrail.execute()"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "Python 2",
+   "language": "python",
+   "name": "python2"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 2
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython2",
+   "version": "2.7.11"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 0
+}
diff --git a/scripts/create_release_wiki_table.py b/scripts/create_release_wiki_table.py
index 3e9a193ba..1ccd3553f 100755
--- a/scripts/create_release_wiki_table.py
+++ b/scripts/create_release_wiki_table.py
@@ -43,11 +43,11 @@
 """
 from datetime import date
 #Release version
-VT_VERSION = "2.2.4"
-VT_REVISION = "048c632a7ac5"
+VT_VERSION = "2.x"
+VT_REVISION = "XXXXXXXXXXXX"
 #Sourceforge information
 SF_ROOT_URL = "http://downloads.sourceforge.net/project/vistrails/vistrails/"
-SF_FOLDER_NAME = "v2.2.4"
+SF_FOLDER_NAME = "v2.x"
 SF_DOWNLOAD_URL = "%s%s"%(SF_ROOT_URL,SF_FOLDER_NAME)
 #binaries names
 MAC_64_BIN = "vistrails-mac-10.6-intel-%s-%s.dmg"%(VT_VERSION, VT_REVISION)
diff --git a/scripts/dist/common/splash/splash.svg b/scripts/dist/common/splash/splash.svg
index 2944ba2a0..a0e735528 100644
--- a/scripts/dist/common/splash/splash.svg
+++ b/scripts/dist/common/splash/splash.svg
@@ -2917,7 +2917,7 @@
    font-size="85.0751"
    transform="scale(1.1065261,0.90372925)"><tspan
      style="font-size:55px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;fill:#000000;font-family:Franklin Gothic;-inkscape-font-specification:Franklin Gothic"
-     id="tspan4025">2.2.4</tspan></text>
+     id="tspan4025">2.x</tspan></text>
 
 
 <flowRoot
@@ -2940,7 +2940,7 @@
    font-size="85.0751"
    transform="scale(1.1065261,0.90372925)"><tspan
      style="font-size:52px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;fill:#ffffff;font-family:Franklin Gothic;-inkscape-font-specification:Franklin Gothic"
-     id="tspan4025-7">2.2.4</tspan></text>
+     id="tspan4025-7">2.x</tspan></text>
 
 
 <image
diff --git a/scripts/dist/mac/setup.py b/scripts/dist/mac/setup.py
index 0ec78852f..329c37fd3 100644
--- a/scripts/dist/mac/setup.py
+++ b/scripts/dist/mac/setup.py
@@ -42,8 +42,10 @@
 
 from setuptools import setup
 import sys
+
 sys.setrecursionlimit(1500)
-VERSION = '2.2.4'
+
+VERSION = '2.x'
 
 # Add VTK 6.2 to path
 sys.path.insert(0,'/Users/vistrails/src/VTK6/build/Wrapping/Python')
diff --git a/scripts/dist/source/make-vistrails-src-build.py b/scripts/dist/source/make-vistrails-src-build.py
index 47b5b706b..9d9a761df 100755
--- a/scripts/dist/source/make-vistrails-src-build.py
+++ b/scripts/dist/source/make-vistrails-src-build.py
@@ -34,13 +34,13 @@
 EXPORT_PATHS = "vistrails doc examples extensions scripts CHANGELOG LICENSE".split()
 
 # VisTrails Release Version
-VT_VERSION = '2.2.4'
+VT_VERSION = '2.x'
 
 # Branch to be used to build release
-VT_BRANCH = 'v2.2'
+VT_BRANCH = 'master'
 
 # Hash used in the release
-VT_HASH = '048c632a7ac5'
+VT_HASH = '0fddb5bfe72c'
 
 # Distribution Tarball name (Do not add ".tar.gz")
 #TARBALL_NAME = "vistrails-src-%s-%s" % (VT_VERSION, VT_HASH)
diff --git a/scripts/dist/windows/vistrails-gdal.iss b/scripts/dist/windows/vistrails-gdal.iss
index ec2d59526..0da7bbebc 100644
--- a/scripts/dist/windows/vistrails-gdal.iss
+++ b/scripts/dist/windows/vistrails-gdal.iss
@@ -38,7 +38,7 @@
 
 [Setup]
 AppName=VisTrails
-AppVerName=VisTrails 2.2.4
+AppVerName=VisTrails 2.x
 OutputBaseFilename=vistrails-gdal-setup
 DefaultGroupName=VisTrails
 
diff --git a/scripts/dist/windows/vistrails.iss b/scripts/dist/windows/vistrails.iss
index e29804f4c..048f3b698 100644
--- a/scripts/dist/windows/vistrails.iss
+++ b/scripts/dist/windows/vistrails.iss
@@ -38,7 +38,7 @@
 
 [Setup]
 AppName=VisTrails
-AppVerName=VisTrails 2.2.4
+AppVerName=VisTrails 2.x
 OutputBaseFilename=vistrails-setup
 DefaultGroupName=VisTrails
 
diff --git a/scripts/dist/windows/vistrailsx64-gdal.iss b/scripts/dist/windows/vistrailsx64-gdal.iss
index 60e54d14f..a87c3f15a 100644
--- a/scripts/dist/windows/vistrailsx64-gdal.iss
+++ b/scripts/dist/windows/vistrailsx64-gdal.iss
@@ -39,7 +39,7 @@
 
 [Setup]
 AppName=VisTrails x64
-AppVerName=VisTrails x64 2.2.4
+AppVerName=VisTrails x64 2.x
 OutputBaseFilename=vistrails-x64-gdal-setup
 DefaultGroupName=VisTrails x64
 
diff --git a/scripts/dist/windows/vistrailsx64.iss b/scripts/dist/windows/vistrailsx64.iss
index d8d3584c0..b44eab0c1 100644
--- a/scripts/dist/windows/vistrailsx64.iss
+++ b/scripts/dist/windows/vistrailsx64.iss
@@ -39,7 +39,7 @@
 
 [Setup]
 AppName=VisTrails x64
-AppVerName=VisTrails x64 2.2.4
+AppVerName=VisTrails x64 2.x
 ArchitecturesInstallIn64BitMode=x64
 OutputBaseFilename=vistrails-x64-setup
 DefaultGroupName=VisTrails x64
diff --git a/scripts/get_usersguide.py b/scripts/get_usersguide.py
index 8bc9edd5c..356403a7c 100755
--- a/scripts/get_usersguide.py
+++ b/scripts/get_usersguide.py
@@ -42,7 +42,7 @@
 
 this_dir = os.path.dirname(os.path.abspath(__file__))
 
-DOWNLOAD_URL = "http://www.vistrails.org/usersguide/v2.2/html/VisTrails.pdf"
+DOWNLOAD_URL = "http://www.vistrails.org/usersguide/dev/html/VisTrails.pdf"
 SAVE_TO = os.path.abspath(sys.argv[1]) if len(sys.argv) > 1 else this_dir
 
 # http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
diff --git a/setup.py b/setup.py
index 612845a83..8f3137516 100644
--- a/setup.py
+++ b/setup.py
@@ -43,7 +43,7 @@
 Who we are: http://www.vistrails.org/index.php/People
 """
 setup(name='vistrails',
-      version='2.2.4',
+      version='2.x',
       packages=packages,
       include_package_data=True,
       entry_points={
diff --git a/vistrails/api/__init__.py b/vistrails/api/__init__.py
index e8f9918cb..1cd1fede4 100644
--- a/vistrails/api/__init__.py
+++ b/vistrails/api/__init__.py
@@ -146,7 +146,7 @@ def add_module(x, y, identifier, name, namespace, controller=None):
         controller = get_current_controller()
     if controller.current_version==-1:
         controller.change_selected_version(0)
-    result = controller.add_module(x, y, identifier, name, namespace)
+    result = controller.add_module(identifier, name, namespace, x, y)
     controller.updatePipelineScene()
     result = controller.current_pipeline.modules[result.id]
     return result
diff --git a/vistrails/core/api.py b/vistrails/core/api.py
index 51a3e96b9..fd02bc791 100644
--- a/vistrails/core/api.py
+++ b/vistrails/core/api.py
@@ -654,7 +654,8 @@ def __init__(self, descriptor):
         self.descriptor = descriptor
 
     def __call__(self, *args, **kwargs):
-        return Module(self.descriptor, *args, **kwargs)
+        raise TypeError("Don't use module_class(....), call "
+                        "vistrail.add_module(module_class, ...) instead")
 
     def __repr__(self):
         return "<Module class %r from %s>" % (self.descriptor.name,
@@ -689,28 +690,16 @@ def __nonzero__(self):
 class Module(object):
     """Wrapper for a module, which can be in a Pipeline or not yet.
     """
-    module_id = None
-    pipeline = None
-
-    def __init__(self, descriptor, **kwargs):
+    def __init__(self, descriptor, pipeline, module_id):
+        if not (isinstance(module_id, (int, long)) and
+                isinstance(pipeline, Pipeline)):
+            raise TypeError
         self.descriptor = descriptor
-        if 'module_id' and 'pipeline' in kwargs:
-            self.module_id = kwargs.pop('module_id')
-            self.pipeline = kwargs.pop('pipeline')
-            if not (isinstance(self.module_id, (int, long)) and
-                    isinstance(self.pipeline, Pipeline)):
-                raise TypeError
-        elif 'module_id' in kwargs or 'pipeline' in kwargs:
-            raise TypeError("Module was given an id but no pipeline")
-
-        if kwargs:
-            raise TypeError("Module was given unexpected argument: %r" %
-                            next(iter(kwargs)))
+        self.pipeline = pipeline
+        self.module_id = module_id
 
     @property
     def module(self):
-        if self.module_id is None:
-            raise ValueError("This module is not part of a pipeline")
         return self.pipeline.pipeline.modules[self.module_id]
 
     @property
@@ -719,8 +708,6 @@ def module_class(self):
 
     @property
     def name(self):
-        if self.module_id is None:
-            raise ValueError("This module is not part of a pipeline")
         mod = self.pipeline.pipeline.modules[self.module_id]
         if '__desc__' in mod.db_annotations_key_index:
             return mod.get_annotation_by_key('__desc__').value
@@ -730,24 +717,17 @@ def name(self):
     def __repr__(self):
         desc = "<Module %r from %s" % (self.descriptor.name,
                                        self.descriptor.identifier)
-        if self.module_id is not None:
-            desc += ", id %d" % self.module_id
-            if self.pipeline is not None:
-                mod = self.pipeline.pipeline.modules[self.module_id]
-                if '__desc__' in mod.db_annotations_key_index:
-                    desc += (", name \"%s\"" %
-                             mod.get_annotation_by_key('__desc__').value)
+        desc += ", id %d" % self.module_id
+        mod = self.pipeline.pipeline.modules[self.module_id]
+        if '__desc__' in mod.db_annotations_key_index:
+            desc += (", name \"%s\"" %
+                     mod.get_annotation_by_key('__desc__').value)
         return desc + ">"
 
     def __eq__(self, other):
         if isinstance(other, Module):
-            if self.module_id is None:
-                return other.module_id is None
-            else:
-                if other.module_id is None:
-                    return False
-                return (self.module_id == other.module_id and
-                        self.pipeline == other.pipeline)
+            return (self.module_id == other.module_id and
+                    self.pipeline == other.pipeline)
         else:
             return ModuleValuePair(self.module, other)
 
diff --git a/vistrails/core/application.py b/vistrails/core/application.py
index 51df63f39..432b48507 100644
--- a/vistrails/core/application.py
+++ b/vistrails/core/application.py
@@ -37,7 +37,6 @@
 
 import os
 import sys
-import weakref
 import warnings
 
 from vistrails.core import debug
@@ -46,6 +45,7 @@
 from vistrails.core.collection import Collection
 import vistrails.core.configuration
 from vistrails.core.configuration import ConfigurationObject
+import vistrails.core.db.action
 from vistrails.core.db.locator import BaseLocator, FileLocator, DBLocator, \
     UntitledLocator
 import vistrails.core.db.action
@@ -73,12 +73,12 @@ def finalize_vistrails(app):
 
 def get_vistrails_application():
     if VistrailsApplication is not None:
-        return VistrailsApplication()
+        return VistrailsApplication
     return None
 
 def set_vistrails_application(app):
     global VistrailsApplication
-    VistrailsApplication = weakref.ref(app, finalize_vistrails)
+    VistrailsApplication = app
 
 def is_running_gui():
     app = get_vistrails_application()
diff --git a/vistrails/core/configuration.py b/vistrails/core/configuration.py
index d7e01e89a..9643a6076 100644
--- a/vistrails/core/configuration.py
+++ b/vistrails/core/configuration.py
@@ -34,7 +34,9 @@
 ##
 ###############################################################################
 
-"""Configuration variables for controlling specific things in VisTrails."""
+"""Configuration variables for controlling specific things in VisTrails.
+"""
+
 from __future__ import division
 
 import argparse
@@ -1145,7 +1147,6 @@ def set_value(self, val):
 
 class ConfigBool(DBConfigBool, ConfigValue):
     def __copy__(self):
-        """ __copy__() -> ConfigBool - Returns a clone of itself """
         return ConfigBool.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1165,7 +1166,6 @@ def set_value(self, val):
 
 class ConfigInt(DBConfigInt, ConfigValue):
     def __copy__(self):
-        """ __copy__() -> ConfigInt - Returns a clone of itself """
         return ConfigInt.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1179,7 +1179,6 @@ def convert(_val):
 
 class ConfigStr(DBConfigStr, ConfigValue):
     def __copy__(self):
-        """ __copy__() -> ConfigStr - Returns a clone of itself """
         return ConfigStr.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1193,7 +1192,6 @@ def convert(_val):
 
 class ConfigFloat(DBConfigFloat, ConfigValue):
     def __copy__(self):
-        """ __copy__() -> ConfigFloat - Returns a clone of itself """
         return ConfigFloat.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1207,7 +1205,6 @@ def convert(_val):
 
 class ConfigList(DBConfigStr, ConfigValue):
     def __copy__(self):
-        """ __copy__() -> ConfigList - Returns a clone of itself """
         return ConfigList.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1236,7 +1233,6 @@ def __init__(self, name, value):
             self.set_type(type(value))
 
     def __copy__(self):
-        """ __copy__() -> ConfigKey - Returns a clone of itself """
         return ConfigKey.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1288,10 +1284,8 @@ class ConfigurationObject(DBConfiguration):
 
     ConfigurationObject exists so that the GUI can automatically infer
     the right types for the widgets.
-
     """
 
-
     def __init__(self, **kwargs):
         self._in_init = True
         self._unset_keys = {}
@@ -1309,7 +1303,6 @@ def __init__(self, **kwargs):
         self.vistrails = []
 
     def __copy__(self):
-        """ __copy__() -> ConfigurationObject - Returns a clone of itself """
         return ConfigurationObject.do_copy(self)
 
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
@@ -1432,21 +1425,18 @@ def update(self, other):
                 self.__setattr__(name, other_key.value)
 
     def unsubscribe(self, field, callable_):
-        """unsubscribe(field, callable_): remove observer from subject
+        """Remove the given `callable_` from the observers of a field.
         """
         self._subscribers[field].remove(weakref.ref(callable_))
 
     def subscribe(self, field, callable_):
-        """subscribe(field, callable_): call observer callable_ when
-        self.field is set.
+        """Call `callable_` when the given field is set.
         """
         append_to_dict_of_lists(self._subscribers, field,
                                 Ref(callable_))
 
     def has(self, key):
-        """has(key) -> bool.
-
-        Returns true if key has valid value in the object.
+        """Returns whether `key` has a valid value in the object.
         """
 
         return key in self.db_config_keys_name_index
@@ -1498,176 +1488,41 @@ def set_deep_value(self, keys_str, value, create_if_missing=False):
         config.__setattr__(keys[-1], value)
 
     def check(self, key):
-        """check(key) -> obj
-
-        Returns False if key is absent in object, and returns object
-        otherwise.
+        """Returns False if key is absent in object, else returns the value.
         """
 
         return self.has(key) and getattr(self, key)
 
     def allkeys(self):
-        """allkeys() -> list of strings
-
-        Returns all options stored in this object.
+        """Returns all options stored in this object.
         """
-
         return self.db_config_keys_name_index.keys() + self._unset_keys.keys()
 
     def keys(self):
-        """keys(self) -> list of strings
-        Returns all public options stored in this object.
+        """Returns all public options stored in this object.
+
         Public options are keys that do not start with a _
         """
         return [k for k in itertools.chain(self.db_config_keys_name_index,
                                            self._unset_keys)
                 if not k.startswith('_')]
 
-# def default():
-#     """ default() -> ConfigurationObject
-#     Returns the default configuration of VisTrails
-
-#     """
-
-#     base_dir = {
-#         'abstractionsDirectory': os.path.join("$DOT_VISTRAILS",
-#                                               "subworkflows"),
-#         'alwaysShowDebugPopup': False,
-#         'autoConnect': True,
-#         'autosave': True,
-#         'dataDirectory': (None, str),
-#         'dbDefault': False,
-# #        'debugSignals': False,
-#         'defaultFileType':system.vistrails_default_file_type(),
-#         'detachHistoryView': False,
-#         'dotVistrails': system.default_dot_vistrails(),
-#         'enablePackagesSilently': False,
-#         'errorOnConnectionTypeerror': False,
-#         'errorOnVariantTypeerror': True,
-#         'executeWorkflows': False,
-#         'fileDirectory': (None, str),
-#         'fixedSpreadsheetCells': False,
-# #        'evolutionGraph': (None, str),
-#         'installBundles': True,
-#         'installBundlesWithPip': False,
-#         'interactiveMode': True,
-#         'logFile': os.path.join("$DOT_VISTRAILS", "vistrails.log"),
-#         'logger': default_logger(),
-#         'maxMemory': (None, int),
-#         'maximizeWindows': False,
-#         'maxRecentVistrails': 5,
-#         'migrateTags': False,
-#         'minMemory': (None, int),
-#         'multiHeads': False,
-#         'nologger': False,
-#         'packageDirectory': (None, str),
-#         'pythonPrompt': False,
-#         'recentVistrailList': (None, str),
-#         'repositoryLocalPath': (None, str),
-#         'repositoryHTTPURL': "http://www.vistrails.org/packages",
-#         'reviewMode': False,
-#         'rootDirectory': (None, str),
-#         'runningJobsList': (None, str),
-#         'shell': default_shell(),
-#         'showScrollbars': True,
-#         'showMovies': True,
-#         'showSplash': True,
-#         'showSpreadsheetOnly': False,
-#         'singleInstance': True,
-#         'spreadsheetDumpCells': (None, str),
-#         'spreadsheetDumpPDF': False,
-#         'staticRegistry': (None, str),
-#         'stopOnError': True,
-#         'temporaryDirectory': (None, str),
-#         'thumbs': default_thumbs(),
-#         'upgradeOn': True,
-#         'upgradeDelay': True,
-#         'upgradeModuleFailPrompt': True,
-#         'useCache': True,
-#         'userPackageDirectory': os.path.join("$DOT_VISTRAILS", "userpackages"),
-#         'verbosenessLevel': (None, int),
-# #        'workflowGraph': (None, str),
-# #        'workflowInfo': (None, str),
-#         'webRepositoryLogin': (None, str),
-#         'webRepositoryURL': "http://www.crowdlabs.org",
-#         'isInServerMode': False,
-#         }
-#     specific_dir = add_specific_config(base_dir)
-#     return ConfigurationObject(**specific_dir)
-
-# def default_logger():
-#     """default_logger() -> ConfigurationObject
-#     Returns the default configuration for the VisTrails logger
-
-#     """
-#     logger_dir = {
-#         'dbHost': '',
-#         'dbName': '',
-#         'dbPasswd': '',
-#         'dbPort': 0,
-#         'dbUser': '',
-#         }
-#     return ConfigurationObject(**logger_dir)
-
-# def default_shell():
-#     """default_shell() -> ConfigurationObject
-#     Returns the default configuration for the VisTrails shell
-#
-#     """
-#     if system.systemType == 'Linux':
-#         shell_dir = {
-#             'font_face': 'Fixed',
-#             'font_size': 12,
-#             }
-#     elif system.systemType in ['Windows', 'Microsoft']:
-#         shell_dir = {
-#             'font_face': 'Courier New',
-#             'font_size': 8,
-#             }
-#     elif system.systemType == 'Darwin':
-#         shell_dir = {
-#             'font_face': 'Monaco',
-#             'font_size': 12,
-#             }
-#     else:
-#         raise VistrailsInternalError('system type not recognized')
-#     return ConfigurationObject(**shell_dir)
-
-# def default_thumbs():
-#     """default_thumbs() -> ConfigurationObject
-#     Returns the default configuration for VisTrails Pipelines Thumbnails
-#     """
-#     thumbs_dir = {
-#                   'autoSave': True,
-#                   'cacheDirectory': os.path.join("$DOT_VISTRAILS", "thumbs"),
-#                   'cacheSize': 20,
-#                   'mouseHover': False,
-#                   'tagsOnly': False,
-#                 }
-#     return ConfigurationObject(**thumbs_dir)
-
-def add_specific_config(base_dir):
-    """add_specific_config() -> dict
-
-    Returns a dict with other specific configuration to the current
-    platform added to base_dir
-
+def add_specific_config(opts):
+    """Returns a new dict with platform-specific options added.
     """
-    newdir = dict(base_dir)
+    newopts = dict(opts)
     if system.systemType == 'Darwin':
-        newdir['useMacBrushedMetalStyle'] = True
+        newopts['useMacBrushedMetalStyle'] = True
 
-    return newdir
+    return newopts
 
 def get_vistrails_persistent_configuration():
-    """get_vistrails_persistent_configuration() -> ConfigurationObject or None
-    Returns the persistent configuration of the application. It returns None if
-    configuration was not found (when running as a bogus application
-    for example.
-    Notice that this function should be use only to write configurations to
-    the user's startup.xml file. Otherwise, use get_vistrails_configuration  or
-    get_vistrails_temp_configuration.
+    """Returns the persistent configuration (the serialized one).
 
+    Returns None if configuration was not found (when running as a bogus
+    application for example).
+    Notice that this function should be use only to write configurations to
+    the user's startup.xml file. Otherwise, use get_vistrails_configuration().
     """
     from vistrails.core.application import get_vistrails_application
     app = get_vistrails_application()
@@ -1677,13 +1532,13 @@ def get_vistrails_persistent_configuration():
         return None
 
 def get_vistrails_temp_configuration():
-    """get_vistrails_temp_configuration() -> ConfigurationObject or None
-    Returns the temp configuration of the application. It returns None if
-    configuration was not found (when running as a bogus application
-    for example. The temp configuration is the one that is used just for the
-    current session and is not persistent. To make changes persistent,
-    use get_vistrails_persistent_configuration() instead.
+    """Returns the current configuration of the application.
 
+    It returns None if configuration was not found (when running as a bogus
+    application for example).
+    The temp configuration is the one that is used just for the current session
+    and is not persistent. To make changes persistent, use
+    get_vistrails_persistent_configuration() instead.
     """
     from vistrails.core.application import get_vistrails_application
     app = get_vistrails_application()
@@ -1845,4 +1700,3 @@ def test_comma_sep_params(self):
 
 if __name__ == '__main__':
     unittest.main()
-
diff --git a/vistrails/core/db/locator.py b/vistrails/core/db/locator.py
index 46955f635..9cbefd45e 100644
--- a/vistrails/core/db/locator.py
+++ b/vistrails/core/db/locator.py
@@ -442,7 +442,7 @@ def __eq__(self, other):
                 self._db == other._db and
                 self._user == other._user and
                 #self._name == other._name and
-                long(self._obj_id) == long(other._obj_id) and
+                self._obj_id == other._obj_id and
                 self._obj_type == other._obj_type)
 
     ##########################################################################
diff --git a/vistrails/core/interpreter/base.py b/vistrails/core/interpreter/base.py
index 726f46a71..86f9021f8 100644
--- a/vistrails/core/interpreter/base.py
+++ b/vistrails/core/interpreter/base.py
@@ -36,7 +36,6 @@
 from __future__ import division
 
 from vistrails.core import debug
-import copy
 
 ##############################################################################
 
@@ -45,7 +44,7 @@ class InternalTuple(object):
 
     list_depth = 0
 
-    def _get_length(self, length):
+    def _get_length(self):
         return len(self._values)
     def _set_length(self, length):
         self._values = [None] * length
@@ -81,88 +80,6 @@ def __init__(self):
         self.done_summon_hook = None
         self.done_update_hook = None
 
-    def get_name_dependencies(self, astList):
-        """get_name_dependencies(astList) -> list of something 
-        
-        """
-        
-        result = []
-        if astList[0]==1: # NAME token
-            result += [astList[1]]
-        else:
-            for e in astList:
-                if isinstance(e, list):
-                    result += self.get_name_dependencies(e)
-        return result
-
-#    def build_alias_dictionary(self, pipeline):
-#        aliases = {}
-#        for mid in pipeline.modules:
-#            for f in pipeline.modules[mid].functions:
-#                fsig = f.getSignature()
-#                for pidx in xrange(len(f.params)):
-#                    palias = f.params[pidx].alias
-#                    if palias and palias!='':
-#                        for f1 in reversed(pipeline.modules[mid].functions):
-#                            if f1.getSignature()==fsig:
-#                                p = f1.params[pidx]
-#                                aliases[palias] = (p.type, expression.parse_expression(str(p.strValue)))
-#                                break
-#        return aliases
-
-    def compute_evaluation_order(self, aliases):
-        # Build the dependencies graph
-        dp = {}
-        for alias,(atype,(base,exp)) in aliases.items():
-            edges = []
-            for e in exp:
-                edges += self.get_name_dependencies()
-            dp[alias] = edges
-            
-        # Topological Sort to find the order to compute aliases
-        # Just a slow implementation, O(n^3)...
-        unordered = copy.copy(list(aliases.keys()))
-        ordered = []
-        while unordered:
-            added = []
-            for i in xrange(len(unordered)):
-                ok = True
-                u = unordered[i]
-                for j in xrange(len(unordered)):
-                    if i!=j:
-                        for v in dp[unordered[j]]:
-                            if u==v:
-                                ok = False
-                                break
-                        if not ok: break
-                if ok: added.append(i)
-            if not added:
-                debug.warning('Looping dependencies detected!')
-                break
-            for i in reversed(added):
-                ordered.append(unordered[i])
-                del unordered[i]
-        return ordered
-
-    def evaluate_exp(self, atype, base, exps, aliases):
-        # FIXME: eval should pretty much never be used
-        import datetime
-        for e in exps:
-            base = (
-                    base[:e[0]] + str(eval(
-                        e[1],
-                        {'datetime': locals()['datetime']},
-                        aliases)) +
-                    base[e[0]:])
-        if not atype in ['string', 'String']:
-            if base=='':
-                base = '0'
-            try:
-                base = eval(base)
-            except Exception:
-                pass
-        return base
-
     def resolve_aliases(self, pipeline,
                         customAliases=None):
         # We don't build the alias dictionary anymore because as we don't 
@@ -178,15 +95,6 @@ def resolve_aliases(self, pipeline,
                 aliases[k] = v
             # no support for expression evaluation. The code that does that is
             # ugly and dangerous.
-#        ordered = self.compute_evaluation_order(aliases)
-#        casting = {'int': int, 'float': float, 'double': float, 'string': str,
-#                   'Integer': int, 'Float': float, 'String': str}
-#        for alias in reversed(ordered):
-#            (atype,base) = aliases[alias]
-#            #no expression evaluation anymore
-#            aliases[alias] = base
-#            #value = self.evaluate_exp(atype,base,exps,aliases)
-#            #aliases[alias] = value
         for alias in aliases:
             try:
                 info = pipeline.aliases[alias]
diff --git a/vistrails/core/interpreter/cached.py b/vistrails/core/interpreter/cached.py
index 54df4b404..310723a04 100644
--- a/vistrails/core/interpreter/cached.py
+++ b/vistrails/core/interpreter/cached.py
@@ -48,7 +48,6 @@
 from vistrails.core import debug
 import vistrails.core.interpreter.base
 from vistrails.core.interpreter.base import AbortExecution
-import vistrails.core.interpreter.utils
 from vistrails.core.log.controller import DummyLogController
 from vistrails.core.modules.basic_modules import identifier as basic_pkg, \
                                                  Generator
@@ -330,7 +329,7 @@ def create_constant(param, module):
             if param.strValue != '':
                 constant.setValue(param.strValue)
             else:
-                constant.setValue( \
+                constant.setValue(
                     constant.translate_to_string(constant.default_value))
             return constant
 
@@ -585,8 +584,9 @@ def make_change_parameter(obj):
                     logging_obj.signalError(mb.module, mb)
                     abort = True
                 except Exception, e:
-                    import traceback
-                    traceback.print_exc()
+                    debug.unexpected_exception(e)
+                    debug.critical("Exception running generators: %s" % e,
+                                   debug.format_exc())
                     abort = True
                 if stop_on_error or abort:
                     break
diff --git a/vistrails/core/interpreter/noncached.py b/vistrails/core/interpreter/noncached.py
index 680168941..4d14db06c 100644
--- a/vistrails/core/interpreter/noncached.py
+++ b/vistrails/core/interpreter/noncached.py
@@ -37,7 +37,6 @@
 
 import vistrails.core.interpreter.base
 import vistrails.core.interpreter.cached
-import vistrails.core.interpreter.utils
 import vistrails.core.vistrail.pipeline
 import atexit
 
diff --git a/vistrails/core/log/group_exec.py b/vistrails/core/log/group_exec.py
index 2ba55a404..884408626 100644
--- a/vistrails/core/log/group_exec.py
+++ b/vistrails/core/log/group_exec.py
@@ -89,19 +89,11 @@ def _get_duration(self):
         return None
     duration = property(_get_duration)
 
-    def _get_annotations(self):
-        return self.db_annotations
-    def _set_annotations(self, annotations):
-        self.db_annotations = annotations
-    annotations = property(_get_annotations, _set_annotations)
+    annotations = DBGroupExec.db_annotations
     def add_annotation(self, annotation):
         self.db_add_annotation(annotation)
 
-    def _get_item_execs(self):
-        return self.db_item_execs
-    def _set_item_execs(self, item_execs):
-        self.db_item_execs = item_execs
-    item_execs = property(_get_item_execs, _set_item_execs)
+    item_execs = DBGroupExec.db_item_execs
     def add_item_exec(self, item_exec):
         self.db_add_item_exec(item_exec)
 
diff --git a/vistrails/core/log/log.py b/vistrails/core/log/log.py
index b44a3c840..dee23f61a 100644
--- a/vistrails/core/log/log.py
+++ b/vistrails/core/log/log.py
@@ -66,11 +66,7 @@ def convert(_log):
     ##########################################################################
     # Properties
 
-    def _get_id(self):
-        return self.db_id
-    def _set_id(self, id):
-        self.db_id = id
-    id = property(_get_id, _set_id)
+    id = DBLog.db_id
 
     def _get_workflow_execs(self):
         return self.db_workflow_execs
@@ -82,11 +78,7 @@ def delete_all_workflow_execs(self):
         for wf_exec in copy.copy(self.workflow_execs):
             self.db_delete_workflow_exec(wf_exec)
 
-    def _get_vistrail_id(self):
-        return self.db_vistrail_id
-    def _set_vistrail_id(self, id):
-        self.db_vistrail_id = id
-    vistrail_id = property(_get_vistrail_id, _set_vistrail_id)
+    vistrail_id = DBLog.db_vistrail_id
 
     def get_last_workflow_exec_id(self):
         if len(self.workflow_execs) < 1:
diff --git a/vistrails/core/log/loop_exec.py b/vistrails/core/log/loop_exec.py
index cfd02fe26..d6f1f76e0 100644
--- a/vistrails/core/log/loop_exec.py
+++ b/vistrails/core/log/loop_exec.py
@@ -69,7 +69,7 @@ def _get_loop_iterations(self):
         return self.db_loop_iterations
     def _set_loop_iterations(self, iterations):
         self.db_loop_iterations = iterations
-    loop_iterations = property(_get_loop_iterations, _set_loop_iterations)
+    loop_iterations = DBLoopExec.db_loop_iterations
     def add_loop_iteration(self, iteration):
         self.db_add_loop_iteration(iteration)
 
@@ -118,10 +118,6 @@ def _get_duration(self):
         return None
     duration = property(_get_duration)
 
-    def _get_item_execs(self):
-        return self.db_item_execs
-    def _set_item_execs(self, item_execs):
-        self.db_item_execs = item_execs
-    item_execs = property(_get_item_execs, _set_item_execs)
+    item_execs = DBLoopIteration.db_item_execs
     def add_item_exec(self, item_exec):
         self.db_add_item_exec(item_exec)
diff --git a/vistrails/core/log/machine.py b/vistrails/core/log/machine.py
index 1d7f0b5fe..75e8019ec 100644
--- a/vistrails/core/log/machine.py
+++ b/vistrails/core/log/machine.py
@@ -60,44 +60,12 @@ def convert(_machine):
     ##########################################################################
     # Properties
 
-    def _get_id(self):
-        return self.db_id
-    def _set_id(self, id):
-        self.db_id = id
-    id = property(_get_id, _set_id)
-
-    def _get_name(self):
-        return self.db_name
-    def _set_name(self, name):
-        self.db_name = name
-    name = property(_get_name, _set_name)
-
-    def _get_os(self):
-        return self.db_os
-    def _set_os(self, os):
-        self.db_os = os
-    os = property(_get_os, _set_os)
-
-    def _get_architecture(self):
-        return self.db_architecture
-    def _set_architecture(self, architecture):
-        self.db_architecture = architecture
-    architecture = property(_get_architecture, _set_architecture)
-
-    def _get_processor(self):
-        return self.db_processor
-    def _set_processor(self, processor):
-        self.db_processor = processor
-    processor = property(_get_processor, _set_processor)
-
-    def _get_ram(self):
-        return self.db_ram
-    def _set_ram(self, ram):
-        self.db_ram = ram
-    ram = property(_get_ram, _set_ram)
-
-    ##########################################################################
-    # Properties
+    id = DBMachine.db_id
+    name = DBMachine.db_name
+    os = DBMachine.db_os
+    architecture = DBMachine.db_architecture
+    processor = DBMachine.db_processor
+    ram = DBMachine.db_ram
 
     def equals_no_id(self, other):
         return (self.name == other.name and
diff --git a/vistrails/core/log/module_exec.py b/vistrails/core/log/module_exec.py
index 920ef88a2..e48a0c5e0 100644
--- a/vistrails/core/log/module_exec.py
+++ b/vistrails/core/log/module_exec.py
@@ -82,19 +82,11 @@ def _get_duration(self):
         return None
     duration = property(_get_duration)
 
-    def _get_annotations(self):
-        return self.db_annotations
-    def _set_annotations(self, annotations):
-        self.db_annotations = annotations
-    annotations = property(_get_annotations, _set_annotations)
+    annotations = DBModuleExec.db_annotations
     def add_annotation(self, annotation):
         self.db_add_annotation(annotation)
 
-    def _get_loop_execs(self):
-        return self.db_loop_execs
-    def _set_loop_execs(self, loop_execs):
-        self.db_loop_execs = loop_execs
-    loop_execs = property(_get_loop_execs, _set_loop_execs)
+    loop_execs = DBModuleExec.db_loop_execs
     def add_loop_exec(self, loop_exec):
         self.db_add_loop_exec(loop_exec)
         
diff --git a/vistrails/core/log/workflow_exec.py b/vistrails/core/log/workflow_exec.py
index 208a38698..cfdb9b3d2 100644
--- a/vistrails/core/log/workflow_exec.py
+++ b/vistrails/core/log/workflow_exec.py
@@ -96,19 +96,11 @@ def _get_duration(self):
         return None
     duration = property(_get_duration)
 
-    def _get_annotations(self):
-        return self.db_annotations
-    def _set_annotations(self, annotations):
-        self.db_annotations = annotations
-    annotations = property(_get_annotations, _set_annotations)
+    annotations = DBWorkflowExec.db_annotations
     def add_annotation(self, annotation):
         self.db_add_annotation(annotation)
-        
-    def _get_item_execs(self):
-        return self.db_item_execs
-    def _set_item_execs(self, item_execs):
-        self.db_item_execs = item_execs
-    item_execs = property(_get_item_execs, _set_item_execs)
+
+    item_execs = DBWorkflowExec.db_item_execs
     def add_item_exec(self, item_exec):
         self.db_add_item_exec(item_exec)
 
diff --git a/vistrails/core/modules/basic_modules.py b/vistrails/core/modules/basic_modules.py
index 38466f2b1..51115a6c0 100644
--- a/vistrails/core/modules/basic_modules.py
+++ b/vistrails/core/modules/basic_modules.py
@@ -149,6 +149,14 @@ class Constant(Module):
 
     __metaclass__ = meta_add_value_ports
 
+    @staticmethod
+    def validate(x):
+        raise NotImplementedError
+
+    @staticmethod
+    def translate_to_python(x):
+        raise NotImplementedError
+
     def compute(self):
         """Constant.compute() only checks validity (and presence) of
         input value."""
@@ -361,7 +369,7 @@ def __getattr__(self, name):
         raise AttributeError
 
 class Path(Constant):
-    _settings = ModuleSettings(constant_widget=("%s:PathChooserWidget" % \
+    _settings = ModuleSettings(constant_widget=("%s:PathChooserWidget" %
                                                 constant_config_path))
     _input_ports = [IPort("value", "Path"),
                     IPort("name", "String", optional=True)]
@@ -424,7 +432,7 @@ class File(Path):
     file system local to the machine where VisTrails is running."""
 
     _settings = ModuleSettings(constant_signature=path_parameter_hasher,
-                               constant_widget=("%s:FileChooserWidget" % \
+                               constant_widget=("%s:FileChooserWidget" %
                                                 constant_config_path))
     _input_ports = [IPort("value", "File"),
                     IPort("create_file", "Boolean", optional=True)]
@@ -443,7 +451,7 @@ def compute(self):
 class Directory(Path):
 
     _settings = ModuleSettings(constant_signature=path_parameter_hasher,
-                               constant_widget=("%s:DirectoryChooserWidget" % \
+                               constant_widget=("%s:DirectoryChooserWidget" %
                                                 constant_config_path))
     _input_ports = [IPort("value", "Directory"),
                     IPort("create_directory", "Boolean", optional=True)]
@@ -472,7 +480,7 @@ def compute(self):
 ##############################################################################
 
 class OutputPath(Path):
-    _settings = ModuleSettings(constant_widget=("%s:OutputPathChooserWidget" % \
+    _settings = ModuleSettings(constant_widget=("%s:OutputPathChooserWidget" %
                                                 constant_config_path))
     _input_ports = [IPort("value", "OutputPath")]
     _output_ports = [OPort("value", "OutputPath")]
@@ -784,7 +792,6 @@ def compute(self):
 
 # Tuple will be reasonably magic right now. We'll integrate it better
 # with vistrails later.
-# TODO: Check Tuple class, test, integrate.
 class Tuple(Module):
     """Tuple represents a tuple of values. Tuple might not be well
     integrated with the rest of VisTrails, so don't use it unless
diff --git a/vistrails/core/modules/config.py b/vistrails/core/modules/config.py
index 482532e2f..92d4e243a 100644
--- a/vistrails/core/modules/config.py
+++ b/vistrails/core/modules/config.py
@@ -495,7 +495,8 @@ def parse_documentation():
                           [(('label', None),),
                            (('default', None),),
                            (('values', None),),
-                           (('entry_type', None),)])
+                           (('entry_type', None),),
+                           (('union', ''),)])
 OutputPort = subnamedtuple('OutputPort', Port)
 
 CompoundPort = subnamedtuple('CompoundPort', Port,
@@ -505,7 +506,8 @@ def parse_documentation():
                                   [(('labels', None),), 
                                    (('defaults', None),),
                                    (('values', None),),
-                                   (('entry_types', None),)])
+                                   (('entry_types', None),),
+                                   (('union', ''),)])
 CompoundOutputPort = subnamedtuple('CompoundOutputPort', CompoundPort)
 
 PortItem = namedtuple('PortItem', [('signature', None)])
diff --git a/vistrails/core/modules/module_descriptor.py b/vistrails/core/modules/module_descriptor.py
index 490969d34..0cd331dab 100644
--- a/vistrails/core/modules/module_descriptor.py
+++ b/vistrails/core/modules/module_descriptor.py
@@ -58,41 +58,43 @@ class OverloadedPort(Exception):
 # ModuleDescriptor
 
 class ModuleDescriptor(DBModuleDescriptor):
-    """ModuleDescriptor is a class that holds information about
-    modules in the registry. There exists exactly one ModuleDescriptor
-    for every registered VisTrails module in the system.
-
-    self.module: reference to the python class that defines the module
-    self.name: name of the module
-    self.identifier: identifier of the package that module belongs to
-    self.input_ports: dictionary of names of input ports to the types
-      consumed by the ports
-    self.output_ports: dictionary of names of output ports to the types
-      produces by the ports
-    self.input_ports_optional: dictionary of input port names that records
-      whether ports should show up by default on GUI
-    self.output_ports_optional: dictionary of output port names that records
-      whether ports should show up by default on GUI
-    self.port_order: stores a map from names to numbers to order the ports
-      in the GUI
-
-    self._is_abstract: whether module is abstract
-    self._configuration_widget: reference to the Qt class that provides a
-      custom configuration widget for the class.  Note that this can
-      be a tuple (path, name) that will be loaded only when needed via
-      __import__ (! this is preferred !) or as a QWidget (deprecated)
-
-    self._left_fringe and self._right_fringe: lists of 2D points that
-      define a drawing style for modules in the GUI
-    self._module_color: color of the module in the GUI
-
-    self._widget_item: stores a reference to the ModuleTreeWidgetItem so
-      that when ports are added to modules things get correctly updated.
-
-    self._input_port_cache, self._output_port_cache,
-      self._port_caches: Dictionaries for fast port spec lookup,
-      created because port spec lookups are sometimes part of hot code
-      paths and need to go as fast as possible.
+    """Description of a VisTrails module in the registry.
+
+    There exists exactly one ModuleDescriptor for every registered VisTrails
+    module in the system. It holds information about a module, such as its
+    name, package identifier and ports.
+
+    :attribute module: reference to the python class that defines the module
+    :attribute name: name of the module
+    :attribute identifier: identifier of the package that module belongs to
+    :attribute input_ports: dictionary of names of input ports to the types
+        consumed by the ports
+    :attribute output_ports: dictionary of names of output ports to the types
+        produces by the ports
+    :attribute input_ports_optional: dictionary of input port names that
+        records whether ports should show up by default on GUI
+    :attribute output_ports_optional: dictionary of output port names that
+        records whether ports should show up by default on GUI
+    :attribute port_order: stores a map from names to numbers to order the
+        ports in the GUI
+
+    :attribute _is_abstract: whether module is abstract
+    :attribute _configuration_widget: reference to the Qt class that provides a
+        custom configuration widget for the class.  Note that this can be a
+        tuple (path, name) that will be loaded only when needed via __import__
+        (! this is preferred !) or as a QWidget (deprecated)
+
+    :attribute _left_fringe, _right_fringe: lists of 2D points that define a
+        drawing style for modules in the GUI
+    :attribute _module_color: color of the module in the GUI
+
+    :attribute _widget_item: stores a reference to the ModuleTreeWidgetItem so
+        that when ports are added to modules things get correctly updated.
+
+    :attribute _input_port_cache, _output_port_cache, _port_caches:
+        Dictionaries for fast port spec lookup, created because port spec
+        lookups are sometimes part of hot code paths and need to go as fast as
+        possible.
     """
 
     ##########################################################################
@@ -140,8 +142,8 @@ def set_defaults(self, other=None):
             self._module_color = None
             self._hasher_callable = None
             self._widget_item = None
-            self._is_hidden = False
-            self._namespace_hidden = False
+            self.is_hidden = False
+            self.namespace_hidden = False
             self._widget_classes = {}
             self.children = []
             # The ghost attributes represent the original values
@@ -166,10 +168,10 @@ def set_defaults(self, other=None):
             self._module_color = other._module_color
             self._hasher_callable = other._hasher_callable
             self._widget_item = other._widget_item
-            self._is_hidden = other._is_hidden
+            self.is_hidden = other.is_hidden
             self._widget_classes = dict((k,copy.copy(v)) for k, v in \
                                          other._widget_classes.iteritems())
-            self._namespace_hidden = other._namespace_hidden
+            self.namespace_hidden = other.namespace_hidden
             self.ghost_identifier = other.ghost_identifier
             self.ghost_package_version = other.ghost_package_version
             self.ghost_namespace = other.ghost_namespace
@@ -324,18 +326,6 @@ def set_hasher_callable(self, callable_):
     def hasher_callable(self):
         return self._hasher_callable
 
-    def _get_is_hidden(self):
-        return self._is_hidden
-    def _set_is_hidden(self, hidden):
-        self._is_hidden = hidden
-    is_hidden = property(_get_is_hidden, _set_is_hidden)
-
-    def _get_namespace_hidden(self):
-        return self._namespace_hidden
-    def _set_namespace_hidden(self, hidden):
-        self._namespace_hidden = hidden
-    namespace_hidden = property(_get_namespace_hidden, _set_namespace_hidden)
-
     ##########################################################################
     # Operators
 
diff --git a/vistrails/core/modules/module_registry.py b/vistrails/core/modules/module_registry.py
index 7eb75810a..12d3df16e 100644
--- a/vistrails/core/modules/module_registry.py
+++ b/vistrails/core/modules/module_registry.py
@@ -83,12 +83,11 @@ def _check_fringe(fringe):
         assert isinstance(v[1], float)
 
 def _toposort_modules(module_list):
-    """_toposort_modules([class]) -> [class]
+    """Topologically sorts Python classes.
 
-    _toposort_modules takes a list of modules and returns them
-    sorted topologically wrt to the subclass relation, such that
-    if a and b are both in the list and issubclass(a,b), then a
-    will appear before b in the resulting order.
+    Takes a list of Python classes and returns them sorted topologically wrt
+    the subclass relation, such that if `a` and `b` are both in the list and
+    ``issubclass(a, b)``, then `a` will appear before `b` in the result.
     """
 
     g = Graph()
@@ -157,7 +156,7 @@ class ModuleRegistrySignals(object):
     # deleted_abstraction_signal = QtCore.SIGNAL("deleted_abstraction")
     # # deleted_package_signal is emitted with package identifier
     # deleted_package_signal = QtCore.SIGNAL("deleted_package")
-    # # new_input_port_signal is emitted with identifier and name of module, 
+    # # new_input_port_signal is emitted with identifier and name of module,
     # # new port and spec
     # new_input_port_signal = QtCore.SIGNAL("new_input_port_signal")
     # # new_output_port_signal is emitted with identifier and name of module,
@@ -184,7 +183,7 @@ def __init__(self):
 
         for notification in notifications:
             app.create_notification(notification)
-        
+
     def emit_new_module(self, descriptor):
         app = get_vistrails_application()
         app.send_notification("reg_new_module", descriptor)
@@ -198,8 +197,8 @@ def emit_new_abstraction(self, descriptor):
     def emit_new_package(self, identifier, prepend=False):
         app = get_vistrails_application()
         app.send_notification("reg_new_package", identifier, prepend)
-        # self.emit(self.new_package_signal, identifier, prepend)        
-        
+        # self.emit(self.new_package_signal, identifier, prepend)
+
     def emit_deleted_module(self, descriptor):
         app = get_vistrails_application()
         app.send_notification("reg_deleted_module", descriptor)
@@ -209,7 +208,7 @@ def emit_deleted_abstraction(self, descriptor):
         app = get_vistrails_application()
         app.send_notification("reg_deleted_abstraction", descriptor)
         # self.emit(self.deleted_abstraction_signal, descriptor)
-    
+
     def emit_deleted_package(self, package):
         app = get_vistrails_application()
         app.send_notification("reg_deleted_package", package)
@@ -217,16 +216,16 @@ def emit_deleted_package(self, package):
 
     def emit_new_input_port(self, identifier, name, port_name, spec):
         app = get_vistrails_application()
-        app.send_notification("reg_new_input_port", identifier, name, 
+        app.send_notification("reg_new_input_port", identifier, name,
                               port_name, spec)
         # self.emit(self.new_input_port_signal, identifier, name, port_name,
         #           spec)
 
     def emit_new_output_port(self, identifier, name, port_name, spec):
         app = get_vistrails_application()
-        app.send_notification("reg_new_output_port", identifier, name, 
+        app.send_notification("reg_new_output_port", identifier, name,
                               port_name, spec)
-        # self.emit(self.new_output_port_signal, identifier, name, port_name, 
+        # self.emit(self.new_output_port_signal, identifier, name, port_name,
         #           spec)
 
     def emit_show_module(self, descriptor):
@@ -241,7 +240,7 @@ def emit_hide_module(self, descriptor):
 
     def emit_module_updated(self, old_descriptor, new_descriptor):
         app = get_vistrails_application()
-        app.send_notification("reg_module_updated", old_descriptor, 
+        app.send_notification("reg_module_updated", old_descriptor,
                               new_descriptor)
         # self.emit(self.module_updated_signal, old_descriptor, new_descriptor)
 
@@ -250,9 +249,6 @@ def emit_module_updated(self, old_descriptor, new_descriptor):
 
 # !!!!!! DEPRECATED !!!!!!
 # Use get_module_registry()
-global registry, add_module, add_input_port, has_input_port, add_output_port, \
-    set_current_package, get_descriptor_by_name, get_module_by_name, \
-    get_descriptor
 registry                 = None
 add_module               = None
 add_input_port           = None
@@ -303,7 +299,7 @@ def __eq__(self, other):
 
     def __hash__(self):
         return (type(self), self._identifier, self._name, self._namespace,
-                self._package_version, self._module_version, 
+                self._package_version, self._module_version,
                 self._module_id).__hash__()
 
     def _get_module_name(self):
@@ -314,7 +310,7 @@ def _get_module_name(self):
 
     def _get_package_name(self):
         if self._package_version:
-            return "%s (version %s)" % (self._identifier, 
+            return "%s (version %s)" % (self._identifier,
                                         self._package_version)
         return self._identifier
     _package_name = property(_get_package_name)
@@ -347,7 +343,7 @@ def __str__(self):
 
 class MissingPackageVersion(ModuleRegistryException):
     def __init__(self, identifier, version):
-        ModuleRegistryException.__init__(self, identifier, None, None, 
+        ModuleRegistryException.__init__(self, identifier, None, None,
                                          version)
 
     def __str__(self):
@@ -356,7 +352,7 @@ def __str__(self):
     __repr__ = __str__
 
 class MissingModuleVersion(ModuleRegistryException):
-    def __init__(self, identifier, name, namespace, module_version, 
+    def __init__(self, identifier, name, namespace, module_version,
                  package_version=None, module_id=None):
         ModuleRegistryException.__init__(self, identifier, name, namespace,
                                          package_version, module_version, module_id)
@@ -368,13 +364,13 @@ def __str__(self):
 
 class AmbiguousResolution(ModuleRegistryException):
     def __init__(self, name, namespace, matches):
-        ModuleRegistryException.__init__(self, "<unkown package>", 
+        ModuleRegistryException.__init__(self, "<unkown package>",
                                          name, namespace)
         self.matches = matches
 
     def __str__(self):
         return ("Ambiguous resolution of module %s.  Could resolve to:\n%s" % \
-                    (self._module_name, 
+                    (self._module_name,
                      ',\n'.join(str(m) for m in self.matches)))
     __repr__ = __str__
 
@@ -389,7 +385,7 @@ def __init__(self, descriptor, port_name, port_type):
 
     def __str__(self):
         return "Missing %s port %s from module %s in package %s" % \
-            (self._port_type, self._port_name, self._module_name, 
+            (self._port_type, self._port_name, self._module_name,
              self._package_name)
     __repr__ = __str__
 
@@ -444,7 +440,7 @@ def __str__(self):
     __repr__ = __str__
 
 class DuplicateModule(ModuleRegistryException):
-    def __init__(self, old_descriptor, new_identifier, new_name, 
+    def __init__(self, old_descriptor, new_identifier, new_name,
                  new_namespace):
         ModuleRegistryException.__init__(self,
                                          new_identifier,
@@ -460,7 +456,7 @@ def __str__(self):
             old_name = self.old_descriptor.name
         return ("Module %s in package %s already exists as "
                 "%s in package %s") % \
-                (self._module_name, self._package_name, old_name, 
+                (self._module_name, self._package_name, old_name,
                  self.old_descriptor.identifier)
     __repr__ = __str__
 
@@ -484,7 +480,7 @@ def __init__(self, descriptor, port_name, port_type, exc):
         self._port_name = port_name
         self._port_type = port_type[0].capitalize() + port_type[1:]
         self._exc = exc
-        
+
     def __str__(self):
         return ('%s port "%s" from module %s in package %s '
                 'has bad specification\n  %s' % \
@@ -502,20 +498,17 @@ def __str__(self):
     __repr__ = __str__
 
 class ModuleRegistry(DBRegistry):
-    """ModuleRegistry serves as a registry of VisTrails modules.
+    """Global registry of modules.
+
+    This holds all the
+    :class:`~vistrails.core.modules.module_descriptor.ModuleDescriptor` objects
+    for the VisTrails modules of enabled packages.
     """
 
     ##########################################################################
     # Constructor and copy
 
     def __init__(self, *args, **kwargs):
-        """ModuleRegistry is the base class for objects that store a hierarchy
-        of registered VisTrails Modules. There is one global registry for the
-        system, and some modules have local registries (in the case of
-        dynamically configurable modules, like PythonSource).
-
-        """
-        
         if 'root_descriptor_id' not in kwargs:
             kwargs['root_descriptor_id'] = -1
         DBRegistry.__init__(self, *args, **kwargs)
@@ -565,7 +558,7 @@ def setup_indices(self):
                     self.packages[key] = pkg
             for descriptor in pkg.descriptor_list:
                 self.descriptors_by_id[descriptor.id] = descriptor
-                k = (descriptor.identifier, descriptor.name, 
+                k = (descriptor.identifier, descriptor.name,
                      descriptor.namespace, pkg.version, descriptor.version)
                 if descriptor.module is not None:
                     self._module_key_map[descriptor.module] = k
@@ -575,7 +568,7 @@ def setup_indices(self):
                     self.descriptors_by_id[descriptor.base_descriptor_id]
                 if descriptor not in base_descriptor.children:
                     base_descriptor.children.append(descriptor)
-        
+
     def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
         cp = DBRegistry.do_copy(self, new_ids, id_scope, id_remap)
         cp.__class__ = ModuleRegistry
@@ -706,11 +699,11 @@ def get_package_by_name(self, identifier, package_version=''):
                 raise MissingPackageVersion(identifier, package_version)
 
     def get_module_by_name(self, identifier, name, namespace=None):
-        """get_module_by_name(name: string): class
-
-        Returns the VisTrails module (the class) registered under the
-        given name.
+        """Gets a module (the class) from its name and package.
 
+        :returns: The subclass of
+            :class:`~vistrails.core.modules.vistrails_module.Module` registered
+            under the given name (**not** the ModuleDescriptor).
         """
         return self.get_descriptor_by_name(identifier, name, namespace).module
 
@@ -737,20 +730,17 @@ def has_descriptor_with_name(self, identifier, name, namespace='',
         return True
     has_module = has_descriptor_with_name
 
-    def get_descriptor_by_name(self, identifier, name, namespace='', 
+    def get_descriptor_by_name(self, identifier, name, namespace='',
                                package_version='', module_version=''):
-        """get_descriptor_by_name(package_identifier : str,
-                                  module_name : str,
-                                  namespace : str,
-                                  package_version : str,
-                                  module_version : str) -> ModuleDescriptor
-        Gets the specified descriptor from the registry.  If you do not
-        specify package_version, you will get the currently loaded version.
+        """Gets the specified descriptor from the registry.
+
+        If you do not specify package_version, you will get the currently
+        loaded version.
         If you do not specify the module_version, you will get the most recent
         version.  Note that module_version is currently only used for
         abstractions.
 
-        Raises a ModuleRegistryException if lookup fails.
+        :raises ModuleRegistryException: if lookup fails.
         """
         namespace = namespace or ''
         package_version = package_version or ''
@@ -791,13 +781,9 @@ def get_similar_descriptor(self, identifier, name, namespace=None,
         except MissingModuleVersion:
             return self.get_similar_descriptor(identifier, name, namespace,
                                                package_version, None)
-            
-    def get_descriptor(self, module):
-        """get_descriptor(module: class) -> ModuleDescriptor
-
-        Returns the ModuleDescriptor of a given vistrails module (a
-        class that subclasses from modules.vistrails_module.Module)
 
+    def get_descriptor(self, module):
+        """Gets a ModuleDescriptor from a given Module subclass.
         """
         # assert isinstance(module, type)
         # assert issubclass(module, core.modules.vistrails_module.Module)
@@ -812,7 +798,7 @@ def module_ports(self, p_type, descriptor):
         return [(p.name, p)
                 for p in descriptor.port_specs_list
                 if p.type == p_type]
-        
+
     def module_source_ports_from_descriptor(self, do_sort, descriptor):
         ports = {}
         for desc in reversed(self.get_module_hierarchy(descriptor)):
@@ -820,11 +806,11 @@ def module_source_ports_from_descriptor(self, do_sort, descriptor):
         all_ports = ports.values()
         if do_sort:
             all_ports.sort(key=lambda x: (x.sort_key, x.id))
-        return all_ports        
+        return all_ports
 
-    def module_source_ports(self, do_sort, identifier, module_name, 
+    def module_source_ports(self, do_sort, identifier, module_name,
                             namespace=None, version=None):
-        descriptor = self.get_descriptor_by_name(identifier, module_name, 
+        descriptor = self.get_descriptor_by_name(identifier, module_name,
                                                  namespace, version)
         return self.module_source_ports_from_descriptor(do_sort, descriptor)
 
@@ -836,10 +822,10 @@ def module_destination_ports_from_descriptor(self, do_sort, descriptor):
         if do_sort:
             all_ports.sort(key=lambda x: (x.sort_key, x.id))
         return all_ports
-        
+
     def module_destination_ports(self, do_sort, identifier, module_name,
                                  namespace=None, version=None):
-        descriptor = self.get_descriptor_by_name(identifier, module_name, 
+        descriptor = self.get_descriptor_by_name(identifier, module_name,
                                                  namespace, version)
         return self.module_destination_ports_from_descriptor(do_sort,
                                                              descriptor)
@@ -848,23 +834,20 @@ def module_destination_ports(self, do_sort, identifier, module_name,
     # Legacy
 
     def get_descriptor_from_name_only(self, name):
-        """get_descriptor_from_name_only(name) -> descriptor
+        """Gets a ModuleDescriptor from a name.
 
         This tries to return a descriptor from a name without a
         package. The call should only be used for converting from
-        legacy vistrails to new ones. For one, it is slow on misses. 
+        legacy vistrails to new ones. For one, it is slow on misses.
 
+        ..  deprecated:: 1.0
+            This is very unsafe and get_descriptor_by_name should be used
+            instead.
         """
         matches = []
         for pkg in self.package_list:
             matches.extend((pkg, key) for key in pkg.descriptors.iterkeys()
                            if key[0] == name)
-#         matches = [[(pkg, desc) for desc in pkg.descriptors.iterkeys()
-#                     if desc[0] == name] for pkg in self.package_list]
-
-#         matches = [x for x in
-#                    self.descriptors.iterkeys()
-#                    if x[1] == name]
         if len(matches) == 0:
             raise MissingModule("<unknown package>", name, None)
         if len(matches) > 1:
@@ -873,17 +856,17 @@ def get_descriptor_from_name_only(self, name):
             raise AmbiguousResolution(name, None, matches_str)
         (pkg, key) = matches[0]
         desc = pkg.descriptors[key]
-        result = self.get_descriptor_by_name(pkg.identifier, desc.name, 
-                                             desc.namespace, pkg.version, 
+        result = self.get_descriptor_by_name(pkg.identifier, desc.name,
+                                             desc.namespace, pkg.version,
                                              desc.version)
         return result
 
     ##########################################################################
 
     def module_signature(self, pipeline, module):
-        """Returns signature of a given core.vistrail.Module in the
-        given core.vistrail.Pipeline, possibly using user-defined
-        hasher.
+        """Computes the signature of a Module in a given Pipeline.
+
+        This might involve a user-defined hasher.
         """
         chm = self._constant_hasher_map
         descriptor = self.get_descriptor_by_name(module.package,
@@ -903,7 +886,7 @@ def get_module_color(self, identifier, name, namespace=None):
     def get_module_fringe(self, identifier, name, namespace=None):
         return self.get_descriptor_by_name(identifier, name, namespace).module_fringe()
 
-    def update_registry(self, base_descriptor, module, identifier, name, 
+    def update_registry(self, base_descriptor, module, identifier, name,
                         namespace, package_version=None, version=None):
         if namespace is not None and not namespace.strip():
             namespace = None
@@ -967,7 +950,7 @@ def convert_port_val(self, val, sig=None, cls=None):
             raise TypeError("Cannot convert value for non-constant type")
         if desc.module is None:
             return None
-        
+
         if not isinstance(val, basestring):
             retval = desc.module.translate_to_string(val)
         else:
@@ -1050,10 +1033,12 @@ def decode_output_port(self, port_info):
                 False)
 
     def auto_add_ports(self, module):
-        """auto_add_ports(module or (module, kwargs)): add
-        input/output ports to registry. Don't call this directly - it is
-        meant to be used by the packagemanager, when inspecting the package
-        contents."""
+        """Add input/output ports to the registry.
+
+        This isn't meant to be called directly -- it is used by the
+        PackageManager to register modules automatically by inspecting a
+        package's contents.
+        """
         if '_input_ports' in module.__dict__:
             for port_info in module._input_ports:
                 name = None
@@ -1085,10 +1070,11 @@ def auto_add_ports(self, module):
                     raise
 
     def auto_add_module(self, module):
-        """auto_add_module(module or (module, kwargs)): add module
-        to registry. Don't call this directly - it is
-        meant to be used by the packagemanager, when inspecting the package
-        contents."""
+        """Add a module to the regsitry.
+
+        Don't call this directly - it is meant to be used by the
+        PackageManager, when inspecting a package's contents.
+        """
         if isinstance(module, type):
             return self.add_module(module)
         elif (isinstance(module, tuple) and
@@ -1101,12 +1087,15 @@ def auto_add_module(self, module):
             raise TypeError("Expected module or (module, kwargs)")
 
     def add_module(self, module, **kwargs):
-        """add_module(module: class, **kwargs) -> ModuleDescriptor
+        """Add a module to the registry.
 
-        See :py:class:`vistrails.core.modules.config.ModuleSettings`.
-        All of its attributes may also be used as kwargs to
-        add_module.
+        Options are taken from the `_settings` attribute, a
+        :class:`~vistrails.core.modules.config.ModuleSettings` instance. All of
+        the attributes of that class may also be used as kwargs to
+        `add_module()`.
 
+        :returns: The new
+            :class:`~vistrails.core.modules.module_descriptor.ModuleDescriptor`
         """
         def remap_dict(d):
             remap = {'configureWidgetType': 'configure_widget',
@@ -1137,7 +1126,7 @@ def remap_dict(d):
             else:
                 raise TypeError("Expected module._settings to be "
                                 "ModuleSettings or dict")
-                
+
         remapped_kwargs = remap_dict(kwargs)
         if module_settings is not None:
             module_settings = module_settings._replace(**remapped_kwargs)
@@ -1146,12 +1135,12 @@ def remap_dict(d):
         return self.add_module_from_settings(module, module_settings)
 
     def add_module_from_settings(self, module, settings):
-        """add_module(module: class, settings) -> ModuleDescriptor
+        """Adds a module to the registry, with an explicit `ModuleSettings`.
 
-        See :py:class:`vistrails.core.modules.config.ModuleSettings`.
-        All of its attributes may also be used as kwargs to
-        add_module.
+        See :class:`~vistrails.core.modules.config.ModuleSettings`.
 
+        :returns: The new
+            :class:`~vistrails.core.modules.module_descriptor.ModuleDescriptor`
         """
 
         def get_setting(attr, default_val):
@@ -1206,7 +1195,7 @@ def get_setting(attr, default_val):
                                            package_version, version):
             raise DuplicateIdentifier(identifier, name, namespace,
                                       package_version, version)
-        descriptor = self.update_registry(base_descriptor, module, identifier, 
+        descriptor = self.update_registry(base_descriptor, module, identifier,
                                           name, namespace, package_version,
                                           version)
         if settings.is_root:
@@ -1225,11 +1214,11 @@ def get_setting(attr, default_val):
             if not self.is_constant_module(module):
                 raise TypeError("To set constant_signature, module "
                                 "must be a subclass of Constant")
-                
+
             # FIXME, currently only allow one per hash, no versioning
             hash_key = (identifier, name, namespace)
             self._constant_hasher_map[hash_key] = settings.constant_signature
-        
+
         constant_widgets = []
         if settings.constant_widget:
             constant_widgets += [settings.constant_widget]
@@ -1245,9 +1234,9 @@ def get_setting(attr, default_val):
                 else:
                     widget_t = ConstantWidgetConfig(widget_t)
                 if widget_t.widget is not None:
-                    self.set_constant_config_widget(descriptor, 
+                    self.set_constant_config_widget(descriptor,
                                                     widget_t.widget,
-                                                    widget_t.widget_type, 
+                                                    widget_t.widget_type,
                                                     widget_t.widget_use)
 
         descriptor.set_module_color(settings.color)
@@ -1260,16 +1249,16 @@ def get_setting(attr, default_val):
         elif settings.left_fringe and settings.right_fringe:
             _check_fringe(settings.left_fringe)
             _check_fringe(settings.right_fringe)
-            descriptor.set_module_fringe(settings.left_fringe, 
+            descriptor.set_module_fringe(settings.left_fringe,
                                          settings.right_fringe)
-        
+
         if settings.ghost_package:
             descriptor.ghost_identifier = settings.ghost_package
         if settings.ghost_package_version:
             descriptor.ghost_package_version = settings.ghost_package_version
         if settings.ghost_namespace:
             descriptor.ghost_namespace = settings.ghost_namespace
-                 
+
         self.signals.emit_new_module(descriptor)
         if self.is_abstraction(descriptor):
             self.signals.emit_new_abstraction(descriptor)
@@ -1316,10 +1305,10 @@ def add_subworkflow(self, vt_fname, **kwargs):
         else:
             debug.warning("Using absolute path for subworkflow: '%s'" % \
                 vt_fname)
-        
+
         vistrail = read_vistrail(vt_fname)
         namespace = kwargs.get('namespace', '')
-        
+
         # create module from workflow
         module = None
         is_upgraded_abstraction = False
@@ -1327,7 +1316,7 @@ def add_subworkflow(self, vt_fname, **kwargs):
             module = new_abstraction(name, vistrail, vt_fname, version)
         except InvalidPipeline, e:
             # This import MUST be delayed until this point or it will fail
-            import vistrails.core.vistrail.controller 
+            import vistrails.core.vistrail.controller
             from vistrails.core.db.io import save_vistrail_to_xml
             from vistrails.core.modules.abstraction import identifier as \
                 abstraction_pkg, version as abstraction_ver
@@ -1336,24 +1325,24 @@ def add_subworkflow(self, vt_fname, **kwargs):
             if version == -1L:
                 version = vistrail.get_latest_version()
             (new_version, new_pipeline) = \
-                controller.handle_invalid_pipeline(e, long(version), vistrail, 
+                controller.handle_invalid_pipeline(e, long(version), vistrail,
                                                    False, True)
             del controller
-            vistrail.set_annotation('__abstraction_descriptor_info__', 
-                                    (identifier, name, namespace, 
+            vistrail.set_annotation('__abstraction_descriptor_info__',
+                                    (identifier, name, namespace,
                                      package_version, str(version)))
             vt_save_dir = tempfile.mkdtemp(prefix='vt_upgrade_abs')
             vt_fname = os.path.join(vt_save_dir, os.path.basename(vt_fname))
-            
-            
+
+
             # need to create new namespace for upgraded version
             new_namespace = str(uuid.uuid1())
             annotation_key = get_next_abs_annotation_key(vistrail)
             vistrail.set_annotation(annotation_key, new_namespace)
 
             # FIXME: Should delete this upgrade file when vistrails is exited
-            save_vistrail_to_xml(vistrail, vt_fname) 
-            module = new_abstraction(name, vistrail, vt_fname, new_version, 
+            save_vistrail_to_xml(vistrail, vt_fname)
+            module = new_abstraction(name, vistrail, vt_fname, new_version,
                                      new_pipeline)
             # need to set identifier to local.abstractions and its version
             kwargs['package'] = abstraction_pkg
@@ -1368,7 +1357,7 @@ def add_subworkflow(self, vt_fname, **kwargs):
             kwargs['ghost_package_version'] = package_version
             kwargs['ghost_namespace'] = namespace
             is_upgraded_abstraction = True
-                                    
+
         module.internal_version = str(module.internal_version)
         kwargs['version'] = module.internal_version
         descriptor = None
@@ -1377,7 +1366,7 @@ def add_subworkflow(self, vt_fname, **kwargs):
         else:
             descriptor = self.add_module(module)
         if is_upgraded_abstraction:
-            descriptor_info = (identifier, name, namespace,  
+            descriptor_info = (identifier, name, namespace,
                                package_version, str(version))
             # print 'adding to upgrades:', descriptor_info
             # print '  ', descriptor.package, descriptor.name, descriptor.namespace, descriptor.version, descriptor.package_version
@@ -1402,10 +1391,10 @@ def has_output_port(self, module, portName):
         return (portName, 'output') in descriptor.port_specs
 
     def create_port_spec(self, name, type, signature=None, sigstring=None,
-                         optional=False, sort_key=-1, labels=None, 
+                         optional=False, sort_key=-1, labels=None,
                          defaults=None, values=None, entry_types=None,
-                         docstring=None, shape=None, 
-                         min_conns=0, max_conns=-1, depth=0):
+                         docstring=None, shape=None,
+                         min_conns=0, max_conns=-1, depth=0, union=''):
         if signature is None and sigstring is None:
             raise VistrailsInternalError("create_port_spec: one of signature "
                                          "and sigstring must be specified")
@@ -1436,7 +1425,7 @@ def create_port_spec(self, name, type, signature=None, sigstring=None,
                 for i, default_val in enumerate(defaults):
                     if default_val is not None:
                         default_conv = self.convert_port_val(default_val,
-                                                             sigstrings[i], 
+                                                             sigstrings[i],
                                                              sig_cls_list[i])
                         if default_conv is not None:
                             new_defaults.append(default_conv)
@@ -1462,7 +1451,7 @@ def create_port_spec(self, name, type, signature=None, sigstring=None,
                         new_values_list = []
                         for val in values_list:
                             if val is not None:
-                                val_conv = self.convert_port_val(val, 
+                                val_conv = self.convert_port_val(val,
                                                                  sigstrings[i],
                                                                  sig_cls_list[i])
                                 if val_conv is not None:
@@ -1470,8 +1459,8 @@ def create_port_spec(self, name, type, signature=None, sigstring=None,
                         new_values.append(new_values_list)
                     else:
                         new_values.append(None)
-                values = new_values        
-        
+                values = new_values
+
         spec = PortSpec(id=spec_id,
                         name=name,
                         type=type,
@@ -1487,7 +1476,8 @@ def create_port_spec(self, name, type, signature=None, sigstring=None,
                         shape=shape,
                         min_conns=min_conns,
                         max_conns=max_conns,
-                        depth=depth)
+                        depth=depth,
+                        union=union)
 
         # don't know how many port spec items are created until after...
         for psi in spec.port_spec_items:
@@ -1517,10 +1507,10 @@ def get_port_spec_from_descriptor(self, desc, port_name, port_type):
         # if we don't find it, raise MissingPort exception
         raise MissingPort(desc, port_name, port_type)
 
-    def get_port_spec(self, package, module_name, namespace, 
+    def get_port_spec(self, package, module_name, namespace,
                       port_name, port_type):
         desc = self.get_descriptor_by_name(package, module_name, namespace)
-        return self.get_port_spec_from_descriptor(desc, port_name, 
+        return self.get_port_spec_from_descriptor(desc, port_name,
                                                   port_type)
 
     def has_port_spec_from_descriptor(self, desc, port_name, port_type):
@@ -1532,86 +1522,81 @@ def has_port_spec_from_descriptor(self, desc, port_name, port_type):
     def has_port_spec(self, package, module_name, namespace,
                       port_name, port_type):
         desc = self.get_descriptor_by_name(package, module_name, namespace)
-        return self.has_port_spec_from_descriptor(desc, port_name, 
+        return self.has_port_spec_from_descriptor(desc, port_name,
                                                   port_type)
 
-    def add_port(self, descriptor, port_name, port_type, port_sig=None, 
+    def add_port(self, descriptor, port_name, port_type, port_sig=None,
                  port_sigstring=None, optional=False, sort_key=-1,
-                 labels=None, defaults=None, values=None, entry_types=None, 
+                 labels=None, defaults=None, values=None, entry_types=None,
                  docstring=None, shape=None, min_conns=0, max_conns=-1,
-                 depth=0):
+                 depth=0, union=''):
         spec = self.create_port_spec(port_name, port_type, port_sig,
                                      port_sigstring, optional, sort_key,
                                      labels, defaults, values, entry_types,
                                      docstring, shape,
-                                     min_conns, max_conns, depth)
+                                     min_conns, max_conns, depth, union)
 
         self.add_port_spec(descriptor, spec)
 
-    def add_input_port(self, module, portName, portSignature, optional=False, 
+    def add_input_port(self, module, portName, portSignature, optional=False,
                        sort_key=-1, labels=None, defaults=None,
                        values=None, entry_types=None, docstring=None,
-                       shape=None, min_conns=0, max_conns=-1, depth=0):
-        """add_input_port(module: class,
-                          portName: string,
-                          portSignature: string,
-                          optional: bool,
-                          sort_key: int,
-                          labels: tuple(string),
-                          defaults: tuple(string),
-                          values: list(list(string)),
-                          entry_types: list(string),
-                          docstring: string,
-                          shape: tuple,
-                          min_conns: int,
-                          max_conns: int,
-                          depth: int) -> None
-
-        Registers a new input port with VisTrails. Receives the module
-        that will now have a certain port, a string representing the
-        name, and a signature of the port, described in
-        doc/module_registry.txt. Optionally, it receives whether the
-        input port is optional."""
+                       shape=None, min_conns=0, max_conns=-1, depth=0,
+                       union=''):
+        """Registers a module's input port.
+
+        :type module: class
+        :type portName: str
+        :type portSignature: str
+        :type optional: bool
+        :type sort_key: int
+        :type labels: list[str]
+        :type defaults: list[str]
+        :type values: list[list[str]]
+        :type entry_types: list[str]
+        :type docstring: str
+        :type shape: list
+        :type min_conns: int
+        :type max_conns: int
+        :type depth: int
+        """
         descriptor = self.get_descriptor(module)
         if isinstance(portSignature, basestring):
             self.add_port(descriptor, portName, 'input', None, portSignature,
                           optional, sort_key, labels, defaults, values,
                           entry_types, docstring, shape, min_conns, max_conns,
-                          depth)
+                          depth, union)
         else:
-            self.add_port(descriptor, portName, 'input', portSignature, None, 
+            self.add_port(descriptor, portName, 'input', portSignature, None,
                           optional, sort_key, labels, defaults, values,
                           entry_types, docstring, shape, min_conns, max_conns,
-                          depth)
+                          depth, union)
 
 
-    def add_output_port(self, module, portName, portSignature, optional=False, 
-                        sort_key=-1, docstring=None, shape=None, 
+    def add_output_port(self, module, portName, portSignature, optional=False,
+                        sort_key=-1, docstring=None, shape=None,
                         min_conns=0, max_conns=-1, depth=0):
-        """add_output_port(module: class,
-                           portName: string,
-                           portSignature: string,
-                           optional: bool,
-                           sort_key: int,
-                           docstring: string,
-                           shape: tuple,
-                           min_conns: int,
-                           max_conns: int,
-                           depth: int) -> None
-
-        Registers a new output port with VisTrails. Receives the
-        module that will now have a certain port, a string
-        representing the name, and a signature of the port, described
-        in doc/module_registry.txt. Optionally, it receives whether
-        the output port is optional."""
+        """Registers a module's output port.
+
+        :type module: class
+        :type portName: str
+        :type portSignature: str
+        :type optional: bool
+        :type sort_key: int
+        :type docstring: str
+        :type shape: list
+        :type min_conns: int
+        :type max_conns: int
+        :type depth: int
+        """
         descriptor = self.get_descriptor(module)
         if isinstance(portSignature, basestring):
-            self.add_port(descriptor, portName, 'output', None, portSignature, 
-                          optional, sort_key, None, None, None, None, 
+            self.add_port(descriptor, portName, 'output', None, portSignature,
+                          optional, sort_key, None, None, None, None,
                           docstring, shape, min_conns, max_conns, depth)
         else:
-            self.add_port(descriptor, portName, 'output', portSignature, None, 
-                          optional, sort_key, None, None, None, None, 
+            self.add_port(descriptor, portName, 'output', portSignature, None,
+                          optional, sort_key, None, None, None, None,
                           docstring, shape, min_conns, max_conns, depth)
 
     def create_package(self, codepath, load_configuration=True, prefix=None):
@@ -1680,17 +1665,19 @@ def initialize_package(self, package):
         except MissingRequirement:
             raise
         except Exception, e:
-            raise package.InitializationFailed(package, 
+            raise package.InitializationFailed(package,
                                                [traceback.format_exc()])
+        finally:
+            self.set_current_package(None)
 
         # The package might have decided to rename itself, let's store that
-        self.set_current_package(None)
         debug.splashMessage("Initializing " + package.codepath + '... done.')
-        package._initialized = True 
+        package._initialized = True
 
     def delete_module(self, identifier, module_name, namespace=None):
-        """deleteModule(module_name): Removes a module from the registry."""
-        descriptor = self.get_descriptor_by_name(identifier, module_name, 
+        """Removes a module from the registry.
+        """
+        descriptor = self.get_descriptor_by_name(identifier, module_name,
                                                  namespace)
         assert len(descriptor.children) == 0
 
@@ -1710,9 +1697,7 @@ def delete_module(self, identifier, module_name, namespace=None):
             del self._module_key_map[descriptor.module]
 
     def remove_package(self, package):
-        """remove_package(package) -> None:
-        Removes an entire package from the registry.
-
+        """Removes an entire package from the registry.
         """
         # graph is the class hierarchy graph for this subset
         graph = Graph()
@@ -1721,7 +1706,7 @@ def remove_package(self, package):
         package = self.packages[package.identifier]
         for descriptor in package.descriptor_list:
             graph.add_vertex(descriptor.sigstring)
-        for descriptor in package.descriptor_list:            
+        for descriptor in package.descriptor_list:
             base_id = descriptor.base_descriptor_id
             if base_id in package.descriptors_by_id:
                 base_descriptor = \
@@ -1733,24 +1718,26 @@ def remove_package(self, package):
         for sigstring in top_sort:
             self.delete_module(
                 *vistrails.core.modules.utils.parse_descriptor_string(sigstring))
-        
+
         # Remove upgraded package subworkflows from registry
         for key, version_dict in package._abs_pkg_upgrades.iteritems():
             for version, descriptor in version_dict.iteritems():
-                self.delete_module(descriptor.identifier, descriptor.name, 
+                self.delete_module(descriptor.identifier, descriptor.name,
                                    descriptor.namespace)
         package._abs_pkg_upgrades.clear()
-        
+
         package.unload()
         self.delete_package(package)
         self.signals.emit_deleted_package(package)
 
     def delete_input_port(self, descriptor, port_name):
-        """ Just remove a name input port with all of its specs """
+        """Remove an input port by name.
+        """
         descriptor.delete_input_port(port_name)
 
     def delete_output_port(self, descriptor, port_name):
-        """ Just remove a name output port with all of its specs """
+        """Removes an output port by name.
+        """
         descriptor.delete_output_port(port_name)
 
     def source_ports_from_descriptor(self, descriptor, sorted=True):
@@ -1758,29 +1745,29 @@ def source_ports_from_descriptor(self, descriptor, sorted=True):
         if sorted:
             ports.sort(key=lambda x: x.name)
         return ports
-    
+
     def destination_ports_from_descriptor(self, descriptor, sorted=True):
         ports = [p[1] for p in self.module_ports('input', descriptor)]
         if sorted:
             ports.sort(key=lambda x: x.name)
         return ports
-        
-    def all_source_ports(self, descriptor, sorted=True):
-        """Returns source ports for all hierarchy leading to given module"""
-        getter = self.source_ports_from_descriptor
-        return [(desc.name, getter(desc, sorted))
-                for desc in self.get_module_hierarchy(descriptor)]
 
     def all_destination_ports(self, descriptor, sorted=True):
-        """Returns destination ports for all hierarchy leading to
-        given module"""
+        """Returns input ports, including inherited, for the given module"""
         getter = self.destination_ports_from_descriptor
         return [(desc.name, getter(desc, sorted))
                 for desc in self.get_module_hierarchy(descriptor)]
 
+    def all_source_ports(self, descriptor, sorted=True):
+        """Returns output ports, including inherited, for the given module.
+        """
+        getter = self.source_ports_from_descriptor
+        return [(desc.name, getter(desc, sorted))
+                for desc in self.get_module_hierarchy(descriptor)]
+
     def get_port_from_all_destinations(self, descriptor, name):
-        """Searches for port identified by name in the destination ports
-        for all hierarchy leading to given module """
+        """Gets an input port, possibly inherited, on the given module.
+        """
         all_ports = self.all_destination_ports(descriptor)
         for (klass, port_list) in all_ports:
             for port in port_list:
@@ -1788,13 +1775,13 @@ def get_port_from_all_destinations(self, descriptor, name):
                     return port
         else:
             return None
-        
+
     def is_method(self, port_spec):
         basic_pkg = get_vistrails_basic_pkg_id()
         constant_desc = \
             self.get_descriptor_by_name(basic_pkg, 'Constant')
         return port_spec.type == 'input' and \
-            all(self.is_descriptor_subclass(d, constant_desc) 
+            all(self.is_descriptor_subclass(d, constant_desc)
                 for d in port_spec.descriptors())
     is_constant = is_method
 
@@ -1805,12 +1792,9 @@ def is_constant_module(self, module):
         return issubclass(module, constant_cls)
 
     def method_ports(self, module_descriptor):
-        """method_ports(module_descriptor: ModuleDescriptor) 
-              -> [PortSpec]}
-
-        Returns a list of port specs that are methods 
-        (spec contains only subclasses of Constant).
+        """Returns port specs that only contain subclasses of Constant.
 
+        :rtype: list[PortSpec]
         """
         getter = self.module_destination_ports_from_descriptor
         return [spec for spec in sorted(getter(False, module_descriptor),
@@ -1818,11 +1802,14 @@ def method_ports(self, module_descriptor):
                 if self.is_method(spec)]
 
     def port_and_port_spec_match(self, port, port_spec):
-        """port_and_port_spec_match(port: Port | PortSpec, 
-                                    port_spec: PortSpec
-                                    ) -> bool
-        Checks if port is similar to port_spec or not.  These ports must
-        have the same name and type"""
+        """Checks whether the ports match, i.e. have the same signature.
+
+        They must also have the same type (both input or both output) and name.
+
+        :type port: Port | PortSpec
+        :type port_spec: PortSpec
+        :rtype: bool
+        """
         if port.type in PortSpec.port_type_map:
             port_type = port.type
         elif port.type in PortSpec.port_type_map.inverse:
@@ -1839,9 +1826,8 @@ def port_and_port_spec_match(self, port, port_spec):
 
     def ports_can_connect(self, sourceModulePort, destinationModulePort,
                           allow_conversion=False, out_converters=None):
-        """ports_can_connect(sourceModulePort,destinationModulePort) ->
-        Boolean returns true if there could exist a connection
-        connecting these two ports."""
+        """Checks whether the given ports can be connected.
+        """
         if sourceModulePort.type == destinationModulePort.type:
             return False
         return self.are_specs_matched(sourceModulePort, destinationModulePort,
@@ -1849,10 +1835,9 @@ def ports_can_connect(self, sourceModulePort, destinationModulePort,
                                       out_converters=out_converters)
 
     def is_port_sub_type(self, sub, super):
-        """ is_port_sub_type(sub: Port, super: Port) -> bool        
-        Check if port super and sub are similar or not. These ports
-        must have exact name as well as position
-        
+        """Checks whether `sub` is a subclass of `super`.
+
+        They must also have the same type (both input or both output) and name.
         """
         if sub.type != super.type:
             return False
@@ -1905,9 +1890,7 @@ def is_descriptor_list_subclass(self, sub_descs, super_descs):
 
     def are_specs_matched(self, sub, super, allow_conversion=False,
                           out_converters=None):
-        """ are_specs_matched(sub: Port, super: Port) -> bool        
-        Check if specs of sub and super port are matched or not
-        
+        """Checks if specs of `sub` subclass `super`.
         """
         # For a connection, this gets called for sub -> super
         basic_pkg = get_vistrails_basic_pkg_id()
@@ -1955,9 +1938,12 @@ def are_specs_matched(self, sub, super, allow_conversion=False,
         return False
 
     def get_module_hierarchy(self, descriptor):
-        """get_module_hierarchy(descriptor) -> [klass].
-        Returns the module hierarchy all the way to Module, excluding
-        any mixins."""
+        """Returns the module and all its parents, in order.
+
+        This will return all the modules descriptor from the given one to the
+        one for the root Module. It will thus not return mixins (which
+        themselves don't subclass Module).
+        """
         if descriptor.module is None:
             descriptors = [descriptor]
             base_id = descriptor.base_descriptor_id
@@ -1971,74 +1957,64 @@ def get_module_hierarchy(self, descriptor):
                 if issubclass(klass, vistrails.core.modules.vistrails_module.Module)]
 
     def get_descriptor_subclasses(self, descriptor):
-        # need to find all descriptors that are subdescriptors of descriptor
+        """Finds descriptors that subclass the given descriptor.
+        """
         sub_list = []
         for pkg in self.package_versions.itervalues():
             for d in pkg.descriptor_list:
                 if self.is_descriptor_subclass(d, descriptor):
                     sub_list.append(d)
         return sub_list
-        
+
     def get_input_port_spec(self, module, portName):
-        """ get_input_port_spec(module: Module, portName: str) ->
-        spec-tuple Return the output port of a module given the module
-        and port name.
+        """Gets a PortSpec from a pipeline module and an input port name.
 
-        FIXME: This should be renamed.
-        
+        :type module: vistrails.core.vistrail.module.Module
+        :rtype: ModuleDescriptor | None
         """
-        descriptor = module.module_descriptor
         if module.has_port_spec(portName, 'input'):
             return module.get_port_spec(portName, 'input')
         return None
 
     def get_output_port_spec(self, module, portName):
-        """ get_output_port_spec(module: Module, portName: str) -> spec-tuple
-        Return the output port of a module given the module
-        and port name.
+        """Gets a PortSpec from a pipeline module and an output port name.
 
-        FIXME: This should be renamed.
-        
+        :type module: vistrails.core.vistrail.module.Module
+        :rtype: ModuleDescriptor | None
         """
-        descriptor = module.module_descriptor
         if module.has_port_spec(portName, 'output'):
             return module.get_port_spec(portName, 'output')
         return None
 
     @staticmethod
     def get_subclass_candidates(module):
-        """get_subclass_candidates(module) -> [class]
+        """Returns all Module superclasses of the given Module class.
+
+        Returns the superclasses of the given Module subclass, but only those
+        that are subclasses of Module themselves. This means that mixins won't
+        be returned, since they don't subclass Module directly.
 
-        Tries to eliminate irrelevant mixins for the hierarchy. Returns all
-        base classes that subclass from Module."""
+        :rtype: list[class]
+        """
         return [klass
                 for klass in module.__bases__
                 if issubclass(klass, vistrails.core.modules.vistrails_module.Module)]
 
     def set_current_package(self, package):
-        """ set_current_package(package: Package) -> None        
-        Set the current package for all addModule operations to
-        name. This means that all modules added after this call will
-        be assigned to the specified package.  Set package to None to
-        indicate that VisTrails default package should be used instead.
+        """Set the current package for all add_module() operations.
+
+        This means that all modules added after this call will be assigned to
+        the specified package.  Set package to None to indicate that VisTrails
+        default package should be used instead.
 
         Do not call this directly. The package manager will call this
         with the correct value prior to calling 'initialize' on the
         package.
-        
         """
         if package is None:
             package = self._default_package
         self._current_package = package
 
-    def get_module_package(self, identifier, name, namespace):
-        """ get_module_package(identifier, moduleName: str) -> str
-        Return the name of the package where the module is registered.
-        
-        """
-        descriptor = self.get_descriptor_by_name(identifier, name, namespace)
-        return descriptor.module_package()
-
     def get_configuration_widget(self, identifier, name, namespace):
         descriptor = self.get_descriptor_by_name(identifier, name, namespace)
         package = self.get_package_by_name(identifier)
@@ -2055,7 +2031,7 @@ def get_constant_config_params(self, widget_type=None, widget_use=None):
             widget_use = 'default'
         return (widget_type, widget_use)
 
-    def get_constant_config_widget(self, descriptor, widget_type=None, 
+    def get_constant_config_widget(self, descriptor, widget_type=None,
                                    widget_use=None):
         widget_type, widget_use = self.get_constant_config_params(widget_type,
                                                                   widget_use)
@@ -2071,7 +2047,7 @@ def get_all_constant_config_widgets(self, descriptor, widget_use=None):
             widgets.update(desc.get_all_constant_config_widgets(widget_use))
         return widgets.values()
 
-    def set_constant_config_widget(self, descriptor, widget_class, 
+    def set_constant_config_widget(self, descriptor, widget_class,
                                    widget_type=None, widget_use=None):
         widget_type, widget_use = self.get_constant_config_params(widget_type,
                                                                   widget_use)
@@ -2085,14 +2061,11 @@ def set_constant_config_widget(self, descriptor, widget_class,
                                               widget_use, widget_type)
 
     def is_descriptor_subclass(self, sub, super):
-        """is_descriptor_subclass(sub : ModuleDescriptor, 
-                                  super: ModuleDescriptor) -> bool
-        
+        """Checks whether a descriptor subclasses another.
         """
-        # use issubclass for speed if we've loaded the modules
         if sub.module is not None and super.module is not None:
             return issubclass(sub.module, super.module)
-        
+
         # otherwise, use descriptors themselves
         if sub == super:
             return True
@@ -2109,13 +2082,12 @@ def find_descriptor_subclass(self, d1, d2):
         elif self.is_descriptor_subclass(d2, d1):
             return d2
         return None
-        
+
     def find_descriptor_superclass(self, d1, d2):
-        """find_descriptor_superclass(d1: ModuleDescriptor,
-                                      d2: ModuleDescriptor) -> ModuleDescriptor
-        Finds the lowest common superclass descriptor for d1 and d2
+        """Finds the lowest common superclass descriptor for `d1` and `d2`
 
-        """        
+        :returns: The ModuleDescriptor or None
+        """
         if self.is_descriptor_subclass(d1, d2):
             return d2
         elif self.is_descriptor_subclass(d2, d1):
@@ -2135,7 +2107,7 @@ def find_descriptor_superclass(self, d1, d2):
     def is_abstraction(self, descriptor):
         basic_pkg = get_vistrails_basic_pkg_id()
         try:
-            abstraction_desc = self.get_descriptor_by_name(basic_pkg, 
+            abstraction_desc = self.get_descriptor_by_name(basic_pkg,
                                                        'SubWorkflow')
         except MissingModule:
             # No abstractions can be loaded before the basic
@@ -2143,7 +2115,7 @@ def is_abstraction(self, descriptor):
             return False
         return abstraction_desc != descriptor and \
             self.is_descriptor_subclass(descriptor, abstraction_desc)
-            
+
     def show_module(self, descriptor):
         self.signals.emit_show_module(descriptor)
     def hide_module(self, descriptor):
@@ -2151,7 +2123,7 @@ def hide_module(self, descriptor):
     def update_module(self, old_descriptor, new_descriptor):
         self.signals.emit_module_updated(old_descriptor, new_descriptor)
 
-    def expand_port_spec_string(self, p_string, cur_package=None, 
+    def expand_port_spec_string(self, p_string, cur_package=None,
                                 old_style=False):
         return vistrails.core.modules.utils.expand_port_spec_string(p_string, cur_package,
                                                           old_style)
diff --git a/vistrails/core/modules/output_modules.py b/vistrails/core/modules/output_modules.py
index be616692a..8c0905471 100644
--- a/vistrails/core/modules/output_modules.py
+++ b/vistrails/core/modules/output_modules.py
@@ -48,26 +48,51 @@
 import vistrails.core.system
 
 class OutputMode(object):
+    """A way of outputting a type of data, associated with a specific module.
+
+    OutputModule subclasses define different types that can be outputted. Each
+    is associated with multiple OutputModes, which are ways of outputting from
+    this module.
+    """
     mode_type = None
     priority = -1  # -1 prevents the mode from being selected automatically
 
     @staticmethod
     def can_compute():
+        """Whether this mode can be used right now.
+
+        This might check for requirements, configuration options, or other
+        things (are we running the GUI, ...)
+        """
         return False
 
     @classmethod
     def get_config(cls):
+        """The configuration class for that mode.
+        """
         return cls.config_cls
 
     def compute_output(self, output_module, configuration):
+        """Actually output using this mode.
+
+        This is called by the output module to handle the output when this mode
+        is selected, using the given configuration.
+        """
         raise NotImplementedError("Subclass of OutputMode should implement "
                                   "this")
 
 # Ideally, these are globally and locally configurable so that we use
 # global settings if nothing is set locally (e.g. output directory)
 class OutputModeConfig(dict):
+    """Set of configuration variables for a given OutputMode.
+
+    These are settings that are showed to the users so he can configure the
+    output. These variables will be passed to
+    :meth:`OutputMode.compute_output`.
+    """
     mode_type = None
     _fields = []
+
     def __init__(self, *args, **kwargs):
         dict.__init__(self, *args, **kwargs)
         for k, v in self.iteritems():
@@ -200,6 +225,12 @@ def __hasitem__(self, k):
                 self.has_override(k) or self.has_global_setting(k))
 
 class OutputModule(NotCacheable, Module):
+    """A configurable, pluggable sink module.
+
+    OutputModule subclasses define different types that can be outputted. Each
+    is associated with multiple OutputModes, which are ways of outputting from
+    this module.
+    """
     _input_ports = [IPort('value', "Variant"),
                     IPort('mode_type', "String"),
                     IPort('configuration', "Dictionary")]
@@ -488,9 +519,8 @@ def get_filename(self, configuration, full_path=None, filename=None,
             if dirname is None:
                 dirname = ''
             if not os.path.isabs(dirname):
-                vt_output_dir = getattr(get_vistrails_temp_configuration(),
-                                        'outputDirectory',
-                                        None)
+                vt_output_dir = get_vistrails_temp_configuration().check(
+                                                            'outputDirectory')
                 if vt_output_dir:
                     dirname = os.path.join(vt_output_dir, dirname)
 
diff --git a/vistrails/core/modules/package.py b/vistrails/core/modules/package.py
index 63fc7a075..7c1a1654e 100644
--- a/vistrails/core/modules/package.py
+++ b/vistrails/core/modules/package.py
@@ -146,7 +146,7 @@ def set_defaults(self, other=None):
             self.py_dependencies = set()
             self.old_identifiers = []
             self._default_configuration = None
-            self._persistent_configuration = None
+            self.persistent_configuration = None
         else:
             self._module = other._module
             self._init_module = other._init_module
@@ -159,8 +159,8 @@ def set_defaults(self, other=None):
             self.old_identifiers = [i for i in self.old_identifiers]
             self._default_configuration = \
                                         copy.copy(other._default_configuration)
-            self._persistent_configuration = \
-                                    copy.copy(other._persistent_configuration)
+            self.persistent_configuration = \
+                                    copy.copy(other.persistent_configuration)
 
         # FIXME decide whether we want None or ''
         if self.version is None:
@@ -689,13 +689,6 @@ def initialized(self):
     ##########################################################################
     # Configuration
 
-    def _get_persistent_configuration(self):
-        return self._persistent_configuration
-    def _set_persistent_configuration(self, config):
-        self._persistent_configuration = config
-    persistent_configuration = property(_get_persistent_configuration,
-                                        _set_persistent_configuration)
-
     def do_load_configuration(self):
         # Sometimes we don't want to change startup.xml, for example
         # when peeking at a package that's on the available package list
diff --git a/vistrails/core/modules/vistrails_module.py b/vistrails/core/modules/vistrails_module.py
index 81bf3ceb6..3bed1cf3c 100644
--- a/vistrails/core/modules/vistrails_module.py
+++ b/vistrails/core/modules/vistrails_module.py
@@ -174,7 +174,8 @@ class ModuleErrors(Exception):
 
     """
     def __init__(self, module_errors):
-        """ModuleErrors should be passed a list of ModuleError objects"""
+        """ModuleErrors should be passed a list of ModuleError objects
+        """
         Exception.__init__(self, str(tuple(me.msg for me in module_errors)))
         self.module_errors = module_errors
 
@@ -357,8 +358,7 @@ def __copy__(self):
         return clone
 
     def clear(self):
-        """clear(self) -> None.
-        Removes all references, prepares for deletion.
+        """Removes all references, prepares for deletion.
 
         """
         for connector_list in self.inputPorts.itervalues():
@@ -371,19 +371,19 @@ def clear(self):
         self._latest_method_order = 0
 
     def is_cacheable(self):
-        """is_cacheable() -> bool.
-        A Module should return whether it can be
-        reused across executions. It is safe for a Module to return
-        different values in different occasions. In other words, it is
-        possible for modules to be cacheable depending on their
-        execution context.
+        """Returns whether this Module can be reused between executions.
+
+        It is safe for a Module to return different values in different
+        occasions. In other words, it is possible for modules to be cacheable
+        depending on their execution context.
 
         """
         return True
 
     def update_upstream_port(self, port_name):
-        """Updates upstream of a single port instead of all ports."""
+        """Updates upstream of a single port instead of all ports.
 
+        """
         if port_name in self.inputPorts:
             for connector in self.inputPorts[port_name]:
                 connector.obj.update() # Might raise
@@ -393,8 +393,9 @@ def update_upstream_port(self, port_name):
 
 
     def useJobCache(self):
-        """ useJobCache() -> Module/None
-            Checks if this is a job cache
+        """Checks if this is a job cache
+
+        DOCTODO
         """
         if not self.moduleInfo.get('pipeline', None):
             return False
@@ -409,8 +410,9 @@ def useJobCache(self):
         return False
 
     def setJobCache(self):
-        """ setJobCache() -> Boolean
-            Checks if this is a job cache and it exists
+        """Checks if this is a job cache and it exists
+
+        DOCTODO
         """
         p_module = self.useJobCache()
         if not p_module:
@@ -432,8 +434,9 @@ def setJobCache(self):
         return False
 
     def addJobCache(self):
-        """ addJobCache() -> None
-            Add outputs from job cache
+        """Add outputs from job cache
+
+        DOCTODO
         """
         p_module = self.useJobCache()
         if not p_module:
@@ -454,10 +457,7 @@ def addJobCache(self):
                 jm.setCache(self.signature, params, p_module.name)
 
     def update_upstream(self):
-        """ update_upstream() -> None
-        Go upstream from the current module, then update its upstream
-        modules and check input connection based on upstream modules
-        results
+        """Recursively update the modules upstream of this one.
 
         """
         suspended = []
@@ -487,8 +487,7 @@ def update_upstream(self):
                     self.remove_input_connector(iport, connector)
 
     def set_iterated_ports(self):
-        """ set_iterated_ports() -> None
-        Calculates which inputs needs to be iterated over
+        """Calculates which inputs needs to be iterated over
         """
         iports = {}
         from vistrails.core.modules.basic_modules import List, Variant
@@ -528,8 +527,7 @@ def set_iterated_ports(self):
                                if p in iports]
 
     def set_streamed_ports(self):
-        """ set_streamed_ports() -> None
-        Calculates which inputs will be streamed
+        """Calculates which inputs will be streamed
 
         """
         self.streamed_ports = {}
@@ -541,9 +539,11 @@ def set_streamed_ports(self):
                     self.streamed_ports[iport] = value
 
     def update(self):
-        """ update() -> None
-        Check if the module is up-to-date then update the
-        modules. Report to the logger if available
+        """Check module status, update upstream and run compute.
+
+        This is the execution logic for the module. It handled all the
+        different possible states (cached, suspended, already failed), run the
+        upstream and the compute() method, reporting everything to the logger.
 
         """
         if self.had_error:
@@ -644,7 +644,9 @@ def get_combine_type(self, default="cartesian"):
 
     def compute_all(self):
         """This method executes the module once for each input.
-           Similarly to controlflow's fold.
+
+        Similarly to controlflow's fold, it calls update() in a loop to handle
+        lists of inputs.
 
         """
         from vistrails.core.modules.sub_module import InputPort
@@ -829,7 +831,7 @@ def generator(self):
 
     def compute_accumulate(self):
         """This method creates a generator object that converts all
-        streaming inputs to list inputs for modules that does not explicitly
+        streaming inputs to list inputs for modules that do not explicitly
         support streaming.
 
         """
@@ -948,8 +950,10 @@ def generator(self):
             self.set_output(name_output, iterator)
 
     def compute_while(self):
-        """This method executes the module once for each module.
-           Similarly to fold.
+        """This method executes the module once for each input.
+
+        Similarly to controlflow's fold, it calls update() in a loop to handle
+        lists of inputs.
 
         """
         name_condition = self.control_params.get(
@@ -1048,8 +1052,7 @@ def compute_while(self):
             self.set_output(name_output, module.get_output(name_output))
 
     def setInputValues(self, module, inputPorts, elementList, iteration):
-        """
-        Function used to set a value inside 'module', given the input port(s).
+        """Function used to set a value inside 'module', given the input ports.
         """
         from vistrails.core.modules.basic_modules import create_constant
         for element, inputPort in izip(elementList, inputPorts):
@@ -1103,9 +1106,7 @@ def get_type_checks(source_spec):
                 for desc in source_spec.descriptors()]
 
     def typeChecking(self, module, inputPorts, inputList):
-        """
-        Function used to check if the types of the input list element and of the
-        inputPort of 'module' match.
+        """Checks if elements of `inputList` match the `inputPort` types.
         """
         from vistrails.core.modules.basic_modules import Generator
         from vistrails.core.modules.basic_modules import get_module
@@ -1398,7 +1399,6 @@ def __str__(self):
         return "<<%s>>" % str(self.__class__)
 
     def annotate(self, d):
-
         """Manually add provenance information to the module's execution
         trace.  For example, a module that generates random numbers
         might add the seed that was used to initialize the generator.
@@ -1420,9 +1420,7 @@ def set_input_port(self, port_name, conn, is_method=False):
             self._latest_method_order += 1
 
     def enable_output_port(self, port_name):
-
-        """ enable_output_port(port_name: str) -> None
-        Set an output port to be active to store result of computation
+        """Set an output port to be active to store result of computation
 
         """
         # Don't reset existing values, it screws up the caching.
@@ -1430,9 +1428,9 @@ def enable_output_port(self, port_name):
             self.set_output(port_name, None)
 
     def remove_input_connector(self, port_name, connector):
-        """ remove_input_connector(port_name: str,
-                                 connector: ModuleConnector) -> None
-        Remove a connector from the connection list of an input port
+        """Remove a connector from the connection list of an input port
+
+        :type connector: ModuleConnector
 
         """
         if port_name in self.inputPorts:
@@ -1442,23 +1440,9 @@ def remove_input_connector(self, port_name, connector):
             if conList==[]:
                 del self.inputPorts[port_name]
 
-    def create_instance_of_type(self, ident, name, ns=''):
-        """ Create a vistrails module from the module registry.  This creates
-        an instance of the module for use in creating the object output by a
-        Module.
-        """
-        from vistrails.core.modules.module_registry import get_module_registry
-        try:
-            reg = get_module_registry()
-            m = reg.get_module_by_name(ident, name, ns)
-            return m()
-        except:
-            msg = "Cannot get module named " + str(name) + \
-                  " with identifier " + str(ident) + " and namespace " + ns
-            raise ModuleError(self, msg)
-
     def set_streaming(self, UserGenerator):
-        """creates a generator object that computes when the next input is received.
+        """Creates a generator object that computes when the next input is
+        received.
         """
         # use the below tag if calling from a PythonSource
         # pragma: streaming - This tag is magic, do not change.
@@ -1565,8 +1549,7 @@ def _Generator():
                                         port=port))
 
     def job_monitor(self):
-        """ job_monitor() -> JobMonitor
-        Returns the JobMonitor for the associated controller if it exists
+        """Returns the JobMonitor for the associated controller if it exists.
         """
         if 'job_monitor' not in self.moduleInfo or \
            not self.moduleInfo['job_monitor']:
@@ -1652,7 +1635,6 @@ class Streaming(object):
     """ A mixin indicating support for streamable inputs
 
     """
-    pass
 
 ################################################################################
 
@@ -1716,12 +1698,12 @@ def __init__(self, obj, port, spec=None, typecheck=None):
         self.typecheck = typecheck
 
     def clear(self):
-        """clear() -> None. Removes references, prepares for deletion."""
+        """Removes references, prepares for deletion."""
         self.obj = None
         self.port = None
 
     def depth(self, fix_list=True):
-        """depth(result) -> int. Returns the list depth of the port value."""
+        """Returns the list depth of the port value."""
         from vistrails.core.modules.basic_modules import List
         depth = self.obj.list_depth + self.spec.depth
         descs = self.spec.descriptors()
@@ -1731,7 +1713,7 @@ def depth(self, fix_list=True):
         return depth
 
     def get_raw(self):
-        """get_raw() -> Module. Returns the value or a Generator."""
+        """Returns the value or a Generator."""
         return self.obj.get_output(self.port)
 
 
@@ -1803,14 +1785,15 @@ def __call__(self):
 
 
 def new_module(base_module, name, class_dict={}, docstring=None):
-    """new_module(base_module or [base_module list],
-                  name,
-                  class_dict={},
-                  docstring=None
-
-    Creates a new VisTrails module dynamically. Exactly one of the
-    elements of the base_module list (or base_module itself, in the case
-    it's a single class) should be a subclass of Module.
+    """Creates a new VisTrails module dynamically.
+
+    :type base_module: class | list[class]
+    :type name: str
+    :type class_dict: dict
+    :type docstring: str | None
+
+    Exactly one of the elements of the base_module list (or base_module itself,
+    in case it's a single class) should be a subclass of Module.
     """
     if isinstance(base_module, type):
         assert issubclass(base_module, Module)
diff --git a/vistrails/core/packagemanager.py b/vistrails/core/packagemanager.py
index b1c689420..6af5c3831 100644
--- a/vistrails/core/packagemanager.py
+++ b/vistrails/core/packagemanager.py
@@ -587,8 +587,11 @@ def initialize_packages(self, prefix_dictionary={},
                     prefix = self._default_prefix_dict.get(package.codepath)
                 package.load(prefix)
             except Package.LoadFailed, e:
-                debug.critical("Package %s failed to load and will be "
-                               "disabled" % package.name, e)
+                debug.critical(
+                        "Package %s failed to load and will be disabled" % (
+                            package.name or
+                            ("<codepath %s>" % package.codepath)),
+                        e)
                 # We disable the package manually to skip over things
                 # we know will not be necessary - the only thing needed is
                 # the reference in the package list
diff --git a/vistrails/core/requirements.py b/vistrails/core/requirements.py
index 8b662b97c..9f45f453f 100644
--- a/vistrails/core/requirements.py
+++ b/vistrails/core/requirements.py
@@ -34,8 +34,9 @@
 ##
 ###############################################################################
 
-"""module that allows online inspection of environment to test presence of
-runtime components such as binaries, libraries, other python modules, etc."""
+"""Online checking for required runtime components.
+"""
+
 from __future__ import division
 
 import os
@@ -45,12 +46,9 @@
 from vistrails.core.configuration import get_vistrails_configuration
 import vistrails.core.system
 
-##############################################################################
 
 def python_module_exists(module_name):
-    """python_module_exists(module_name): Boolean.
-    Returns if python module of given name can be safely imported.
-
+    """Checks that a Python module is importable, and return True or False.
     """
     if module_name in sys.modules:
         return True
@@ -59,21 +57,27 @@ def python_module_exists(module_name):
         return True
     except ImportError:
         return False
-    
+
 
 def executable_file_exists(filename):
-    """executable_file_exists(filename): Boolean.
-    Returns if certain file is in current path and is executable.
-    
+    """Checks whether the given executable file name is in the PATH.
     """
     result = vistrails.core.system.executable_is_in_path(filename)
     if not result:
         result = vistrails.core.system.executable_is_in_path(filename)
     return result
 
-# FIXME: Add documentation.
 
 def require_python_module(module_name, dep_dict=None):
+    """Fail if the given Python module isn't importable and can't be installed.
+
+    This raises `MissingRequirements` and is thus suitable for use in a
+    package's `package_requirements()` function. If `dep_dict` is provided, it
+    will try to install the requirement before failing, using
+    :func:`~vistrails.core.bundles.installbundle.install`.
+
+    :raises MissingRequirement: on error
+    """
     exists = python_module_exists(module_name)
     if (not exists and
             dep_dict and
@@ -83,19 +87,29 @@ def require_python_module(module_name, dep_dict=None):
     if not exists:
         raise MissingRequirement(module_name)
 
+
 def require_executable(filename):
+    """Fail if the given executable file name is not in PATH.
+
+    This raises `MissingRequirements` and is thus suitable for use in a
+    package's `package_requirements()` function.
+
+    :raises MissingRequirement: on error
+    """
     if not executable_file_exists(filename):
         raise MissingRequirement(filename)
 
-##############################################################################
 
 class MissingRequirement(Exception):
-    """Raise this exception in packages when necessary items are missing."""
+    """Indicates that a package won't run because it's missing dependencies.
+    """
     def __init__(self, req):
         self.requirement = req
+
     def __str__(self):
         return "Missing Requirement: %s" % self.requirement
 
+
 ##############################################################################
 
 def setNewPyQtAPI():
diff --git a/vistrails/core/resources/default_vistrails_startup_xml b/vistrails/core/resources/default_vistrails_startup.xml
similarity index 100%
rename from vistrails/core/resources/default_vistrails_startup_xml
rename to vistrails/core/resources/default_vistrails_startup.xml
diff --git a/vistrails/core/resources/spawned_startup_xml b/vistrails/core/resources/spawned_startup.xml
similarity index 100%
rename from vistrails/core/resources/spawned_startup_xml
rename to vistrails/core/resources/spawned_startup.xml
diff --git a/vistrails/core/startup.py b/vistrails/core/startup.py
index ce463bfb6..275dee62c 100644
--- a/vistrails/core/startup.py
+++ b/vistrails/core/startup.py
@@ -164,7 +164,7 @@ def clean_dotvistrails():
             command_line_config.dotVistrails = tmpdir
             shutil.copyfile(os.path.join(system.vistrails_root_directory(),
                                          'core', 'resources',
-                                         'spawned_startup_xml'),
+                                         'spawned_startup.xml'),
                             os.path.join(tmpdir, 'startup.xml'))
             command_line_config.enablePackagesSilently = True
             command_line_config.errorLog = False
@@ -463,7 +463,7 @@ def create_startupxml_if_needed(self):
         if needs_create:
             root_dir = system.vistrails_root_directory()
             origin = os.path.join(root_dir, 'core','resources',
-                                  'default_vistrails_startup_xml')
+                                  'default_vistrails_startup.xml')
             try:
                 shutil.copyfile(origin, fname)
                 debug.log('Succeeded!')
diff --git a/vistrails/core/system/__init__.py b/vistrails/core/system/__init__.py
index 915d44fa2..f170cee99 100644
--- a/vistrails/core/system/__init__.py
+++ b/vistrails/core/system/__init__.py
@@ -299,7 +299,7 @@ def default_connections_file():
     """
     return os.path.join(current_dot_vistrails(), 'connections.xml')
 
-VERSION = '2.2.4'
+VERSION = '2.x'
 def vistrails_version():
     """vistrails_version() -> string - Returns the current VisTrails version."""
     # 0.1 was the Vis2005 version
diff --git a/vistrails/core/upgradeworkflow.py b/vistrails/core/upgradeworkflow.py
index 41f6a81ab..3b660b170 100644
--- a/vistrails/core/upgradeworkflow.py
+++ b/vistrails/core/upgradeworkflow.py
@@ -377,7 +377,7 @@ def attempt_automatic_upgrade(controller, pipeline, module_id,
                                   function_remap=None, src_port_remap=None, 
                                   dst_port_remap=None, annotation_remap=None,
                                   control_param_remap=None):
-        """attempt_automatic_upgrade(module_id, pipeline): [Action]
+        """Automatically upgrade by simply replacing a module with the new version.
 
         Attempts to automatically upgrade module by simply adding a
         new module with the current package version, and recreating
@@ -716,7 +716,6 @@ def replace_module(controller, pipeline, module_id, new_descriptor,
 
     @staticmethod
     def remap_module(controller, module_id, pipeline, pkg_remap):
-
         """remap_module offers a method to shortcut the
         specification of upgrades.  It is useful when just changing
         the names of ports or modules, but can also be used to add
@@ -725,13 +724,17 @@ def remap_module(controller, module_id, pipeline, pkg_remap):
         first three arguments are passed from the arguments to that
         method.
 
-        pkg_remap specifies all of the changes and is of the format
-        {<old_module_name>: [(<start_version>, <end_version>, 
-                             <new_module_klass> | <new_module_id> | None, 
-                             <remap_dictionary>)]}
+        pkg_remap specifies all of the changes and is of the format::
+
+            {<old_module_name>: [(<start_version>, <end_version>,
+                                  <new_module_klass> | <new_module_id> | None,
+                                  <remap_dictionary>)]}
+
         where new_module_klass is the class and new_module_id
-        is a string of the format 
+        is a string of the format::
+
             <package_name>:[<namespace> | ]<module_name>
+
         passing None keeps the original name,
         and remap_dictionary is {<remap_type>:
         <name_changes>} and <name_changes> is a map from <old_name> to
@@ -740,20 +743,22 @@ def remap_module(controller, module_id, pipeline, pkg_remap):
         module and should return a list of operations with elements of
         the form ('add', <obj>).
 
-        For example:
-
-        def outputName_remap(old_conn, new_module):
-            ops = []
-            ...
-            return ops
-        pkg_remap = {'FileSink': [(None, '1.5.1', FileSink,
-                                     {'dst_port_remap':
-                                          {'overrideFile': 'overwrite',
-                                           'outputName': outputName_remap},
-                                      'function_remap':
-                                          {'overrideFile': 'overwrite',
-                                           'outputName': 'outputPath'}}),
-                        }
+        For example::
+
+            def outputName_remap(old_conn, new_module):
+                ops = []
+                ...
+                return ops
+
+            pkg_remap = {'FileSink': [
+                             (None, '1.5.1', FileSink, {
+                                  'dst_port_remap': {
+                                      'overrideFile': 'overwrite',
+                                      'outputName': outputName_remap},
+                                  'function_remap': {
+                                      'overrideFile': 'overwrite',
+                                      'outputName': 'outputPath'}}),
+            }
         """
 
         reg = get_module_registry()
diff --git a/vistrails/core/utils/__init__.py b/vistrails/core/utils/__init__.py
index 55e700775..82d9d369a 100644
--- a/vistrails/core/utils/__init__.py
+++ b/vistrails/core/utils/__init__.py
@@ -486,23 +486,6 @@ def set_execution_progress(self, *args, **kwargs): pass
     def flushMoveActions(self, *args, **kwargs): pass
     def scene(self): 
         return self._scene
-##############################################################################    
-# FIXME: Add tests
-def no_interrupt(callable_, *args, **kwargs):
-    """no_interrupt(callable_, *args, **kwargs) -> return arguments
-    from callable.
-
-    Calls callable_ with *args and **kwargs and keeps retrying as long as call
-is interrupted by the OS. This makes calling read more convenient when
-using output from the subprocess module."""
-    while True:
-        try:
-            return callable_(*args, **kwargs)
-        except IOError, e:
-            if e.errno == errno.EINTR:
-                continue
-            else:
-                raise
 
 ################################################################################
 # class for creating weak references to bound methods
diff --git a/vistrails/core/vistrail/controller.py b/vistrails/core/vistrail/controller.py
index 77dce14ed..5840e965f 100644
--- a/vistrails/core/vistrail/controller.py
+++ b/vistrails/core/vistrail/controller.py
@@ -185,10 +185,6 @@ def __init__(self, vistrail=None, locator=None, abstractions=None,
         # when writing the vistrail
         self._mashups = []
 
-        # the redo stack stores the undone action ids 
-        # (undo is automatic with us, through the version tree)
-        self.redo_stack = []
-
         # this is a reference to the current parameter exploration
         self.current_parameter_exploration = None
         
@@ -202,13 +198,6 @@ def __init__(self, vistrail=None, locator=None, abstractions=None,
                           id_scope=id_scope, 
                           set_log_on_vt=set_log_on_vt)
 
-    # allow gui.vistrail_controller to reference individual views
-    def _get_current_version(self):
-        return self._current_version
-    def _set_current_version(self, version):
-        self._current_version = version
-    current_version = property(_get_current_version, _set_current_version)
-
     def _get_current_base_version(self):
         version = self.current_version
         if self._upgrade_rev_map:
@@ -217,12 +206,6 @@ def _get_current_base_version(self):
             return version
     current_base_version = property(_get_current_base_version)
 
-    def _get_current_pipeline(self):
-        return self._current_pipeline
-    def _set_current_pipeline(self, pipeline):
-        self._current_pipeline = pipeline
-    current_pipeline = property(_get_current_pipeline, _set_current_pipeline)
-
     def flush_pipeline_cache(self):
         self._pipelines = {0: Pipeline()}
 
@@ -1063,7 +1046,6 @@ def add_module_from_descriptor(self, descriptor, x=0.0, y=0.0,
         action = self.add_module_action(module)
         return module
 
-
     def add_module(self, identifier, name, namespace='', x=0.0, y=0.0, 
                    internal_version=-1):
         """ addModule(x: int, y: int, identifier, name: str, namespace='') 
@@ -1474,8 +1456,6 @@ def create_ungroup(self, module_id):
         self.validate(self.current_pipeline, False)
         return res
 
-
-
     ##########################################################################
     # Methods to access/find pipeline information
     
@@ -1765,7 +1745,6 @@ def add_to_pipeline(port_type, port, other_port, names):
                     raise VistrailsInternalError("port_type incorrect")
                 pipeline.add_connection(new_conn)
             return (old_module, old_port_name, new_name)
-            
 
         outside_connections = []
         existing_ports = {}
@@ -4045,7 +4024,6 @@ def write_vistrail(self, locator, version=None, export=False):
                                                debug.format_exception(e)))
             return result
 
-
     def write_workflow(self, locator, version=None):
         if self.current_pipeline:
             pipeline = Pipeline()
@@ -4086,41 +4064,6 @@ def write_registry(self, locator):
     def update_checkout_version(self, app=''):
         self.vistrail.update_checkout_version(app)
 
-    def reset_redo_stack(self):
-        self.redo_stack = []
-
-    def undo(self):
-        """Performs one undo step, moving up the version tree."""
-        action_map = self.vistrail.actionMap
-        old_action = action_map.get(self.current_version, None)
-        self.redo_stack.append(self.current_version)
-        self.show_parent_version()
-        new_action = action_map.get(self.current_version, None)
-        return (old_action, new_action)
-        # self.set_pipeline_selection(old_action, new_action, 'undo')
-        # return self.current_version
-
-    def redo(self):
-        """Performs one redo step if possible, moving down the version tree."""
-        action_map = self.vistrail.actionMap
-        old_action = action_map.get(self.current_version, None)
-        if len(self.redo_stack) < 1:
-            debug.critical("Redo on an empty redo stack. Ignoring.")
-            return
-        next_version = self.redo_stack[-1]
-        self.redo_stack = self.redo_stack[:-1]
-        self.show_child_version(next_version)
-        new_action = action_map[self.current_version]
-        return (old_action, new_action)
-        # self.set_pipeline_selection(old_action, new_action, 'redo')
-        # return next_version
-
-    def can_redo(self):
-        return (len(self.redo_stack) > 0)
-
-    def can_undo(self):
-        return self.current_version > 0
-
     def layout_modules(self, old_modules=[], preserve_order=False, 
                new_modules=[], new_connections=[], module_size_func=None, no_gaps=False):
         """Lays out modules and returns the new version.
diff --git a/vistrails/core/vistrail/module.py b/vistrails/core/vistrail/module.py
index f4d5e6c65..c37406c6c 100644
--- a/vistrails/core/vistrail/module.py
+++ b/vistrails/core/vistrail/module.py
@@ -337,6 +337,23 @@ def destinationPorts(self):
         ports.extend(self.input_port_specs)
         return ports
 
+    def unionPorts(self):
+        """unionPorts() -> dict of {union_name: list of ports}
+        Returns dict of union (input) ports module supports
+
+        They are used to indicate that ports are really the same port but of
+        different types.
+        """
+        ports = self.destinationPorts()
+        groups = {}
+        for port_spec in ports:
+            if port_spec.union:
+                if port_spec.union not in groups:
+                    groups[port_spec.union] = []
+                groups[port_spec.union].append(port_spec)
+        return groups
+
+
     ##########################################################################
     # Debugging
 
diff --git a/vistrails/core/vistrail/module_param.py b/vistrails/core/vistrail/module_param.py
index d1dc2ab29..614b464b5 100644
--- a/vistrails/core/vistrail/module_param.py
+++ b/vistrails/core/vistrail/module_param.py
@@ -95,7 +95,7 @@ def __init__(self, *args, **kwargs):
         self.queryMethod = None
 
         # this is used for parameter settings
-        self._port_spec_item = None
+        self.port_spec_item = None
 
         # Used by constant widgets to determine how default is displayed
         self.param_exists = True
@@ -110,7 +110,7 @@ def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
         cp.maxValue = self.maxValue
         cp.evaluatedStrValue = self.evaluatedStrValue
         cp.queryMethod = self.queryMethod
-        cp._port_spec_item = self._port_spec_item
+        cp.port_spec_item = self.port_spec_item
 
         # cp.identifier = self.identifier
         # cp.namespace = self.namespace
@@ -128,7 +128,7 @@ def convert(_parameter):
         _parameter.minValue = ""
         _parameter.maxValue = ""
         _parameter.evaluatedStrValue = ""
-        _parameter._port_spec_item = None
+        _parameter.port_spec_item = None
 
         # _parameter.identifier = ""
         # _parameter.namespace = ""
@@ -190,12 +190,6 @@ def _set_identifier(self, identifier):
         self._identifier = identifier
         self.update_db_type()
     identifier = property(_get_identifier, _set_identifier)
-        
-    def _get_port_spec_item(self):
-        return self._port_spec_item
-    def _set_port_spec_item(self, psi):
-        self._port_spec_item = psi
-    port_spec_item = property(_get_port_spec_item, _set_port_spec_item)
 
     def _get_spec_tuple(self):
         return (self._identifier, self._type, self._namespace)
diff --git a/vistrails/core/vistrail/pipeline.py b/vistrails/core/vistrail/pipeline.py
index 5f031a298..9f1ff2652 100644
--- a/vistrails/core/vistrail/pipeline.py
+++ b/vistrails/core/vistrail/pipeline.py
@@ -251,12 +251,14 @@ def _get_connection_list(self):
 
     def clear(self):
         """clear() -> None. Erases pipeline contents."""
-        if hasattr(self, 'db_modules'):
-            for module in self.db_modules:
-                self.db_delete_module(module)
         if hasattr(self, 'db_connections'):
-            for connection in self.db_connections:
-                self.db_delete_connection(connection)
+            while self.db_connections:
+                self.db_delete_object(self.db_connections[0].id,
+                                      Connection.vtType)
+        if hasattr(self, 'db_modules'):
+            while self.db_modules:
+                self.db_delete_object(self.db_modules[0].id,
+                                      Module.vtType)
         self.graph = Graph()
         self.aliases = Bidict()
         self._subpipeline_signatures = Bidict()
diff --git a/vistrails/core/vistrail/port_spec.py b/vistrails/core/vistrail/port_spec.py
index 5a4e2aefe..5bfc02566 100644
--- a/vistrails/core/vistrail/port_spec.py
+++ b/vistrails/core/vistrail/port_spec.py
@@ -125,6 +125,8 @@ def __init__(self, *args, **kwargs):
             kwargs['sort_key'] = -1
         if 'depth' not in kwargs:
             kwargs['depth'] = 0
+        if 'union' not in kwargs:
+            kwargs['union'] = ''
         if 'id' not in kwargs:
             kwargs['id'] = -1
         if 'tooltip' in kwargs:
@@ -132,6 +134,11 @@ def __init__(self, *args, **kwargs):
             del kwargs['tooltip']
         else:
             self._tooltip = None
+        if 'union_tooltip' in kwargs:
+            self._union_tooltip = kwargs['union_tooltip']
+            del kwargs['union_tooltip']
+        else:
+            self._union_tooltip = None
 
         if 'docstring' in kwargs:
             self._docstring = kwargs['docstring']
@@ -221,6 +228,7 @@ def from_sigstring(sigstring):
     min_conns = DBPortSpec.db_min_conns
     max_conns = DBPortSpec.db_max_conns
     _depth = DBPortSpec.db_depth
+    union = DBPortSpec.db_union
     port_spec_items = DBPortSpec.db_portSpecItems
     items = DBPortSpec.db_portSpecItems
 
@@ -259,7 +267,11 @@ def _set_depth(self, depth):
         self._depth = depth
     depth = property(_get_depth, _set_depth)
 
-    def toolTip(self):
+    def toolTip(self, union=None):
+        if union:
+            if self._union_tooltip is None:
+                self.create_union_tooltip(union)
+            return self._union_tooltip
         if self._tooltip is None:
             self.create_tooltip()
         return self._tooltip
@@ -404,12 +416,28 @@ def create_tooltip(self):
             port_string = self.type.capitalize()
         else:
             port_string = 'Invalid'
-        _depth = " (depth %s)" % self.depth if self.depth else ''
+        depth = " (depth %s)" % self.depth if self.depth else ''
         self._tooltip = "%s port %s\n%s%s" % (port_string,
-                                            self.name,
+                                            self.union if self.union else self.name,
                                             self._short_sigstring,
-                                            _depth)
-        
+                                            depth)
+
+    def create_union_tooltip(self, union):
+        """Creates a tooltip for a union port
+        """
+
+        type_list = []
+        for ps in union:
+            type_list.append(ps.type_name())
+
+        if self.type in ['input', 'output']:
+            port_string = self.type.capitalize()
+        else:
+            port_string = 'Invalid'
+        self._union_tooltip = "%s port %s\n%s" % (port_string,
+                                                  self.union if self.union else self.name,
+                                                  '\n'.join(type_list))
+
     ##########################################################################
     # Operators
     
@@ -418,8 +446,8 @@ def __str__(self):
         object. 
 
         """
-        rep = "<portSpec id=%s name=%s type=%s signature=%s depth=%s />"
-        return  rep % (str(self.id), str(self.name), 
+        rep = "<portSpec id=%s name=%s union=%s type=%s signature=%s depth=%s />"
+        return  rep % (str(self.id), str(self.name), str(self.union),
                        str(self.type), str(self.sigstring), str(self.depth))
 
     def __eq__(self, other):
@@ -468,6 +496,18 @@ def key_no_id(self):
                 self.name,
                 self.signature)
 
+    def type_name(self):
+        """ Returns a one-line type description
+        """
+        depths = 'List of ' * self.depth
+        descriptors = self.descriptors()
+        if len(descriptors) > 1:
+            name = "(" + ",".join(d.name for d in descriptors) + ")"
+        else:
+            name = descriptors[0].name
+        return depths + name
+
+
 ################################################################################
 # Testing
 
diff --git a/vistrails/core/vistrail/vistrail.py b/vistrails/core/vistrail/vistrail.py
index 56c58b068..ad9625141 100644
--- a/vistrails/core/vistrail/vistrail.py
+++ b/vistrails/core/vistrail/vistrail.py
@@ -169,6 +169,7 @@ def convert(_vistrail):
     annotations = DBVistrail.db_annotations
     action_annotations = DBVistrail.db_actionAnnotations
     vistrail_variables = DBVistrail.db_vistrailVariables
+    vistrail_vars = vistrail_variables
     parameter_explorations = DBVistrail.db_parameter_explorations
     
     def _get_actionMap(self):
@@ -216,13 +217,6 @@ def _set_database_info(self, value):
         return self.set_annotation("__database_info__", value)
     database_info = property(_get_database_info, _set_database_info)
     
-    def _get_vistrail_vars(self):
-        return self.vistrail_variables
-    
-    def _set_vistrail_vars(self, vars):
-        self.vistrail_variables = vars
-    vistrail_vars = property(_get_vistrail_vars, _set_vistrail_vars)
-    
     def has_vistrail_var(self, name):
         return self.db_has_vistrailVariable_with_name(name)
     
diff --git a/vistrails/db/bin/generate.py b/vistrails/db/bin/generate.py
index 4b1d1d7b3..d61f2e201 100644
--- a/vistrails/db/bin/generate.py
+++ b/vistrails/db/bin/generate.py
@@ -147,9 +147,8 @@ def preprocess_template(in_fname, out_fname=None):
     in_file.close()
 
 def indent_python(fname):
-    subprocess.Popen(["emacs", "-batch", fname, "-f", "mark-whole-buffer",
-                      "-f", "indent-region", "-f", "save-buffer", "-kill"],
-                     stdout=subprocess.PIPE).communicate()
+    import autopep8
+    autopep8.fix_file(fname, options=autopep8.parse_args([fname, '-i']))
 
 def run_template(template_fname, objects, version, version_string, output_file,
                  indent=False):
diff --git a/vistrails/db/domain/__init__.py b/vistrails/db/domain/__init__.py
index 7eb838a8c..6f6ec5eb9 100644
--- a/vistrails/db/domain/__init__.py
+++ b/vistrails/db/domain/__init__.py
@@ -34,6 +34,4 @@
 ##
 ###############################################################################
 
-from __future__ import division
-
-from vistrails.db.versions.v1_0_4.domain import *
+from vistrails.db.versions.v1_0_5.domain import *
diff --git a/vistrails/db/persistence/__init__.py b/vistrails/db/persistence/__init__.py
index b6e3a5c48..4f9097675 100644
--- a/vistrails/db/persistence/__init__.py
+++ b/vistrails/db/persistence/__init__.py
@@ -33,7 +33,6 @@
 ## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 ##
 ###############################################################################
-
 from __future__ import division
 
-from vistrails.db.versions.v1_0_4.persistence import *
+from vistrails.db.versions.v1_0_5.persistence import *
diff --git a/vistrails/db/services/locator.py b/vistrails/db/services/locator.py
index 726516c01..ac760981b 100644
--- a/vistrails/db/services/locator.py
+++ b/vistrails/db/services/locator.py
@@ -716,6 +716,8 @@ def __init__(self, host, port, database, user, passwd, name=None,
         self._hash = ''
         self.kwargs = kwargs
         self._obj_id = self.kwargs.get('obj_id', None)
+        if self._obj_id is not None:
+            self._obj_id = long(self._obj_id)
         self._obj_type = self.kwargs.get('obj_type', None)
         self._conn_id = self.kwargs.get('connection_id', None)
         self._vnode = self.kwargs.get('version_node', None)
@@ -855,6 +857,8 @@ def save(self, save_bundle, do_copy=False, version=None):
         save_bundle = io.save_bundle_to_db(save_bundle, connection, do_copy, version)
         primary_obj = save_bundle.get_primary_obj()
         self._obj_id = primary_obj.db_id
+        if self._obj_id is not None:
+            self._obj_id = long(self._obj_id)
         self._obj_type = primary_obj.vtType
         for obj in save_bundle.get_db_objs():
             obj.locator = self
@@ -1049,7 +1053,7 @@ def __eq__(self, other):
                 self._db == other._db and
                 self._user == other._user and
                 #self._name == other._name and
-                long(self._obj_id) == long(other._obj_id) and
+                self._obj_id == other._obj_id and
                 self._obj_type == other._obj_type)
 
     def __ne__(self, other):
diff --git a/vistrails/db/specs/all.xml b/vistrails/db/specs/all.xml
index 3a98de2a0..ff238cdc7 100644
--- a/vistrails/db/specs/all.xml
+++ b/vistrails/db/specs/all.xml
@@ -1764,6 +1764,11 @@
       <sql type="int"/>
     </property>
 
+    <property name="union" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
     <property name="sort_key" type="int">
       <xml name="sortKey" nodeType="xs:attribute" type="xs:int"/>
       <sql type="int"/>
diff --git a/vistrails/db/versions/__init__.py b/vistrails/db/versions/__init__.py
index 67fbf9c58..4a95ab0dc 100644
--- a/vistrails/db/versions/__init__.py
+++ b/vistrails/db/versions/__init__.py
@@ -42,7 +42,7 @@
 from vistrails.core.system import vistrails_root_directory
 from vistrails.db import VistrailsDBException
 
-currentVersion = '1.0.4'
+currentVersion = '1.0.5'
 
 def getVersionDAO(version=None):
     if version is None:
@@ -85,9 +85,11 @@ def translate_object(obj, method_name, version=None, target_version=None):
         '1.0.1': '1.0.2',
         '1.0.2': '1.0.3',
         '1.0.3': '1.0.4',
+        '1.0.4': '1.0.5',
         }
 
     rev_version_map = {
+        '1.0.5': '1.0.4',
         '1.0.4': '1.0.3',
         '1.0.3': '1.0.2',
         '1.0.2': '1.0.1',
diff --git a/vistrails/db/versions/v1_0_4/translate/v1_0_5.py b/vistrails/db/versions/v1_0_4/translate/v1_0_5.py
new file mode 100644
index 000000000..f49239a17
--- /dev/null
+++ b/vistrails/db/versions/v1_0_4/translate/v1_0_5.py
@@ -0,0 +1,106 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+from __future__ import division
+
+from vistrails.db.versions.v1_0_4.domain import DBVistrail, DBAnnotation, \
+                                      DBWorkflow, DBLog, DBRegistry, \
+                                      DBPortSpec, DBAdd, DBChange, DBDelete
+from vistrails.core import debug
+from vistrails.core.system import get_elementtree_library
+ElementTree = get_elementtree_library()
+
+id_scope = None
+
+def translateVistrail(_vistrail):
+    """ Translate new DBVistrailVariable based vistrail variables to old
+         annotation based type """
+    global id_scope
+    
+    def update_workflow(old_obj, trans_dict):
+        return DBWorkflow.update_version(old_obj.db_workflow, 
+                                         trans_dict, DBWorkflow())
+
+    def update_operations(old_obj, trans_dict):
+        new_ops = []
+        for obj in old_obj.db_operations:
+            if obj.vtType == 'delete':
+                new_ops.append(DBDelete.update_version(obj, trans_dict))
+            elif obj.vtType == 'add':
+                new_op = DBAdd.update_version(obj, trans_dict)
+                new_ops.append(new_op)
+            elif obj.vtType == 'change':
+                new_op = DBChange.update_version(obj, trans_dict)
+                new_ops.append(new_op)
+        return new_ops
+
+    vistrail = DBVistrail()
+    id_scope = vistrail.idScope
+
+    translate_dict = {'DBAction': {'operations': update_operations},
+                      'DBGroup': {'workflow': update_workflow}
+                      }
+
+    if _vistrail.db_controlParameters:
+        debug.warning(("Vistrail contains %s control parameters that "
+                      "cannot be converted") % len(_vistrail.db_controlParameters))
+    vistrail = DBVistrail.update_version(_vistrail, translate_dict, vistrail)
+
+    vistrail.db_version = '1.0.4'
+    return vistrail
+
+def translateWorkflow(_workflow):
+    def update_workflow(old_obj, translate_dict):
+        return DBWorkflow.update_version(old_obj.db_workflow, translate_dict)
+    translate_dict = {'DBGroup': {'workflow': update_workflow}}
+    workflow = DBWorkflow.update_version(_workflow, translate_dict)
+
+    workflow.db_version = '1.0.4'
+    return workflow
+
+def translateLog(_log):
+    translate_dict = {}
+    log = DBLog.update_version(_log, translate_dict)
+    log.db_version = '1.0.4'
+    return log
+
+def translateRegistry(_registry):
+    global id_scope
+    translate_dict = {}
+    registry = DBRegistry()
+    id_scope = registry.idScope
+    vistrail = DBRegistry.update_version(_registry, translate_dict, registry)
+    registry.db_version = '1.0.4'
+    return registry
diff --git a/vistrails/db/versions/v1_0_5/__init__.py b/vistrails/db/versions/v1_0_5/__init__.py
new file mode 100644
index 000000000..83f9e2281
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/__init__.py
@@ -0,0 +1,39 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+version = '1.0.5'
diff --git a/vistrails/db/versions/v1_0_5/domain/__init__.py b/vistrails/db/versions/v1_0_5/domain/__init__.py
new file mode 100644
index 000000000..8aba7f5f4
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/__init__.py
@@ -0,0 +1,44 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from auto_gen import *
+from registry import DBRegistry
+from workflow import DBWorkflow
+from vistrail import DBVistrail
+from log import DBLog
+from id_scope import IdScope
diff --git a/vistrails/db/versions/v1_0_5/domain/auto_gen.py b/vistrails/db/versions/v1_0_5/domain/auto_gen.py
new file mode 100644
index 000000000..27f447adf
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/auto_gen.py
@@ -0,0 +1,18705 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+"""generated automatically by auto_dao.py"""
+
+import copy
+
+class DBOpmWasGeneratedBy(object):
+
+    vtType = 'opm_was_generated_by'
+
+    def __init__(self, effect=None, role=None, cause=None, accounts=None, opm_times=None):
+        self.db_deleted_effect = []
+        self._db_effect = effect
+        self.db_deleted_role = []
+        self._db_role = role
+        self.db_deleted_cause = []
+        self._db_cause = cause
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.db_deleted_opm_times = []
+        if opm_times is None:
+            self._db_opm_times = []
+        else:
+            self._db_opm_times = opm_times
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmWasGeneratedBy.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmWasGeneratedBy()
+        if self._db_effect is not None:
+            cp._db_effect = self._db_effect.do_copy(new_ids, id_scope, id_remap)
+        if self._db_role is not None:
+            cp._db_role = self._db_role.do_copy(new_ids, id_scope, id_remap)
+        if self._db_cause is not None:
+            cp._db_cause = self._db_cause.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_opm_times is None:
+            cp._db_opm_times = []
+        else:
+            cp._db_opm_times = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_times]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmWasGeneratedBy()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'effect' in class_dict:
+            res = class_dict['effect'](old_obj, trans_dict)
+            new_obj.db_effect = res
+        elif hasattr(old_obj, 'db_effect') and old_obj.db_effect is not None:
+            obj = old_obj.db_effect
+            new_obj.db_add_effect(DBOpmArtifactIdEffect.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_effect') and hasattr(new_obj, 'db_deleted_effect'):
+            for obj in old_obj.db_deleted_effect:
+                n_obj = DBOpmArtifactIdEffect.update_version(obj, trans_dict)
+                new_obj.db_deleted_effect.append(n_obj)
+        if 'role' in class_dict:
+            res = class_dict['role'](old_obj, trans_dict)
+            new_obj.db_role = res
+        elif hasattr(old_obj, 'db_role') and old_obj.db_role is not None:
+            obj = old_obj.db_role
+            new_obj.db_add_role(DBOpmRole.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_role') and hasattr(new_obj, 'db_deleted_role'):
+            for obj in old_obj.db_deleted_role:
+                n_obj = DBOpmRole.update_version(obj, trans_dict)
+                new_obj.db_deleted_role.append(n_obj)
+        if 'cause' in class_dict:
+            res = class_dict['cause'](old_obj, trans_dict)
+            new_obj.db_cause = res
+        elif hasattr(old_obj, 'db_cause') and old_obj.db_cause is not None:
+            obj = old_obj.db_cause
+            new_obj.db_add_cause(DBOpmProcessIdCause.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_cause') and hasattr(new_obj, 'db_deleted_cause'):
+            for obj in old_obj.db_deleted_cause:
+                n_obj = DBOpmProcessIdCause.update_version(obj, trans_dict)
+                new_obj.db_deleted_cause.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'opm_times' in class_dict:
+            res = class_dict['opm_times'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_time(obj)
+        elif hasattr(old_obj, 'db_opm_times') and old_obj.db_opm_times is not None:
+            for obj in old_obj.db_opm_times:
+                new_obj.db_add_opm_time(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_times') and hasattr(new_obj, 'db_deleted_opm_times'):
+            for obj in old_obj.db_deleted_opm_times:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_times.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_effect is not None:
+            children.extend(self._db_effect.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_effect = None
+        if self._db_role is not None:
+            children.extend(self._db_role.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_role = None
+        if self._db_cause is not None:
+            children.extend(self._db_cause.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_cause = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_opm_times:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_time(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_effect)
+        children.extend(self.db_deleted_role)
+        children.extend(self.db_deleted_cause)
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_opm_times)
+        if remove:
+            self.db_deleted_effect = []
+            self.db_deleted_role = []
+            self.db_deleted_cause = []
+            self.db_deleted_accounts = []
+            self.db_deleted_opm_times = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_effect is not None and self._db_effect.has_changes():
+            return True
+        if self._db_role is not None and self._db_role.has_changes():
+            return True
+        if self._db_cause is not None and self._db_cause.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_opm_times:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_effect(self):
+        return self._db_effect
+    def __set_db_effect(self, effect):
+        self._db_effect = effect
+        self.is_dirty = True
+    db_effect = property(__get_db_effect, __set_db_effect)
+    def db_add_effect(self, effect):
+        self._db_effect = effect
+    def db_change_effect(self, effect):
+        self._db_effect = effect
+    def db_delete_effect(self, effect):
+        if not self.is_new:
+            self.db_deleted_effect.append(self._db_effect)
+        self._db_effect = None
+    
+    def __get_db_role(self):
+        return self._db_role
+    def __set_db_role(self, role):
+        self._db_role = role
+        self.is_dirty = True
+    db_role = property(__get_db_role, __set_db_role)
+    def db_add_role(self, role):
+        self._db_role = role
+    def db_change_role(self, role):
+        self._db_role = role
+    def db_delete_role(self, role):
+        if not self.is_new:
+            self.db_deleted_role.append(self._db_role)
+        self._db_role = None
+    
+    def __get_db_cause(self):
+        return self._db_cause
+    def __set_db_cause(self, cause):
+        self._db_cause = cause
+        self.is_dirty = True
+    db_cause = property(__get_db_cause, __set_db_cause)
+    def db_add_cause(self, cause):
+        self._db_cause = cause
+    def db_change_cause(self, cause):
+        self._db_cause = cause
+    def db_delete_cause(self, cause):
+        if not self.is_new:
+            self.db_deleted_cause.append(self._db_cause)
+        self._db_cause = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def __get_db_opm_times(self):
+        return self._db_opm_times
+    def __set_db_opm_times(self, opm_times):
+        self._db_opm_times = opm_times
+        self.is_dirty = True
+    db_opm_times = property(__get_db_opm_times, __set_db_opm_times)
+    def db_get_opm_times(self):
+        return self._db_opm_times
+    def db_add_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_change_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_delete_opm_time(self, opm_time):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_time(self, key):
+        return None
+    
+
+
+class DBConfigKey(object):
+
+    vtType = 'config_key'
+
+    def __init__(self, value=None, name=None):
+        self.db_deleted_value = []
+        self._db_value = value
+        self._db_name = name
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfigKey.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfigKey(name=self._db_name)
+        if self._db_value is not None:
+            cp._db_value = self._db_value.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfigKey()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            obj = old_obj.db_value
+            if obj.vtType == 'config_str':
+                new_obj.db_add_value(DBConfigStr.update_version(obj, trans_dict))
+            elif obj.vtType == 'config_int':
+                new_obj.db_add_value(DBConfigInt.update_version(obj, trans_dict))
+            elif obj.vtType == 'config_float':
+                new_obj.db_add_value(DBConfigFloat.update_version(obj, trans_dict))
+            elif obj.vtType == 'config_bool':
+                new_obj.db_add_value(DBConfigBool.update_version(obj, trans_dict))
+            elif obj.vtType == 'configuration':
+                new_obj.db_add_value(DBConfiguration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_value') and hasattr(new_obj, 'db_deleted_value'):
+            for obj in old_obj.db_deleted_value:
+                if obj.vtType == 'config_str':
+                    n_obj = DBConfigStr.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'config_int':
+                    n_obj = DBConfigInt.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'config_float':
+                    n_obj = DBConfigFloat.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'config_bool':
+                    n_obj = DBConfigBool.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'configuration':
+                    n_obj = DBConfiguration.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_value is not None:
+            children.extend(self._db_value.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_value = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_value)
+        if remove:
+            self.db_deleted_value = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_value is not None and self._db_value.has_changes():
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        if not self.is_new:
+            self.db_deleted_value.append(self._db_value)
+        self._db_value = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def getPrimaryKey(self):
+        return self._db_name
+
+class DBMashupAlias(object):
+
+    vtType = 'mashup_alias'
+
+    def __init__(self, id=None, name=None, component=None):
+        self._db_id = id
+        self._db_name = name
+        self.db_deleted_component = []
+        self._db_component = component
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashupAlias.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashupAlias(id=self._db_id,
+                           name=self._db_name)
+        if self._db_component is not None:
+            cp._db_component = self._db_component.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashupAlias()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'component' in class_dict:
+            res = class_dict['component'](old_obj, trans_dict)
+            new_obj.db_component = res
+        elif hasattr(old_obj, 'db_component') and old_obj.db_component is not None:
+            obj = old_obj.db_component
+            new_obj.db_add_component(DBMashupComponent.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_component') and hasattr(new_obj, 'db_deleted_component'):
+            for obj in old_obj.db_deleted_component:
+                n_obj = DBMashupComponent.update_version(obj, trans_dict)
+                new_obj.db_deleted_component.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_component is not None:
+            children.extend(self._db_component.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_component = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_component)
+        if remove:
+            self.db_deleted_component = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_component is not None and self._db_component.has_changes():
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_component(self):
+        return self._db_component
+    def __set_db_component(self, component):
+        self._db_component = component
+        self.is_dirty = True
+    db_component = property(__get_db_component, __set_db_component)
+    def db_add_component(self, component):
+        self._db_component = component
+    def db_change_component(self, component):
+        self._db_component = component
+    def db_delete_component(self, component):
+        if not self.is_new:
+            self.db_deleted_component.append(self._db_component)
+        self._db_component = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBGroup(object):
+
+    vtType = 'group'
+
+    def __init__(self, id=None, workflow=None, cache=None, name=None, namespace=None, package=None, version=None, location=None, functions=None, annotations=None, controlParameters=None):
+        self._db_id = id
+        self.db_deleted_workflow = []
+        self._db_workflow = workflow
+        self._db_cache = cache
+        self._db_name = name
+        self._db_namespace = namespace
+        self._db_package = package
+        self._db_version = version
+        self.db_deleted_location = []
+        self._db_location = location
+        self.db_deleted_functions = []
+        self.db_functions_id_index = {}
+        if functions is None:
+            self._db_functions = []
+        else:
+            self._db_functions = functions
+            for v in self._db_functions:
+                self.db_functions_id_index[v.db_id] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.db_deleted_controlParameters = []
+        self.db_controlParameters_id_index = {}
+        self.db_controlParameters_name_index = {}
+        if controlParameters is None:
+            self._db_controlParameters = []
+        else:
+            self._db_controlParameters = controlParameters
+            for v in self._db_controlParameters:
+                self.db_controlParameters_id_index[v.db_id] = v
+                self.db_controlParameters_name_index[v.db_name] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBGroup.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBGroup(id=self._db_id,
+                     cache=self._db_cache,
+                     name=self._db_name,
+                     namespace=self._db_namespace,
+                     package=self._db_package,
+                     version=self._db_version)
+        if self._db_workflow is not None:
+            cp._db_workflow = self._db_workflow.do_copy()
+        if self._db_location is not None:
+            cp._db_location = self._db_location.do_copy(new_ids, id_scope, id_remap)
+        if self._db_functions is None:
+            cp._db_functions = []
+        else:
+            cp._db_functions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_functions]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_controlParameters is None:
+            cp._db_controlParameters = []
+        else:
+            cp._db_controlParameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_controlParameters]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_functions_id_index = dict((v.db_id, v) for v in cp._db_functions)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        cp.db_controlParameters_id_index = dict((v.db_id, v) for v in cp._db_controlParameters)
+        cp.db_controlParameters_name_index = dict((v.db_name, v) for v in cp._db_controlParameters)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBGroup()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'workflow' in class_dict:
+            res = class_dict['workflow'](old_obj, trans_dict)
+            new_obj.db_workflow = res
+        elif hasattr(old_obj, 'db_workflow') and old_obj.db_workflow is not None:
+            obj = old_obj.db_workflow
+            new_obj.db_add_workflow(DBWorkflow.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_workflow') and hasattr(new_obj, 'db_deleted_workflow'):
+            for obj in old_obj.db_deleted_workflow:
+                n_obj = DBWorkflow.update_version(obj, trans_dict)
+                new_obj.db_deleted_workflow.append(n_obj)
+        if 'cache' in class_dict:
+            res = class_dict['cache'](old_obj, trans_dict)
+            new_obj.db_cache = res
+        elif hasattr(old_obj, 'db_cache') and old_obj.db_cache is not None:
+            new_obj.db_cache = old_obj.db_cache
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'location' in class_dict:
+            res = class_dict['location'](old_obj, trans_dict)
+            new_obj.db_location = res
+        elif hasattr(old_obj, 'db_location') and old_obj.db_location is not None:
+            obj = old_obj.db_location
+            new_obj.db_add_location(DBLocation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_location') and hasattr(new_obj, 'db_deleted_location'):
+            for obj in old_obj.db_deleted_location:
+                n_obj = DBLocation.update_version(obj, trans_dict)
+                new_obj.db_deleted_location.append(n_obj)
+        if 'functions' in class_dict:
+            res = class_dict['functions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_function(obj)
+        elif hasattr(old_obj, 'db_functions') and old_obj.db_functions is not None:
+            for obj in old_obj.db_functions:
+                new_obj.db_add_function(DBFunction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_functions') and hasattr(new_obj, 'db_deleted_functions'):
+            for obj in old_obj.db_deleted_functions:
+                n_obj = DBFunction.update_version(obj, trans_dict)
+                new_obj.db_deleted_functions.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'controlParameters' in class_dict:
+            res = class_dict['controlParameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_controlParameter(obj)
+        elif hasattr(old_obj, 'db_controlParameters') and old_obj.db_controlParameters is not None:
+            for obj in old_obj.db_controlParameters:
+                new_obj.db_add_controlParameter(DBControlParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_controlParameters') and hasattr(new_obj, 'db_deleted_controlParameters'):
+            for obj in old_obj.db_deleted_controlParameters:
+                n_obj = DBControlParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_controlParameters.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_location is not None:
+            children.extend(self._db_location.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_location = None
+        to_del = []
+        for child in self.db_functions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_function(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_controlParameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_controlParameter(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_workflow)
+        children.extend(self.db_deleted_location)
+        children.extend(self.db_deleted_functions)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_controlParameters)
+        if remove:
+            self.db_deleted_workflow = []
+            self.db_deleted_location = []
+            self.db_deleted_functions = []
+            self.db_deleted_annotations = []
+            self.db_deleted_controlParameters = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_workflow is not None and self._db_workflow.has_changes():
+            return True
+        if self._db_location is not None and self._db_location.has_changes():
+            return True
+        for child in self._db_functions:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_controlParameters:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_workflow(self):
+        return self._db_workflow
+    def __set_db_workflow(self, workflow):
+        self._db_workflow = workflow
+        self.is_dirty = True
+    db_workflow = property(__get_db_workflow, __set_db_workflow)
+    def db_add_workflow(self, workflow):
+        self._db_workflow = workflow
+    def db_change_workflow(self, workflow):
+        self._db_workflow = workflow
+    def db_delete_workflow(self, workflow):
+        if not self.is_new:
+            self.db_deleted_workflow.append(self._db_workflow)
+        self._db_workflow = None
+    
+    def __get_db_cache(self):
+        return self._db_cache
+    def __set_db_cache(self, cache):
+        self._db_cache = cache
+        self.is_dirty = True
+    db_cache = property(__get_db_cache, __set_db_cache)
+    def db_add_cache(self, cache):
+        self._db_cache = cache
+    def db_change_cache(self, cache):
+        self._db_cache = cache
+    def db_delete_cache(self, cache):
+        self._db_cache = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_location(self):
+        return self._db_location
+    def __set_db_location(self, location):
+        self._db_location = location
+        self.is_dirty = True
+    db_location = property(__get_db_location, __set_db_location)
+    def db_add_location(self, location):
+        self._db_location = location
+    def db_change_location(self, location):
+        self._db_location = location
+    def db_delete_location(self, location):
+        if not self.is_new:
+            self.db_deleted_location.append(self._db_location)
+        self._db_location = None
+    
+    def __get_db_functions(self):
+        return self._db_functions
+    def __set_db_functions(self, functions):
+        self._db_functions = functions
+        self.is_dirty = True
+    db_functions = property(__get_db_functions, __set_db_functions)
+    def db_get_functions(self):
+        return self._db_functions
+    def db_add_function(self, function):
+        self.is_dirty = True
+        self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_change_function(self, function):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                self._db_functions[i] = function
+                found = True
+                break
+        if not found:
+            self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_delete_function(self, function):
+        self.is_dirty = True
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                if not self._db_functions[i].is_new:
+                    self.db_deleted_functions.append(self._db_functions[i])
+                del self._db_functions[i]
+                break
+        del self.db_functions_id_index[function.db_id]
+    def db_get_function(self, key):
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == key:
+                return self._db_functions[i]
+        return None
+    def db_get_function_by_id(self, key):
+        return self.db_functions_id_index[key]
+    def db_has_function_with_id(self, key):
+        return key in self.db_functions_id_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def __get_db_controlParameters(self):
+        return self._db_controlParameters
+    def __set_db_controlParameters(self, controlParameters):
+        self._db_controlParameters = controlParameters
+        self.is_dirty = True
+    db_controlParameters = property(__get_db_controlParameters, __set_db_controlParameters)
+    def db_get_controlParameters(self):
+        return self._db_controlParameters
+    def db_add_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_change_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                self._db_controlParameters[i] = controlParameter
+                found = True
+                break
+        if not found:
+            self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_delete_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                if not self._db_controlParameters[i].is_new:
+                    self.db_deleted_controlParameters.append(self._db_controlParameters[i])
+                del self._db_controlParameters[i]
+                break
+        del self.db_controlParameters_id_index[controlParameter.db_id]
+        del self.db_controlParameters_name_index[controlParameter.db_name]
+    def db_get_controlParameter(self, key):
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == key:
+                return self._db_controlParameters[i]
+        return None
+    def db_get_controlParameter_by_id(self, key):
+        return self.db_controlParameters_id_index[key]
+    def db_has_controlParameter_with_id(self, key):
+        return key in self.db_controlParameters_id_index
+    def db_get_controlParameter_by_name(self, key):
+        return self.db_controlParameters_name_index[key]
+    def db_has_controlParameter_with_name(self, key):
+        return key in self.db_controlParameters_name_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmWasControlledBy(object):
+
+    vtType = 'opm_was_controlled_by'
+
+    def __init__(self, effect=None, role=None, cause=None, accounts=None, starts=None, ends=None):
+        self.db_deleted_effect = []
+        self._db_effect = effect
+        self.db_deleted_role = []
+        self._db_role = role
+        self.db_deleted_cause = []
+        self._db_cause = cause
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.db_deleted_starts = []
+        if starts is None:
+            self._db_starts = []
+        else:
+            self._db_starts = starts
+        self.db_deleted_ends = []
+        if ends is None:
+            self._db_ends = []
+        else:
+            self._db_ends = ends
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmWasControlledBy.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmWasControlledBy()
+        if self._db_effect is not None:
+            cp._db_effect = self._db_effect.do_copy(new_ids, id_scope, id_remap)
+        if self._db_role is not None:
+            cp._db_role = self._db_role.do_copy(new_ids, id_scope, id_remap)
+        if self._db_cause is not None:
+            cp._db_cause = self._db_cause.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_starts is None:
+            cp._db_starts = []
+        else:
+            cp._db_starts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_starts]
+        if self._db_ends is None:
+            cp._db_ends = []
+        else:
+            cp._db_ends = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_ends]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmWasControlledBy()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'effect' in class_dict:
+            res = class_dict['effect'](old_obj, trans_dict)
+            new_obj.db_effect = res
+        elif hasattr(old_obj, 'db_effect') and old_obj.db_effect is not None:
+            obj = old_obj.db_effect
+            new_obj.db_add_effect(DBOpmProcessIdEffect.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_effect') and hasattr(new_obj, 'db_deleted_effect'):
+            for obj in old_obj.db_deleted_effect:
+                n_obj = DBOpmProcessIdEffect.update_version(obj, trans_dict)
+                new_obj.db_deleted_effect.append(n_obj)
+        if 'role' in class_dict:
+            res = class_dict['role'](old_obj, trans_dict)
+            new_obj.db_role = res
+        elif hasattr(old_obj, 'db_role') and old_obj.db_role is not None:
+            obj = old_obj.db_role
+            new_obj.db_add_role(DBOpmRole.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_role') and hasattr(new_obj, 'db_deleted_role'):
+            for obj in old_obj.db_deleted_role:
+                n_obj = DBOpmRole.update_version(obj, trans_dict)
+                new_obj.db_deleted_role.append(n_obj)
+        if 'cause' in class_dict:
+            res = class_dict['cause'](old_obj, trans_dict)
+            new_obj.db_cause = res
+        elif hasattr(old_obj, 'db_cause') and old_obj.db_cause is not None:
+            obj = old_obj.db_cause
+            new_obj.db_add_cause(DBOpmAgentId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_cause') and hasattr(new_obj, 'db_deleted_cause'):
+            for obj in old_obj.db_deleted_cause:
+                n_obj = DBOpmAgentId.update_version(obj, trans_dict)
+                new_obj.db_deleted_cause.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'starts' in class_dict:
+            res = class_dict['starts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_start(obj)
+        elif hasattr(old_obj, 'db_starts') and old_obj.db_starts is not None:
+            for obj in old_obj.db_starts:
+                new_obj.db_add_start(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_starts') and hasattr(new_obj, 'db_deleted_starts'):
+            for obj in old_obj.db_deleted_starts:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_starts.append(n_obj)
+        if 'ends' in class_dict:
+            res = class_dict['ends'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_end(obj)
+        elif hasattr(old_obj, 'db_ends') and old_obj.db_ends is not None:
+            for obj in old_obj.db_ends:
+                new_obj.db_add_end(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_ends') and hasattr(new_obj, 'db_deleted_ends'):
+            for obj in old_obj.db_deleted_ends:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_ends.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_effect is not None:
+            children.extend(self._db_effect.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_effect = None
+        if self._db_role is not None:
+            children.extend(self._db_role.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_role = None
+        if self._db_cause is not None:
+            children.extend(self._db_cause.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_cause = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_starts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_start(child)
+        to_del = []
+        for child in self.db_ends:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_end(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_effect)
+        children.extend(self.db_deleted_role)
+        children.extend(self.db_deleted_cause)
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_starts)
+        children.extend(self.db_deleted_ends)
+        if remove:
+            self.db_deleted_effect = []
+            self.db_deleted_role = []
+            self.db_deleted_cause = []
+            self.db_deleted_accounts = []
+            self.db_deleted_starts = []
+            self.db_deleted_ends = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_effect is not None and self._db_effect.has_changes():
+            return True
+        if self._db_role is not None and self._db_role.has_changes():
+            return True
+        if self._db_cause is not None and self._db_cause.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_starts:
+            if child.has_changes():
+                return True
+        for child in self._db_ends:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_effect(self):
+        return self._db_effect
+    def __set_db_effect(self, effect):
+        self._db_effect = effect
+        self.is_dirty = True
+    db_effect = property(__get_db_effect, __set_db_effect)
+    def db_add_effect(self, effect):
+        self._db_effect = effect
+    def db_change_effect(self, effect):
+        self._db_effect = effect
+    def db_delete_effect(self, effect):
+        if not self.is_new:
+            self.db_deleted_effect.append(self._db_effect)
+        self._db_effect = None
+    
+    def __get_db_role(self):
+        return self._db_role
+    def __set_db_role(self, role):
+        self._db_role = role
+        self.is_dirty = True
+    db_role = property(__get_db_role, __set_db_role)
+    def db_add_role(self, role):
+        self._db_role = role
+    def db_change_role(self, role):
+        self._db_role = role
+    def db_delete_role(self, role):
+        if not self.is_new:
+            self.db_deleted_role.append(self._db_role)
+        self._db_role = None
+    
+    def __get_db_cause(self):
+        return self._db_cause
+    def __set_db_cause(self, cause):
+        self._db_cause = cause
+        self.is_dirty = True
+    db_cause = property(__get_db_cause, __set_db_cause)
+    def db_add_cause(self, cause):
+        self._db_cause = cause
+    def db_change_cause(self, cause):
+        self._db_cause = cause
+    def db_delete_cause(self, cause):
+        if not self.is_new:
+            self.db_deleted_cause.append(self._db_cause)
+        self._db_cause = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def __get_db_starts(self):
+        return self._db_starts
+    def __set_db_starts(self, starts):
+        self._db_starts = starts
+        self.is_dirty = True
+    db_starts = property(__get_db_starts, __set_db_starts)
+    def db_get_starts(self):
+        return self._db_starts
+    def db_add_start(self, start):
+        self.is_dirty = True
+        self._db_starts.append(start)
+    def db_change_start(self, start):
+        self.is_dirty = True
+        self._db_starts.append(start)
+    def db_delete_start(self, start):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_start(self, key):
+        return None
+    
+    def __get_db_ends(self):
+        return self._db_ends
+    def __set_db_ends(self, ends):
+        self._db_ends = ends
+        self.is_dirty = True
+    db_ends = property(__get_db_ends, __set_db_ends)
+    def db_get_ends(self):
+        return self._db_ends
+    def db_add_end(self, end):
+        self.is_dirty = True
+        self._db_ends.append(end)
+    def db_change_end(self, end):
+        self.is_dirty = True
+        self._db_ends.append(end)
+    def db_delete_end(self, end):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_end(self, key):
+        return None
+    
+
+
+class DBAdd(object):
+
+    vtType = 'add'
+
+    def __init__(self, data=None, id=None, what=None, objectId=None, parentObjId=None, parentObjType=None):
+        self.db_deleted_data = []
+        self._db_data = data
+        self._db_id = id
+        self._db_what = what
+        self._db_objectId = objectId
+        self._db_parentObjId = parentObjId
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBAdd.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBAdd(id=self._db_id,
+                   what=self._db_what,
+                   objectId=self._db_objectId,
+                   parentObjId=self._db_parentObjId,
+                   parentObjType=self._db_parentObjType)
+        if self._db_data is not None:
+            cp._db_data = self._db_data.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_objectId') and (self._db_what, self._db_objectId) in id_remap:
+                cp._db_objectId = id_remap[(self._db_what, self._db_objectId)]
+            if hasattr(self, 'db_parentObjId') and (self._db_parentObjType, self._db_parentObjId) in id_remap:
+                cp._db_parentObjId = id_remap[(self._db_parentObjType, self._db_parentObjId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBAdd()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'data' in class_dict:
+            res = class_dict['data'](old_obj, trans_dict)
+            new_obj.db_data = res
+        elif hasattr(old_obj, 'db_data') and old_obj.db_data is not None:
+            obj = old_obj.db_data
+            if obj.vtType == 'module':
+                new_obj.db_add_data(DBModule.update_version(obj, trans_dict))
+            elif obj.vtType == 'location':
+                new_obj.db_add_data(DBLocation.update_version(obj, trans_dict))
+            elif obj.vtType == 'annotation':
+                new_obj.db_add_data(DBAnnotation.update_version(obj, trans_dict))
+            elif obj.vtType == 'controlParameter':
+                new_obj.db_add_data(DBControlParameter.update_version(obj, trans_dict))
+            elif obj.vtType == 'function':
+                new_obj.db_add_data(DBFunction.update_version(obj, trans_dict))
+            elif obj.vtType == 'connection':
+                new_obj.db_add_data(DBConnection.update_version(obj, trans_dict))
+            elif obj.vtType == 'port':
+                new_obj.db_add_data(DBPort.update_version(obj, trans_dict))
+            elif obj.vtType == 'parameter':
+                new_obj.db_add_data(DBParameter.update_version(obj, trans_dict))
+            elif obj.vtType == 'portSpec':
+                new_obj.db_add_data(DBPortSpec.update_version(obj, trans_dict))
+            elif obj.vtType == 'abstraction':
+                new_obj.db_add_data(DBAbstraction.update_version(obj, trans_dict))
+            elif obj.vtType == 'group':
+                new_obj.db_add_data(DBGroup.update_version(obj, trans_dict))
+            elif obj.vtType == 'other':
+                new_obj.db_add_data(DBOther.update_version(obj, trans_dict))
+            elif obj.vtType == 'plugin_data':
+                new_obj.db_add_data(DBPluginData.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_data') and hasattr(new_obj, 'db_deleted_data'):
+            for obj in old_obj.db_deleted_data:
+                if obj.vtType == 'module':
+                    n_obj = DBModule.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'location':
+                    n_obj = DBLocation.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'annotation':
+                    n_obj = DBAnnotation.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'controlParameter':
+                    n_obj = DBControlParameter.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'function':
+                    n_obj = DBFunction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'connection':
+                    n_obj = DBConnection.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'port':
+                    n_obj = DBPort.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'parameter':
+                    n_obj = DBParameter.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'portSpec':
+                    n_obj = DBPortSpec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'abstraction':
+                    n_obj = DBAbstraction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'group':
+                    n_obj = DBGroup.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'other':
+                    n_obj = DBOther.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'plugin_data':
+                    n_obj = DBPluginData.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'what' in class_dict:
+            res = class_dict['what'](old_obj, trans_dict)
+            new_obj.db_what = res
+        elif hasattr(old_obj, 'db_what') and old_obj.db_what is not None:
+            new_obj.db_what = old_obj.db_what
+        if 'objectId' in class_dict:
+            res = class_dict['objectId'](old_obj, trans_dict)
+            new_obj.db_objectId = res
+        elif hasattr(old_obj, 'db_objectId') and old_obj.db_objectId is not None:
+            new_obj.db_objectId = old_obj.db_objectId
+        if 'parentObjId' in class_dict:
+            res = class_dict['parentObjId'](old_obj, trans_dict)
+            new_obj.db_parentObjId = res
+        elif hasattr(old_obj, 'db_parentObjId') and old_obj.db_parentObjId is not None:
+            new_obj.db_parentObjId = old_obj.db_parentObjId
+        if 'parentObjType' in class_dict:
+            res = class_dict['parentObjType'](old_obj, trans_dict)
+            new_obj.db_parentObjType = res
+        elif hasattr(old_obj, 'db_parentObjType') and old_obj.db_parentObjType is not None:
+            new_obj.db_parentObjType = old_obj.db_parentObjType
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_data is not None:
+            children.extend(self._db_data.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_data = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_data)
+        if remove:
+            self.db_deleted_data = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_data is not None and self._db_data.has_changes():
+            return True
+        return False
+    def __get_db_data(self):
+        return self._db_data
+    def __set_db_data(self, data):
+        self._db_data = data
+        self.is_dirty = True
+    db_data = property(__get_db_data, __set_db_data)
+    def db_add_data(self, data):
+        self._db_data = data
+    def db_change_data(self, data):
+        self._db_data = data
+    def db_delete_data(self, data):
+        if not self.is_new:
+            self.db_deleted_data.append(self._db_data)
+        self._db_data = None
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_what(self):
+        return self._db_what
+    def __set_db_what(self, what):
+        self._db_what = what
+        self.is_dirty = True
+    db_what = property(__get_db_what, __set_db_what)
+    def db_add_what(self, what):
+        self._db_what = what
+    def db_change_what(self, what):
+        self._db_what = what
+    def db_delete_what(self, what):
+        self._db_what = None
+    
+    def __get_db_objectId(self):
+        return self._db_objectId
+    def __set_db_objectId(self, objectId):
+        self._db_objectId = objectId
+        self.is_dirty = True
+    db_objectId = property(__get_db_objectId, __set_db_objectId)
+    def db_add_objectId(self, objectId):
+        self._db_objectId = objectId
+    def db_change_objectId(self, objectId):
+        self._db_objectId = objectId
+    def db_delete_objectId(self, objectId):
+        self._db_objectId = None
+    
+    def __get_db_parentObjId(self):
+        return self._db_parentObjId
+    def __set_db_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+        self.is_dirty = True
+    db_parentObjId = property(__get_db_parentObjId, __set_db_parentObjId)
+    def db_add_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_change_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_delete_parentObjId(self, parentObjId):
+        self._db_parentObjId = None
+    
+    def __get_db_parentObjType(self):
+        return self._db_parentObjType
+    def __set_db_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+    db_parentObjType = property(__get_db_parentObjType, __set_db_parentObjType)
+    def db_add_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_change_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_delete_parentObjType(self, parentObjType):
+        self._db_parentObjType = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvGeneration(object):
+
+    vtType = 'prov_generation'
+
+    def __init__(self, prov_entity=None, prov_activity=None, prov_role=None):
+        self.db_deleted_prov_entity = []
+        self._db_prov_entity = prov_entity
+        self.db_deleted_prov_activity = []
+        self._db_prov_activity = prov_activity
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvGeneration.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvGeneration(prov_role=self._db_prov_role)
+        if self._db_prov_entity is not None:
+            cp._db_prov_entity = self._db_prov_entity.do_copy(new_ids, id_scope, id_remap)
+        if self._db_prov_activity is not None:
+            cp._db_prov_activity = self._db_prov_activity.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvGeneration()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_entity' in class_dict:
+            res = class_dict['prov_entity'](old_obj, trans_dict)
+            new_obj.db_prov_entity = res
+        elif hasattr(old_obj, 'db_prov_entity') and old_obj.db_prov_entity is not None:
+            obj = old_obj.db_prov_entity
+            new_obj.db_add_prov_entity(DBRefProvEntity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_entity') and hasattr(new_obj, 'db_deleted_prov_entity'):
+            for obj in old_obj.db_deleted_prov_entity:
+                n_obj = DBRefProvEntity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_entity.append(n_obj)
+        if 'prov_activity' in class_dict:
+            res = class_dict['prov_activity'](old_obj, trans_dict)
+            new_obj.db_prov_activity = res
+        elif hasattr(old_obj, 'db_prov_activity') and old_obj.db_prov_activity is not None:
+            obj = old_obj.db_prov_activity
+            new_obj.db_add_prov_activity(DBRefProvActivity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_activity') and hasattr(new_obj, 'db_deleted_prov_activity'):
+            for obj in old_obj.db_deleted_prov_activity:
+                n_obj = DBRefProvActivity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_activity.append(n_obj)
+        if 'prov_role' in class_dict:
+            res = class_dict['prov_role'](old_obj, trans_dict)
+            new_obj.db_prov_role = res
+        elif hasattr(old_obj, 'db_prov_role') and old_obj.db_prov_role is not None:
+            new_obj.db_prov_role = old_obj.db_prov_role
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_prov_entity is not None:
+            children.extend(self._db_prov_entity.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_entity = None
+        if self._db_prov_activity is not None:
+            children.extend(self._db_prov_activity.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_activity = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_prov_entity)
+        children.extend(self.db_deleted_prov_activity)
+        if remove:
+            self.db_deleted_prov_entity = []
+            self.db_deleted_prov_activity = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_prov_entity is not None and self._db_prov_entity.has_changes():
+            return True
+        if self._db_prov_activity is not None and self._db_prov_activity.has_changes():
+            return True
+        return False
+    def __get_db_prov_entity(self):
+        return self._db_prov_entity
+    def __set_db_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+        self.is_dirty = True
+    db_prov_entity = property(__get_db_prov_entity, __set_db_prov_entity)
+    def db_add_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+    def db_change_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+    def db_delete_prov_entity(self, prov_entity):
+        if not self.is_new:
+            self.db_deleted_prov_entity.append(self._db_prov_entity)
+        self._db_prov_entity = None
+    
+    def __get_db_prov_activity(self):
+        return self._db_prov_activity
+    def __set_db_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+        self.is_dirty = True
+    db_prov_activity = property(__get_db_prov_activity, __set_db_prov_activity)
+    def db_add_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_change_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_delete_prov_activity(self, prov_activity):
+        if not self.is_new:
+            self.db_deleted_prov_activity.append(self._db_prov_activity)
+        self._db_prov_activity = None
+    
+    def __get_db_prov_role(self):
+        return self._db_prov_role
+    def __set_db_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+    db_prov_role = property(__get_db_prov_role, __set_db_prov_role)
+    def db_add_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_change_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_delete_prov_role(self, prov_role):
+        self._db_prov_role = None
+    
+
+
+class DBOpmUsed(object):
+
+    vtType = 'opm_used'
+
+    def __init__(self, effect=None, role=None, cause=None, accounts=None, opm_times=None):
+        self.db_deleted_effect = []
+        self._db_effect = effect
+        self.db_deleted_role = []
+        self._db_role = role
+        self.db_deleted_cause = []
+        self._db_cause = cause
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.db_deleted_opm_times = []
+        if opm_times is None:
+            self._db_opm_times = []
+        else:
+            self._db_opm_times = opm_times
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmUsed.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmUsed()
+        if self._db_effect is not None:
+            cp._db_effect = self._db_effect.do_copy(new_ids, id_scope, id_remap)
+        if self._db_role is not None:
+            cp._db_role = self._db_role.do_copy(new_ids, id_scope, id_remap)
+        if self._db_cause is not None:
+            cp._db_cause = self._db_cause.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_opm_times is None:
+            cp._db_opm_times = []
+        else:
+            cp._db_opm_times = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_times]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmUsed()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'effect' in class_dict:
+            res = class_dict['effect'](old_obj, trans_dict)
+            new_obj.db_effect = res
+        elif hasattr(old_obj, 'db_effect') and old_obj.db_effect is not None:
+            obj = old_obj.db_effect
+            new_obj.db_add_effect(DBOpmProcessIdEffect.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_effect') and hasattr(new_obj, 'db_deleted_effect'):
+            for obj in old_obj.db_deleted_effect:
+                n_obj = DBOpmProcessIdEffect.update_version(obj, trans_dict)
+                new_obj.db_deleted_effect.append(n_obj)
+        if 'role' in class_dict:
+            res = class_dict['role'](old_obj, trans_dict)
+            new_obj.db_role = res
+        elif hasattr(old_obj, 'db_role') and old_obj.db_role is not None:
+            obj = old_obj.db_role
+            new_obj.db_add_role(DBOpmRole.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_role') and hasattr(new_obj, 'db_deleted_role'):
+            for obj in old_obj.db_deleted_role:
+                n_obj = DBOpmRole.update_version(obj, trans_dict)
+                new_obj.db_deleted_role.append(n_obj)
+        if 'cause' in class_dict:
+            res = class_dict['cause'](old_obj, trans_dict)
+            new_obj.db_cause = res
+        elif hasattr(old_obj, 'db_cause') and old_obj.db_cause is not None:
+            obj = old_obj.db_cause
+            new_obj.db_add_cause(DBOpmArtifactIdCause.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_cause') and hasattr(new_obj, 'db_deleted_cause'):
+            for obj in old_obj.db_deleted_cause:
+                n_obj = DBOpmArtifactIdCause.update_version(obj, trans_dict)
+                new_obj.db_deleted_cause.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'opm_times' in class_dict:
+            res = class_dict['opm_times'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_time(obj)
+        elif hasattr(old_obj, 'db_opm_times') and old_obj.db_opm_times is not None:
+            for obj in old_obj.db_opm_times:
+                new_obj.db_add_opm_time(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_times') and hasattr(new_obj, 'db_deleted_opm_times'):
+            for obj in old_obj.db_deleted_opm_times:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_times.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_effect is not None:
+            children.extend(self._db_effect.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_effect = None
+        if self._db_role is not None:
+            children.extend(self._db_role.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_role = None
+        if self._db_cause is not None:
+            children.extend(self._db_cause.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_cause = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_opm_times:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_time(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_effect)
+        children.extend(self.db_deleted_role)
+        children.extend(self.db_deleted_cause)
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_opm_times)
+        if remove:
+            self.db_deleted_effect = []
+            self.db_deleted_role = []
+            self.db_deleted_cause = []
+            self.db_deleted_accounts = []
+            self.db_deleted_opm_times = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_effect is not None and self._db_effect.has_changes():
+            return True
+        if self._db_role is not None and self._db_role.has_changes():
+            return True
+        if self._db_cause is not None and self._db_cause.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_opm_times:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_effect(self):
+        return self._db_effect
+    def __set_db_effect(self, effect):
+        self._db_effect = effect
+        self.is_dirty = True
+    db_effect = property(__get_db_effect, __set_db_effect)
+    def db_add_effect(self, effect):
+        self._db_effect = effect
+    def db_change_effect(self, effect):
+        self._db_effect = effect
+    def db_delete_effect(self, effect):
+        if not self.is_new:
+            self.db_deleted_effect.append(self._db_effect)
+        self._db_effect = None
+    
+    def __get_db_role(self):
+        return self._db_role
+    def __set_db_role(self, role):
+        self._db_role = role
+        self.is_dirty = True
+    db_role = property(__get_db_role, __set_db_role)
+    def db_add_role(self, role):
+        self._db_role = role
+    def db_change_role(self, role):
+        self._db_role = role
+    def db_delete_role(self, role):
+        if not self.is_new:
+            self.db_deleted_role.append(self._db_role)
+        self._db_role = None
+    
+    def __get_db_cause(self):
+        return self._db_cause
+    def __set_db_cause(self, cause):
+        self._db_cause = cause
+        self.is_dirty = True
+    db_cause = property(__get_db_cause, __set_db_cause)
+    def db_add_cause(self, cause):
+        self._db_cause = cause
+    def db_change_cause(self, cause):
+        self._db_cause = cause
+    def db_delete_cause(self, cause):
+        if not self.is_new:
+            self.db_deleted_cause.append(self._db_cause)
+        self._db_cause = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def __get_db_opm_times(self):
+        return self._db_opm_times
+    def __set_db_opm_times(self, opm_times):
+        self._db_opm_times = opm_times
+        self.is_dirty = True
+    db_opm_times = property(__get_db_opm_times, __set_db_opm_times)
+    def db_get_opm_times(self):
+        return self._db_opm_times
+    def db_add_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_change_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_delete_opm_time(self, opm_time):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_time(self, key):
+        return None
+    
+
+
+class DBOpmArtifactIdCause(object):
+
+    vtType = 'opm_artifact_id_cause'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmArtifactIdCause.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmArtifactIdCause(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_artifact', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_artifact', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmArtifactIdCause()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBRefProvEntity(object):
+
+    vtType = 'ref_prov_entity'
+
+    def __init__(self, prov_ref=None):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBRefProvEntity.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBRefProvEntity(prov_ref=self._db_prov_ref)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prov_ref') and ('prov_entity', self._db_prov_ref) in id_remap:
+                cp._db_prov_ref = id_remap[('prov_entity', self._db_prov_ref)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRefProvEntity()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_ref' in class_dict:
+            res = class_dict['prov_ref'](old_obj, trans_dict)
+            new_obj.db_prov_ref = res
+        elif hasattr(old_obj, 'db_prov_ref') and old_obj.db_prov_ref is not None:
+            new_obj.db_prov_ref = old_obj.db_prov_ref
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_prov_ref(self):
+        return self._db_prov_ref
+    def __set_db_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+    db_prov_ref = property(__get_db_prov_ref, __set_db_prov_ref)
+    def db_add_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_change_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_delete_prov_ref(self, prov_ref):
+        self._db_prov_ref = None
+    
+
+
+class DBVtConnection(object):
+
+    vtType = 'vt_connection'
+
+    def __init__(self, id=None, vt_source=None, vt_dest=None, vt_source_port=None, vt_dest_port=None, vt_source_signature=None, vt_dest_signature=None):
+        self._db_id = id
+        self._db_vt_source = vt_source
+        self._db_vt_dest = vt_dest
+        self._db_vt_source_port = vt_source_port
+        self._db_vt_dest_port = vt_dest_port
+        self._db_vt_source_signature = vt_source_signature
+        self._db_vt_dest_signature = vt_dest_signature
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBVtConnection.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBVtConnection(id=self._db_id,
+                            vt_source=self._db_vt_source,
+                            vt_dest=self._db_vt_dest,
+                            vt_source_port=self._db_vt_source_port,
+                            vt_dest_port=self._db_vt_dest_port,
+                            vt_source_signature=self._db_vt_source_signature,
+                            vt_dest_signature=self._db_vt_dest_signature)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBVtConnection()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'vt_source' in class_dict:
+            res = class_dict['vt_source'](old_obj, trans_dict)
+            new_obj.db_vt_source = res
+        elif hasattr(old_obj, 'db_vt_source') and old_obj.db_vt_source is not None:
+            new_obj.db_vt_source = old_obj.db_vt_source
+        if 'vt_dest' in class_dict:
+            res = class_dict['vt_dest'](old_obj, trans_dict)
+            new_obj.db_vt_dest = res
+        elif hasattr(old_obj, 'db_vt_dest') and old_obj.db_vt_dest is not None:
+            new_obj.db_vt_dest = old_obj.db_vt_dest
+        if 'vt_source_port' in class_dict:
+            res = class_dict['vt_source_port'](old_obj, trans_dict)
+            new_obj.db_vt_source_port = res
+        elif hasattr(old_obj, 'db_vt_source_port') and old_obj.db_vt_source_port is not None:
+            new_obj.db_vt_source_port = old_obj.db_vt_source_port
+        if 'vt_dest_port' in class_dict:
+            res = class_dict['vt_dest_port'](old_obj, trans_dict)
+            new_obj.db_vt_dest_port = res
+        elif hasattr(old_obj, 'db_vt_dest_port') and old_obj.db_vt_dest_port is not None:
+            new_obj.db_vt_dest_port = old_obj.db_vt_dest_port
+        if 'vt_source_signature' in class_dict:
+            res = class_dict['vt_source_signature'](old_obj, trans_dict)
+            new_obj.db_vt_source_signature = res
+        elif hasattr(old_obj, 'db_vt_source_signature') and old_obj.db_vt_source_signature is not None:
+            new_obj.db_vt_source_signature = old_obj.db_vt_source_signature
+        if 'vt_dest_signature' in class_dict:
+            res = class_dict['vt_dest_signature'](old_obj, trans_dict)
+            new_obj.db_vt_dest_signature = res
+        elif hasattr(old_obj, 'db_vt_dest_signature') and old_obj.db_vt_dest_signature is not None:
+            new_obj.db_vt_dest_signature = old_obj.db_vt_dest_signature
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_vt_source(self):
+        return self._db_vt_source
+    def __set_db_vt_source(self, vt_source):
+        self._db_vt_source = vt_source
+        self.is_dirty = True
+    db_vt_source = property(__get_db_vt_source, __set_db_vt_source)
+    def db_add_vt_source(self, vt_source):
+        self._db_vt_source = vt_source
+    def db_change_vt_source(self, vt_source):
+        self._db_vt_source = vt_source
+    def db_delete_vt_source(self, vt_source):
+        self._db_vt_source = None
+    
+    def __get_db_vt_dest(self):
+        return self._db_vt_dest
+    def __set_db_vt_dest(self, vt_dest):
+        self._db_vt_dest = vt_dest
+        self.is_dirty = True
+    db_vt_dest = property(__get_db_vt_dest, __set_db_vt_dest)
+    def db_add_vt_dest(self, vt_dest):
+        self._db_vt_dest = vt_dest
+    def db_change_vt_dest(self, vt_dest):
+        self._db_vt_dest = vt_dest
+    def db_delete_vt_dest(self, vt_dest):
+        self._db_vt_dest = None
+    
+    def __get_db_vt_source_port(self):
+        return self._db_vt_source_port
+    def __set_db_vt_source_port(self, vt_source_port):
+        self._db_vt_source_port = vt_source_port
+        self.is_dirty = True
+    db_vt_source_port = property(__get_db_vt_source_port, __set_db_vt_source_port)
+    def db_add_vt_source_port(self, vt_source_port):
+        self._db_vt_source_port = vt_source_port
+    def db_change_vt_source_port(self, vt_source_port):
+        self._db_vt_source_port = vt_source_port
+    def db_delete_vt_source_port(self, vt_source_port):
+        self._db_vt_source_port = None
+    
+    def __get_db_vt_dest_port(self):
+        return self._db_vt_dest_port
+    def __set_db_vt_dest_port(self, vt_dest_port):
+        self._db_vt_dest_port = vt_dest_port
+        self.is_dirty = True
+    db_vt_dest_port = property(__get_db_vt_dest_port, __set_db_vt_dest_port)
+    def db_add_vt_dest_port(self, vt_dest_port):
+        self._db_vt_dest_port = vt_dest_port
+    def db_change_vt_dest_port(self, vt_dest_port):
+        self._db_vt_dest_port = vt_dest_port
+    def db_delete_vt_dest_port(self, vt_dest_port):
+        self._db_vt_dest_port = None
+    
+    def __get_db_vt_source_signature(self):
+        return self._db_vt_source_signature
+    def __set_db_vt_source_signature(self, vt_source_signature):
+        self._db_vt_source_signature = vt_source_signature
+        self.is_dirty = True
+    db_vt_source_signature = property(__get_db_vt_source_signature, __set_db_vt_source_signature)
+    def db_add_vt_source_signature(self, vt_source_signature):
+        self._db_vt_source_signature = vt_source_signature
+    def db_change_vt_source_signature(self, vt_source_signature):
+        self._db_vt_source_signature = vt_source_signature
+    def db_delete_vt_source_signature(self, vt_source_signature):
+        self._db_vt_source_signature = None
+    
+    def __get_db_vt_dest_signature(self):
+        return self._db_vt_dest_signature
+    def __set_db_vt_dest_signature(self, vt_dest_signature):
+        self._db_vt_dest_signature = vt_dest_signature
+        self.is_dirty = True
+    db_vt_dest_signature = property(__get_db_vt_dest_signature, __set_db_vt_dest_signature)
+    def db_add_vt_dest_signature(self, vt_dest_signature):
+        self._db_vt_dest_signature = vt_dest_signature
+    def db_change_vt_dest_signature(self, vt_dest_signature):
+        self._db_vt_dest_signature = vt_dest_signature
+    def db_delete_vt_dest_signature(self, vt_dest_signature):
+        self._db_vt_dest_signature = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmAccount(object):
+
+    vtType = 'opm_account'
+
+    def __init__(self, id=None, value=None):
+        self._db_id = id
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAccount.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAccount(id=self._db_id,
+                          value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAccount()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBGroupExec(object):
+
+    vtType = 'group_exec'
+
+    def __init__(self, item_execs=None, id=None, ts_start=None, ts_end=None, cached=None, module_id=None, group_name=None, group_type=None, completed=None, error=None, machine_id=None, annotations=None):
+        self.db_deleted_item_execs = []
+        self.db_item_execs_id_index = {}
+        if item_execs is None:
+            self._db_item_execs = []
+        else:
+            self._db_item_execs = item_execs
+            for v in self._db_item_execs:
+                self.db_item_execs_id_index[v.db_id] = v
+        self._db_id = id
+        self._db_ts_start = ts_start
+        self._db_ts_end = ts_end
+        self._db_cached = cached
+        self._db_module_id = module_id
+        self._db_group_name = group_name
+        self._db_group_type = group_type
+        self._db_completed = completed
+        self._db_error = error
+        self._db_machine_id = machine_id
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBGroupExec.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBGroupExec(id=self._db_id,
+                         ts_start=self._db_ts_start,
+                         ts_end=self._db_ts_end,
+                         cached=self._db_cached,
+                         module_id=self._db_module_id,
+                         group_name=self._db_group_name,
+                         group_type=self._db_group_type,
+                         completed=self._db_completed,
+                         error=self._db_error,
+                         machine_id=self._db_machine_id)
+        if self._db_item_execs is None:
+            cp._db_item_execs = []
+        else:
+            cp._db_item_execs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_item_execs]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_module_id') and ('module', self._db_module_id) in id_remap:
+                cp._db_module_id = id_remap[('module', self._db_module_id)]
+            if hasattr(self, 'db_machine_id') and ('machine', self._db_machine_id) in id_remap:
+                cp._db_machine_id = id_remap[('machine', self._db_machine_id)]
+        
+        # recreate indices and set flags
+        cp.db_item_execs_id_index = dict((v.db_id, v) for v in cp._db_item_execs)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBGroupExec()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'item_execs' in class_dict:
+            res = class_dict['item_execs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_item_exec(obj)
+        elif hasattr(old_obj, 'db_item_execs') and old_obj.db_item_execs is not None:
+            for obj in old_obj.db_item_execs:
+                if obj.vtType == 'module_exec':
+                    new_obj.db_add_item_exec(DBModuleExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'group_exec':
+                    new_obj.db_add_item_exec(DBGroupExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'loop_exec':
+                    new_obj.db_add_item_exec(DBLoopExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_item_execs') and hasattr(new_obj, 'db_deleted_item_execs'):
+            for obj in old_obj.db_deleted_item_execs:
+                if obj.vtType == 'module_exec':
+                    n_obj = DBModuleExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'group_exec':
+                    n_obj = DBGroupExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'loop_exec':
+                    n_obj = DBLoopExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'ts_start' in class_dict:
+            res = class_dict['ts_start'](old_obj, trans_dict)
+            new_obj.db_ts_start = res
+        elif hasattr(old_obj, 'db_ts_start') and old_obj.db_ts_start is not None:
+            new_obj.db_ts_start = old_obj.db_ts_start
+        if 'ts_end' in class_dict:
+            res = class_dict['ts_end'](old_obj, trans_dict)
+            new_obj.db_ts_end = res
+        elif hasattr(old_obj, 'db_ts_end') and old_obj.db_ts_end is not None:
+            new_obj.db_ts_end = old_obj.db_ts_end
+        if 'cached' in class_dict:
+            res = class_dict['cached'](old_obj, trans_dict)
+            new_obj.db_cached = res
+        elif hasattr(old_obj, 'db_cached') and old_obj.db_cached is not None:
+            new_obj.db_cached = old_obj.db_cached
+        if 'module_id' in class_dict:
+            res = class_dict['module_id'](old_obj, trans_dict)
+            new_obj.db_module_id = res
+        elif hasattr(old_obj, 'db_module_id') and old_obj.db_module_id is not None:
+            new_obj.db_module_id = old_obj.db_module_id
+        if 'group_name' in class_dict:
+            res = class_dict['group_name'](old_obj, trans_dict)
+            new_obj.db_group_name = res
+        elif hasattr(old_obj, 'db_group_name') and old_obj.db_group_name is not None:
+            new_obj.db_group_name = old_obj.db_group_name
+        if 'group_type' in class_dict:
+            res = class_dict['group_type'](old_obj, trans_dict)
+            new_obj.db_group_type = res
+        elif hasattr(old_obj, 'db_group_type') and old_obj.db_group_type is not None:
+            new_obj.db_group_type = old_obj.db_group_type
+        if 'completed' in class_dict:
+            res = class_dict['completed'](old_obj, trans_dict)
+            new_obj.db_completed = res
+        elif hasattr(old_obj, 'db_completed') and old_obj.db_completed is not None:
+            new_obj.db_completed = old_obj.db_completed
+        if 'error' in class_dict:
+            res = class_dict['error'](old_obj, trans_dict)
+            new_obj.db_error = res
+        elif hasattr(old_obj, 'db_error') and old_obj.db_error is not None:
+            new_obj.db_error = old_obj.db_error
+        if 'machine_id' in class_dict:
+            res = class_dict['machine_id'](old_obj, trans_dict)
+            new_obj.db_machine_id = res
+        elif hasattr(old_obj, 'db_machine_id') and old_obj.db_machine_id is not None:
+            new_obj.db_machine_id = old_obj.db_machine_id
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_item_execs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_item_exec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_item_execs)
+        if remove:
+            self.db_deleted_annotations = []
+            self.db_deleted_item_execs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_item_execs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_item_execs(self):
+        return self._db_item_execs
+    def __set_db_item_execs(self, item_execs):
+        self._db_item_execs = item_execs
+        self.is_dirty = True
+    db_item_execs = property(__get_db_item_execs, __set_db_item_execs)
+    def db_get_item_execs(self):
+        return self._db_item_execs
+    def db_add_item_exec(self, item_exec):
+        self.is_dirty = True
+        self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_change_item_exec(self, item_exec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                self._db_item_execs[i] = item_exec
+                found = True
+                break
+        if not found:
+            self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_delete_item_exec(self, item_exec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                if not self._db_item_execs[i].is_new:
+                    self.db_deleted_item_execs.append(self._db_item_execs[i])
+                del self._db_item_execs[i]
+                break
+        del self.db_item_execs_id_index[item_exec.db_id]
+    def db_get_item_exec(self, key):
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == key:
+                return self._db_item_execs[i]
+        return None
+    def db_get_item_exec_by_id(self, key):
+        return self.db_item_execs_id_index[key]
+    def db_has_item_exec_with_id(self, key):
+        return key in self.db_item_execs_id_index
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_ts_start(self):
+        return self._db_ts_start
+    def __set_db_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+        self.is_dirty = True
+    db_ts_start = property(__get_db_ts_start, __set_db_ts_start)
+    def db_add_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_change_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_delete_ts_start(self, ts_start):
+        self._db_ts_start = None
+    
+    def __get_db_ts_end(self):
+        return self._db_ts_end
+    def __set_db_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+        self.is_dirty = True
+    db_ts_end = property(__get_db_ts_end, __set_db_ts_end)
+    def db_add_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_change_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_delete_ts_end(self, ts_end):
+        self._db_ts_end = None
+    
+    def __get_db_cached(self):
+        return self._db_cached
+    def __set_db_cached(self, cached):
+        self._db_cached = cached
+        self.is_dirty = True
+    db_cached = property(__get_db_cached, __set_db_cached)
+    def db_add_cached(self, cached):
+        self._db_cached = cached
+    def db_change_cached(self, cached):
+        self._db_cached = cached
+    def db_delete_cached(self, cached):
+        self._db_cached = None
+    
+    def __get_db_module_id(self):
+        return self._db_module_id
+    def __set_db_module_id(self, module_id):
+        self._db_module_id = module_id
+        self.is_dirty = True
+    db_module_id = property(__get_db_module_id, __set_db_module_id)
+    def db_add_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_change_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_delete_module_id(self, module_id):
+        self._db_module_id = None
+    
+    def __get_db_group_name(self):
+        return self._db_group_name
+    def __set_db_group_name(self, group_name):
+        self._db_group_name = group_name
+        self.is_dirty = True
+    db_group_name = property(__get_db_group_name, __set_db_group_name)
+    def db_add_group_name(self, group_name):
+        self._db_group_name = group_name
+    def db_change_group_name(self, group_name):
+        self._db_group_name = group_name
+    def db_delete_group_name(self, group_name):
+        self._db_group_name = None
+    
+    def __get_db_group_type(self):
+        return self._db_group_type
+    def __set_db_group_type(self, group_type):
+        self._db_group_type = group_type
+        self.is_dirty = True
+    db_group_type = property(__get_db_group_type, __set_db_group_type)
+    def db_add_group_type(self, group_type):
+        self._db_group_type = group_type
+    def db_change_group_type(self, group_type):
+        self._db_group_type = group_type
+    def db_delete_group_type(self, group_type):
+        self._db_group_type = None
+    
+    def __get_db_completed(self):
+        return self._db_completed
+    def __set_db_completed(self, completed):
+        self._db_completed = completed
+        self.is_dirty = True
+    db_completed = property(__get_db_completed, __set_db_completed)
+    def db_add_completed(self, completed):
+        self._db_completed = completed
+    def db_change_completed(self, completed):
+        self._db_completed = completed
+    def db_delete_completed(self, completed):
+        self._db_completed = None
+    
+    def __get_db_error(self):
+        return self._db_error
+    def __set_db_error(self, error):
+        self._db_error = error
+        self.is_dirty = True
+    db_error = property(__get_db_error, __set_db_error)
+    def db_add_error(self, error):
+        self._db_error = error
+    def db_change_error(self, error):
+        self._db_error = error
+    def db_delete_error(self, error):
+        self._db_error = None
+    
+    def __get_db_machine_id(self):
+        return self._db_machine_id
+    def __set_db_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+        self.is_dirty = True
+    db_machine_id = property(__get_db_machine_id, __set_db_machine_id)
+    def db_add_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+    def db_change_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+    def db_delete_machine_id(self, machine_id):
+        self._db_machine_id = None
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmAgentId(object):
+
+    vtType = 'opm_agent_id'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAgentId.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAgentId(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_agent', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_agent', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAgentId()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBParameter(object):
+
+    vtType = 'parameter'
+
+    def __init__(self, id=None, pos=None, name=None, type=None, val=None, alias=None):
+        self._db_id = id
+        self._db_pos = pos
+        self._db_name = name
+        self._db_type = type
+        self._db_val = val
+        self._db_alias = alias
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBParameter.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBParameter(id=self._db_id,
+                         pos=self._db_pos,
+                         name=self._db_name,
+                         type=self._db_type,
+                         val=self._db_val,
+                         alias=self._db_alias)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBParameter()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'pos' in class_dict:
+            res = class_dict['pos'](old_obj, trans_dict)
+            new_obj.db_pos = res
+        elif hasattr(old_obj, 'db_pos') and old_obj.db_pos is not None:
+            new_obj.db_pos = old_obj.db_pos
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'type' in class_dict:
+            res = class_dict['type'](old_obj, trans_dict)
+            new_obj.db_type = res
+        elif hasattr(old_obj, 'db_type') and old_obj.db_type is not None:
+            new_obj.db_type = old_obj.db_type
+        if 'val' in class_dict:
+            res = class_dict['val'](old_obj, trans_dict)
+            new_obj.db_val = res
+        elif hasattr(old_obj, 'db_val') and old_obj.db_val is not None:
+            new_obj.db_val = old_obj.db_val
+        if 'alias' in class_dict:
+            res = class_dict['alias'](old_obj, trans_dict)
+            new_obj.db_alias = res
+        elif hasattr(old_obj, 'db_alias') and old_obj.db_alias is not None:
+            new_obj.db_alias = old_obj.db_alias
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_pos(self):
+        return self._db_pos
+    def __set_db_pos(self, pos):
+        self._db_pos = pos
+        self.is_dirty = True
+    db_pos = property(__get_db_pos, __set_db_pos)
+    def db_add_pos(self, pos):
+        self._db_pos = pos
+    def db_change_pos(self, pos):
+        self._db_pos = pos
+    def db_delete_pos(self, pos):
+        self._db_pos = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_type(self):
+        return self._db_type
+    def __set_db_type(self, type):
+        self._db_type = type
+        self.is_dirty = True
+    db_type = property(__get_db_type, __set_db_type)
+    def db_add_type(self, type):
+        self._db_type = type
+    def db_change_type(self, type):
+        self._db_type = type
+    def db_delete_type(self, type):
+        self._db_type = None
+    
+    def __get_db_val(self):
+        return self._db_val
+    def __set_db_val(self, val):
+        self._db_val = val
+        self.is_dirty = True
+    db_val = property(__get_db_val, __set_db_val)
+    def db_add_val(self, val):
+        self._db_val = val
+    def db_change_val(self, val):
+        self._db_val = val
+    def db_delete_val(self, val):
+        self._db_val = None
+    
+    def __get_db_alias(self):
+        return self._db_alias
+    def __set_db_alias(self, alias):
+        self._db_alias = alias
+        self.is_dirty = True
+    db_alias = property(__get_db_alias, __set_db_alias)
+    def db_add_alias(self, alias):
+        self._db_alias = alias
+    def db_change_alias(self, alias):
+        self._db_alias = alias
+    def db_delete_alias(self, alias):
+        self._db_alias = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBVistrail(object):
+
+    vtType = 'vistrail'
+
+    def __init__(self, id=None, entity_type=None, version=None, name=None, last_modified=None, actions=None, tags=None, annotations=None, controlParameters=None, vistrailVariables=None, parameter_explorations=None, actionAnnotations=None):
+        self._db_id = id
+        self._db_entity_type = entity_type
+        self._db_version = version
+        self._db_name = name
+        self._db_last_modified = last_modified
+        self.db_deleted_actions = []
+        self.db_actions_id_index = {}
+        if actions is None:
+            self._db_actions = []
+        else:
+            self._db_actions = actions
+            for v in self._db_actions:
+                self.db_actions_id_index[v.db_id] = v
+        self.db_deleted_tags = []
+        self.db_tags_id_index = {}
+        self.db_tags_name_index = {}
+        if tags is None:
+            self._db_tags = []
+        else:
+            self._db_tags = tags
+            for v in self._db_tags:
+                self.db_tags_id_index[v.db_id] = v
+                self.db_tags_name_index[v.db_name] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.db_deleted_controlParameters = []
+        self.db_controlParameters_id_index = {}
+        self.db_controlParameters_name_index = {}
+        if controlParameters is None:
+            self._db_controlParameters = []
+        else:
+            self._db_controlParameters = controlParameters
+            for v in self._db_controlParameters:
+                self.db_controlParameters_id_index[v.db_id] = v
+                self.db_controlParameters_name_index[v.db_name] = v
+        self.db_deleted_vistrailVariables = []
+        self.db_vistrailVariables_name_index = {}
+        self.db_vistrailVariables_uuid_index = {}
+        if vistrailVariables is None:
+            self._db_vistrailVariables = []
+        else:
+            self._db_vistrailVariables = vistrailVariables
+            for v in self._db_vistrailVariables:
+                self.db_vistrailVariables_name_index[v.db_name] = v
+                self.db_vistrailVariables_uuid_index[v.db_uuid] = v
+        self.db_deleted_parameter_explorations = []
+        self.db_parameter_explorations_id_index = {}
+        if parameter_explorations is None:
+            self._db_parameter_explorations = []
+        else:
+            self._db_parameter_explorations = parameter_explorations
+            for v in self._db_parameter_explorations:
+                self.db_parameter_explorations_id_index[v.db_id] = v
+        self.db_deleted_actionAnnotations = []
+        self.db_actionAnnotations_id_index = {}
+        self.db_actionAnnotations_action_id_index = {}
+        self.db_actionAnnotations_key_index = {}
+        if actionAnnotations is None:
+            self._db_actionAnnotations = []
+        else:
+            self._db_actionAnnotations = actionAnnotations
+            for v in self._db_actionAnnotations:
+                self.db_actionAnnotations_id_index[v.db_id] = v
+                self.db_actionAnnotations_action_id_index[(v.db_action_id,v.db_key)] = v
+                self.db_actionAnnotations_key_index[(v.db_key,v.db_value)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBVistrail.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBVistrail(id=self._db_id,
+                        entity_type=self._db_entity_type,
+                        version=self._db_version,
+                        name=self._db_name,
+                        last_modified=self._db_last_modified)
+        if self._db_actions is None:
+            cp._db_actions = []
+        else:
+            cp._db_actions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_actions]
+        if self._db_tags is None:
+            cp._db_tags = []
+        else:
+            cp._db_tags = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_tags]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_controlParameters is None:
+            cp._db_controlParameters = []
+        else:
+            cp._db_controlParameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_controlParameters]
+        if self._db_vistrailVariables is None:
+            cp._db_vistrailVariables = []
+        else:
+            cp._db_vistrailVariables = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_vistrailVariables]
+        if self._db_parameter_explorations is None:
+            cp._db_parameter_explorations = []
+        else:
+            cp._db_parameter_explorations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_parameter_explorations]
+        if self._db_actionAnnotations is None:
+            cp._db_actionAnnotations = []
+        else:
+            cp._db_actionAnnotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_actionAnnotations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_actions_id_index = dict((v.db_id, v) for v in cp._db_actions)
+        cp.db_tags_id_index = dict((v.db_id, v) for v in cp._db_tags)
+        cp.db_tags_name_index = dict((v.db_name, v) for v in cp._db_tags)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        cp.db_controlParameters_id_index = dict((v.db_id, v) for v in cp._db_controlParameters)
+        cp.db_controlParameters_name_index = dict((v.db_name, v) for v in cp._db_controlParameters)
+        cp.db_vistrailVariables_name_index = dict((v.db_name, v) for v in cp._db_vistrailVariables)
+        cp.db_vistrailVariables_uuid_index = dict((v.db_uuid, v) for v in cp._db_vistrailVariables)
+        cp.db_parameter_explorations_id_index = dict((v.db_id, v) for v in cp._db_parameter_explorations)
+        cp.db_actionAnnotations_id_index = dict((v.db_id, v) for v in cp._db_actionAnnotations)
+        cp.db_actionAnnotations_action_id_index = dict(((v.db_action_id,v.db_key), v) for v in cp._db_actionAnnotations)
+        cp.db_actionAnnotations_key_index = dict(((v.db_key,v.db_value), v) for v in cp._db_actionAnnotations)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBVistrail()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'entity_type' in class_dict:
+            res = class_dict['entity_type'](old_obj, trans_dict)
+            new_obj.db_entity_type = res
+        elif hasattr(old_obj, 'db_entity_type') and old_obj.db_entity_type is not None:
+            new_obj.db_entity_type = old_obj.db_entity_type
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'last_modified' in class_dict:
+            res = class_dict['last_modified'](old_obj, trans_dict)
+            new_obj.db_last_modified = res
+        elif hasattr(old_obj, 'db_last_modified') and old_obj.db_last_modified is not None:
+            new_obj.db_last_modified = old_obj.db_last_modified
+        if 'actions' in class_dict:
+            res = class_dict['actions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_action(obj)
+        elif hasattr(old_obj, 'db_actions') and old_obj.db_actions is not None:
+            for obj in old_obj.db_actions:
+                new_obj.db_add_action(DBAction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_actions') and hasattr(new_obj, 'db_deleted_actions'):
+            for obj in old_obj.db_deleted_actions:
+                n_obj = DBAction.update_version(obj, trans_dict)
+                new_obj.db_deleted_actions.append(n_obj)
+        if 'tags' in class_dict:
+            res = class_dict['tags'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_tag(obj)
+        elif hasattr(old_obj, 'db_tags') and old_obj.db_tags is not None:
+            for obj in old_obj.db_tags:
+                new_obj.db_add_tag(DBTag.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_tags') and hasattr(new_obj, 'db_deleted_tags'):
+            for obj in old_obj.db_deleted_tags:
+                n_obj = DBTag.update_version(obj, trans_dict)
+                new_obj.db_deleted_tags.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'controlParameters' in class_dict:
+            res = class_dict['controlParameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_controlParameter(obj)
+        elif hasattr(old_obj, 'db_controlParameters') and old_obj.db_controlParameters is not None:
+            for obj in old_obj.db_controlParameters:
+                new_obj.db_add_controlParameter(DBControlParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_controlParameters') and hasattr(new_obj, 'db_deleted_controlParameters'):
+            for obj in old_obj.db_deleted_controlParameters:
+                n_obj = DBControlParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_controlParameters.append(n_obj)
+        if 'vistrailVariables' in class_dict:
+            res = class_dict['vistrailVariables'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_vistrailVariable(obj)
+        elif hasattr(old_obj, 'db_vistrailVariables') and old_obj.db_vistrailVariables is not None:
+            for obj in old_obj.db_vistrailVariables:
+                new_obj.db_add_vistrailVariable(DBVistrailVariable.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_vistrailVariables') and hasattr(new_obj, 'db_deleted_vistrailVariables'):
+            for obj in old_obj.db_deleted_vistrailVariables:
+                n_obj = DBVistrailVariable.update_version(obj, trans_dict)
+                new_obj.db_deleted_vistrailVariables.append(n_obj)
+        if 'parameter_explorations' in class_dict:
+            res = class_dict['parameter_explorations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_parameter_exploration(obj)
+        elif hasattr(old_obj, 'db_parameter_explorations') and old_obj.db_parameter_explorations is not None:
+            for obj in old_obj.db_parameter_explorations:
+                new_obj.db_add_parameter_exploration(DBParameterExploration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_parameter_explorations') and hasattr(new_obj, 'db_deleted_parameter_explorations'):
+            for obj in old_obj.db_deleted_parameter_explorations:
+                n_obj = DBParameterExploration.update_version(obj, trans_dict)
+                new_obj.db_deleted_parameter_explorations.append(n_obj)
+        if 'actionAnnotations' in class_dict:
+            res = class_dict['actionAnnotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_actionAnnotation(obj)
+        elif hasattr(old_obj, 'db_actionAnnotations') and old_obj.db_actionAnnotations is not None:
+            for obj in old_obj.db_actionAnnotations:
+                new_obj.db_add_actionAnnotation(DBActionAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_actionAnnotations') and hasattr(new_obj, 'db_deleted_actionAnnotations'):
+            for obj in old_obj.db_deleted_actionAnnotations:
+                n_obj = DBActionAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_actionAnnotations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_actions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_action(child)
+        to_del = []
+        for child in self.db_tags:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_tag(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_controlParameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_controlParameter(child)
+        to_del = []
+        for child in self.db_vistrailVariables:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_vistrailVariable(child)
+        to_del = []
+        for child in self.db_parameter_explorations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_parameter_exploration(child)
+        to_del = []
+        for child in self.db_actionAnnotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_actionAnnotation(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_actions)
+        children.extend(self.db_deleted_tags)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_controlParameters)
+        children.extend(self.db_deleted_vistrailVariables)
+        children.extend(self.db_deleted_parameter_explorations)
+        children.extend(self.db_deleted_actionAnnotations)
+        if remove:
+            self.db_deleted_actions = []
+            self.db_deleted_tags = []
+            self.db_deleted_annotations = []
+            self.db_deleted_controlParameters = []
+            self.db_deleted_vistrailVariables = []
+            self.db_deleted_parameter_explorations = []
+            self.db_deleted_actionAnnotations = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_actions:
+            if child.has_changes():
+                return True
+        for child in self._db_tags:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_controlParameters:
+            if child.has_changes():
+                return True
+        for child in self._db_vistrailVariables:
+            if child.has_changes():
+                return True
+        for child in self._db_parameter_explorations:
+            if child.has_changes():
+                return True
+        for child in self._db_actionAnnotations:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_entity_type(self):
+        return self._db_entity_type
+    def __set_db_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+        self.is_dirty = True
+    db_entity_type = property(__get_db_entity_type, __set_db_entity_type)
+    def db_add_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_change_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_delete_entity_type(self, entity_type):
+        self._db_entity_type = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_last_modified(self):
+        return self._db_last_modified
+    def __set_db_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+        self.is_dirty = True
+    db_last_modified = property(__get_db_last_modified, __set_db_last_modified)
+    def db_add_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_change_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_delete_last_modified(self, last_modified):
+        self._db_last_modified = None
+    
+    def __get_db_actions(self):
+        return self._db_actions
+    def __set_db_actions(self, actions):
+        self._db_actions = actions
+        self.is_dirty = True
+    db_actions = property(__get_db_actions, __set_db_actions)
+    def db_get_actions(self):
+        return self._db_actions
+    def db_add_action(self, action):
+        self.is_dirty = True
+        self._db_actions.append(action)
+        self.db_actions_id_index[action.db_id] = action
+    def db_change_action(self, action):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == action.db_id:
+                self._db_actions[i] = action
+                found = True
+                break
+        if not found:
+            self._db_actions.append(action)
+        self.db_actions_id_index[action.db_id] = action
+    def db_delete_action(self, action):
+        self.is_dirty = True
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == action.db_id:
+                if not self._db_actions[i].is_new:
+                    self.db_deleted_actions.append(self._db_actions[i])
+                del self._db_actions[i]
+                break
+        del self.db_actions_id_index[action.db_id]
+    def db_get_action(self, key):
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == key:
+                return self._db_actions[i]
+        return None
+    def db_get_action_by_id(self, key):
+        return self.db_actions_id_index[key]
+    def db_has_action_with_id(self, key):
+        return key in self.db_actions_id_index
+    
+    def __get_db_tags(self):
+        return self._db_tags
+    def __set_db_tags(self, tags):
+        self._db_tags = tags
+        self.is_dirty = True
+    db_tags = property(__get_db_tags, __set_db_tags)
+    def db_get_tags(self):
+        return self._db_tags
+    def db_add_tag(self, tag):
+        self.is_dirty = True
+        self._db_tags.append(tag)
+        self.db_tags_id_index[tag.db_id] = tag
+        self.db_tags_name_index[tag.db_name] = tag
+    def db_change_tag(self, tag):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_tags)):
+            if self._db_tags[i].db_id == tag.db_id:
+                self._db_tags[i] = tag
+                found = True
+                break
+        if not found:
+            self._db_tags.append(tag)
+        self.db_tags_id_index[tag.db_id] = tag
+        self.db_tags_name_index[tag.db_name] = tag
+    def db_delete_tag(self, tag):
+        self.is_dirty = True
+        for i in xrange(len(self._db_tags)):
+            if self._db_tags[i].db_id == tag.db_id:
+                if not self._db_tags[i].is_new:
+                    self.db_deleted_tags.append(self._db_tags[i])
+                del self._db_tags[i]
+                break
+        del self.db_tags_id_index[tag.db_id]
+        del self.db_tags_name_index[tag.db_name]
+    def db_get_tag(self, key):
+        for i in xrange(len(self._db_tags)):
+            if self._db_tags[i].db_id == key:
+                return self._db_tags[i]
+        return None
+    def db_get_tag_by_id(self, key):
+        return self.db_tags_id_index[key]
+    def db_has_tag_with_id(self, key):
+        return key in self.db_tags_id_index
+    def db_get_tag_by_name(self, key):
+        return self.db_tags_name_index[key]
+    def db_has_tag_with_name(self, key):
+        return key in self.db_tags_name_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def __get_db_controlParameters(self):
+        return self._db_controlParameters
+    def __set_db_controlParameters(self, controlParameters):
+        self._db_controlParameters = controlParameters
+        self.is_dirty = True
+    db_controlParameters = property(__get_db_controlParameters, __set_db_controlParameters)
+    def db_get_controlParameters(self):
+        return self._db_controlParameters
+    def db_add_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_change_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                self._db_controlParameters[i] = controlParameter
+                found = True
+                break
+        if not found:
+            self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_delete_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                if not self._db_controlParameters[i].is_new:
+                    self.db_deleted_controlParameters.append(self._db_controlParameters[i])
+                del self._db_controlParameters[i]
+                break
+        del self.db_controlParameters_id_index[controlParameter.db_id]
+        del self.db_controlParameters_name_index[controlParameter.db_name]
+    def db_get_controlParameter(self, key):
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == key:
+                return self._db_controlParameters[i]
+        return None
+    def db_get_controlParameter_by_id(self, key):
+        return self.db_controlParameters_id_index[key]
+    def db_has_controlParameter_with_id(self, key):
+        return key in self.db_controlParameters_id_index
+    def db_get_controlParameter_by_name(self, key):
+        return self.db_controlParameters_name_index[key]
+    def db_has_controlParameter_with_name(self, key):
+        return key in self.db_controlParameters_name_index
+    
+    def __get_db_vistrailVariables(self):
+        return self._db_vistrailVariables
+    def __set_db_vistrailVariables(self, vistrailVariables):
+        self._db_vistrailVariables = vistrailVariables
+        self.is_dirty = True
+    db_vistrailVariables = property(__get_db_vistrailVariables, __set_db_vistrailVariables)
+    def db_get_vistrailVariables(self):
+        return self._db_vistrailVariables
+    def db_add_vistrailVariable(self, vistrailVariable):
+        self.is_dirty = True
+        self._db_vistrailVariables.append(vistrailVariable)
+        self.db_vistrailVariables_name_index[vistrailVariable.db_name] = vistrailVariable
+        self.db_vistrailVariables_uuid_index[vistrailVariable.db_uuid] = vistrailVariable
+    def db_change_vistrailVariable(self, vistrailVariable):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_vistrailVariables)):
+            if self._db_vistrailVariables[i].db_name == vistrailVariable.db_name:
+                self._db_vistrailVariables[i] = vistrailVariable
+                found = True
+                break
+        if not found:
+            self._db_vistrailVariables.append(vistrailVariable)
+        self.db_vistrailVariables_name_index[vistrailVariable.db_name] = vistrailVariable
+        self.db_vistrailVariables_uuid_index[vistrailVariable.db_uuid] = vistrailVariable
+    def db_delete_vistrailVariable(self, vistrailVariable):
+        self.is_dirty = True
+        for i in xrange(len(self._db_vistrailVariables)):
+            if self._db_vistrailVariables[i].db_name == vistrailVariable.db_name:
+                if not self._db_vistrailVariables[i].is_new:
+                    self.db_deleted_vistrailVariables.append(self._db_vistrailVariables[i])
+                del self._db_vistrailVariables[i]
+                break
+        del self.db_vistrailVariables_name_index[vistrailVariable.db_name]
+        del self.db_vistrailVariables_uuid_index[vistrailVariable.db_uuid]
+    def db_get_vistrailVariable(self, key):
+        for i in xrange(len(self._db_vistrailVariables)):
+            if self._db_vistrailVariables[i].db_name == key:
+                return self._db_vistrailVariables[i]
+        return None
+    def db_get_vistrailVariable_by_name(self, key):
+        return self.db_vistrailVariables_name_index[key]
+    def db_has_vistrailVariable_with_name(self, key):
+        return key in self.db_vistrailVariables_name_index
+    def db_get_vistrailVariable_by_uuid(self, key):
+        return self.db_vistrailVariables_uuid_index[key]
+    def db_has_vistrailVariable_with_uuid(self, key):
+        return key in self.db_vistrailVariables_uuid_index
+    
+    def __get_db_parameter_explorations(self):
+        return self._db_parameter_explorations
+    def __set_db_parameter_explorations(self, parameter_explorations):
+        self._db_parameter_explorations = parameter_explorations
+        self.is_dirty = True
+    db_parameter_explorations = property(__get_db_parameter_explorations, __set_db_parameter_explorations)
+    def db_get_parameter_explorations(self):
+        return self._db_parameter_explorations
+    def db_add_parameter_exploration(self, parameter_exploration):
+        self.is_dirty = True
+        self._db_parameter_explorations.append(parameter_exploration)
+        self.db_parameter_explorations_id_index[parameter_exploration.db_id] = parameter_exploration
+    def db_change_parameter_exploration(self, parameter_exploration):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_parameter_explorations)):
+            if self._db_parameter_explorations[i].db_id == parameter_exploration.db_id:
+                self._db_parameter_explorations[i] = parameter_exploration
+                found = True
+                break
+        if not found:
+            self._db_parameter_explorations.append(parameter_exploration)
+        self.db_parameter_explorations_id_index[parameter_exploration.db_id] = parameter_exploration
+    def db_delete_parameter_exploration(self, parameter_exploration):
+        self.is_dirty = True
+        for i in xrange(len(self._db_parameter_explorations)):
+            if self._db_parameter_explorations[i].db_id == parameter_exploration.db_id:
+                if not self._db_parameter_explorations[i].is_new:
+                    self.db_deleted_parameter_explorations.append(self._db_parameter_explorations[i])
+                del self._db_parameter_explorations[i]
+                break
+        del self.db_parameter_explorations_id_index[parameter_exploration.db_id]
+    def db_get_parameter_exploration(self, key):
+        for i in xrange(len(self._db_parameter_explorations)):
+            if self._db_parameter_explorations[i].db_id == key:
+                return self._db_parameter_explorations[i]
+        return None
+    def db_get_parameter_exploration_by_id(self, key):
+        return self.db_parameter_explorations_id_index[key]
+    def db_has_parameter_exploration_with_id(self, key):
+        return key in self.db_parameter_explorations_id_index
+    
+    def __get_db_actionAnnotations(self):
+        return self._db_actionAnnotations
+    def __set_db_actionAnnotations(self, actionAnnotations):
+        self._db_actionAnnotations = actionAnnotations
+        self.is_dirty = True
+    db_actionAnnotations = property(__get_db_actionAnnotations, __set_db_actionAnnotations)
+    def db_get_actionAnnotations(self):
+        return self._db_actionAnnotations
+    def db_add_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        self._db_actionAnnotations.append(actionAnnotation)
+        self.db_actionAnnotations_id_index[actionAnnotation.db_id] = actionAnnotation
+        self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)] = actionAnnotation
+        self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)] = actionAnnotation
+    def db_change_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == actionAnnotation.db_id:
+                self._db_actionAnnotations[i] = actionAnnotation
+                found = True
+                break
+        if not found:
+            self._db_actionAnnotations.append(actionAnnotation)
+        self.db_actionAnnotations_id_index[actionAnnotation.db_id] = actionAnnotation
+        self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)] = actionAnnotation
+        self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)] = actionAnnotation
+    def db_delete_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == actionAnnotation.db_id:
+                if not self._db_actionAnnotations[i].is_new:
+                    self.db_deleted_actionAnnotations.append(self._db_actionAnnotations[i])
+                del self._db_actionAnnotations[i]
+                break
+        del self.db_actionAnnotations_id_index[actionAnnotation.db_id]
+        del self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)]
+        try:
+            del self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)]
+        except KeyError:
+            pass
+    def db_get_actionAnnotation(self, key):
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == key:
+                return self._db_actionAnnotations[i]
+        return None
+    def db_get_actionAnnotation_by_id(self, key):
+        return self.db_actionAnnotations_id_index[key]
+    def db_has_actionAnnotation_with_id(self, key):
+        return key in self.db_actionAnnotations_id_index
+    def db_get_actionAnnotation_by_action_id(self, key):
+        return self.db_actionAnnotations_action_id_index[key]
+    def db_has_actionAnnotation_with_action_id(self, key):
+        return key in self.db_actionAnnotations_action_id_index
+    def db_get_actionAnnotation_by_key(self, key):
+        return self.db_actionAnnotations_key_index[key]
+    def db_has_actionAnnotation_with_key(self, key):
+        return key in self.db_actionAnnotations_key_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmArtifactValue(object):
+
+    vtType = 'opm_artifact_value'
+
+    def __init__(self, value=None):
+        self.db_deleted_value = []
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmArtifactValue.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmArtifactValue()
+        if self._db_value is not None:
+            cp._db_value = self._db_value.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmArtifactValue()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            obj = old_obj.db_value
+            if obj.vtType == 'portSpec':
+                new_obj.db_add_value(DBPortSpec.update_version(obj, trans_dict))
+            elif obj.vtType == 'function':
+                new_obj.db_add_value(DBFunction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_value') and hasattr(new_obj, 'db_deleted_value'):
+            for obj in old_obj.db_deleted_value:
+                if obj.vtType == 'portSpec':
+                    n_obj = DBPortSpec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'function':
+                    n_obj = DBFunction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_value is not None:
+            children.extend(self._db_value.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_value = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_value)
+        if remove:
+            self.db_deleted_value = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_value is not None and self._db_value.has_changes():
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        if not self.is_new:
+            self.db_deleted_value.append(self._db_value)
+        self._db_value = None
+    
+
+
+class DBConfigStr(object):
+
+    vtType = 'config_str'
+
+    def __init__(self, value=None):
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfigStr.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfigStr(value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfigStr()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+
+
+class DBStartup(object):
+
+    vtType = 'startup'
+
+    def __init__(self, version=None, configuration=None, enabled_packages=None, disabled_packages=None):
+        self._db_version = version
+        self.db_deleted_configuration = []
+        self._db_configuration = configuration
+        self.db_deleted_enabled_packages = []
+        self._db_enabled_packages = enabled_packages
+        self.db_deleted_disabled_packages = []
+        self._db_disabled_packages = disabled_packages
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBStartup.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBStartup(version=self._db_version)
+        if self._db_configuration is not None:
+            cp._db_configuration = self._db_configuration.do_copy(new_ids, id_scope, id_remap)
+        if self._db_enabled_packages is not None:
+            cp._db_enabled_packages = self._db_enabled_packages.do_copy(new_ids, id_scope, id_remap)
+        if self._db_disabled_packages is not None:
+            cp._db_disabled_packages = self._db_disabled_packages.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBStartup()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'configuration' in class_dict:
+            res = class_dict['configuration'](old_obj, trans_dict)
+            new_obj.db_configuration = res
+        elif hasattr(old_obj, 'db_configuration') and old_obj.db_configuration is not None:
+            obj = old_obj.db_configuration
+            new_obj.db_add_configuration(DBConfiguration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_configuration') and hasattr(new_obj, 'db_deleted_configuration'):
+            for obj in old_obj.db_deleted_configuration:
+                n_obj = DBConfiguration.update_version(obj, trans_dict)
+                new_obj.db_deleted_configuration.append(n_obj)
+        if 'enabled_packages' in class_dict:
+            res = class_dict['enabled_packages'](old_obj, trans_dict)
+            new_obj.db_enabled_packages = res
+        elif hasattr(old_obj, 'db_enabled_packages') and old_obj.db_enabled_packages is not None:
+            obj = old_obj.db_enabled_packages
+            new_obj.db_add_enabled_packages(DBEnabledPackages.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_enabled_packages') and hasattr(new_obj, 'db_deleted_enabled_packages'):
+            for obj in old_obj.db_deleted_enabled_packages:
+                n_obj = DBEnabledPackages.update_version(obj, trans_dict)
+                new_obj.db_deleted_enabled_packages.append(n_obj)
+        if 'disabled_packages' in class_dict:
+            res = class_dict['disabled_packages'](old_obj, trans_dict)
+            new_obj.db_disabled_packages = res
+        elif hasattr(old_obj, 'db_disabled_packages') and old_obj.db_disabled_packages is not None:
+            obj = old_obj.db_disabled_packages
+            new_obj.db_add_disabled_packages(DBDisabledPackages.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_disabled_packages') and hasattr(new_obj, 'db_deleted_disabled_packages'):
+            for obj in old_obj.db_deleted_disabled_packages:
+                n_obj = DBDisabledPackages.update_version(obj, trans_dict)
+                new_obj.db_deleted_disabled_packages.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_configuration is not None:
+            children.extend(self._db_configuration.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_configuration = None
+        if self._db_enabled_packages is not None:
+            children.extend(self._db_enabled_packages.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_enabled_packages = None
+        if self._db_disabled_packages is not None:
+            children.extend(self._db_disabled_packages.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_disabled_packages = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_configuration)
+        children.extend(self.db_deleted_enabled_packages)
+        children.extend(self.db_deleted_disabled_packages)
+        if remove:
+            self.db_deleted_configuration = []
+            self.db_deleted_enabled_packages = []
+            self.db_deleted_disabled_packages = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_configuration is not None and self._db_configuration.has_changes():
+            return True
+        if self._db_enabled_packages is not None and self._db_enabled_packages.has_changes():
+            return True
+        if self._db_disabled_packages is not None and self._db_disabled_packages.has_changes():
+            return True
+        return False
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_configuration(self):
+        return self._db_configuration
+    def __set_db_configuration(self, configuration):
+        self._db_configuration = configuration
+        self.is_dirty = True
+    db_configuration = property(__get_db_configuration, __set_db_configuration)
+    def db_add_configuration(self, configuration):
+        self._db_configuration = configuration
+    def db_change_configuration(self, configuration):
+        self._db_configuration = configuration
+    def db_delete_configuration(self, configuration):
+        if not self.is_new:
+            self.db_deleted_configuration.append(self._db_configuration)
+        self._db_configuration = None
+    
+    def __get_db_enabled_packages(self):
+        return self._db_enabled_packages
+    def __set_db_enabled_packages(self, enabled_packages):
+        self._db_enabled_packages = enabled_packages
+        self.is_dirty = True
+    db_enabled_packages = property(__get_db_enabled_packages, __set_db_enabled_packages)
+    def db_add_enabled_packages(self, enabled_packages):
+        self._db_enabled_packages = enabled_packages
+    def db_change_enabled_packages(self, enabled_packages):
+        self._db_enabled_packages = enabled_packages
+    def db_delete_enabled_packages(self, enabled_packages):
+        if not self.is_new:
+            self.db_deleted_enabled_packages.append(self._db_enabled_packages)
+        self._db_enabled_packages = None
+    
+    def __get_db_disabled_packages(self):
+        return self._db_disabled_packages
+    def __set_db_disabled_packages(self, disabled_packages):
+        self._db_disabled_packages = disabled_packages
+        self.is_dirty = True
+    db_disabled_packages = property(__get_db_disabled_packages, __set_db_disabled_packages)
+    def db_add_disabled_packages(self, disabled_packages):
+        self._db_disabled_packages = disabled_packages
+    def db_change_disabled_packages(self, disabled_packages):
+        self._db_disabled_packages = disabled_packages
+    def db_delete_disabled_packages(self, disabled_packages):
+        if not self.is_new:
+            self.db_deleted_disabled_packages.append(self._db_disabled_packages)
+        self._db_disabled_packages = None
+    
+
+
+class DBModule(object):
+
+    vtType = 'module'
+
+    def __init__(self, id=None, cache=None, name=None, namespace=None, package=None, version=None, location=None, functions=None, annotations=None, controlParameters=None, portSpecs=None):
+        self._db_id = id
+        self._db_cache = cache
+        self._db_name = name
+        self._db_namespace = namespace
+        self._db_package = package
+        self._db_version = version
+        self.db_deleted_location = []
+        self._db_location = location
+        self.db_deleted_functions = []
+        self.db_functions_id_index = {}
+        if functions is None:
+            self._db_functions = []
+        else:
+            self._db_functions = functions
+            for v in self._db_functions:
+                self.db_functions_id_index[v.db_id] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.db_deleted_controlParameters = []
+        self.db_controlParameters_id_index = {}
+        self.db_controlParameters_name_index = {}
+        if controlParameters is None:
+            self._db_controlParameters = []
+        else:
+            self._db_controlParameters = controlParameters
+            for v in self._db_controlParameters:
+                self.db_controlParameters_id_index[v.db_id] = v
+                self.db_controlParameters_name_index[v.db_name] = v
+        self.db_deleted_portSpecs = []
+        self.db_portSpecs_id_index = {}
+        self.db_portSpecs_name_index = {}
+        if portSpecs is None:
+            self._db_portSpecs = []
+        else:
+            self._db_portSpecs = portSpecs
+            for v in self._db_portSpecs:
+                self.db_portSpecs_id_index[v.db_id] = v
+                self.db_portSpecs_name_index[(v.db_name,v.db_type)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBModule.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBModule(id=self._db_id,
+                      cache=self._db_cache,
+                      name=self._db_name,
+                      namespace=self._db_namespace,
+                      package=self._db_package,
+                      version=self._db_version)
+        if self._db_location is not None:
+            cp._db_location = self._db_location.do_copy(new_ids, id_scope, id_remap)
+        if self._db_functions is None:
+            cp._db_functions = []
+        else:
+            cp._db_functions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_functions]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_controlParameters is None:
+            cp._db_controlParameters = []
+        else:
+            cp._db_controlParameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_controlParameters]
+        if self._db_portSpecs is None:
+            cp._db_portSpecs = []
+        else:
+            cp._db_portSpecs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_portSpecs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_functions_id_index = dict((v.db_id, v) for v in cp._db_functions)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        cp.db_controlParameters_id_index = dict((v.db_id, v) for v in cp._db_controlParameters)
+        cp.db_controlParameters_name_index = dict((v.db_name, v) for v in cp._db_controlParameters)
+        cp.db_portSpecs_id_index = dict((v.db_id, v) for v in cp._db_portSpecs)
+        cp.db_portSpecs_name_index = dict(((v.db_name,v.db_type), v) for v in cp._db_portSpecs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBModule()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'cache' in class_dict:
+            res = class_dict['cache'](old_obj, trans_dict)
+            new_obj.db_cache = res
+        elif hasattr(old_obj, 'db_cache') and old_obj.db_cache is not None:
+            new_obj.db_cache = old_obj.db_cache
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'location' in class_dict:
+            res = class_dict['location'](old_obj, trans_dict)
+            new_obj.db_location = res
+        elif hasattr(old_obj, 'db_location') and old_obj.db_location is not None:
+            obj = old_obj.db_location
+            new_obj.db_add_location(DBLocation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_location') and hasattr(new_obj, 'db_deleted_location'):
+            for obj in old_obj.db_deleted_location:
+                n_obj = DBLocation.update_version(obj, trans_dict)
+                new_obj.db_deleted_location.append(n_obj)
+        if 'functions' in class_dict:
+            res = class_dict['functions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_function(obj)
+        elif hasattr(old_obj, 'db_functions') and old_obj.db_functions is not None:
+            for obj in old_obj.db_functions:
+                new_obj.db_add_function(DBFunction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_functions') and hasattr(new_obj, 'db_deleted_functions'):
+            for obj in old_obj.db_deleted_functions:
+                n_obj = DBFunction.update_version(obj, trans_dict)
+                new_obj.db_deleted_functions.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'controlParameters' in class_dict:
+            res = class_dict['controlParameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_controlParameter(obj)
+        elif hasattr(old_obj, 'db_controlParameters') and old_obj.db_controlParameters is not None:
+            for obj in old_obj.db_controlParameters:
+                new_obj.db_add_controlParameter(DBControlParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_controlParameters') and hasattr(new_obj, 'db_deleted_controlParameters'):
+            for obj in old_obj.db_deleted_controlParameters:
+                n_obj = DBControlParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_controlParameters.append(n_obj)
+        if 'portSpecs' in class_dict:
+            res = class_dict['portSpecs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_portSpec(obj)
+        elif hasattr(old_obj, 'db_portSpecs') and old_obj.db_portSpecs is not None:
+            for obj in old_obj.db_portSpecs:
+                new_obj.db_add_portSpec(DBPortSpec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_portSpecs') and hasattr(new_obj, 'db_deleted_portSpecs'):
+            for obj in old_obj.db_deleted_portSpecs:
+                n_obj = DBPortSpec.update_version(obj, trans_dict)
+                new_obj.db_deleted_portSpecs.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_location is not None:
+            children.extend(self._db_location.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_location = None
+        to_del = []
+        for child in self.db_functions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_function(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_controlParameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_controlParameter(child)
+        to_del = []
+        for child in self.db_portSpecs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_portSpec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_location)
+        children.extend(self.db_deleted_functions)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_controlParameters)
+        children.extend(self.db_deleted_portSpecs)
+        if remove:
+            self.db_deleted_location = []
+            self.db_deleted_functions = []
+            self.db_deleted_annotations = []
+            self.db_deleted_controlParameters = []
+            self.db_deleted_portSpecs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_location is not None and self._db_location.has_changes():
+            return True
+        for child in self._db_functions:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_controlParameters:
+            if child.has_changes():
+                return True
+        for child in self._db_portSpecs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_cache(self):
+        return self._db_cache
+    def __set_db_cache(self, cache):
+        self._db_cache = cache
+        self.is_dirty = True
+    db_cache = property(__get_db_cache, __set_db_cache)
+    def db_add_cache(self, cache):
+        self._db_cache = cache
+    def db_change_cache(self, cache):
+        self._db_cache = cache
+    def db_delete_cache(self, cache):
+        self._db_cache = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_location(self):
+        return self._db_location
+    def __set_db_location(self, location):
+        self._db_location = location
+        self.is_dirty = True
+    db_location = property(__get_db_location, __set_db_location)
+    def db_add_location(self, location):
+        self._db_location = location
+    def db_change_location(self, location):
+        self._db_location = location
+    def db_delete_location(self, location):
+        if not self.is_new:
+            self.db_deleted_location.append(self._db_location)
+        self._db_location = None
+    
+    def __get_db_functions(self):
+        return self._db_functions
+    def __set_db_functions(self, functions):
+        self._db_functions = functions
+        self.is_dirty = True
+    db_functions = property(__get_db_functions, __set_db_functions)
+    def db_get_functions(self):
+        return self._db_functions
+    def db_add_function(self, function):
+        self.is_dirty = True
+        self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_change_function(self, function):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                self._db_functions[i] = function
+                found = True
+                break
+        if not found:
+            self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_delete_function(self, function):
+        self.is_dirty = True
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                if not self._db_functions[i].is_new:
+                    self.db_deleted_functions.append(self._db_functions[i])
+                del self._db_functions[i]
+                break
+        del self.db_functions_id_index[function.db_id]
+    def db_get_function(self, key):
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == key:
+                return self._db_functions[i]
+        return None
+    def db_get_function_by_id(self, key):
+        return self.db_functions_id_index[key]
+    def db_has_function_with_id(self, key):
+        return key in self.db_functions_id_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def __get_db_controlParameters(self):
+        return self._db_controlParameters
+    def __set_db_controlParameters(self, controlParameters):
+        self._db_controlParameters = controlParameters
+        self.is_dirty = True
+    db_controlParameters = property(__get_db_controlParameters, __set_db_controlParameters)
+    def db_get_controlParameters(self):
+        return self._db_controlParameters
+    def db_add_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_change_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                self._db_controlParameters[i] = controlParameter
+                found = True
+                break
+        if not found:
+            self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_delete_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                if not self._db_controlParameters[i].is_new:
+                    self.db_deleted_controlParameters.append(self._db_controlParameters[i])
+                del self._db_controlParameters[i]
+                break
+        del self.db_controlParameters_id_index[controlParameter.db_id]
+        del self.db_controlParameters_name_index[controlParameter.db_name]
+    def db_get_controlParameter(self, key):
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == key:
+                return self._db_controlParameters[i]
+        return None
+    def db_get_controlParameter_by_id(self, key):
+        return self.db_controlParameters_id_index[key]
+    def db_has_controlParameter_with_id(self, key):
+        return key in self.db_controlParameters_id_index
+    def db_get_controlParameter_by_name(self, key):
+        return self.db_controlParameters_name_index[key]
+    def db_has_controlParameter_with_name(self, key):
+        return key in self.db_controlParameters_name_index
+    
+    def __get_db_portSpecs(self):
+        return self._db_portSpecs
+    def __set_db_portSpecs(self, portSpecs):
+        self._db_portSpecs = portSpecs
+        self.is_dirty = True
+    db_portSpecs = property(__get_db_portSpecs, __set_db_portSpecs)
+    def db_get_portSpecs(self):
+        return self._db_portSpecs
+    def db_add_portSpec(self, portSpec):
+        self.is_dirty = True
+        self._db_portSpecs.append(portSpec)
+        self.db_portSpecs_id_index[portSpec.db_id] = portSpec
+        self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)] = portSpec
+    def db_change_portSpec(self, portSpec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == portSpec.db_id:
+                self._db_portSpecs[i] = portSpec
+                found = True
+                break
+        if not found:
+            self._db_portSpecs.append(portSpec)
+        self.db_portSpecs_id_index[portSpec.db_id] = portSpec
+        self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)] = portSpec
+    def db_delete_portSpec(self, portSpec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == portSpec.db_id:
+                if not self._db_portSpecs[i].is_new:
+                    self.db_deleted_portSpecs.append(self._db_portSpecs[i])
+                del self._db_portSpecs[i]
+                break
+        del self.db_portSpecs_id_index[portSpec.db_id]
+        del self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)]
+    def db_get_portSpec(self, key):
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == key:
+                return self._db_portSpecs[i]
+        return None
+    def db_get_portSpec_by_id(self, key):
+        return self.db_portSpecs_id_index[key]
+    def db_has_portSpec_with_id(self, key):
+        return key in self.db_portSpecs_id_index
+    def db_get_portSpec_by_name(self, key):
+        return self.db_portSpecs_name_index[key]
+    def db_has_portSpec_with_name(self, key):
+        return key in self.db_portSpecs_name_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBPort(object):
+
+    vtType = 'port'
+
+    def __init__(self, id=None, type=None, moduleId=None, moduleName=None, name=None, signature=None):
+        self._db_id = id
+        self._db_type = type
+        self._db_moduleId = moduleId
+        self._db_moduleName = moduleName
+        self._db_name = name
+        self._db_signature = signature
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPort.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPort(id=self._db_id,
+                    type=self._db_type,
+                    moduleId=self._db_moduleId,
+                    moduleName=self._db_moduleName,
+                    name=self._db_name,
+                    signature=self._db_signature)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_moduleId') and ('module', self._db_moduleId) in id_remap:
+                cp._db_moduleId = id_remap[('module', self._db_moduleId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPort()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'type' in class_dict:
+            res = class_dict['type'](old_obj, trans_dict)
+            new_obj.db_type = res
+        elif hasattr(old_obj, 'db_type') and old_obj.db_type is not None:
+            new_obj.db_type = old_obj.db_type
+        if 'moduleId' in class_dict:
+            res = class_dict['moduleId'](old_obj, trans_dict)
+            new_obj.db_moduleId = res
+        elif hasattr(old_obj, 'db_moduleId') and old_obj.db_moduleId is not None:
+            new_obj.db_moduleId = old_obj.db_moduleId
+        if 'moduleName' in class_dict:
+            res = class_dict['moduleName'](old_obj, trans_dict)
+            new_obj.db_moduleName = res
+        elif hasattr(old_obj, 'db_moduleName') and old_obj.db_moduleName is not None:
+            new_obj.db_moduleName = old_obj.db_moduleName
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'signature' in class_dict:
+            res = class_dict['signature'](old_obj, trans_dict)
+            new_obj.db_signature = res
+        elif hasattr(old_obj, 'db_signature') and old_obj.db_signature is not None:
+            new_obj.db_signature = old_obj.db_signature
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_type(self):
+        return self._db_type
+    def __set_db_type(self, type):
+        self._db_type = type
+        self.is_dirty = True
+    db_type = property(__get_db_type, __set_db_type)
+    def db_add_type(self, type):
+        self._db_type = type
+    def db_change_type(self, type):
+        self._db_type = type
+    def db_delete_type(self, type):
+        self._db_type = None
+    
+    def __get_db_moduleId(self):
+        return self._db_moduleId
+    def __set_db_moduleId(self, moduleId):
+        self._db_moduleId = moduleId
+        self.is_dirty = True
+    db_moduleId = property(__get_db_moduleId, __set_db_moduleId)
+    def db_add_moduleId(self, moduleId):
+        self._db_moduleId = moduleId
+    def db_change_moduleId(self, moduleId):
+        self._db_moduleId = moduleId
+    def db_delete_moduleId(self, moduleId):
+        self._db_moduleId = None
+    
+    def __get_db_moduleName(self):
+        return self._db_moduleName
+    def __set_db_moduleName(self, moduleName):
+        self._db_moduleName = moduleName
+        self.is_dirty = True
+    db_moduleName = property(__get_db_moduleName, __set_db_moduleName)
+    def db_add_moduleName(self, moduleName):
+        self._db_moduleName = moduleName
+    def db_change_moduleName(self, moduleName):
+        self._db_moduleName = moduleName
+    def db_delete_moduleName(self, moduleName):
+        self._db_moduleName = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_signature(self):
+        return self._db_signature
+    def __set_db_signature(self, signature):
+        self._db_signature = signature
+        self.is_dirty = True
+    db_signature = property(__get_db_signature, __set_db_signature)
+    def db_add_signature(self, signature):
+        self._db_signature = signature
+    def db_change_signature(self, signature):
+        self._db_signature = signature
+    def db_delete_signature(self, signature):
+        self._db_signature = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmAgents(object):
+
+    vtType = 'opm_agents'
+
+    def __init__(self, agents=None):
+        self.db_deleted_agents = []
+        self.db_agents_id_index = {}
+        if agents is None:
+            self._db_agents = []
+        else:
+            self._db_agents = agents
+            for v in self._db_agents:
+                self.db_agents_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAgents.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAgents()
+        if self._db_agents is None:
+            cp._db_agents = []
+        else:
+            cp._db_agents = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_agents]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_agents_id_index = dict((v.db_id, v) for v in cp._db_agents)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAgents()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'agents' in class_dict:
+            res = class_dict['agents'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_agent(obj)
+        elif hasattr(old_obj, 'db_agents') and old_obj.db_agents is not None:
+            for obj in old_obj.db_agents:
+                new_obj.db_add_agent(DBOpmAgent.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_agents') and hasattr(new_obj, 'db_deleted_agents'):
+            for obj in old_obj.db_deleted_agents:
+                n_obj = DBOpmAgent.update_version(obj, trans_dict)
+                new_obj.db_deleted_agents.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_agents:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_agent(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_agents)
+        if remove:
+            self.db_deleted_agents = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_agents:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_agents(self):
+        return self._db_agents
+    def __set_db_agents(self, agents):
+        self._db_agents = agents
+        self.is_dirty = True
+    db_agents = property(__get_db_agents, __set_db_agents)
+    def db_get_agents(self):
+        return self._db_agents
+    def db_add_agent(self, agent):
+        self.is_dirty = True
+        self._db_agents.append(agent)
+        self.db_agents_id_index[agent.db_id] = agent
+    def db_change_agent(self, agent):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_agents)):
+            if self._db_agents[i].db_id == agent.db_id:
+                self._db_agents[i] = agent
+                found = True
+                break
+        if not found:
+            self._db_agents.append(agent)
+        self.db_agents_id_index[agent.db_id] = agent
+    def db_delete_agent(self, agent):
+        self.is_dirty = True
+        for i in xrange(len(self._db_agents)):
+            if self._db_agents[i].db_id == agent.db_id:
+                if not self._db_agents[i].is_new:
+                    self.db_deleted_agents.append(self._db_agents[i])
+                del self._db_agents[i]
+                break
+        del self.db_agents_id_index[agent.db_id]
+    def db_get_agent(self, key):
+        for i in xrange(len(self._db_agents)):
+            if self._db_agents[i].db_id == key:
+                return self._db_agents[i]
+        return None
+    def db_get_agent_by_id(self, key):
+        return self.db_agents_id_index[key]
+    def db_has_agent_with_id(self, key):
+        return key in self.db_agents_id_index
+    
+
+
+class DBOpmDependencies(object):
+
+    vtType = 'opm_dependencies'
+
+    def __init__(self, dependencys=None):
+        self.db_deleted_dependencys = []
+        if dependencys is None:
+            self._db_dependencys = []
+        else:
+            self._db_dependencys = dependencys
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmDependencies.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmDependencies()
+        if self._db_dependencys is None:
+            cp._db_dependencys = []
+        else:
+            cp._db_dependencys = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_dependencys]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmDependencies()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'dependencys' in class_dict:
+            res = class_dict['dependencys'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_dependency(obj)
+        elif hasattr(old_obj, 'db_dependencys') and old_obj.db_dependencys is not None:
+            for obj in old_obj.db_dependencys:
+                if obj.vtType == 'opm_used':
+                    new_obj.db_add_dependency(DBOpmUsed.update_version(obj, trans_dict))
+                elif obj.vtType == 'opm_was_generated_by':
+                    new_obj.db_add_dependency(DBOpmWasGeneratedBy.update_version(obj, trans_dict))
+                elif obj.vtType == 'opm_was_triggered_by':
+                    new_obj.db_add_dependency(DBOpmWasTriggeredBy.update_version(obj, trans_dict))
+                elif obj.vtType == 'opm_was_derived_from':
+                    new_obj.db_add_dependency(DBOpmWasDerivedFrom.update_version(obj, trans_dict))
+                elif obj.vtType == 'opm_was_controlled_by':
+                    new_obj.db_add_dependency(DBOpmWasControlledBy.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_dependencys') and hasattr(new_obj, 'db_deleted_dependencys'):
+            for obj in old_obj.db_deleted_dependencys:
+                if obj.vtType == 'opm_used':
+                    n_obj = DBOpmUsed.update_version(obj, trans_dict)
+                    new_obj.db_deleted_dependencys.append(n_obj)
+                elif obj.vtType == 'opm_was_generated_by':
+                    n_obj = DBOpmWasGeneratedBy.update_version(obj, trans_dict)
+                    new_obj.db_deleted_dependencys.append(n_obj)
+                elif obj.vtType == 'opm_was_triggered_by':
+                    n_obj = DBOpmWasTriggeredBy.update_version(obj, trans_dict)
+                    new_obj.db_deleted_dependencys.append(n_obj)
+                elif obj.vtType == 'opm_was_derived_from':
+                    n_obj = DBOpmWasDerivedFrom.update_version(obj, trans_dict)
+                    new_obj.db_deleted_dependencys.append(n_obj)
+                elif obj.vtType == 'opm_was_controlled_by':
+                    n_obj = DBOpmWasControlledBy.update_version(obj, trans_dict)
+                    new_obj.db_deleted_dependencys.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_dependencys:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_dependency(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_dependencys)
+        if remove:
+            self.db_deleted_dependencys = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_dependencys:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_dependencys(self):
+        return self._db_dependencys
+    def __set_db_dependencys(self, dependencys):
+        self._db_dependencys = dependencys
+        self.is_dirty = True
+    db_dependencys = property(__get_db_dependencys, __set_db_dependencys)
+    def db_get_dependencys(self):
+        return self._db_dependencys
+    def db_add_dependency(self, dependency):
+        self.is_dirty = True
+        self._db_dependencys.append(dependency)
+    def db_change_dependency(self, dependency):
+        self.is_dirty = True
+        self._db_dependencys.append(dependency)
+    def db_delete_dependency(self, dependency):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_dependency(self, key):
+        return None
+    
+
+
+class DBPEFunction(object):
+
+    vtType = 'pe_function'
+
+    def __init__(self, id=None, module_id=None, port_name=None, is_alias=None, parameters=None):
+        self._db_id = id
+        self._db_module_id = module_id
+        self._db_port_name = port_name
+        self._db_is_alias = is_alias
+        self.db_deleted_parameters = []
+        self.db_parameters_id_index = {}
+        if parameters is None:
+            self._db_parameters = []
+        else:
+            self._db_parameters = parameters
+            for v in self._db_parameters:
+                self.db_parameters_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPEFunction.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPEFunction(id=self._db_id,
+                          module_id=self._db_module_id,
+                          port_name=self._db_port_name,
+                          is_alias=self._db_is_alias)
+        if self._db_parameters is None:
+            cp._db_parameters = []
+        else:
+            cp._db_parameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_parameters]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_module_id') and ('module', self._db_module_id) in id_remap:
+                cp._db_module_id = id_remap[('module', self._db_module_id)]
+        
+        # recreate indices and set flags
+        cp.db_parameters_id_index = dict((v.db_id, v) for v in cp._db_parameters)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPEFunction()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'module_id' in class_dict:
+            res = class_dict['module_id'](old_obj, trans_dict)
+            new_obj.db_module_id = res
+        elif hasattr(old_obj, 'db_module_id') and old_obj.db_module_id is not None:
+            new_obj.db_module_id = old_obj.db_module_id
+        if 'port_name' in class_dict:
+            res = class_dict['port_name'](old_obj, trans_dict)
+            new_obj.db_port_name = res
+        elif hasattr(old_obj, 'db_port_name') and old_obj.db_port_name is not None:
+            new_obj.db_port_name = old_obj.db_port_name
+        if 'is_alias' in class_dict:
+            res = class_dict['is_alias'](old_obj, trans_dict)
+            new_obj.db_is_alias = res
+        elif hasattr(old_obj, 'db_is_alias') and old_obj.db_is_alias is not None:
+            new_obj.db_is_alias = old_obj.db_is_alias
+        if 'parameters' in class_dict:
+            res = class_dict['parameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_parameter(obj)
+        elif hasattr(old_obj, 'db_parameters') and old_obj.db_parameters is not None:
+            for obj in old_obj.db_parameters:
+                new_obj.db_add_parameter(DBPEParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_parameters') and hasattr(new_obj, 'db_deleted_parameters'):
+            for obj in old_obj.db_deleted_parameters:
+                n_obj = DBPEParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_parameters.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_parameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_parameter(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_parameters)
+        if remove:
+            self.db_deleted_parameters = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_parameters:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_module_id(self):
+        return self._db_module_id
+    def __set_db_module_id(self, module_id):
+        self._db_module_id = module_id
+        self.is_dirty = True
+    db_module_id = property(__get_db_module_id, __set_db_module_id)
+    def db_add_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_change_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_delete_module_id(self, module_id):
+        self._db_module_id = None
+    
+    def __get_db_port_name(self):
+        return self._db_port_name
+    def __set_db_port_name(self, port_name):
+        self._db_port_name = port_name
+        self.is_dirty = True
+    db_port_name = property(__get_db_port_name, __set_db_port_name)
+    def db_add_port_name(self, port_name):
+        self._db_port_name = port_name
+    def db_change_port_name(self, port_name):
+        self._db_port_name = port_name
+    def db_delete_port_name(self, port_name):
+        self._db_port_name = None
+    
+    def __get_db_is_alias(self):
+        return self._db_is_alias
+    def __set_db_is_alias(self, is_alias):
+        self._db_is_alias = is_alias
+        self.is_dirty = True
+    db_is_alias = property(__get_db_is_alias, __set_db_is_alias)
+    def db_add_is_alias(self, is_alias):
+        self._db_is_alias = is_alias
+    def db_change_is_alias(self, is_alias):
+        self._db_is_alias = is_alias
+    def db_delete_is_alias(self, is_alias):
+        self._db_is_alias = None
+    
+    def __get_db_parameters(self):
+        return self._db_parameters
+    def __set_db_parameters(self, parameters):
+        self._db_parameters = parameters
+        self.is_dirty = True
+    db_parameters = property(__get_db_parameters, __set_db_parameters)
+    def db_get_parameters(self):
+        return self._db_parameters
+    def db_add_parameter(self, parameter):
+        self.is_dirty = True
+        self._db_parameters.append(parameter)
+        self.db_parameters_id_index[parameter.db_id] = parameter
+    def db_change_parameter(self, parameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == parameter.db_id:
+                self._db_parameters[i] = parameter
+                found = True
+                break
+        if not found:
+            self._db_parameters.append(parameter)
+        self.db_parameters_id_index[parameter.db_id] = parameter
+    def db_delete_parameter(self, parameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == parameter.db_id:
+                if not self._db_parameters[i].is_new:
+                    self.db_deleted_parameters.append(self._db_parameters[i])
+                del self._db_parameters[i]
+                break
+        del self.db_parameters_id_index[parameter.db_id]
+    def db_get_parameter(self, key):
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == key:
+                return self._db_parameters[i]
+        return None
+    def db_get_parameter_by_id(self, key):
+        return self.db_parameters_id_index[key]
+    def db_has_parameter_with_id(self, key):
+        return key in self.db_parameters_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBWorkflow(object):
+
+    vtType = 'workflow'
+
+    def __init__(self, modules=None, id=None, entity_type=None, name=None, version=None, last_modified=None, connections=None, annotations=None, plugin_datas=None, others=None, vistrail_id=None):
+        self.db_deleted_modules = []
+        self.db_modules_id_index = {}
+        if modules is None:
+            self._db_modules = []
+        else:
+            self._db_modules = modules
+            for v in self._db_modules:
+                self.db_modules_id_index[v.db_id] = v
+        self._db_id = id
+        self._db_entity_type = entity_type
+        self._db_name = name
+        self._db_version = version
+        self._db_last_modified = last_modified
+        self.db_deleted_connections = []
+        self.db_connections_id_index = {}
+        if connections is None:
+            self._db_connections = []
+        else:
+            self._db_connections = connections
+            for v in self._db_connections:
+                self.db_connections_id_index[v.db_id] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+        self.db_deleted_plugin_datas = []
+        self.db_plugin_datas_id_index = {}
+        if plugin_datas is None:
+            self._db_plugin_datas = []
+        else:
+            self._db_plugin_datas = plugin_datas
+            for v in self._db_plugin_datas:
+                self.db_plugin_datas_id_index[v.db_id] = v
+        self.db_deleted_others = []
+        self.db_others_id_index = {}
+        if others is None:
+            self._db_others = []
+        else:
+            self._db_others = others
+            for v in self._db_others:
+                self.db_others_id_index[v.db_id] = v
+        self._db_vistrail_id = vistrail_id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBWorkflow.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBWorkflow(id=self._db_id,
+                        entity_type=self._db_entity_type,
+                        name=self._db_name,
+                        version=self._db_version,
+                        last_modified=self._db_last_modified,
+                        vistrail_id=self._db_vistrail_id)
+        if self._db_modules is None:
+            cp._db_modules = []
+        else:
+            cp._db_modules = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_modules]
+        if self._db_connections is None:
+            cp._db_connections = []
+        else:
+            cp._db_connections = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_connections]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_plugin_datas is None:
+            cp._db_plugin_datas = []
+        else:
+            cp._db_plugin_datas = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_plugin_datas]
+        if self._db_others is None:
+            cp._db_others = []
+        else:
+            cp._db_others = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_others]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_vistrail_id') and ('vistrail', self._db_vistrail_id) in id_remap:
+                cp._db_vistrail_id = id_remap[('vistrail', self._db_vistrail_id)]
+        
+        # recreate indices and set flags
+        cp.db_modules_id_index = dict((v.db_id, v) for v in cp._db_modules)
+        cp.db_connections_id_index = dict((v.db_id, v) for v in cp._db_connections)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_plugin_datas_id_index = dict((v.db_id, v) for v in cp._db_plugin_datas)
+        cp.db_others_id_index = dict((v.db_id, v) for v in cp._db_others)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBWorkflow()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'modules' in class_dict:
+            res = class_dict['modules'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_module(obj)
+        elif hasattr(old_obj, 'db_modules') and old_obj.db_modules is not None:
+            for obj in old_obj.db_modules:
+                if obj.vtType == 'module':
+                    new_obj.db_add_module(DBModule.update_version(obj, trans_dict))
+                elif obj.vtType == 'abstraction':
+                    new_obj.db_add_module(DBAbstraction.update_version(obj, trans_dict))
+                elif obj.vtType == 'group':
+                    new_obj.db_add_module(DBGroup.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_modules') and hasattr(new_obj, 'db_deleted_modules'):
+            for obj in old_obj.db_deleted_modules:
+                if obj.vtType == 'module':
+                    n_obj = DBModule.update_version(obj, trans_dict)
+                    new_obj.db_deleted_modules.append(n_obj)
+                elif obj.vtType == 'abstraction':
+                    n_obj = DBAbstraction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_modules.append(n_obj)
+                elif obj.vtType == 'group':
+                    n_obj = DBGroup.update_version(obj, trans_dict)
+                    new_obj.db_deleted_modules.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'entity_type' in class_dict:
+            res = class_dict['entity_type'](old_obj, trans_dict)
+            new_obj.db_entity_type = res
+        elif hasattr(old_obj, 'db_entity_type') and old_obj.db_entity_type is not None:
+            new_obj.db_entity_type = old_obj.db_entity_type
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'last_modified' in class_dict:
+            res = class_dict['last_modified'](old_obj, trans_dict)
+            new_obj.db_last_modified = res
+        elif hasattr(old_obj, 'db_last_modified') and old_obj.db_last_modified is not None:
+            new_obj.db_last_modified = old_obj.db_last_modified
+        if 'connections' in class_dict:
+            res = class_dict['connections'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_connection(obj)
+        elif hasattr(old_obj, 'db_connections') and old_obj.db_connections is not None:
+            for obj in old_obj.db_connections:
+                new_obj.db_add_connection(DBConnection.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_connections') and hasattr(new_obj, 'db_deleted_connections'):
+            for obj in old_obj.db_deleted_connections:
+                n_obj = DBConnection.update_version(obj, trans_dict)
+                new_obj.db_deleted_connections.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'plugin_datas' in class_dict:
+            res = class_dict['plugin_datas'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_plugin_data(obj)
+        elif hasattr(old_obj, 'db_plugin_datas') and old_obj.db_plugin_datas is not None:
+            for obj in old_obj.db_plugin_datas:
+                new_obj.db_add_plugin_data(DBPluginData.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_plugin_datas') and hasattr(new_obj, 'db_deleted_plugin_datas'):
+            for obj in old_obj.db_deleted_plugin_datas:
+                n_obj = DBPluginData.update_version(obj, trans_dict)
+                new_obj.db_deleted_plugin_datas.append(n_obj)
+        if 'others' in class_dict:
+            res = class_dict['others'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_other(obj)
+        elif hasattr(old_obj, 'db_others') and old_obj.db_others is not None:
+            for obj in old_obj.db_others:
+                new_obj.db_add_other(DBOther.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_others') and hasattr(new_obj, 'db_deleted_others'):
+            for obj in old_obj.db_deleted_others:
+                n_obj = DBOther.update_version(obj, trans_dict)
+                new_obj.db_deleted_others.append(n_obj)
+        if 'vistrail_id' in class_dict:
+            res = class_dict['vistrail_id'](old_obj, trans_dict)
+            new_obj.db_vistrail_id = res
+        elif hasattr(old_obj, 'db_vistrail_id') and old_obj.db_vistrail_id is not None:
+            new_obj.db_vistrail_id = old_obj.db_vistrail_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_connections:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_connection(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_plugin_datas:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_plugin_data(child)
+        to_del = []
+        for child in self.db_others:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_other(child)
+        to_del = []
+        for child in self.db_modules:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_module(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_connections)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_plugin_datas)
+        children.extend(self.db_deleted_others)
+        children.extend(self.db_deleted_modules)
+        if remove:
+            self.db_deleted_connections = []
+            self.db_deleted_annotations = []
+            self.db_deleted_plugin_datas = []
+            self.db_deleted_others = []
+            self.db_deleted_modules = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_connections:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_plugin_datas:
+            if child.has_changes():
+                return True
+        for child in self._db_others:
+            if child.has_changes():
+                return True
+        for child in self._db_modules:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_modules(self):
+        return self._db_modules
+    def __set_db_modules(self, modules):
+        self._db_modules = modules
+        self.is_dirty = True
+    db_modules = property(__get_db_modules, __set_db_modules)
+    def db_get_modules(self):
+        return self._db_modules
+    def db_add_module(self, module):
+        self.is_dirty = True
+        self._db_modules.append(module)
+        self.db_modules_id_index[module.db_id] = module
+    def db_change_module(self, module):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_modules)):
+            if self._db_modules[i].db_id == module.db_id:
+                self._db_modules[i] = module
+                found = True
+                break
+        if not found:
+            self._db_modules.append(module)
+        self.db_modules_id_index[module.db_id] = module
+    def db_delete_module(self, module):
+        self.is_dirty = True
+        for i in xrange(len(self._db_modules)):
+            if self._db_modules[i].db_id == module.db_id:
+                if not self._db_modules[i].is_new:
+                    self.db_deleted_modules.append(self._db_modules[i])
+                del self._db_modules[i]
+                break
+        del self.db_modules_id_index[module.db_id]
+    def db_get_module(self, key):
+        for i in xrange(len(self._db_modules)):
+            if self._db_modules[i].db_id == key:
+                return self._db_modules[i]
+        return None
+    def db_get_module_by_id(self, key):
+        return self.db_modules_id_index[key]
+    def db_has_module_with_id(self, key):
+        return key in self.db_modules_id_index
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_entity_type(self):
+        return self._db_entity_type
+    def __set_db_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+        self.is_dirty = True
+    db_entity_type = property(__get_db_entity_type, __set_db_entity_type)
+    def db_add_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_change_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_delete_entity_type(self, entity_type):
+        self._db_entity_type = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_last_modified(self):
+        return self._db_last_modified
+    def __set_db_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+        self.is_dirty = True
+    db_last_modified = property(__get_db_last_modified, __set_db_last_modified)
+    def db_add_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_change_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_delete_last_modified(self, last_modified):
+        self._db_last_modified = None
+    
+    def __get_db_connections(self):
+        return self._db_connections
+    def __set_db_connections(self, connections):
+        self._db_connections = connections
+        self.is_dirty = True
+    db_connections = property(__get_db_connections, __set_db_connections)
+    def db_get_connections(self):
+        return self._db_connections
+    def db_add_connection(self, connection):
+        self.is_dirty = True
+        self._db_connections.append(connection)
+        self.db_connections_id_index[connection.db_id] = connection
+    def db_change_connection(self, connection):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_connections)):
+            if self._db_connections[i].db_id == connection.db_id:
+                self._db_connections[i] = connection
+                found = True
+                break
+        if not found:
+            self._db_connections.append(connection)
+        self.db_connections_id_index[connection.db_id] = connection
+    def db_delete_connection(self, connection):
+        self.is_dirty = True
+        for i in xrange(len(self._db_connections)):
+            if self._db_connections[i].db_id == connection.db_id:
+                if not self._db_connections[i].is_new:
+                    self.db_deleted_connections.append(self._db_connections[i])
+                del self._db_connections[i]
+                break
+        del self.db_connections_id_index[connection.db_id]
+    def db_get_connection(self, key):
+        for i in xrange(len(self._db_connections)):
+            if self._db_connections[i].db_id == key:
+                return self._db_connections[i]
+        return None
+    def db_get_connection_by_id(self, key):
+        return self.db_connections_id_index[key]
+    def db_has_connection_with_id(self, key):
+        return key in self.db_connections_id_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    
+    def __get_db_plugin_datas(self):
+        return self._db_plugin_datas
+    def __set_db_plugin_datas(self, plugin_datas):
+        self._db_plugin_datas = plugin_datas
+        self.is_dirty = True
+    db_plugin_datas = property(__get_db_plugin_datas, __set_db_plugin_datas)
+    def db_get_plugin_datas(self):
+        return self._db_plugin_datas
+    def db_add_plugin_data(self, plugin_data):
+        self.is_dirty = True
+        self._db_plugin_datas.append(plugin_data)
+        self.db_plugin_datas_id_index[plugin_data.db_id] = plugin_data
+    def db_change_plugin_data(self, plugin_data):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_plugin_datas)):
+            if self._db_plugin_datas[i].db_id == plugin_data.db_id:
+                self._db_plugin_datas[i] = plugin_data
+                found = True
+                break
+        if not found:
+            self._db_plugin_datas.append(plugin_data)
+        self.db_plugin_datas_id_index[plugin_data.db_id] = plugin_data
+    def db_delete_plugin_data(self, plugin_data):
+        self.is_dirty = True
+        for i in xrange(len(self._db_plugin_datas)):
+            if self._db_plugin_datas[i].db_id == plugin_data.db_id:
+                if not self._db_plugin_datas[i].is_new:
+                    self.db_deleted_plugin_datas.append(self._db_plugin_datas[i])
+                del self._db_plugin_datas[i]
+                break
+        del self.db_plugin_datas_id_index[plugin_data.db_id]
+    def db_get_plugin_data(self, key):
+        for i in xrange(len(self._db_plugin_datas)):
+            if self._db_plugin_datas[i].db_id == key:
+                return self._db_plugin_datas[i]
+        return None
+    def db_get_plugin_data_by_id(self, key):
+        return self.db_plugin_datas_id_index[key]
+    def db_has_plugin_data_with_id(self, key):
+        return key in self.db_plugin_datas_id_index
+    
+    def __get_db_others(self):
+        return self._db_others
+    def __set_db_others(self, others):
+        self._db_others = others
+        self.is_dirty = True
+    db_others = property(__get_db_others, __set_db_others)
+    def db_get_others(self):
+        return self._db_others
+    def db_add_other(self, other):
+        self.is_dirty = True
+        self._db_others.append(other)
+        self.db_others_id_index[other.db_id] = other
+    def db_change_other(self, other):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_others)):
+            if self._db_others[i].db_id == other.db_id:
+                self._db_others[i] = other
+                found = True
+                break
+        if not found:
+            self._db_others.append(other)
+        self.db_others_id_index[other.db_id] = other
+    def db_delete_other(self, other):
+        self.is_dirty = True
+        for i in xrange(len(self._db_others)):
+            if self._db_others[i].db_id == other.db_id:
+                if not self._db_others[i].is_new:
+                    self.db_deleted_others.append(self._db_others[i])
+                del self._db_others[i]
+                break
+        del self.db_others_id_index[other.db_id]
+    def db_get_other(self, key):
+        for i in xrange(len(self._db_others)):
+            if self._db_others[i].db_id == key:
+                return self._db_others[i]
+        return None
+    def db_get_other_by_id(self, key):
+        return self.db_others_id_index[key]
+    def db_has_other_with_id(self, key):
+        return key in self.db_others_id_index
+    
+    def __get_db_vistrail_id(self):
+        return self._db_vistrail_id
+    def __set_db_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+        self.is_dirty = True
+    db_vistrail_id = property(__get_db_vistrail_id, __set_db_vistrail_id)
+    def db_add_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+    def db_change_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+    def db_delete_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMashupAction(object):
+
+    vtType = 'mashup_action'
+
+    def __init__(self, id=None, prevId=None, date=None, user=None, mashup=None):
+        self._db_id = id
+        self._db_prevId = prevId
+        self._db_date = date
+        self._db_user = user
+        self.db_deleted_mashup = []
+        self._db_mashup = mashup
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashupAction.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashupAction(id=self._db_id,
+                            prevId=self._db_prevId,
+                            date=self._db_date,
+                            user=self._db_user)
+        if self._db_mashup is not None:
+            cp._db_mashup = self._db_mashup.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prevId') and ('mashup_action', self._db_prevId) in id_remap:
+                cp._db_prevId = id_remap[('mashup_action', self._db_prevId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashupAction()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'prevId' in class_dict:
+            res = class_dict['prevId'](old_obj, trans_dict)
+            new_obj.db_prevId = res
+        elif hasattr(old_obj, 'db_prevId') and old_obj.db_prevId is not None:
+            new_obj.db_prevId = old_obj.db_prevId
+        if 'date' in class_dict:
+            res = class_dict['date'](old_obj, trans_dict)
+            new_obj.db_date = res
+        elif hasattr(old_obj, 'db_date') and old_obj.db_date is not None:
+            new_obj.db_date = old_obj.db_date
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        if 'mashup' in class_dict:
+            res = class_dict['mashup'](old_obj, trans_dict)
+            new_obj.db_mashup = res
+        elif hasattr(old_obj, 'db_mashup') and old_obj.db_mashup is not None:
+            obj = old_obj.db_mashup
+            new_obj.db_add_mashup(DBMashup.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_mashup') and hasattr(new_obj, 'db_deleted_mashup'):
+            for obj in old_obj.db_deleted_mashup:
+                n_obj = DBMashup.update_version(obj, trans_dict)
+                new_obj.db_deleted_mashup.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_mashup is not None:
+            children.extend(self._db_mashup.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_mashup = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_mashup)
+        if remove:
+            self.db_deleted_mashup = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_mashup is not None and self._db_mashup.has_changes():
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_prevId(self):
+        return self._db_prevId
+    def __set_db_prevId(self, prevId):
+        self._db_prevId = prevId
+        self.is_dirty = True
+    db_prevId = property(__get_db_prevId, __set_db_prevId)
+    def db_add_prevId(self, prevId):
+        self._db_prevId = prevId
+    def db_change_prevId(self, prevId):
+        self._db_prevId = prevId
+    def db_delete_prevId(self, prevId):
+        self._db_prevId = None
+    
+    def __get_db_date(self):
+        return self._db_date
+    def __set_db_date(self, date):
+        self._db_date = date
+        self.is_dirty = True
+    db_date = property(__get_db_date, __set_db_date)
+    def db_add_date(self, date):
+        self._db_date = date
+    def db_change_date(self, date):
+        self._db_date = date
+    def db_delete_date(self, date):
+        self._db_date = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def __get_db_mashup(self):
+        return self._db_mashup
+    def __set_db_mashup(self, mashup):
+        self._db_mashup = mashup
+        self.is_dirty = True
+    db_mashup = property(__get_db_mashup, __set_db_mashup)
+    def db_add_mashup(self, mashup):
+        self._db_mashup = mashup
+    def db_change_mashup(self, mashup):
+        self._db_mashup = mashup
+    def db_delete_mashup(self, mashup):
+        if not self.is_new:
+            self.db_deleted_mashup.append(self._db_mashup)
+        self._db_mashup = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBConfiguration(object):
+
+    vtType = 'configuration'
+
+    def __init__(self, config_keys=None):
+        self.db_deleted_config_keys = []
+        self.db_config_keys_name_index = {}
+        if config_keys is None:
+            self._db_config_keys = []
+        else:
+            self._db_config_keys = config_keys
+            for v in self._db_config_keys:
+                self.db_config_keys_name_index[v.db_name] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfiguration.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfiguration()
+        if self._db_config_keys is None:
+            cp._db_config_keys = []
+        else:
+            cp._db_config_keys = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_config_keys]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_config_keys_name_index = dict((v.db_name, v) for v in cp._db_config_keys)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfiguration()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'config_keys' in class_dict:
+            res = class_dict['config_keys'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_config_key(obj)
+        elif hasattr(old_obj, 'db_config_keys') and old_obj.db_config_keys is not None:
+            for obj in old_obj.db_config_keys:
+                new_obj.db_add_config_key(DBConfigKey.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_config_keys') and hasattr(new_obj, 'db_deleted_config_keys'):
+            for obj in old_obj.db_deleted_config_keys:
+                n_obj = DBConfigKey.update_version(obj, trans_dict)
+                new_obj.db_deleted_config_keys.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_config_keys:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_config_key(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_config_keys)
+        if remove:
+            self.db_deleted_config_keys = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_config_keys:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_config_keys(self):
+        return self._db_config_keys
+    def __set_db_config_keys(self, config_keys):
+        self._db_config_keys = config_keys
+        self.is_dirty = True
+    db_config_keys = property(__get_db_config_keys, __set_db_config_keys)
+    def db_get_config_keys(self):
+        return self._db_config_keys
+    def db_add_config_key(self, config_key):
+        self.is_dirty = True
+        self._db_config_keys.append(config_key)
+        self.db_config_keys_name_index[config_key.db_name] = config_key
+    def db_change_config_key(self, config_key):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_config_keys)):
+            if self._db_config_keys[i].db_name == config_key.db_name:
+                self._db_config_keys[i] = config_key
+                found = True
+                break
+        if not found:
+            self._db_config_keys.append(config_key)
+        self.db_config_keys_name_index[config_key.db_name] = config_key
+    def db_delete_config_key(self, config_key):
+        self.is_dirty = True
+        for i in xrange(len(self._db_config_keys)):
+            if self._db_config_keys[i].db_name == config_key.db_name:
+                if not self._db_config_keys[i].is_new:
+                    self.db_deleted_config_keys.append(self._db_config_keys[i])
+                del self._db_config_keys[i]
+                break
+        del self.db_config_keys_name_index[config_key.db_name]
+    def db_get_config_key(self, key):
+        for i in xrange(len(self._db_config_keys)):
+            if self._db_config_keys[i].db_name == key:
+                return self._db_config_keys[i]
+        return None
+    def db_get_config_key_by_name(self, key):
+        return self.db_config_keys_name_index[key]
+    def db_has_config_key_with_name(self, key):
+        return key in self.db_config_keys_name_index
+    
+
+
+class DBChange(object):
+
+    vtType = 'change'
+
+    def __init__(self, data=None, id=None, what=None, oldObjId=None, newObjId=None, parentObjId=None, parentObjType=None):
+        self.db_deleted_data = []
+        self._db_data = data
+        self._db_id = id
+        self._db_what = what
+        self._db_oldObjId = oldObjId
+        self._db_newObjId = newObjId
+        self._db_parentObjId = parentObjId
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBChange.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBChange(id=self._db_id,
+                      what=self._db_what,
+                      oldObjId=self._db_oldObjId,
+                      newObjId=self._db_newObjId,
+                      parentObjId=self._db_parentObjId,
+                      parentObjType=self._db_parentObjType)
+        if self._db_data is not None:
+            cp._db_data = self._db_data.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_oldObjId') and (self._db_what, self._db_oldObjId) in id_remap:
+                cp._db_oldObjId = id_remap[(self._db_what, self._db_oldObjId)]
+            if hasattr(self, 'db_newObjId') and (self._db_what, self._db_newObjId) in id_remap:
+                cp._db_newObjId = id_remap[(self._db_what, self._db_newObjId)]
+            if hasattr(self, 'db_parentObjId') and (self._db_parentObjType, self._db_parentObjId) in id_remap:
+                cp._db_parentObjId = id_remap[(self._db_parentObjType, self._db_parentObjId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBChange()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'data' in class_dict:
+            res = class_dict['data'](old_obj, trans_dict)
+            new_obj.db_data = res
+        elif hasattr(old_obj, 'db_data') and old_obj.db_data is not None:
+            obj = old_obj.db_data
+            if obj.vtType == 'module':
+                new_obj.db_add_data(DBModule.update_version(obj, trans_dict))
+            elif obj.vtType == 'location':
+                new_obj.db_add_data(DBLocation.update_version(obj, trans_dict))
+            elif obj.vtType == 'annotation':
+                new_obj.db_add_data(DBAnnotation.update_version(obj, trans_dict))
+            elif obj.vtType == 'controlParameter':
+                new_obj.db_add_data(DBControlParameter.update_version(obj, trans_dict))
+            elif obj.vtType == 'function':
+                new_obj.db_add_data(DBFunction.update_version(obj, trans_dict))
+            elif obj.vtType == 'connection':
+                new_obj.db_add_data(DBConnection.update_version(obj, trans_dict))
+            elif obj.vtType == 'port':
+                new_obj.db_add_data(DBPort.update_version(obj, trans_dict))
+            elif obj.vtType == 'parameter':
+                new_obj.db_add_data(DBParameter.update_version(obj, trans_dict))
+            elif obj.vtType == 'portSpec':
+                new_obj.db_add_data(DBPortSpec.update_version(obj, trans_dict))
+            elif obj.vtType == 'abstraction':
+                new_obj.db_add_data(DBAbstraction.update_version(obj, trans_dict))
+            elif obj.vtType == 'group':
+                new_obj.db_add_data(DBGroup.update_version(obj, trans_dict))
+            elif obj.vtType == 'other':
+                new_obj.db_add_data(DBOther.update_version(obj, trans_dict))
+            elif obj.vtType == 'plugin_data':
+                new_obj.db_add_data(DBPluginData.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_data') and hasattr(new_obj, 'db_deleted_data'):
+            for obj in old_obj.db_deleted_data:
+                if obj.vtType == 'module':
+                    n_obj = DBModule.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'location':
+                    n_obj = DBLocation.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'annotation':
+                    n_obj = DBAnnotation.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'controlParameter':
+                    n_obj = DBControlParameter.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'function':
+                    n_obj = DBFunction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'connection':
+                    n_obj = DBConnection.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'port':
+                    n_obj = DBPort.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'parameter':
+                    n_obj = DBParameter.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'portSpec':
+                    n_obj = DBPortSpec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'abstraction':
+                    n_obj = DBAbstraction.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'group':
+                    n_obj = DBGroup.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'other':
+                    n_obj = DBOther.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+                elif obj.vtType == 'plugin_data':
+                    n_obj = DBPluginData.update_version(obj, trans_dict)
+                    new_obj.db_deleted_data.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'what' in class_dict:
+            res = class_dict['what'](old_obj, trans_dict)
+            new_obj.db_what = res
+        elif hasattr(old_obj, 'db_what') and old_obj.db_what is not None:
+            new_obj.db_what = old_obj.db_what
+        if 'oldObjId' in class_dict:
+            res = class_dict['oldObjId'](old_obj, trans_dict)
+            new_obj.db_oldObjId = res
+        elif hasattr(old_obj, 'db_oldObjId') and old_obj.db_oldObjId is not None:
+            new_obj.db_oldObjId = old_obj.db_oldObjId
+        if 'newObjId' in class_dict:
+            res = class_dict['newObjId'](old_obj, trans_dict)
+            new_obj.db_newObjId = res
+        elif hasattr(old_obj, 'db_newObjId') and old_obj.db_newObjId is not None:
+            new_obj.db_newObjId = old_obj.db_newObjId
+        if 'parentObjId' in class_dict:
+            res = class_dict['parentObjId'](old_obj, trans_dict)
+            new_obj.db_parentObjId = res
+        elif hasattr(old_obj, 'db_parentObjId') and old_obj.db_parentObjId is not None:
+            new_obj.db_parentObjId = old_obj.db_parentObjId
+        if 'parentObjType' in class_dict:
+            res = class_dict['parentObjType'](old_obj, trans_dict)
+            new_obj.db_parentObjType = res
+        elif hasattr(old_obj, 'db_parentObjType') and old_obj.db_parentObjType is not None:
+            new_obj.db_parentObjType = old_obj.db_parentObjType
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_data is not None:
+            children.extend(self._db_data.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_data = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_data)
+        if remove:
+            self.db_deleted_data = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_data is not None and self._db_data.has_changes():
+            return True
+        return False
+    def __get_db_data(self):
+        return self._db_data
+    def __set_db_data(self, data):
+        self._db_data = data
+        self.is_dirty = True
+    db_data = property(__get_db_data, __set_db_data)
+    def db_add_data(self, data):
+        self._db_data = data
+    def db_change_data(self, data):
+        self._db_data = data
+    def db_delete_data(self, data):
+        if not self.is_new:
+            self.db_deleted_data.append(self._db_data)
+        self._db_data = None
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_what(self):
+        return self._db_what
+    def __set_db_what(self, what):
+        self._db_what = what
+        self.is_dirty = True
+    db_what = property(__get_db_what, __set_db_what)
+    def db_add_what(self, what):
+        self._db_what = what
+    def db_change_what(self, what):
+        self._db_what = what
+    def db_delete_what(self, what):
+        self._db_what = None
+    
+    def __get_db_oldObjId(self):
+        return self._db_oldObjId
+    def __set_db_oldObjId(self, oldObjId):
+        self._db_oldObjId = oldObjId
+        self.is_dirty = True
+    db_oldObjId = property(__get_db_oldObjId, __set_db_oldObjId)
+    def db_add_oldObjId(self, oldObjId):
+        self._db_oldObjId = oldObjId
+    def db_change_oldObjId(self, oldObjId):
+        self._db_oldObjId = oldObjId
+    def db_delete_oldObjId(self, oldObjId):
+        self._db_oldObjId = None
+    
+    def __get_db_newObjId(self):
+        return self._db_newObjId
+    def __set_db_newObjId(self, newObjId):
+        self._db_newObjId = newObjId
+        self.is_dirty = True
+    db_newObjId = property(__get_db_newObjId, __set_db_newObjId)
+    def db_add_newObjId(self, newObjId):
+        self._db_newObjId = newObjId
+    def db_change_newObjId(self, newObjId):
+        self._db_newObjId = newObjId
+    def db_delete_newObjId(self, newObjId):
+        self._db_newObjId = None
+    
+    def __get_db_parentObjId(self):
+        return self._db_parentObjId
+    def __set_db_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+        self.is_dirty = True
+    db_parentObjId = property(__get_db_parentObjId, __set_db_parentObjId)
+    def db_add_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_change_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_delete_parentObjId(self, parentObjId):
+        self._db_parentObjId = None
+    
+    def __get_db_parentObjType(self):
+        return self._db_parentObjType
+    def __set_db_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+    db_parentObjType = property(__get_db_parentObjType, __set_db_parentObjType)
+    def db_add_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_change_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_delete_parentObjType(self, parentObjType):
+        self._db_parentObjType = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBPackage(object):
+
+    vtType = 'package'
+
+    def __init__(self, id=None, name=None, identifier=None, codepath=None, load_configuration=None, version=None, description=None, module_descriptors=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_identifier = identifier
+        self._db_codepath = codepath
+        self._db_load_configuration = load_configuration
+        self._db_version = version
+        self._db_description = description
+        self.db_deleted_module_descriptors = []
+        self.db_module_descriptors_id_index = {}
+        self.db_module_descriptors_name_index = {}
+        if module_descriptors is None:
+            self._db_module_descriptors = []
+        else:
+            self._db_module_descriptors = module_descriptors
+            for v in self._db_module_descriptors:
+                self.db_module_descriptors_id_index[v.db_id] = v
+                self.db_module_descriptors_name_index[(v.db_name,v.db_namespace,v.db_version)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPackage.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPackage(id=self._db_id,
+                       name=self._db_name,
+                       identifier=self._db_identifier,
+                       codepath=self._db_codepath,
+                       load_configuration=self._db_load_configuration,
+                       version=self._db_version,
+                       description=self._db_description)
+        if self._db_module_descriptors is None:
+            cp._db_module_descriptors = []
+        else:
+            cp._db_module_descriptors = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_module_descriptors]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_module_descriptors_id_index = dict((v.db_id, v) for v in cp._db_module_descriptors)
+        cp.db_module_descriptors_name_index = dict(((v.db_name,v.db_namespace,v.db_version), v) for v in cp._db_module_descriptors)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPackage()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'identifier' in class_dict:
+            res = class_dict['identifier'](old_obj, trans_dict)
+            new_obj.db_identifier = res
+        elif hasattr(old_obj, 'db_identifier') and old_obj.db_identifier is not None:
+            new_obj.db_identifier = old_obj.db_identifier
+        if 'codepath' in class_dict:
+            res = class_dict['codepath'](old_obj, trans_dict)
+            new_obj.db_codepath = res
+        elif hasattr(old_obj, 'db_codepath') and old_obj.db_codepath is not None:
+            new_obj.db_codepath = old_obj.db_codepath
+        if 'load_configuration' in class_dict:
+            res = class_dict['load_configuration'](old_obj, trans_dict)
+            new_obj.db_load_configuration = res
+        elif hasattr(old_obj, 'db_load_configuration') and old_obj.db_load_configuration is not None:
+            new_obj.db_load_configuration = old_obj.db_load_configuration
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'description' in class_dict:
+            res = class_dict['description'](old_obj, trans_dict)
+            new_obj.db_description = res
+        elif hasattr(old_obj, 'db_description') and old_obj.db_description is not None:
+            new_obj.db_description = old_obj.db_description
+        if 'module_descriptors' in class_dict:
+            res = class_dict['module_descriptors'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_module_descriptor(obj)
+        elif hasattr(old_obj, 'db_module_descriptors') and old_obj.db_module_descriptors is not None:
+            for obj in old_obj.db_module_descriptors:
+                new_obj.db_add_module_descriptor(DBModuleDescriptor.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_module_descriptors') and hasattr(new_obj, 'db_deleted_module_descriptors'):
+            for obj in old_obj.db_deleted_module_descriptors:
+                n_obj = DBModuleDescriptor.update_version(obj, trans_dict)
+                new_obj.db_deleted_module_descriptors.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_module_descriptors:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_module_descriptor(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_module_descriptors)
+        if remove:
+            self.db_deleted_module_descriptors = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_module_descriptors:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_identifier(self):
+        return self._db_identifier
+    def __set_db_identifier(self, identifier):
+        self._db_identifier = identifier
+        self.is_dirty = True
+    db_identifier = property(__get_db_identifier, __set_db_identifier)
+    def db_add_identifier(self, identifier):
+        self._db_identifier = identifier
+    def db_change_identifier(self, identifier):
+        self._db_identifier = identifier
+    def db_delete_identifier(self, identifier):
+        self._db_identifier = None
+    
+    def __get_db_codepath(self):
+        return self._db_codepath
+    def __set_db_codepath(self, codepath):
+        self._db_codepath = codepath
+        self.is_dirty = True
+    db_codepath = property(__get_db_codepath, __set_db_codepath)
+    def db_add_codepath(self, codepath):
+        self._db_codepath = codepath
+    def db_change_codepath(self, codepath):
+        self._db_codepath = codepath
+    def db_delete_codepath(self, codepath):
+        self._db_codepath = None
+    
+    def __get_db_load_configuration(self):
+        return self._db_load_configuration
+    def __set_db_load_configuration(self, load_configuration):
+        self._db_load_configuration = load_configuration
+        self.is_dirty = True
+    db_load_configuration = property(__get_db_load_configuration, __set_db_load_configuration)
+    def db_add_load_configuration(self, load_configuration):
+        self._db_load_configuration = load_configuration
+    def db_change_load_configuration(self, load_configuration):
+        self._db_load_configuration = load_configuration
+    def db_delete_load_configuration(self, load_configuration):
+        self._db_load_configuration = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_description(self):
+        return self._db_description
+    def __set_db_description(self, description):
+        self._db_description = description
+        self.is_dirty = True
+    db_description = property(__get_db_description, __set_db_description)
+    def db_add_description(self, description):
+        self._db_description = description
+    def db_change_description(self, description):
+        self._db_description = description
+    def db_delete_description(self, description):
+        self._db_description = None
+    
+    def __get_db_module_descriptors(self):
+        return self._db_module_descriptors
+    def __set_db_module_descriptors(self, module_descriptors):
+        self._db_module_descriptors = module_descriptors
+        self.is_dirty = True
+    db_module_descriptors = property(__get_db_module_descriptors, __set_db_module_descriptors)
+    def db_get_module_descriptors(self):
+        return self._db_module_descriptors
+    def db_add_module_descriptor(self, module_descriptor):
+        self.is_dirty = True
+        self._db_module_descriptors.append(module_descriptor)
+        self.db_module_descriptors_id_index[module_descriptor.db_id] = module_descriptor
+        self.db_module_descriptors_name_index[(module_descriptor.db_name,module_descriptor.db_namespace,module_descriptor.db_version)] = module_descriptor
+    def db_change_module_descriptor(self, module_descriptor):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_module_descriptors)):
+            if self._db_module_descriptors[i].db_id == module_descriptor.db_id:
+                self._db_module_descriptors[i] = module_descriptor
+                found = True
+                break
+        if not found:
+            self._db_module_descriptors.append(module_descriptor)
+        self.db_module_descriptors_id_index[module_descriptor.db_id] = module_descriptor
+        self.db_module_descriptors_name_index[(module_descriptor.db_name,module_descriptor.db_namespace,module_descriptor.db_version)] = module_descriptor
+    def db_delete_module_descriptor(self, module_descriptor):
+        self.is_dirty = True
+        for i in xrange(len(self._db_module_descriptors)):
+            if self._db_module_descriptors[i].db_id == module_descriptor.db_id:
+                if not self._db_module_descriptors[i].is_new:
+                    self.db_deleted_module_descriptors.append(self._db_module_descriptors[i])
+                del self._db_module_descriptors[i]
+                break
+        del self.db_module_descriptors_id_index[module_descriptor.db_id]
+        del self.db_module_descriptors_name_index[(module_descriptor.db_name,module_descriptor.db_namespace,module_descriptor.db_version)]
+    def db_get_module_descriptor(self, key):
+        for i in xrange(len(self._db_module_descriptors)):
+            if self._db_module_descriptors[i].db_id == key:
+                return self._db_module_descriptors[i]
+        return None
+    def db_get_module_descriptor_by_id(self, key):
+        return self.db_module_descriptors_id_index[key]
+    def db_has_module_descriptor_with_id(self, key):
+        return key in self.db_module_descriptors_id_index
+    def db_get_module_descriptor_by_name(self, key):
+        return self.db_module_descriptors_name_index[key]
+    def db_has_module_descriptor_with_name(self, key):
+        return key in self.db_module_descriptors_name_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBLoopExec(object):
+
+    vtType = 'loop_exec'
+
+    def __init__(self, id=None, ts_start=None, ts_end=None, loop_iterations=None):
+        self._db_id = id
+        self._db_ts_start = ts_start
+        self._db_ts_end = ts_end
+        self.db_deleted_loop_iterations = []
+        self.db_loop_iterations_id_index = {}
+        if loop_iterations is None:
+            self._db_loop_iterations = []
+        else:
+            self._db_loop_iterations = loop_iterations
+            for v in self._db_loop_iterations:
+                self.db_loop_iterations_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBLoopExec.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBLoopExec(id=self._db_id,
+                        ts_start=self._db_ts_start,
+                        ts_end=self._db_ts_end)
+        if self._db_loop_iterations is None:
+            cp._db_loop_iterations = []
+        else:
+            cp._db_loop_iterations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_loop_iterations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_loop_iterations_id_index = dict((v.db_id, v) for v in cp._db_loop_iterations)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBLoopExec()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'ts_start' in class_dict:
+            res = class_dict['ts_start'](old_obj, trans_dict)
+            new_obj.db_ts_start = res
+        elif hasattr(old_obj, 'db_ts_start') and old_obj.db_ts_start is not None:
+            new_obj.db_ts_start = old_obj.db_ts_start
+        if 'ts_end' in class_dict:
+            res = class_dict['ts_end'](old_obj, trans_dict)
+            new_obj.db_ts_end = res
+        elif hasattr(old_obj, 'db_ts_end') and old_obj.db_ts_end is not None:
+            new_obj.db_ts_end = old_obj.db_ts_end
+        if 'loop_iterations' in class_dict:
+            res = class_dict['loop_iterations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_loop_iteration(obj)
+        elif hasattr(old_obj, 'db_loop_iterations') and old_obj.db_loop_iterations is not None:
+            for obj in old_obj.db_loop_iterations:
+                new_obj.db_add_loop_iteration(DBLoopIteration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_loop_iterations') and hasattr(new_obj, 'db_deleted_loop_iterations'):
+            for obj in old_obj.db_deleted_loop_iterations:
+                n_obj = DBLoopIteration.update_version(obj, trans_dict)
+                new_obj.db_deleted_loop_iterations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_loop_iterations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_loop_iteration(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_loop_iterations)
+        if remove:
+            self.db_deleted_loop_iterations = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_loop_iterations:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_ts_start(self):
+        return self._db_ts_start
+    def __set_db_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+        self.is_dirty = True
+    db_ts_start = property(__get_db_ts_start, __set_db_ts_start)
+    def db_add_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_change_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_delete_ts_start(self, ts_start):
+        self._db_ts_start = None
+    
+    def __get_db_ts_end(self):
+        return self._db_ts_end
+    def __set_db_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+        self.is_dirty = True
+    db_ts_end = property(__get_db_ts_end, __set_db_ts_end)
+    def db_add_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_change_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_delete_ts_end(self, ts_end):
+        self._db_ts_end = None
+    
+    def __get_db_loop_iterations(self):
+        return self._db_loop_iterations
+    def __set_db_loop_iterations(self, loop_iterations):
+        self._db_loop_iterations = loop_iterations
+        self.is_dirty = True
+    db_loop_iterations = property(__get_db_loop_iterations, __set_db_loop_iterations)
+    def db_get_loop_iterations(self):
+        return self._db_loop_iterations
+    def db_add_loop_iteration(self, loop_iteration):
+        self.is_dirty = True
+        self._db_loop_iterations.append(loop_iteration)
+        self.db_loop_iterations_id_index[loop_iteration.db_id] = loop_iteration
+    def db_change_loop_iteration(self, loop_iteration):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_loop_iterations)):
+            if self._db_loop_iterations[i].db_id == loop_iteration.db_id:
+                self._db_loop_iterations[i] = loop_iteration
+                found = True
+                break
+        if not found:
+            self._db_loop_iterations.append(loop_iteration)
+        self.db_loop_iterations_id_index[loop_iteration.db_id] = loop_iteration
+    def db_delete_loop_iteration(self, loop_iteration):
+        self.is_dirty = True
+        for i in xrange(len(self._db_loop_iterations)):
+            if self._db_loop_iterations[i].db_id == loop_iteration.db_id:
+                if not self._db_loop_iterations[i].is_new:
+                    self.db_deleted_loop_iterations.append(self._db_loop_iterations[i])
+                del self._db_loop_iterations[i]
+                break
+        del self.db_loop_iterations_id_index[loop_iteration.db_id]
+    def db_get_loop_iteration(self, key):
+        for i in xrange(len(self._db_loop_iterations)):
+            if self._db_loop_iterations[i].db_id == key:
+                return self._db_loop_iterations[i]
+        return None
+    def db_get_loop_iteration_by_id(self, key):
+        return self.db_loop_iterations_id_index[key]
+    def db_has_loop_iteration_with_id(self, key):
+        return key in self.db_loop_iterations_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBConnection(object):
+
+    vtType = 'connection'
+
+    def __init__(self, id=None, ports=None):
+        self._db_id = id
+        self.db_deleted_ports = []
+        self.db_ports_id_index = {}
+        self.db_ports_type_index = {}
+        if ports is None:
+            self._db_ports = []
+        else:
+            self._db_ports = ports
+            for v in self._db_ports:
+                self.db_ports_id_index[v.db_id] = v
+                self.db_ports_type_index[v.db_type] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConnection.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConnection(id=self._db_id)
+        if self._db_ports is None:
+            cp._db_ports = []
+        else:
+            cp._db_ports = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_ports]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_ports_id_index = dict((v.db_id, v) for v in cp._db_ports)
+        cp.db_ports_type_index = dict((v.db_type, v) for v in cp._db_ports)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConnection()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'ports' in class_dict:
+            res = class_dict['ports'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_port(obj)
+        elif hasattr(old_obj, 'db_ports') and old_obj.db_ports is not None:
+            for obj in old_obj.db_ports:
+                new_obj.db_add_port(DBPort.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_ports') and hasattr(new_obj, 'db_deleted_ports'):
+            for obj in old_obj.db_deleted_ports:
+                n_obj = DBPort.update_version(obj, trans_dict)
+                new_obj.db_deleted_ports.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_ports:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_port(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_ports)
+        if remove:
+            self.db_deleted_ports = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_ports:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_ports(self):
+        return self._db_ports
+    def __set_db_ports(self, ports):
+        self._db_ports = ports
+        self.is_dirty = True
+    db_ports = property(__get_db_ports, __set_db_ports)
+    def db_get_ports(self):
+        return self._db_ports
+    def db_add_port(self, port):
+        self.is_dirty = True
+        self._db_ports.append(port)
+        self.db_ports_id_index[port.db_id] = port
+        self.db_ports_type_index[port.db_type] = port
+    def db_change_port(self, port):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_ports)):
+            if self._db_ports[i].db_id == port.db_id:
+                self._db_ports[i] = port
+                found = True
+                break
+        if not found:
+            self._db_ports.append(port)
+        self.db_ports_id_index[port.db_id] = port
+        self.db_ports_type_index[port.db_type] = port
+    def db_delete_port(self, port):
+        self.is_dirty = True
+        for i in xrange(len(self._db_ports)):
+            if self._db_ports[i].db_id == port.db_id:
+                if not self._db_ports[i].is_new:
+                    self.db_deleted_ports.append(self._db_ports[i])
+                del self._db_ports[i]
+                break
+        del self.db_ports_id_index[port.db_id]
+        del self.db_ports_type_index[port.db_type]
+    def db_get_port(self, key):
+        for i in xrange(len(self._db_ports)):
+            if self._db_ports[i].db_id == key:
+                return self._db_ports[i]
+        return None
+    def db_get_port_by_id(self, key):
+        return self.db_ports_id_index[key]
+    def db_has_port_with_id(self, key):
+        return key in self.db_ports_id_index
+    def db_get_port_by_type(self, key):
+        return self.db_ports_type_index[key]
+    def db_has_port_with_type(self, key):
+        return key in self.db_ports_type_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBConfigBool(object):
+
+    vtType = 'config_bool'
+
+    def __init__(self, value=None):
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfigBool.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfigBool(value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfigBool()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+
+
+class DBAction(object):
+
+    vtType = 'action'
+
+    def __init__(self, operations=None, id=None, prevId=None, date=None, session=None, user=None, annotations=None):
+        self.db_deleted_operations = []
+        self.db_operations_id_index = {}
+        if operations is None:
+            self._db_operations = []
+        else:
+            self._db_operations = operations
+            for v in self._db_operations:
+                self.db_operations_id_index[v.db_id] = v
+        self._db_id = id
+        self._db_prevId = prevId
+        self._db_date = date
+        self._db_session = session
+        self._db_user = user
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBAction.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBAction(id=self._db_id,
+                      prevId=self._db_prevId,
+                      date=self._db_date,
+                      session=self._db_session,
+                      user=self._db_user)
+        if self._db_operations is None:
+            cp._db_operations = []
+        else:
+            cp._db_operations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_operations]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prevId') and ('action', self._db_prevId) in id_remap:
+                cp._db_prevId = id_remap[('action', self._db_prevId)]
+        
+        # recreate indices and set flags
+        cp.db_operations_id_index = dict((v.db_id, v) for v in cp._db_operations)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBAction()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'operations' in class_dict:
+            res = class_dict['operations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_operation(obj)
+        elif hasattr(old_obj, 'db_operations') and old_obj.db_operations is not None:
+            for obj in old_obj.db_operations:
+                if obj.vtType == 'add':
+                    new_obj.db_add_operation(DBAdd.update_version(obj, trans_dict))
+                elif obj.vtType == 'delete':
+                    new_obj.db_add_operation(DBDelete.update_version(obj, trans_dict))
+                elif obj.vtType == 'change':
+                    new_obj.db_add_operation(DBChange.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_operations') and hasattr(new_obj, 'db_deleted_operations'):
+            for obj in old_obj.db_deleted_operations:
+                if obj.vtType == 'add':
+                    n_obj = DBAdd.update_version(obj, trans_dict)
+                    new_obj.db_deleted_operations.append(n_obj)
+                elif obj.vtType == 'delete':
+                    n_obj = DBDelete.update_version(obj, trans_dict)
+                    new_obj.db_deleted_operations.append(n_obj)
+                elif obj.vtType == 'change':
+                    n_obj = DBChange.update_version(obj, trans_dict)
+                    new_obj.db_deleted_operations.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'prevId' in class_dict:
+            res = class_dict['prevId'](old_obj, trans_dict)
+            new_obj.db_prevId = res
+        elif hasattr(old_obj, 'db_prevId') and old_obj.db_prevId is not None:
+            new_obj.db_prevId = old_obj.db_prevId
+        if 'date' in class_dict:
+            res = class_dict['date'](old_obj, trans_dict)
+            new_obj.db_date = res
+        elif hasattr(old_obj, 'db_date') and old_obj.db_date is not None:
+            new_obj.db_date = old_obj.db_date
+        if 'session' in class_dict:
+            res = class_dict['session'](old_obj, trans_dict)
+            new_obj.db_session = res
+        elif hasattr(old_obj, 'db_session') and old_obj.db_session is not None:
+            new_obj.db_session = old_obj.db_session
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_operations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_operation(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_operations)
+        if remove:
+            self.db_deleted_annotations = []
+            self.db_deleted_operations = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_operations:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_operations(self):
+        return self._db_operations
+    def __set_db_operations(self, operations):
+        self._db_operations = operations
+        self.is_dirty = True
+    db_operations = property(__get_db_operations, __set_db_operations)
+    def db_get_operations(self):
+        return self._db_operations
+    def db_add_operation(self, operation):
+        self.is_dirty = True
+        self._db_operations.append(operation)
+        self.db_operations_id_index[operation.db_id] = operation
+    def db_change_operation(self, operation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_operations)):
+            if self._db_operations[i].db_id == operation.db_id:
+                self._db_operations[i] = operation
+                found = True
+                break
+        if not found:
+            self._db_operations.append(operation)
+        self.db_operations_id_index[operation.db_id] = operation
+    def db_delete_operation(self, operation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_operations)):
+            if self._db_operations[i].db_id == operation.db_id:
+                if not self._db_operations[i].is_new:
+                    self.db_deleted_operations.append(self._db_operations[i])
+                del self._db_operations[i]
+                break
+        del self.db_operations_id_index[operation.db_id]
+    def db_get_operation(self, key):
+        for i in xrange(len(self._db_operations)):
+            if self._db_operations[i].db_id == key:
+                return self._db_operations[i]
+        return None
+    def db_get_operation_by_id(self, key):
+        return self.db_operations_id_index[key]
+    def db_has_operation_with_id(self, key):
+        return key in self.db_operations_id_index
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_prevId(self):
+        return self._db_prevId
+    def __set_db_prevId(self, prevId):
+        self._db_prevId = prevId
+        self.is_dirty = True
+    db_prevId = property(__get_db_prevId, __set_db_prevId)
+    def db_add_prevId(self, prevId):
+        self._db_prevId = prevId
+    def db_change_prevId(self, prevId):
+        self._db_prevId = prevId
+    def db_delete_prevId(self, prevId):
+        self._db_prevId = None
+    
+    def __get_db_date(self):
+        return self._db_date
+    def __set_db_date(self, date):
+        self._db_date = date
+        self.is_dirty = True
+    db_date = property(__get_db_date, __set_db_date)
+    def db_add_date(self, date):
+        self._db_date = date
+    def db_change_date(self, date):
+        self._db_date = date
+    def db_delete_date(self, date):
+        self._db_date = None
+    
+    def __get_db_session(self):
+        return self._db_session
+    def __set_db_session(self, session):
+        self._db_session = session
+        self.is_dirty = True
+    db_session = property(__get_db_session, __set_db_session)
+    def db_add_session(self, session):
+        self._db_session = session
+    def db_change_session(self, session):
+        self._db_session = session
+    def db_delete_session(self, session):
+        self._db_session = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBStartupPackage(object):
+
+    vtType = 'startup_package'
+
+    def __init__(self, name=None, configuration=None):
+        self._db_name = name
+        self.db_deleted_configuration = []
+        self._db_configuration = configuration
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBStartupPackage.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBStartupPackage(name=self._db_name)
+        if self._db_configuration is not None:
+            cp._db_configuration = self._db_configuration.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBStartupPackage()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'configuration' in class_dict:
+            res = class_dict['configuration'](old_obj, trans_dict)
+            new_obj.db_configuration = res
+        elif hasattr(old_obj, 'db_configuration') and old_obj.db_configuration is not None:
+            obj = old_obj.db_configuration
+            new_obj.db_add_configuration(DBConfiguration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_configuration') and hasattr(new_obj, 'db_deleted_configuration'):
+            for obj in old_obj.db_deleted_configuration:
+                n_obj = DBConfiguration.update_version(obj, trans_dict)
+                new_obj.db_deleted_configuration.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_configuration is not None:
+            children.extend(self._db_configuration.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_configuration = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_configuration)
+        if remove:
+            self.db_deleted_configuration = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_configuration is not None and self._db_configuration.has_changes():
+            return True
+        return False
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_configuration(self):
+        return self._db_configuration
+    def __set_db_configuration(self, configuration):
+        self._db_configuration = configuration
+        self.is_dirty = True
+    db_configuration = property(__get_db_configuration, __set_db_configuration)
+    def db_add_configuration(self, configuration):
+        self._db_configuration = configuration
+    def db_change_configuration(self, configuration):
+        self._db_configuration = configuration
+    def db_delete_configuration(self, configuration):
+        if not self.is_new:
+            self.db_deleted_configuration.append(self._db_configuration)
+        self._db_configuration = None
+    
+
+
+class DBConfigInt(object):
+
+    vtType = 'config_int'
+
+    def __init__(self, value=None):
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfigInt.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfigInt(value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfigInt()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+
+
+class DBOpmProcessIdEffect(object):
+
+    vtType = 'opm_process_id_effect'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmProcessIdEffect.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmProcessIdEffect(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_process', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_process', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmProcessIdEffect()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBRefProvPlan(object):
+
+    vtType = 'ref_prov_plan'
+
+    def __init__(self, prov_ref=None):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBRefProvPlan.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBRefProvPlan(prov_ref=self._db_prov_ref)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prov_ref') and ('prov_entity', self._db_prov_ref) in id_remap:
+                cp._db_prov_ref = id_remap[('prov_entity', self._db_prov_ref)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRefProvPlan()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_ref' in class_dict:
+            res = class_dict['prov_ref'](old_obj, trans_dict)
+            new_obj.db_prov_ref = res
+        elif hasattr(old_obj, 'db_prov_ref') and old_obj.db_prov_ref is not None:
+            new_obj.db_prov_ref = old_obj.db_prov_ref
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_prov_ref(self):
+        return self._db_prov_ref
+    def __set_db_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+    db_prov_ref = property(__get_db_prov_ref, __set_db_prov_ref)
+    def db_add_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_change_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_delete_prov_ref(self, prov_ref):
+        self._db_prov_ref = None
+    
+
+
+class DBOpmAccounts(object):
+
+    vtType = 'opm_accounts'
+
+    def __init__(self, accounts=None, opm_overlapss=None):
+        self.db_deleted_accounts = []
+        self.db_accounts_id_index = {}
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+            for v in self._db_accounts:
+                self.db_accounts_id_index[v.db_id] = v
+        self.db_deleted_opm_overlapss = []
+        if opm_overlapss is None:
+            self._db_opm_overlapss = []
+        else:
+            self._db_opm_overlapss = opm_overlapss
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAccounts.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAccounts()
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_opm_overlapss is None:
+            cp._db_opm_overlapss = []
+        else:
+            cp._db_opm_overlapss = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_overlapss]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_accounts_id_index = dict((v.db_id, v) for v in cp._db_accounts)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAccounts()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccount.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccount.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'opm_overlapss' in class_dict:
+            res = class_dict['opm_overlapss'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_overlaps(obj)
+        elif hasattr(old_obj, 'db_opm_overlapss') and old_obj.db_opm_overlapss is not None:
+            for obj in old_obj.db_opm_overlapss:
+                new_obj.db_add_opm_overlaps(DBOpmOverlaps.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_overlapss') and hasattr(new_obj, 'db_deleted_opm_overlapss'):
+            for obj in old_obj.db_deleted_opm_overlapss:
+                n_obj = DBOpmOverlaps.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_overlapss.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_opm_overlapss:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_overlaps(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_opm_overlapss)
+        if remove:
+            self.db_deleted_accounts = []
+            self.db_deleted_opm_overlapss = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_opm_overlapss:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+        self.db_accounts_id_index[account.db_id] = account
+    def db_change_account(self, account):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_accounts)):
+            if self._db_accounts[i].db_id == account.db_id:
+                self._db_accounts[i] = account
+                found = True
+                break
+        if not found:
+            self._db_accounts.append(account)
+        self.db_accounts_id_index[account.db_id] = account
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        for i in xrange(len(self._db_accounts)):
+            if self._db_accounts[i].db_id == account.db_id:
+                if not self._db_accounts[i].is_new:
+                    self.db_deleted_accounts.append(self._db_accounts[i])
+                del self._db_accounts[i]
+                break
+        del self.db_accounts_id_index[account.db_id]
+    def db_get_account(self, key):
+        for i in xrange(len(self._db_accounts)):
+            if self._db_accounts[i].db_id == key:
+                return self._db_accounts[i]
+        return None
+    def db_get_account_by_id(self, key):
+        return self.db_accounts_id_index[key]
+    def db_has_account_with_id(self, key):
+        return key in self.db_accounts_id_index
+    
+    def __get_db_opm_overlapss(self):
+        return self._db_opm_overlapss
+    def __set_db_opm_overlapss(self, opm_overlapss):
+        self._db_opm_overlapss = opm_overlapss
+        self.is_dirty = True
+    db_opm_overlapss = property(__get_db_opm_overlapss, __set_db_opm_overlapss)
+    def db_get_opm_overlapss(self):
+        return self._db_opm_overlapss
+    def db_add_opm_overlaps(self, opm_overlaps):
+        self.is_dirty = True
+        self._db_opm_overlapss.append(opm_overlaps)
+    def db_change_opm_overlaps(self, opm_overlaps):
+        self.is_dirty = True
+        self._db_opm_overlapss.append(opm_overlaps)
+    def db_delete_opm_overlaps(self, opm_overlaps):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_overlaps(self, key):
+        return None
+    
+
+
+class DBRefProvAgent(object):
+
+    vtType = 'ref_prov_agent'
+
+    def __init__(self, prov_ref=None):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBRefProvAgent.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBRefProvAgent(prov_ref=self._db_prov_ref)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prov_ref') and ('prov_agent', self._db_prov_ref) in id_remap:
+                cp._db_prov_ref = id_remap[('prov_agent', self._db_prov_ref)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRefProvAgent()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_ref' in class_dict:
+            res = class_dict['prov_ref'](old_obj, trans_dict)
+            new_obj.db_prov_ref = res
+        elif hasattr(old_obj, 'db_prov_ref') and old_obj.db_prov_ref is not None:
+            new_obj.db_prov_ref = old_obj.db_prov_ref
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_prov_ref(self):
+        return self._db_prov_ref
+    def __set_db_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+    db_prov_ref = property(__get_db_prov_ref, __set_db_prov_ref)
+    def db_add_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_change_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_delete_prov_ref(self, prov_ref):
+        self._db_prov_ref = None
+    
+
+
+class DBPortSpec(object):
+
+    vtType = 'portSpec'
+
+    def __init__(self, id=None, name=None, type=None, optional=None, depth=None, union=None, sort_key=None, portSpecItems=None, min_conns=None, max_conns=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_type = type
+        self._db_optional = optional
+        self._db_depth = depth
+        self._db_union = union
+        self._db_sort_key = sort_key
+        self.db_deleted_portSpecItems = []
+        self.db_portSpecItems_id_index = {}
+        if portSpecItems is None:
+            self._db_portSpecItems = []
+        else:
+            self._db_portSpecItems = portSpecItems
+            for v in self._db_portSpecItems:
+                self.db_portSpecItems_id_index[v.db_id] = v
+        self._db_min_conns = min_conns
+        self._db_max_conns = max_conns
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPortSpec.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPortSpec(id=self._db_id,
+                        name=self._db_name,
+                        type=self._db_type,
+                        optional=self._db_optional,
+                        depth=self._db_depth,
+                        union=self._db_union,
+                        sort_key=self._db_sort_key,
+                        min_conns=self._db_min_conns,
+                        max_conns=self._db_max_conns)
+        if self._db_portSpecItems is None:
+            cp._db_portSpecItems = []
+        else:
+            cp._db_portSpecItems = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_portSpecItems]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_portSpecItems_id_index = dict((v.db_id, v) for v in cp._db_portSpecItems)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPortSpec()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'type' in class_dict:
+            res = class_dict['type'](old_obj, trans_dict)
+            new_obj.db_type = res
+        elif hasattr(old_obj, 'db_type') and old_obj.db_type is not None:
+            new_obj.db_type = old_obj.db_type
+        if 'optional' in class_dict:
+            res = class_dict['optional'](old_obj, trans_dict)
+            new_obj.db_optional = res
+        elif hasattr(old_obj, 'db_optional') and old_obj.db_optional is not None:
+            new_obj.db_optional = old_obj.db_optional
+        if 'depth' in class_dict:
+            res = class_dict['depth'](old_obj, trans_dict)
+            new_obj.db_depth = res
+        elif hasattr(old_obj, 'db_depth') and old_obj.db_depth is not None:
+            new_obj.db_depth = old_obj.db_depth
+        if 'union' in class_dict:
+            res = class_dict['union'](old_obj, trans_dict)
+            new_obj.db_union = res
+        elif hasattr(old_obj, 'db_union') and old_obj.db_union is not None:
+            new_obj.db_union = old_obj.db_union
+        if 'sort_key' in class_dict:
+            res = class_dict['sort_key'](old_obj, trans_dict)
+            new_obj.db_sort_key = res
+        elif hasattr(old_obj, 'db_sort_key') and old_obj.db_sort_key is not None:
+            new_obj.db_sort_key = old_obj.db_sort_key
+        if 'portSpecItems' in class_dict:
+            res = class_dict['portSpecItems'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_portSpecItem(obj)
+        elif hasattr(old_obj, 'db_portSpecItems') and old_obj.db_portSpecItems is not None:
+            for obj in old_obj.db_portSpecItems:
+                new_obj.db_add_portSpecItem(DBPortSpecItem.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_portSpecItems') and hasattr(new_obj, 'db_deleted_portSpecItems'):
+            for obj in old_obj.db_deleted_portSpecItems:
+                n_obj = DBPortSpecItem.update_version(obj, trans_dict)
+                new_obj.db_deleted_portSpecItems.append(n_obj)
+        if 'min_conns' in class_dict:
+            res = class_dict['min_conns'](old_obj, trans_dict)
+            new_obj.db_min_conns = res
+        elif hasattr(old_obj, 'db_min_conns') and old_obj.db_min_conns is not None:
+            new_obj.db_min_conns = old_obj.db_min_conns
+        if 'max_conns' in class_dict:
+            res = class_dict['max_conns'](old_obj, trans_dict)
+            new_obj.db_max_conns = res
+        elif hasattr(old_obj, 'db_max_conns') and old_obj.db_max_conns is not None:
+            new_obj.db_max_conns = old_obj.db_max_conns
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if not for_action:
+            for child in self.db_portSpecItems:
+                children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_portSpecItems)
+        if remove:
+            self.db_deleted_portSpecItems = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_portSpecItems:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_type(self):
+        return self._db_type
+    def __set_db_type(self, type):
+        self._db_type = type
+        self.is_dirty = True
+    db_type = property(__get_db_type, __set_db_type)
+    def db_add_type(self, type):
+        self._db_type = type
+    def db_change_type(self, type):
+        self._db_type = type
+    def db_delete_type(self, type):
+        self._db_type = None
+    
+    def __get_db_optional(self):
+        return self._db_optional
+    def __set_db_optional(self, optional):
+        self._db_optional = optional
+        self.is_dirty = True
+    db_optional = property(__get_db_optional, __set_db_optional)
+    def db_add_optional(self, optional):
+        self._db_optional = optional
+    def db_change_optional(self, optional):
+        self._db_optional = optional
+    def db_delete_optional(self, optional):
+        self._db_optional = None
+    
+    def __get_db_depth(self):
+        return self._db_depth
+    def __set_db_depth(self, depth):
+        self._db_depth = depth
+        self.is_dirty = True
+    db_depth = property(__get_db_depth, __set_db_depth)
+    def db_add_depth(self, depth):
+        self._db_depth = depth
+    def db_change_depth(self, depth):
+        self._db_depth = depth
+    def db_delete_depth(self, depth):
+        self._db_depth = None
+    
+    def __get_db_union(self):
+        return self._db_union
+    def __set_db_union(self, union):
+        self._db_union = union
+        self.is_dirty = True
+    db_union = property(__get_db_union, __set_db_union)
+    def db_add_union(self, union):
+        self._db_union = union
+    def db_change_union(self, union):
+        self._db_union = union
+    def db_delete_union(self, union):
+        self._db_union = None
+    
+    def __get_db_sort_key(self):
+        return self._db_sort_key
+    def __set_db_sort_key(self, sort_key):
+        self._db_sort_key = sort_key
+        self.is_dirty = True
+    db_sort_key = property(__get_db_sort_key, __set_db_sort_key)
+    def db_add_sort_key(self, sort_key):
+        self._db_sort_key = sort_key
+    def db_change_sort_key(self, sort_key):
+        self._db_sort_key = sort_key
+    def db_delete_sort_key(self, sort_key):
+        self._db_sort_key = None
+    
+    def __get_db_portSpecItems(self):
+        return self._db_portSpecItems
+    def __set_db_portSpecItems(self, portSpecItems):
+        self._db_portSpecItems = portSpecItems
+        self.is_dirty = True
+    db_portSpecItems = property(__get_db_portSpecItems, __set_db_portSpecItems)
+    def db_get_portSpecItems(self):
+        return self._db_portSpecItems
+    def db_add_portSpecItem(self, portSpecItem):
+        self.is_dirty = True
+        self._db_portSpecItems.append(portSpecItem)
+        self.db_portSpecItems_id_index[portSpecItem.db_id] = portSpecItem
+    def db_change_portSpecItem(self, portSpecItem):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_portSpecItems)):
+            if self._db_portSpecItems[i].db_id == portSpecItem.db_id:
+                self._db_portSpecItems[i] = portSpecItem
+                found = True
+                break
+        if not found:
+            self._db_portSpecItems.append(portSpecItem)
+        self.db_portSpecItems_id_index[portSpecItem.db_id] = portSpecItem
+    def db_delete_portSpecItem(self, portSpecItem):
+        self.is_dirty = True
+        for i in xrange(len(self._db_portSpecItems)):
+            if self._db_portSpecItems[i].db_id == portSpecItem.db_id:
+                if not self._db_portSpecItems[i].is_new:
+                    self.db_deleted_portSpecItems.append(self._db_portSpecItems[i])
+                del self._db_portSpecItems[i]
+                break
+        del self.db_portSpecItems_id_index[portSpecItem.db_id]
+    def db_get_portSpecItem(self, key):
+        for i in xrange(len(self._db_portSpecItems)):
+            if self._db_portSpecItems[i].db_id == key:
+                return self._db_portSpecItems[i]
+        return None
+    def db_get_portSpecItem_by_id(self, key):
+        return self.db_portSpecItems_id_index[key]
+    def db_has_portSpecItem_with_id(self, key):
+        return key in self.db_portSpecItems_id_index
+    
+    def __get_db_min_conns(self):
+        return self._db_min_conns
+    def __set_db_min_conns(self, min_conns):
+        self._db_min_conns = min_conns
+        self.is_dirty = True
+    db_min_conns = property(__get_db_min_conns, __set_db_min_conns)
+    def db_add_min_conns(self, min_conns):
+        self._db_min_conns = min_conns
+    def db_change_min_conns(self, min_conns):
+        self._db_min_conns = min_conns
+    def db_delete_min_conns(self, min_conns):
+        self._db_min_conns = None
+    
+    def __get_db_max_conns(self):
+        return self._db_max_conns
+    def __set_db_max_conns(self, max_conns):
+        self._db_max_conns = max_conns
+        self.is_dirty = True
+    db_max_conns = property(__get_db_max_conns, __set_db_max_conns)
+    def db_add_max_conns(self, max_conns):
+        self._db_max_conns = max_conns
+    def db_change_max_conns(self, max_conns):
+        self._db_max_conns = max_conns
+    def db_delete_max_conns(self, max_conns):
+        self._db_max_conns = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBEnabledPackages(object):
+
+    vtType = 'enabled_packages'
+
+    def __init__(self, packages=None):
+        self.db_deleted_packages = []
+        self.db_packages_name_index = {}
+        if packages is None:
+            self._db_packages = []
+        else:
+            self._db_packages = packages
+            for v in self._db_packages:
+                self.db_packages_name_index[v.db_name] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBEnabledPackages.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBEnabledPackages()
+        if self._db_packages is None:
+            cp._db_packages = []
+        else:
+            cp._db_packages = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_packages]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_packages_name_index = dict((v.db_name, v) for v in cp._db_packages)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBEnabledPackages()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'packages' in class_dict:
+            res = class_dict['packages'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_package(obj)
+        elif hasattr(old_obj, 'db_packages') and old_obj.db_packages is not None:
+            for obj in old_obj.db_packages:
+                new_obj.db_add_package(DBStartupPackage.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_packages') and hasattr(new_obj, 'db_deleted_packages'):
+            for obj in old_obj.db_deleted_packages:
+                n_obj = DBStartupPackage.update_version(obj, trans_dict)
+                new_obj.db_deleted_packages.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_packages:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_package(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_packages)
+        if remove:
+            self.db_deleted_packages = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_packages:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_packages(self):
+        return self._db_packages
+    def __set_db_packages(self, packages):
+        self._db_packages = packages
+        self.is_dirty = True
+    db_packages = property(__get_db_packages, __set_db_packages)
+    def db_get_packages(self):
+        return self._db_packages
+    def db_add_package(self, package):
+        self.is_dirty = True
+        self._db_packages.append(package)
+        self.db_packages_name_index[package.db_name] = package
+    def db_change_package(self, package):
+        self.is_dirty = True
+        self._db_packages.append(package)
+        self.db_packages_name_index[package.db_name] = package
+    def db_delete_package(self, package):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_package(self, key):
+        return None
+    def db_get_package_by_name(self, key):
+        return self.db_packages_name_index[key]
+    def db_has_package_with_name(self, key):
+        return key in self.db_packages_name_index
+    
+
+
+class DBOpmArtifact(object):
+
+    vtType = 'opm_artifact'
+
+    def __init__(self, id=None, value=None, accounts=None):
+        self._db_id = id
+        self.db_deleted_value = []
+        self._db_value = value
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmArtifact.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmArtifact(id=self._db_id)
+        if self._db_value is not None:
+            cp._db_value = self._db_value.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmArtifact()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            obj = old_obj.db_value
+            new_obj.db_add_value(DBOpmArtifactValue.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_value') and hasattr(new_obj, 'db_deleted_value'):
+            for obj in old_obj.db_deleted_value:
+                n_obj = DBOpmArtifactValue.update_version(obj, trans_dict)
+                new_obj.db_deleted_value.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_value is not None:
+            children.extend(self._db_value.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_value = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_value)
+        children.extend(self.db_deleted_accounts)
+        if remove:
+            self.db_deleted_value = []
+            self.db_deleted_accounts = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_value is not None and self._db_value.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        if not self.is_new:
+            self.db_deleted_value.append(self._db_value)
+        self._db_value = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBLog(object):
+
+    vtType = 'log'
+
+    def __init__(self, id=None, entity_type=None, version=None, name=None, last_modified=None, workflow_execs=None, vistrail_id=None):
+        self._db_id = id
+        self._db_entity_type = entity_type
+        self._db_version = version
+        self._db_name = name
+        self._db_last_modified = last_modified
+        self.db_deleted_workflow_execs = []
+        self.db_workflow_execs_id_index = {}
+        if workflow_execs is None:
+            self._db_workflow_execs = []
+        else:
+            self._db_workflow_execs = workflow_execs
+            for v in self._db_workflow_execs:
+                self.db_workflow_execs_id_index[v.db_id] = v
+        self._db_vistrail_id = vistrail_id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBLog.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBLog(id=self._db_id,
+                   entity_type=self._db_entity_type,
+                   version=self._db_version,
+                   name=self._db_name,
+                   last_modified=self._db_last_modified,
+                   vistrail_id=self._db_vistrail_id)
+        if self._db_workflow_execs is None:
+            cp._db_workflow_execs = []
+        else:
+            cp._db_workflow_execs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_workflow_execs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_vistrail_id') and ('vistrail', self._db_vistrail_id) in id_remap:
+                cp._db_vistrail_id = id_remap[('vistrail', self._db_vistrail_id)]
+        
+        # recreate indices and set flags
+        cp.db_workflow_execs_id_index = dict((v.db_id, v) for v in cp._db_workflow_execs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBLog()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'entity_type' in class_dict:
+            res = class_dict['entity_type'](old_obj, trans_dict)
+            new_obj.db_entity_type = res
+        elif hasattr(old_obj, 'db_entity_type') and old_obj.db_entity_type is not None:
+            new_obj.db_entity_type = old_obj.db_entity_type
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'last_modified' in class_dict:
+            res = class_dict['last_modified'](old_obj, trans_dict)
+            new_obj.db_last_modified = res
+        elif hasattr(old_obj, 'db_last_modified') and old_obj.db_last_modified is not None:
+            new_obj.db_last_modified = old_obj.db_last_modified
+        if 'workflow_execs' in class_dict:
+            res = class_dict['workflow_execs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_workflow_exec(obj)
+        elif hasattr(old_obj, 'db_workflow_execs') and old_obj.db_workflow_execs is not None:
+            for obj in old_obj.db_workflow_execs:
+                new_obj.db_add_workflow_exec(DBWorkflowExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_workflow_execs') and hasattr(new_obj, 'db_deleted_workflow_execs'):
+            for obj in old_obj.db_deleted_workflow_execs:
+                n_obj = DBWorkflowExec.update_version(obj, trans_dict)
+                new_obj.db_deleted_workflow_execs.append(n_obj)
+        if 'vistrail_id' in class_dict:
+            res = class_dict['vistrail_id'](old_obj, trans_dict)
+            new_obj.db_vistrail_id = res
+        elif hasattr(old_obj, 'db_vistrail_id') and old_obj.db_vistrail_id is not None:
+            new_obj.db_vistrail_id = old_obj.db_vistrail_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_workflow_execs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_workflow_exec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_workflow_execs)
+        if remove:
+            self.db_deleted_workflow_execs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_workflow_execs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_entity_type(self):
+        return self._db_entity_type
+    def __set_db_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+        self.is_dirty = True
+    db_entity_type = property(__get_db_entity_type, __set_db_entity_type)
+    def db_add_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_change_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_delete_entity_type(self, entity_type):
+        self._db_entity_type = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_last_modified(self):
+        return self._db_last_modified
+    def __set_db_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+        self.is_dirty = True
+    db_last_modified = property(__get_db_last_modified, __set_db_last_modified)
+    def db_add_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_change_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_delete_last_modified(self, last_modified):
+        self._db_last_modified = None
+    
+    def __get_db_workflow_execs(self):
+        return self._db_workflow_execs
+    def __set_db_workflow_execs(self, workflow_execs):
+        self._db_workflow_execs = workflow_execs
+        self.is_dirty = True
+    db_workflow_execs = property(__get_db_workflow_execs, __set_db_workflow_execs)
+    def db_get_workflow_execs(self):
+        return self._db_workflow_execs
+    def db_add_workflow_exec(self, workflow_exec):
+        self.is_dirty = True
+        self._db_workflow_execs.append(workflow_exec)
+        self.db_workflow_execs_id_index[workflow_exec.db_id] = workflow_exec
+    def db_change_workflow_exec(self, workflow_exec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_workflow_execs)):
+            if self._db_workflow_execs[i].db_id == workflow_exec.db_id:
+                self._db_workflow_execs[i] = workflow_exec
+                found = True
+                break
+        if not found:
+            self._db_workflow_execs.append(workflow_exec)
+        self.db_workflow_execs_id_index[workflow_exec.db_id] = workflow_exec
+    def db_delete_workflow_exec(self, workflow_exec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_workflow_execs)):
+            if self._db_workflow_execs[i].db_id == workflow_exec.db_id:
+                if not self._db_workflow_execs[i].is_new:
+                    self.db_deleted_workflow_execs.append(self._db_workflow_execs[i])
+                del self._db_workflow_execs[i]
+                break
+        del self.db_workflow_execs_id_index[workflow_exec.db_id]
+    def db_get_workflow_exec(self, key):
+        for i in xrange(len(self._db_workflow_execs)):
+            if self._db_workflow_execs[i].db_id == key:
+                return self._db_workflow_execs[i]
+        return None
+    def db_get_workflow_exec_by_id(self, key):
+        return self.db_workflow_execs_id_index[key]
+    def db_has_workflow_exec_with_id(self, key):
+        return key in self.db_workflow_execs_id_index
+    
+    def __get_db_vistrail_id(self):
+        return self._db_vistrail_id
+    def __set_db_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+        self.is_dirty = True
+    db_vistrail_id = property(__get_db_vistrail_id, __set_db_vistrail_id)
+    def db_add_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+    def db_change_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = vistrail_id
+    def db_delete_vistrail_id(self, vistrail_id):
+        self._db_vistrail_id = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBLoopIteration(object):
+
+    vtType = 'loop_iteration'
+
+    def __init__(self, item_execs=None, id=None, ts_start=None, ts_end=None, iteration=None, completed=None, error=None):
+        self.db_deleted_item_execs = []
+        self.db_item_execs_id_index = {}
+        if item_execs is None:
+            self._db_item_execs = []
+        else:
+            self._db_item_execs = item_execs
+            for v in self._db_item_execs:
+                self.db_item_execs_id_index[v.db_id] = v
+        self._db_id = id
+        self._db_ts_start = ts_start
+        self._db_ts_end = ts_end
+        self._db_iteration = iteration
+        self._db_completed = completed
+        self._db_error = error
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBLoopIteration.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBLoopIteration(id=self._db_id,
+                             ts_start=self._db_ts_start,
+                             ts_end=self._db_ts_end,
+                             iteration=self._db_iteration,
+                             completed=self._db_completed,
+                             error=self._db_error)
+        if self._db_item_execs is None:
+            cp._db_item_execs = []
+        else:
+            cp._db_item_execs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_item_execs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_item_execs_id_index = dict((v.db_id, v) for v in cp._db_item_execs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBLoopIteration()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'item_execs' in class_dict:
+            res = class_dict['item_execs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_item_exec(obj)
+        elif hasattr(old_obj, 'db_item_execs') and old_obj.db_item_execs is not None:
+            for obj in old_obj.db_item_execs:
+                if obj.vtType == 'module_exec':
+                    new_obj.db_add_item_exec(DBModuleExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'group_exec':
+                    new_obj.db_add_item_exec(DBGroupExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'loop_exec':
+                    new_obj.db_add_item_exec(DBLoopExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_item_execs') and hasattr(new_obj, 'db_deleted_item_execs'):
+            for obj in old_obj.db_deleted_item_execs:
+                if obj.vtType == 'module_exec':
+                    n_obj = DBModuleExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'group_exec':
+                    n_obj = DBGroupExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'loop_exec':
+                    n_obj = DBLoopExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'ts_start' in class_dict:
+            res = class_dict['ts_start'](old_obj, trans_dict)
+            new_obj.db_ts_start = res
+        elif hasattr(old_obj, 'db_ts_start') and old_obj.db_ts_start is not None:
+            new_obj.db_ts_start = old_obj.db_ts_start
+        if 'ts_end' in class_dict:
+            res = class_dict['ts_end'](old_obj, trans_dict)
+            new_obj.db_ts_end = res
+        elif hasattr(old_obj, 'db_ts_end') and old_obj.db_ts_end is not None:
+            new_obj.db_ts_end = old_obj.db_ts_end
+        if 'iteration' in class_dict:
+            res = class_dict['iteration'](old_obj, trans_dict)
+            new_obj.db_iteration = res
+        elif hasattr(old_obj, 'db_iteration') and old_obj.db_iteration is not None:
+            new_obj.db_iteration = old_obj.db_iteration
+        if 'completed' in class_dict:
+            res = class_dict['completed'](old_obj, trans_dict)
+            new_obj.db_completed = res
+        elif hasattr(old_obj, 'db_completed') and old_obj.db_completed is not None:
+            new_obj.db_completed = old_obj.db_completed
+        if 'error' in class_dict:
+            res = class_dict['error'](old_obj, trans_dict)
+            new_obj.db_error = res
+        elif hasattr(old_obj, 'db_error') and old_obj.db_error is not None:
+            new_obj.db_error = old_obj.db_error
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_item_execs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_item_exec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_item_execs)
+        if remove:
+            self.db_deleted_item_execs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_item_execs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_item_execs(self):
+        return self._db_item_execs
+    def __set_db_item_execs(self, item_execs):
+        self._db_item_execs = item_execs
+        self.is_dirty = True
+    db_item_execs = property(__get_db_item_execs, __set_db_item_execs)
+    def db_get_item_execs(self):
+        return self._db_item_execs
+    def db_add_item_exec(self, item_exec):
+        self.is_dirty = True
+        self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_change_item_exec(self, item_exec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                self._db_item_execs[i] = item_exec
+                found = True
+                break
+        if not found:
+            self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_delete_item_exec(self, item_exec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                if not self._db_item_execs[i].is_new:
+                    self.db_deleted_item_execs.append(self._db_item_execs[i])
+                del self._db_item_execs[i]
+                break
+        del self.db_item_execs_id_index[item_exec.db_id]
+    def db_get_item_exec(self, key):
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == key:
+                return self._db_item_execs[i]
+        return None
+    def db_get_item_exec_by_id(self, key):
+        return self.db_item_execs_id_index[key]
+    def db_has_item_exec_with_id(self, key):
+        return key in self.db_item_execs_id_index
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_ts_start(self):
+        return self._db_ts_start
+    def __set_db_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+        self.is_dirty = True
+    db_ts_start = property(__get_db_ts_start, __set_db_ts_start)
+    def db_add_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_change_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_delete_ts_start(self, ts_start):
+        self._db_ts_start = None
+    
+    def __get_db_ts_end(self):
+        return self._db_ts_end
+    def __set_db_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+        self.is_dirty = True
+    db_ts_end = property(__get_db_ts_end, __set_db_ts_end)
+    def db_add_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_change_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_delete_ts_end(self, ts_end):
+        self._db_ts_end = None
+    
+    def __get_db_iteration(self):
+        return self._db_iteration
+    def __set_db_iteration(self, iteration):
+        self._db_iteration = iteration
+        self.is_dirty = True
+    db_iteration = property(__get_db_iteration, __set_db_iteration)
+    def db_add_iteration(self, iteration):
+        self._db_iteration = iteration
+    def db_change_iteration(self, iteration):
+        self._db_iteration = iteration
+    def db_delete_iteration(self, iteration):
+        self._db_iteration = None
+    
+    def __get_db_completed(self):
+        return self._db_completed
+    def __set_db_completed(self, completed):
+        self._db_completed = completed
+        self.is_dirty = True
+    db_completed = property(__get_db_completed, __set_db_completed)
+    def db_add_completed(self, completed):
+        self._db_completed = completed
+    def db_change_completed(self, completed):
+        self._db_completed = completed
+    def db_delete_completed(self, completed):
+        self._db_completed = None
+    
+    def __get_db_error(self):
+        return self._db_error
+    def __set_db_error(self, error):
+        self._db_error = error
+        self.is_dirty = True
+    db_error = property(__get_db_error, __set_db_error)
+    def db_add_error(self, error):
+        self._db_error = error
+    def db_change_error(self, error):
+        self._db_error = error
+    def db_delete_error(self, error):
+        self._db_error = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmProcessIdCause(object):
+
+    vtType = 'opm_process_id_cause'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmProcessIdCause.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmProcessIdCause(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_process', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_process', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmProcessIdCause()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBOpmArtifacts(object):
+
+    vtType = 'opm_artifacts'
+
+    def __init__(self, artifacts=None):
+        self.db_deleted_artifacts = []
+        self.db_artifacts_id_index = {}
+        if artifacts is None:
+            self._db_artifacts = []
+        else:
+            self._db_artifacts = artifacts
+            for v in self._db_artifacts:
+                self.db_artifacts_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmArtifacts.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmArtifacts()
+        if self._db_artifacts is None:
+            cp._db_artifacts = []
+        else:
+            cp._db_artifacts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_artifacts]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_artifacts_id_index = dict((v.db_id, v) for v in cp._db_artifacts)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmArtifacts()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'artifacts' in class_dict:
+            res = class_dict['artifacts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_artifact(obj)
+        elif hasattr(old_obj, 'db_artifacts') and old_obj.db_artifacts is not None:
+            for obj in old_obj.db_artifacts:
+                new_obj.db_add_artifact(DBOpmArtifact.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_artifacts') and hasattr(new_obj, 'db_deleted_artifacts'):
+            for obj in old_obj.db_deleted_artifacts:
+                n_obj = DBOpmArtifact.update_version(obj, trans_dict)
+                new_obj.db_deleted_artifacts.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_artifacts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_artifact(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_artifacts)
+        if remove:
+            self.db_deleted_artifacts = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_artifacts:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_artifacts(self):
+        return self._db_artifacts
+    def __set_db_artifacts(self, artifacts):
+        self._db_artifacts = artifacts
+        self.is_dirty = True
+    db_artifacts = property(__get_db_artifacts, __set_db_artifacts)
+    def db_get_artifacts(self):
+        return self._db_artifacts
+    def db_add_artifact(self, artifact):
+        self.is_dirty = True
+        self._db_artifacts.append(artifact)
+        self.db_artifacts_id_index[artifact.db_id] = artifact
+    def db_change_artifact(self, artifact):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_artifacts)):
+            if self._db_artifacts[i].db_id == artifact.db_id:
+                self._db_artifacts[i] = artifact
+                found = True
+                break
+        if not found:
+            self._db_artifacts.append(artifact)
+        self.db_artifacts_id_index[artifact.db_id] = artifact
+    def db_delete_artifact(self, artifact):
+        self.is_dirty = True
+        for i in xrange(len(self._db_artifacts)):
+            if self._db_artifacts[i].db_id == artifact.db_id:
+                if not self._db_artifacts[i].is_new:
+                    self.db_deleted_artifacts.append(self._db_artifacts[i])
+                del self._db_artifacts[i]
+                break
+        del self.db_artifacts_id_index[artifact.db_id]
+    def db_get_artifact(self, key):
+        for i in xrange(len(self._db_artifacts)):
+            if self._db_artifacts[i].db_id == key:
+                return self._db_artifacts[i]
+        return None
+    def db_get_artifact_by_id(self, key):
+        return self.db_artifacts_id_index[key]
+    def db_has_artifact_with_id(self, key):
+        return key in self.db_artifacts_id_index
+    
+
+
+class DBPEParameter(object):
+
+    vtType = 'pe_parameter'
+
+    def __init__(self, id=None, pos=None, interpolator=None, value=None, dimension=None):
+        self._db_id = id
+        self._db_pos = pos
+        self._db_interpolator = interpolator
+        self._db_value = value
+        self._db_dimension = dimension
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPEParameter.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPEParameter(id=self._db_id,
+                           pos=self._db_pos,
+                           interpolator=self._db_interpolator,
+                           value=self._db_value,
+                           dimension=self._db_dimension)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPEParameter()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'pos' in class_dict:
+            res = class_dict['pos'](old_obj, trans_dict)
+            new_obj.db_pos = res
+        elif hasattr(old_obj, 'db_pos') and old_obj.db_pos is not None:
+            new_obj.db_pos = old_obj.db_pos
+        if 'interpolator' in class_dict:
+            res = class_dict['interpolator'](old_obj, trans_dict)
+            new_obj.db_interpolator = res
+        elif hasattr(old_obj, 'db_interpolator') and old_obj.db_interpolator is not None:
+            new_obj.db_interpolator = old_obj.db_interpolator
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        if 'dimension' in class_dict:
+            res = class_dict['dimension'](old_obj, trans_dict)
+            new_obj.db_dimension = res
+        elif hasattr(old_obj, 'db_dimension') and old_obj.db_dimension is not None:
+            new_obj.db_dimension = old_obj.db_dimension
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_pos(self):
+        return self._db_pos
+    def __set_db_pos(self, pos):
+        self._db_pos = pos
+        self.is_dirty = True
+    db_pos = property(__get_db_pos, __set_db_pos)
+    def db_add_pos(self, pos):
+        self._db_pos = pos
+    def db_change_pos(self, pos):
+        self._db_pos = pos
+    def db_delete_pos(self, pos):
+        self._db_pos = None
+    
+    def __get_db_interpolator(self):
+        return self._db_interpolator
+    def __set_db_interpolator(self, interpolator):
+        self._db_interpolator = interpolator
+        self.is_dirty = True
+    db_interpolator = property(__get_db_interpolator, __set_db_interpolator)
+    def db_add_interpolator(self, interpolator):
+        self._db_interpolator = interpolator
+    def db_change_interpolator(self, interpolator):
+        self._db_interpolator = interpolator
+    def db_delete_interpolator(self, interpolator):
+        self._db_interpolator = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def __get_db_dimension(self):
+        return self._db_dimension
+    def __set_db_dimension(self, dimension):
+        self._db_dimension = dimension
+        self.is_dirty = True
+    db_dimension = property(__get_db_dimension, __set_db_dimension)
+    def db_add_dimension(self, dimension):
+        self._db_dimension = dimension
+    def db_change_dimension(self, dimension):
+        self._db_dimension = dimension
+    def db_delete_dimension(self, dimension):
+        self._db_dimension = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBWorkflowExec(object):
+
+    vtType = 'workflow_exec'
+
+    def __init__(self, item_execs=None, id=None, user=None, ip=None, session=None, vt_version=None, ts_start=None, ts_end=None, parent_id=None, parent_type=None, parent_version=None, completed=None, name=None, annotations=None, machines=None):
+        self.db_deleted_item_execs = []
+        self.db_item_execs_id_index = {}
+        if item_execs is None:
+            self._db_item_execs = []
+        else:
+            self._db_item_execs = item_execs
+            for v in self._db_item_execs:
+                self.db_item_execs_id_index[v.db_id] = v
+        self._db_id = id
+        self._db_user = user
+        self._db_ip = ip
+        self._db_session = session
+        self._db_vt_version = vt_version
+        self._db_ts_start = ts_start
+        self._db_ts_end = ts_end
+        self._db_parent_id = parent_id
+        self._db_parent_type = parent_type
+        self._db_parent_version = parent_version
+        self._db_completed = completed
+        self._db_name = name
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+        self.db_deleted_machines = []
+        self.db_machines_id_index = {}
+        if machines is None:
+            self._db_machines = []
+        else:
+            self._db_machines = machines
+            for v in self._db_machines:
+                self.db_machines_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBWorkflowExec.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBWorkflowExec(id=self._db_id,
+                            user=self._db_user,
+                            ip=self._db_ip,
+                            session=self._db_session,
+                            vt_version=self._db_vt_version,
+                            ts_start=self._db_ts_start,
+                            ts_end=self._db_ts_end,
+                            parent_id=self._db_parent_id,
+                            parent_type=self._db_parent_type,
+                            parent_version=self._db_parent_version,
+                            completed=self._db_completed,
+                            name=self._db_name)
+        if self._db_item_execs is None:
+            cp._db_item_execs = []
+        else:
+            cp._db_item_execs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_item_execs]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_machines is None:
+            cp._db_machines = []
+        else:
+            cp._db_machines = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_machines]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_item_execs_id_index = dict((v.db_id, v) for v in cp._db_item_execs)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_machines_id_index = dict((v.db_id, v) for v in cp._db_machines)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBWorkflowExec()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'item_execs' in class_dict:
+            res = class_dict['item_execs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_item_exec(obj)
+        elif hasattr(old_obj, 'db_item_execs') and old_obj.db_item_execs is not None:
+            for obj in old_obj.db_item_execs:
+                if obj.vtType == 'module_exec':
+                    new_obj.db_add_item_exec(DBModuleExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'group_exec':
+                    new_obj.db_add_item_exec(DBGroupExec.update_version(obj, trans_dict))
+                elif obj.vtType == 'loop_exec':
+                    new_obj.db_add_item_exec(DBLoopExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_item_execs') and hasattr(new_obj, 'db_deleted_item_execs'):
+            for obj in old_obj.db_deleted_item_execs:
+                if obj.vtType == 'module_exec':
+                    n_obj = DBModuleExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'group_exec':
+                    n_obj = DBGroupExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+                elif obj.vtType == 'loop_exec':
+                    n_obj = DBLoopExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_item_execs.append(n_obj)
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        if 'ip' in class_dict:
+            res = class_dict['ip'](old_obj, trans_dict)
+            new_obj.db_ip = res
+        elif hasattr(old_obj, 'db_ip') and old_obj.db_ip is not None:
+            new_obj.db_ip = old_obj.db_ip
+        if 'session' in class_dict:
+            res = class_dict['session'](old_obj, trans_dict)
+            new_obj.db_session = res
+        elif hasattr(old_obj, 'db_session') and old_obj.db_session is not None:
+            new_obj.db_session = old_obj.db_session
+        if 'vt_version' in class_dict:
+            res = class_dict['vt_version'](old_obj, trans_dict)
+            new_obj.db_vt_version = res
+        elif hasattr(old_obj, 'db_vt_version') and old_obj.db_vt_version is not None:
+            new_obj.db_vt_version = old_obj.db_vt_version
+        if 'ts_start' in class_dict:
+            res = class_dict['ts_start'](old_obj, trans_dict)
+            new_obj.db_ts_start = res
+        elif hasattr(old_obj, 'db_ts_start') and old_obj.db_ts_start is not None:
+            new_obj.db_ts_start = old_obj.db_ts_start
+        if 'ts_end' in class_dict:
+            res = class_dict['ts_end'](old_obj, trans_dict)
+            new_obj.db_ts_end = res
+        elif hasattr(old_obj, 'db_ts_end') and old_obj.db_ts_end is not None:
+            new_obj.db_ts_end = old_obj.db_ts_end
+        if 'parent_id' in class_dict:
+            res = class_dict['parent_id'](old_obj, trans_dict)
+            new_obj.db_parent_id = res
+        elif hasattr(old_obj, 'db_parent_id') and old_obj.db_parent_id is not None:
+            new_obj.db_parent_id = old_obj.db_parent_id
+        if 'parent_type' in class_dict:
+            res = class_dict['parent_type'](old_obj, trans_dict)
+            new_obj.db_parent_type = res
+        elif hasattr(old_obj, 'db_parent_type') and old_obj.db_parent_type is not None:
+            new_obj.db_parent_type = old_obj.db_parent_type
+        if 'parent_version' in class_dict:
+            res = class_dict['parent_version'](old_obj, trans_dict)
+            new_obj.db_parent_version = res
+        elif hasattr(old_obj, 'db_parent_version') and old_obj.db_parent_version is not None:
+            new_obj.db_parent_version = old_obj.db_parent_version
+        if 'completed' in class_dict:
+            res = class_dict['completed'](old_obj, trans_dict)
+            new_obj.db_completed = res
+        elif hasattr(old_obj, 'db_completed') and old_obj.db_completed is not None:
+            new_obj.db_completed = old_obj.db_completed
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'machines' in class_dict:
+            res = class_dict['machines'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_machine(obj)
+        elif hasattr(old_obj, 'db_machines') and old_obj.db_machines is not None:
+            for obj in old_obj.db_machines:
+                new_obj.db_add_machine(DBMachine.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_machines') and hasattr(new_obj, 'db_deleted_machines'):
+            for obj in old_obj.db_deleted_machines:
+                n_obj = DBMachine.update_version(obj, trans_dict)
+                new_obj.db_deleted_machines.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_machines:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_machine(child)
+        to_del = []
+        for child in self.db_item_execs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_item_exec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_machines)
+        children.extend(self.db_deleted_item_execs)
+        if remove:
+            self.db_deleted_annotations = []
+            self.db_deleted_machines = []
+            self.db_deleted_item_execs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_machines:
+            if child.has_changes():
+                return True
+        for child in self._db_item_execs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_item_execs(self):
+        return self._db_item_execs
+    def __set_db_item_execs(self, item_execs):
+        self._db_item_execs = item_execs
+        self.is_dirty = True
+    db_item_execs = property(__get_db_item_execs, __set_db_item_execs)
+    def db_get_item_execs(self):
+        return self._db_item_execs
+    def db_add_item_exec(self, item_exec):
+        self.is_dirty = True
+        self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_change_item_exec(self, item_exec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                self._db_item_execs[i] = item_exec
+                found = True
+                break
+        if not found:
+            self._db_item_execs.append(item_exec)
+        self.db_item_execs_id_index[item_exec.db_id] = item_exec
+    def db_delete_item_exec(self, item_exec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == item_exec.db_id:
+                if not self._db_item_execs[i].is_new:
+                    self.db_deleted_item_execs.append(self._db_item_execs[i])
+                del self._db_item_execs[i]
+                break
+        del self.db_item_execs_id_index[item_exec.db_id]
+    def db_get_item_exec(self, key):
+        for i in xrange(len(self._db_item_execs)):
+            if self._db_item_execs[i].db_id == key:
+                return self._db_item_execs[i]
+        return None
+    def db_get_item_exec_by_id(self, key):
+        return self.db_item_execs_id_index[key]
+    def db_has_item_exec_with_id(self, key):
+        return key in self.db_item_execs_id_index
+    
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def __get_db_ip(self):
+        return self._db_ip
+    def __set_db_ip(self, ip):
+        self._db_ip = ip
+        self.is_dirty = True
+    db_ip = property(__get_db_ip, __set_db_ip)
+    def db_add_ip(self, ip):
+        self._db_ip = ip
+    def db_change_ip(self, ip):
+        self._db_ip = ip
+    def db_delete_ip(self, ip):
+        self._db_ip = None
+    
+    def __get_db_session(self):
+        return self._db_session
+    def __set_db_session(self, session):
+        self._db_session = session
+        self.is_dirty = True
+    db_session = property(__get_db_session, __set_db_session)
+    def db_add_session(self, session):
+        self._db_session = session
+    def db_change_session(self, session):
+        self._db_session = session
+    def db_delete_session(self, session):
+        self._db_session = None
+    
+    def __get_db_vt_version(self):
+        return self._db_vt_version
+    def __set_db_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+        self.is_dirty = True
+    db_vt_version = property(__get_db_vt_version, __set_db_vt_version)
+    def db_add_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+    def db_change_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+    def db_delete_vt_version(self, vt_version):
+        self._db_vt_version = None
+    
+    def __get_db_ts_start(self):
+        return self._db_ts_start
+    def __set_db_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+        self.is_dirty = True
+    db_ts_start = property(__get_db_ts_start, __set_db_ts_start)
+    def db_add_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_change_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_delete_ts_start(self, ts_start):
+        self._db_ts_start = None
+    
+    def __get_db_ts_end(self):
+        return self._db_ts_end
+    def __set_db_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+        self.is_dirty = True
+    db_ts_end = property(__get_db_ts_end, __set_db_ts_end)
+    def db_add_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_change_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_delete_ts_end(self, ts_end):
+        self._db_ts_end = None
+    
+    def __get_db_parent_id(self):
+        return self._db_parent_id
+    def __set_db_parent_id(self, parent_id):
+        self._db_parent_id = parent_id
+        self.is_dirty = True
+    db_parent_id = property(__get_db_parent_id, __set_db_parent_id)
+    def db_add_parent_id(self, parent_id):
+        self._db_parent_id = parent_id
+    def db_change_parent_id(self, parent_id):
+        self._db_parent_id = parent_id
+    def db_delete_parent_id(self, parent_id):
+        self._db_parent_id = None
+    
+    def __get_db_parent_type(self):
+        return self._db_parent_type
+    def __set_db_parent_type(self, parent_type):
+        self._db_parent_type = parent_type
+        self.is_dirty = True
+    db_parent_type = property(__get_db_parent_type, __set_db_parent_type)
+    def db_add_parent_type(self, parent_type):
+        self._db_parent_type = parent_type
+    def db_change_parent_type(self, parent_type):
+        self._db_parent_type = parent_type
+    def db_delete_parent_type(self, parent_type):
+        self._db_parent_type = None
+    
+    def __get_db_parent_version(self):
+        return self._db_parent_version
+    def __set_db_parent_version(self, parent_version):
+        self._db_parent_version = parent_version
+        self.is_dirty = True
+    db_parent_version = property(__get_db_parent_version, __set_db_parent_version)
+    def db_add_parent_version(self, parent_version):
+        self._db_parent_version = parent_version
+    def db_change_parent_version(self, parent_version):
+        self._db_parent_version = parent_version
+    def db_delete_parent_version(self, parent_version):
+        self._db_parent_version = None
+    
+    def __get_db_completed(self):
+        return self._db_completed
+    def __set_db_completed(self, completed):
+        self._db_completed = completed
+        self.is_dirty = True
+    db_completed = property(__get_db_completed, __set_db_completed)
+    def db_add_completed(self, completed):
+        self._db_completed = completed
+    def db_change_completed(self, completed):
+        self._db_completed = completed
+    def db_delete_completed(self, completed):
+        self._db_completed = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    
+    def __get_db_machines(self):
+        return self._db_machines
+    def __set_db_machines(self, machines):
+        self._db_machines = machines
+        self.is_dirty = True
+    db_machines = property(__get_db_machines, __set_db_machines)
+    def db_get_machines(self):
+        return self._db_machines
+    def db_add_machine(self, machine):
+        self.is_dirty = True
+        self._db_machines.append(machine)
+        self.db_machines_id_index[machine.db_id] = machine
+    def db_change_machine(self, machine):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_machines)):
+            if self._db_machines[i].db_id == machine.db_id:
+                self._db_machines[i] = machine
+                found = True
+                break
+        if not found:
+            self._db_machines.append(machine)
+        self.db_machines_id_index[machine.db_id] = machine
+    def db_delete_machine(self, machine):
+        self.is_dirty = True
+        for i in xrange(len(self._db_machines)):
+            if self._db_machines[i].db_id == machine.db_id:
+                if not self._db_machines[i].is_new:
+                    self.db_deleted_machines.append(self._db_machines[i])
+                del self._db_machines[i]
+                break
+        del self.db_machines_id_index[machine.db_id]
+    def db_get_machine(self, key):
+        for i in xrange(len(self._db_machines)):
+            if self._db_machines[i].db_id == key:
+                return self._db_machines[i]
+        return None
+    def db_get_machine_by_id(self, key):
+        return self.db_machines_id_index[key]
+    def db_has_machine_with_id(self, key):
+        return key in self.db_machines_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBLocation(object):
+
+    vtType = 'location'
+
+    def __init__(self, id=None, x=None, y=None):
+        self._db_id = id
+        self._db_x = x
+        self._db_y = y
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBLocation.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBLocation(id=self._db_id,
+                        x=self._db_x,
+                        y=self._db_y)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBLocation()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'x' in class_dict:
+            res = class_dict['x'](old_obj, trans_dict)
+            new_obj.db_x = res
+        elif hasattr(old_obj, 'db_x') and old_obj.db_x is not None:
+            new_obj.db_x = old_obj.db_x
+        if 'y' in class_dict:
+            res = class_dict['y'](old_obj, trans_dict)
+            new_obj.db_y = res
+        elif hasattr(old_obj, 'db_y') and old_obj.db_y is not None:
+            new_obj.db_y = old_obj.db_y
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_x(self):
+        return self._db_x
+    def __set_db_x(self, x):
+        self._db_x = x
+        self.is_dirty = True
+    db_x = property(__get_db_x, __set_db_x)
+    def db_add_x(self, x):
+        self._db_x = x
+    def db_change_x(self, x):
+        self._db_x = x
+    def db_delete_x(self, x):
+        self._db_x = None
+    
+    def __get_db_y(self):
+        return self._db_y
+    def __set_db_y(self, y):
+        self._db_y = y
+        self.is_dirty = True
+    db_y = property(__get_db_y, __set_db_y)
+    def db_add_y(self, y):
+        self._db_y = y
+    def db_change_y(self, y):
+        self._db_y = y
+    def db_delete_y(self, y):
+        self._db_y = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBFunction(object):
+
+    vtType = 'function'
+
+    def __init__(self, id=None, pos=None, name=None, parameters=None):
+        self._db_id = id
+        self._db_pos = pos
+        self._db_name = name
+        self.db_deleted_parameters = []
+        self.db_parameters_id_index = {}
+        if parameters is None:
+            self._db_parameters = []
+        else:
+            self._db_parameters = parameters
+            for v in self._db_parameters:
+                self.db_parameters_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBFunction.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBFunction(id=self._db_id,
+                        pos=self._db_pos,
+                        name=self._db_name)
+        if self._db_parameters is None:
+            cp._db_parameters = []
+        else:
+            cp._db_parameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_parameters]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_parameters_id_index = dict((v.db_id, v) for v in cp._db_parameters)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBFunction()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'pos' in class_dict:
+            res = class_dict['pos'](old_obj, trans_dict)
+            new_obj.db_pos = res
+        elif hasattr(old_obj, 'db_pos') and old_obj.db_pos is not None:
+            new_obj.db_pos = old_obj.db_pos
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'parameters' in class_dict:
+            res = class_dict['parameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_parameter(obj)
+        elif hasattr(old_obj, 'db_parameters') and old_obj.db_parameters is not None:
+            for obj in old_obj.db_parameters:
+                new_obj.db_add_parameter(DBParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_parameters') and hasattr(new_obj, 'db_deleted_parameters'):
+            for obj in old_obj.db_deleted_parameters:
+                n_obj = DBParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_parameters.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_parameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_parameter(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_parameters)
+        if remove:
+            self.db_deleted_parameters = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_parameters:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_pos(self):
+        return self._db_pos
+    def __set_db_pos(self, pos):
+        self._db_pos = pos
+        self.is_dirty = True
+    db_pos = property(__get_db_pos, __set_db_pos)
+    def db_add_pos(self, pos):
+        self._db_pos = pos
+    def db_change_pos(self, pos):
+        self._db_pos = pos
+    def db_delete_pos(self, pos):
+        self._db_pos = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_parameters(self):
+        return self._db_parameters
+    def __set_db_parameters(self, parameters):
+        self._db_parameters = parameters
+        self.is_dirty = True
+    db_parameters = property(__get_db_parameters, __set_db_parameters)
+    def db_get_parameters(self):
+        return self._db_parameters
+    def db_add_parameter(self, parameter):
+        self.is_dirty = True
+        self._db_parameters.append(parameter)
+        self.db_parameters_id_index[parameter.db_id] = parameter
+    def db_change_parameter(self, parameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == parameter.db_id:
+                self._db_parameters[i] = parameter
+                found = True
+                break
+        if not found:
+            self._db_parameters.append(parameter)
+        self.db_parameters_id_index[parameter.db_id] = parameter
+    def db_delete_parameter(self, parameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == parameter.db_id:
+                if not self._db_parameters[i].is_new:
+                    self.db_deleted_parameters.append(self._db_parameters[i])
+                del self._db_parameters[i]
+                break
+        del self.db_parameters_id_index[parameter.db_id]
+    def db_get_parameter(self, key):
+        for i in xrange(len(self._db_parameters)):
+            if self._db_parameters[i].db_id == key:
+                return self._db_parameters[i]
+        return None
+    def db_get_parameter_by_id(self, key):
+        return self.db_parameters_id_index[key]
+    def db_has_parameter_with_id(self, key):
+        return key in self.db_parameters_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBActionAnnotation(object):
+
+    vtType = 'actionAnnotation'
+
+    def __init__(self, id=None, key=None, value=None, action_id=None, date=None, user=None):
+        self._db_id = id
+        self._db_key = key
+        self._db_value = value
+        self._db_action_id = action_id
+        self._db_date = date
+        self._db_user = user
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBActionAnnotation.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBActionAnnotation(id=self._db_id,
+                                key=self._db_key,
+                                value=self._db_value,
+                                action_id=self._db_action_id,
+                                date=self._db_date,
+                                user=self._db_user)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_action_id') and ('action', self._db_action_id) in id_remap:
+                cp._db_action_id = id_remap[('action', self._db_action_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBActionAnnotation()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'key' in class_dict:
+            res = class_dict['key'](old_obj, trans_dict)
+            new_obj.db_key = res
+        elif hasattr(old_obj, 'db_key') and old_obj.db_key is not None:
+            new_obj.db_key = old_obj.db_key
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        if 'action_id' in class_dict:
+            res = class_dict['action_id'](old_obj, trans_dict)
+            new_obj.db_action_id = res
+        elif hasattr(old_obj, 'db_action_id') and old_obj.db_action_id is not None:
+            new_obj.db_action_id = old_obj.db_action_id
+        if 'date' in class_dict:
+            res = class_dict['date'](old_obj, trans_dict)
+            new_obj.db_date = res
+        elif hasattr(old_obj, 'db_date') and old_obj.db_date is not None:
+            new_obj.db_date = old_obj.db_date
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_key(self):
+        return self._db_key
+    def __set_db_key(self, key):
+        self._db_key = key
+        self.is_dirty = True
+    db_key = property(__get_db_key, __set_db_key)
+    def db_add_key(self, key):
+        self._db_key = key
+    def db_change_key(self, key):
+        self._db_key = key
+    def db_delete_key(self, key):
+        self._db_key = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def __get_db_action_id(self):
+        return self._db_action_id
+    def __set_db_action_id(self, action_id):
+        self._db_action_id = action_id
+        self.is_dirty = True
+    db_action_id = property(__get_db_action_id, __set_db_action_id)
+    def db_add_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_change_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_delete_action_id(self, action_id):
+        self._db_action_id = None
+    
+    def __get_db_date(self):
+        return self._db_date
+    def __set_db_date(self, date):
+        self._db_date = date
+        self.is_dirty = True
+    db_date = property(__get_db_date, __set_db_date)
+    def db_add_date(self, date):
+        self._db_date = date
+    def db_change_date(self, date):
+        self._db_date = date
+    def db_delete_date(self, date):
+        self._db_date = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvActivity(object):
+
+    vtType = 'prov_activity'
+
+    def __init__(self, id=None, startTime=None, endTime=None, vt_id=None, vt_type=None, vt_cached=None, vt_completed=None, vt_machine_id=None, vt_error=None, is_part_of=None):
+        self._db_id = id
+        self._db_startTime = startTime
+        self._db_endTime = endTime
+        self._db_vt_id = vt_id
+        self._db_vt_type = vt_type
+        self._db_vt_cached = vt_cached
+        self._db_vt_completed = vt_completed
+        self._db_vt_machine_id = vt_machine_id
+        self._db_vt_error = vt_error
+        self.db_deleted_is_part_of = []
+        self._db_is_part_of = is_part_of
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvActivity.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvActivity(id=self._db_id,
+                            startTime=self._db_startTime,
+                            endTime=self._db_endTime,
+                            vt_id=self._db_vt_id,
+                            vt_type=self._db_vt_type,
+                            vt_cached=self._db_vt_cached,
+                            vt_completed=self._db_vt_completed,
+                            vt_machine_id=self._db_vt_machine_id,
+                            vt_error=self._db_vt_error)
+        if self._db_is_part_of is not None:
+            cp._db_is_part_of = self._db_is_part_of.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvActivity()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'startTime' in class_dict:
+            res = class_dict['startTime'](old_obj, trans_dict)
+            new_obj.db_startTime = res
+        elif hasattr(old_obj, 'db_startTime') and old_obj.db_startTime is not None:
+            new_obj.db_startTime = old_obj.db_startTime
+        if 'endTime' in class_dict:
+            res = class_dict['endTime'](old_obj, trans_dict)
+            new_obj.db_endTime = res
+        elif hasattr(old_obj, 'db_endTime') and old_obj.db_endTime is not None:
+            new_obj.db_endTime = old_obj.db_endTime
+        if 'vt_id' in class_dict:
+            res = class_dict['vt_id'](old_obj, trans_dict)
+            new_obj.db_vt_id = res
+        elif hasattr(old_obj, 'db_vt_id') and old_obj.db_vt_id is not None:
+            new_obj.db_vt_id = old_obj.db_vt_id
+        if 'vt_type' in class_dict:
+            res = class_dict['vt_type'](old_obj, trans_dict)
+            new_obj.db_vt_type = res
+        elif hasattr(old_obj, 'db_vt_type') and old_obj.db_vt_type is not None:
+            new_obj.db_vt_type = old_obj.db_vt_type
+        if 'vt_cached' in class_dict:
+            res = class_dict['vt_cached'](old_obj, trans_dict)
+            new_obj.db_vt_cached = res
+        elif hasattr(old_obj, 'db_vt_cached') and old_obj.db_vt_cached is not None:
+            new_obj.db_vt_cached = old_obj.db_vt_cached
+        if 'vt_completed' in class_dict:
+            res = class_dict['vt_completed'](old_obj, trans_dict)
+            new_obj.db_vt_completed = res
+        elif hasattr(old_obj, 'db_vt_completed') and old_obj.db_vt_completed is not None:
+            new_obj.db_vt_completed = old_obj.db_vt_completed
+        if 'vt_machine_id' in class_dict:
+            res = class_dict['vt_machine_id'](old_obj, trans_dict)
+            new_obj.db_vt_machine_id = res
+        elif hasattr(old_obj, 'db_vt_machine_id') and old_obj.db_vt_machine_id is not None:
+            new_obj.db_vt_machine_id = old_obj.db_vt_machine_id
+        if 'vt_error' in class_dict:
+            res = class_dict['vt_error'](old_obj, trans_dict)
+            new_obj.db_vt_error = res
+        elif hasattr(old_obj, 'db_vt_error') and old_obj.db_vt_error is not None:
+            new_obj.db_vt_error = old_obj.db_vt_error
+        if 'is_part_of' in class_dict:
+            res = class_dict['is_part_of'](old_obj, trans_dict)
+            new_obj.db_is_part_of = res
+        elif hasattr(old_obj, 'db_is_part_of') and old_obj.db_is_part_of is not None:
+            obj = old_obj.db_is_part_of
+            new_obj.db_add_is_part_of(DBIsPartOf.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_is_part_of') and hasattr(new_obj, 'db_deleted_is_part_of'):
+            for obj in old_obj.db_deleted_is_part_of:
+                n_obj = DBIsPartOf.update_version(obj, trans_dict)
+                new_obj.db_deleted_is_part_of.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_is_part_of is not None:
+            children.extend(self._db_is_part_of.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_is_part_of = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_is_part_of)
+        if remove:
+            self.db_deleted_is_part_of = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_is_part_of is not None and self._db_is_part_of.has_changes():
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_startTime(self):
+        return self._db_startTime
+    def __set_db_startTime(self, startTime):
+        self._db_startTime = startTime
+        self.is_dirty = True
+    db_startTime = property(__get_db_startTime, __set_db_startTime)
+    def db_add_startTime(self, startTime):
+        self._db_startTime = startTime
+    def db_change_startTime(self, startTime):
+        self._db_startTime = startTime
+    def db_delete_startTime(self, startTime):
+        self._db_startTime = None
+    
+    def __get_db_endTime(self):
+        return self._db_endTime
+    def __set_db_endTime(self, endTime):
+        self._db_endTime = endTime
+        self.is_dirty = True
+    db_endTime = property(__get_db_endTime, __set_db_endTime)
+    def db_add_endTime(self, endTime):
+        self._db_endTime = endTime
+    def db_change_endTime(self, endTime):
+        self._db_endTime = endTime
+    def db_delete_endTime(self, endTime):
+        self._db_endTime = None
+    
+    def __get_db_vt_id(self):
+        return self._db_vt_id
+    def __set_db_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+        self.is_dirty = True
+    db_vt_id = property(__get_db_vt_id, __set_db_vt_id)
+    def db_add_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_change_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_delete_vt_id(self, vt_id):
+        self._db_vt_id = None
+    
+    def __get_db_vt_type(self):
+        return self._db_vt_type
+    def __set_db_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+        self.is_dirty = True
+    db_vt_type = property(__get_db_vt_type, __set_db_vt_type)
+    def db_add_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+    def db_change_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+    def db_delete_vt_type(self, vt_type):
+        self._db_vt_type = None
+    
+    def __get_db_vt_cached(self):
+        return self._db_vt_cached
+    def __set_db_vt_cached(self, vt_cached):
+        self._db_vt_cached = vt_cached
+        self.is_dirty = True
+    db_vt_cached = property(__get_db_vt_cached, __set_db_vt_cached)
+    def db_add_vt_cached(self, vt_cached):
+        self._db_vt_cached = vt_cached
+    def db_change_vt_cached(self, vt_cached):
+        self._db_vt_cached = vt_cached
+    def db_delete_vt_cached(self, vt_cached):
+        self._db_vt_cached = None
+    
+    def __get_db_vt_completed(self):
+        return self._db_vt_completed
+    def __set_db_vt_completed(self, vt_completed):
+        self._db_vt_completed = vt_completed
+        self.is_dirty = True
+    db_vt_completed = property(__get_db_vt_completed, __set_db_vt_completed)
+    def db_add_vt_completed(self, vt_completed):
+        self._db_vt_completed = vt_completed
+    def db_change_vt_completed(self, vt_completed):
+        self._db_vt_completed = vt_completed
+    def db_delete_vt_completed(self, vt_completed):
+        self._db_vt_completed = None
+    
+    def __get_db_vt_machine_id(self):
+        return self._db_vt_machine_id
+    def __set_db_vt_machine_id(self, vt_machine_id):
+        self._db_vt_machine_id = vt_machine_id
+        self.is_dirty = True
+    db_vt_machine_id = property(__get_db_vt_machine_id, __set_db_vt_machine_id)
+    def db_add_vt_machine_id(self, vt_machine_id):
+        self._db_vt_machine_id = vt_machine_id
+    def db_change_vt_machine_id(self, vt_machine_id):
+        self._db_vt_machine_id = vt_machine_id
+    def db_delete_vt_machine_id(self, vt_machine_id):
+        self._db_vt_machine_id = None
+    
+    def __get_db_vt_error(self):
+        return self._db_vt_error
+    def __set_db_vt_error(self, vt_error):
+        self._db_vt_error = vt_error
+        self.is_dirty = True
+    db_vt_error = property(__get_db_vt_error, __set_db_vt_error)
+    def db_add_vt_error(self, vt_error):
+        self._db_vt_error = vt_error
+    def db_change_vt_error(self, vt_error):
+        self._db_vt_error = vt_error
+    def db_delete_vt_error(self, vt_error):
+        self._db_vt_error = None
+    
+    def __get_db_is_part_of(self):
+        return self._db_is_part_of
+    def __set_db_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+        self.is_dirty = True
+    db_is_part_of = property(__get_db_is_part_of, __set_db_is_part_of)
+    def db_add_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+    def db_change_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+    def db_delete_is_part_of(self, is_part_of):
+        if not self.is_new:
+            self.db_deleted_is_part_of.append(self._db_is_part_of)
+        self._db_is_part_of = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvUsage(object):
+
+    vtType = 'prov_usage'
+
+    def __init__(self, prov_activity=None, prov_entity=None, prov_role=None):
+        self.db_deleted_prov_activity = []
+        self._db_prov_activity = prov_activity
+        self.db_deleted_prov_entity = []
+        self._db_prov_entity = prov_entity
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvUsage.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvUsage(prov_role=self._db_prov_role)
+        if self._db_prov_activity is not None:
+            cp._db_prov_activity = self._db_prov_activity.do_copy(new_ids, id_scope, id_remap)
+        if self._db_prov_entity is not None:
+            cp._db_prov_entity = self._db_prov_entity.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvUsage()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_activity' in class_dict:
+            res = class_dict['prov_activity'](old_obj, trans_dict)
+            new_obj.db_prov_activity = res
+        elif hasattr(old_obj, 'db_prov_activity') and old_obj.db_prov_activity is not None:
+            obj = old_obj.db_prov_activity
+            new_obj.db_add_prov_activity(DBRefProvActivity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_activity') and hasattr(new_obj, 'db_deleted_prov_activity'):
+            for obj in old_obj.db_deleted_prov_activity:
+                n_obj = DBRefProvActivity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_activity.append(n_obj)
+        if 'prov_entity' in class_dict:
+            res = class_dict['prov_entity'](old_obj, trans_dict)
+            new_obj.db_prov_entity = res
+        elif hasattr(old_obj, 'db_prov_entity') and old_obj.db_prov_entity is not None:
+            obj = old_obj.db_prov_entity
+            new_obj.db_add_prov_entity(DBRefProvEntity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_entity') and hasattr(new_obj, 'db_deleted_prov_entity'):
+            for obj in old_obj.db_deleted_prov_entity:
+                n_obj = DBRefProvEntity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_entity.append(n_obj)
+        if 'prov_role' in class_dict:
+            res = class_dict['prov_role'](old_obj, trans_dict)
+            new_obj.db_prov_role = res
+        elif hasattr(old_obj, 'db_prov_role') and old_obj.db_prov_role is not None:
+            new_obj.db_prov_role = old_obj.db_prov_role
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_prov_activity is not None:
+            children.extend(self._db_prov_activity.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_activity = None
+        if self._db_prov_entity is not None:
+            children.extend(self._db_prov_entity.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_entity = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_prov_activity)
+        children.extend(self.db_deleted_prov_entity)
+        if remove:
+            self.db_deleted_prov_activity = []
+            self.db_deleted_prov_entity = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_prov_activity is not None and self._db_prov_activity.has_changes():
+            return True
+        if self._db_prov_entity is not None and self._db_prov_entity.has_changes():
+            return True
+        return False
+    def __get_db_prov_activity(self):
+        return self._db_prov_activity
+    def __set_db_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+        self.is_dirty = True
+    db_prov_activity = property(__get_db_prov_activity, __set_db_prov_activity)
+    def db_add_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_change_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_delete_prov_activity(self, prov_activity):
+        if not self.is_new:
+            self.db_deleted_prov_activity.append(self._db_prov_activity)
+        self._db_prov_activity = None
+    
+    def __get_db_prov_entity(self):
+        return self._db_prov_entity
+    def __set_db_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+        self.is_dirty = True
+    db_prov_entity = property(__get_db_prov_entity, __set_db_prov_entity)
+    def db_add_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+    def db_change_prov_entity(self, prov_entity):
+        self._db_prov_entity = prov_entity
+    def db_delete_prov_entity(self, prov_entity):
+        if not self.is_new:
+            self.db_deleted_prov_entity.append(self._db_prov_entity)
+        self._db_prov_entity = None
+    
+    def __get_db_prov_role(self):
+        return self._db_prov_role
+    def __set_db_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+    db_prov_role = property(__get_db_prov_role, __set_db_prov_role)
+    def db_add_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_change_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_delete_prov_role(self, prov_role):
+        self._db_prov_role = None
+    
+
+
+class DBOpmArtifactIdEffect(object):
+
+    vtType = 'opm_artifact_id_effect'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmArtifactIdEffect.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmArtifactIdEffect(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_artifact', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_artifact', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmArtifactIdEffect()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBOpmGraph(object):
+
+    vtType = 'opm_graph'
+
+    def __init__(self, accounts=None, processes=None, artifacts=None, agents=None, dependencies=None):
+        self.db_deleted_accounts = []
+        self._db_accounts = accounts
+        self.db_deleted_processes = []
+        self._db_processes = processes
+        self.db_deleted_artifacts = []
+        self._db_artifacts = artifacts
+        self.db_deleted_agents = []
+        self._db_agents = agents
+        self.db_deleted_dependencies = []
+        self._db_dependencies = dependencies
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmGraph.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmGraph()
+        if self._db_accounts is not None:
+            cp._db_accounts = self._db_accounts.do_copy(new_ids, id_scope, id_remap)
+        if self._db_processes is not None:
+            cp._db_processes = self._db_processes.do_copy(new_ids, id_scope, id_remap)
+        if self._db_artifacts is not None:
+            cp._db_artifacts = self._db_artifacts.do_copy(new_ids, id_scope, id_remap)
+        if self._db_agents is not None:
+            cp._db_agents = self._db_agents.do_copy(new_ids, id_scope, id_remap)
+        if self._db_dependencies is not None:
+            cp._db_dependencies = self._db_dependencies.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmGraph()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            new_obj.db_accounts = res
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            obj = old_obj.db_accounts
+            new_obj.db_add_accounts(DBOpmAccounts.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccounts.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'processes' in class_dict:
+            res = class_dict['processes'](old_obj, trans_dict)
+            new_obj.db_processes = res
+        elif hasattr(old_obj, 'db_processes') and old_obj.db_processes is not None:
+            obj = old_obj.db_processes
+            new_obj.db_add_processes(DBOpmProcesses.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_processes') and hasattr(new_obj, 'db_deleted_processes'):
+            for obj in old_obj.db_deleted_processes:
+                n_obj = DBOpmProcesses.update_version(obj, trans_dict)
+                new_obj.db_deleted_processes.append(n_obj)
+        if 'artifacts' in class_dict:
+            res = class_dict['artifacts'](old_obj, trans_dict)
+            new_obj.db_artifacts = res
+        elif hasattr(old_obj, 'db_artifacts') and old_obj.db_artifacts is not None:
+            obj = old_obj.db_artifacts
+            new_obj.db_add_artifacts(DBOpmArtifacts.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_artifacts') and hasattr(new_obj, 'db_deleted_artifacts'):
+            for obj in old_obj.db_deleted_artifacts:
+                n_obj = DBOpmArtifacts.update_version(obj, trans_dict)
+                new_obj.db_deleted_artifacts.append(n_obj)
+        if 'agents' in class_dict:
+            res = class_dict['agents'](old_obj, trans_dict)
+            new_obj.db_agents = res
+        elif hasattr(old_obj, 'db_agents') and old_obj.db_agents is not None:
+            obj = old_obj.db_agents
+            new_obj.db_add_agents(DBOpmAgents.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_agents') and hasattr(new_obj, 'db_deleted_agents'):
+            for obj in old_obj.db_deleted_agents:
+                n_obj = DBOpmAgents.update_version(obj, trans_dict)
+                new_obj.db_deleted_agents.append(n_obj)
+        if 'dependencies' in class_dict:
+            res = class_dict['dependencies'](old_obj, trans_dict)
+            new_obj.db_dependencies = res
+        elif hasattr(old_obj, 'db_dependencies') and old_obj.db_dependencies is not None:
+            obj = old_obj.db_dependencies
+            new_obj.db_add_dependencies(DBOpmDependencies.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_dependencies') and hasattr(new_obj, 'db_deleted_dependencies'):
+            for obj in old_obj.db_deleted_dependencies:
+                n_obj = DBOpmDependencies.update_version(obj, trans_dict)
+                new_obj.db_deleted_dependencies.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_accounts is not None:
+            children.extend(self._db_accounts.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_accounts = None
+        if self._db_processes is not None:
+            children.extend(self._db_processes.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_processes = None
+        if self._db_artifacts is not None:
+            children.extend(self._db_artifacts.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_artifacts = None
+        if self._db_agents is not None:
+            children.extend(self._db_agents.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_agents = None
+        if self._db_dependencies is not None:
+            children.extend(self._db_dependencies.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_dependencies = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_processes)
+        children.extend(self.db_deleted_artifacts)
+        children.extend(self.db_deleted_agents)
+        children.extend(self.db_deleted_dependencies)
+        if remove:
+            self.db_deleted_accounts = []
+            self.db_deleted_processes = []
+            self.db_deleted_artifacts = []
+            self.db_deleted_agents = []
+            self.db_deleted_dependencies = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_accounts is not None and self._db_accounts.has_changes():
+            return True
+        if self._db_processes is not None and self._db_processes.has_changes():
+            return True
+        if self._db_artifacts is not None and self._db_artifacts.has_changes():
+            return True
+        if self._db_agents is not None and self._db_agents.has_changes():
+            return True
+        if self._db_dependencies is not None and self._db_dependencies.has_changes():
+            return True
+        return False
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_add_accounts(self, accounts):
+        self._db_accounts = accounts
+    def db_change_accounts(self, accounts):
+        self._db_accounts = accounts
+    def db_delete_accounts(self, accounts):
+        if not self.is_new:
+            self.db_deleted_accounts.append(self._db_accounts)
+        self._db_accounts = None
+    
+    def __get_db_processes(self):
+        return self._db_processes
+    def __set_db_processes(self, processes):
+        self._db_processes = processes
+        self.is_dirty = True
+    db_processes = property(__get_db_processes, __set_db_processes)
+    def db_add_processes(self, processes):
+        self._db_processes = processes
+    def db_change_processes(self, processes):
+        self._db_processes = processes
+    def db_delete_processes(self, processes):
+        if not self.is_new:
+            self.db_deleted_processes.append(self._db_processes)
+        self._db_processes = None
+    
+    def __get_db_artifacts(self):
+        return self._db_artifacts
+    def __set_db_artifacts(self, artifacts):
+        self._db_artifacts = artifacts
+        self.is_dirty = True
+    db_artifacts = property(__get_db_artifacts, __set_db_artifacts)
+    def db_add_artifacts(self, artifacts):
+        self._db_artifacts = artifacts
+    def db_change_artifacts(self, artifacts):
+        self._db_artifacts = artifacts
+    def db_delete_artifacts(self, artifacts):
+        if not self.is_new:
+            self.db_deleted_artifacts.append(self._db_artifacts)
+        self._db_artifacts = None
+    
+    def __get_db_agents(self):
+        return self._db_agents
+    def __set_db_agents(self, agents):
+        self._db_agents = agents
+        self.is_dirty = True
+    db_agents = property(__get_db_agents, __set_db_agents)
+    def db_add_agents(self, agents):
+        self._db_agents = agents
+    def db_change_agents(self, agents):
+        self._db_agents = agents
+    def db_delete_agents(self, agents):
+        if not self.is_new:
+            self.db_deleted_agents.append(self._db_agents)
+        self._db_agents = None
+    
+    def __get_db_dependencies(self):
+        return self._db_dependencies
+    def __set_db_dependencies(self, dependencies):
+        self._db_dependencies = dependencies
+        self.is_dirty = True
+    db_dependencies = property(__get_db_dependencies, __set_db_dependencies)
+    def db_add_dependencies(self, dependencies):
+        self._db_dependencies = dependencies
+    def db_change_dependencies(self, dependencies):
+        self._db_dependencies = dependencies
+    def db_delete_dependencies(self, dependencies):
+        if not self.is_new:
+            self.db_deleted_dependencies.append(self._db_dependencies)
+        self._db_dependencies = None
+    
+
+
+class DBIsPartOf(object):
+
+    vtType = 'is_part_of'
+
+    def __init__(self, prov_ref=None):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBIsPartOf.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBIsPartOf(prov_ref=self._db_prov_ref)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBIsPartOf()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_ref' in class_dict:
+            res = class_dict['prov_ref'](old_obj, trans_dict)
+            new_obj.db_prov_ref = res
+        elif hasattr(old_obj, 'db_prov_ref') and old_obj.db_prov_ref is not None:
+            new_obj.db_prov_ref = old_obj.db_prov_ref
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_prov_ref(self):
+        return self._db_prov_ref
+    def __set_db_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+    db_prov_ref = property(__get_db_prov_ref, __set_db_prov_ref)
+    def db_add_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_change_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_delete_prov_ref(self, prov_ref):
+        self._db_prov_ref = None
+    
+
+
+class DBOpmWasDerivedFrom(object):
+
+    vtType = 'opm_was_derived_from'
+
+    def __init__(self, effect=None, role=None, cause=None, accounts=None, opm_times=None):
+        self.db_deleted_effect = []
+        self._db_effect = effect
+        self.db_deleted_role = []
+        self._db_role = role
+        self.db_deleted_cause = []
+        self._db_cause = cause
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.db_deleted_opm_times = []
+        if opm_times is None:
+            self._db_opm_times = []
+        else:
+            self._db_opm_times = opm_times
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmWasDerivedFrom.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmWasDerivedFrom()
+        if self._db_effect is not None:
+            cp._db_effect = self._db_effect.do_copy(new_ids, id_scope, id_remap)
+        if self._db_role is not None:
+            cp._db_role = self._db_role.do_copy(new_ids, id_scope, id_remap)
+        if self._db_cause is not None:
+            cp._db_cause = self._db_cause.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_opm_times is None:
+            cp._db_opm_times = []
+        else:
+            cp._db_opm_times = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_times]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmWasDerivedFrom()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'effect' in class_dict:
+            res = class_dict['effect'](old_obj, trans_dict)
+            new_obj.db_effect = res
+        elif hasattr(old_obj, 'db_effect') and old_obj.db_effect is not None:
+            obj = old_obj.db_effect
+            new_obj.db_add_effect(DBOpmArtifactIdEffect.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_effect') and hasattr(new_obj, 'db_deleted_effect'):
+            for obj in old_obj.db_deleted_effect:
+                n_obj = DBOpmArtifactIdEffect.update_version(obj, trans_dict)
+                new_obj.db_deleted_effect.append(n_obj)
+        if 'role' in class_dict:
+            res = class_dict['role'](old_obj, trans_dict)
+            new_obj.db_role = res
+        elif hasattr(old_obj, 'db_role') and old_obj.db_role is not None:
+            obj = old_obj.db_role
+            new_obj.db_add_role(DBOpmRole.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_role') and hasattr(new_obj, 'db_deleted_role'):
+            for obj in old_obj.db_deleted_role:
+                n_obj = DBOpmRole.update_version(obj, trans_dict)
+                new_obj.db_deleted_role.append(n_obj)
+        if 'cause' in class_dict:
+            res = class_dict['cause'](old_obj, trans_dict)
+            new_obj.db_cause = res
+        elif hasattr(old_obj, 'db_cause') and old_obj.db_cause is not None:
+            obj = old_obj.db_cause
+            new_obj.db_add_cause(DBOpmArtifactIdCause.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_cause') and hasattr(new_obj, 'db_deleted_cause'):
+            for obj in old_obj.db_deleted_cause:
+                n_obj = DBOpmArtifactIdCause.update_version(obj, trans_dict)
+                new_obj.db_deleted_cause.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'opm_times' in class_dict:
+            res = class_dict['opm_times'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_time(obj)
+        elif hasattr(old_obj, 'db_opm_times') and old_obj.db_opm_times is not None:
+            for obj in old_obj.db_opm_times:
+                new_obj.db_add_opm_time(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_times') and hasattr(new_obj, 'db_deleted_opm_times'):
+            for obj in old_obj.db_deleted_opm_times:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_times.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_effect is not None:
+            children.extend(self._db_effect.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_effect = None
+        if self._db_role is not None:
+            children.extend(self._db_role.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_role = None
+        if self._db_cause is not None:
+            children.extend(self._db_cause.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_cause = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_opm_times:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_time(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_effect)
+        children.extend(self.db_deleted_role)
+        children.extend(self.db_deleted_cause)
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_opm_times)
+        if remove:
+            self.db_deleted_effect = []
+            self.db_deleted_role = []
+            self.db_deleted_cause = []
+            self.db_deleted_accounts = []
+            self.db_deleted_opm_times = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_effect is not None and self._db_effect.has_changes():
+            return True
+        if self._db_role is not None and self._db_role.has_changes():
+            return True
+        if self._db_cause is not None and self._db_cause.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_opm_times:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_effect(self):
+        return self._db_effect
+    def __set_db_effect(self, effect):
+        self._db_effect = effect
+        self.is_dirty = True
+    db_effect = property(__get_db_effect, __set_db_effect)
+    def db_add_effect(self, effect):
+        self._db_effect = effect
+    def db_change_effect(self, effect):
+        self._db_effect = effect
+    def db_delete_effect(self, effect):
+        if not self.is_new:
+            self.db_deleted_effect.append(self._db_effect)
+        self._db_effect = None
+    
+    def __get_db_role(self):
+        return self._db_role
+    def __set_db_role(self, role):
+        self._db_role = role
+        self.is_dirty = True
+    db_role = property(__get_db_role, __set_db_role)
+    def db_add_role(self, role):
+        self._db_role = role
+    def db_change_role(self, role):
+        self._db_role = role
+    def db_delete_role(self, role):
+        if not self.is_new:
+            self.db_deleted_role.append(self._db_role)
+        self._db_role = None
+    
+    def __get_db_cause(self):
+        return self._db_cause
+    def __set_db_cause(self, cause):
+        self._db_cause = cause
+        self.is_dirty = True
+    db_cause = property(__get_db_cause, __set_db_cause)
+    def db_add_cause(self, cause):
+        self._db_cause = cause
+    def db_change_cause(self, cause):
+        self._db_cause = cause
+    def db_delete_cause(self, cause):
+        if not self.is_new:
+            self.db_deleted_cause.append(self._db_cause)
+        self._db_cause = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def __get_db_opm_times(self):
+        return self._db_opm_times
+    def __set_db_opm_times(self, opm_times):
+        self._db_opm_times = opm_times
+        self.is_dirty = True
+    db_opm_times = property(__get_db_opm_times, __set_db_opm_times)
+    def db_get_opm_times(self):
+        return self._db_opm_times
+    def db_add_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_change_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_delete_opm_time(self, opm_time):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_time(self, key):
+        return None
+    
+
+
+class DBControlParameter(object):
+
+    vtType = 'controlParameter'
+
+    def __init__(self, id=None, name=None, value=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBControlParameter.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBControlParameter(id=self._db_id,
+                                name=self._db_name,
+                                value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBControlParameter()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBPluginData(object):
+
+    vtType = 'plugin_data'
+
+    def __init__(self, id=None, data=None):
+        self._db_id = id
+        self._db_data = data
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPluginData.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPluginData(id=self._db_id,
+                          data=self._db_data)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPluginData()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'data' in class_dict:
+            res = class_dict['data'](old_obj, trans_dict)
+            new_obj.db_data = res
+        elif hasattr(old_obj, 'db_data') and old_obj.db_data is not None:
+            new_obj.db_data = old_obj.db_data
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_data(self):
+        return self._db_data
+    def __set_db_data(self, data):
+        self._db_data = data
+        self.is_dirty = True
+    db_data = property(__get_db_data, __set_db_data)
+    def db_add_data(self, data):
+        self._db_data = data
+    def db_change_data(self, data):
+        self._db_data = data
+    def db_delete_data(self, data):
+        self._db_data = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBDelete(object):
+
+    vtType = 'delete'
+
+    def __init__(self, id=None, what=None, objectId=None, parentObjId=None, parentObjType=None):
+        self._db_id = id
+        self._db_what = what
+        self._db_objectId = objectId
+        self._db_parentObjId = parentObjId
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBDelete.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBDelete(id=self._db_id,
+                      what=self._db_what,
+                      objectId=self._db_objectId,
+                      parentObjId=self._db_parentObjId,
+                      parentObjType=self._db_parentObjType)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_objectId') and (self._db_what, self._db_objectId) in id_remap:
+                cp._db_objectId = id_remap[(self._db_what, self._db_objectId)]
+            if hasattr(self, 'db_parentObjId') and (self._db_parentObjType, self._db_parentObjId) in id_remap:
+                cp._db_parentObjId = id_remap[(self._db_parentObjType, self._db_parentObjId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBDelete()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'what' in class_dict:
+            res = class_dict['what'](old_obj, trans_dict)
+            new_obj.db_what = res
+        elif hasattr(old_obj, 'db_what') and old_obj.db_what is not None:
+            new_obj.db_what = old_obj.db_what
+        if 'objectId' in class_dict:
+            res = class_dict['objectId'](old_obj, trans_dict)
+            new_obj.db_objectId = res
+        elif hasattr(old_obj, 'db_objectId') and old_obj.db_objectId is not None:
+            new_obj.db_objectId = old_obj.db_objectId
+        if 'parentObjId' in class_dict:
+            res = class_dict['parentObjId'](old_obj, trans_dict)
+            new_obj.db_parentObjId = res
+        elif hasattr(old_obj, 'db_parentObjId') and old_obj.db_parentObjId is not None:
+            new_obj.db_parentObjId = old_obj.db_parentObjId
+        if 'parentObjType' in class_dict:
+            res = class_dict['parentObjType'](old_obj, trans_dict)
+            new_obj.db_parentObjType = res
+        elif hasattr(old_obj, 'db_parentObjType') and old_obj.db_parentObjType is not None:
+            new_obj.db_parentObjType = old_obj.db_parentObjType
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_what(self):
+        return self._db_what
+    def __set_db_what(self, what):
+        self._db_what = what
+        self.is_dirty = True
+    db_what = property(__get_db_what, __set_db_what)
+    def db_add_what(self, what):
+        self._db_what = what
+    def db_change_what(self, what):
+        self._db_what = what
+    def db_delete_what(self, what):
+        self._db_what = None
+    
+    def __get_db_objectId(self):
+        return self._db_objectId
+    def __set_db_objectId(self, objectId):
+        self._db_objectId = objectId
+        self.is_dirty = True
+    db_objectId = property(__get_db_objectId, __set_db_objectId)
+    def db_add_objectId(self, objectId):
+        self._db_objectId = objectId
+    def db_change_objectId(self, objectId):
+        self._db_objectId = objectId
+    def db_delete_objectId(self, objectId):
+        self._db_objectId = None
+    
+    def __get_db_parentObjId(self):
+        return self._db_parentObjId
+    def __set_db_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+        self.is_dirty = True
+    db_parentObjId = property(__get_db_parentObjId, __set_db_parentObjId)
+    def db_add_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_change_parentObjId(self, parentObjId):
+        self._db_parentObjId = parentObjId
+    def db_delete_parentObjId(self, parentObjId):
+        self._db_parentObjId = None
+    
+    def __get_db_parentObjType(self):
+        return self._db_parentObjType
+    def __set_db_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+        self.is_dirty = True
+    db_parentObjType = property(__get_db_parentObjType, __set_db_parentObjType)
+    def db_add_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_change_parentObjType(self, parentObjType):
+        self._db_parentObjType = parentObjType
+    def db_delete_parentObjType(self, parentObjType):
+        self._db_parentObjType = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBVistrailVariable(object):
+
+    vtType = 'vistrailVariable'
+
+    def __init__(self, name=None, uuid=None, package=None, module=None, namespace=None, value=None):
+        self._db_name = name
+        self._db_uuid = uuid
+        self._db_package = package
+        self._db_module = module
+        self._db_namespace = namespace
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBVistrailVariable.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBVistrailVariable(name=self._db_name,
+                                uuid=self._db_uuid,
+                                package=self._db_package,
+                                module=self._db_module,
+                                namespace=self._db_namespace,
+                                value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBVistrailVariable()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'uuid' in class_dict:
+            res = class_dict['uuid'](old_obj, trans_dict)
+            new_obj.db_uuid = res
+        elif hasattr(old_obj, 'db_uuid') and old_obj.db_uuid is not None:
+            new_obj.db_uuid = old_obj.db_uuid
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'module' in class_dict:
+            res = class_dict['module'](old_obj, trans_dict)
+            new_obj.db_module = res
+        elif hasattr(old_obj, 'db_module') and old_obj.db_module is not None:
+            new_obj.db_module = old_obj.db_module
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_uuid(self):
+        return self._db_uuid
+    def __set_db_uuid(self, uuid):
+        self._db_uuid = uuid
+        self.is_dirty = True
+    db_uuid = property(__get_db_uuid, __set_db_uuid)
+    def db_add_uuid(self, uuid):
+        self._db_uuid = uuid
+    def db_change_uuid(self, uuid):
+        self._db_uuid = uuid
+    def db_delete_uuid(self, uuid):
+        self._db_uuid = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_module(self):
+        return self._db_module
+    def __set_db_module(self, module):
+        self._db_module = module
+        self.is_dirty = True
+    db_module = property(__get_db_module, __set_db_module)
+    def db_add_module(self, module):
+        self._db_module = module
+    def db_change_module(self, module):
+        self._db_module = module
+    def db_delete_module(self, module):
+        self._db_module = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def getPrimaryKey(self):
+        return self._db_name
+
+class DBOpmOverlaps(object):
+
+    vtType = 'opm_overlaps'
+
+    def __init__(self, opm_account_ids=None):
+        self.db_deleted_opm_account_ids = []
+        if opm_account_ids is None:
+            self._db_opm_account_ids = []
+        else:
+            self._db_opm_account_ids = opm_account_ids
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmOverlaps.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmOverlaps()
+        if self._db_opm_account_ids is None:
+            cp._db_opm_account_ids = []
+        else:
+            cp._db_opm_account_ids = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_account_ids]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmOverlaps()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'opm_account_ids' in class_dict:
+            res = class_dict['opm_account_ids'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_account_id(obj)
+        elif hasattr(old_obj, 'db_opm_account_ids') and old_obj.db_opm_account_ids is not None:
+            for obj in old_obj.db_opm_account_ids:
+                new_obj.db_add_opm_account_id(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_account_ids') and hasattr(new_obj, 'db_deleted_opm_account_ids'):
+            for obj in old_obj.db_deleted_opm_account_ids:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_account_ids.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_opm_account_ids:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_account_id(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_opm_account_ids)
+        if remove:
+            self.db_deleted_opm_account_ids = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_opm_account_ids:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_opm_account_ids(self):
+        return self._db_opm_account_ids
+    def __set_db_opm_account_ids(self, opm_account_ids):
+        self._db_opm_account_ids = opm_account_ids
+        self.is_dirty = True
+    db_opm_account_ids = property(__get_db_opm_account_ids, __set_db_opm_account_ids)
+    def db_get_opm_account_ids(self):
+        return self._db_opm_account_ids
+    def db_add_opm_account_id(self, opm_account_id):
+        self.is_dirty = True
+        self._db_opm_account_ids.append(opm_account_id)
+    def db_change_opm_account_id(self, opm_account_id):
+        self.is_dirty = True
+        self._db_opm_account_ids.append(opm_account_id)
+    def db_delete_opm_account_id(self, opm_account_id):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_account_id(self, key):
+        return None
+    
+
+
+class DBOpmWasTriggeredBy(object):
+
+    vtType = 'opm_was_triggered_by'
+
+    def __init__(self, effect=None, role=None, cause=None, accounts=None, opm_times=None):
+        self.db_deleted_effect = []
+        self._db_effect = effect
+        self.db_deleted_role = []
+        self._db_role = role
+        self.db_deleted_cause = []
+        self._db_cause = cause
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.db_deleted_opm_times = []
+        if opm_times is None:
+            self._db_opm_times = []
+        else:
+            self._db_opm_times = opm_times
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmWasTriggeredBy.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmWasTriggeredBy()
+        if self._db_effect is not None:
+            cp._db_effect = self._db_effect.do_copy(new_ids, id_scope, id_remap)
+        if self._db_role is not None:
+            cp._db_role = self._db_role.do_copy(new_ids, id_scope, id_remap)
+        if self._db_cause is not None:
+            cp._db_cause = self._db_cause.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        if self._db_opm_times is None:
+            cp._db_opm_times = []
+        else:
+            cp._db_opm_times = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_opm_times]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmWasTriggeredBy()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'effect' in class_dict:
+            res = class_dict['effect'](old_obj, trans_dict)
+            new_obj.db_effect = res
+        elif hasattr(old_obj, 'db_effect') and old_obj.db_effect is not None:
+            obj = old_obj.db_effect
+            new_obj.db_add_effect(DBOpmProcessIdEffect.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_effect') and hasattr(new_obj, 'db_deleted_effect'):
+            for obj in old_obj.db_deleted_effect:
+                n_obj = DBOpmProcessIdEffect.update_version(obj, trans_dict)
+                new_obj.db_deleted_effect.append(n_obj)
+        if 'role' in class_dict:
+            res = class_dict['role'](old_obj, trans_dict)
+            new_obj.db_role = res
+        elif hasattr(old_obj, 'db_role') and old_obj.db_role is not None:
+            obj = old_obj.db_role
+            new_obj.db_add_role(DBOpmRole.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_role') and hasattr(new_obj, 'db_deleted_role'):
+            for obj in old_obj.db_deleted_role:
+                n_obj = DBOpmRole.update_version(obj, trans_dict)
+                new_obj.db_deleted_role.append(n_obj)
+        if 'cause' in class_dict:
+            res = class_dict['cause'](old_obj, trans_dict)
+            new_obj.db_cause = res
+        elif hasattr(old_obj, 'db_cause') and old_obj.db_cause is not None:
+            obj = old_obj.db_cause
+            new_obj.db_add_cause(DBOpmProcessIdCause.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_cause') and hasattr(new_obj, 'db_deleted_cause'):
+            for obj in old_obj.db_deleted_cause:
+                n_obj = DBOpmProcessIdCause.update_version(obj, trans_dict)
+                new_obj.db_deleted_cause.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        if 'opm_times' in class_dict:
+            res = class_dict['opm_times'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_opm_time(obj)
+        elif hasattr(old_obj, 'db_opm_times') and old_obj.db_opm_times is not None:
+            for obj in old_obj.db_opm_times:
+                new_obj.db_add_opm_time(DBOpmTime.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_opm_times') and hasattr(new_obj, 'db_deleted_opm_times'):
+            for obj in old_obj.db_deleted_opm_times:
+                n_obj = DBOpmTime.update_version(obj, trans_dict)
+                new_obj.db_deleted_opm_times.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_effect is not None:
+            children.extend(self._db_effect.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_effect = None
+        if self._db_role is not None:
+            children.extend(self._db_role.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_role = None
+        if self._db_cause is not None:
+            children.extend(self._db_cause.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_cause = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        to_del = []
+        for child in self.db_opm_times:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_opm_time(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_effect)
+        children.extend(self.db_deleted_role)
+        children.extend(self.db_deleted_cause)
+        children.extend(self.db_deleted_accounts)
+        children.extend(self.db_deleted_opm_times)
+        if remove:
+            self.db_deleted_effect = []
+            self.db_deleted_role = []
+            self.db_deleted_cause = []
+            self.db_deleted_accounts = []
+            self.db_deleted_opm_times = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_effect is not None and self._db_effect.has_changes():
+            return True
+        if self._db_role is not None and self._db_role.has_changes():
+            return True
+        if self._db_cause is not None and self._db_cause.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        for child in self._db_opm_times:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_effect(self):
+        return self._db_effect
+    def __set_db_effect(self, effect):
+        self._db_effect = effect
+        self.is_dirty = True
+    db_effect = property(__get_db_effect, __set_db_effect)
+    def db_add_effect(self, effect):
+        self._db_effect = effect
+    def db_change_effect(self, effect):
+        self._db_effect = effect
+    def db_delete_effect(self, effect):
+        if not self.is_new:
+            self.db_deleted_effect.append(self._db_effect)
+        self._db_effect = None
+    
+    def __get_db_role(self):
+        return self._db_role
+    def __set_db_role(self, role):
+        self._db_role = role
+        self.is_dirty = True
+    db_role = property(__get_db_role, __set_db_role)
+    def db_add_role(self, role):
+        self._db_role = role
+    def db_change_role(self, role):
+        self._db_role = role
+    def db_delete_role(self, role):
+        if not self.is_new:
+            self.db_deleted_role.append(self._db_role)
+        self._db_role = None
+    
+    def __get_db_cause(self):
+        return self._db_cause
+    def __set_db_cause(self, cause):
+        self._db_cause = cause
+        self.is_dirty = True
+    db_cause = property(__get_db_cause, __set_db_cause)
+    def db_add_cause(self, cause):
+        self._db_cause = cause
+    def db_change_cause(self, cause):
+        self._db_cause = cause
+    def db_delete_cause(self, cause):
+        if not self.is_new:
+            self.db_deleted_cause.append(self._db_cause)
+        self._db_cause = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def __get_db_opm_times(self):
+        return self._db_opm_times
+    def __set_db_opm_times(self, opm_times):
+        self._db_opm_times = opm_times
+        self.is_dirty = True
+    db_opm_times = property(__get_db_opm_times, __set_db_opm_times)
+    def db_get_opm_times(self):
+        return self._db_opm_times
+    def db_add_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_change_opm_time(self, opm_time):
+        self.is_dirty = True
+        self._db_opm_times.append(opm_time)
+    def db_delete_opm_time(self, opm_time):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_opm_time(self, key):
+        return None
+    
+
+
+class DBModuleDescriptor(object):
+
+    vtType = 'module_descriptor'
+
+    def __init__(self, id=None, name=None, package=None, namespace=None, package_version=None, version=None, base_descriptor_id=None, portSpecs=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_package = package
+        self._db_namespace = namespace
+        self._db_package_version = package_version
+        self._db_version = version
+        self._db_base_descriptor_id = base_descriptor_id
+        self.db_deleted_portSpecs = []
+        self.db_portSpecs_id_index = {}
+        self.db_portSpecs_name_index = {}
+        if portSpecs is None:
+            self._db_portSpecs = []
+        else:
+            self._db_portSpecs = portSpecs
+            for v in self._db_portSpecs:
+                self.db_portSpecs_id_index[v.db_id] = v
+                self.db_portSpecs_name_index[(v.db_name,v.db_type)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBModuleDescriptor.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBModuleDescriptor(id=self._db_id,
+                                name=self._db_name,
+                                package=self._db_package,
+                                namespace=self._db_namespace,
+                                package_version=self._db_package_version,
+                                version=self._db_version,
+                                base_descriptor_id=self._db_base_descriptor_id)
+        if self._db_portSpecs is None:
+            cp._db_portSpecs = []
+        else:
+            cp._db_portSpecs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_portSpecs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_base_descriptor_id') and ('module_descriptor', self._db_base_descriptor_id) in id_remap:
+                cp._db_base_descriptor_id = id_remap[('module_descriptor', self._db_base_descriptor_id)]
+        
+        # recreate indices and set flags
+        cp.db_portSpecs_id_index = dict((v.db_id, v) for v in cp._db_portSpecs)
+        cp.db_portSpecs_name_index = dict(((v.db_name,v.db_type), v) for v in cp._db_portSpecs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBModuleDescriptor()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'package_version' in class_dict:
+            res = class_dict['package_version'](old_obj, trans_dict)
+            new_obj.db_package_version = res
+        elif hasattr(old_obj, 'db_package_version') and old_obj.db_package_version is not None:
+            new_obj.db_package_version = old_obj.db_package_version
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'base_descriptor_id' in class_dict:
+            res = class_dict['base_descriptor_id'](old_obj, trans_dict)
+            new_obj.db_base_descriptor_id = res
+        elif hasattr(old_obj, 'db_base_descriptor_id') and old_obj.db_base_descriptor_id is not None:
+            new_obj.db_base_descriptor_id = old_obj.db_base_descriptor_id
+        if 'portSpecs' in class_dict:
+            res = class_dict['portSpecs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_portSpec(obj)
+        elif hasattr(old_obj, 'db_portSpecs') and old_obj.db_portSpecs is not None:
+            for obj in old_obj.db_portSpecs:
+                new_obj.db_add_portSpec(DBPortSpec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_portSpecs') and hasattr(new_obj, 'db_deleted_portSpecs'):
+            for obj in old_obj.db_deleted_portSpecs:
+                n_obj = DBPortSpec.update_version(obj, trans_dict)
+                new_obj.db_deleted_portSpecs.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_portSpecs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_portSpec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_portSpecs)
+        if remove:
+            self.db_deleted_portSpecs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_portSpecs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_package_version(self):
+        return self._db_package_version
+    def __set_db_package_version(self, package_version):
+        self._db_package_version = package_version
+        self.is_dirty = True
+    db_package_version = property(__get_db_package_version, __set_db_package_version)
+    def db_add_package_version(self, package_version):
+        self._db_package_version = package_version
+    def db_change_package_version(self, package_version):
+        self._db_package_version = package_version
+    def db_delete_package_version(self, package_version):
+        self._db_package_version = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_base_descriptor_id(self):
+        return self._db_base_descriptor_id
+    def __set_db_base_descriptor_id(self, base_descriptor_id):
+        self._db_base_descriptor_id = base_descriptor_id
+        self.is_dirty = True
+    db_base_descriptor_id = property(__get_db_base_descriptor_id, __set_db_base_descriptor_id)
+    def db_add_base_descriptor_id(self, base_descriptor_id):
+        self._db_base_descriptor_id = base_descriptor_id
+    def db_change_base_descriptor_id(self, base_descriptor_id):
+        self._db_base_descriptor_id = base_descriptor_id
+    def db_delete_base_descriptor_id(self, base_descriptor_id):
+        self._db_base_descriptor_id = None
+    
+    def __get_db_portSpecs(self):
+        return self._db_portSpecs
+    def __set_db_portSpecs(self, portSpecs):
+        self._db_portSpecs = portSpecs
+        self.is_dirty = True
+    db_portSpecs = property(__get_db_portSpecs, __set_db_portSpecs)
+    def db_get_portSpecs(self):
+        return self._db_portSpecs
+    def db_add_portSpec(self, portSpec):
+        self.is_dirty = True
+        self._db_portSpecs.append(portSpec)
+        self.db_portSpecs_id_index[portSpec.db_id] = portSpec
+        self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)] = portSpec
+    def db_change_portSpec(self, portSpec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == portSpec.db_id:
+                self._db_portSpecs[i] = portSpec
+                found = True
+                break
+        if not found:
+            self._db_portSpecs.append(portSpec)
+        self.db_portSpecs_id_index[portSpec.db_id] = portSpec
+        self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)] = portSpec
+    def db_delete_portSpec(self, portSpec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == portSpec.db_id:
+                if not self._db_portSpecs[i].is_new:
+                    self.db_deleted_portSpecs.append(self._db_portSpecs[i])
+                del self._db_portSpecs[i]
+                break
+        del self.db_portSpecs_id_index[portSpec.db_id]
+        del self.db_portSpecs_name_index[(portSpec.db_name,portSpec.db_type)]
+    def db_get_portSpec(self, key):
+        for i in xrange(len(self._db_portSpecs)):
+            if self._db_portSpecs[i].db_id == key:
+                return self._db_portSpecs[i]
+        return None
+    def db_get_portSpec_by_id(self, key):
+        return self.db_portSpecs_id_index[key]
+    def db_has_portSpec_with_id(self, key):
+        return key in self.db_portSpecs_id_index
+    def db_get_portSpec_by_name(self, key):
+        return self.db_portSpecs_name_index[key]
+    def db_has_portSpec_with_name(self, key):
+        return key in self.db_portSpecs_name_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBTag(object):
+
+    vtType = 'tag'
+
+    def __init__(self, id=None, name=None):
+        self._db_id = id
+        self._db_name = name
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBTag.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBTag(id=self._db_id,
+                   name=self._db_name)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('action', self._db_id) in id_remap:
+                cp._db_id = id_remap[('action', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBTag()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmRole(object):
+
+    vtType = 'opm_role'
+
+    def __init__(self, value=None):
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmRole.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmRole(value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmRole()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+
+
+class DBProvDocument(object):
+
+    vtType = 'prov_document'
+
+    def __init__(self, prov_entitys=None, prov_activitys=None, prov_agents=None, vt_connections=None, prov_usages=None, prov_generations=None, prov_associations=None):
+        self.db_deleted_prov_entitys = []
+        self.db_prov_entitys_id_index = {}
+        if prov_entitys is None:
+            self._db_prov_entitys = []
+        else:
+            self._db_prov_entitys = prov_entitys
+            for v in self._db_prov_entitys:
+                self.db_prov_entitys_id_index[v.db_id] = v
+        self.db_deleted_prov_activitys = []
+        self.db_prov_activitys_id_index = {}
+        if prov_activitys is None:
+            self._db_prov_activitys = []
+        else:
+            self._db_prov_activitys = prov_activitys
+            for v in self._db_prov_activitys:
+                self.db_prov_activitys_id_index[v.db_id] = v
+        self.db_deleted_prov_agents = []
+        self.db_prov_agents_id_index = {}
+        if prov_agents is None:
+            self._db_prov_agents = []
+        else:
+            self._db_prov_agents = prov_agents
+            for v in self._db_prov_agents:
+                self.db_prov_agents_id_index[v.db_id] = v
+        self.db_deleted_vt_connections = []
+        self.db_vt_connections_id_index = {}
+        if vt_connections is None:
+            self._db_vt_connections = []
+        else:
+            self._db_vt_connections = vt_connections
+            for v in self._db_vt_connections:
+                self.db_vt_connections_id_index[v.db_id] = v
+        self.db_deleted_prov_usages = []
+        if prov_usages is None:
+            self._db_prov_usages = []
+        else:
+            self._db_prov_usages = prov_usages
+        self.db_deleted_prov_generations = []
+        if prov_generations is None:
+            self._db_prov_generations = []
+        else:
+            self._db_prov_generations = prov_generations
+        self.db_deleted_prov_associations = []
+        if prov_associations is None:
+            self._db_prov_associations = []
+        else:
+            self._db_prov_associations = prov_associations
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvDocument.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvDocument()
+        if self._db_prov_entitys is None:
+            cp._db_prov_entitys = []
+        else:
+            cp._db_prov_entitys = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_entitys]
+        if self._db_prov_activitys is None:
+            cp._db_prov_activitys = []
+        else:
+            cp._db_prov_activitys = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_activitys]
+        if self._db_prov_agents is None:
+            cp._db_prov_agents = []
+        else:
+            cp._db_prov_agents = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_agents]
+        if self._db_vt_connections is None:
+            cp._db_vt_connections = []
+        else:
+            cp._db_vt_connections = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_vt_connections]
+        if self._db_prov_usages is None:
+            cp._db_prov_usages = []
+        else:
+            cp._db_prov_usages = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_usages]
+        if self._db_prov_generations is None:
+            cp._db_prov_generations = []
+        else:
+            cp._db_prov_generations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_generations]
+        if self._db_prov_associations is None:
+            cp._db_prov_associations = []
+        else:
+            cp._db_prov_associations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_prov_associations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_prov_entitys_id_index = dict((v.db_id, v) for v in cp._db_prov_entitys)
+        cp.db_prov_activitys_id_index = dict((v.db_id, v) for v in cp._db_prov_activitys)
+        cp.db_prov_agents_id_index = dict((v.db_id, v) for v in cp._db_prov_agents)
+        cp.db_vt_connections_id_index = dict((v.db_id, v) for v in cp._db_vt_connections)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvDocument()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_entitys' in class_dict:
+            res = class_dict['prov_entitys'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_entity(obj)
+        elif hasattr(old_obj, 'db_prov_entitys') and old_obj.db_prov_entitys is not None:
+            for obj in old_obj.db_prov_entitys:
+                new_obj.db_add_prov_entity(DBProvEntity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_entitys') and hasattr(new_obj, 'db_deleted_prov_entitys'):
+            for obj in old_obj.db_deleted_prov_entitys:
+                n_obj = DBProvEntity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_entitys.append(n_obj)
+        if 'prov_activitys' in class_dict:
+            res = class_dict['prov_activitys'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_activity(obj)
+        elif hasattr(old_obj, 'db_prov_activitys') and old_obj.db_prov_activitys is not None:
+            for obj in old_obj.db_prov_activitys:
+                new_obj.db_add_prov_activity(DBProvActivity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_activitys') and hasattr(new_obj, 'db_deleted_prov_activitys'):
+            for obj in old_obj.db_deleted_prov_activitys:
+                n_obj = DBProvActivity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_activitys.append(n_obj)
+        if 'prov_agents' in class_dict:
+            res = class_dict['prov_agents'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_agent(obj)
+        elif hasattr(old_obj, 'db_prov_agents') and old_obj.db_prov_agents is not None:
+            for obj in old_obj.db_prov_agents:
+                new_obj.db_add_prov_agent(DBProvAgent.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_agents') and hasattr(new_obj, 'db_deleted_prov_agents'):
+            for obj in old_obj.db_deleted_prov_agents:
+                n_obj = DBProvAgent.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_agents.append(n_obj)
+        if 'vt_connections' in class_dict:
+            res = class_dict['vt_connections'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_vt_connection(obj)
+        elif hasattr(old_obj, 'db_vt_connections') and old_obj.db_vt_connections is not None:
+            for obj in old_obj.db_vt_connections:
+                new_obj.db_add_vt_connection(DBVtConnection.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_vt_connections') and hasattr(new_obj, 'db_deleted_vt_connections'):
+            for obj in old_obj.db_deleted_vt_connections:
+                n_obj = DBVtConnection.update_version(obj, trans_dict)
+                new_obj.db_deleted_vt_connections.append(n_obj)
+        if 'prov_usages' in class_dict:
+            res = class_dict['prov_usages'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_usage(obj)
+        elif hasattr(old_obj, 'db_prov_usages') and old_obj.db_prov_usages is not None:
+            for obj in old_obj.db_prov_usages:
+                new_obj.db_add_prov_usage(DBProvUsage.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_usages') and hasattr(new_obj, 'db_deleted_prov_usages'):
+            for obj in old_obj.db_deleted_prov_usages:
+                n_obj = DBProvUsage.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_usages.append(n_obj)
+        if 'prov_generations' in class_dict:
+            res = class_dict['prov_generations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_generation(obj)
+        elif hasattr(old_obj, 'db_prov_generations') and old_obj.db_prov_generations is not None:
+            for obj in old_obj.db_prov_generations:
+                new_obj.db_add_prov_generation(DBProvGeneration.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_generations') and hasattr(new_obj, 'db_deleted_prov_generations'):
+            for obj in old_obj.db_deleted_prov_generations:
+                n_obj = DBProvGeneration.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_generations.append(n_obj)
+        if 'prov_associations' in class_dict:
+            res = class_dict['prov_associations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_prov_association(obj)
+        elif hasattr(old_obj, 'db_prov_associations') and old_obj.db_prov_associations is not None:
+            for obj in old_obj.db_prov_associations:
+                new_obj.db_add_prov_association(DBProvAssociation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_associations') and hasattr(new_obj, 'db_deleted_prov_associations'):
+            for obj in old_obj.db_deleted_prov_associations:
+                n_obj = DBProvAssociation.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_associations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_prov_entitys:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_entity(child)
+        to_del = []
+        for child in self.db_prov_activitys:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_activity(child)
+        to_del = []
+        for child in self.db_prov_agents:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_agent(child)
+        to_del = []
+        for child in self.db_vt_connections:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_vt_connection(child)
+        to_del = []
+        for child in self.db_prov_usages:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_usage(child)
+        to_del = []
+        for child in self.db_prov_generations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_generation(child)
+        to_del = []
+        for child in self.db_prov_associations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_prov_association(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_prov_entitys)
+        children.extend(self.db_deleted_prov_activitys)
+        children.extend(self.db_deleted_prov_agents)
+        children.extend(self.db_deleted_vt_connections)
+        children.extend(self.db_deleted_prov_usages)
+        children.extend(self.db_deleted_prov_generations)
+        children.extend(self.db_deleted_prov_associations)
+        if remove:
+            self.db_deleted_prov_entitys = []
+            self.db_deleted_prov_activitys = []
+            self.db_deleted_prov_agents = []
+            self.db_deleted_vt_connections = []
+            self.db_deleted_prov_usages = []
+            self.db_deleted_prov_generations = []
+            self.db_deleted_prov_associations = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_prov_entitys:
+            if child.has_changes():
+                return True
+        for child in self._db_prov_activitys:
+            if child.has_changes():
+                return True
+        for child in self._db_prov_agents:
+            if child.has_changes():
+                return True
+        for child in self._db_vt_connections:
+            if child.has_changes():
+                return True
+        for child in self._db_prov_usages:
+            if child.has_changes():
+                return True
+        for child in self._db_prov_generations:
+            if child.has_changes():
+                return True
+        for child in self._db_prov_associations:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_prov_entitys(self):
+        return self._db_prov_entitys
+    def __set_db_prov_entitys(self, prov_entitys):
+        self._db_prov_entitys = prov_entitys
+        self.is_dirty = True
+    db_prov_entitys = property(__get_db_prov_entitys, __set_db_prov_entitys)
+    def db_get_prov_entitys(self):
+        return self._db_prov_entitys
+    def db_add_prov_entity(self, prov_entity):
+        self.is_dirty = True
+        self._db_prov_entitys.append(prov_entity)
+        self.db_prov_entitys_id_index[prov_entity.db_id] = prov_entity
+    def db_change_prov_entity(self, prov_entity):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_prov_entitys)):
+            if self._db_prov_entitys[i].db_id == prov_entity.db_id:
+                self._db_prov_entitys[i] = prov_entity
+                found = True
+                break
+        if not found:
+            self._db_prov_entitys.append(prov_entity)
+        self.db_prov_entitys_id_index[prov_entity.db_id] = prov_entity
+    def db_delete_prov_entity(self, prov_entity):
+        self.is_dirty = True
+        for i in xrange(len(self._db_prov_entitys)):
+            if self._db_prov_entitys[i].db_id == prov_entity.db_id:
+                if not self._db_prov_entitys[i].is_new:
+                    self.db_deleted_prov_entitys.append(self._db_prov_entitys[i])
+                del self._db_prov_entitys[i]
+                break
+        del self.db_prov_entitys_id_index[prov_entity.db_id]
+    def db_get_prov_entity(self, key):
+        for i in xrange(len(self._db_prov_entitys)):
+            if self._db_prov_entitys[i].db_id == key:
+                return self._db_prov_entitys[i]
+        return None
+    def db_get_prov_entity_by_id(self, key):
+        return self.db_prov_entitys_id_index[key]
+    def db_has_prov_entity_with_id(self, key):
+        return key in self.db_prov_entitys_id_index
+    
+    def __get_db_prov_activitys(self):
+        return self._db_prov_activitys
+    def __set_db_prov_activitys(self, prov_activitys):
+        self._db_prov_activitys = prov_activitys
+        self.is_dirty = True
+    db_prov_activitys = property(__get_db_prov_activitys, __set_db_prov_activitys)
+    def db_get_prov_activitys(self):
+        return self._db_prov_activitys
+    def db_add_prov_activity(self, prov_activity):
+        self.is_dirty = True
+        self._db_prov_activitys.append(prov_activity)
+        self.db_prov_activitys_id_index[prov_activity.db_id] = prov_activity
+    def db_change_prov_activity(self, prov_activity):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_prov_activitys)):
+            if self._db_prov_activitys[i].db_id == prov_activity.db_id:
+                self._db_prov_activitys[i] = prov_activity
+                found = True
+                break
+        if not found:
+            self._db_prov_activitys.append(prov_activity)
+        self.db_prov_activitys_id_index[prov_activity.db_id] = prov_activity
+    def db_delete_prov_activity(self, prov_activity):
+        self.is_dirty = True
+        for i in xrange(len(self._db_prov_activitys)):
+            if self._db_prov_activitys[i].db_id == prov_activity.db_id:
+                if not self._db_prov_activitys[i].is_new:
+                    self.db_deleted_prov_activitys.append(self._db_prov_activitys[i])
+                del self._db_prov_activitys[i]
+                break
+        del self.db_prov_activitys_id_index[prov_activity.db_id]
+    def db_get_prov_activity(self, key):
+        for i in xrange(len(self._db_prov_activitys)):
+            if self._db_prov_activitys[i].db_id == key:
+                return self._db_prov_activitys[i]
+        return None
+    def db_get_prov_activity_by_id(self, key):
+        return self.db_prov_activitys_id_index[key]
+    def db_has_prov_activity_with_id(self, key):
+        return key in self.db_prov_activitys_id_index
+    
+    def __get_db_prov_agents(self):
+        return self._db_prov_agents
+    def __set_db_prov_agents(self, prov_agents):
+        self._db_prov_agents = prov_agents
+        self.is_dirty = True
+    db_prov_agents = property(__get_db_prov_agents, __set_db_prov_agents)
+    def db_get_prov_agents(self):
+        return self._db_prov_agents
+    def db_add_prov_agent(self, prov_agent):
+        self.is_dirty = True
+        self._db_prov_agents.append(prov_agent)
+        self.db_prov_agents_id_index[prov_agent.db_id] = prov_agent
+    def db_change_prov_agent(self, prov_agent):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_prov_agents)):
+            if self._db_prov_agents[i].db_id == prov_agent.db_id:
+                self._db_prov_agents[i] = prov_agent
+                found = True
+                break
+        if not found:
+            self._db_prov_agents.append(prov_agent)
+        self.db_prov_agents_id_index[prov_agent.db_id] = prov_agent
+    def db_delete_prov_agent(self, prov_agent):
+        self.is_dirty = True
+        for i in xrange(len(self._db_prov_agents)):
+            if self._db_prov_agents[i].db_id == prov_agent.db_id:
+                if not self._db_prov_agents[i].is_new:
+                    self.db_deleted_prov_agents.append(self._db_prov_agents[i])
+                del self._db_prov_agents[i]
+                break
+        del self.db_prov_agents_id_index[prov_agent.db_id]
+    def db_get_prov_agent(self, key):
+        for i in xrange(len(self._db_prov_agents)):
+            if self._db_prov_agents[i].db_id == key:
+                return self._db_prov_agents[i]
+        return None
+    def db_get_prov_agent_by_id(self, key):
+        return self.db_prov_agents_id_index[key]
+    def db_has_prov_agent_with_id(self, key):
+        return key in self.db_prov_agents_id_index
+    
+    def __get_db_vt_connections(self):
+        return self._db_vt_connections
+    def __set_db_vt_connections(self, vt_connections):
+        self._db_vt_connections = vt_connections
+        self.is_dirty = True
+    db_vt_connections = property(__get_db_vt_connections, __set_db_vt_connections)
+    def db_get_vt_connections(self):
+        return self._db_vt_connections
+    def db_add_vt_connection(self, vt_connection):
+        self.is_dirty = True
+        self._db_vt_connections.append(vt_connection)
+        self.db_vt_connections_id_index[vt_connection.db_id] = vt_connection
+    def db_change_vt_connection(self, vt_connection):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_vt_connections)):
+            if self._db_vt_connections[i].db_id == vt_connection.db_id:
+                self._db_vt_connections[i] = vt_connection
+                found = True
+                break
+        if not found:
+            self._db_vt_connections.append(vt_connection)
+        self.db_vt_connections_id_index[vt_connection.db_id] = vt_connection
+    def db_delete_vt_connection(self, vt_connection):
+        self.is_dirty = True
+        for i in xrange(len(self._db_vt_connections)):
+            if self._db_vt_connections[i].db_id == vt_connection.db_id:
+                if not self._db_vt_connections[i].is_new:
+                    self.db_deleted_vt_connections.append(self._db_vt_connections[i])
+                del self._db_vt_connections[i]
+                break
+        del self.db_vt_connections_id_index[vt_connection.db_id]
+    def db_get_vt_connection(self, key):
+        for i in xrange(len(self._db_vt_connections)):
+            if self._db_vt_connections[i].db_id == key:
+                return self._db_vt_connections[i]
+        return None
+    def db_get_vt_connection_by_id(self, key):
+        return self.db_vt_connections_id_index[key]
+    def db_has_vt_connection_with_id(self, key):
+        return key in self.db_vt_connections_id_index
+    
+    def __get_db_prov_usages(self):
+        return self._db_prov_usages
+    def __set_db_prov_usages(self, prov_usages):
+        self._db_prov_usages = prov_usages
+        self.is_dirty = True
+    db_prov_usages = property(__get_db_prov_usages, __set_db_prov_usages)
+    def db_get_prov_usages(self):
+        return self._db_prov_usages
+    def db_add_prov_usage(self, prov_usage):
+        self.is_dirty = True
+        self._db_prov_usages.append(prov_usage)
+    def db_change_prov_usage(self, prov_usage):
+        self.is_dirty = True
+        self._db_prov_usages.append(prov_usage)
+    def db_delete_prov_usage(self, prov_usage):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_prov_usage(self, key):
+        return None
+    
+    def __get_db_prov_generations(self):
+        return self._db_prov_generations
+    def __set_db_prov_generations(self, prov_generations):
+        self._db_prov_generations = prov_generations
+        self.is_dirty = True
+    db_prov_generations = property(__get_db_prov_generations, __set_db_prov_generations)
+    def db_get_prov_generations(self):
+        return self._db_prov_generations
+    def db_add_prov_generation(self, prov_generation):
+        self.is_dirty = True
+        self._db_prov_generations.append(prov_generation)
+    def db_change_prov_generation(self, prov_generation):
+        self.is_dirty = True
+        self._db_prov_generations.append(prov_generation)
+    def db_delete_prov_generation(self, prov_generation):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_prov_generation(self, key):
+        return None
+    
+    def __get_db_prov_associations(self):
+        return self._db_prov_associations
+    def __set_db_prov_associations(self, prov_associations):
+        self._db_prov_associations = prov_associations
+        self.is_dirty = True
+    db_prov_associations = property(__get_db_prov_associations, __set_db_prov_associations)
+    def db_get_prov_associations(self):
+        return self._db_prov_associations
+    def db_add_prov_association(self, prov_association):
+        self.is_dirty = True
+        self._db_prov_associations.append(prov_association)
+    def db_change_prov_association(self, prov_association):
+        self.is_dirty = True
+        self._db_prov_associations.append(prov_association)
+    def db_delete_prov_association(self, prov_association):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_prov_association(self, key):
+        return None
+    
+
+
+class DBOpmProcesses(object):
+
+    vtType = 'opm_processes'
+
+    def __init__(self, processs=None):
+        self.db_deleted_processs = []
+        self.db_processs_id_index = {}
+        if processs is None:
+            self._db_processs = []
+        else:
+            self._db_processs = processs
+            for v in self._db_processs:
+                self.db_processs_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmProcesses.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmProcesses()
+        if self._db_processs is None:
+            cp._db_processs = []
+        else:
+            cp._db_processs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_processs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_processs_id_index = dict((v.db_id, v) for v in cp._db_processs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmProcesses()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'processs' in class_dict:
+            res = class_dict['processs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_process(obj)
+        elif hasattr(old_obj, 'db_processs') and old_obj.db_processs is not None:
+            for obj in old_obj.db_processs:
+                new_obj.db_add_process(DBOpmProcess.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_processs') and hasattr(new_obj, 'db_deleted_processs'):
+            for obj in old_obj.db_deleted_processs:
+                n_obj = DBOpmProcess.update_version(obj, trans_dict)
+                new_obj.db_deleted_processs.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_processs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_process(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_processs)
+        if remove:
+            self.db_deleted_processs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_processs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_processs(self):
+        return self._db_processs
+    def __set_db_processs(self, processs):
+        self._db_processs = processs
+        self.is_dirty = True
+    db_processs = property(__get_db_processs, __set_db_processs)
+    def db_get_processs(self):
+        return self._db_processs
+    def db_add_process(self, process):
+        self.is_dirty = True
+        self._db_processs.append(process)
+        self.db_processs_id_index[process.db_id] = process
+    def db_change_process(self, process):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_processs)):
+            if self._db_processs[i].db_id == process.db_id:
+                self._db_processs[i] = process
+                found = True
+                break
+        if not found:
+            self._db_processs.append(process)
+        self.db_processs_id_index[process.db_id] = process
+    def db_delete_process(self, process):
+        self.is_dirty = True
+        for i in xrange(len(self._db_processs)):
+            if self._db_processs[i].db_id == process.db_id:
+                if not self._db_processs[i].is_new:
+                    self.db_deleted_processs.append(self._db_processs[i])
+                del self._db_processs[i]
+                break
+        del self.db_processs_id_index[process.db_id]
+    def db_get_process(self, key):
+        for i in xrange(len(self._db_processs)):
+            if self._db_processs[i].db_id == key:
+                return self._db_processs[i]
+        return None
+    def db_get_process_by_id(self, key):
+        return self.db_processs_id_index[key]
+    def db_has_process_with_id(self, key):
+        return key in self.db_processs_id_index
+    
+
+
+class DBOpmAccountId(object):
+
+    vtType = 'opm_account_id'
+
+    def __init__(self, id=None):
+        self._db_id = id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAccountId.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAccountId(id=self._db_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_id') and ('opm_account', self._db_id) in id_remap:
+                cp._db_id = id_remap[('opm_account', self._db_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAccountId()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+
+
+class DBPortSpecItem(object):
+
+    vtType = 'portSpecItem'
+
+    def __init__(self, id=None, pos=None, module=None, package=None, namespace=None, label=None, default=None, values=None, entry_type=None):
+        self._db_id = id
+        self._db_pos = pos
+        self._db_module = module
+        self._db_package = package
+        self._db_namespace = namespace
+        self._db_label = label
+        self._db_default = default
+        self._db_values = values
+        self._db_entry_type = entry_type
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBPortSpecItem.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBPortSpecItem(id=self._db_id,
+                            pos=self._db_pos,
+                            module=self._db_module,
+                            package=self._db_package,
+                            namespace=self._db_namespace,
+                            label=self._db_label,
+                            default=self._db_default,
+                            values=self._db_values,
+                            entry_type=self._db_entry_type)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBPortSpecItem()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'pos' in class_dict:
+            res = class_dict['pos'](old_obj, trans_dict)
+            new_obj.db_pos = res
+        elif hasattr(old_obj, 'db_pos') and old_obj.db_pos is not None:
+            new_obj.db_pos = old_obj.db_pos
+        if 'module' in class_dict:
+            res = class_dict['module'](old_obj, trans_dict)
+            new_obj.db_module = res
+        elif hasattr(old_obj, 'db_module') and old_obj.db_module is not None:
+            new_obj.db_module = old_obj.db_module
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'label' in class_dict:
+            res = class_dict['label'](old_obj, trans_dict)
+            new_obj.db_label = res
+        elif hasattr(old_obj, 'db_label') and old_obj.db_label is not None:
+            new_obj.db_label = old_obj.db_label
+        if 'default' in class_dict:
+            res = class_dict['default'](old_obj, trans_dict)
+            new_obj.db_default = res
+        elif hasattr(old_obj, 'db_default') and old_obj.db_default is not None:
+            new_obj.db_default = old_obj.db_default
+        if 'values' in class_dict:
+            res = class_dict['values'](old_obj, trans_dict)
+            new_obj.db_values = res
+        elif hasattr(old_obj, 'db_values') and old_obj.db_values is not None:
+            new_obj.db_values = old_obj.db_values
+        if 'entry_type' in class_dict:
+            res = class_dict['entry_type'](old_obj, trans_dict)
+            new_obj.db_entry_type = res
+        elif hasattr(old_obj, 'db_entry_type') and old_obj.db_entry_type is not None:
+            new_obj.db_entry_type = old_obj.db_entry_type
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_pos(self):
+        return self._db_pos
+    def __set_db_pos(self, pos):
+        self._db_pos = pos
+        self.is_dirty = True
+    db_pos = property(__get_db_pos, __set_db_pos)
+    def db_add_pos(self, pos):
+        self._db_pos = pos
+    def db_change_pos(self, pos):
+        self._db_pos = pos
+    def db_delete_pos(self, pos):
+        self._db_pos = None
+    
+    def __get_db_module(self):
+        return self._db_module
+    def __set_db_module(self, module):
+        self._db_module = module
+        self.is_dirty = True
+    db_module = property(__get_db_module, __set_db_module)
+    def db_add_module(self, module):
+        self._db_module = module
+    def db_change_module(self, module):
+        self._db_module = module
+    def db_delete_module(self, module):
+        self._db_module = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_label(self):
+        return self._db_label
+    def __set_db_label(self, label):
+        self._db_label = label
+        self.is_dirty = True
+    db_label = property(__get_db_label, __set_db_label)
+    def db_add_label(self, label):
+        self._db_label = label
+    def db_change_label(self, label):
+        self._db_label = label
+    def db_delete_label(self, label):
+        self._db_label = None
+    
+    def __get_db_default(self):
+        return self._db_default
+    def __set_db_default(self, default):
+        self._db_default = default
+        self.is_dirty = True
+    db_default = property(__get_db_default, __set_db_default)
+    def db_add_default(self, default):
+        self._db_default = default
+    def db_change_default(self, default):
+        self._db_default = default
+    def db_delete_default(self, default):
+        self._db_default = None
+    
+    def __get_db_values(self):
+        return self._db_values
+    def __set_db_values(self, values):
+        self._db_values = values
+        self.is_dirty = True
+    db_values = property(__get_db_values, __set_db_values)
+    def db_add_values(self, values):
+        self._db_values = values
+    def db_change_values(self, values):
+        self._db_values = values
+    def db_delete_values(self, values):
+        self._db_values = None
+    
+    def __get_db_entry_type(self):
+        return self._db_entry_type
+    def __set_db_entry_type(self, entry_type):
+        self._db_entry_type = entry_type
+        self.is_dirty = True
+    db_entry_type = property(__get_db_entry_type, __set_db_entry_type)
+    def db_add_entry_type(self, entry_type):
+        self._db_entry_type = entry_type
+    def db_change_entry_type(self, entry_type):
+        self._db_entry_type = entry_type
+    def db_delete_entry_type(self, entry_type):
+        self._db_entry_type = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMashupComponent(object):
+
+    vtType = 'mashup_component'
+
+    def __init__(self, id=None, vtid=None, vttype=None, vtparent_type=None, vtparent_id=None, vtpos=None, vtmid=None, pos=None, type=None, val=None, minVal=None, maxVal=None, stepSize=None, strvaluelist=None, widget=None, seq=None, parent=None):
+        self._db_id = id
+        self._db_vtid = vtid
+        self._db_vttype = vttype
+        self._db_vtparent_type = vtparent_type
+        self._db_vtparent_id = vtparent_id
+        self._db_vtpos = vtpos
+        self._db_vtmid = vtmid
+        self._db_pos = pos
+        self._db_type = type
+        self._db_val = val
+        self._db_minVal = minVal
+        self._db_maxVal = maxVal
+        self._db_stepSize = stepSize
+        self._db_strvaluelist = strvaluelist
+        self._db_widget = widget
+        self._db_seq = seq
+        self._db_parent = parent
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashupComponent.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashupComponent(id=self._db_id,
+                               vtid=self._db_vtid,
+                               vttype=self._db_vttype,
+                               vtparent_type=self._db_vtparent_type,
+                               vtparent_id=self._db_vtparent_id,
+                               vtpos=self._db_vtpos,
+                               vtmid=self._db_vtmid,
+                               pos=self._db_pos,
+                               type=self._db_type,
+                               val=self._db_val,
+                               minVal=self._db_minVal,
+                               maxVal=self._db_maxVal,
+                               stepSize=self._db_stepSize,
+                               strvaluelist=self._db_strvaluelist,
+                               widget=self._db_widget,
+                               seq=self._db_seq,
+                               parent=self._db_parent)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashupComponent()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'vtid' in class_dict:
+            res = class_dict['vtid'](old_obj, trans_dict)
+            new_obj.db_vtid = res
+        elif hasattr(old_obj, 'db_vtid') and old_obj.db_vtid is not None:
+            new_obj.db_vtid = old_obj.db_vtid
+        if 'vttype' in class_dict:
+            res = class_dict['vttype'](old_obj, trans_dict)
+            new_obj.db_vttype = res
+        elif hasattr(old_obj, 'db_vttype') and old_obj.db_vttype is not None:
+            new_obj.db_vttype = old_obj.db_vttype
+        if 'vtparent_type' in class_dict:
+            res = class_dict['vtparent_type'](old_obj, trans_dict)
+            new_obj.db_vtparent_type = res
+        elif hasattr(old_obj, 'db_vtparent_type') and old_obj.db_vtparent_type is not None:
+            new_obj.db_vtparent_type = old_obj.db_vtparent_type
+        if 'vtparent_id' in class_dict:
+            res = class_dict['vtparent_id'](old_obj, trans_dict)
+            new_obj.db_vtparent_id = res
+        elif hasattr(old_obj, 'db_vtparent_id') and old_obj.db_vtparent_id is not None:
+            new_obj.db_vtparent_id = old_obj.db_vtparent_id
+        if 'vtpos' in class_dict:
+            res = class_dict['vtpos'](old_obj, trans_dict)
+            new_obj.db_vtpos = res
+        elif hasattr(old_obj, 'db_vtpos') and old_obj.db_vtpos is not None:
+            new_obj.db_vtpos = old_obj.db_vtpos
+        if 'vtmid' in class_dict:
+            res = class_dict['vtmid'](old_obj, trans_dict)
+            new_obj.db_vtmid = res
+        elif hasattr(old_obj, 'db_vtmid') and old_obj.db_vtmid is not None:
+            new_obj.db_vtmid = old_obj.db_vtmid
+        if 'pos' in class_dict:
+            res = class_dict['pos'](old_obj, trans_dict)
+            new_obj.db_pos = res
+        elif hasattr(old_obj, 'db_pos') and old_obj.db_pos is not None:
+            new_obj.db_pos = old_obj.db_pos
+        if 'type' in class_dict:
+            res = class_dict['type'](old_obj, trans_dict)
+            new_obj.db_type = res
+        elif hasattr(old_obj, 'db_type') and old_obj.db_type is not None:
+            new_obj.db_type = old_obj.db_type
+        if 'val' in class_dict:
+            res = class_dict['val'](old_obj, trans_dict)
+            new_obj.db_val = res
+        elif hasattr(old_obj, 'db_val') and old_obj.db_val is not None:
+            new_obj.db_val = old_obj.db_val
+        if 'minVal' in class_dict:
+            res = class_dict['minVal'](old_obj, trans_dict)
+            new_obj.db_minVal = res
+        elif hasattr(old_obj, 'db_minVal') and old_obj.db_minVal is not None:
+            new_obj.db_minVal = old_obj.db_minVal
+        if 'maxVal' in class_dict:
+            res = class_dict['maxVal'](old_obj, trans_dict)
+            new_obj.db_maxVal = res
+        elif hasattr(old_obj, 'db_maxVal') and old_obj.db_maxVal is not None:
+            new_obj.db_maxVal = old_obj.db_maxVal
+        if 'stepSize' in class_dict:
+            res = class_dict['stepSize'](old_obj, trans_dict)
+            new_obj.db_stepSize = res
+        elif hasattr(old_obj, 'db_stepSize') and old_obj.db_stepSize is not None:
+            new_obj.db_stepSize = old_obj.db_stepSize
+        if 'strvaluelist' in class_dict:
+            res = class_dict['strvaluelist'](old_obj, trans_dict)
+            new_obj.db_strvaluelist = res
+        elif hasattr(old_obj, 'db_strvaluelist') and old_obj.db_strvaluelist is not None:
+            new_obj.db_strvaluelist = old_obj.db_strvaluelist
+        if 'widget' in class_dict:
+            res = class_dict['widget'](old_obj, trans_dict)
+            new_obj.db_widget = res
+        elif hasattr(old_obj, 'db_widget') and old_obj.db_widget is not None:
+            new_obj.db_widget = old_obj.db_widget
+        if 'seq' in class_dict:
+            res = class_dict['seq'](old_obj, trans_dict)
+            new_obj.db_seq = res
+        elif hasattr(old_obj, 'db_seq') and old_obj.db_seq is not None:
+            new_obj.db_seq = old_obj.db_seq
+        if 'parent' in class_dict:
+            res = class_dict['parent'](old_obj, trans_dict)
+            new_obj.db_parent = res
+        elif hasattr(old_obj, 'db_parent') and old_obj.db_parent is not None:
+            new_obj.db_parent = old_obj.db_parent
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_vtid(self):
+        return self._db_vtid
+    def __set_db_vtid(self, vtid):
+        self._db_vtid = vtid
+        self.is_dirty = True
+    db_vtid = property(__get_db_vtid, __set_db_vtid)
+    def db_add_vtid(self, vtid):
+        self._db_vtid = vtid
+    def db_change_vtid(self, vtid):
+        self._db_vtid = vtid
+    def db_delete_vtid(self, vtid):
+        self._db_vtid = None
+    
+    def __get_db_vttype(self):
+        return self._db_vttype
+    def __set_db_vttype(self, vttype):
+        self._db_vttype = vttype
+        self.is_dirty = True
+    db_vttype = property(__get_db_vttype, __set_db_vttype)
+    def db_add_vttype(self, vttype):
+        self._db_vttype = vttype
+    def db_change_vttype(self, vttype):
+        self._db_vttype = vttype
+    def db_delete_vttype(self, vttype):
+        self._db_vttype = None
+    
+    def __get_db_vtparent_type(self):
+        return self._db_vtparent_type
+    def __set_db_vtparent_type(self, vtparent_type):
+        self._db_vtparent_type = vtparent_type
+        self.is_dirty = True
+    db_vtparent_type = property(__get_db_vtparent_type, __set_db_vtparent_type)
+    def db_add_vtparent_type(self, vtparent_type):
+        self._db_vtparent_type = vtparent_type
+    def db_change_vtparent_type(self, vtparent_type):
+        self._db_vtparent_type = vtparent_type
+    def db_delete_vtparent_type(self, vtparent_type):
+        self._db_vtparent_type = None
+    
+    def __get_db_vtparent_id(self):
+        return self._db_vtparent_id
+    def __set_db_vtparent_id(self, vtparent_id):
+        self._db_vtparent_id = vtparent_id
+        self.is_dirty = True
+    db_vtparent_id = property(__get_db_vtparent_id, __set_db_vtparent_id)
+    def db_add_vtparent_id(self, vtparent_id):
+        self._db_vtparent_id = vtparent_id
+    def db_change_vtparent_id(self, vtparent_id):
+        self._db_vtparent_id = vtparent_id
+    def db_delete_vtparent_id(self, vtparent_id):
+        self._db_vtparent_id = None
+    
+    def __get_db_vtpos(self):
+        return self._db_vtpos
+    def __set_db_vtpos(self, vtpos):
+        self._db_vtpos = vtpos
+        self.is_dirty = True
+    db_vtpos = property(__get_db_vtpos, __set_db_vtpos)
+    def db_add_vtpos(self, vtpos):
+        self._db_vtpos = vtpos
+    def db_change_vtpos(self, vtpos):
+        self._db_vtpos = vtpos
+    def db_delete_vtpos(self, vtpos):
+        self._db_vtpos = None
+    
+    def __get_db_vtmid(self):
+        return self._db_vtmid
+    def __set_db_vtmid(self, vtmid):
+        self._db_vtmid = vtmid
+        self.is_dirty = True
+    db_vtmid = property(__get_db_vtmid, __set_db_vtmid)
+    def db_add_vtmid(self, vtmid):
+        self._db_vtmid = vtmid
+    def db_change_vtmid(self, vtmid):
+        self._db_vtmid = vtmid
+    def db_delete_vtmid(self, vtmid):
+        self._db_vtmid = None
+    
+    def __get_db_pos(self):
+        return self._db_pos
+    def __set_db_pos(self, pos):
+        self._db_pos = pos
+        self.is_dirty = True
+    db_pos = property(__get_db_pos, __set_db_pos)
+    def db_add_pos(self, pos):
+        self._db_pos = pos
+    def db_change_pos(self, pos):
+        self._db_pos = pos
+    def db_delete_pos(self, pos):
+        self._db_pos = None
+    
+    def __get_db_type(self):
+        return self._db_type
+    def __set_db_type(self, type):
+        self._db_type = type
+        self.is_dirty = True
+    db_type = property(__get_db_type, __set_db_type)
+    def db_add_type(self, type):
+        self._db_type = type
+    def db_change_type(self, type):
+        self._db_type = type
+    def db_delete_type(self, type):
+        self._db_type = None
+    
+    def __get_db_val(self):
+        return self._db_val
+    def __set_db_val(self, val):
+        self._db_val = val
+        self.is_dirty = True
+    db_val = property(__get_db_val, __set_db_val)
+    def db_add_val(self, val):
+        self._db_val = val
+    def db_change_val(self, val):
+        self._db_val = val
+    def db_delete_val(self, val):
+        self._db_val = None
+    
+    def __get_db_minVal(self):
+        return self._db_minVal
+    def __set_db_minVal(self, minVal):
+        self._db_minVal = minVal
+        self.is_dirty = True
+    db_minVal = property(__get_db_minVal, __set_db_minVal)
+    def db_add_minVal(self, minVal):
+        self._db_minVal = minVal
+    def db_change_minVal(self, minVal):
+        self._db_minVal = minVal
+    def db_delete_minVal(self, minVal):
+        self._db_minVal = None
+    
+    def __get_db_maxVal(self):
+        return self._db_maxVal
+    def __set_db_maxVal(self, maxVal):
+        self._db_maxVal = maxVal
+        self.is_dirty = True
+    db_maxVal = property(__get_db_maxVal, __set_db_maxVal)
+    def db_add_maxVal(self, maxVal):
+        self._db_maxVal = maxVal
+    def db_change_maxVal(self, maxVal):
+        self._db_maxVal = maxVal
+    def db_delete_maxVal(self, maxVal):
+        self._db_maxVal = None
+    
+    def __get_db_stepSize(self):
+        return self._db_stepSize
+    def __set_db_stepSize(self, stepSize):
+        self._db_stepSize = stepSize
+        self.is_dirty = True
+    db_stepSize = property(__get_db_stepSize, __set_db_stepSize)
+    def db_add_stepSize(self, stepSize):
+        self._db_stepSize = stepSize
+    def db_change_stepSize(self, stepSize):
+        self._db_stepSize = stepSize
+    def db_delete_stepSize(self, stepSize):
+        self._db_stepSize = None
+    
+    def __get_db_strvaluelist(self):
+        return self._db_strvaluelist
+    def __set_db_strvaluelist(self, strvaluelist):
+        self._db_strvaluelist = strvaluelist
+        self.is_dirty = True
+    db_strvaluelist = property(__get_db_strvaluelist, __set_db_strvaluelist)
+    def db_add_strvaluelist(self, strvaluelist):
+        self._db_strvaluelist = strvaluelist
+    def db_change_strvaluelist(self, strvaluelist):
+        self._db_strvaluelist = strvaluelist
+    def db_delete_strvaluelist(self, strvaluelist):
+        self._db_strvaluelist = None
+    
+    def __get_db_widget(self):
+        return self._db_widget
+    def __set_db_widget(self, widget):
+        self._db_widget = widget
+        self.is_dirty = True
+    db_widget = property(__get_db_widget, __set_db_widget)
+    def db_add_widget(self, widget):
+        self._db_widget = widget
+    def db_change_widget(self, widget):
+        self._db_widget = widget
+    def db_delete_widget(self, widget):
+        self._db_widget = None
+    
+    def __get_db_seq(self):
+        return self._db_seq
+    def __set_db_seq(self, seq):
+        self._db_seq = seq
+        self.is_dirty = True
+    db_seq = property(__get_db_seq, __set_db_seq)
+    def db_add_seq(self, seq):
+        self._db_seq = seq
+    def db_change_seq(self, seq):
+        self._db_seq = seq
+    def db_delete_seq(self, seq):
+        self._db_seq = None
+    
+    def __get_db_parent(self):
+        return self._db_parent
+    def __set_db_parent(self, parent):
+        self._db_parent = parent
+        self.is_dirty = True
+    db_parent = property(__get_db_parent, __set_db_parent)
+    def db_add_parent(self, parent):
+        self._db_parent = parent
+    def db_change_parent(self, parent):
+        self._db_parent = parent
+    def db_delete_parent(self, parent):
+        self._db_parent = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMashup(object):
+
+    vtType = 'mashup'
+
+    def __init__(self, id=None, name=None, version=None, aliases=None, type=None, vtid=None, layout=None, geometry=None, has_seq=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_version = version
+        self.db_deleted_aliases = []
+        self.db_aliases_id_index = {}
+        if aliases is None:
+            self._db_aliases = []
+        else:
+            self._db_aliases = aliases
+            for v in self._db_aliases:
+                self.db_aliases_id_index[v.db_id] = v
+        self._db_type = type
+        self._db_vtid = vtid
+        self._db_layout = layout
+        self._db_geometry = geometry
+        self._db_has_seq = has_seq
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashup.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashup(id=self._db_id,
+                      name=self._db_name,
+                      version=self._db_version,
+                      type=self._db_type,
+                      vtid=self._db_vtid,
+                      layout=self._db_layout,
+                      geometry=self._db_geometry,
+                      has_seq=self._db_has_seq)
+        if self._db_aliases is None:
+            cp._db_aliases = []
+        else:
+            cp._db_aliases = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_aliases]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_vtid') and ('vistrail', self._db_vtid) in id_remap:
+                cp._db_vtid = id_remap[('vistrail', self._db_vtid)]
+        
+        # recreate indices and set flags
+        cp.db_aliases_id_index = dict((v.db_id, v) for v in cp._db_aliases)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashup()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'aliases' in class_dict:
+            res = class_dict['aliases'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_alias(obj)
+        elif hasattr(old_obj, 'db_aliases') and old_obj.db_aliases is not None:
+            for obj in old_obj.db_aliases:
+                new_obj.db_add_alias(DBMashupAlias.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_aliases') and hasattr(new_obj, 'db_deleted_aliases'):
+            for obj in old_obj.db_deleted_aliases:
+                n_obj = DBMashupAlias.update_version(obj, trans_dict)
+                new_obj.db_deleted_aliases.append(n_obj)
+        if 'type' in class_dict:
+            res = class_dict['type'](old_obj, trans_dict)
+            new_obj.db_type = res
+        elif hasattr(old_obj, 'db_type') and old_obj.db_type is not None:
+            new_obj.db_type = old_obj.db_type
+        if 'vtid' in class_dict:
+            res = class_dict['vtid'](old_obj, trans_dict)
+            new_obj.db_vtid = res
+        elif hasattr(old_obj, 'db_vtid') and old_obj.db_vtid is not None:
+            new_obj.db_vtid = old_obj.db_vtid
+        if 'layout' in class_dict:
+            res = class_dict['layout'](old_obj, trans_dict)
+            new_obj.db_layout = res
+        elif hasattr(old_obj, 'db_layout') and old_obj.db_layout is not None:
+            new_obj.db_layout = old_obj.db_layout
+        if 'geometry' in class_dict:
+            res = class_dict['geometry'](old_obj, trans_dict)
+            new_obj.db_geometry = res
+        elif hasattr(old_obj, 'db_geometry') and old_obj.db_geometry is not None:
+            new_obj.db_geometry = old_obj.db_geometry
+        if 'has_seq' in class_dict:
+            res = class_dict['has_seq'](old_obj, trans_dict)
+            new_obj.db_has_seq = res
+        elif hasattr(old_obj, 'db_has_seq') and old_obj.db_has_seq is not None:
+            new_obj.db_has_seq = old_obj.db_has_seq
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_aliases:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_alias(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_aliases)
+        if remove:
+            self.db_deleted_aliases = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_aliases:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_aliases(self):
+        return self._db_aliases
+    def __set_db_aliases(self, aliases):
+        self._db_aliases = aliases
+        self.is_dirty = True
+    db_aliases = property(__get_db_aliases, __set_db_aliases)
+    def db_get_aliases(self):
+        return self._db_aliases
+    def db_add_alias(self, alias):
+        self.is_dirty = True
+        self._db_aliases.append(alias)
+        self.db_aliases_id_index[alias.db_id] = alias
+    def db_change_alias(self, alias):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_aliases)):
+            if self._db_aliases[i].db_id == alias.db_id:
+                self._db_aliases[i] = alias
+                found = True
+                break
+        if not found:
+            self._db_aliases.append(alias)
+        self.db_aliases_id_index[alias.db_id] = alias
+    def db_delete_alias(self, alias):
+        self.is_dirty = True
+        for i in xrange(len(self._db_aliases)):
+            if self._db_aliases[i].db_id == alias.db_id:
+                if not self._db_aliases[i].is_new:
+                    self.db_deleted_aliases.append(self._db_aliases[i])
+                del self._db_aliases[i]
+                break
+        del self.db_aliases_id_index[alias.db_id]
+    def db_get_alias(self, key):
+        for i in xrange(len(self._db_aliases)):
+            if self._db_aliases[i].db_id == key:
+                return self._db_aliases[i]
+        return None
+    def db_get_alias_by_id(self, key):
+        return self.db_aliases_id_index[key]
+    def db_has_alias_with_id(self, key):
+        return key in self.db_aliases_id_index
+    
+    def __get_db_type(self):
+        return self._db_type
+    def __set_db_type(self, type):
+        self._db_type = type
+        self.is_dirty = True
+    db_type = property(__get_db_type, __set_db_type)
+    def db_add_type(self, type):
+        self._db_type = type
+    def db_change_type(self, type):
+        self._db_type = type
+    def db_delete_type(self, type):
+        self._db_type = None
+    
+    def __get_db_vtid(self):
+        return self._db_vtid
+    def __set_db_vtid(self, vtid):
+        self._db_vtid = vtid
+        self.is_dirty = True
+    db_vtid = property(__get_db_vtid, __set_db_vtid)
+    def db_add_vtid(self, vtid):
+        self._db_vtid = vtid
+    def db_change_vtid(self, vtid):
+        self._db_vtid = vtid
+    def db_delete_vtid(self, vtid):
+        self._db_vtid = None
+    
+    def __get_db_layout(self):
+        return self._db_layout
+    def __set_db_layout(self, layout):
+        self._db_layout = layout
+        self.is_dirty = True
+    db_layout = property(__get_db_layout, __set_db_layout)
+    def db_add_layout(self, layout):
+        self._db_layout = layout
+    def db_change_layout(self, layout):
+        self._db_layout = layout
+    def db_delete_layout(self, layout):
+        self._db_layout = None
+    
+    def __get_db_geometry(self):
+        return self._db_geometry
+    def __set_db_geometry(self, geometry):
+        self._db_geometry = geometry
+        self.is_dirty = True
+    db_geometry = property(__get_db_geometry, __set_db_geometry)
+    def db_add_geometry(self, geometry):
+        self._db_geometry = geometry
+    def db_change_geometry(self, geometry):
+        self._db_geometry = geometry
+    def db_delete_geometry(self, geometry):
+        self._db_geometry = None
+    
+    def __get_db_has_seq(self):
+        return self._db_has_seq
+    def __set_db_has_seq(self, has_seq):
+        self._db_has_seq = has_seq
+        self.is_dirty = True
+    db_has_seq = property(__get_db_has_seq, __set_db_has_seq)
+    def db_add_has_seq(self, has_seq):
+        self._db_has_seq = has_seq
+    def db_change_has_seq(self, has_seq):
+        self._db_has_seq = has_seq
+    def db_delete_has_seq(self, has_seq):
+        self._db_has_seq = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMachine(object):
+
+    vtType = 'machine'
+
+    def __init__(self, id=None, name=None, os=None, architecture=None, processor=None, ram=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_os = os
+        self._db_architecture = architecture
+        self._db_processor = processor
+        self._db_ram = ram
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMachine.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMachine(id=self._db_id,
+                       name=self._db_name,
+                       os=self._db_os,
+                       architecture=self._db_architecture,
+                       processor=self._db_processor,
+                       ram=self._db_ram)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_vistrailId') and ('vistrail', self._db_vistrailId) in id_remap:
+                cp._db_vistrailId = id_remap[('vistrail', self._db_vistrailId)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMachine()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'os' in class_dict:
+            res = class_dict['os'](old_obj, trans_dict)
+            new_obj.db_os = res
+        elif hasattr(old_obj, 'db_os') and old_obj.db_os is not None:
+            new_obj.db_os = old_obj.db_os
+        if 'architecture' in class_dict:
+            res = class_dict['architecture'](old_obj, trans_dict)
+            new_obj.db_architecture = res
+        elif hasattr(old_obj, 'db_architecture') and old_obj.db_architecture is not None:
+            new_obj.db_architecture = old_obj.db_architecture
+        if 'processor' in class_dict:
+            res = class_dict['processor'](old_obj, trans_dict)
+            new_obj.db_processor = res
+        elif hasattr(old_obj, 'db_processor') and old_obj.db_processor is not None:
+            new_obj.db_processor = old_obj.db_processor
+        if 'ram' in class_dict:
+            res = class_dict['ram'](old_obj, trans_dict)
+            new_obj.db_ram = res
+        elif hasattr(old_obj, 'db_ram') and old_obj.db_ram is not None:
+            new_obj.db_ram = old_obj.db_ram
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_os(self):
+        return self._db_os
+    def __set_db_os(self, os):
+        self._db_os = os
+        self.is_dirty = True
+    db_os = property(__get_db_os, __set_db_os)
+    def db_add_os(self, os):
+        self._db_os = os
+    def db_change_os(self, os):
+        self._db_os = os
+    def db_delete_os(self, os):
+        self._db_os = None
+    
+    def __get_db_architecture(self):
+        return self._db_architecture
+    def __set_db_architecture(self, architecture):
+        self._db_architecture = architecture
+        self.is_dirty = True
+    db_architecture = property(__get_db_architecture, __set_db_architecture)
+    def db_add_architecture(self, architecture):
+        self._db_architecture = architecture
+    def db_change_architecture(self, architecture):
+        self._db_architecture = architecture
+    def db_delete_architecture(self, architecture):
+        self._db_architecture = None
+    
+    def __get_db_processor(self):
+        return self._db_processor
+    def __set_db_processor(self, processor):
+        self._db_processor = processor
+        self.is_dirty = True
+    db_processor = property(__get_db_processor, __set_db_processor)
+    def db_add_processor(self, processor):
+        self._db_processor = processor
+    def db_change_processor(self, processor):
+        self._db_processor = processor
+    def db_delete_processor(self, processor):
+        self._db_processor = None
+    
+    def __get_db_ram(self):
+        return self._db_ram
+    def __set_db_ram(self, ram):
+        self._db_ram = ram
+        self.is_dirty = True
+    db_ram = property(__get_db_ram, __set_db_ram)
+    def db_add_ram(self, ram):
+        self._db_ram = ram
+    def db_change_ram(self, ram):
+        self._db_ram = ram
+    def db_delete_ram(self, ram):
+        self._db_ram = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBConfigFloat(object):
+
+    vtType = 'config_float'
+
+    def __init__(self, value=None):
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBConfigFloat.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBConfigFloat(value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBConfigFloat()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+
+
+class DBOther(object):
+
+    vtType = 'other'
+
+    def __init__(self, id=None, key=None, value=None):
+        self._db_id = id
+        self._db_key = key
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOther.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOther(id=self._db_id,
+                     key=self._db_key,
+                     value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOther()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'key' in class_dict:
+            res = class_dict['key'](old_obj, trans_dict)
+            new_obj.db_key = res
+        elif hasattr(old_obj, 'db_key') and old_obj.db_key is not None:
+            new_obj.db_key = old_obj.db_key
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_key(self):
+        return self._db_key
+    def __set_db_key(self, key):
+        self._db_key = key
+        self.is_dirty = True
+    db_key = property(__get_db_key, __set_db_key)
+    def db_add_key(self, key):
+        self._db_key = key
+    def db_change_key(self, key):
+        self._db_key = key
+    def db_delete_key(self, key):
+        self._db_key = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBRefProvActivity(object):
+
+    vtType = 'ref_prov_activity'
+
+    def __init__(self, prov_ref=None):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBRefProvActivity.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBRefProvActivity(prov_ref=self._db_prov_ref)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_prov_ref') and ('prov_activity', self._db_prov_ref) in id_remap:
+                cp._db_prov_ref = id_remap[('prov_activity', self._db_prov_ref)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRefProvActivity()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_ref' in class_dict:
+            res = class_dict['prov_ref'](old_obj, trans_dict)
+            new_obj.db_prov_ref = res
+        elif hasattr(old_obj, 'db_prov_ref') and old_obj.db_prov_ref is not None:
+            new_obj.db_prov_ref = old_obj.db_prov_ref
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_prov_ref(self):
+        return self._db_prov_ref
+    def __set_db_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+        self.is_dirty = True
+    db_prov_ref = property(__get_db_prov_ref, __set_db_prov_ref)
+    def db_add_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_change_prov_ref(self, prov_ref):
+        self._db_prov_ref = prov_ref
+    def db_delete_prov_ref(self, prov_ref):
+        self._db_prov_ref = None
+    
+
+
+class DBAbstraction(object):
+
+    vtType = 'abstraction'
+
+    def __init__(self, id=None, cache=None, name=None, namespace=None, package=None, version=None, internal_version=None, location=None, functions=None, annotations=None, controlParameters=None):
+        self._db_id = id
+        self._db_cache = cache
+        self._db_name = name
+        self._db_namespace = namespace
+        self._db_package = package
+        self._db_version = version
+        self._db_internal_version = internal_version
+        self.db_deleted_location = []
+        self._db_location = location
+        self.db_deleted_functions = []
+        self.db_functions_id_index = {}
+        if functions is None:
+            self._db_functions = []
+        else:
+            self._db_functions = functions
+            for v in self._db_functions:
+                self.db_functions_id_index[v.db_id] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.db_deleted_controlParameters = []
+        self.db_controlParameters_id_index = {}
+        self.db_controlParameters_name_index = {}
+        if controlParameters is None:
+            self._db_controlParameters = []
+        else:
+            self._db_controlParameters = controlParameters
+            for v in self._db_controlParameters:
+                self.db_controlParameters_id_index[v.db_id] = v
+                self.db_controlParameters_name_index[v.db_name] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBAbstraction.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBAbstraction(id=self._db_id,
+                           cache=self._db_cache,
+                           name=self._db_name,
+                           namespace=self._db_namespace,
+                           package=self._db_package,
+                           version=self._db_version,
+                           internal_version=self._db_internal_version)
+        if self._db_location is not None:
+            cp._db_location = self._db_location.do_copy(new_ids, id_scope, id_remap)
+        if self._db_functions is None:
+            cp._db_functions = []
+        else:
+            cp._db_functions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_functions]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_controlParameters is None:
+            cp._db_controlParameters = []
+        else:
+            cp._db_controlParameters = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_controlParameters]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_functions_id_index = dict((v.db_id, v) for v in cp._db_functions)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        cp.db_controlParameters_id_index = dict((v.db_id, v) for v in cp._db_controlParameters)
+        cp.db_controlParameters_name_index = dict((v.db_name, v) for v in cp._db_controlParameters)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBAbstraction()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'cache' in class_dict:
+            res = class_dict['cache'](old_obj, trans_dict)
+            new_obj.db_cache = res
+        elif hasattr(old_obj, 'db_cache') and old_obj.db_cache is not None:
+            new_obj.db_cache = old_obj.db_cache
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'namespace' in class_dict:
+            res = class_dict['namespace'](old_obj, trans_dict)
+            new_obj.db_namespace = res
+        elif hasattr(old_obj, 'db_namespace') and old_obj.db_namespace is not None:
+            new_obj.db_namespace = old_obj.db_namespace
+        if 'package' in class_dict:
+            res = class_dict['package'](old_obj, trans_dict)
+            new_obj.db_package = res
+        elif hasattr(old_obj, 'db_package') and old_obj.db_package is not None:
+            new_obj.db_package = old_obj.db_package
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'internal_version' in class_dict:
+            res = class_dict['internal_version'](old_obj, trans_dict)
+            new_obj.db_internal_version = res
+        elif hasattr(old_obj, 'db_internal_version') and old_obj.db_internal_version is not None:
+            new_obj.db_internal_version = old_obj.db_internal_version
+        if 'location' in class_dict:
+            res = class_dict['location'](old_obj, trans_dict)
+            new_obj.db_location = res
+        elif hasattr(old_obj, 'db_location') and old_obj.db_location is not None:
+            obj = old_obj.db_location
+            new_obj.db_add_location(DBLocation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_location') and hasattr(new_obj, 'db_deleted_location'):
+            for obj in old_obj.db_deleted_location:
+                n_obj = DBLocation.update_version(obj, trans_dict)
+                new_obj.db_deleted_location.append(n_obj)
+        if 'functions' in class_dict:
+            res = class_dict['functions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_function(obj)
+        elif hasattr(old_obj, 'db_functions') and old_obj.db_functions is not None:
+            for obj in old_obj.db_functions:
+                new_obj.db_add_function(DBFunction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_functions') and hasattr(new_obj, 'db_deleted_functions'):
+            for obj in old_obj.db_deleted_functions:
+                n_obj = DBFunction.update_version(obj, trans_dict)
+                new_obj.db_deleted_functions.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'controlParameters' in class_dict:
+            res = class_dict['controlParameters'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_controlParameter(obj)
+        elif hasattr(old_obj, 'db_controlParameters') and old_obj.db_controlParameters is not None:
+            for obj in old_obj.db_controlParameters:
+                new_obj.db_add_controlParameter(DBControlParameter.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_controlParameters') and hasattr(new_obj, 'db_deleted_controlParameters'):
+            for obj in old_obj.db_deleted_controlParameters:
+                n_obj = DBControlParameter.update_version(obj, trans_dict)
+                new_obj.db_deleted_controlParameters.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_location is not None:
+            children.extend(self._db_location.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_location = None
+        to_del = []
+        for child in self.db_functions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_function(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_controlParameters:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_controlParameter(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_location)
+        children.extend(self.db_deleted_functions)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_controlParameters)
+        if remove:
+            self.db_deleted_location = []
+            self.db_deleted_functions = []
+            self.db_deleted_annotations = []
+            self.db_deleted_controlParameters = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_location is not None and self._db_location.has_changes():
+            return True
+        for child in self._db_functions:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_controlParameters:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_cache(self):
+        return self._db_cache
+    def __set_db_cache(self, cache):
+        self._db_cache = cache
+        self.is_dirty = True
+    db_cache = property(__get_db_cache, __set_db_cache)
+    def db_add_cache(self, cache):
+        self._db_cache = cache
+    def db_change_cache(self, cache):
+        self._db_cache = cache
+    def db_delete_cache(self, cache):
+        self._db_cache = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_namespace(self):
+        return self._db_namespace
+    def __set_db_namespace(self, namespace):
+        self._db_namespace = namespace
+        self.is_dirty = True
+    db_namespace = property(__get_db_namespace, __set_db_namespace)
+    def db_add_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_change_namespace(self, namespace):
+        self._db_namespace = namespace
+    def db_delete_namespace(self, namespace):
+        self._db_namespace = None
+    
+    def __get_db_package(self):
+        return self._db_package
+    def __set_db_package(self, package):
+        self._db_package = package
+        self.is_dirty = True
+    db_package = property(__get_db_package, __set_db_package)
+    def db_add_package(self, package):
+        self._db_package = package
+    def db_change_package(self, package):
+        self._db_package = package
+    def db_delete_package(self, package):
+        self._db_package = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_internal_version(self):
+        return self._db_internal_version
+    def __set_db_internal_version(self, internal_version):
+        self._db_internal_version = internal_version
+        self.is_dirty = True
+    db_internal_version = property(__get_db_internal_version, __set_db_internal_version)
+    def db_add_internal_version(self, internal_version):
+        self._db_internal_version = internal_version
+    def db_change_internal_version(self, internal_version):
+        self._db_internal_version = internal_version
+    def db_delete_internal_version(self, internal_version):
+        self._db_internal_version = None
+    
+    def __get_db_location(self):
+        return self._db_location
+    def __set_db_location(self, location):
+        self._db_location = location
+        self.is_dirty = True
+    db_location = property(__get_db_location, __set_db_location)
+    def db_add_location(self, location):
+        self._db_location = location
+    def db_change_location(self, location):
+        self._db_location = location
+    def db_delete_location(self, location):
+        if not self.is_new:
+            self.db_deleted_location.append(self._db_location)
+        self._db_location = None
+    
+    def __get_db_functions(self):
+        return self._db_functions
+    def __set_db_functions(self, functions):
+        self._db_functions = functions
+        self.is_dirty = True
+    db_functions = property(__get_db_functions, __set_db_functions)
+    def db_get_functions(self):
+        return self._db_functions
+    def db_add_function(self, function):
+        self.is_dirty = True
+        self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_change_function(self, function):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                self._db_functions[i] = function
+                found = True
+                break
+        if not found:
+            self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_delete_function(self, function):
+        self.is_dirty = True
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                if not self._db_functions[i].is_new:
+                    self.db_deleted_functions.append(self._db_functions[i])
+                del self._db_functions[i]
+                break
+        del self.db_functions_id_index[function.db_id]
+    def db_get_function(self, key):
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == key:
+                return self._db_functions[i]
+        return None
+    def db_get_function_by_id(self, key):
+        return self.db_functions_id_index[key]
+    def db_has_function_with_id(self, key):
+        return key in self.db_functions_id_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def __get_db_controlParameters(self):
+        return self._db_controlParameters
+    def __set_db_controlParameters(self, controlParameters):
+        self._db_controlParameters = controlParameters
+        self.is_dirty = True
+    db_controlParameters = property(__get_db_controlParameters, __set_db_controlParameters)
+    def db_get_controlParameters(self):
+        return self._db_controlParameters
+    def db_add_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_change_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                self._db_controlParameters[i] = controlParameter
+                found = True
+                break
+        if not found:
+            self._db_controlParameters.append(controlParameter)
+        self.db_controlParameters_id_index[controlParameter.db_id] = controlParameter
+        self.db_controlParameters_name_index[controlParameter.db_name] = controlParameter
+    def db_delete_controlParameter(self, controlParameter):
+        self.is_dirty = True
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == controlParameter.db_id:
+                if not self._db_controlParameters[i].is_new:
+                    self.db_deleted_controlParameters.append(self._db_controlParameters[i])
+                del self._db_controlParameters[i]
+                break
+        del self.db_controlParameters_id_index[controlParameter.db_id]
+        del self.db_controlParameters_name_index[controlParameter.db_name]
+    def db_get_controlParameter(self, key):
+        for i in xrange(len(self._db_controlParameters)):
+            if self._db_controlParameters[i].db_id == key:
+                return self._db_controlParameters[i]
+        return None
+    def db_get_controlParameter_by_id(self, key):
+        return self.db_controlParameters_id_index[key]
+    def db_has_controlParameter_with_id(self, key):
+        return key in self.db_controlParameters_id_index
+    def db_get_controlParameter_by_name(self, key):
+        return self.db_controlParameters_name_index[key]
+    def db_has_controlParameter_with_name(self, key):
+        return key in self.db_controlParameters_name_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvAgent(object):
+
+    vtType = 'prov_agent'
+
+    def __init__(self, id=None, vt_id=None, prov_type=None, prov_label=None, vt_machine_os=None, vt_machine_architecture=None, vt_machine_processor=None, vt_machine_ram=None):
+        self._db_id = id
+        self._db_vt_id = vt_id
+        self._db_prov_type = prov_type
+        self._db_prov_label = prov_label
+        self._db_vt_machine_os = vt_machine_os
+        self._db_vt_machine_architecture = vt_machine_architecture
+        self._db_vt_machine_processor = vt_machine_processor
+        self._db_vt_machine_ram = vt_machine_ram
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvAgent.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvAgent(id=self._db_id,
+                         vt_id=self._db_vt_id,
+                         prov_type=self._db_prov_type,
+                         prov_label=self._db_prov_label,
+                         vt_machine_os=self._db_vt_machine_os,
+                         vt_machine_architecture=self._db_vt_machine_architecture,
+                         vt_machine_processor=self._db_vt_machine_processor,
+                         vt_machine_ram=self._db_vt_machine_ram)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvAgent()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'vt_id' in class_dict:
+            res = class_dict['vt_id'](old_obj, trans_dict)
+            new_obj.db_vt_id = res
+        elif hasattr(old_obj, 'db_vt_id') and old_obj.db_vt_id is not None:
+            new_obj.db_vt_id = old_obj.db_vt_id
+        if 'prov_type' in class_dict:
+            res = class_dict['prov_type'](old_obj, trans_dict)
+            new_obj.db_prov_type = res
+        elif hasattr(old_obj, 'db_prov_type') and old_obj.db_prov_type is not None:
+            new_obj.db_prov_type = old_obj.db_prov_type
+        if 'prov_label' in class_dict:
+            res = class_dict['prov_label'](old_obj, trans_dict)
+            new_obj.db_prov_label = res
+        elif hasattr(old_obj, 'db_prov_label') and old_obj.db_prov_label is not None:
+            new_obj.db_prov_label = old_obj.db_prov_label
+        if 'vt_machine_os' in class_dict:
+            res = class_dict['vt_machine_os'](old_obj, trans_dict)
+            new_obj.db_vt_machine_os = res
+        elif hasattr(old_obj, 'db_vt_machine_os') and old_obj.db_vt_machine_os is not None:
+            new_obj.db_vt_machine_os = old_obj.db_vt_machine_os
+        if 'vt_machine_architecture' in class_dict:
+            res = class_dict['vt_machine_architecture'](old_obj, trans_dict)
+            new_obj.db_vt_machine_architecture = res
+        elif hasattr(old_obj, 'db_vt_machine_architecture') and old_obj.db_vt_machine_architecture is not None:
+            new_obj.db_vt_machine_architecture = old_obj.db_vt_machine_architecture
+        if 'vt_machine_processor' in class_dict:
+            res = class_dict['vt_machine_processor'](old_obj, trans_dict)
+            new_obj.db_vt_machine_processor = res
+        elif hasattr(old_obj, 'db_vt_machine_processor') and old_obj.db_vt_machine_processor is not None:
+            new_obj.db_vt_machine_processor = old_obj.db_vt_machine_processor
+        if 'vt_machine_ram' in class_dict:
+            res = class_dict['vt_machine_ram'](old_obj, trans_dict)
+            new_obj.db_vt_machine_ram = res
+        elif hasattr(old_obj, 'db_vt_machine_ram') and old_obj.db_vt_machine_ram is not None:
+            new_obj.db_vt_machine_ram = old_obj.db_vt_machine_ram
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_vt_id(self):
+        return self._db_vt_id
+    def __set_db_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+        self.is_dirty = True
+    db_vt_id = property(__get_db_vt_id, __set_db_vt_id)
+    def db_add_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_change_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_delete_vt_id(self, vt_id):
+        self._db_vt_id = None
+    
+    def __get_db_prov_type(self):
+        return self._db_prov_type
+    def __set_db_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+        self.is_dirty = True
+    db_prov_type = property(__get_db_prov_type, __set_db_prov_type)
+    def db_add_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+    def db_change_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+    def db_delete_prov_type(self, prov_type):
+        self._db_prov_type = None
+    
+    def __get_db_prov_label(self):
+        return self._db_prov_label
+    def __set_db_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+        self.is_dirty = True
+    db_prov_label = property(__get_db_prov_label, __set_db_prov_label)
+    def db_add_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+    def db_change_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+    def db_delete_prov_label(self, prov_label):
+        self._db_prov_label = None
+    
+    def __get_db_vt_machine_os(self):
+        return self._db_vt_machine_os
+    def __set_db_vt_machine_os(self, vt_machine_os):
+        self._db_vt_machine_os = vt_machine_os
+        self.is_dirty = True
+    db_vt_machine_os = property(__get_db_vt_machine_os, __set_db_vt_machine_os)
+    def db_add_vt_machine_os(self, vt_machine_os):
+        self._db_vt_machine_os = vt_machine_os
+    def db_change_vt_machine_os(self, vt_machine_os):
+        self._db_vt_machine_os = vt_machine_os
+    def db_delete_vt_machine_os(self, vt_machine_os):
+        self._db_vt_machine_os = None
+    
+    def __get_db_vt_machine_architecture(self):
+        return self._db_vt_machine_architecture
+    def __set_db_vt_machine_architecture(self, vt_machine_architecture):
+        self._db_vt_machine_architecture = vt_machine_architecture
+        self.is_dirty = True
+    db_vt_machine_architecture = property(__get_db_vt_machine_architecture, __set_db_vt_machine_architecture)
+    def db_add_vt_machine_architecture(self, vt_machine_architecture):
+        self._db_vt_machine_architecture = vt_machine_architecture
+    def db_change_vt_machine_architecture(self, vt_machine_architecture):
+        self._db_vt_machine_architecture = vt_machine_architecture
+    def db_delete_vt_machine_architecture(self, vt_machine_architecture):
+        self._db_vt_machine_architecture = None
+    
+    def __get_db_vt_machine_processor(self):
+        return self._db_vt_machine_processor
+    def __set_db_vt_machine_processor(self, vt_machine_processor):
+        self._db_vt_machine_processor = vt_machine_processor
+        self.is_dirty = True
+    db_vt_machine_processor = property(__get_db_vt_machine_processor, __set_db_vt_machine_processor)
+    def db_add_vt_machine_processor(self, vt_machine_processor):
+        self._db_vt_machine_processor = vt_machine_processor
+    def db_change_vt_machine_processor(self, vt_machine_processor):
+        self._db_vt_machine_processor = vt_machine_processor
+    def db_delete_vt_machine_processor(self, vt_machine_processor):
+        self._db_vt_machine_processor = None
+    
+    def __get_db_vt_machine_ram(self):
+        return self._db_vt_machine_ram
+    def __set_db_vt_machine_ram(self, vt_machine_ram):
+        self._db_vt_machine_ram = vt_machine_ram
+        self.is_dirty = True
+    db_vt_machine_ram = property(__get_db_vt_machine_ram, __set_db_vt_machine_ram)
+    def db_add_vt_machine_ram(self, vt_machine_ram):
+        self._db_vt_machine_ram = vt_machine_ram
+    def db_change_vt_machine_ram(self, vt_machine_ram):
+        self._db_vt_machine_ram = vt_machine_ram
+    def db_delete_vt_machine_ram(self, vt_machine_ram):
+        self._db_vt_machine_ram = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMashuptrail(object):
+
+    vtType = 'mashuptrail'
+
+    def __init__(self, id=None, name=None, version=None, vtVersion=None, last_modified=None, actions=None, annotations=None, actionAnnotations=None):
+        self._db_id = id
+        self._db_name = name
+        self._db_version = version
+        self._db_vtVersion = vtVersion
+        self._db_last_modified = last_modified
+        self.db_deleted_actions = []
+        self.db_actions_id_index = {}
+        if actions is None:
+            self._db_actions = []
+        else:
+            self._db_actions = actions
+            for v in self._db_actions:
+                self.db_actions_id_index[v.db_id] = v
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        self.db_annotations_key_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+                self.db_annotations_key_index[v.db_key] = v
+        self.db_deleted_actionAnnotations = []
+        self.db_actionAnnotations_id_index = {}
+        self.db_actionAnnotations_action_id_index = {}
+        self.db_actionAnnotations_key_index = {}
+        if actionAnnotations is None:
+            self._db_actionAnnotations = []
+        else:
+            self._db_actionAnnotations = actionAnnotations
+            for v in self._db_actionAnnotations:
+                self.db_actionAnnotations_id_index[v.db_id] = v
+                self.db_actionAnnotations_action_id_index[(v.db_action_id,v.db_key)] = v
+                self.db_actionAnnotations_key_index[(v.db_key,v.db_value)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashuptrail.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashuptrail(id=self._db_id,
+                           name=self._db_name,
+                           version=self._db_version,
+                           vtVersion=self._db_vtVersion,
+                           last_modified=self._db_last_modified)
+        if self._db_actions is None:
+            cp._db_actions = []
+        else:
+            cp._db_actions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_actions]
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_actionAnnotations is None:
+            cp._db_actionAnnotations = []
+        else:
+            cp._db_actionAnnotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_actionAnnotations]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_actions_id_index = dict((v.db_id, v) for v in cp._db_actions)
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_annotations_key_index = dict((v.db_key, v) for v in cp._db_annotations)
+        cp.db_actionAnnotations_id_index = dict((v.db_id, v) for v in cp._db_actionAnnotations)
+        cp.db_actionAnnotations_action_id_index = dict(((v.db_action_id,v.db_key), v) for v in cp._db_actionAnnotations)
+        cp.db_actionAnnotations_key_index = dict(((v.db_key,v.db_value), v) for v in cp._db_actionAnnotations)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashuptrail()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'vtVersion' in class_dict:
+            res = class_dict['vtVersion'](old_obj, trans_dict)
+            new_obj.db_vtVersion = res
+        elif hasattr(old_obj, 'db_vtVersion') and old_obj.db_vtVersion is not None:
+            new_obj.db_vtVersion = old_obj.db_vtVersion
+        if 'last_modified' in class_dict:
+            res = class_dict['last_modified'](old_obj, trans_dict)
+            new_obj.db_last_modified = res
+        elif hasattr(old_obj, 'db_last_modified') and old_obj.db_last_modified is not None:
+            new_obj.db_last_modified = old_obj.db_last_modified
+        if 'actions' in class_dict:
+            res = class_dict['actions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_action(obj)
+        elif hasattr(old_obj, 'db_actions') and old_obj.db_actions is not None:
+            for obj in old_obj.db_actions:
+                new_obj.db_add_action(DBMashupAction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_actions') and hasattr(new_obj, 'db_deleted_actions'):
+            for obj in old_obj.db_deleted_actions:
+                n_obj = DBMashupAction.update_version(obj, trans_dict)
+                new_obj.db_deleted_actions.append(n_obj)
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'actionAnnotations' in class_dict:
+            res = class_dict['actionAnnotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_actionAnnotation(obj)
+        elif hasattr(old_obj, 'db_actionAnnotations') and old_obj.db_actionAnnotations is not None:
+            for obj in old_obj.db_actionAnnotations:
+                new_obj.db_add_actionAnnotation(DBMashupActionAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_actionAnnotations') and hasattr(new_obj, 'db_deleted_actionAnnotations'):
+            for obj in old_obj.db_deleted_actionAnnotations:
+                n_obj = DBMashupActionAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_actionAnnotations.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_actions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_action(child)
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_actionAnnotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_actionAnnotation(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_actions)
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_actionAnnotations)
+        if remove:
+            self.db_deleted_actions = []
+            self.db_deleted_annotations = []
+            self.db_deleted_actionAnnotations = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_actions:
+            if child.has_changes():
+                return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_actionAnnotations:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_vtVersion(self):
+        return self._db_vtVersion
+    def __set_db_vtVersion(self, vtVersion):
+        self._db_vtVersion = vtVersion
+        self.is_dirty = True
+    db_vtVersion = property(__get_db_vtVersion, __set_db_vtVersion)
+    def db_add_vtVersion(self, vtVersion):
+        self._db_vtVersion = vtVersion
+    def db_change_vtVersion(self, vtVersion):
+        self._db_vtVersion = vtVersion
+    def db_delete_vtVersion(self, vtVersion):
+        self._db_vtVersion = None
+    
+    def __get_db_last_modified(self):
+        return self._db_last_modified
+    def __set_db_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+        self.is_dirty = True
+    db_last_modified = property(__get_db_last_modified, __set_db_last_modified)
+    def db_add_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_change_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_delete_last_modified(self, last_modified):
+        self._db_last_modified = None
+    
+    def __get_db_actions(self):
+        return self._db_actions
+    def __set_db_actions(self, actions):
+        self._db_actions = actions
+        self.is_dirty = True
+    db_actions = property(__get_db_actions, __set_db_actions)
+    def db_get_actions(self):
+        return self._db_actions
+    def db_add_action(self, action):
+        self.is_dirty = True
+        self._db_actions.append(action)
+        self.db_actions_id_index[action.db_id] = action
+    def db_change_action(self, action):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == action.db_id:
+                self._db_actions[i] = action
+                found = True
+                break
+        if not found:
+            self._db_actions.append(action)
+        self.db_actions_id_index[action.db_id] = action
+    def db_delete_action(self, action):
+        self.is_dirty = True
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == action.db_id:
+                if not self._db_actions[i].is_new:
+                    self.db_deleted_actions.append(self._db_actions[i])
+                del self._db_actions[i]
+                break
+        del self.db_actions_id_index[action.db_id]
+    def db_get_action(self, key):
+        for i in xrange(len(self._db_actions)):
+            if self._db_actions[i].db_id == key:
+                return self._db_actions[i]
+        return None
+    def db_get_action_by_id(self, key):
+        return self.db_actions_id_index[key]
+    def db_has_action_with_id(self, key):
+        return key in self.db_actions_id_index
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+        self.db_annotations_key_index[annotation.db_key] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+        del self.db_annotations_key_index[annotation.db_key]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    def db_get_annotation_by_key(self, key):
+        return self.db_annotations_key_index[key]
+    def db_has_annotation_with_key(self, key):
+        return key in self.db_annotations_key_index
+    
+    def __get_db_actionAnnotations(self):
+        return self._db_actionAnnotations
+    def __set_db_actionAnnotations(self, actionAnnotations):
+        self._db_actionAnnotations = actionAnnotations
+        self.is_dirty = True
+    db_actionAnnotations = property(__get_db_actionAnnotations, __set_db_actionAnnotations)
+    def db_get_actionAnnotations(self):
+        return self._db_actionAnnotations
+    def db_add_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        self._db_actionAnnotations.append(actionAnnotation)
+        self.db_actionAnnotations_id_index[actionAnnotation.db_id] = actionAnnotation
+        self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)] = actionAnnotation
+        self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)] = actionAnnotation
+    def db_change_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == actionAnnotation.db_id:
+                self._db_actionAnnotations[i] = actionAnnotation
+                found = True
+                break
+        if not found:
+            self._db_actionAnnotations.append(actionAnnotation)
+        self.db_actionAnnotations_id_index[actionAnnotation.db_id] = actionAnnotation
+        self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)] = actionAnnotation
+        self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)] = actionAnnotation
+    def db_delete_actionAnnotation(self, actionAnnotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == actionAnnotation.db_id:
+                if not self._db_actionAnnotations[i].is_new:
+                    self.db_deleted_actionAnnotations.append(self._db_actionAnnotations[i])
+                del self._db_actionAnnotations[i]
+                break
+        del self.db_actionAnnotations_id_index[actionAnnotation.db_id]
+        del self.db_actionAnnotations_action_id_index[(actionAnnotation.db_action_id,actionAnnotation.db_key)]
+        try:
+            del self.db_actionAnnotations_key_index[(actionAnnotation.db_key,actionAnnotation.db_value)]
+        except KeyError:
+            pass
+    def db_get_actionAnnotation(self, key):
+        for i in xrange(len(self._db_actionAnnotations)):
+            if self._db_actionAnnotations[i].db_id == key:
+                return self._db_actionAnnotations[i]
+        return None
+    def db_get_actionAnnotation_by_id(self, key):
+        return self.db_actionAnnotations_id_index[key]
+    def db_has_actionAnnotation_with_id(self, key):
+        return key in self.db_actionAnnotations_id_index
+    def db_get_actionAnnotation_by_action_id(self, key):
+        return self.db_actionAnnotations_action_id_index[key]
+    def db_has_actionAnnotation_with_action_id(self, key):
+        return key in self.db_actionAnnotations_action_id_index
+    def db_get_actionAnnotation_by_key(self, key):
+        return self.db_actionAnnotations_key_index[key]
+    def db_has_actionAnnotation_with_key(self, key):
+        return key in self.db_actionAnnotations_key_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBRegistry(object):
+
+    vtType = 'registry'
+
+    def __init__(self, id=None, entity_type=None, version=None, root_descriptor_id=None, name=None, last_modified=None, packages=None):
+        self._db_id = id
+        self._db_entity_type = entity_type
+        self._db_version = version
+        self._db_root_descriptor_id = root_descriptor_id
+        self._db_name = name
+        self._db_last_modified = last_modified
+        self.db_deleted_packages = []
+        self.db_packages_id_index = {}
+        self.db_packages_identifier_index = {}
+        if packages is None:
+            self._db_packages = []
+        else:
+            self._db_packages = packages
+            for v in self._db_packages:
+                self.db_packages_id_index[v.db_id] = v
+                self.db_packages_identifier_index[(v.db_identifier,v.db_version)] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBRegistry.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBRegistry(id=self._db_id,
+                        entity_type=self._db_entity_type,
+                        version=self._db_version,
+                        root_descriptor_id=self._db_root_descriptor_id,
+                        name=self._db_name,
+                        last_modified=self._db_last_modified)
+        if self._db_packages is None:
+            cp._db_packages = []
+        else:
+            cp._db_packages = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_packages]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_root_descriptor_id') and ('module_descriptor', self._db_root_descriptor_id) in id_remap:
+                cp._db_root_descriptor_id = id_remap[('module_descriptor', self._db_root_descriptor_id)]
+        
+        # recreate indices and set flags
+        cp.db_packages_id_index = dict((v.db_id, v) for v in cp._db_packages)
+        cp.db_packages_identifier_index = dict(((v.db_identifier,v.db_version), v) for v in cp._db_packages)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRegistry()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'entity_type' in class_dict:
+            res = class_dict['entity_type'](old_obj, trans_dict)
+            new_obj.db_entity_type = res
+        elif hasattr(old_obj, 'db_entity_type') and old_obj.db_entity_type is not None:
+            new_obj.db_entity_type = old_obj.db_entity_type
+        if 'version' in class_dict:
+            res = class_dict['version'](old_obj, trans_dict)
+            new_obj.db_version = res
+        elif hasattr(old_obj, 'db_version') and old_obj.db_version is not None:
+            new_obj.db_version = old_obj.db_version
+        if 'root_descriptor_id' in class_dict:
+            res = class_dict['root_descriptor_id'](old_obj, trans_dict)
+            new_obj.db_root_descriptor_id = res
+        elif hasattr(old_obj, 'db_root_descriptor_id') and old_obj.db_root_descriptor_id is not None:
+            new_obj.db_root_descriptor_id = old_obj.db_root_descriptor_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'last_modified' in class_dict:
+            res = class_dict['last_modified'](old_obj, trans_dict)
+            new_obj.db_last_modified = res
+        elif hasattr(old_obj, 'db_last_modified') and old_obj.db_last_modified is not None:
+            new_obj.db_last_modified = old_obj.db_last_modified
+        if 'packages' in class_dict:
+            res = class_dict['packages'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_package(obj)
+        elif hasattr(old_obj, 'db_packages') and old_obj.db_packages is not None:
+            for obj in old_obj.db_packages:
+                new_obj.db_add_package(DBPackage.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_packages') and hasattr(new_obj, 'db_deleted_packages'):
+            for obj in old_obj.db_deleted_packages:
+                n_obj = DBPackage.update_version(obj, trans_dict)
+                new_obj.db_deleted_packages.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_packages:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_package(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_packages)
+        if remove:
+            self.db_deleted_packages = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_packages:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_entity_type(self):
+        return self._db_entity_type
+    def __set_db_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+        self.is_dirty = True
+    db_entity_type = property(__get_db_entity_type, __set_db_entity_type)
+    def db_add_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_change_entity_type(self, entity_type):
+        self._db_entity_type = entity_type
+    def db_delete_entity_type(self, entity_type):
+        self._db_entity_type = None
+    
+    def __get_db_version(self):
+        return self._db_version
+    def __set_db_version(self, version):
+        self._db_version = version
+        self.is_dirty = True
+    db_version = property(__get_db_version, __set_db_version)
+    def db_add_version(self, version):
+        self._db_version = version
+    def db_change_version(self, version):
+        self._db_version = version
+    def db_delete_version(self, version):
+        self._db_version = None
+    
+    def __get_db_root_descriptor_id(self):
+        return self._db_root_descriptor_id
+    def __set_db_root_descriptor_id(self, root_descriptor_id):
+        self._db_root_descriptor_id = root_descriptor_id
+        self.is_dirty = True
+    db_root_descriptor_id = property(__get_db_root_descriptor_id, __set_db_root_descriptor_id)
+    def db_add_root_descriptor_id(self, root_descriptor_id):
+        self._db_root_descriptor_id = root_descriptor_id
+    def db_change_root_descriptor_id(self, root_descriptor_id):
+        self._db_root_descriptor_id = root_descriptor_id
+    def db_delete_root_descriptor_id(self, root_descriptor_id):
+        self._db_root_descriptor_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_last_modified(self):
+        return self._db_last_modified
+    def __set_db_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+        self.is_dirty = True
+    db_last_modified = property(__get_db_last_modified, __set_db_last_modified)
+    def db_add_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_change_last_modified(self, last_modified):
+        self._db_last_modified = last_modified
+    def db_delete_last_modified(self, last_modified):
+        self._db_last_modified = None
+    
+    def __get_db_packages(self):
+        return self._db_packages
+    def __set_db_packages(self, packages):
+        self._db_packages = packages
+        self.is_dirty = True
+    db_packages = property(__get_db_packages, __set_db_packages)
+    def db_get_packages(self):
+        return self._db_packages
+    def db_add_package(self, package):
+        self.is_dirty = True
+        self._db_packages.append(package)
+        self.db_packages_id_index[package.db_id] = package
+        self.db_packages_identifier_index[(package.db_identifier,package.db_version)] = package
+    def db_change_package(self, package):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_packages)):
+            if self._db_packages[i].db_id == package.db_id:
+                self._db_packages[i] = package
+                found = True
+                break
+        if not found:
+            self._db_packages.append(package)
+        self.db_packages_id_index[package.db_id] = package
+        self.db_packages_identifier_index[(package.db_identifier,package.db_version)] = package
+    def db_delete_package(self, package):
+        self.is_dirty = True
+        for i in xrange(len(self._db_packages)):
+            if self._db_packages[i].db_id == package.db_id:
+                if not self._db_packages[i].is_new:
+                    self.db_deleted_packages.append(self._db_packages[i])
+                del self._db_packages[i]
+                break
+        del self.db_packages_id_index[package.db_id]
+        del self.db_packages_identifier_index[(package.db_identifier,package.db_version)]
+    def db_get_package(self, key):
+        for i in xrange(len(self._db_packages)):
+            if self._db_packages[i].db_id == key:
+                return self._db_packages[i]
+        return None
+    def db_get_package_by_id(self, key):
+        return self.db_packages_id_index[key]
+    def db_has_package_with_id(self, key):
+        return key in self.db_packages_id_index
+    def db_get_package_by_identifier(self, key):
+        return self.db_packages_identifier_index[key]
+    def db_has_package_with_identifier(self, key):
+        return key in self.db_packages_identifier_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmAgent(object):
+
+    vtType = 'opm_agent'
+
+    def __init__(self, id=None, value=None, accounts=None):
+        self._db_id = id
+        self._db_value = value
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmAgent.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmAgent(id=self._db_id,
+                        value=self._db_value)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmAgent()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_accounts)
+        if remove:
+            self.db_deleted_accounts = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvEntity(object):
+
+    vtType = 'prov_entity'
+
+    def __init__(self, id=None, prov_type=None, prov_label=None, prov_value=None, vt_id=None, vt_type=None, vt_desc=None, vt_package=None, vt_version=None, vt_cache=None, vt_location_x=None, vt_location_y=None, is_part_of=None):
+        self._db_id = id
+        self._db_prov_type = prov_type
+        self._db_prov_label = prov_label
+        self._db_prov_value = prov_value
+        self._db_vt_id = vt_id
+        self._db_vt_type = vt_type
+        self._db_vt_desc = vt_desc
+        self._db_vt_package = vt_package
+        self._db_vt_version = vt_version
+        self._db_vt_cache = vt_cache
+        self._db_vt_location_x = vt_location_x
+        self._db_vt_location_y = vt_location_y
+        self.db_deleted_is_part_of = []
+        self._db_is_part_of = is_part_of
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvEntity.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvEntity(id=self._db_id,
+                          prov_type=self._db_prov_type,
+                          prov_label=self._db_prov_label,
+                          prov_value=self._db_prov_value,
+                          vt_id=self._db_vt_id,
+                          vt_type=self._db_vt_type,
+                          vt_desc=self._db_vt_desc,
+                          vt_package=self._db_vt_package,
+                          vt_version=self._db_vt_version,
+                          vt_cache=self._db_vt_cache,
+                          vt_location_x=self._db_vt_location_x,
+                          vt_location_y=self._db_vt_location_y)
+        if self._db_is_part_of is not None:
+            cp._db_is_part_of = self._db_is_part_of.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvEntity()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'prov_type' in class_dict:
+            res = class_dict['prov_type'](old_obj, trans_dict)
+            new_obj.db_prov_type = res
+        elif hasattr(old_obj, 'db_prov_type') and old_obj.db_prov_type is not None:
+            new_obj.db_prov_type = old_obj.db_prov_type
+        if 'prov_label' in class_dict:
+            res = class_dict['prov_label'](old_obj, trans_dict)
+            new_obj.db_prov_label = res
+        elif hasattr(old_obj, 'db_prov_label') and old_obj.db_prov_label is not None:
+            new_obj.db_prov_label = old_obj.db_prov_label
+        if 'prov_value' in class_dict:
+            res = class_dict['prov_value'](old_obj, trans_dict)
+            new_obj.db_prov_value = res
+        elif hasattr(old_obj, 'db_prov_value') and old_obj.db_prov_value is not None:
+            new_obj.db_prov_value = old_obj.db_prov_value
+        if 'vt_id' in class_dict:
+            res = class_dict['vt_id'](old_obj, trans_dict)
+            new_obj.db_vt_id = res
+        elif hasattr(old_obj, 'db_vt_id') and old_obj.db_vt_id is not None:
+            new_obj.db_vt_id = old_obj.db_vt_id
+        if 'vt_type' in class_dict:
+            res = class_dict['vt_type'](old_obj, trans_dict)
+            new_obj.db_vt_type = res
+        elif hasattr(old_obj, 'db_vt_type') and old_obj.db_vt_type is not None:
+            new_obj.db_vt_type = old_obj.db_vt_type
+        if 'vt_desc' in class_dict:
+            res = class_dict['vt_desc'](old_obj, trans_dict)
+            new_obj.db_vt_desc = res
+        elif hasattr(old_obj, 'db_vt_desc') and old_obj.db_vt_desc is not None:
+            new_obj.db_vt_desc = old_obj.db_vt_desc
+        if 'vt_package' in class_dict:
+            res = class_dict['vt_package'](old_obj, trans_dict)
+            new_obj.db_vt_package = res
+        elif hasattr(old_obj, 'db_vt_package') and old_obj.db_vt_package is not None:
+            new_obj.db_vt_package = old_obj.db_vt_package
+        if 'vt_version' in class_dict:
+            res = class_dict['vt_version'](old_obj, trans_dict)
+            new_obj.db_vt_version = res
+        elif hasattr(old_obj, 'db_vt_version') and old_obj.db_vt_version is not None:
+            new_obj.db_vt_version = old_obj.db_vt_version
+        if 'vt_cache' in class_dict:
+            res = class_dict['vt_cache'](old_obj, trans_dict)
+            new_obj.db_vt_cache = res
+        elif hasattr(old_obj, 'db_vt_cache') and old_obj.db_vt_cache is not None:
+            new_obj.db_vt_cache = old_obj.db_vt_cache
+        if 'vt_location_x' in class_dict:
+            res = class_dict['vt_location_x'](old_obj, trans_dict)
+            new_obj.db_vt_location_x = res
+        elif hasattr(old_obj, 'db_vt_location_x') and old_obj.db_vt_location_x is not None:
+            new_obj.db_vt_location_x = old_obj.db_vt_location_x
+        if 'vt_location_y' in class_dict:
+            res = class_dict['vt_location_y'](old_obj, trans_dict)
+            new_obj.db_vt_location_y = res
+        elif hasattr(old_obj, 'db_vt_location_y') and old_obj.db_vt_location_y is not None:
+            new_obj.db_vt_location_y = old_obj.db_vt_location_y
+        if 'is_part_of' in class_dict:
+            res = class_dict['is_part_of'](old_obj, trans_dict)
+            new_obj.db_is_part_of = res
+        elif hasattr(old_obj, 'db_is_part_of') and old_obj.db_is_part_of is not None:
+            obj = old_obj.db_is_part_of
+            new_obj.db_add_is_part_of(DBIsPartOf.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_is_part_of') and hasattr(new_obj, 'db_deleted_is_part_of'):
+            for obj in old_obj.db_deleted_is_part_of:
+                n_obj = DBIsPartOf.update_version(obj, trans_dict)
+                new_obj.db_deleted_is_part_of.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_is_part_of is not None:
+            children.extend(self._db_is_part_of.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_is_part_of = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_is_part_of)
+        if remove:
+            self.db_deleted_is_part_of = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_is_part_of is not None and self._db_is_part_of.has_changes():
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_prov_type(self):
+        return self._db_prov_type
+    def __set_db_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+        self.is_dirty = True
+    db_prov_type = property(__get_db_prov_type, __set_db_prov_type)
+    def db_add_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+    def db_change_prov_type(self, prov_type):
+        self._db_prov_type = prov_type
+    def db_delete_prov_type(self, prov_type):
+        self._db_prov_type = None
+    
+    def __get_db_prov_label(self):
+        return self._db_prov_label
+    def __set_db_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+        self.is_dirty = True
+    db_prov_label = property(__get_db_prov_label, __set_db_prov_label)
+    def db_add_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+    def db_change_prov_label(self, prov_label):
+        self._db_prov_label = prov_label
+    def db_delete_prov_label(self, prov_label):
+        self._db_prov_label = None
+    
+    def __get_db_prov_value(self):
+        return self._db_prov_value
+    def __set_db_prov_value(self, prov_value):
+        self._db_prov_value = prov_value
+        self.is_dirty = True
+    db_prov_value = property(__get_db_prov_value, __set_db_prov_value)
+    def db_add_prov_value(self, prov_value):
+        self._db_prov_value = prov_value
+    def db_change_prov_value(self, prov_value):
+        self._db_prov_value = prov_value
+    def db_delete_prov_value(self, prov_value):
+        self._db_prov_value = None
+    
+    def __get_db_vt_id(self):
+        return self._db_vt_id
+    def __set_db_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+        self.is_dirty = True
+    db_vt_id = property(__get_db_vt_id, __set_db_vt_id)
+    def db_add_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_change_vt_id(self, vt_id):
+        self._db_vt_id = vt_id
+    def db_delete_vt_id(self, vt_id):
+        self._db_vt_id = None
+    
+    def __get_db_vt_type(self):
+        return self._db_vt_type
+    def __set_db_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+        self.is_dirty = True
+    db_vt_type = property(__get_db_vt_type, __set_db_vt_type)
+    def db_add_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+    def db_change_vt_type(self, vt_type):
+        self._db_vt_type = vt_type
+    def db_delete_vt_type(self, vt_type):
+        self._db_vt_type = None
+    
+    def __get_db_vt_desc(self):
+        return self._db_vt_desc
+    def __set_db_vt_desc(self, vt_desc):
+        self._db_vt_desc = vt_desc
+        self.is_dirty = True
+    db_vt_desc = property(__get_db_vt_desc, __set_db_vt_desc)
+    def db_add_vt_desc(self, vt_desc):
+        self._db_vt_desc = vt_desc
+    def db_change_vt_desc(self, vt_desc):
+        self._db_vt_desc = vt_desc
+    def db_delete_vt_desc(self, vt_desc):
+        self._db_vt_desc = None
+    
+    def __get_db_vt_package(self):
+        return self._db_vt_package
+    def __set_db_vt_package(self, vt_package):
+        self._db_vt_package = vt_package
+        self.is_dirty = True
+    db_vt_package = property(__get_db_vt_package, __set_db_vt_package)
+    def db_add_vt_package(self, vt_package):
+        self._db_vt_package = vt_package
+    def db_change_vt_package(self, vt_package):
+        self._db_vt_package = vt_package
+    def db_delete_vt_package(self, vt_package):
+        self._db_vt_package = None
+    
+    def __get_db_vt_version(self):
+        return self._db_vt_version
+    def __set_db_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+        self.is_dirty = True
+    db_vt_version = property(__get_db_vt_version, __set_db_vt_version)
+    def db_add_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+    def db_change_vt_version(self, vt_version):
+        self._db_vt_version = vt_version
+    def db_delete_vt_version(self, vt_version):
+        self._db_vt_version = None
+    
+    def __get_db_vt_cache(self):
+        return self._db_vt_cache
+    def __set_db_vt_cache(self, vt_cache):
+        self._db_vt_cache = vt_cache
+        self.is_dirty = True
+    db_vt_cache = property(__get_db_vt_cache, __set_db_vt_cache)
+    def db_add_vt_cache(self, vt_cache):
+        self._db_vt_cache = vt_cache
+    def db_change_vt_cache(self, vt_cache):
+        self._db_vt_cache = vt_cache
+    def db_delete_vt_cache(self, vt_cache):
+        self._db_vt_cache = None
+    
+    def __get_db_vt_location_x(self):
+        return self._db_vt_location_x
+    def __set_db_vt_location_x(self, vt_location_x):
+        self._db_vt_location_x = vt_location_x
+        self.is_dirty = True
+    db_vt_location_x = property(__get_db_vt_location_x, __set_db_vt_location_x)
+    def db_add_vt_location_x(self, vt_location_x):
+        self._db_vt_location_x = vt_location_x
+    def db_change_vt_location_x(self, vt_location_x):
+        self._db_vt_location_x = vt_location_x
+    def db_delete_vt_location_x(self, vt_location_x):
+        self._db_vt_location_x = None
+    
+    def __get_db_vt_location_y(self):
+        return self._db_vt_location_y
+    def __set_db_vt_location_y(self, vt_location_y):
+        self._db_vt_location_y = vt_location_y
+        self.is_dirty = True
+    db_vt_location_y = property(__get_db_vt_location_y, __set_db_vt_location_y)
+    def db_add_vt_location_y(self, vt_location_y):
+        self._db_vt_location_y = vt_location_y
+    def db_change_vt_location_y(self, vt_location_y):
+        self._db_vt_location_y = vt_location_y
+    def db_delete_vt_location_y(self, vt_location_y):
+        self._db_vt_location_y = None
+    
+    def __get_db_is_part_of(self):
+        return self._db_is_part_of
+    def __set_db_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+        self.is_dirty = True
+    db_is_part_of = property(__get_db_is_part_of, __set_db_is_part_of)
+    def db_add_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+    def db_change_is_part_of(self, is_part_of):
+        self._db_is_part_of = is_part_of
+    def db_delete_is_part_of(self, is_part_of):
+        if not self.is_new:
+            self.db_deleted_is_part_of.append(self._db_is_part_of)
+        self._db_is_part_of = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBAnnotation(object):
+
+    vtType = 'annotation'
+
+    def __init__(self, id=None, key=None, value=None):
+        self._db_id = id
+        self._db_key = key
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBAnnotation.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBAnnotation(id=self._db_id,
+                          key=self._db_key,
+                          value=self._db_value)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBAnnotation()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'key' in class_dict:
+            res = class_dict['key'](old_obj, trans_dict)
+            new_obj.db_key = res
+        elif hasattr(old_obj, 'db_key') and old_obj.db_key is not None:
+            new_obj.db_key = old_obj.db_key
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_key(self):
+        return self._db_key
+    def __set_db_key(self, key):
+        self._db_key = key
+        self.is_dirty = True
+    db_key = property(__get_db_key, __set_db_key)
+    def db_add_key(self, key):
+        self._db_key = key
+    def db_change_key(self, key):
+        self._db_key = key
+    def db_delete_key(self, key):
+        self._db_key = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmTime(object):
+
+    vtType = 'opm_time'
+
+    def __init__(self, no_later_than=None, no_earlier_than=None, clock_id=None):
+        self._db_no_later_than = no_later_than
+        self._db_no_earlier_than = no_earlier_than
+        self._db_clock_id = clock_id
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmTime.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmTime(no_later_than=self._db_no_later_than,
+                       no_earlier_than=self._db_no_earlier_than,
+                       clock_id=self._db_clock_id)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmTime()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'no_later_than' in class_dict:
+            res = class_dict['no_later_than'](old_obj, trans_dict)
+            new_obj.db_no_later_than = res
+        elif hasattr(old_obj, 'db_no_later_than') and old_obj.db_no_later_than is not None:
+            new_obj.db_no_later_than = old_obj.db_no_later_than
+        if 'no_earlier_than' in class_dict:
+            res = class_dict['no_earlier_than'](old_obj, trans_dict)
+            new_obj.db_no_earlier_than = res
+        elif hasattr(old_obj, 'db_no_earlier_than') and old_obj.db_no_earlier_than is not None:
+            new_obj.db_no_earlier_than = old_obj.db_no_earlier_than
+        if 'clock_id' in class_dict:
+            res = class_dict['clock_id'](old_obj, trans_dict)
+            new_obj.db_clock_id = res
+        elif hasattr(old_obj, 'db_clock_id') and old_obj.db_clock_id is not None:
+            new_obj.db_clock_id = old_obj.db_clock_id
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_no_later_than(self):
+        return self._db_no_later_than
+    def __set_db_no_later_than(self, no_later_than):
+        self._db_no_later_than = no_later_than
+        self.is_dirty = True
+    db_no_later_than = property(__get_db_no_later_than, __set_db_no_later_than)
+    def db_add_no_later_than(self, no_later_than):
+        self._db_no_later_than = no_later_than
+    def db_change_no_later_than(self, no_later_than):
+        self._db_no_later_than = no_later_than
+    def db_delete_no_later_than(self, no_later_than):
+        self._db_no_later_than = None
+    
+    def __get_db_no_earlier_than(self):
+        return self._db_no_earlier_than
+    def __set_db_no_earlier_than(self, no_earlier_than):
+        self._db_no_earlier_than = no_earlier_than
+        self.is_dirty = True
+    db_no_earlier_than = property(__get_db_no_earlier_than, __set_db_no_earlier_than)
+    def db_add_no_earlier_than(self, no_earlier_than):
+        self._db_no_earlier_than = no_earlier_than
+    def db_change_no_earlier_than(self, no_earlier_than):
+        self._db_no_earlier_than = no_earlier_than
+    def db_delete_no_earlier_than(self, no_earlier_than):
+        self._db_no_earlier_than = None
+    
+    def __get_db_clock_id(self):
+        return self._db_clock_id
+    def __set_db_clock_id(self, clock_id):
+        self._db_clock_id = clock_id
+        self.is_dirty = True
+    db_clock_id = property(__get_db_clock_id, __set_db_clock_id)
+    def db_add_clock_id(self, clock_id):
+        self._db_clock_id = clock_id
+    def db_change_clock_id(self, clock_id):
+        self._db_clock_id = clock_id
+    def db_delete_clock_id(self, clock_id):
+        self._db_clock_id = None
+    
+
+
+class DBParameterExploration(object):
+
+    vtType = 'parameter_exploration'
+
+    def __init__(self, id=None, action_id=None, name=None, date=None, user=None, dims=None, layout=None, functions=None):
+        self._db_id = id
+        self._db_action_id = action_id
+        self._db_name = name
+        self._db_date = date
+        self._db_user = user
+        self._db_dims = dims
+        self._db_layout = layout
+        self.db_deleted_functions = []
+        self.db_functions_id_index = {}
+        if functions is None:
+            self._db_functions = []
+        else:
+            self._db_functions = functions
+            for v in self._db_functions:
+                self.db_functions_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBParameterExploration.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBParameterExploration(id=self._db_id,
+                                    action_id=self._db_action_id,
+                                    name=self._db_name,
+                                    date=self._db_date,
+                                    user=self._db_user,
+                                    dims=self._db_dims,
+                                    layout=self._db_layout)
+        if self._db_functions is None:
+            cp._db_functions = []
+        else:
+            cp._db_functions = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_functions]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_action_id') and ('action', self._db_action_id) in id_remap:
+                cp._db_action_id = id_remap[('action', self._db_action_id)]
+        
+        # recreate indices and set flags
+        cp.db_functions_id_index = dict((v.db_id, v) for v in cp._db_functions)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBParameterExploration()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'action_id' in class_dict:
+            res = class_dict['action_id'](old_obj, trans_dict)
+            new_obj.db_action_id = res
+        elif hasattr(old_obj, 'db_action_id') and old_obj.db_action_id is not None:
+            new_obj.db_action_id = old_obj.db_action_id
+        if 'name' in class_dict:
+            res = class_dict['name'](old_obj, trans_dict)
+            new_obj.db_name = res
+        elif hasattr(old_obj, 'db_name') and old_obj.db_name is not None:
+            new_obj.db_name = old_obj.db_name
+        if 'date' in class_dict:
+            res = class_dict['date'](old_obj, trans_dict)
+            new_obj.db_date = res
+        elif hasattr(old_obj, 'db_date') and old_obj.db_date is not None:
+            new_obj.db_date = old_obj.db_date
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        if 'dims' in class_dict:
+            res = class_dict['dims'](old_obj, trans_dict)
+            new_obj.db_dims = res
+        elif hasattr(old_obj, 'db_dims') and old_obj.db_dims is not None:
+            new_obj.db_dims = old_obj.db_dims
+        if 'layout' in class_dict:
+            res = class_dict['layout'](old_obj, trans_dict)
+            new_obj.db_layout = res
+        elif hasattr(old_obj, 'db_layout') and old_obj.db_layout is not None:
+            new_obj.db_layout = old_obj.db_layout
+        if 'functions' in class_dict:
+            res = class_dict['functions'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_function(obj)
+        elif hasattr(old_obj, 'db_functions') and old_obj.db_functions is not None:
+            for obj in old_obj.db_functions:
+                new_obj.db_add_function(DBPEFunction.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_functions') and hasattr(new_obj, 'db_deleted_functions'):
+            for obj in old_obj.db_deleted_functions:
+                n_obj = DBPEFunction.update_version(obj, trans_dict)
+                new_obj.db_deleted_functions.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_functions:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_function(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_functions)
+        if remove:
+            self.db_deleted_functions = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_functions:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_action_id(self):
+        return self._db_action_id
+    def __set_db_action_id(self, action_id):
+        self._db_action_id = action_id
+        self.is_dirty = True
+    db_action_id = property(__get_db_action_id, __set_db_action_id)
+    def db_add_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_change_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_delete_action_id(self, action_id):
+        self._db_action_id = None
+    
+    def __get_db_name(self):
+        return self._db_name
+    def __set_db_name(self, name):
+        self._db_name = name
+        self.is_dirty = True
+    db_name = property(__get_db_name, __set_db_name)
+    def db_add_name(self, name):
+        self._db_name = name
+    def db_change_name(self, name):
+        self._db_name = name
+    def db_delete_name(self, name):
+        self._db_name = None
+    
+    def __get_db_date(self):
+        return self._db_date
+    def __set_db_date(self, date):
+        self._db_date = date
+        self.is_dirty = True
+    db_date = property(__get_db_date, __set_db_date)
+    def db_add_date(self, date):
+        self._db_date = date
+    def db_change_date(self, date):
+        self._db_date = date
+    def db_delete_date(self, date):
+        self._db_date = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def __get_db_dims(self):
+        return self._db_dims
+    def __set_db_dims(self, dims):
+        self._db_dims = dims
+        self.is_dirty = True
+    db_dims = property(__get_db_dims, __set_db_dims)
+    def db_add_dims(self, dims):
+        self._db_dims = dims
+    def db_change_dims(self, dims):
+        self._db_dims = dims
+    def db_delete_dims(self, dims):
+        self._db_dims = None
+    
+    def __get_db_layout(self):
+        return self._db_layout
+    def __set_db_layout(self, layout):
+        self._db_layout = layout
+        self.is_dirty = True
+    db_layout = property(__get_db_layout, __set_db_layout)
+    def db_add_layout(self, layout):
+        self._db_layout = layout
+    def db_change_layout(self, layout):
+        self._db_layout = layout
+    def db_delete_layout(self, layout):
+        self._db_layout = None
+    
+    def __get_db_functions(self):
+        return self._db_functions
+    def __set_db_functions(self, functions):
+        self._db_functions = functions
+        self.is_dirty = True
+    db_functions = property(__get_db_functions, __set_db_functions)
+    def db_get_functions(self):
+        return self._db_functions
+    def db_add_function(self, function):
+        self.is_dirty = True
+        self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_change_function(self, function):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                self._db_functions[i] = function
+                found = True
+                break
+        if not found:
+            self._db_functions.append(function)
+        self.db_functions_id_index[function.db_id] = function
+    def db_delete_function(self, function):
+        self.is_dirty = True
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == function.db_id:
+                if not self._db_functions[i].is_new:
+                    self.db_deleted_functions.append(self._db_functions[i])
+                del self._db_functions[i]
+                break
+        del self.db_functions_id_index[function.db_id]
+    def db_get_function(self, key):
+        for i in xrange(len(self._db_functions)):
+            if self._db_functions[i].db_id == key:
+                return self._db_functions[i]
+        return None
+    def db_get_function_by_id(self, key):
+        return self.db_functions_id_index[key]
+    def db_has_function_with_id(self, key):
+        return key in self.db_functions_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBMashupActionAnnotation(object):
+
+    vtType = 'mashup_actionAnnotation'
+
+    def __init__(self, id=None, key=None, value=None, action_id=None, date=None, user=None):
+        self._db_id = id
+        self._db_key = key
+        self._db_value = value
+        self._db_action_id = action_id
+        self._db_date = date
+        self._db_user = user
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBMashupActionAnnotation.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBMashupActionAnnotation(id=self._db_id,
+                                      key=self._db_key,
+                                      value=self._db_value,
+                                      action_id=self._db_action_id,
+                                      date=self._db_date,
+                                      user=self._db_user)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_action_id') and ('mashup_action', self._db_action_id) in id_remap:
+                cp._db_action_id = id_remap[('mashup_action', self._db_action_id)]
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBMashupActionAnnotation()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'key' in class_dict:
+            res = class_dict['key'](old_obj, trans_dict)
+            new_obj.db_key = res
+        elif hasattr(old_obj, 'db_key') and old_obj.db_key is not None:
+            new_obj.db_key = old_obj.db_key
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            new_obj.db_value = old_obj.db_value
+        if 'action_id' in class_dict:
+            res = class_dict['action_id'](old_obj, trans_dict)
+            new_obj.db_action_id = res
+        elif hasattr(old_obj, 'db_action_id') and old_obj.db_action_id is not None:
+            new_obj.db_action_id = old_obj.db_action_id
+        if 'date' in class_dict:
+            res = class_dict['date'](old_obj, trans_dict)
+            new_obj.db_date = res
+        elif hasattr(old_obj, 'db_date') and old_obj.db_date is not None:
+            new_obj.db_date = old_obj.db_date
+        if 'user' in class_dict:
+            res = class_dict['user'](old_obj, trans_dict)
+            new_obj.db_user = res
+        elif hasattr(old_obj, 'db_user') and old_obj.db_user is not None:
+            new_obj.db_user = old_obj.db_user
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        return [(self, parent[0], parent[1])]
+    def db_deleted_children(self, remove=False):
+        children = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_key(self):
+        return self._db_key
+    def __set_db_key(self, key):
+        self._db_key = key
+        self.is_dirty = True
+    db_key = property(__get_db_key, __set_db_key)
+    def db_add_key(self, key):
+        self._db_key = key
+    def db_change_key(self, key):
+        self._db_key = key
+    def db_delete_key(self, key):
+        self._db_key = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        self._db_value = None
+    
+    def __get_db_action_id(self):
+        return self._db_action_id
+    def __set_db_action_id(self, action_id):
+        self._db_action_id = action_id
+        self.is_dirty = True
+    db_action_id = property(__get_db_action_id, __set_db_action_id)
+    def db_add_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_change_action_id(self, action_id):
+        self._db_action_id = action_id
+    def db_delete_action_id(self, action_id):
+        self._db_action_id = None
+    
+    def __get_db_date(self):
+        return self._db_date
+    def __set_db_date(self, date):
+        self._db_date = date
+        self.is_dirty = True
+    db_date = property(__get_db_date, __set_db_date)
+    def db_add_date(self, date):
+        self._db_date = date
+    def db_change_date(self, date):
+        self._db_date = date
+    def db_delete_date(self, date):
+        self._db_date = None
+    
+    def __get_db_user(self):
+        return self._db_user
+    def __set_db_user(self, user):
+        self._db_user = user
+        self.is_dirty = True
+    db_user = property(__get_db_user, __set_db_user)
+    def db_add_user(self, user):
+        self._db_user = user
+    def db_change_user(self, user):
+        self._db_user = user
+    def db_delete_user(self, user):
+        self._db_user = None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBOpmProcess(object):
+
+    vtType = 'opm_process'
+
+    def __init__(self, id=None, value=None, accounts=None):
+        self._db_id = id
+        self.db_deleted_value = []
+        self._db_value = value
+        self.db_deleted_accounts = []
+        if accounts is None:
+            self._db_accounts = []
+        else:
+            self._db_accounts = accounts
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmProcess.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmProcess(id=self._db_id)
+        if self._db_value is not None:
+            cp._db_value = self._db_value.do_copy(new_ids, id_scope, id_remap)
+        if self._db_accounts is None:
+            cp._db_accounts = []
+        else:
+            cp._db_accounts = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_accounts]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmProcess()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            obj = old_obj.db_value
+            new_obj.db_add_value(DBOpmProcessValue.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_value') and hasattr(new_obj, 'db_deleted_value'):
+            for obj in old_obj.db_deleted_value:
+                n_obj = DBOpmProcessValue.update_version(obj, trans_dict)
+                new_obj.db_deleted_value.append(n_obj)
+        if 'accounts' in class_dict:
+            res = class_dict['accounts'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_account(obj)
+        elif hasattr(old_obj, 'db_accounts') and old_obj.db_accounts is not None:
+            for obj in old_obj.db_accounts:
+                new_obj.db_add_account(DBOpmAccountId.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_accounts') and hasattr(new_obj, 'db_deleted_accounts'):
+            for obj in old_obj.db_deleted_accounts:
+                n_obj = DBOpmAccountId.update_version(obj, trans_dict)
+                new_obj.db_deleted_accounts.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_value is not None:
+            children.extend(self._db_value.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_value = None
+        to_del = []
+        for child in self.db_accounts:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_account(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_value)
+        children.extend(self.db_deleted_accounts)
+        if remove:
+            self.db_deleted_value = []
+            self.db_deleted_accounts = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_value is not None and self._db_value.has_changes():
+            return True
+        for child in self._db_accounts:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        if not self.is_new:
+            self.db_deleted_value.append(self._db_value)
+        self._db_value = None
+    
+    def __get_db_accounts(self):
+        return self._db_accounts
+    def __set_db_accounts(self, accounts):
+        self._db_accounts = accounts
+        self.is_dirty = True
+    db_accounts = property(__get_db_accounts, __set_db_accounts)
+    def db_get_accounts(self):
+        return self._db_accounts
+    def db_add_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_change_account(self, account):
+        self.is_dirty = True
+        self._db_accounts.append(account)
+    def db_delete_account(self, account):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_account(self, key):
+        return None
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBDisabledPackages(object):
+
+    vtType = 'disabled_packages'
+
+    def __init__(self, packages=None):
+        self.db_deleted_packages = []
+        self.db_packages_name_index = {}
+        if packages is None:
+            self._db_packages = []
+        else:
+            self._db_packages = packages
+            for v in self._db_packages:
+                self.db_packages_name_index[v.db_name] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBDisabledPackages.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBDisabledPackages()
+        if self._db_packages is None:
+            cp._db_packages = []
+        else:
+            cp._db_packages = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_packages]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        cp.db_packages_name_index = dict((v.db_name, v) for v in cp._db_packages)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBDisabledPackages()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'packages' in class_dict:
+            res = class_dict['packages'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_package(obj)
+        elif hasattr(old_obj, 'db_packages') and old_obj.db_packages is not None:
+            for obj in old_obj.db_packages:
+                new_obj.db_add_package(DBStartupPackage.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_packages') and hasattr(new_obj, 'db_deleted_packages'):
+            for obj in old_obj.db_deleted_packages:
+                n_obj = DBStartupPackage.update_version(obj, trans_dict)
+                new_obj.db_deleted_packages.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_packages:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_package(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_packages)
+        if remove:
+            self.db_deleted_packages = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_packages:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_packages(self):
+        return self._db_packages
+    def __set_db_packages(self, packages):
+        self._db_packages = packages
+        self.is_dirty = True
+    db_packages = property(__get_db_packages, __set_db_packages)
+    def db_get_packages(self):
+        return self._db_packages
+    def db_add_package(self, package):
+        self.is_dirty = True
+        self._db_packages.append(package)
+        self.db_packages_name_index[package.db_name] = package
+    def db_change_package(self, package):
+        self.is_dirty = True
+        self._db_packages.append(package)
+        self.db_packages_name_index[package.db_name] = package
+    def db_delete_package(self, package):
+        self.is_dirty = True
+        raise Exception('Cannot delete a non-keyed object')
+    def db_get_package(self, key):
+        return None
+    def db_get_package_by_name(self, key):
+        return self.db_packages_name_index[key]
+    def db_has_package_with_name(self, key):
+        return key in self.db_packages_name_index
+    
+
+
+class DBModuleExec(object):
+
+    vtType = 'module_exec'
+
+    def __init__(self, id=None, ts_start=None, ts_end=None, cached=None, module_id=None, module_name=None, completed=None, error=None, machine_id=None, annotations=None, loop_execs=None):
+        self._db_id = id
+        self._db_ts_start = ts_start
+        self._db_ts_end = ts_end
+        self._db_cached = cached
+        self._db_module_id = module_id
+        self._db_module_name = module_name
+        self._db_completed = completed
+        self._db_error = error
+        self._db_machine_id = machine_id
+        self.db_deleted_annotations = []
+        self.db_annotations_id_index = {}
+        if annotations is None:
+            self._db_annotations = []
+        else:
+            self._db_annotations = annotations
+            for v in self._db_annotations:
+                self.db_annotations_id_index[v.db_id] = v
+        self.db_deleted_loop_execs = []
+        self.db_loop_execs_id_index = {}
+        if loop_execs is None:
+            self._db_loop_execs = []
+        else:
+            self._db_loop_execs = loop_execs
+            for v in self._db_loop_execs:
+                self.db_loop_execs_id_index[v.db_id] = v
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBModuleExec.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBModuleExec(id=self._db_id,
+                          ts_start=self._db_ts_start,
+                          ts_end=self._db_ts_end,
+                          cached=self._db_cached,
+                          module_id=self._db_module_id,
+                          module_name=self._db_module_name,
+                          completed=self._db_completed,
+                          error=self._db_error,
+                          machine_id=self._db_machine_id)
+        if self._db_annotations is None:
+            cp._db_annotations = []
+        else:
+            cp._db_annotations = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_annotations]
+        if self._db_loop_execs is None:
+            cp._db_loop_execs = []
+        else:
+            cp._db_loop_execs = [v.do_copy(new_ids, id_scope, id_remap) for v in self._db_loop_execs]
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+            if hasattr(self, 'db_module_id') and ('module', self._db_module_id) in id_remap:
+                cp._db_module_id = id_remap[('module', self._db_module_id)]
+            if hasattr(self, 'db_machine_id') and ('machine', self._db_machine_id) in id_remap:
+                cp._db_machine_id = id_remap[('machine', self._db_machine_id)]
+        
+        # recreate indices and set flags
+        cp.db_annotations_id_index = dict((v.db_id, v) for v in cp._db_annotations)
+        cp.db_loop_execs_id_index = dict((v.db_id, v) for v in cp._db_loop_execs)
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBModuleExec()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'id' in class_dict:
+            res = class_dict['id'](old_obj, trans_dict)
+            new_obj.db_id = res
+        elif hasattr(old_obj, 'db_id') and old_obj.db_id is not None:
+            new_obj.db_id = old_obj.db_id
+        if 'ts_start' in class_dict:
+            res = class_dict['ts_start'](old_obj, trans_dict)
+            new_obj.db_ts_start = res
+        elif hasattr(old_obj, 'db_ts_start') and old_obj.db_ts_start is not None:
+            new_obj.db_ts_start = old_obj.db_ts_start
+        if 'ts_end' in class_dict:
+            res = class_dict['ts_end'](old_obj, trans_dict)
+            new_obj.db_ts_end = res
+        elif hasattr(old_obj, 'db_ts_end') and old_obj.db_ts_end is not None:
+            new_obj.db_ts_end = old_obj.db_ts_end
+        if 'cached' in class_dict:
+            res = class_dict['cached'](old_obj, trans_dict)
+            new_obj.db_cached = res
+        elif hasattr(old_obj, 'db_cached') and old_obj.db_cached is not None:
+            new_obj.db_cached = old_obj.db_cached
+        if 'module_id' in class_dict:
+            res = class_dict['module_id'](old_obj, trans_dict)
+            new_obj.db_module_id = res
+        elif hasattr(old_obj, 'db_module_id') and old_obj.db_module_id is not None:
+            new_obj.db_module_id = old_obj.db_module_id
+        if 'module_name' in class_dict:
+            res = class_dict['module_name'](old_obj, trans_dict)
+            new_obj.db_module_name = res
+        elif hasattr(old_obj, 'db_module_name') and old_obj.db_module_name is not None:
+            new_obj.db_module_name = old_obj.db_module_name
+        if 'completed' in class_dict:
+            res = class_dict['completed'](old_obj, trans_dict)
+            new_obj.db_completed = res
+        elif hasattr(old_obj, 'db_completed') and old_obj.db_completed is not None:
+            new_obj.db_completed = old_obj.db_completed
+        if 'error' in class_dict:
+            res = class_dict['error'](old_obj, trans_dict)
+            new_obj.db_error = res
+        elif hasattr(old_obj, 'db_error') and old_obj.db_error is not None:
+            new_obj.db_error = old_obj.db_error
+        if 'machine_id' in class_dict:
+            res = class_dict['machine_id'](old_obj, trans_dict)
+            new_obj.db_machine_id = res
+        elif hasattr(old_obj, 'db_machine_id') and old_obj.db_machine_id is not None:
+            new_obj.db_machine_id = old_obj.db_machine_id
+        if 'annotations' in class_dict:
+            res = class_dict['annotations'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_annotation(obj)
+        elif hasattr(old_obj, 'db_annotations') and old_obj.db_annotations is not None:
+            for obj in old_obj.db_annotations:
+                new_obj.db_add_annotation(DBAnnotation.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_annotations') and hasattr(new_obj, 'db_deleted_annotations'):
+            for obj in old_obj.db_deleted_annotations:
+                n_obj = DBAnnotation.update_version(obj, trans_dict)
+                new_obj.db_deleted_annotations.append(n_obj)
+        if 'loop_execs' in class_dict:
+            res = class_dict['loop_execs'](old_obj, trans_dict)
+            for obj in res:
+                new_obj.db_add_loop_exec(obj)
+        elif hasattr(old_obj, 'db_loop_execs') and old_obj.db_loop_execs is not None:
+            for obj in old_obj.db_loop_execs:
+                new_obj.db_add_loop_exec(DBLoopExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_loop_execs') and hasattr(new_obj, 'db_deleted_loop_execs'):
+            for obj in old_obj.db_deleted_loop_execs:
+                n_obj = DBLoopExec.update_version(obj, trans_dict)
+                new_obj.db_deleted_loop_execs.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        to_del = []
+        for child in self.db_annotations:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_annotation(child)
+        to_del = []
+        for child in self.db_loop_execs:
+            children.extend(child.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                to_del.append(child)
+        for child in to_del:
+            self.db_delete_loop_exec(child)
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_annotations)
+        children.extend(self.db_deleted_loop_execs)
+        if remove:
+            self.db_deleted_annotations = []
+            self.db_deleted_loop_execs = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        for child in self._db_annotations:
+            if child.has_changes():
+                return True
+        for child in self._db_loop_execs:
+            if child.has_changes():
+                return True
+        return False
+    def __get_db_id(self):
+        return self._db_id
+    def __set_db_id(self, id):
+        self._db_id = id
+        self.is_dirty = True
+    db_id = property(__get_db_id, __set_db_id)
+    def db_add_id(self, id):
+        self._db_id = id
+    def db_change_id(self, id):
+        self._db_id = id
+    def db_delete_id(self, id):
+        self._db_id = None
+    
+    def __get_db_ts_start(self):
+        return self._db_ts_start
+    def __set_db_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+        self.is_dirty = True
+    db_ts_start = property(__get_db_ts_start, __set_db_ts_start)
+    def db_add_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_change_ts_start(self, ts_start):
+        self._db_ts_start = ts_start
+    def db_delete_ts_start(self, ts_start):
+        self._db_ts_start = None
+    
+    def __get_db_ts_end(self):
+        return self._db_ts_end
+    def __set_db_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+        self.is_dirty = True
+    db_ts_end = property(__get_db_ts_end, __set_db_ts_end)
+    def db_add_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_change_ts_end(self, ts_end):
+        self._db_ts_end = ts_end
+    def db_delete_ts_end(self, ts_end):
+        self._db_ts_end = None
+    
+    def __get_db_cached(self):
+        return self._db_cached
+    def __set_db_cached(self, cached):
+        self._db_cached = cached
+        self.is_dirty = True
+    db_cached = property(__get_db_cached, __set_db_cached)
+    def db_add_cached(self, cached):
+        self._db_cached = cached
+    def db_change_cached(self, cached):
+        self._db_cached = cached
+    def db_delete_cached(self, cached):
+        self._db_cached = None
+    
+    def __get_db_module_id(self):
+        return self._db_module_id
+    def __set_db_module_id(self, module_id):
+        self._db_module_id = module_id
+        self.is_dirty = True
+    db_module_id = property(__get_db_module_id, __set_db_module_id)
+    def db_add_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_change_module_id(self, module_id):
+        self._db_module_id = module_id
+    def db_delete_module_id(self, module_id):
+        self._db_module_id = None
+    
+    def __get_db_module_name(self):
+        return self._db_module_name
+    def __set_db_module_name(self, module_name):
+        self._db_module_name = module_name
+        self.is_dirty = True
+    db_module_name = property(__get_db_module_name, __set_db_module_name)
+    def db_add_module_name(self, module_name):
+        self._db_module_name = module_name
+    def db_change_module_name(self, module_name):
+        self._db_module_name = module_name
+    def db_delete_module_name(self, module_name):
+        self._db_module_name = None
+    
+    def __get_db_completed(self):
+        return self._db_completed
+    def __set_db_completed(self, completed):
+        self._db_completed = completed
+        self.is_dirty = True
+    db_completed = property(__get_db_completed, __set_db_completed)
+    def db_add_completed(self, completed):
+        self._db_completed = completed
+    def db_change_completed(self, completed):
+        self._db_completed = completed
+    def db_delete_completed(self, completed):
+        self._db_completed = None
+    
+    def __get_db_error(self):
+        return self._db_error
+    def __set_db_error(self, error):
+        self._db_error = error
+        self.is_dirty = True
+    db_error = property(__get_db_error, __set_db_error)
+    def db_add_error(self, error):
+        self._db_error = error
+    def db_change_error(self, error):
+        self._db_error = error
+    def db_delete_error(self, error):
+        self._db_error = None
+    
+    def __get_db_machine_id(self):
+        return self._db_machine_id
+    def __set_db_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+        self.is_dirty = True
+    db_machine_id = property(__get_db_machine_id, __set_db_machine_id)
+    def db_add_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+    def db_change_machine_id(self, machine_id):
+        self._db_machine_id = machine_id
+    def db_delete_machine_id(self, machine_id):
+        self._db_machine_id = None
+    
+    def __get_db_annotations(self):
+        return self._db_annotations
+    def __set_db_annotations(self, annotations):
+        self._db_annotations = annotations
+        self.is_dirty = True
+    db_annotations = property(__get_db_annotations, __set_db_annotations)
+    def db_get_annotations(self):
+        return self._db_annotations
+    def db_add_annotation(self, annotation):
+        self.is_dirty = True
+        self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_change_annotation(self, annotation):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                self._db_annotations[i] = annotation
+                found = True
+                break
+        if not found:
+            self._db_annotations.append(annotation)
+        self.db_annotations_id_index[annotation.db_id] = annotation
+    def db_delete_annotation(self, annotation):
+        self.is_dirty = True
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == annotation.db_id:
+                if not self._db_annotations[i].is_new:
+                    self.db_deleted_annotations.append(self._db_annotations[i])
+                del self._db_annotations[i]
+                break
+        del self.db_annotations_id_index[annotation.db_id]
+    def db_get_annotation(self, key):
+        for i in xrange(len(self._db_annotations)):
+            if self._db_annotations[i].db_id == key:
+                return self._db_annotations[i]
+        return None
+    def db_get_annotation_by_id(self, key):
+        return self.db_annotations_id_index[key]
+    def db_has_annotation_with_id(self, key):
+        return key in self.db_annotations_id_index
+    
+    def __get_db_loop_execs(self):
+        return self._db_loop_execs
+    def __set_db_loop_execs(self, loop_execs):
+        self._db_loop_execs = loop_execs
+        self.is_dirty = True
+    db_loop_execs = property(__get_db_loop_execs, __set_db_loop_execs)
+    def db_get_loop_execs(self):
+        return self._db_loop_execs
+    def db_add_loop_exec(self, loop_exec):
+        self.is_dirty = True
+        self._db_loop_execs.append(loop_exec)
+        self.db_loop_execs_id_index[loop_exec.db_id] = loop_exec
+    def db_change_loop_exec(self, loop_exec):
+        self.is_dirty = True
+        found = False
+        for i in xrange(len(self._db_loop_execs)):
+            if self._db_loop_execs[i].db_id == loop_exec.db_id:
+                self._db_loop_execs[i] = loop_exec
+                found = True
+                break
+        if not found:
+            self._db_loop_execs.append(loop_exec)
+        self.db_loop_execs_id_index[loop_exec.db_id] = loop_exec
+    def db_delete_loop_exec(self, loop_exec):
+        self.is_dirty = True
+        for i in xrange(len(self._db_loop_execs)):
+            if self._db_loop_execs[i].db_id == loop_exec.db_id:
+                if not self._db_loop_execs[i].is_new:
+                    self.db_deleted_loop_execs.append(self._db_loop_execs[i])
+                del self._db_loop_execs[i]
+                break
+        del self.db_loop_execs_id_index[loop_exec.db_id]
+    def db_get_loop_exec(self, key):
+        for i in xrange(len(self._db_loop_execs)):
+            if self._db_loop_execs[i].db_id == key:
+                return self._db_loop_execs[i]
+        return None
+    def db_get_loop_exec_by_id(self, key):
+        return self.db_loop_execs_id_index[key]
+    def db_has_loop_exec_with_id(self, key):
+        return key in self.db_loop_execs_id_index
+    
+    def getPrimaryKey(self):
+        return self._db_id
+
+class DBProvAssociation(object):
+
+    vtType = 'prov_association'
+
+    def __init__(self, prov_activity=None, prov_agent=None, prov_plan=None, prov_role=None):
+        self.db_deleted_prov_activity = []
+        self._db_prov_activity = prov_activity
+        self.db_deleted_prov_agent = []
+        self._db_prov_agent = prov_agent
+        self.db_deleted_prov_plan = []
+        self._db_prov_plan = prov_plan
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBProvAssociation.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBProvAssociation(prov_role=self._db_prov_role)
+        if self._db_prov_activity is not None:
+            cp._db_prov_activity = self._db_prov_activity.do_copy(new_ids, id_scope, id_remap)
+        if self._db_prov_agent is not None:
+            cp._db_prov_agent = self._db_prov_agent.do_copy(new_ids, id_scope, id_remap)
+        if self._db_prov_plan is not None:
+            cp._db_prov_plan = self._db_prov_plan.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBProvAssociation()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'prov_activity' in class_dict:
+            res = class_dict['prov_activity'](old_obj, trans_dict)
+            new_obj.db_prov_activity = res
+        elif hasattr(old_obj, 'db_prov_activity') and old_obj.db_prov_activity is not None:
+            obj = old_obj.db_prov_activity
+            new_obj.db_add_prov_activity(DBRefProvActivity.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_activity') and hasattr(new_obj, 'db_deleted_prov_activity'):
+            for obj in old_obj.db_deleted_prov_activity:
+                n_obj = DBRefProvActivity.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_activity.append(n_obj)
+        if 'prov_agent' in class_dict:
+            res = class_dict['prov_agent'](old_obj, trans_dict)
+            new_obj.db_prov_agent = res
+        elif hasattr(old_obj, 'db_prov_agent') and old_obj.db_prov_agent is not None:
+            obj = old_obj.db_prov_agent
+            new_obj.db_add_prov_agent(DBRefProvAgent.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_agent') and hasattr(new_obj, 'db_deleted_prov_agent'):
+            for obj in old_obj.db_deleted_prov_agent:
+                n_obj = DBRefProvAgent.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_agent.append(n_obj)
+        if 'prov_plan' in class_dict:
+            res = class_dict['prov_plan'](old_obj, trans_dict)
+            new_obj.db_prov_plan = res
+        elif hasattr(old_obj, 'db_prov_plan') and old_obj.db_prov_plan is not None:
+            obj = old_obj.db_prov_plan
+            new_obj.db_add_prov_plan(DBRefProvPlan.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_prov_plan') and hasattr(new_obj, 'db_deleted_prov_plan'):
+            for obj in old_obj.db_deleted_prov_plan:
+                n_obj = DBRefProvPlan.update_version(obj, trans_dict)
+                new_obj.db_deleted_prov_plan.append(n_obj)
+        if 'prov_role' in class_dict:
+            res = class_dict['prov_role'](old_obj, trans_dict)
+            new_obj.db_prov_role = res
+        elif hasattr(old_obj, 'db_prov_role') and old_obj.db_prov_role is not None:
+            new_obj.db_prov_role = old_obj.db_prov_role
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_prov_activity is not None:
+            children.extend(self._db_prov_activity.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_activity = None
+        if self._db_prov_agent is not None:
+            children.extend(self._db_prov_agent.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_agent = None
+        if self._db_prov_plan is not None:
+            children.extend(self._db_prov_plan.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_prov_plan = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_prov_activity)
+        children.extend(self.db_deleted_prov_agent)
+        children.extend(self.db_deleted_prov_plan)
+        if remove:
+            self.db_deleted_prov_activity = []
+            self.db_deleted_prov_agent = []
+            self.db_deleted_prov_plan = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_prov_activity is not None and self._db_prov_activity.has_changes():
+            return True
+        if self._db_prov_agent is not None and self._db_prov_agent.has_changes():
+            return True
+        if self._db_prov_plan is not None and self._db_prov_plan.has_changes():
+            return True
+        return False
+    def __get_db_prov_activity(self):
+        return self._db_prov_activity
+    def __set_db_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+        self.is_dirty = True
+    db_prov_activity = property(__get_db_prov_activity, __set_db_prov_activity)
+    def db_add_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_change_prov_activity(self, prov_activity):
+        self._db_prov_activity = prov_activity
+    def db_delete_prov_activity(self, prov_activity):
+        if not self.is_new:
+            self.db_deleted_prov_activity.append(self._db_prov_activity)
+        self._db_prov_activity = None
+    
+    def __get_db_prov_agent(self):
+        return self._db_prov_agent
+    def __set_db_prov_agent(self, prov_agent):
+        self._db_prov_agent = prov_agent
+        self.is_dirty = True
+    db_prov_agent = property(__get_db_prov_agent, __set_db_prov_agent)
+    def db_add_prov_agent(self, prov_agent):
+        self._db_prov_agent = prov_agent
+    def db_change_prov_agent(self, prov_agent):
+        self._db_prov_agent = prov_agent
+    def db_delete_prov_agent(self, prov_agent):
+        if not self.is_new:
+            self.db_deleted_prov_agent.append(self._db_prov_agent)
+        self._db_prov_agent = None
+    
+    def __get_db_prov_plan(self):
+        return self._db_prov_plan
+    def __set_db_prov_plan(self, prov_plan):
+        self._db_prov_plan = prov_plan
+        self.is_dirty = True
+    db_prov_plan = property(__get_db_prov_plan, __set_db_prov_plan)
+    def db_add_prov_plan(self, prov_plan):
+        self._db_prov_plan = prov_plan
+    def db_change_prov_plan(self, prov_plan):
+        self._db_prov_plan = prov_plan
+    def db_delete_prov_plan(self, prov_plan):
+        if not self.is_new:
+            self.db_deleted_prov_plan.append(self._db_prov_plan)
+        self._db_prov_plan = None
+    
+    def __get_db_prov_role(self):
+        return self._db_prov_role
+    def __set_db_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+        self.is_dirty = True
+    db_prov_role = property(__get_db_prov_role, __set_db_prov_role)
+    def db_add_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_change_prov_role(self, prov_role):
+        self._db_prov_role = prov_role
+    def db_delete_prov_role(self, prov_role):
+        self._db_prov_role = None
+    
+
+
+class DBOpmProcessValue(object):
+
+    vtType = 'opm_process_value'
+
+    def __init__(self, value=None):
+        self.db_deleted_value = []
+        self._db_value = value
+        self.is_dirty = True
+        self.is_new = True
+    
+    def __copy__(self):
+        return DBOpmProcessValue.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = DBOpmProcessValue()
+        if self._db_value is not None:
+            cp._db_value = self._db_value.do_copy(new_ids, id_scope, id_remap)
+        
+        # set new ids
+        if new_ids:
+            new_id = id_scope.getNewId(self.vtType)
+            if self.vtType in id_scope.remap:
+                id_remap[(id_scope.remap[self.vtType], self.db_id)] = new_id
+            else:
+                id_remap[(self.vtType, self.db_id)] = new_id
+            cp.db_id = new_id
+        
+        # recreate indices and set flags
+        if not new_ids:
+            cp.is_dirty = self.is_dirty
+            cp.is_new = self.is_new
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBOpmProcessValue()
+        class_dict = {}
+        if new_obj.__class__.__name__ in trans_dict:
+            class_dict = trans_dict[new_obj.__class__.__name__]
+        if 'value' in class_dict:
+            res = class_dict['value'](old_obj, trans_dict)
+            new_obj.db_value = res
+        elif hasattr(old_obj, 'db_value') and old_obj.db_value is not None:
+            obj = old_obj.db_value
+            if obj.vtType == 'module_exec':
+                new_obj.db_add_value(DBModuleExec.update_version(obj, trans_dict))
+            elif obj.vtType == 'group_exec':
+                new_obj.db_add_value(DBGroupExec.update_version(obj, trans_dict))
+            elif obj.vtType == 'loop_exec':
+                new_obj.db_add_value(DBLoopExec.update_version(obj, trans_dict))
+        if hasattr(old_obj, 'db_deleted_value') and hasattr(new_obj, 'db_deleted_value'):
+            for obj in old_obj.db_deleted_value:
+                if obj.vtType == 'module_exec':
+                    n_obj = DBModuleExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'group_exec':
+                    n_obj = DBGroupExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+                elif obj.vtType == 'loop_exec':
+                    n_obj = DBLoopExec.update_version(obj, trans_dict)
+                    new_obj.db_deleted_value.append(n_obj)
+        new_obj.is_new = old_obj.is_new
+        new_obj.is_dirty = old_obj.is_dirty
+        return new_obj
+
+    def db_children(self, parent=(None,None), orphan=False, for_action=False):
+        children = []
+        if self._db_value is not None:
+            children.extend(self._db_value.db_children((self.vtType, self.db_id), orphan, for_action))
+            if orphan:
+                self._db_value = None
+        children.append((self, parent[0], parent[1]))
+        return children
+    def db_deleted_children(self, remove=False):
+        children = []
+        children.extend(self.db_deleted_value)
+        if remove:
+            self.db_deleted_value = []
+        return children
+    def has_changes(self):
+        if self.is_dirty:
+            return True
+        if self._db_value is not None and self._db_value.has_changes():
+            return True
+        return False
+    def __get_db_value(self):
+        return self._db_value
+    def __set_db_value(self, value):
+        self._db_value = value
+        self.is_dirty = True
+    db_value = property(__get_db_value, __set_db_value)
+    def db_add_value(self, value):
+        self._db_value = value
+    def db_change_value(self, value):
+        self._db_value = value
+    def db_delete_value(self, value):
+        if not self.is_new:
+            self.db_deleted_value.append(self._db_value)
+        self._db_value = None
+    
+
+
diff --git a/vistrails/db/versions/v1_0_5/domain/id_scope.py b/vistrails/db/versions/v1_0_5/domain/id_scope.py
new file mode 100644
index 000000000..59345cf08
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/id_scope.py
@@ -0,0 +1,88 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+import copy
+
+class IdScope:
+    def __init__(self, beginId=0L, remap=None):
+        self.ids = {}
+        self.beginId = beginId
+        if remap is None:
+            self.remap = {}
+        else:
+            self.remap = remap
+
+    def __copy__(self):
+        cp = IdScope(beginId=self.beginId)
+        cp.ids = copy.copy(self.ids)
+        cp.remap = copy.copy(self.remap)
+        return cp
+
+    def __str__(self):
+        return str(self.ids)
+
+    def getNewId(self, objType):
+        try:
+            objType = self.remap[objType]
+        except KeyError:
+            pass
+        try:
+            id = self.ids[objType]
+            self.ids[objType] += 1
+            return id
+        except KeyError:
+            self.ids[objType] = self.beginId + 1
+            return self.beginId
+
+    def updateBeginId(self, objType, beginId):
+        try:
+            objType = self.remap[objType]
+        except KeyError:
+            pass
+        try:
+            if self.ids[objType] <= beginId:
+                self.ids[objType] = beginId
+        except KeyError:
+            self.ids[objType] = beginId
+        
+    def setBeginId(self, objType, beginId):
+        try:
+            objType = self.remap[objType]
+        except KeyError:
+            pass
+        self.ids[objType] = beginId
diff --git a/vistrails/db/versions/v1_0_5/domain/log.py b/vistrails/db/versions/v1_0_5/domain/log.py
new file mode 100644
index 000000000..46fae4a0e
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/log.py
@@ -0,0 +1,75 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from auto_gen import DBLog as _DBLog
+from auto_gen import DBAbstraction, DBModule, DBGroup, DBLoopExec, \
+    DBGroupExec, DBModuleExec
+from id_scope import IdScope
+
+import copy
+
+class DBLog(_DBLog):
+
+    def __init__(self, *args, **kwargs):
+        _DBLog.__init__(self, *args, **kwargs)
+        self.id_scope = IdScope(1,
+                                {DBLoopExec.vtType: 'item_exec',
+                                 DBModuleExec.vtType: 'item_exec',
+                                 DBGroupExec.vtType: 'item_exec',
+                                 DBAbstraction.vtType: DBModule.vtType,
+                                 DBGroup.vtType: DBModule.vtType})
+
+    def __copy__(self):
+        return DBLog.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = _DBLog.do_copy(self, new_ids, id_scope, id_remap)
+        cp.__class__ = DBLog
+        cp.id_scope = copy.copy(self.id_scope)
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBLog()
+        new_obj = _DBLog.update_version(old_obj, trans_dict, new_obj)
+        new_obj.update_id_scope()
+        return new_obj
+
+    def update_id_scope(self):
+        pass
diff --git a/vistrails/db/versions/v1_0_5/domain/registry.py b/vistrails/db/versions/v1_0_5/domain/registry.py
new file mode 100644
index 000000000..05c314147
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/registry.py
@@ -0,0 +1,66 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from auto_gen import DBRegistry as _DBRegistry, DBPackage, DBModuleDescriptor, \
+    DBPortSpec
+from id_scope import IdScope
+
+class DBRegistry(_DBRegistry):
+    def __init__(self, *args, **kwargs):
+        _DBRegistry.__init__(self, *args, **kwargs)
+        self.idScope = IdScope()
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBRegistry()
+        new_obj = _DBRegistry.update_version(old_obj, trans_dict, new_obj)
+        new_obj.update_id_scope()
+        return new_obj
+    
+    def update_id_scope(self):
+        for package in self.db_packages:
+            self.idScope.updateBeginId(DBPackage.vtType, package.db_id+1)
+            for descriptor in package.db_module_descriptors:
+                self.idScope.updateBeginId(DBModuleDescriptor.vtType,
+                                           descriptor.db_id+1)
+                for port_spec in descriptor.db_portSpecs:
+                    self.idScope.updateBeginId(DBPortSpec.vtType, 
+                                               port_spec.db_id+1)
+
+
diff --git a/vistrails/db/versions/v1_0_5/domain/vistrail.py b/vistrails/db/versions/v1_0_5/domain/vistrail.py
new file mode 100644
index 000000000..db5377a20
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/vistrail.py
@@ -0,0 +1,223 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+import copy
+import hashlib
+from auto_gen import DBVistrail as _DBVistrail
+from auto_gen import DBAdd, DBChange, DBDelete, DBAbstraction, DBGroup, \
+    DBModule, DBAnnotation, DBActionAnnotation, DBParameterExploration
+from id_scope import IdScope
+
+class DBVistrail(_DBVistrail):
+    def __init__(self, *args, **kwargs):
+        _DBVistrail.__init__(self, *args, **kwargs)
+        self.idScope = IdScope(remap={DBAdd.vtType: 'operation',
+                                      DBChange.vtType: 'operation',
+                                      DBDelete.vtType: 'operation',
+                                      DBAbstraction.vtType: DBModule.vtType,
+                                      DBGroup.vtType: DBModule.vtType,
+                                      DBActionAnnotation.vtType: \
+                                          DBAnnotation.vtType})
+
+        self.idScope.setBeginId('action', 1)
+        self.idScope.setBeginId(DBParameterExploration.vtType, 1)
+        self.db_objects = {}
+
+        # keep a reference to the current logging information here
+        self.db_log_filename = None
+        self.log = None
+
+    def __copy__(self):
+        return DBVistrail.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = _DBVistrail.do_copy(self, new_ids, id_scope, id_remap)
+        cp.__class__ = DBVistrail
+        
+        cp.idScope = copy.copy(self.idScope)
+        cp.db_objects = copy.copy(self.db_objects)
+        cp.db_log_filename = self.db_log_filename
+        if self.log is not None:
+            cp.log = copy.copy(self.log)
+        else:
+            cp.log = None
+        
+        return cp
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBVistrail()
+        new_obj = _DBVistrail.update_version(old_obj, trans_dict, new_obj)
+        new_obj.update_id_scope()
+        if hasattr(old_obj, 'db_log_filename'):
+            new_obj.db_log_filename = old_obj.db_log_filename
+        if hasattr(old_obj, 'log'):
+            new_obj.log = old_obj.log
+        return new_obj
+
+    def update_id_scope(self):
+        def getOldObjId(operation):
+            if operation.vtType == 'change':
+                return operation.db_oldObjId
+            return operation.db_objectId
+
+        def getNewObjId(operation):
+            if operation.vtType == 'change':
+                return operation.db_newObjId
+            return operation.db_objectId
+
+        for action in self.db_actions:
+            self.idScope.updateBeginId('action', action.db_id+1)
+            if action.db_session is not None:
+                self.idScope.updateBeginId('session', action.db_session + 1)
+            for operation in action.db_operations:
+                self.idScope.updateBeginId('operation', operation.db_id+1)
+                if operation.vtType == 'add' or operation.vtType == 'change':
+                    # update ids of data
+                    self.idScope.updateBeginId(operation.db_what, 
+                                               getNewObjId(operation)+1)
+                    if operation.db_data is None:
+                        if operation.vtType == 'change':
+                            operation.db_objectId = operation.db_oldObjId
+                    self.db_add_object(operation.db_data)
+            for annotation in action.db_annotations:
+                self.idScope.updateBeginId('annotation', annotation.db_id+1)
+        
+        for annotation in self.db_annotations:
+            self.idScope.updateBeginId('annotation', annotation.db_id+1)
+        for annotation in self.db_actionAnnotations:
+            self.idScope.updateBeginId('annotation', annotation.db_id+1)
+        for paramexp in self.db_parameter_explorations:
+            self.idScope.updateBeginId('parameter_exploration',
+                                       paramexp.db_id+1)
+
+    def db_add_object(self, obj):
+        self.db_objects[(obj.vtType, obj.db_id)] = obj
+
+    def db_get_object(self, type, id):
+        return self.db_objects.get((type, id), None)
+
+    def db_update_object(self, obj, **kwargs):
+        # want to swap out old object with a new version
+        # need this for updating aliases...
+        # hack it using setattr...
+        real_obj = self.db_objects[(obj.vtType, obj.db_id)]
+        for (k, v) in kwargs.iteritems():
+            if hasattr(real_obj, k):
+                setattr(real_obj, k, v)
+
+    def update_checkout_version(self, app=''):
+        checkout_key = "__checkout_version_"
+        action_key = checkout_key + app
+        annotation_key = action_key + '_annotationhash'
+        action_annotation_key = action_key + '_actionannotationhash'
+
+        # delete previous checkout annotations
+        deletekeys = [action_key,annotation_key,action_annotation_key]
+        for key in deletekeys:
+            while self.db_has_annotation_with_key(key):
+                a = self.db_get_annotation_by_key(key)
+                self.db_delete_annotation(a)
+        
+        # annotation hash - requires annotations to be clean
+        value = self.hashAnnotations()
+        if self.db_has_annotation_with_key(annotation_key):
+            annotation = self.db_get_annotation_by_key(annotation_key)
+            annotation.db_value = value
+        else:
+            annotation=DBAnnotation(self.idScope.getNewId(DBAnnotation.vtType), 
+                                  annotation_key, value)
+            self.db_add_annotation(annotation)
+        # action annotation hash
+        value = self.hashActionAnnotations()
+        if self.db_has_annotation_with_key(action_annotation_key):
+            annotation = self.db_get_annotation_by_key(action_annotation_key)
+            annotation.db_value = value
+        else:
+            annotation=DBAnnotation(self.idScope.getNewId(DBAnnotation.vtType), 
+                                    action_annotation_key, value)
+            self.db_add_annotation(annotation)
+        # last action id hash
+        if len(self.db_actions) == 0:
+            value = 0
+        else:
+            value = max(v.db_id for v in self.db_actions)
+        if self.db_has_annotation_with_key(action_key):
+            annotation = self.db_get_annotation_by_key(action_key)
+            annotation.db_value = str(value)
+        else:
+            annotation=DBAnnotation(self.idScope.getNewId(DBAnnotation.vtType), 
+                                    action_key, str(value))
+            self.db_add_annotation(annotation)
+
+    def hashAnnotations(self):
+        annotations = {}
+        for annotation in self.db_annotations:
+            if annotation._db_key not in annotations:
+                annotations[annotation._db_key] = []
+            if annotation._db_value not in annotations[annotation._db_key]:
+                annotations[annotation._db_key].append(annotation._db_value)
+        keys = annotations.keys()
+        keys.sort()
+        m = hashlib.md5()
+        for k in keys:
+            m.update(str(k))
+            annotations[k].sort()
+            for v in annotations[k]:
+                m.update(str(v))
+        return m.hexdigest()
+
+    def hashActionAnnotations(self):
+        action_annotations = {}
+        for action_id, key, value in [[aa.db_action_id, aa.db_key, 
+                         aa.db_value] for aa in self.db_actionAnnotations]:
+            index = (str(action_id), key)
+            if index not in action_annotations:
+                action_annotations[index] = []
+            if value not in action_annotations[index]:
+                action_annotations[index].append(value)
+        keys = action_annotations.keys()
+        keys.sort()
+        m = hashlib.md5()
+        for k in keys:
+            m.update(k[0] + k[1])
+            action_annotations[k].sort()
+            for v in action_annotations[k]:
+                m.update(str(v))
+        return m.hexdigest()
diff --git a/vistrails/db/versions/v1_0_5/domain/workflow.py b/vistrails/db/versions/v1_0_5/domain/workflow.py
new file mode 100644
index 000000000..c3118c50a
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/domain/workflow.py
@@ -0,0 +1,175 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from auto_gen import DBWorkflow as _DBWorkflow
+from auto_gen import DBAbstraction, DBModule, DBGroup
+from id_scope import IdScope
+
+import copy
+
+class DBWorkflow(_DBWorkflow):
+
+    def __init__(self, *args, **kwargs):
+        _DBWorkflow.__init__(self, *args, **kwargs)
+        self.objects = {}
+        self.tmp_id = IdScope(1,
+                              {DBAbstraction.vtType: DBModule.vtType,
+                               DBGroup.vtType: DBModule.vtType})
+
+    def __copy__(self):
+        return DBWorkflow.do_copy(self)
+
+    def do_copy(self, new_ids=False, id_scope=None, id_remap=None):
+        cp = _DBWorkflow.do_copy(self, new_ids, id_scope, id_remap)
+        cp.__class__ = DBWorkflow
+        # need to go through and reset the index to the copied objects
+        cp.build_index()
+        cp.tmp_id = copy.copy(self.tmp_id)
+        return cp        
+
+    @staticmethod
+    def update_version(old_obj, trans_dict, new_obj=None):
+        if new_obj is None:
+            new_obj = DBWorkflow()
+        new_obj = _DBWorkflow.update_version(old_obj, trans_dict, new_obj)
+        new_obj.update_id_scope()
+        new_obj.build_index()
+        return new_obj
+    
+    def update_id_scope(self):
+        pass
+
+    _vtTypeMap = {DBAbstraction.vtType: DBModule.vtType, 
+                  DBGroup.vtType: DBModule.vtType}
+
+    def build_index(self):
+        g = self._vtTypeMap.get
+        self.objects = dict(((g(o.vtType, o.vtType), o._db_id), o)
+                            for (o,_,_) in self.db_children())
+
+    def add_to_index(self, object):
+        obj_type = self._vtTypeMap.get(object.vtType, object.vtType)
+        self.objects[(obj_type, object.getPrimaryKey())] = object
+
+    def delete_from_index(self, object):
+        obj_type = self._vtTypeMap.get(object.vtType, object.vtType)
+        del self.objects[(obj_type, object.getPrimaryKey())]
+
+    def capitalizeOne(self, str):
+        return str[0].upper() + str[1:]
+
+    def db_print_objects(self):
+        for k,v in self.objects.iteritems():
+            print '%s: %s' % (k, v)
+
+    def db_has_object(self, type, id):
+        return (type, id) in self.objects
+
+    def db_get_object(self, type, id):
+        return self.objects[(type, id)]
+
+    def db_add_object(self, object, parent_obj_type=None,
+                      parent_obj_id=None, parent_obj=None):
+        if parent_obj is None:
+            if parent_obj_type is None or parent_obj_id is None:
+                parent_obj = self
+            else:
+                if parent_obj_type == DBAbstraction.vtType or \
+                        parent_obj_type == DBGroup.vtType:
+                    parent_obj_type = DBModule.vtType
+                try:
+                    parent_obj = self.objects[(parent_obj_type, parent_obj_id)]
+                except KeyError:
+                    msg = "Cannot find object of type '%s' with id '%s'" % \
+                        (parent_obj_type, parent_obj_id)
+                    raise Exception(msg)
+        if object.vtType == DBAbstraction.vtType or \
+                object.vtType == DBGroup.vtType:
+            obj_type = DBModule.vtType
+        else:
+            obj_type = object.vtType
+        funname = 'db_add_' + obj_type
+        obj_copy = copy.copy(object)
+        getattr(parent_obj, funname)(obj_copy)
+        self.add_to_index(obj_copy)
+
+    def db_change_object(self, old_id, object, parent_obj_type=None, 
+                         parent_obj_id=None, parent_obj=None):
+        if parent_obj is None:
+            if parent_obj_type is None or parent_obj_id is None:
+                parent_obj = self
+            else:
+                if parent_obj_type == DBAbstraction.vtType or \
+                        parent_obj_type == DBGroup.vtType:
+                    parent_obj_type = DBModule.vtType
+                try:
+                    parent_obj = self.objects[(parent_obj_type, parent_obj_id)]
+                except KeyError:
+                    msg = "Cannot find object of type '%s' with id '%s'" % \
+                        (parent_obj_type, parent_obj_id)
+                    raise Exception(msg)
+
+        self.db_delete_object(old_id, object.vtType, None, None, parent_obj)
+        self.db_add_object(object, None, None, parent_obj)
+
+    def db_delete_object(self, obj_id, obj_type, parent_obj_type=None, 
+                         parent_obj_id=None, parent_obj=None):
+        if parent_obj is None:
+            if parent_obj_type is None or parent_obj_id is None:
+                parent_obj = self
+            else:
+                if parent_obj_type == DBAbstraction.vtType or \
+                        parent_obj_type == DBGroup.vtType:
+                    parent_obj_type = DBModule.vtType
+                try:
+                    parent_obj = self.objects[(parent_obj_type, parent_obj_id)]
+                except KeyError:
+                    msg = "Cannot find object of type '%s' with id '%s'" % \
+                        (parent_obj_type, parent_obj_id)
+                    raise Exception(msg)
+        if obj_type == DBAbstraction.vtType or obj_type == DBGroup.vtType:
+            obj_type = DBModule.vtType
+        funname = 'db_get_' + obj_type
+        if hasattr(parent_obj, funname):
+            object = getattr(parent_obj, funname)(obj_id)
+        else:
+            attr_name = 'db_' + obj_type
+            object = getattr(parent_obj, attr_name)
+        funname = 'db_delete_' + obj_type
+        getattr(parent_obj, funname)(object)
+        self.delete_from_index(object)
diff --git a/vistrails/db/versions/v1_0_5/persistence/__init__.py b/vistrails/db/versions/v1_0_5/persistence/__init__.py
new file mode 100644
index 000000000..86ececbff
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/__init__.py
@@ -0,0 +1,475 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+from __future__ import division
+
+from xml.auto_gen import XMLDAOListBase
+from sql.auto_gen import SQLDAOListBase
+from vistrails.core.system import get_elementtree_library
+
+from vistrails.db import VistrailsDBException
+from vistrails.db.versions.v1_0_5 import version as my_version
+from vistrails.db.versions.v1_0_5.domain import DBGroup, DBWorkflow, DBVistrail, DBLog, \
+    DBRegistry, DBMashuptrail
+
+root_set = set([DBVistrail.vtType, DBWorkflow.vtType, 
+                DBLog.vtType, DBRegistry.vtType, DBMashuptrail.vtType])
+
+ElementTree = get_elementtree_library()
+
+
+class DAOList(dict):
+    def __init__(self):
+        self['xml'] = XMLDAOListBase()
+        self['sql'] = SQLDAOListBase()
+
+    def parse_xml_file(self, filename):
+        return ElementTree.parse(filename)
+
+    def write_xml_file(self, filename, tree):
+        def indent(elem, level=0):
+            i = "\n" + level*"  "
+            if len(elem):
+                if not elem.text or not elem.text.strip():
+                    elem.text = i + "  "
+                if not elem.tail or not elem.tail.strip():
+                    elem.tail = i
+                for elem in elem:
+                    indent(elem, level+1)
+                if not elem.tail or not elem.tail.strip():
+                    elem.tail = i
+            else:
+                if level and (not elem.tail or not elem.tail.strip()):
+                    elem.tail = i
+        indent(tree.getroot())
+        tree.write(filename)
+
+    def read_xml_object(self, vtType, node):
+        return self['xml'][vtType].fromXML(node)
+
+    def write_xml_object(self, obj, node=None):
+        res_node = self['xml'][obj.vtType].toXML(obj, node)
+        return res_node
+        
+    def open_from_xml(self, filename, vtType, tree=None):
+        """open_from_xml(filename) -> DBVistrail"""
+        if tree is None:
+            tree = self.parse_xml_file(filename)
+        vistrail = self.read_xml_object(vtType, tree.getroot())
+        return vistrail
+
+    def save_to_xml(self, obj, filename, tags, version=None):
+        """save_to_xml(obj : object, filename: str, tags: dict,
+                       version: str) -> None
+    
+        """
+        root = self.write_xml_object(obj)
+        if version is None:
+            version = my_version
+        root.set('version', version)
+        for k, v in tags.iteritems():
+            root.set(k, v)
+        tree = ElementTree.ElementTree(root)
+        self.write_xml_file(filename, tree)
+
+    def open_from_db(self, db_connection, vtType, id=None, lock=False, 
+                     global_props=None):
+        all_objects = {}
+        if global_props is None:
+            global_props = {}
+        if id is not None:
+            global_props['id'] = id
+        #  global_props
+        res_objects = self['sql'][vtType].get_sql_columns(db_connection, 
+                                                          global_props,
+                                                          lock)
+        if len(res_objects) > 1:
+            raise VistrailsDBException("More than object of type '%s' and "
+                                       "id '%s' exist in the database" % \
+                                           (vtType, id))
+        elif len(res_objects) <= 0:
+            raise VistrailsDBException("No objects of type '%s' and "
+                                       "id '%s' exist in the database" % \
+                                           (vtType, id))
+        
+        all_objects.update(res_objects)
+        res = res_objects.values()[0]
+        global_props = {'entity_id': res.db_id,
+                        'entity_type': res.vtType}
+
+        # collect all commands so that they can be executed together
+        # daoList should contain (dao_type, dao, dbCommand) values
+        daoList = []
+        # dbCommandList should contain dbCommand values
+        dbCommandList = []
+        
+        # generate SELECT statements
+        for dao_type, dao in self['sql'].iteritems():
+            if dao_type in root_set:
+                continue
+
+            daoList.append([dao_type, dao, None])
+            dbCommand = dao.get_sql_select(db_connection, global_props, lock)
+            dbCommandList.append(dbCommand)
+            
+        # Exacute all select statements
+        results = self['sql'][vtType].executeSQLGroup(db_connection,
+                                                      dbCommandList, True)
+
+        # add result to correct dao
+        for i in xrange(len(daoList)):
+            daoList[i][2] = results[i]
+        
+        # process results
+        for dao_type, dao, data in daoList:
+            current_objs = dao.process_sql_columns(data, global_props)
+            all_objects.update(current_objs)
+
+            if dao_type == DBGroup.vtType:
+                for key, obj in current_objs.iteritems():
+                    new_props = {'parent_id': key[1],
+                                 'entity_id': global_props['entity_id'],
+                                 'entity_type': global_props['entity_type']}
+                    res_obj = self.open_from_db(db_connection, 
+                                                DBWorkflow.vtType, 
+                                                None, lock, new_props)
+                    res_dict = {}
+                    res_dict[(res_obj.vtType, res_obj.db_id)] = res_obj
+                    all_objects.update(res_dict)
+
+        for key, obj in all_objects.iteritems():
+            if key[0] == vtType and key[1] == id:
+                continue
+            self['sql'][obj.vtType].from_sql_fast(obj, all_objects)
+        for obj in all_objects.itervalues():
+            obj.is_dirty = False
+            obj.is_new = False
+
+        return res
+
+    def open_many_from_db(self, db_connection, vtType, ids, lock=False):
+        """ Loads multiple objects. They need to be loaded as one single
+            multiple select statement command for performance reasons.
+        """
+
+        log_dao = self['sql'][vtType]
+        # loop through ids and build SELECT statements
+        selects = [log_dao.get_sql_select(db_connection, {'id': id}, lock)
+                   for id in ids]
+        # Execute all SELECT statements for main objects
+        results = log_dao.executeSQLGroup(db_connection, selects, True)
+
+        # list of final objects
+        objects = []
+        # list of selects
+        selects = []
+        # list of children id:all_objects_dict
+        all_objects_dict = {}
+        # process each result and extract child SELECTS
+        # daoList should contain (id, dao_type, dao, result) values
+        daoList = []
+        # selects should contain dbCommand values
+        selects = []
+        global_props = {}
+        for id, data in zip(ids, results):
+            res_objects = log_dao.process_sql_columns(data, global_props)
+            if len(res_objects) > 1:
+                raise VistrailsDBException("More than object of type '%s' and "
+                                           "id '%s' exist in the database" % \
+                                               (vtType, id))
+            elif len(res_objects) <= 0:
+                raise VistrailsDBException("No objects of type '%s' and "
+                                           "id '%s' exist in the database" % \
+                                               (vtType, id))
+            all_objects = {}
+            all_objects_dict[id] = all_objects
+            all_objects.update(res_objects)
+            objects.append(res_objects.values()[0])
+            # collect all commands so that they can be executed together
+        
+            # generate SELECT statements for children
+            for dao_type, dao in self['sql'].iteritems():
+                if dao_type in root_set:
+                    continue
+    
+                daoList.append([id, dao_type, dao, None])
+                dbCommand = dao.get_sql_select(db_connection, global_props, lock)
+                selects.append(dbCommand)
+
+        # Execute all child select statements
+        results = self['sql'][vtType].executeSQLGroup(db_connection,
+                                                      selects, True)
+        for i in xrange(len(daoList)):
+            daoList[i][3] = results[i]
+
+        # process results
+        for id, dao_type, dao, data in daoList:
+            all_objects = all_objects_dict[id]
+            current_objs = dao.process_sql_columns(data, global_props)
+            all_objects.update(current_objs)
+
+            if dao_type == DBGroup.vtType:
+                for key, obj in current_objs.iteritems():
+                    new_props = {'parent_id': key[1],
+                                 'entity_id': global_props['entity_id'],
+                                 'entity_type': global_props['entity_type']}
+                    res_obj = self.open_from_db(db_connection, 
+                                                DBWorkflow.vtType, 
+                                                None, lock, new_props)
+                    res_dict = {}
+                    res_dict[(res_obj.vtType, res_obj.db_id)] = res_obj
+                    all_objects.update(res_dict)
+
+        
+        for id, all_objects in all_objects_dict.iteritems():
+            for key, obj in all_objects.iteritems():
+                if key[0] == vtType and key[1] == id:
+                    continue
+                self['sql'][obj.vtType].from_sql_fast(obj, all_objects)
+        for id, dao_type, dao, data in daoList:
+            all_objects = all_objects_dict[id]
+            for obj in all_objects.itervalues():
+                obj.is_dirty = False
+                obj.is_new = False
+    
+        return objects
+
+    def save_to_db(self, db_connection, obj, do_copy=False, global_props=None):
+        if do_copy == 'with_ids':
+            do_copy = True
+        elif do_copy and obj.db_id is not None:
+            obj.db_id = None
+
+        children = obj.db_children()
+        children.reverse()
+        if global_props is None:
+            global_props = {'entity_type': obj.vtType}
+        # print 'global_props:', global_props
+
+        # assumes not deleting entire thing
+        child = children[0][0]
+        self['sql'][child.vtType].set_sql_columns(db_connection, child, 
+                                                  global_props, do_copy)
+        self['sql'][child.vtType].to_sql_fast(child, do_copy)
+
+        global_props = {'entity_id': child.db_id,
+                        'entity_type': child.vtType}
+
+        # do deletes
+        if not do_copy:
+            for (child, _, _) in children:
+                for c in child.db_deleted_children(True):
+                    self['sql'][c.vtType].delete_sql_column(db_connection,
+                                                            c,
+                                                            global_props)
+        child = children.pop(0)[0]
+        child.is_dirty = False
+        child.is_new = False
+        
+        if not len(children):
+            return
+
+        # list of all children
+        dbCommandList = []
+        writtenChildren = []
+        # process remaining children
+        for (child, _, _) in children:
+            dbCommand = self['sql'][child.vtType].set_sql_command(
+                            db_connection, child, global_props, do_copy)
+            if dbCommand is not None:
+                dbCommandList.append(dbCommand)
+                writtenChildren.append(child)
+            self['sql'][child.vtType].to_sql_fast(child, do_copy)
+
+        # Debug version of Execute all insert/update statements
+        #results = [self['sql'][children[0][0].vtType].executeSQL(
+        #                      db_connection, c, False) for c in dbCommandList]
+
+        # Execute all insert/update statements
+        results = self['sql'][children[0][0].vtType].executeSQLGroup(
+                                                    db_connection,
+                                                    dbCommandList, False)
+        resultDict = dict(zip(writtenChildren, results))
+        # process remaining children
+        for (child, _, _) in children:
+            if child in resultDict:
+                lastId = resultDict[child]
+                self['sql'][child.vtType].set_sql_process(child, 
+                                                          global_props,
+                                                          lastId)
+            self['sql'][child.vtType].to_sql_fast(child, do_copy)
+            if child.vtType == DBGroup.vtType:
+                if child.db_workflow:
+                    # print '*** entity_type:', global_props['entity_type']
+                    new_props = {'entity_id': global_props['entity_id'],
+                                 'entity_type': global_props['entity_type']}
+                    is_dirty = child.db_workflow.is_dirty
+                    child.db_workflow.db_entity_type = DBWorkflow.vtType
+                    child.db_workflow.is_dirty = is_dirty
+                    self.save_to_db(db_connection, child.db_workflow, do_copy,
+                                    new_props)
+
+    def save_many_to_db(self, db_connection, objList, do_copy=False):
+        if do_copy == 'with_ids':
+            do_copy = True
+        if not len(objList):
+            return
+        childrenDict = {}
+        global_propsDict = {}
+        dbCommandList = []
+        writtenChildren = []
+        for obj in objList:
+            if do_copy and obj.db_id is not None:
+                obj.db_id = None
+
+            children = obj.db_children()
+            children.reverse()
+            global_props = {'entity_type': obj.vtType}
+
+            child = children[0][0]
+            dbCommand = self['sql'][child.vtType].set_sql_command(
+                db_connection, child, global_props, do_copy)
+            if dbCommand is not None:
+                dbCommandList.append(dbCommand)
+                writtenChildren.append(child)
+            
+            childrenDict[child] = children
+            global_propsDict[child] = global_props
+
+        # Execute all insert/update statements for the main objects
+        results = self['sql'][children[0][0].vtType].executeSQLGroup(
+                                                    db_connection,
+                                                    dbCommandList, False)
+        resultDict = dict(zip(writtenChildren, results))
+        dbCommandList = []
+        writtenChildren = []
+        for child, children in childrenDict.iteritems():
+            # process objects
+            if child in resultDict:
+                lastId = resultDict[child]
+                self['sql'][child.vtType].set_sql_process(
+                    child, global_propsDict[child], lastId)
+            self['sql'][child.vtType].to_sql_fast(child, do_copy)
+
+            # process children
+            global_props = {'entity_id': child.db_id,
+                                       'entity_type': child.vtType}
+            global_propsDict[child] = global_props
+            # do deletes
+            if not do_copy:
+                for (child, _, _) in childrenDict[child]:
+                    for c in child.db_deleted_children(True):
+                        self['sql'][c.vtType].delete_sql_column(db_connection,
+                                                                c,
+                                                                global_props)
+            child = children.pop(0)[0]
+            child.is_dirty = False
+            child.is_new = False
+            
+            # list of all children
+            # process remaining children
+            for (child, _, _) in children:
+                dbCommand = self['sql'][child.vtType].set_sql_command(
+                                db_connection, child, global_props, do_copy)
+                if dbCommand is not None:
+                    dbCommandList.append(dbCommand)
+                    writtenChildren.append(child)
+                self['sql'][child.vtType].to_sql_fast(child, do_copy)
+    
+        # Execute all child insert/update statements
+        results = self['sql'][children[0][0].vtType].executeSQLGroup(
+                                                        db_connection,
+                                                        dbCommandList, False)
+        resultDict = dict(zip(writtenChildren, results))
+
+        for child, children in childrenDict.iteritems():
+            global_props = global_propsDict[child]
+            # process remaining children
+            for (child, _, _) in children:
+                if child in resultDict:
+                    lastId = resultDict[child]
+                    self['sql'][child.vtType].set_sql_process(child, 
+                                                              global_props,
+                                                              lastId)
+                self['sql'][child.vtType].to_sql_fast(child, do_copy)
+                if child.vtType == DBGroup.vtType:
+                    if child.db_workflow:
+                        # print '*** entity_type:', global_props['entity_type']
+                        new_props = {'entity_id': global_props['entity_id'],
+                                     'entity_type': global_props['entity_type']}
+                        is_dirty = child.db_workflow.is_dirty
+                        child.db_workflow.db_entity_type = DBWorkflow.vtType
+                        child.db_workflow.is_dirty = is_dirty
+                        self.save_to_db(db_connection, child.db_workflow, do_copy,
+                                        new_props)
+
+    def delete_from_db(self, db_connection, type, obj_id):
+        if type not in root_set:
+            raise VistrailsDBException("Cannot delete entity of type '%s'" \
+                                           % type)
+
+        id_str = str(obj_id)
+        for (dao_type, dao) in self['sql'].iteritems():
+            if dao_type not in root_set:
+                db_cmd = \
+                    self['sql'][type].createSQLDelete(dao.table,
+                                                      {'entity_type': type,
+                                                       'entity_id': id_str})
+                self['sql'][type].executeSQL(db_connection, db_cmd, False)
+        db_cmd = self['sql'][type].createSQLDelete(self['sql'][type].table,
+                                                   {'id': id_str})
+        self['sql'][type].executeSQL(db_connection, db_cmd, False)
+
+    def serialize(self, object):
+        root = self.write_xml_object(object)
+        return ElementTree.tostring(root)
+
+    def unserialize(self, str, obj_type):
+        def set_dirty(obj):
+            for child, _, _ in obj.db_children():
+                if child.vtType == DBGroup.vtType:
+                    if child.db_workflow:
+                        set_dirty(child.db_workflow)
+                child.is_dirty = True
+                child.is_new = True
+        try:
+            root = ElementTree.fromstring(str)
+            obj = self.read_xml_object(obj_type, root)
+            set_dirty(obj)
+            return obj
+        except SyntaxError, e:
+            msg = "Invalid VisTrails serialized object %s" % str
+            raise VistrailsDBException(msg)
+            return None
diff --git a/vistrails/core/interpreter/utils.py b/vistrails/db/versions/v1_0_5/persistence/sql/__init__.py
similarity index 98%
rename from vistrails/core/interpreter/utils.py
rename to vistrails/db/versions/v1_0_5/persistence/sql/__init__.py
index 0a88b85f3..aa8ef81e8 100644
--- a/vistrails/core/interpreter/utils.py
+++ b/vistrails/db/versions/v1_0_5/persistence/sql/__init__.py
@@ -33,3 +33,7 @@
 ## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
 ##
 ###############################################################################
+
+from __future__ import division
+
+pass
\ No newline at end of file
diff --git a/vistrails/db/versions/v1_0_5/persistence/sql/auto_gen.py b/vistrails/db/versions/v1_0_5/persistence/sql/auto_gen.py
new file mode 100644
index 000000000..db6f5a48f
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/sql/auto_gen.py
@@ -0,0 +1,8360 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+"""generated automatically by auto_dao.py"""
+
+from sql_dao import SQLDAO
+from vistrails.db.versions.v1_0_5.domain import *
+
+class DBMashupAliasSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashup_alias'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_alias'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            parent = self.convertFromDB(row[2], 'long', 'int')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            
+            mashup_alias = DBMashupAlias(name=name,
+                                         id=id)
+            mashup_alias.db_parent = parent
+            mashup_alias.db_entity_id = entity_id
+            mashup_alias.db_entity_type = entity_type
+            mashup_alias.is_dirty = False
+            res[('mashup_alias', id)] = mashup_alias
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_alias'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            parent = self.convertFromDB(row[2], 'long', 'int')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            
+            mashup_alias = DBMashupAlias(name=name,
+                                         id=id)
+            mashup_alias.db_parent = parent
+            mashup_alias.db_entity_id = entity_id
+            mashup_alias.db_entity_type = entity_type
+            mashup_alias.is_dirty = False
+            res[('mashup_alias', id)] = mashup_alias
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('mashup', obj.db_parent) in all_objects:
+            p = all_objects[('mashup', obj.db_parent)]
+            p.db_add_alias(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_alias'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_alias'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_component is not None:
+            child = obj.db_component
+            child.db_mashup_alias = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashup_alias'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBGroupSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'group_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            group = DBGroup(cache=cache,
+                            name=name,
+                            namespace=namespace,
+                            package=package,
+                            version=version,
+                            id=id)
+            group.db_parentType = parentType
+            group.db_entity_id = entity_id
+            group.db_entity_type = entity_type
+            group.db_parent = parent
+            group.is_dirty = False
+            res[('group', id)] = group
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            group = DBGroup(cache=cache,
+                            name=name,
+                            namespace=namespace,
+                            package=package,
+                            version=version,
+                            id=id)
+            group.db_parentType = parentType
+            group.db_entity_id = entity_id
+            group.db_entity_type = entity_type
+            group.db_parent = parent
+            group.is_dirty = False
+            res[('group', id)] = group
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_module(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_workflow is not None:
+            child = obj.db_workflow
+            child.db_group = obj.db_id
+        if obj.db_location is not None:
+            child = obj.db_location
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_functions:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_controlParameters:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'group_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBAddSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'add_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'add_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            objectId = self.convertFromDB(row[2], 'long', 'int')
+            parentObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjType = self.convertFromDB(row[4], 'str', 'char(16)')
+            action = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            add = DBAdd(what=what,
+                        objectId=objectId,
+                        parentObjId=parentObjId,
+                        parentObjType=parentObjType,
+                        id=id)
+            add.db_action = action
+            add.db_entity_id = entity_id
+            add.db_entity_type = entity_type
+            add.is_dirty = False
+            res[('add', id)] = add
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'add_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            objectId = self.convertFromDB(row[2], 'long', 'int')
+            parentObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjType = self.convertFromDB(row[4], 'str', 'char(16)')
+            action = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            add = DBAdd(what=what,
+                        objectId=objectId,
+                        parentObjId=parentObjId,
+                        parentObjType=parentObjType,
+                        id=id)
+            add.db_action = action
+            add.db_entity_id = entity_id
+            add.db_entity_type = entity_type
+            add.is_dirty = False
+            res[('add', id)] = add
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('action', obj.db_action) in all_objects:
+            p = all_objects[('action', obj.db_action)]
+            p.db_add_operation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'add_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_objectId') and obj.db_objectId is not None:
+            columnMap['object_id'] = \
+                self.convertToDB(obj.db_objectId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'add_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_objectId') and obj.db_objectId is not None:
+            columnMap['object_id'] = \
+                self.convertToDB(obj.db_objectId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_data is not None:
+            child = obj.db_data
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'add_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBGroupExecSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'group_exec'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'group_name', 'group_type', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_exec'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            cached = self.convertFromDB(row[3], 'int', 'int')
+            module_id = self.convertFromDB(row[4], 'long', 'int')
+            group_name = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            group_type = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            completed = self.convertFromDB(row[7], 'int', 'int')
+            error = self.convertFromDB(row[8], 'str', 'varchar(1023)')
+            machine_id = self.convertFromDB(row[9], 'long', 'int')
+            parentType = self.convertFromDB(row[10], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[11], 'long', 'int')
+            entity_type = self.convertFromDB(row[12], 'str', 'char(16)')
+            parent = self.convertFromDB(row[13], 'long', 'long')
+            
+            group_exec = DBGroupExec(ts_start=ts_start,
+                                     ts_end=ts_end,
+                                     cached=cached,
+                                     module_id=module_id,
+                                     group_name=group_name,
+                                     group_type=group_type,
+                                     completed=completed,
+                                     error=error,
+                                     machine_id=machine_id,
+                                     id=id)
+            group_exec.db_parentType = parentType
+            group_exec.db_entity_id = entity_id
+            group_exec.db_entity_type = entity_type
+            group_exec.db_parent = parent
+            group_exec.is_dirty = False
+            res[('group_exec', id)] = group_exec
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'group_name', 'group_type', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_exec'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            cached = self.convertFromDB(row[3], 'int', 'int')
+            module_id = self.convertFromDB(row[4], 'long', 'int')
+            group_name = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            group_type = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            completed = self.convertFromDB(row[7], 'int', 'int')
+            error = self.convertFromDB(row[8], 'str', 'varchar(1023)')
+            machine_id = self.convertFromDB(row[9], 'long', 'int')
+            parentType = self.convertFromDB(row[10], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[11], 'long', 'int')
+            entity_type = self.convertFromDB(row[12], 'str', 'char(16)')
+            parent = self.convertFromDB(row[13], 'long', 'long')
+            
+            group_exec = DBGroupExec(ts_start=ts_start,
+                                     ts_end=ts_end,
+                                     cached=cached,
+                                     module_id=module_id,
+                                     group_name=group_name,
+                                     group_type=group_type,
+                                     completed=completed,
+                                     error=error,
+                                     machine_id=machine_id,
+                                     id=id)
+            group_exec.db_parentType = parentType
+            group_exec.db_entity_id = entity_id
+            group_exec.db_entity_type = entity_type
+            group_exec.db_parent = parent
+            group_exec.is_dirty = False
+            res[('group_exec', id)] = group_exec
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow_exec':
+            p = all_objects[('workflow_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'loop_iteration':
+            p = all_objects[('loop_iteration', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'group_exec':
+            p = all_objects[('group_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'group_name', 'group_type', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_cached') and obj.db_cached is not None:
+            columnMap['cached'] = \
+                self.convertToDB(obj.db_cached, 'int', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_group_name') and obj.db_group_name is not None:
+            columnMap['group_name'] = \
+                self.convertToDB(obj.db_group_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_group_type') and obj.db_group_type is not None:
+            columnMap['group_type'] = \
+                self.convertToDB(obj.db_group_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_machine_id') and obj.db_machine_id is not None:
+            columnMap['machine_id'] = \
+                self.convertToDB(obj.db_machine_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'group_name', 'group_type', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'group_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_cached') and obj.db_cached is not None:
+            columnMap['cached'] = \
+                self.convertToDB(obj.db_cached, 'int', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_group_name') and obj.db_group_name is not None:
+            columnMap['group_name'] = \
+                self.convertToDB(obj.db_group_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_group_type') and obj.db_group_type is not None:
+            columnMap['group_type'] = \
+                self.convertToDB(obj.db_group_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_machine_id') and obj.db_machine_id is not None:
+            columnMap['machine_id'] = \
+                self.convertToDB(obj.db_machine_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_item_execs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'group_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBParameterSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'parameter'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'name', 'type', 'val', 'alias', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'parameter'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            type = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            val = self.convertFromDB(row[4], 'str', 'mediumtext')
+            alias = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            parameter = DBParameter(pos=pos,
+                                    name=name,
+                                    type=type,
+                                    val=val,
+                                    alias=alias,
+                                    id=id)
+            parameter.db_parentType = parentType
+            parameter.db_entity_id = entity_id
+            parameter.db_entity_type = entity_type
+            parameter.db_parent = parent
+            parameter.is_dirty = False
+            res[('parameter', id)] = parameter
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'name', 'type', 'val', 'alias', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'parameter'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            type = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            val = self.convertFromDB(row[4], 'str', 'mediumtext')
+            alias = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            parameter = DBParameter(pos=pos,
+                                    name=name,
+                                    type=type,
+                                    val=val,
+                                    alias=alias,
+                                    id=id)
+            parameter.db_parentType = parentType
+            parameter.db_entity_id = entity_id
+            parameter.db_entity_type = entity_type
+            parameter.db_parent = parent
+            parameter.is_dirty = False
+            res[('parameter', id)] = parameter
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'function':
+            p = all_objects[('function', obj.db_parent)]
+            p.db_add_parameter(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'pos', 'name', 'type', 'val', 'alias', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_val') and obj.db_val is not None:
+            columnMap['val'] = \
+                self.convertToDB(obj.db_val, 'str', 'mediumtext')
+        if hasattr(obj, 'db_alias') and obj.db_alias is not None:
+            columnMap['alias'] = \
+                self.convertToDB(obj.db_alias, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'pos', 'name', 'type', 'val', 'alias', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_val') and obj.db_val is not None:
+            columnMap['val'] = \
+                self.convertToDB(obj.db_val, 'str', 'mediumtext')
+        if hasattr(obj, 'db_alias') and obj.db_alias is not None:
+            columnMap['alias'] = \
+                self.convertToDB(obj.db_alias, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBVistrailSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'vistrail'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified']
+        table = 'vistrail'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            
+            vistrail = DBVistrail(entity_type=entity_type,
+                                  version=version,
+                                  name=name,
+                                  last_modified=last_modified,
+                                  id=id)
+            vistrail.is_dirty = False
+            res[('vistrail', id)] = vistrail
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified']
+        table = 'vistrail'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            
+            vistrail = DBVistrail(entity_type=entity_type,
+                                  version=version,
+                                  name=name,
+                                  last_modified=last_modified,
+                                  id=id)
+            vistrail.is_dirty = False
+            res[('vistrail', id)] = vistrail
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        pass
+    
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified']
+        table = 'vistrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified']
+        table = 'vistrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_actions:
+            child.db_vistrail = obj.db_id
+        for child in obj.db_tags:
+            child.db_vistrail = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_controlParameters:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_vistrailVariables:
+            child.db_vistrail = obj.db_id
+        for child in obj.db_parameter_explorations:
+            child.db_vistrail = obj.db_id
+        for child in obj.db_actionAnnotations:
+            child.db_vistrail = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'vistrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBModuleSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'module'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            module = DBModule(cache=cache,
+                              name=name,
+                              namespace=namespace,
+                              package=package,
+                              version=version,
+                              id=id)
+            module.db_parentType = parentType
+            module.db_entity_id = entity_id
+            module.db_entity_type = entity_type
+            module.db_parent = parent
+            module.is_dirty = False
+            res[('module', id)] = module
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            module = DBModule(cache=cache,
+                              name=name,
+                              namespace=namespace,
+                              package=package,
+                              version=version,
+                              id=id)
+            module.db_parentType = parentType
+            module.db_entity_id = entity_id
+            module.db_entity_type = entity_type
+            module.db_parent = parent
+            module.is_dirty = False
+            res[('module', id)] = module
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_module(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_location is not None:
+            child = obj.db_location
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_functions:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_controlParameters:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_portSpecs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'module'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPortSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'port'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'type', 'moduleId', 'moduleName', 'name', 'signature', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            type = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            moduleId = self.convertFromDB(row[2], 'long', 'int')
+            moduleName = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            name = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            signature = self.convertFromDB(row[5], 'str', 'varchar(4095)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            port = DBPort(type=type,
+                          moduleId=moduleId,
+                          moduleName=moduleName,
+                          name=name,
+                          signature=signature,
+                          id=id)
+            port.db_parentType = parentType
+            port.db_entity_id = entity_id
+            port.db_entity_type = entity_type
+            port.db_parent = parent
+            port.is_dirty = False
+            res[('port', id)] = port
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'type', 'moduleId', 'moduleName', 'name', 'signature', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            type = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            moduleId = self.convertFromDB(row[2], 'long', 'int')
+            moduleName = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            name = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            signature = self.convertFromDB(row[5], 'str', 'varchar(4095)')
+            parentType = self.convertFromDB(row[6], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            parent = self.convertFromDB(row[9], 'long', 'long')
+            
+            port = DBPort(type=type,
+                          moduleId=moduleId,
+                          moduleName=moduleName,
+                          name=name,
+                          signature=signature,
+                          id=id)
+            port.db_parentType = parentType
+            port.db_entity_id = entity_id
+            port.db_entity_type = entity_type
+            port.db_parent = parent
+            port.is_dirty = False
+            res[('port', id)] = port
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'connection':
+            p = all_objects[('connection', obj.db_parent)]
+            p.db_add_port(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'type', 'moduleId', 'moduleName', 'name', 'signature', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_moduleId') and obj.db_moduleId is not None:
+            columnMap['moduleId'] = \
+                self.convertToDB(obj.db_moduleId, 'long', 'int')
+        if hasattr(obj, 'db_moduleName') and obj.db_moduleName is not None:
+            columnMap['moduleName'] = \
+                self.convertToDB(obj.db_moduleName, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_signature') and obj.db_signature is not None:
+            columnMap['signature'] = \
+                self.convertToDB(obj.db_signature, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'type', 'moduleId', 'moduleName', 'name', 'signature', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_moduleId') and obj.db_moduleId is not None:
+            columnMap['moduleId'] = \
+                self.convertToDB(obj.db_moduleId, 'long', 'int')
+        if hasattr(obj, 'db_moduleName') and obj.db_moduleName is not None:
+            columnMap['moduleName'] = \
+                self.convertToDB(obj.db_moduleName, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_signature') and obj.db_signature is not None:
+            columnMap['signature'] = \
+                self.convertToDB(obj.db_signature, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'port'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPEFunctionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'pe_function'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'module_id', 'port_name', 'is_alias', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_function'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            module_id = self.convertFromDB(row[1], 'long', 'int')
+            port_name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            is_alias = self.convertFromDB(row[3], 'long', 'int')
+            parentType = self.convertFromDB(row[4], 'str', 'char(32)')
+            parameter_exploration = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            pe_function = DBPEFunction(module_id=module_id,
+                                       port_name=port_name,
+                                       id=id)
+            pe_function.db_parentType = parentType
+            pe_function.db_parameter_exploration = parameter_exploration
+            pe_function.db_entity_id = entity_id
+            pe_function.db_entity_type = entity_type
+            pe_function.is_dirty = False
+            res[('pe_function', id)] = pe_function
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'module_id', 'port_name', 'is_alias', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_function'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            module_id = self.convertFromDB(row[1], 'long', 'int')
+            port_name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            is_alias = self.convertFromDB(row[3], 'long', 'int')
+            parentType = self.convertFromDB(row[4], 'str', 'char(32)')
+            parameter_exploration = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            pe_function = DBPEFunction(module_id=module_id,
+                                       port_name=port_name,
+                                       id=id)
+            pe_function.db_parentType = parentType
+            pe_function.db_parameter_exploration = parameter_exploration
+            pe_function.db_entity_id = entity_id
+            pe_function.db_entity_type = entity_type
+            pe_function.is_dirty = False
+            res[('pe_function', id)] = pe_function
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('parameter_exploration', obj.db_parameter_exploration) in all_objects:
+            p = all_objects[('parameter_exploration', obj.db_parameter_exploration)]
+            p.db_add_function(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'module_id', 'port_name', 'is_alias', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_port_name') and obj.db_port_name is not None:
+            columnMap['port_name'] = \
+                self.convertToDB(obj.db_port_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_is_alias') and obj.db_is_alias is not None:
+            columnMap['is_alias'] = \
+                self.convertToDB(obj.db_is_alias, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_parameter_exploration') and obj.db_parameter_exploration is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parameter_exploration, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'module_id', 'port_name', 'is_alias', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_port_name') and obj.db_port_name is not None:
+            columnMap['port_name'] = \
+                self.convertToDB(obj.db_port_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_is_alias') and obj.db_is_alias is not None:
+            columnMap['is_alias'] = \
+                self.convertToDB(obj.db_is_alias, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_parameter_exploration') and obj.db_parameter_exploration is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parameter_exploration, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_parameters:
+            child.db_pe_function = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'pe_function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBWorkflowSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'workflow'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'entity_id', 'entity_type', 'name', 'version', 'last_modified', 'vistrail_id', 'parent_id']
+        table = 'workflow'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_id = self.convertFromDB(row[1], 'long', 'int')
+            entity_type = self.convertFromDB(row[2], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[4], 'str', 'char(16)')
+            last_modified = self.convertFromDB(row[5], 'datetime', 'datetime')
+            vistrail_id = self.convertFromDB(row[6], 'long', 'int')
+            group = self.convertFromDB(row[7], 'long', 'int')
+            
+            workflow = DBWorkflow(entity_type=entity_type,
+                                  name=name,
+                                  version=version,
+                                  last_modified=last_modified,
+                                  vistrail_id=vistrail_id,
+                                  id=id)
+            workflow.db_entity_id = entity_id
+            workflow.db_group = group
+            workflow.is_dirty = False
+            res[('workflow', id)] = workflow
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'entity_id', 'entity_type', 'name', 'version', 'last_modified', 'vistrail_id', 'parent_id']
+        table = 'workflow'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_id = self.convertFromDB(row[1], 'long', 'int')
+            entity_type = self.convertFromDB(row[2], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[4], 'str', 'char(16)')
+            last_modified = self.convertFromDB(row[5], 'datetime', 'datetime')
+            vistrail_id = self.convertFromDB(row[6], 'long', 'int')
+            group = self.convertFromDB(row[7], 'long', 'int')
+            
+            workflow = DBWorkflow(entity_type=entity_type,
+                                  name=name,
+                                  version=version,
+                                  last_modified=last_modified,
+                                  vistrail_id=vistrail_id,
+                                  id=id)
+            workflow.db_entity_id = entity_id
+            workflow.db_group = group
+            workflow.is_dirty = False
+            res[('workflow', id)] = workflow
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('group', obj.db_group) in all_objects:
+            p = all_objects[('group', obj.db_group)]
+            p.db_add_workflow(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'entity_id', 'entity_type', 'name', 'version', 'last_modified', 'vistrail_id', 'parent_id']
+        table = 'workflow'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_vistrail_id') and obj.db_vistrail_id is not None:
+            columnMap['vistrail_id'] = \
+                self.convertToDB(obj.db_vistrail_id, 'long', 'int')
+        if hasattr(obj, 'db_group') and obj.db_group is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_group, 'long', 'int')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'entity_id', 'entity_type', 'name', 'version', 'last_modified', 'vistrail_id', 'parent_id']
+        table = 'workflow'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_vistrail_id') and obj.db_vistrail_id is not None:
+            columnMap['vistrail_id'] = \
+                self.convertToDB(obj.db_vistrail_id, 'long', 'int')
+        if hasattr(obj, 'db_group') and obj.db_group is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_group, 'long', 'int')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_connections:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_plugin_datas:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_others:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_modules:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'workflow'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMashupActionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashup_action'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'prev_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            prevId = self.convertFromDB(row[1], 'long', 'int')
+            date = self.convertFromDB(row[2], 'datetime', 'datetime')
+            user = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            mashuptrail = self.convertFromDB(row[4], 'long', 'int')
+            entity_id = self.convertFromDB(row[5], 'long', 'int')
+            entity_type = self.convertFromDB(row[6], 'str', 'char(16)')
+            
+            mashup_action = DBMashupAction(prevId=prevId,
+                                           date=date,
+                                           user=user,
+                                           id=id)
+            mashup_action.db_mashuptrail = mashuptrail
+            mashup_action.db_entity_id = entity_id
+            mashup_action.db_entity_type = entity_type
+            mashup_action.is_dirty = False
+            res[('mashup_action', id)] = mashup_action
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'prev_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            prevId = self.convertFromDB(row[1], 'long', 'int')
+            date = self.convertFromDB(row[2], 'datetime', 'datetime')
+            user = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            mashuptrail = self.convertFromDB(row[4], 'long', 'int')
+            entity_id = self.convertFromDB(row[5], 'long', 'int')
+            entity_type = self.convertFromDB(row[6], 'str', 'char(16)')
+            
+            mashup_action = DBMashupAction(prevId=prevId,
+                                           date=date,
+                                           user=user,
+                                           id=id)
+            mashup_action.db_mashuptrail = mashuptrail
+            mashup_action.db_entity_id = entity_id
+            mashup_action.db_entity_type = entity_type
+            mashup_action.is_dirty = False
+            res[('mashup_action', id)] = mashup_action
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('mashuptrail', obj.db_mashuptrail) in all_objects:
+            p = all_objects[('mashuptrail', obj.db_mashuptrail)]
+            p.db_add_action(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'prev_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_prevId') and obj.db_prevId is not None:
+            columnMap['prev_id'] = \
+                self.convertToDB(obj.db_prevId, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashuptrail') and obj.db_mashuptrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_mashuptrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'prev_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_prevId') and obj.db_prevId is not None:
+            columnMap['prev_id'] = \
+                self.convertToDB(obj.db_prevId, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashuptrail') and obj.db_mashuptrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_mashuptrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_mashup is not None:
+            child = obj.db_mashup
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashup_action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBChangeSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'change_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'old_obj_id', 'new_obj_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'change_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            oldObjId = self.convertFromDB(row[2], 'long', 'int')
+            newObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjId = self.convertFromDB(row[4], 'long', 'int')
+            parentObjType = self.convertFromDB(row[5], 'str', 'char(16)')
+            action = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            change = DBChange(what=what,
+                              oldObjId=oldObjId,
+                              newObjId=newObjId,
+                              parentObjId=parentObjId,
+                              parentObjType=parentObjType,
+                              id=id)
+            change.db_action = action
+            change.db_entity_id = entity_id
+            change.db_entity_type = entity_type
+            change.is_dirty = False
+            res[('change', id)] = change
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'old_obj_id', 'new_obj_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'change_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            oldObjId = self.convertFromDB(row[2], 'long', 'int')
+            newObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjId = self.convertFromDB(row[4], 'long', 'int')
+            parentObjType = self.convertFromDB(row[5], 'str', 'char(16)')
+            action = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            change = DBChange(what=what,
+                              oldObjId=oldObjId,
+                              newObjId=newObjId,
+                              parentObjId=parentObjId,
+                              parentObjType=parentObjType,
+                              id=id)
+            change.db_action = action
+            change.db_entity_id = entity_id
+            change.db_entity_type = entity_type
+            change.is_dirty = False
+            res[('change', id)] = change
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('action', obj.db_action) in all_objects:
+            p = all_objects[('action', obj.db_action)]
+            p.db_add_operation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'what', 'old_obj_id', 'new_obj_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'change_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_oldObjId') and obj.db_oldObjId is not None:
+            columnMap['old_obj_id'] = \
+                self.convertToDB(obj.db_oldObjId, 'long', 'int')
+        if hasattr(obj, 'db_newObjId') and obj.db_newObjId is not None:
+            columnMap['new_obj_id'] = \
+                self.convertToDB(obj.db_newObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'what', 'old_obj_id', 'new_obj_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'change_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_oldObjId') and obj.db_oldObjId is not None:
+            columnMap['old_obj_id'] = \
+                self.convertToDB(obj.db_oldObjId, 'long', 'int')
+        if hasattr(obj, 'db_newObjId') and obj.db_newObjId is not None:
+            columnMap['new_obj_id'] = \
+                self.convertToDB(obj.db_newObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_data is not None:
+            child = obj.db_data
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'change_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPackageSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'package'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'identifier', 'codepath', 'load_configuration', 'version', 'description', 'parent_id', 'entity_id', 'entity_type']
+        table = 'package'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            identifier = self.convertFromDB(row[2], 'str', 'varchar(1023)')
+            codepath = self.convertFromDB(row[3], 'str', 'varchar(1023)')
+            load_configuration = self.convertFromDB(row[4], 'int', 'int')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            description = self.convertFromDB(row[6], 'str', 'varchar(1023)')
+            registry = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            package = DBPackage(name=name,
+                                identifier=identifier,
+                                codepath=codepath,
+                                load_configuration=load_configuration,
+                                version=version,
+                                description=description,
+                                id=id)
+            package.db_registry = registry
+            package.db_entity_id = entity_id
+            package.db_entity_type = entity_type
+            package.is_dirty = False
+            res[('package', id)] = package
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'identifier', 'codepath', 'load_configuration', 'version', 'description', 'parent_id', 'entity_id', 'entity_type']
+        table = 'package'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            identifier = self.convertFromDB(row[2], 'str', 'varchar(1023)')
+            codepath = self.convertFromDB(row[3], 'str', 'varchar(1023)')
+            load_configuration = self.convertFromDB(row[4], 'int', 'int')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            description = self.convertFromDB(row[6], 'str', 'varchar(1023)')
+            registry = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            package = DBPackage(name=name,
+                                identifier=identifier,
+                                codepath=codepath,
+                                load_configuration=load_configuration,
+                                version=version,
+                                description=description,
+                                id=id)
+            package.db_registry = registry
+            package.db_entity_id = entity_id
+            package.db_entity_type = entity_type
+            package.is_dirty = False
+            res[('package', id)] = package
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('registry', obj.db_registry) in all_objects:
+            p = all_objects[('registry', obj.db_registry)]
+            p.db_add_package(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'identifier', 'codepath', 'load_configuration', 'version', 'description', 'parent_id', 'entity_id', 'entity_type']
+        table = 'package'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_identifier') and obj.db_identifier is not None:
+            columnMap['identifier'] = \
+                self.convertToDB(obj.db_identifier, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_codepath') and obj.db_codepath is not None:
+            columnMap['codepath'] = \
+                self.convertToDB(obj.db_codepath, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_load_configuration') and obj.db_load_configuration is not None:
+            columnMap['load_configuration'] = \
+                self.convertToDB(obj.db_load_configuration, 'int', 'int')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_description') and obj.db_description is not None:
+            columnMap['description'] = \
+                self.convertToDB(obj.db_description, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_registry') and obj.db_registry is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_registry, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'identifier', 'codepath', 'load_configuration', 'version', 'description', 'parent_id', 'entity_id', 'entity_type']
+        table = 'package'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_identifier') and obj.db_identifier is not None:
+            columnMap['identifier'] = \
+                self.convertToDB(obj.db_identifier, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_codepath') and obj.db_codepath is not None:
+            columnMap['codepath'] = \
+                self.convertToDB(obj.db_codepath, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_load_configuration') and obj.db_load_configuration is not None:
+            columnMap['load_configuration'] = \
+                self.convertToDB(obj.db_load_configuration, 'int', 'int')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_description') and obj.db_description is not None:
+            columnMap['description'] = \
+                self.convertToDB(obj.db_description, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_registry') and obj.db_registry is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_registry, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_module_descriptors:
+            child.db_package = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'package'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBLoopExecSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'loop_exec'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'loop_exec'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            loop_exec = DBLoopExec(ts_start=ts_start,
+                                   ts_end=ts_end,
+                                   id=id)
+            loop_exec.db_parentType = parentType
+            loop_exec.db_entity_id = entity_id
+            loop_exec.db_entity_type = entity_type
+            loop_exec.db_parent = parent
+            loop_exec.is_dirty = False
+            res[('loop_exec', id)] = loop_exec
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'loop_exec'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            loop_exec = DBLoopExec(ts_start=ts_start,
+                                   ts_end=ts_end,
+                                   id=id)
+            loop_exec.db_parentType = parentType
+            loop_exec.db_entity_id = entity_id
+            loop_exec.db_entity_type = entity_type
+            loop_exec.db_parent = parent
+            loop_exec.is_dirty = False
+            res[('loop_exec', id)] = loop_exec
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow_exec':
+            p = all_objects[('workflow_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'group_exec':
+            p = all_objects[('group_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'module_exec':
+            p = all_objects[('module_exec', obj.db_parent)]
+            p.db_add_loop_exec(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'ts_start', 'ts_end', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'loop_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'ts_start', 'ts_end', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'loop_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_loop_iterations:
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'loop_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBConnectionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'connection_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'connection_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            parentType = self.convertFromDB(row[1], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[2], 'long', 'int')
+            entity_type = self.convertFromDB(row[3], 'str', 'char(16)')
+            parent = self.convertFromDB(row[4], 'long', 'long')
+            
+            connection = DBConnection(id=id)
+            connection.db_parentType = parentType
+            connection.db_entity_id = entity_id
+            connection.db_entity_type = entity_type
+            connection.db_parent = parent
+            connection.is_dirty = False
+            res[('connection', id)] = connection
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'connection_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            parentType = self.convertFromDB(row[1], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[2], 'long', 'int')
+            entity_type = self.convertFromDB(row[3], 'str', 'char(16)')
+            parent = self.convertFromDB(row[4], 'long', 'long')
+            
+            connection = DBConnection(id=id)
+            connection.db_parentType = parentType
+            connection.db_entity_id = entity_id
+            connection.db_entity_type = entity_type
+            connection.db_parent = parent
+            connection.is_dirty = False
+            res[('connection', id)] = connection
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_connection(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'connection_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'connection_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_ports:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'connection_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBActionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'action'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'prev_id', 'date', 'session', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            prevId = self.convertFromDB(row[1], 'long', 'int')
+            date = self.convertFromDB(row[2], 'datetime', 'datetime')
+            session = self.convertFromDB(row[3], 'long', 'int')
+            user = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            action = DBAction(prevId=prevId,
+                              date=date,
+                              session=session,
+                              user=user,
+                              id=id)
+            action.db_vistrail = vistrail
+            action.db_entity_id = entity_id
+            action.db_entity_type = entity_type
+            action.is_dirty = False
+            res[('action', id)] = action
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'prev_id', 'date', 'session', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            prevId = self.convertFromDB(row[1], 'long', 'int')
+            date = self.convertFromDB(row[2], 'datetime', 'datetime')
+            session = self.convertFromDB(row[3], 'long', 'int')
+            user = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            action = DBAction(prevId=prevId,
+                              date=date,
+                              session=session,
+                              user=user,
+                              id=id)
+            action.db_vistrail = vistrail
+            action.db_entity_id = entity_id
+            action.db_entity_type = entity_type
+            action.is_dirty = False
+            res[('action', id)] = action
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('vistrail', obj.db_vistrail) in all_objects:
+            p = all_objects[('vistrail', obj.db_vistrail)]
+            p.db_add_action(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'prev_id', 'date', 'session', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_prevId') and obj.db_prevId is not None:
+            columnMap['prev_id'] = \
+                self.convertToDB(obj.db_prevId, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_session') and obj.db_session is not None:
+            columnMap['session'] = \
+                self.convertToDB(obj.db_session, 'long', 'int')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'prev_id', 'date', 'session', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_prevId') and obj.db_prevId is not None:
+            columnMap['prev_id'] = \
+                self.convertToDB(obj.db_prevId, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_session') and obj.db_session is not None:
+            columnMap['session'] = \
+                self.convertToDB(obj.db_session, 'long', 'int')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_operations:
+            child.db_action = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'action'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPortSpecSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'port_spec'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'type', 'optional', 'depth', 'union', 'sort_key', 'min_conns', 'max_conns', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port_spec'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            type = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            optional = self.convertFromDB(row[3], 'int', 'int')
+            depth = self.convertFromDB(row[4], 'int', 'int')
+            union = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            sort_key = self.convertFromDB(row[6], 'int', 'int')
+            min_conns = self.convertFromDB(row[7], 'int', 'int')
+            max_conns = self.convertFromDB(row[8], 'int', 'int')
+            parentType = self.convertFromDB(row[9], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            parent = self.convertFromDB(row[12], 'long', 'long')
+            
+            portSpec = DBPortSpec(name=name,
+                                  type=type,
+                                  optional=optional,
+                                  depth=depth,
+                                  union=union,
+                                  sort_key=sort_key,
+                                  min_conns=min_conns,
+                                  max_conns=max_conns,
+                                  id=id)
+            portSpec.db_parentType = parentType
+            portSpec.db_entity_id = entity_id
+            portSpec.db_entity_type = entity_type
+            portSpec.db_parent = parent
+            portSpec.is_dirty = False
+            res[('portSpec', id)] = portSpec
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'type', 'optional', 'depth', 'union', 'sort_key', 'min_conns', 'max_conns', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port_spec'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            type = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            optional = self.convertFromDB(row[3], 'int', 'int')
+            depth = self.convertFromDB(row[4], 'int', 'int')
+            union = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            sort_key = self.convertFromDB(row[6], 'int', 'int')
+            min_conns = self.convertFromDB(row[7], 'int', 'int')
+            max_conns = self.convertFromDB(row[8], 'int', 'int')
+            parentType = self.convertFromDB(row[9], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            parent = self.convertFromDB(row[12], 'long', 'long')
+            
+            portSpec = DBPortSpec(name=name,
+                                  type=type,
+                                  optional=optional,
+                                  depth=depth,
+                                  union=union,
+                                  sort_key=sort_key,
+                                  min_conns=min_conns,
+                                  max_conns=max_conns,
+                                  id=id)
+            portSpec.db_parentType = parentType
+            portSpec.db_entity_id = entity_id
+            portSpec.db_entity_type = entity_type
+            portSpec.db_parent = parent
+            portSpec.is_dirty = False
+            res[('portSpec', id)] = portSpec
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'module':
+            p = all_objects[('module', obj.db_parent)]
+            p.db_add_portSpec(obj)
+        elif obj.db_parentType == 'module_descriptor':
+            p = all_objects[('module_descriptor', obj.db_parent)]
+            p.db_add_portSpec(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'type', 'optional', 'depth', 'union', 'sort_key', 'min_conns', 'max_conns', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port_spec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_optional') and obj.db_optional is not None:
+            columnMap['optional'] = \
+                self.convertToDB(obj.db_optional, 'int', 'int')
+        if hasattr(obj, 'db_depth') and obj.db_depth is not None:
+            columnMap['depth'] = \
+                self.convertToDB(obj.db_depth, 'int', 'int')
+        if hasattr(obj, 'db_union') and obj.db_union is not None:
+            columnMap['union'] = \
+                self.convertToDB(obj.db_union, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_sort_key') and obj.db_sort_key is not None:
+            columnMap['sort_key'] = \
+                self.convertToDB(obj.db_sort_key, 'int', 'int')
+        if hasattr(obj, 'db_min_conns') and obj.db_min_conns is not None:
+            columnMap['min_conns'] = \
+                self.convertToDB(obj.db_min_conns, 'int', 'int')
+        if hasattr(obj, 'db_max_conns') and obj.db_max_conns is not None:
+            columnMap['max_conns'] = \
+                self.convertToDB(obj.db_max_conns, 'int', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'type', 'optional', 'depth', 'union', 'sort_key', 'min_conns', 'max_conns', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'port_spec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_optional') and obj.db_optional is not None:
+            columnMap['optional'] = \
+                self.convertToDB(obj.db_optional, 'int', 'int')
+        if hasattr(obj, 'db_depth') and obj.db_depth is not None:
+            columnMap['depth'] = \
+                self.convertToDB(obj.db_depth, 'int', 'int')
+        if hasattr(obj, 'db_union') and obj.db_union is not None:
+            columnMap['union'] = \
+                self.convertToDB(obj.db_union, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_sort_key') and obj.db_sort_key is not None:
+            columnMap['sort_key'] = \
+                self.convertToDB(obj.db_sort_key, 'int', 'int')
+        if hasattr(obj, 'db_min_conns') and obj.db_min_conns is not None:
+            columnMap['min_conns'] = \
+                self.convertToDB(obj.db_min_conns, 'int', 'int')
+        if hasattr(obj, 'db_max_conns') and obj.db_max_conns is not None:
+            columnMap['max_conns'] = \
+                self.convertToDB(obj.db_max_conns, 'int', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_portSpecItems:
+            child.db_portSpec = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'port_spec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBLogSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'log_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified', 'vistrail_id']
+        table = 'log_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            vistrail_id = self.convertFromDB(row[5], 'long', 'int')
+            
+            log = DBLog(entity_type=entity_type,
+                        version=version,
+                        name=name,
+                        last_modified=last_modified,
+                        vistrail_id=vistrail_id,
+                        id=id)
+            log.is_dirty = False
+            res[('log', id)] = log
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified', 'vistrail_id']
+        table = 'log_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            name = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            vistrail_id = self.convertFromDB(row[5], 'long', 'int')
+            
+            log = DBLog(entity_type=entity_type,
+                        version=version,
+                        name=name,
+                        last_modified=last_modified,
+                        vistrail_id=vistrail_id,
+                        id=id)
+            log.is_dirty = False
+            res[('log', id)] = log
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        pass
+    
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified', 'vistrail_id']
+        table = 'log_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_vistrail_id') and obj.db_vistrail_id is not None:
+            columnMap['vistrail_id'] = \
+                self.convertToDB(obj.db_vistrail_id, 'long', 'int')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'entity_type', 'version', 'name', 'last_modified', 'vistrail_id']
+        table = 'log_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_vistrail_id') and obj.db_vistrail_id is not None:
+            columnMap['vistrail_id'] = \
+                self.convertToDB(obj.db_vistrail_id, 'long', 'int')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_workflow_execs:
+            child.db_log = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'log_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBLoopIterationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'loop_iteration'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'iteration', 'completed', 'error', 'parent_id', 'entity_id', 'entity_type']
+        table = 'loop_iteration'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            iteration = self.convertFromDB(row[3], 'int', 'int')
+            completed = self.convertFromDB(row[4], 'int', 'int')
+            error = self.convertFromDB(row[5], 'str', 'varchar(1023)')
+            parent = self.convertFromDB(row[6], 'str', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            loop_iteration = DBLoopIteration(ts_start=ts_start,
+                                             ts_end=ts_end,
+                                             iteration=iteration,
+                                             completed=completed,
+                                             error=error,
+                                             id=id)
+            loop_iteration.db_parent = parent
+            loop_iteration.db_entity_id = entity_id
+            loop_iteration.db_entity_type = entity_type
+            loop_iteration.is_dirty = False
+            res[('loop_iteration', id)] = loop_iteration
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'iteration', 'completed', 'error', 'parent_id', 'entity_id', 'entity_type']
+        table = 'loop_iteration'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            iteration = self.convertFromDB(row[3], 'int', 'int')
+            completed = self.convertFromDB(row[4], 'int', 'int')
+            error = self.convertFromDB(row[5], 'str', 'varchar(1023)')
+            parent = self.convertFromDB(row[6], 'str', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            loop_iteration = DBLoopIteration(ts_start=ts_start,
+                                             ts_end=ts_end,
+                                             iteration=iteration,
+                                             completed=completed,
+                                             error=error,
+                                             id=id)
+            loop_iteration.db_parent = parent
+            loop_iteration.db_entity_id = entity_id
+            loop_iteration.db_entity_type = entity_type
+            loop_iteration.is_dirty = False
+            res[('loop_iteration', id)] = loop_iteration
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('loop_exec', obj.db_parent) in all_objects:
+            p = all_objects[('loop_exec', obj.db_parent)]
+            p.db_add_loop_iteration(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'ts_start', 'ts_end', 'iteration', 'completed', 'error', 'parent_id', 'entity_id', 'entity_type']
+        table = 'loop_iteration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_iteration') and obj.db_iteration is not None:
+            columnMap['iteration'] = \
+                self.convertToDB(obj.db_iteration, 'int', 'int')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'str', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'ts_start', 'ts_end', 'iteration', 'completed', 'error', 'parent_id', 'entity_id', 'entity_type']
+        table = 'loop_iteration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_iteration') and obj.db_iteration is not None:
+            columnMap['iteration'] = \
+                self.convertToDB(obj.db_iteration, 'int', 'int')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'str', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_item_execs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'loop_iteration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPEParameterSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'pe_parameter'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'interpolator', 'value', 'dimension', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_parameter'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            interpolator = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[3], 'str', 'mediumtext')
+            dimension = self.convertFromDB(row[4], 'long', 'int')
+            parentType = self.convertFromDB(row[5], 'str', 'char(32)')
+            pe_function = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            pe_parameter = DBPEParameter(pos=pos,
+                                         interpolator=interpolator,
+                                         value=value,
+                                         dimension=dimension,
+                                         id=id)
+            pe_parameter.db_parentType = parentType
+            pe_parameter.db_pe_function = pe_function
+            pe_parameter.db_entity_id = entity_id
+            pe_parameter.db_entity_type = entity_type
+            pe_parameter.is_dirty = False
+            res[('pe_parameter', id)] = pe_parameter
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'interpolator', 'value', 'dimension', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_parameter'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            interpolator = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[3], 'str', 'mediumtext')
+            dimension = self.convertFromDB(row[4], 'long', 'int')
+            parentType = self.convertFromDB(row[5], 'str', 'char(32)')
+            pe_function = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            pe_parameter = DBPEParameter(pos=pos,
+                                         interpolator=interpolator,
+                                         value=value,
+                                         dimension=dimension,
+                                         id=id)
+            pe_parameter.db_parentType = parentType
+            pe_parameter.db_pe_function = pe_function
+            pe_parameter.db_entity_id = entity_id
+            pe_parameter.db_entity_type = entity_type
+            pe_parameter.is_dirty = False
+            res[('pe_parameter', id)] = pe_parameter
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('pe_function', obj.db_pe_function) in all_objects:
+            p = all_objects[('pe_function', obj.db_pe_function)]
+            p.db_add_parameter(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'pos', 'interpolator', 'value', 'dimension', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_interpolator') and obj.db_interpolator is not None:
+            columnMap['interpolator'] = \
+                self.convertToDB(obj.db_interpolator, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_dimension') and obj.db_dimension is not None:
+            columnMap['dimension'] = \
+                self.convertToDB(obj.db_dimension, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_pe_function') and obj.db_pe_function is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_pe_function, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'pos', 'interpolator', 'value', 'dimension', 'parent_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'pe_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_interpolator') and obj.db_interpolator is not None:
+            columnMap['interpolator'] = \
+                self.convertToDB(obj.db_interpolator, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_dimension') and obj.db_dimension is not None:
+            columnMap['dimension'] = \
+                self.convertToDB(obj.db_dimension, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_pe_function') and obj.db_pe_function is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_pe_function, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'pe_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBWorkflowExecSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'workflow_exec'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'user', 'ip', 'session', 'vt_version', 'ts_start', 'ts_end', 'parent_id', 'parent_type', 'parent_version', 'completed', 'name', 'log_id', 'entity_id', 'entity_type']
+        table = 'workflow_exec'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            user = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            ip = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            session = self.convertFromDB(row[3], 'long', 'int')
+            vt_version = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            ts_start = self.convertFromDB(row[5], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[6], 'datetime', 'datetime')
+            parent_id = self.convertFromDB(row[7], 'long', 'int')
+            parent_type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            parent_version = self.convertFromDB(row[9], 'long', 'int')
+            completed = self.convertFromDB(row[10], 'int', 'int')
+            name = self.convertFromDB(row[11], 'str', 'varchar(255)')
+            log = self.convertFromDB(row[12], 'long', 'int')
+            entity_id = self.convertFromDB(row[13], 'long', 'int')
+            entity_type = self.convertFromDB(row[14], 'str', 'char(16)')
+            
+            workflow_exec = DBWorkflowExec(user=user,
+                                           ip=ip,
+                                           session=session,
+                                           vt_version=vt_version,
+                                           ts_start=ts_start,
+                                           ts_end=ts_end,
+                                           parent_id=parent_id,
+                                           parent_type=parent_type,
+                                           parent_version=parent_version,
+                                           completed=completed,
+                                           name=name,
+                                           id=id)
+            workflow_exec.db_log = log
+            workflow_exec.db_entity_id = entity_id
+            workflow_exec.db_entity_type = entity_type
+            workflow_exec.is_dirty = False
+            res[('workflow_exec', id)] = workflow_exec
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'user', 'ip', 'session', 'vt_version', 'ts_start', 'ts_end', 'parent_id', 'parent_type', 'parent_version', 'completed', 'name', 'log_id', 'entity_id', 'entity_type']
+        table = 'workflow_exec'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            user = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            ip = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            session = self.convertFromDB(row[3], 'long', 'int')
+            vt_version = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            ts_start = self.convertFromDB(row[5], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[6], 'datetime', 'datetime')
+            parent_id = self.convertFromDB(row[7], 'long', 'int')
+            parent_type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            parent_version = self.convertFromDB(row[9], 'long', 'int')
+            completed = self.convertFromDB(row[10], 'int', 'int')
+            name = self.convertFromDB(row[11], 'str', 'varchar(255)')
+            log = self.convertFromDB(row[12], 'long', 'int')
+            entity_id = self.convertFromDB(row[13], 'long', 'int')
+            entity_type = self.convertFromDB(row[14], 'str', 'char(16)')
+            
+            workflow_exec = DBWorkflowExec(user=user,
+                                           ip=ip,
+                                           session=session,
+                                           vt_version=vt_version,
+                                           ts_start=ts_start,
+                                           ts_end=ts_end,
+                                           parent_id=parent_id,
+                                           parent_type=parent_type,
+                                           parent_version=parent_version,
+                                           completed=completed,
+                                           name=name,
+                                           id=id)
+            workflow_exec.db_log = log
+            workflow_exec.db_entity_id = entity_id
+            workflow_exec.db_entity_type = entity_type
+            workflow_exec.is_dirty = False
+            res[('workflow_exec', id)] = workflow_exec
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('log', obj.db_log) in all_objects:
+            p = all_objects[('log', obj.db_log)]
+            p.db_add_workflow_exec(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'user', 'ip', 'session', 'vt_version', 'ts_start', 'ts_end', 'parent_id', 'parent_type', 'parent_version', 'completed', 'name', 'log_id', 'entity_id', 'entity_type']
+        table = 'workflow_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ip') and obj.db_ip is not None:
+            columnMap['ip'] = \
+                self.convertToDB(obj.db_ip, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_session') and obj.db_session is not None:
+            columnMap['session'] = \
+                self.convertToDB(obj.db_session, 'long', 'int')
+        if hasattr(obj, 'db_vt_version') and obj.db_vt_version is not None:
+            columnMap['vt_version'] = \
+                self.convertToDB(obj.db_vt_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_parent_id') and obj.db_parent_id is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent_id, 'long', 'int')
+        if hasattr(obj, 'db_parent_type') and obj.db_parent_type is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parent_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parent_version') and obj.db_parent_version is not None:
+            columnMap['parent_version'] = \
+                self.convertToDB(obj.db_parent_version, 'long', 'int')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_log') and obj.db_log is not None:
+            columnMap['log_id'] = \
+                self.convertToDB(obj.db_log, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'user', 'ip', 'session', 'vt_version', 'ts_start', 'ts_end', 'parent_id', 'parent_type', 'parent_version', 'completed', 'name', 'log_id', 'entity_id', 'entity_type']
+        table = 'workflow_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ip') and obj.db_ip is not None:
+            columnMap['ip'] = \
+                self.convertToDB(obj.db_ip, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_session') and obj.db_session is not None:
+            columnMap['session'] = \
+                self.convertToDB(obj.db_session, 'long', 'int')
+        if hasattr(obj, 'db_vt_version') and obj.db_vt_version is not None:
+            columnMap['vt_version'] = \
+                self.convertToDB(obj.db_vt_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_parent_id') and obj.db_parent_id is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent_id, 'long', 'int')
+        if hasattr(obj, 'db_parent_type') and obj.db_parent_type is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parent_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parent_version') and obj.db_parent_version is not None:
+            columnMap['parent_version'] = \
+                self.convertToDB(obj.db_parent_version, 'long', 'int')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_log') and obj.db_log is not None:
+            columnMap['log_id'] = \
+                self.convertToDB(obj.db_log, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_machines:
+            child.db_workflow_exec = obj.db_id
+        for child in obj.db_item_execs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'workflow_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBLocationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'location'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'x', 'y', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'location'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            x = self.convertFromDB(row[1], 'float', 'DECIMAL(18,12)')
+            y = self.convertFromDB(row[2], 'float', 'DECIMAL(18,12)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            location = DBLocation(x=x,
+                                  y=y,
+                                  id=id)
+            location.db_parentType = parentType
+            location.db_entity_id = entity_id
+            location.db_entity_type = entity_type
+            location.db_parent = parent
+            location.is_dirty = False
+            res[('location', id)] = location
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'x', 'y', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'location'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            x = self.convertFromDB(row[1], 'float', 'DECIMAL(18,12)')
+            y = self.convertFromDB(row[2], 'float', 'DECIMAL(18,12)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            location = DBLocation(x=x,
+                                  y=y,
+                                  id=id)
+            location.db_parentType = parentType
+            location.db_entity_id = entity_id
+            location.db_entity_type = entity_type
+            location.db_parent = parent
+            location.is_dirty = False
+            res[('location', id)] = location
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'module':
+            p = all_objects[('module', obj.db_parent)]
+            p.db_add_location(obj)
+        elif obj.db_parentType == 'abstraction':
+            p = all_objects[('abstraction', obj.db_parent)]
+            p.db_add_location(obj)
+        elif obj.db_parentType == 'group':
+            p = all_objects[('group', obj.db_parent)]
+            p.db_add_location(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'x', 'y', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'location'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_x') and obj.db_x is not None:
+            columnMap['x'] = \
+                self.convertToDB(obj.db_x, 'float', 'DECIMAL(18,12)')
+        if hasattr(obj, 'db_y') and obj.db_y is not None:
+            columnMap['y'] = \
+                self.convertToDB(obj.db_y, 'float', 'DECIMAL(18,12)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'x', 'y', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'location'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_x') and obj.db_x is not None:
+            columnMap['x'] = \
+                self.convertToDB(obj.db_x, 'float', 'DECIMAL(18,12)')
+        if hasattr(obj, 'db_y') and obj.db_y is not None:
+            columnMap['y'] = \
+                self.convertToDB(obj.db_y, 'float', 'DECIMAL(18,12)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'location'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBFunctionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'function'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'name', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'function'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            function = DBFunction(pos=pos,
+                                  name=name,
+                                  id=id)
+            function.db_parentType = parentType
+            function.db_entity_id = entity_id
+            function.db_entity_type = entity_type
+            function.db_parent = parent
+            function.is_dirty = False
+            res[('function', id)] = function
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'name', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'function'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            function = DBFunction(pos=pos,
+                                  name=name,
+                                  id=id)
+            function.db_parentType = parentType
+            function.db_entity_id = entity_id
+            function.db_entity_type = entity_type
+            function.db_parent = parent
+            function.is_dirty = False
+            res[('function', id)] = function
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'module':
+            p = all_objects[('module', obj.db_parent)]
+            p.db_add_function(obj)
+        elif obj.db_parentType == 'abstraction':
+            p = all_objects[('abstraction', obj.db_parent)]
+            p.db_add_function(obj)
+        elif obj.db_parentType == 'group':
+            p = all_objects[('group', obj.db_parent)]
+            p.db_add_function(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'pos', 'name', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'pos', 'name', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_parameters:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'function'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBActionAnnotationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'action_annotation'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action_annotation'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(8191)')
+            action_id = self.convertFromDB(row[3], 'long', 'int')
+            date = self.convertFromDB(row[4], 'datetime', 'datetime')
+            user = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            actionAnnotation = DBActionAnnotation(key=key,
+                                                  value=value,
+                                                  action_id=action_id,
+                                                  date=date,
+                                                  user=user,
+                                                  id=id)
+            actionAnnotation.db_vistrail = vistrail
+            actionAnnotation.db_entity_id = entity_id
+            actionAnnotation.db_entity_type = entity_type
+            actionAnnotation.is_dirty = False
+            res[('actionAnnotation', id)] = actionAnnotation
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action_annotation'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(8191)')
+            action_id = self.convertFromDB(row[3], 'long', 'int')
+            date = self.convertFromDB(row[4], 'datetime', 'datetime')
+            user = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            actionAnnotation = DBActionAnnotation(key=key,
+                                                  value=value,
+                                                  action_id=action_id,
+                                                  date=date,
+                                                  user=user,
+                                                  id=id)
+            actionAnnotation.db_vistrail = vistrail
+            actionAnnotation.db_entity_id = entity_id
+            actionAnnotation.db_entity_type = entity_type
+            actionAnnotation.is_dirty = False
+            res[('actionAnnotation', id)] = actionAnnotation
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('vistrail', obj.db_vistrail) in all_objects:
+            p = all_objects[('vistrail', obj.db_vistrail)]
+            p.db_add_actionAnnotation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBControlParameterSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'control_parameter'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'control_parameter'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'mediumtext')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            controlParameter = DBControlParameter(name=name,
+                                                  value=value,
+                                                  id=id)
+            controlParameter.db_parentType = parentType
+            controlParameter.db_entity_id = entity_id
+            controlParameter.db_entity_type = entity_type
+            controlParameter.db_parent = parent
+            controlParameter.is_dirty = False
+            res[('controlParameter', id)] = controlParameter
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'control_parameter'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'mediumtext')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            controlParameter = DBControlParameter(name=name,
+                                                  value=value,
+                                                  id=id)
+            controlParameter.db_parentType = parentType
+            controlParameter.db_entity_id = entity_id
+            controlParameter.db_entity_type = entity_type
+            controlParameter.db_parent = parent
+            controlParameter.is_dirty = False
+            res[('controlParameter', id)] = controlParameter
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'vistrail':
+            p = all_objects[('vistrail', obj.db_parent)]
+            p.db_add_controlParameter(obj)
+        elif obj.db_parentType == 'module':
+            p = all_objects[('module', obj.db_parent)]
+            p.db_add_controlParameter(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'abstraction':
+            p = all_objects[('abstraction', obj.db_parent)]
+            p.db_add_controlParameter(obj)
+        elif obj.db_parentType == 'group':
+            p = all_objects[('group', obj.db_parent)]
+            p.db_add_controlParameter(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'control_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'control_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'control_parameter'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPluginDataSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'plugin_data'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'data', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'plugin_data'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            data = self.convertFromDB(row[1], 'str', 'varchar(8191)')
+            parentType = self.convertFromDB(row[2], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            parent = self.convertFromDB(row[5], 'long', 'long')
+            
+            plugin_data = DBPluginData(data=data,
+                                       id=id)
+            plugin_data.db_parentType = parentType
+            plugin_data.db_entity_id = entity_id
+            plugin_data.db_entity_type = entity_type
+            plugin_data.db_parent = parent
+            plugin_data.is_dirty = False
+            res[('plugin_data', id)] = plugin_data
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'data', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'plugin_data'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            data = self.convertFromDB(row[1], 'str', 'varchar(8191)')
+            parentType = self.convertFromDB(row[2], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            parent = self.convertFromDB(row[5], 'long', 'long')
+            
+            plugin_data = DBPluginData(data=data,
+                                       id=id)
+            plugin_data.db_parentType = parentType
+            plugin_data.db_entity_id = entity_id
+            plugin_data.db_entity_type = entity_type
+            plugin_data.db_parent = parent
+            plugin_data.is_dirty = False
+            res[('plugin_data', id)] = plugin_data
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_plugin_data(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'data', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'plugin_data'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_data') and obj.db_data is not None:
+            columnMap['data'] = \
+                self.convertToDB(obj.db_data, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'data', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'plugin_data'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_data') and obj.db_data is not None:
+            columnMap['data'] = \
+                self.convertToDB(obj.db_data, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'plugin_data'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBDeleteSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'delete_tbl'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'delete_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            objectId = self.convertFromDB(row[2], 'long', 'int')
+            parentObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjType = self.convertFromDB(row[4], 'str', 'char(16)')
+            action = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            delete = DBDelete(what=what,
+                              objectId=objectId,
+                              parentObjId=parentObjId,
+                              parentObjType=parentObjType,
+                              id=id)
+            delete.db_action = action
+            delete.db_entity_id = entity_id
+            delete.db_entity_type = entity_type
+            delete.is_dirty = False
+            res[('delete', id)] = delete
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'delete_tbl'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            what = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            objectId = self.convertFromDB(row[2], 'long', 'int')
+            parentObjId = self.convertFromDB(row[3], 'long', 'int')
+            parentObjType = self.convertFromDB(row[4], 'str', 'char(16)')
+            action = self.convertFromDB(row[5], 'long', 'int')
+            entity_id = self.convertFromDB(row[6], 'long', 'int')
+            entity_type = self.convertFromDB(row[7], 'str', 'char(16)')
+            
+            delete = DBDelete(what=what,
+                              objectId=objectId,
+                              parentObjId=parentObjId,
+                              parentObjType=parentObjType,
+                              id=id)
+            delete.db_action = action
+            delete.db_entity_id = entity_id
+            delete.db_entity_type = entity_type
+            delete.is_dirty = False
+            res[('delete', id)] = delete
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('action', obj.db_action) in all_objects:
+            p = all_objects[('action', obj.db_action)]
+            p.db_add_operation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'delete_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_objectId') and obj.db_objectId is not None:
+            columnMap['object_id'] = \
+                self.convertToDB(obj.db_objectId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'what', 'object_id', 'par_obj_id', 'par_obj_type', 'action_id', 'entity_id', 'entity_type']
+        table = 'delete_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_what') and obj.db_what is not None:
+            columnMap['what'] = \
+                self.convertToDB(obj.db_what, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_objectId') and obj.db_objectId is not None:
+            columnMap['object_id'] = \
+                self.convertToDB(obj.db_objectId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjId') and obj.db_parentObjId is not None:
+            columnMap['par_obj_id'] = \
+                self.convertToDB(obj.db_parentObjId, 'long', 'int')
+        if hasattr(obj, 'db_parentObjType') and obj.db_parentObjType is not None:
+            columnMap['par_obj_type'] = \
+                self.convertToDB(obj.db_parentObjType, 'str', 'char(16)')
+        if hasattr(obj, 'db_action') and obj.db_action is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'delete_tbl'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBVistrailVariableSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'vistrail_variable'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['name', 'uuid', 'package', 'module', 'namespace', 'value', 'parent_id', 'entity_id', 'entity_type']
+        table = 'vistrail_variable'
+        whereMap = global_props
+        orderBy = 'name'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            name = self.convertFromDB(row[0], 'str', 'varchar(255)')
+            uuid = self.convertFromDB(row[1], 'str', 'char(36)')
+            package = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            module = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[5], 'str', 'varchar(8191)')
+            vistrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            vistrailVariable = DBVistrailVariable(uuid=uuid,
+                                                  package=package,
+                                                  module=module,
+                                                  namespace=namespace,
+                                                  value=value,
+                                                  name=name)
+            vistrailVariable.db_vistrail = vistrail
+            vistrailVariable.db_entity_id = entity_id
+            vistrailVariable.db_entity_type = entity_type
+            vistrailVariable.is_dirty = False
+            res[('vistrailVariable', name)] = vistrailVariable
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['name', 'uuid', 'package', 'module', 'namespace', 'value', 'parent_id', 'entity_id', 'entity_type']
+        table = 'vistrail_variable'
+        whereMap = global_props
+        orderBy = 'name'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            name = self.convertFromDB(row[0], 'str', 'varchar(255)')
+            uuid = self.convertFromDB(row[1], 'str', 'char(36)')
+            package = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            module = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[5], 'str', 'varchar(8191)')
+            vistrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            vistrailVariable = DBVistrailVariable(uuid=uuid,
+                                                  package=package,
+                                                  module=module,
+                                                  namespace=namespace,
+                                                  value=value,
+                                                  name=name)
+            vistrailVariable.db_vistrail = vistrail
+            vistrailVariable.db_entity_id = entity_id
+            vistrailVariable.db_entity_type = entity_type
+            vistrailVariable.is_dirty = False
+            res[('vistrailVariable', name)] = vistrailVariable
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('vistrail', obj.db_vistrail) in all_objects:
+            p = all_objects[('vistrail', obj.db_vistrail)]
+            p.db_add_vistrailVariable(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['name', 'uuid', 'package', 'module', 'namespace', 'value', 'parent_id', 'entity_id', 'entity_type']
+        table = 'vistrail_variable'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_name is not None:
+            keyStr = self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+            whereMap['name'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_uuid') and obj.db_uuid is not None:
+            columnMap['uuid'] = \
+                self.convertToDB(obj.db_uuid, 'str', 'char(36)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_module') and obj.db_module is not None:
+            columnMap['module'] = \
+                self.convertToDB(obj.db_module, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['name', 'uuid', 'package', 'module', 'namespace', 'value', 'parent_id', 'entity_id', 'entity_type']
+        table = 'vistrail_variable'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_name is not None:
+            keyStr = self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+            whereMap['name'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_uuid') and obj.db_uuid is not None:
+            columnMap['uuid'] = \
+                self.convertToDB(obj.db_uuid, 'str', 'char(36)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_module') and obj.db_module is not None:
+            columnMap['module'] = \
+                self.convertToDB(obj.db_module, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'vistrail_variable'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_name is not None:
+            keyStr = self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+            whereMap['name'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBModuleDescriptorSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'module_descriptor'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'package', 'namespace', 'package_version', 'version', 'base_descriptor_id', 'parent_id', 'entity_id', 'entity_type']
+        table = 'module_descriptor'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package_version = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            base_descriptor_id = self.convertFromDB(row[6], 'long', 'int')
+            package = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            module_descriptor = DBModuleDescriptor(name=name,
+                                                   package=package,
+                                                   namespace=namespace,
+                                                   package_version=package_version,
+                                                   version=version,
+                                                   base_descriptor_id=base_descriptor_id,
+                                                   id=id)
+            module_descriptor.db_package = package
+            module_descriptor.db_entity_id = entity_id
+            module_descriptor.db_entity_type = entity_type
+            module_descriptor.is_dirty = False
+            res[('module_descriptor', id)] = module_descriptor
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'package', 'namespace', 'package_version', 'version', 'base_descriptor_id', 'parent_id', 'entity_id', 'entity_type']
+        table = 'module_descriptor'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package_version = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            base_descriptor_id = self.convertFromDB(row[6], 'long', 'int')
+            package = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            module_descriptor = DBModuleDescriptor(name=name,
+                                                   package=package,
+                                                   namespace=namespace,
+                                                   package_version=package_version,
+                                                   version=version,
+                                                   base_descriptor_id=base_descriptor_id,
+                                                   id=id)
+            module_descriptor.db_package = package
+            module_descriptor.db_entity_id = entity_id
+            module_descriptor.db_entity_type = entity_type
+            module_descriptor.is_dirty = False
+            res[('module_descriptor', id)] = module_descriptor
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('package', obj.db_package) in all_objects:
+            p = all_objects[('package', obj.db_package)]
+            p.db_add_module_descriptor(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'package', 'namespace', 'package_version', 'version', 'base_descriptor_id', 'parent_id', 'entity_id', 'entity_type']
+        table = 'module_descriptor'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package_version') and obj.db_package_version is not None:
+            columnMap['package_version'] = \
+                self.convertToDB(obj.db_package_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_base_descriptor_id') and obj.db_base_descriptor_id is not None:
+            columnMap['base_descriptor_id'] = \
+                self.convertToDB(obj.db_base_descriptor_id, 'long', 'int')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_package, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'package', 'namespace', 'package_version', 'version', 'base_descriptor_id', 'parent_id', 'entity_id', 'entity_type']
+        table = 'module_descriptor'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package_version') and obj.db_package_version is not None:
+            columnMap['package_version'] = \
+                self.convertToDB(obj.db_package_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_base_descriptor_id') and obj.db_base_descriptor_id is not None:
+            columnMap['base_descriptor_id'] = \
+                self.convertToDB(obj.db_base_descriptor_id, 'long', 'int')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_package, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_portSpecs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'module_descriptor'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBTagSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'tag'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'tag'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[2], 'long', 'int')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            
+            tag = DBTag(name=name,
+                        id=id)
+            tag.db_vistrail = vistrail
+            tag.db_entity_id = entity_id
+            tag.db_entity_type = entity_type
+            tag.is_dirty = False
+            res[('tag', id)] = tag
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'tag'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[2], 'long', 'int')
+            entity_id = self.convertFromDB(row[3], 'long', 'int')
+            entity_type = self.convertFromDB(row[4], 'str', 'char(16)')
+            
+            tag = DBTag(name=name,
+                        id=id)
+            tag.db_vistrail = vistrail
+            tag.db_entity_id = entity_id
+            tag.db_entity_type = entity_type
+            tag.is_dirty = False
+            res[('tag', id)] = tag
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('vistrail', obj.db_vistrail) in all_objects:
+            p = all_objects[('vistrail', obj.db_vistrail)]
+            p.db_add_tag(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'tag'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'parent_id', 'entity_id', 'entity_type']
+        table = 'tag'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'tag'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBPortSpecItemSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'port_spec_item'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'module', 'package', 'namespace', 'label', '_default', '_values', 'entry_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'port_spec_item'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            module = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            label = self.convertFromDB(row[5], 'str', 'varchar(4095)')
+            default = self.convertFromDB(row[6], 'str', 'varchar(4095)')
+            values = self.convertFromDB(row[7], 'str', 'mediumtext')
+            entry_type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            portSpec = self.convertFromDB(row[9], 'long', 'int')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            
+            portSpecItem = DBPortSpecItem(pos=pos,
+                                          module=module,
+                                          package=package,
+                                          namespace=namespace,
+                                          label=label,
+                                          default=default,
+                                          values=values,
+                                          entry_type=entry_type,
+                                          id=id)
+            portSpecItem.db_portSpec = portSpec
+            portSpecItem.db_entity_id = entity_id
+            portSpecItem.db_entity_type = entity_type
+            portSpecItem.is_dirty = False
+            res[('portSpecItem', id)] = portSpecItem
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'pos', 'module', 'package', 'namespace', 'label', '_default', '_values', 'entry_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'port_spec_item'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            pos = self.convertFromDB(row[1], 'long', 'int')
+            module = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            label = self.convertFromDB(row[5], 'str', 'varchar(4095)')
+            default = self.convertFromDB(row[6], 'str', 'varchar(4095)')
+            values = self.convertFromDB(row[7], 'str', 'mediumtext')
+            entry_type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            portSpec = self.convertFromDB(row[9], 'long', 'int')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            
+            portSpecItem = DBPortSpecItem(pos=pos,
+                                          module=module,
+                                          package=package,
+                                          namespace=namespace,
+                                          label=label,
+                                          default=default,
+                                          values=values,
+                                          entry_type=entry_type,
+                                          id=id)
+            portSpecItem.db_portSpec = portSpec
+            portSpecItem.db_entity_id = entity_id
+            portSpecItem.db_entity_type = entity_type
+            portSpecItem.is_dirty = False
+            res[('portSpecItem', id)] = portSpecItem
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('portSpec', obj.db_portSpec) in all_objects:
+            p = all_objects[('portSpec', obj.db_portSpec)]
+            p.db_add_portSpecItem(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'pos', 'module', 'package', 'namespace', 'label', '_default', '_values', 'entry_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'port_spec_item'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_module') and obj.db_module is not None:
+            columnMap['module'] = \
+                self.convertToDB(obj.db_module, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_label') and obj.db_label is not None:
+            columnMap['label'] = \
+                self.convertToDB(obj.db_label, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_default') and obj.db_default is not None:
+            columnMap['_default'] = \
+                self.convertToDB(obj.db_default, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_values') and obj.db_values is not None:
+            columnMap['_values'] = \
+                self.convertToDB(obj.db_values, 'str', 'mediumtext')
+        if hasattr(obj, 'db_entry_type') and obj.db_entry_type is not None:
+            columnMap['entry_type'] = \
+                self.convertToDB(obj.db_entry_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_portSpec') and obj.db_portSpec is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_portSpec, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'pos', 'module', 'package', 'namespace', 'label', '_default', '_values', 'entry_type', 'parent_id', 'entity_id', 'entity_type']
+        table = 'port_spec_item'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_module') and obj.db_module is not None:
+            columnMap['module'] = \
+                self.convertToDB(obj.db_module, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_label') and obj.db_label is not None:
+            columnMap['label'] = \
+                self.convertToDB(obj.db_label, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_default') and obj.db_default is not None:
+            columnMap['_default'] = \
+                self.convertToDB(obj.db_default, 'str', 'varchar(4095)')
+        if hasattr(obj, 'db_values') and obj.db_values is not None:
+            columnMap['_values'] = \
+                self.convertToDB(obj.db_values, 'str', 'mediumtext')
+        if hasattr(obj, 'db_entry_type') and obj.db_entry_type is not None:
+            columnMap['entry_type'] = \
+                self.convertToDB(obj.db_entry_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_portSpec') and obj.db_portSpec is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_portSpec, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'port_spec_item'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMashupComponentSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashup_component'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'vtid', 'vttype', 'vtparent_type', 'vtparent_id', 'vtpos', 'vtmid', 'pos', 'type', 'val', 'minVal', 'maxVal', 'stepSize', 'strvaluelist', 'widget', 'seq', 'parent', 'alias_id', 'entity_id', 'entity_type']
+        table = 'mashup_component'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            vtid = self.convertFromDB(row[1], 'long', 'int')
+            vttype = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            vtparent_type = self.convertFromDB(row[3], 'str', 'char(32)')
+            vtparent_id = self.convertFromDB(row[4], 'long', 'int')
+            vtpos = self.convertFromDB(row[5], 'long', 'int')
+            vtmid = self.convertFromDB(row[6], 'long', 'int')
+            pos = self.convertFromDB(row[7], 'long', 'int')
+            type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            val = self.convertFromDB(row[9], 'str', 'mediumtext')
+            minVal = self.convertFromDB(row[10], 'str', 'varchar(255)')
+            maxVal = self.convertFromDB(row[11], 'str', 'varchar(255)')
+            stepSize = self.convertFromDB(row[12], 'str', 'varchar(255)')
+            strvaluelist = self.convertFromDB(row[13], 'str', 'mediumtext')
+            widget = self.convertFromDB(row[14], 'str', 'varchar(255)')
+            seq = self.convertFromDB(row[15], 'int', 'int')
+            parent = self.convertFromDB(row[16], 'str', 'varchar(255)')
+            mashup_alias = self.convertFromDB(row[17], 'long', 'int')
+            entity_id = self.convertFromDB(row[18], 'long', 'int')
+            entity_type = self.convertFromDB(row[19], 'str', 'char(16)')
+            
+            mashup_component = DBMashupComponent(vtid=vtid,
+                                                 vttype=vttype,
+                                                 vtparent_type=vtparent_type,
+                                                 vtparent_id=vtparent_id,
+                                                 vtpos=vtpos,
+                                                 vtmid=vtmid,
+                                                 pos=pos,
+                                                 type=type,
+                                                 val=val,
+                                                 minVal=minVal,
+                                                 maxVal=maxVal,
+                                                 stepSize=stepSize,
+                                                 strvaluelist=strvaluelist,
+                                                 widget=widget,
+                                                 seq=seq,
+                                                 parent=parent,
+                                                 id=id)
+            mashup_component.db_mashup_alias = mashup_alias
+            mashup_component.db_entity_id = entity_id
+            mashup_component.db_entity_type = entity_type
+            mashup_component.is_dirty = False
+            res[('mashup_component', id)] = mashup_component
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'vtid', 'vttype', 'vtparent_type', 'vtparent_id', 'vtpos', 'vtmid', 'pos', 'type', 'val', 'minVal', 'maxVal', 'stepSize', 'strvaluelist', 'widget', 'seq', 'parent', 'alias_id', 'entity_id', 'entity_type']
+        table = 'mashup_component'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            vtid = self.convertFromDB(row[1], 'long', 'int')
+            vttype = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            vtparent_type = self.convertFromDB(row[3], 'str', 'char(32)')
+            vtparent_id = self.convertFromDB(row[4], 'long', 'int')
+            vtpos = self.convertFromDB(row[5], 'long', 'int')
+            vtmid = self.convertFromDB(row[6], 'long', 'int')
+            pos = self.convertFromDB(row[7], 'long', 'int')
+            type = self.convertFromDB(row[8], 'str', 'varchar(255)')
+            val = self.convertFromDB(row[9], 'str', 'mediumtext')
+            minVal = self.convertFromDB(row[10], 'str', 'varchar(255)')
+            maxVal = self.convertFromDB(row[11], 'str', 'varchar(255)')
+            stepSize = self.convertFromDB(row[12], 'str', 'varchar(255)')
+            strvaluelist = self.convertFromDB(row[13], 'str', 'mediumtext')
+            widget = self.convertFromDB(row[14], 'str', 'varchar(255)')
+            seq = self.convertFromDB(row[15], 'int', 'int')
+            parent = self.convertFromDB(row[16], 'str', 'varchar(255)')
+            mashup_alias = self.convertFromDB(row[17], 'long', 'int')
+            entity_id = self.convertFromDB(row[18], 'long', 'int')
+            entity_type = self.convertFromDB(row[19], 'str', 'char(16)')
+            
+            mashup_component = DBMashupComponent(vtid=vtid,
+                                                 vttype=vttype,
+                                                 vtparent_type=vtparent_type,
+                                                 vtparent_id=vtparent_id,
+                                                 vtpos=vtpos,
+                                                 vtmid=vtmid,
+                                                 pos=pos,
+                                                 type=type,
+                                                 val=val,
+                                                 minVal=minVal,
+                                                 maxVal=maxVal,
+                                                 stepSize=stepSize,
+                                                 strvaluelist=strvaluelist,
+                                                 widget=widget,
+                                                 seq=seq,
+                                                 parent=parent,
+                                                 id=id)
+            mashup_component.db_mashup_alias = mashup_alias
+            mashup_component.db_entity_id = entity_id
+            mashup_component.db_entity_type = entity_type
+            mashup_component.is_dirty = False
+            res[('mashup_component', id)] = mashup_component
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('mashup_alias', obj.db_mashup_alias) in all_objects:
+            p = all_objects[('mashup_alias', obj.db_mashup_alias)]
+            p.db_add_component(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'vtid', 'vttype', 'vtparent_type', 'vtparent_id', 'vtpos', 'vtmid', 'pos', 'type', 'val', 'minVal', 'maxVal', 'stepSize', 'strvaluelist', 'widget', 'seq', 'parent', 'alias_id', 'entity_id', 'entity_type']
+        table = 'mashup_component'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_vtid') and obj.db_vtid is not None:
+            columnMap['vtid'] = \
+                self.convertToDB(obj.db_vtid, 'long', 'int')
+        if hasattr(obj, 'db_vttype') and obj.db_vttype is not None:
+            columnMap['vttype'] = \
+                self.convertToDB(obj.db_vttype, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vtparent_type') and obj.db_vtparent_type is not None:
+            columnMap['vtparent_type'] = \
+                self.convertToDB(obj.db_vtparent_type, 'str', 'char(32)')
+        if hasattr(obj, 'db_vtparent_id') and obj.db_vtparent_id is not None:
+            columnMap['vtparent_id'] = \
+                self.convertToDB(obj.db_vtparent_id, 'long', 'int')
+        if hasattr(obj, 'db_vtpos') and obj.db_vtpos is not None:
+            columnMap['vtpos'] = \
+                self.convertToDB(obj.db_vtpos, 'long', 'int')
+        if hasattr(obj, 'db_vtmid') and obj.db_vtmid is not None:
+            columnMap['vtmid'] = \
+                self.convertToDB(obj.db_vtmid, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_val') and obj.db_val is not None:
+            columnMap['val'] = \
+                self.convertToDB(obj.db_val, 'str', 'mediumtext')
+        if hasattr(obj, 'db_minVal') and obj.db_minVal is not None:
+            columnMap['minVal'] = \
+                self.convertToDB(obj.db_minVal, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_maxVal') and obj.db_maxVal is not None:
+            columnMap['maxVal'] = \
+                self.convertToDB(obj.db_maxVal, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_stepSize') and obj.db_stepSize is not None:
+            columnMap['stepSize'] = \
+                self.convertToDB(obj.db_stepSize, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_strvaluelist') and obj.db_strvaluelist is not None:
+            columnMap['strvaluelist'] = \
+                self.convertToDB(obj.db_strvaluelist, 'str', 'mediumtext')
+        if hasattr(obj, 'db_widget') and obj.db_widget is not None:
+            columnMap['widget'] = \
+                self.convertToDB(obj.db_widget, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_seq') and obj.db_seq is not None:
+            columnMap['seq'] = \
+                self.convertToDB(obj.db_seq, 'int', 'int')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent'] = \
+                self.convertToDB(obj.db_parent, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashup_alias') and obj.db_mashup_alias is not None:
+            columnMap['alias_id'] = \
+                self.convertToDB(obj.db_mashup_alias, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'vtid', 'vttype', 'vtparent_type', 'vtparent_id', 'vtpos', 'vtmid', 'pos', 'type', 'val', 'minVal', 'maxVal', 'stepSize', 'strvaluelist', 'widget', 'seq', 'parent', 'alias_id', 'entity_id', 'entity_type']
+        table = 'mashup_component'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_vtid') and obj.db_vtid is not None:
+            columnMap['vtid'] = \
+                self.convertToDB(obj.db_vtid, 'long', 'int')
+        if hasattr(obj, 'db_vttype') and obj.db_vttype is not None:
+            columnMap['vttype'] = \
+                self.convertToDB(obj.db_vttype, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vtparent_type') and obj.db_vtparent_type is not None:
+            columnMap['vtparent_type'] = \
+                self.convertToDB(obj.db_vtparent_type, 'str', 'char(32)')
+        if hasattr(obj, 'db_vtparent_id') and obj.db_vtparent_id is not None:
+            columnMap['vtparent_id'] = \
+                self.convertToDB(obj.db_vtparent_id, 'long', 'int')
+        if hasattr(obj, 'db_vtpos') and obj.db_vtpos is not None:
+            columnMap['vtpos'] = \
+                self.convertToDB(obj.db_vtpos, 'long', 'int')
+        if hasattr(obj, 'db_vtmid') and obj.db_vtmid is not None:
+            columnMap['vtmid'] = \
+                self.convertToDB(obj.db_vtmid, 'long', 'int')
+        if hasattr(obj, 'db_pos') and obj.db_pos is not None:
+            columnMap['pos'] = \
+                self.convertToDB(obj.db_pos, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_val') and obj.db_val is not None:
+            columnMap['val'] = \
+                self.convertToDB(obj.db_val, 'str', 'mediumtext')
+        if hasattr(obj, 'db_minVal') and obj.db_minVal is not None:
+            columnMap['minVal'] = \
+                self.convertToDB(obj.db_minVal, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_maxVal') and obj.db_maxVal is not None:
+            columnMap['maxVal'] = \
+                self.convertToDB(obj.db_maxVal, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_stepSize') and obj.db_stepSize is not None:
+            columnMap['stepSize'] = \
+                self.convertToDB(obj.db_stepSize, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_strvaluelist') and obj.db_strvaluelist is not None:
+            columnMap['strvaluelist'] = \
+                self.convertToDB(obj.db_strvaluelist, 'str', 'mediumtext')
+        if hasattr(obj, 'db_widget') and obj.db_widget is not None:
+            columnMap['widget'] = \
+                self.convertToDB(obj.db_widget, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_seq') and obj.db_seq is not None:
+            columnMap['seq'] = \
+                self.convertToDB(obj.db_seq, 'int', 'int')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent'] = \
+                self.convertToDB(obj.db_parent, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashup_alias') and obj.db_mashup_alias is not None:
+            columnMap['alias_id'] = \
+                self.convertToDB(obj.db_mashup_alias, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashup_component'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMashupSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashup'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'version', 'type', 'vtid', 'layout', 'geometry', 'has_seq', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[2], 'long', 'int')
+            type = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            vtid = self.convertFromDB(row[4], 'long', 'int')
+            layout = self.convertFromDB(row[5], 'str', 'mediumtext')
+            geometry = self.convertFromDB(row[6], 'str', 'mediumtext')
+            has_seq = self.convertFromDB(row[7], 'int', 'int')
+            parent = self.convertFromDB(row[8], 'long', 'int')
+            entity_id = self.convertFromDB(row[9], 'long', 'int')
+            entity_type = self.convertFromDB(row[10], 'str', 'char(16)')
+            
+            mashup = DBMashup(name=name,
+                              version=version,
+                              type=type,
+                              vtid=vtid,
+                              layout=layout,
+                              geometry=geometry,
+                              has_seq=has_seq,
+                              id=id)
+            mashup.db_parent = parent
+            mashup.db_entity_id = entity_id
+            mashup.db_entity_type = entity_type
+            mashup.is_dirty = False
+            res[('mashup', id)] = mashup
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'version', 'type', 'vtid', 'layout', 'geometry', 'has_seq', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            version = self.convertFromDB(row[2], 'long', 'int')
+            type = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            vtid = self.convertFromDB(row[4], 'long', 'int')
+            layout = self.convertFromDB(row[5], 'str', 'mediumtext')
+            geometry = self.convertFromDB(row[6], 'str', 'mediumtext')
+            has_seq = self.convertFromDB(row[7], 'int', 'int')
+            parent = self.convertFromDB(row[8], 'long', 'int')
+            entity_id = self.convertFromDB(row[9], 'long', 'int')
+            entity_type = self.convertFromDB(row[10], 'str', 'char(16)')
+            
+            mashup = DBMashup(name=name,
+                              version=version,
+                              type=type,
+                              vtid=vtid,
+                              layout=layout,
+                              geometry=geometry,
+                              has_seq=has_seq,
+                              id=id)
+            mashup.db_parent = parent
+            mashup.db_entity_id = entity_id
+            mashup.db_entity_type = entity_type
+            mashup.is_dirty = False
+            res[('mashup', id)] = mashup
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('mashup_action', obj.db_parent) in all_objects:
+            p = all_objects[('mashup_action', obj.db_parent)]
+            p.db_add_mashup(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'version', 'type', 'vtid', 'layout', 'geometry', 'has_seq', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vtid') and obj.db_vtid is not None:
+            columnMap['vtid'] = \
+                self.convertToDB(obj.db_vtid, 'long', 'int')
+        if hasattr(obj, 'db_layout') and obj.db_layout is not None:
+            columnMap['layout'] = \
+                self.convertToDB(obj.db_layout, 'str', 'mediumtext')
+        if hasattr(obj, 'db_geometry') and obj.db_geometry is not None:
+            columnMap['geometry'] = \
+                self.convertToDB(obj.db_geometry, 'str', 'mediumtext')
+        if hasattr(obj, 'db_has_seq') and obj.db_has_seq is not None:
+            columnMap['has_seq'] = \
+                self.convertToDB(obj.db_has_seq, 'int', 'int')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'version', 'type', 'vtid', 'layout', 'geometry', 'has_seq', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'long', 'int')
+        if hasattr(obj, 'db_type') and obj.db_type is not None:
+            columnMap['type'] = \
+                self.convertToDB(obj.db_type, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vtid') and obj.db_vtid is not None:
+            columnMap['vtid'] = \
+                self.convertToDB(obj.db_vtid, 'long', 'int')
+        if hasattr(obj, 'db_layout') and obj.db_layout is not None:
+            columnMap['layout'] = \
+                self.convertToDB(obj.db_layout, 'str', 'mediumtext')
+        if hasattr(obj, 'db_geometry') and obj.db_geometry is not None:
+            columnMap['geometry'] = \
+                self.convertToDB(obj.db_geometry, 'str', 'mediumtext')
+        if hasattr(obj, 'db_has_seq') and obj.db_has_seq is not None:
+            columnMap['has_seq'] = \
+                self.convertToDB(obj.db_has_seq, 'int', 'int')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_aliases:
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashup'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMachineSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'machine'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'os', 'architecture', 'processor', 'ram', 'vt_id', 'log_id', 'entity_id', 'entity_type']
+        table = 'machine'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            os = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            architecture = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            processor = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            ram = self.convertFromDB(row[5], 'int', 'bigint')
+            vistrailId = self.convertFromDB(row[6], 'long', 'int')
+            workflow_exec = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            machine = DBMachine(name=name,
+                                os=os,
+                                architecture=architecture,
+                                processor=processor,
+                                ram=ram,
+                                id=id)
+            machine.db_vistrailId = vistrailId
+            machine.db_workflow_exec = workflow_exec
+            machine.db_entity_id = entity_id
+            machine.db_entity_type = entity_type
+            machine.is_dirty = False
+            res[('machine', id)] = machine
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'os', 'architecture', 'processor', 'ram', 'vt_id', 'log_id', 'entity_id', 'entity_type']
+        table = 'machine'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            os = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            architecture = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            processor = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            ram = self.convertFromDB(row[5], 'int', 'bigint')
+            vistrailId = self.convertFromDB(row[6], 'long', 'int')
+            workflow_exec = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            machine = DBMachine(name=name,
+                                os=os,
+                                architecture=architecture,
+                                processor=processor,
+                                ram=ram,
+                                id=id)
+            machine.db_vistrailId = vistrailId
+            machine.db_workflow_exec = workflow_exec
+            machine.db_entity_id = entity_id
+            machine.db_entity_type = entity_type
+            machine.is_dirty = False
+            res[('machine', id)] = machine
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('workflow_exec', obj.db_workflow_exec) in all_objects:
+            p = all_objects[('workflow_exec', obj.db_workflow_exec)]
+            p.db_add_machine(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'os', 'architecture', 'processor', 'ram', 'vt_id', 'log_id', 'entity_id', 'entity_type']
+        table = 'machine'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_os') and obj.db_os is not None:
+            columnMap['os'] = \
+                self.convertToDB(obj.db_os, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_architecture') and obj.db_architecture is not None:
+            columnMap['architecture'] = \
+                self.convertToDB(obj.db_architecture, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_processor') and obj.db_processor is not None:
+            columnMap['processor'] = \
+                self.convertToDB(obj.db_processor, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ram') and obj.db_ram is not None:
+            columnMap['ram'] = \
+                self.convertToDB(obj.db_ram, 'int', 'bigint')
+        if hasattr(obj, 'db_vistrailId') and obj.db_vistrailId is not None:
+            columnMap['vt_id'] = \
+                self.convertToDB(obj.db_vistrailId, 'long', 'int')
+        if hasattr(obj, 'db_workflow_exec') and obj.db_workflow_exec is not None:
+            columnMap['log_id'] = \
+                self.convertToDB(obj.db_workflow_exec, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'os', 'architecture', 'processor', 'ram', 'vt_id', 'log_id', 'entity_id', 'entity_type']
+        table = 'machine'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_os') and obj.db_os is not None:
+            columnMap['os'] = \
+                self.convertToDB(obj.db_os, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_architecture') and obj.db_architecture is not None:
+            columnMap['architecture'] = \
+                self.convertToDB(obj.db_architecture, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_processor') and obj.db_processor is not None:
+            columnMap['processor'] = \
+                self.convertToDB(obj.db_processor, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_ram') and obj.db_ram is not None:
+            columnMap['ram'] = \
+                self.convertToDB(obj.db_ram, 'int', 'bigint')
+        if hasattr(obj, 'db_vistrailId') and obj.db_vistrailId is not None:
+            columnMap['vt_id'] = \
+                self.convertToDB(obj.db_vistrailId, 'long', 'int')
+        if hasattr(obj, 'db_workflow_exec') and obj.db_workflow_exec is not None:
+            columnMap['log_id'] = \
+                self.convertToDB(obj.db_workflow_exec, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'machine'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBOtherSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'other'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'okey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'other'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            other = DBOther(key=key,
+                            value=value,
+                            id=id)
+            other.db_parentType = parentType
+            other.db_entity_id = entity_id
+            other.db_entity_type = entity_type
+            other.db_parent = parent
+            other.is_dirty = False
+            res[('other', id)] = other
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'okey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'other'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            other = DBOther(key=key,
+                            value=value,
+                            id=id)
+            other.db_parentType = parentType
+            other.db_entity_id = entity_id
+            other.db_entity_type = entity_type
+            other.db_parent = parent
+            other.is_dirty = False
+            res[('other', id)] = other
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_other(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'okey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'other'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['okey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'okey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'other'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['okey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'other'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBAbstractionSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'abstraction'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'internal_version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'abstraction'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            internal_version = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[7], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            parent = self.convertFromDB(row[10], 'long', 'long')
+            
+            abstraction = DBAbstraction(cache=cache,
+                                        name=name,
+                                        namespace=namespace,
+                                        package=package,
+                                        version=version,
+                                        internal_version=internal_version,
+                                        id=id)
+            abstraction.db_parentType = parentType
+            abstraction.db_entity_id = entity_id
+            abstraction.db_entity_type = entity_type
+            abstraction.db_parent = parent
+            abstraction.is_dirty = False
+            res[('abstraction', id)] = abstraction
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'internal_version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'abstraction'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            cache = self.convertFromDB(row[1], 'int', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            namespace = self.convertFromDB(row[3], 'str', 'varchar(255)')
+            package = self.convertFromDB(row[4], 'str', 'varchar(511)')
+            version = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            internal_version = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            parentType = self.convertFromDB(row[7], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            parent = self.convertFromDB(row[10], 'long', 'long')
+            
+            abstraction = DBAbstraction(cache=cache,
+                                        name=name,
+                                        namespace=namespace,
+                                        package=package,
+                                        version=version,
+                                        internal_version=internal_version,
+                                        id=id)
+            abstraction.db_parentType = parentType
+            abstraction.db_entity_id = entity_id
+            abstraction.db_entity_type = entity_type
+            abstraction.db_parent = parent
+            abstraction.is_dirty = False
+            res[('abstraction', id)] = abstraction
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_module(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'internal_version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'abstraction'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_internal_version') and obj.db_internal_version is not None:
+            columnMap['internal_version'] = \
+                self.convertToDB(obj.db_internal_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'cache', 'name', 'namespace', 'package', 'version', 'internal_version', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'abstraction'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_cache') and obj.db_cache is not None:
+            columnMap['cache'] = \
+                self.convertToDB(obj.db_cache, 'int', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_namespace') and obj.db_namespace is not None:
+            columnMap['namespace'] = \
+                self.convertToDB(obj.db_namespace, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_package') and obj.db_package is not None:
+            columnMap['package'] = \
+                self.convertToDB(obj.db_package, 'str', 'varchar(511)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_internal_version') and obj.db_internal_version is not None:
+            columnMap['internal_version'] = \
+                self.convertToDB(obj.db_internal_version, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        if obj.db_location is not None:
+            child = obj.db_location
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_functions:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_controlParameters:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'abstraction'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMashuptrailSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashuptrail'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'version', 'vt_version', 'last_modified', 'entity_type']
+        table = 'mashuptrail'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'char(36)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            vtVersion = self.convertFromDB(row[3], 'long', 'int')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            
+            mashuptrail = DBMashuptrail(name=name,
+                                        version=version,
+                                        vtVersion=vtVersion,
+                                        last_modified=last_modified,
+                                        id=id)
+            mashuptrail.db_entity_type = entity_type
+            mashuptrail.is_dirty = False
+            res[('mashuptrail', id)] = mashuptrail
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'name', 'version', 'vt_version', 'last_modified', 'entity_type']
+        table = 'mashuptrail'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            name = self.convertFromDB(row[1], 'str', 'char(36)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            vtVersion = self.convertFromDB(row[3], 'long', 'int')
+            last_modified = self.convertFromDB(row[4], 'datetime', 'datetime')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            
+            mashuptrail = DBMashuptrail(name=name,
+                                        version=version,
+                                        vtVersion=vtVersion,
+                                        last_modified=last_modified,
+                                        id=id)
+            mashuptrail.db_entity_type = entity_type
+            mashuptrail.is_dirty = False
+            res[('mashuptrail', id)] = mashuptrail
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        pass
+    
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'name', 'version', 'vt_version', 'last_modified', 'entity_type']
+        table = 'mashuptrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'char(36)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_vtVersion') and obj.db_vtVersion is not None:
+            columnMap['vt_version'] = \
+                self.convertToDB(obj.db_vtVersion, 'long', 'int')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'name', 'version', 'vt_version', 'last_modified', 'entity_type']
+        table = 'mashuptrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'char(36)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_vtVersion') and obj.db_vtVersion is not None:
+            columnMap['vt_version'] = \
+                self.convertToDB(obj.db_vtVersion, 'long', 'int')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_actions:
+            child.db_mashuptrail = obj.db_id
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_actionAnnotations:
+            child.db_mashuptrail = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashuptrail'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBRegistrySQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'registry'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'root_descriptor_id', 'name', 'last_modified']
+        table = 'registry'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            root_descriptor_id = self.convertFromDB(row[3], 'long', 'int')
+            name = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[5], 'datetime', 'datetime')
+            
+            registry = DBRegistry(entity_type=entity_type,
+                                  version=version,
+                                  root_descriptor_id=root_descriptor_id,
+                                  name=name,
+                                  last_modified=last_modified,
+                                  id=id)
+            registry.is_dirty = False
+            res[('registry', id)] = registry
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'entity_type', 'version', 'root_descriptor_id', 'name', 'last_modified']
+        table = 'registry'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            global_props['entity_id'] = self.convertToDB(id, 'long', 'int')
+            entity_type = self.convertFromDB(row[1], 'str', 'char(16)')
+            global_props['entity_type'] = self.convertToDB(entity_type, 'str', 'char(16)')
+            version = self.convertFromDB(row[2], 'str', 'char(16)')
+            root_descriptor_id = self.convertFromDB(row[3], 'long', 'int')
+            name = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            last_modified = self.convertFromDB(row[5], 'datetime', 'datetime')
+            
+            registry = DBRegistry(entity_type=entity_type,
+                                  version=version,
+                                  root_descriptor_id=root_descriptor_id,
+                                  name=name,
+                                  last_modified=last_modified,
+                                  id=id)
+            registry.is_dirty = False
+            res[('registry', id)] = registry
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        pass
+    
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'entity_type', 'version', 'root_descriptor_id', 'name', 'last_modified']
+        table = 'registry'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_root_descriptor_id') and obj.db_root_descriptor_id is not None:
+            columnMap['root_descriptor_id'] = \
+                self.convertToDB(obj.db_root_descriptor_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'entity_type', 'version', 'root_descriptor_id', 'name', 'last_modified']
+        table = 'registry'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_version') and obj.db_version is not None:
+            columnMap['version'] = \
+                self.convertToDB(obj.db_version, 'str', 'char(16)')
+        if hasattr(obj, 'db_root_descriptor_id') and obj.db_root_descriptor_id is not None:
+            columnMap['root_descriptor_id'] = \
+                self.convertToDB(obj.db_root_descriptor_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_last_modified') and obj.db_last_modified is not None:
+            columnMap['last_modified'] = \
+                self.convertToDB(obj.db_last_modified, 'datetime', 'datetime')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        if obj.db_id is None:
+            obj.db_id = lastId
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            global_props['entity_type'] = self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            global_props['entity_id'] = self.convertToDB(obj.db_id, 'long', 'int')
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_packages:
+            child.db_registry = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'registry'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBAnnotationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'annotation'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'annotation'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'mediumtext')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            annotation = DBAnnotation(key=key,
+                                      value=value,
+                                      id=id)
+            annotation.db_parentType = parentType
+            annotation.db_entity_id = entity_id
+            annotation.db_entity_type = entity_type
+            annotation.db_parent = parent
+            annotation.is_dirty = False
+            res[('annotation', id)] = annotation
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'annotation'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'mediumtext')
+            parentType = self.convertFromDB(row[3], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[4], 'long', 'int')
+            entity_type = self.convertFromDB(row[5], 'str', 'char(16)')
+            parent = self.convertFromDB(row[6], 'long', 'long')
+            
+            annotation = DBAnnotation(key=key,
+                                      value=value,
+                                      id=id)
+            annotation.db_parentType = parentType
+            annotation.db_entity_id = entity_id
+            annotation.db_entity_type = entity_type
+            annotation.db_parent = parent
+            annotation.is_dirty = False
+            res[('annotation', id)] = annotation
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'vistrail':
+            p = all_objects[('vistrail', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'workflow':
+            p = all_objects[('workflow', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'module':
+            p = all_objects[('module', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'workflow_exec':
+            p = all_objects[('workflow_exec', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'module_exec':
+            p = all_objects[('module_exec', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'group_exec':
+            p = all_objects[('group_exec', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'add':
+            p = all_objects[('add', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'change':
+            p = all_objects[('change', obj.db_parent)]
+            p.db_add_data(obj)
+        elif obj.db_parentType == 'action':
+            p = all_objects[('action', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'abstraction':
+            p = all_objects[('abstraction', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'mashuptrail':
+            p = all_objects[('mashuptrail', obj.db_parent)]
+            p.db_add_annotation(obj)
+        elif obj.db_parentType == 'group':
+            p = all_objects[('group', obj.db_parent)]
+            p.db_add_annotation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'akey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'akey', 'value', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'mediumtext')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBParameterExplorationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'parameter_exploration'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'action_id', 'name', 'date', 'user', 'dims', 'layout', 'parent_id', 'entity_id', 'entity_type']
+        table = 'parameter_exploration'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            action_id = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            date = self.convertFromDB(row[3], 'datetime', 'datetime')
+            user = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            dims = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            layout = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            parameter_exploration = DBParameterExploration(action_id=action_id,
+                                                           name=name,
+                                                           date=date,
+                                                           user=user,
+                                                           dims=dims,
+                                                           layout=layout,
+                                                           id=id)
+            parameter_exploration.db_vistrail = vistrail
+            parameter_exploration.db_entity_id = entity_id
+            parameter_exploration.db_entity_type = entity_type
+            parameter_exploration.is_dirty = False
+            res[('parameter_exploration', id)] = parameter_exploration
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'action_id', 'name', 'date', 'user', 'dims', 'layout', 'parent_id', 'entity_id', 'entity_type']
+        table = 'parameter_exploration'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            action_id = self.convertFromDB(row[1], 'long', 'int')
+            name = self.convertFromDB(row[2], 'str', 'varchar(255)')
+            date = self.convertFromDB(row[3], 'datetime', 'datetime')
+            user = self.convertFromDB(row[4], 'str', 'varchar(255)')
+            dims = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            layout = self.convertFromDB(row[6], 'str', 'varchar(255)')
+            vistrail = self.convertFromDB(row[7], 'long', 'int')
+            entity_id = self.convertFromDB(row[8], 'long', 'int')
+            entity_type = self.convertFromDB(row[9], 'str', 'char(16)')
+            
+            parameter_exploration = DBParameterExploration(action_id=action_id,
+                                                           name=name,
+                                                           date=date,
+                                                           user=user,
+                                                           dims=dims,
+                                                           layout=layout,
+                                                           id=id)
+            parameter_exploration.db_vistrail = vistrail
+            parameter_exploration.db_entity_id = entity_id
+            parameter_exploration.db_entity_type = entity_type
+            parameter_exploration.is_dirty = False
+            res[('parameter_exploration', id)] = parameter_exploration
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('vistrail', obj.db_vistrail) in all_objects:
+            p = all_objects[('vistrail', obj.db_vistrail)]
+            p.db_add_parameter_exploration(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'action_id', 'name', 'date', 'user', 'dims', 'layout', 'parent_id', 'entity_id', 'entity_type']
+        table = 'parameter_exploration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_dims') and obj.db_dims is not None:
+            columnMap['dims'] = \
+                self.convertToDB(obj.db_dims, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_layout') and obj.db_layout is not None:
+            columnMap['layout'] = \
+                self.convertToDB(obj.db_layout, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'action_id', 'name', 'date', 'user', 'dims', 'layout', 'parent_id', 'entity_id', 'entity_type']
+        table = 'parameter_exploration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_name') and obj.db_name is not None:
+            columnMap['name'] = \
+                self.convertToDB(obj.db_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_dims') and obj.db_dims is not None:
+            columnMap['dims'] = \
+                self.convertToDB(obj.db_dims, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_layout') and obj.db_layout is not None:
+            columnMap['layout'] = \
+                self.convertToDB(obj.db_layout, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_vistrail') and obj.db_vistrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_vistrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_functions:
+            child.db_parameter_exploration = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'parameter_exploration'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBMashupActionAnnotationSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'mashup_action_annotation'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action_annotation'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(8191)')
+            action_id = self.convertFromDB(row[3], 'long', 'int')
+            date = self.convertFromDB(row[4], 'datetime', 'datetime')
+            user = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            mashuptrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            mashup_actionAnnotation = DBMashupActionAnnotation(key=key,
+                                                               value=value,
+                                                               action_id=action_id,
+                                                               date=date,
+                                                               user=user,
+                                                               id=id)
+            mashup_actionAnnotation.db_mashuptrail = mashuptrail
+            mashup_actionAnnotation.db_entity_id = entity_id
+            mashup_actionAnnotation.db_entity_type = entity_type
+            mashup_actionAnnotation.is_dirty = False
+            res[('mashup_actionAnnotation', id)] = mashup_actionAnnotation
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action_annotation'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            key = self.convertFromDB(row[1], 'str', 'varchar(255)')
+            value = self.convertFromDB(row[2], 'str', 'varchar(8191)')
+            action_id = self.convertFromDB(row[3], 'long', 'int')
+            date = self.convertFromDB(row[4], 'datetime', 'datetime')
+            user = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            mashuptrail = self.convertFromDB(row[6], 'long', 'int')
+            entity_id = self.convertFromDB(row[7], 'long', 'int')
+            entity_type = self.convertFromDB(row[8], 'str', 'char(16)')
+            
+            mashup_actionAnnotation = DBMashupActionAnnotation(key=key,
+                                                               value=value,
+                                                               action_id=action_id,
+                                                               date=date,
+                                                               user=user,
+                                                               id=id)
+            mashup_actionAnnotation.db_mashuptrail = mashuptrail
+            mashup_actionAnnotation.db_entity_id = entity_id
+            mashup_actionAnnotation.db_entity_type = entity_type
+            mashup_actionAnnotation.is_dirty = False
+            res[('mashup_actionAnnotation', id)] = mashup_actionAnnotation
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if ('mashuptrail', obj.db_mashuptrail) in all_objects:
+            p = all_objects[('mashuptrail', obj.db_mashuptrail)]
+            p.db_add_actionAnnotation(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashuptrail') and obj.db_mashuptrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_mashuptrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'akey', 'value', 'action_id', 'date', 'user', 'parent_id', 'entity_id', 'entity_type']
+        table = 'mashup_action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_key') and obj.db_key is not None:
+            columnMap['akey'] = \
+                self.convertToDB(obj.db_key, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_value') and obj.db_value is not None:
+            columnMap['value'] = \
+                self.convertToDB(obj.db_value, 'str', 'varchar(8191)')
+        if hasattr(obj, 'db_action_id') and obj.db_action_id is not None:
+            columnMap['action_id'] = \
+                self.convertToDB(obj.db_action_id, 'long', 'int')
+        if hasattr(obj, 'db_date') and obj.db_date is not None:
+            columnMap['date'] = \
+                self.convertToDB(obj.db_date, 'datetime', 'datetime')
+        if hasattr(obj, 'db_user') and obj.db_user is not None:
+            columnMap['user'] = \
+                self.convertToDB(obj.db_user, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_mashuptrail') and obj.db_mashuptrail is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_mashuptrail, 'long', 'int')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        pass
+    
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'mashup_action_annotation'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+class DBModuleExecSQLDAOBase(SQLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+        self.table = 'module_exec'
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def get_sql_columns(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'module_name', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module_exec'
+        whereMap = global_props
+        orderBy = 'id'
+
+        dbCommand = self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+        data = self.executeSQL(db, dbCommand, True)
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            cached = self.convertFromDB(row[3], 'int', 'int')
+            module_id = self.convertFromDB(row[4], 'long', 'int')
+            module_name = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            completed = self.convertFromDB(row[6], 'int', 'int')
+            error = self.convertFromDB(row[7], 'str', 'varchar(1023)')
+            machine_id = self.convertFromDB(row[8], 'long', 'int')
+            parentType = self.convertFromDB(row[9], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            parent = self.convertFromDB(row[12], 'long', 'long')
+            
+            module_exec = DBModuleExec(ts_start=ts_start,
+                                       ts_end=ts_end,
+                                       cached=cached,
+                                       module_id=module_id,
+                                       module_name=module_name,
+                                       completed=completed,
+                                       error=error,
+                                       machine_id=machine_id,
+                                       id=id)
+            module_exec.db_parentType = parentType
+            module_exec.db_entity_id = entity_id
+            module_exec.db_entity_type = entity_type
+            module_exec.db_parent = parent
+            module_exec.is_dirty = False
+            res[('module_exec', id)] = module_exec
+        return res
+
+    def get_sql_select(self, db, global_props,lock=False):
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'module_name', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module_exec'
+        whereMap = global_props
+        orderBy = 'id'
+        return self.createSQLSelect(table, columns, whereMap, orderBy, lock)
+
+    def process_sql_columns(self, data, global_props):
+        res = {}
+        for row in data:
+            id = self.convertFromDB(row[0], 'long', 'int')
+            ts_start = self.convertFromDB(row[1], 'datetime', 'datetime')
+            ts_end = self.convertFromDB(row[2], 'datetime', 'datetime')
+            cached = self.convertFromDB(row[3], 'int', 'int')
+            module_id = self.convertFromDB(row[4], 'long', 'int')
+            module_name = self.convertFromDB(row[5], 'str', 'varchar(255)')
+            completed = self.convertFromDB(row[6], 'int', 'int')
+            error = self.convertFromDB(row[7], 'str', 'varchar(1023)')
+            machine_id = self.convertFromDB(row[8], 'long', 'int')
+            parentType = self.convertFromDB(row[9], 'str', 'char(32)')
+            entity_id = self.convertFromDB(row[10], 'long', 'int')
+            entity_type = self.convertFromDB(row[11], 'str', 'char(16)')
+            parent = self.convertFromDB(row[12], 'long', 'long')
+            
+            module_exec = DBModuleExec(ts_start=ts_start,
+                                       ts_end=ts_end,
+                                       cached=cached,
+                                       module_id=module_id,
+                                       module_name=module_name,
+                                       completed=completed,
+                                       error=error,
+                                       machine_id=machine_id,
+                                       id=id)
+            module_exec.db_parentType = parentType
+            module_exec.db_entity_id = entity_id
+            module_exec.db_entity_type = entity_type
+            module_exec.db_parent = parent
+            module_exec.is_dirty = False
+            res[('module_exec', id)] = module_exec
+        return res
+
+    def from_sql_fast(self, obj, all_objects):
+        if obj.db_parentType == 'workflow_exec':
+            p = all_objects[('workflow_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'group_exec':
+            p = all_objects[('group_exec', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        elif obj.db_parentType == 'loop_iteration':
+            p = all_objects[('loop_iteration', obj.db_parent)]
+            p.db_add_item_exec(obj)
+        
+    def set_sql_columns(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'module_name', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_cached') and obj.db_cached is not None:
+            columnMap['cached'] = \
+                self.convertToDB(obj.db_cached, 'int', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_module_name') and obj.db_module_name is not None:
+            columnMap['module_name'] = \
+                self.convertToDB(obj.db_module_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_machine_id') and obj.db_machine_id is not None:
+            columnMap['machine_id'] = \
+                self.convertToDB(obj.db_machine_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        lastId = self.executeSQL(db, dbCommand, False)
+        
+    def set_sql_command(self, db, obj, global_props, do_copy=True):
+        if not do_copy and not obj.is_dirty:
+            return None
+        columns = ['id', 'ts_start', 'ts_end', 'cached', 'module_id', 'module_name', 'completed', 'error', 'machine_id', 'parent_type', 'entity_id', 'entity_type', 'parent_id']
+        table = 'module_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        columnMap = {}
+        if hasattr(obj, 'db_id') and obj.db_id is not None:
+            columnMap['id'] = \
+                self.convertToDB(obj.db_id, 'long', 'int')
+        if hasattr(obj, 'db_ts_start') and obj.db_ts_start is not None:
+            columnMap['ts_start'] = \
+                self.convertToDB(obj.db_ts_start, 'datetime', 'datetime')
+        if hasattr(obj, 'db_ts_end') and obj.db_ts_end is not None:
+            columnMap['ts_end'] = \
+                self.convertToDB(obj.db_ts_end, 'datetime', 'datetime')
+        if hasattr(obj, 'db_cached') and obj.db_cached is not None:
+            columnMap['cached'] = \
+                self.convertToDB(obj.db_cached, 'int', 'int')
+        if hasattr(obj, 'db_module_id') and obj.db_module_id is not None:
+            columnMap['module_id'] = \
+                self.convertToDB(obj.db_module_id, 'long', 'int')
+        if hasattr(obj, 'db_module_name') and obj.db_module_name is not None:
+            columnMap['module_name'] = \
+                self.convertToDB(obj.db_module_name, 'str', 'varchar(255)')
+        if hasattr(obj, 'db_completed') and obj.db_completed is not None:
+            columnMap['completed'] = \
+                self.convertToDB(obj.db_completed, 'int', 'int')
+        if hasattr(obj, 'db_error') and obj.db_error is not None:
+            columnMap['error'] = \
+                self.convertToDB(obj.db_error, 'str', 'varchar(1023)')
+        if hasattr(obj, 'db_machine_id') and obj.db_machine_id is not None:
+            columnMap['machine_id'] = \
+                self.convertToDB(obj.db_machine_id, 'long', 'int')
+        if hasattr(obj, 'db_parentType') and obj.db_parentType is not None:
+            columnMap['parent_type'] = \
+                self.convertToDB(obj.db_parentType, 'str', 'char(32)')
+        if hasattr(obj, 'db_entity_id') and obj.db_entity_id is not None:
+            columnMap['entity_id'] = \
+                self.convertToDB(obj.db_entity_id, 'long', 'int')
+        if hasattr(obj, 'db_entity_type') and obj.db_entity_type is not None:
+            columnMap['entity_type'] = \
+                self.convertToDB(obj.db_entity_type, 'str', 'char(16)')
+        if hasattr(obj, 'db_parent') and obj.db_parent is not None:
+            columnMap['parent_id'] = \
+                self.convertToDB(obj.db_parent, 'long', 'long')
+        columnMap.update(global_props)
+
+        if obj.is_new or do_copy:
+            dbCommand = self.createSQLInsert(table, columnMap)
+        else:
+            dbCommand = self.createSQLUpdate(table, columnMap, whereMap)
+        return dbCommand
+
+    def set_sql_process(self, obj, global_props, lastId):
+        pass
+
+    def to_sql_fast(self, obj, do_copy=True):
+        for child in obj.db_annotations:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        for child in obj.db_loop_execs:
+            child.db_parentType = obj.vtType
+            child.db_parent = obj.db_id
+        
+    def delete_sql_column(self, db, obj, global_props):
+        table = 'module_exec'
+        whereMap = {}
+        whereMap.update(global_props)
+        if obj.db_id is not None:
+            keyStr = self.convertToDB(obj.db_id, 'long', 'int')
+            whereMap['id'] = keyStr
+        dbCommand = self.createSQLDelete(table, whereMap)
+        self.executeSQL(db, dbCommand, False)
+
+"""generated automatically by auto_dao.py"""
+
+class SQLDAOListBase(dict):
+
+    def __init__(self, daos=None):
+        if daos is not None:
+            dict.update(self, daos)
+
+        if 'mashup_alias' not in self:
+            self['mashup_alias'] = DBMashupAliasSQLDAOBase(self)
+        if 'group' not in self:
+            self['group'] = DBGroupSQLDAOBase(self)
+        if 'add' not in self:
+            self['add'] = DBAddSQLDAOBase(self)
+        if 'group_exec' not in self:
+            self['group_exec'] = DBGroupExecSQLDAOBase(self)
+        if 'parameter' not in self:
+            self['parameter'] = DBParameterSQLDAOBase(self)
+        if 'vistrail' not in self:
+            self['vistrail'] = DBVistrailSQLDAOBase(self)
+        if 'module' not in self:
+            self['module'] = DBModuleSQLDAOBase(self)
+        if 'port' not in self:
+            self['port'] = DBPortSQLDAOBase(self)
+        if 'pe_function' not in self:
+            self['pe_function'] = DBPEFunctionSQLDAOBase(self)
+        if 'workflow' not in self:
+            self['workflow'] = DBWorkflowSQLDAOBase(self)
+        if 'mashup_action' not in self:
+            self['mashup_action'] = DBMashupActionSQLDAOBase(self)
+        if 'change' not in self:
+            self['change'] = DBChangeSQLDAOBase(self)
+        if 'package' not in self:
+            self['package'] = DBPackageSQLDAOBase(self)
+        if 'loop_exec' not in self:
+            self['loop_exec'] = DBLoopExecSQLDAOBase(self)
+        if 'connection' not in self:
+            self['connection'] = DBConnectionSQLDAOBase(self)
+        if 'action' not in self:
+            self['action'] = DBActionSQLDAOBase(self)
+        if 'portSpec' not in self:
+            self['portSpec'] = DBPortSpecSQLDAOBase(self)
+        if 'log' not in self:
+            self['log'] = DBLogSQLDAOBase(self)
+        if 'loop_iteration' not in self:
+            self['loop_iteration'] = DBLoopIterationSQLDAOBase(self)
+        if 'pe_parameter' not in self:
+            self['pe_parameter'] = DBPEParameterSQLDAOBase(self)
+        if 'workflow_exec' not in self:
+            self['workflow_exec'] = DBWorkflowExecSQLDAOBase(self)
+        if 'location' not in self:
+            self['location'] = DBLocationSQLDAOBase(self)
+        if 'function' not in self:
+            self['function'] = DBFunctionSQLDAOBase(self)
+        if 'actionAnnotation' not in self:
+            self['actionAnnotation'] = DBActionAnnotationSQLDAOBase(self)
+        if 'controlParameter' not in self:
+            self['controlParameter'] = DBControlParameterSQLDAOBase(self)
+        if 'plugin_data' not in self:
+            self['plugin_data'] = DBPluginDataSQLDAOBase(self)
+        if 'delete' not in self:
+            self['delete'] = DBDeleteSQLDAOBase(self)
+        if 'vistrailVariable' not in self:
+            self['vistrailVariable'] = DBVistrailVariableSQLDAOBase(self)
+        if 'module_descriptor' not in self:
+            self['module_descriptor'] = DBModuleDescriptorSQLDAOBase(self)
+        if 'tag' not in self:
+            self['tag'] = DBTagSQLDAOBase(self)
+        if 'portSpecItem' not in self:
+            self['portSpecItem'] = DBPortSpecItemSQLDAOBase(self)
+        if 'mashup_component' not in self:
+            self['mashup_component'] = DBMashupComponentSQLDAOBase(self)
+        if 'mashup' not in self:
+            self['mashup'] = DBMashupSQLDAOBase(self)
+        if 'machine' not in self:
+            self['machine'] = DBMachineSQLDAOBase(self)
+        if 'other' not in self:
+            self['other'] = DBOtherSQLDAOBase(self)
+        if 'abstraction' not in self:
+            self['abstraction'] = DBAbstractionSQLDAOBase(self)
+        if 'mashuptrail' not in self:
+            self['mashuptrail'] = DBMashuptrailSQLDAOBase(self)
+        if 'registry' not in self:
+            self['registry'] = DBRegistrySQLDAOBase(self)
+        if 'annotation' not in self:
+            self['annotation'] = DBAnnotationSQLDAOBase(self)
+        if 'parameter_exploration' not in self:
+            self['parameter_exploration'] = DBParameterExplorationSQLDAOBase(self)
+        if 'mashup_actionAnnotation' not in self:
+            self['mashup_actionAnnotation'] = DBMashupActionAnnotationSQLDAOBase(self)
+        if 'module_exec' not in self:
+            self['module_exec'] = DBModuleExecSQLDAOBase(self)
diff --git a/vistrails/db/versions/v1_0_5/persistence/sql/sql_dao.py b/vistrails/db/versions/v1_0_5/persistence/sql/sql_dao.py
new file mode 100644
index 000000000..5bfc8d88a
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/sql/sql_dao.py
@@ -0,0 +1,263 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from datetime import date, datetime
+
+from vistrails.core import debug
+from vistrails.core.system import strftime, time_strptime
+from vistrails.db import VistrailsDBException
+from vistrails.db.services.io import get_db_lib
+
+class SQLDAO:
+    def __init__(self):
+        pass
+
+    def convertFromDB(self, value, type, db_type):
+        if value is not None:
+            if type == 'str':
+                return str(value)
+            elif type == 'long':
+                return long(value)
+            elif type == 'float':
+                return float(value)
+            elif type == 'int':
+                return int(value)
+            elif type == 'date':
+                if db_type == 'date':
+                    return value
+                else:
+                    return date(*time_strptime(str(value), '%Y-%m-%d')[0:3])
+            elif type == 'datetime':
+                if db_type == 'datetime':
+                    return value
+                else:
+                    return datetime(*time_strptime(str(value),
+                                                   '%Y-%m-%d %H:%M:%S')[0:6])
+        return None
+
+    def convertWarning(self, before, after, _from, to):
+        text = ["Value truncated when saving to database",
+                "%s truncated to %s\nwhile converting '%s' to '%s'"]
+        debug.warning(text[0], text[1] % (before, after, _from, to))
+
+    def convertToDB(self, value, type, db_type):
+        if value is not None:
+            if type == 'str':
+                value = str(value)
+                if db_type.startswith('varchar'):
+                    try:
+                        length = int(db_type[8:-1])
+                        if len(value) > length:
+                            self.convertWarning(value, value[:length],
+                                                type, db_type)
+                            value = value[:length]
+                    except Exception, e:
+                        pass
+                if db_type.startswith('char'):
+                    try:
+                        length = int(db_type[5:-1])
+                        if len(value) > length:
+                            self.convertWarning(value, value[:length],
+                                                type, db_type)
+                            value = value[:length]
+                    except Exception, e:
+                        pass
+                # return "'" + str(value).replace("'", "''") + "'"
+                return value
+            elif type == 'long':
+                return str(value)
+            elif type == 'float':
+                # necessary to avoid conversion warnings in MySQL
+                if db_type.startswith('DECIMAL'):
+                    try:
+                        value="%%.%sf"%str(db_type[8:-1].split(',')[1])%value
+                    except Exception, e:
+                        pass
+                return str(value)
+            elif type == 'int':
+                # note: on 64-bit machines int:s are 64-bit
+                MIN_INT = -2147483648
+                MAX_INT =  2147483647
+                if db_type == 'int':
+                    if int(value) < MIN_INT:
+                        self.convertWarning(value, MIN_INT, type, db_type)
+                        value = MIN_INT
+                    if int(value) > MAX_INT:
+                        self.convertWarning(value, MAX_INT, type, db_type)
+                        value = MAX_INT
+                return str(value)
+            elif type == 'date':
+                return value.isoformat()
+            elif type == 'datetime':
+                return strftime(value, '%Y-%m-%d %H:%M:%S')
+            else:
+                return str(value)
+
+        return None
+
+    def createSQLSelect(self, table, columns, whereMap, orderBy=None, 
+                        forUpdate=False):
+        columnStr = ', '.join(columns)
+        whereStr = ''
+        whereClause = ''
+        values = []
+        for column, value in whereMap.iteritems():
+            whereStr += '%s%s = %%s' % \
+                        (whereClause, column)
+            values.append(value)
+            whereClause = ' AND '
+        dbCommand = """SELECT %s FROM %s WHERE %s""" % \
+                    (columnStr, table, whereStr)
+        if orderBy is not None:
+            dbCommand += " ORDER BY " + orderBy
+        if forUpdate:
+            dbCommand += " FOR UPDATE"
+        dbCommand += ";"
+        return (dbCommand, tuple(values))
+
+    def createSQLInsert(self, table, columnMap):
+        columns = []
+        values = []
+        for column, value in columnMap.iteritems():
+            if value is None:
+                value = 'NULL'
+            columns.append(column)
+            values.append(value)
+        columnStr = ', '.join(columns)
+        # valueStr = '%s, '.join(values)
+        valueStr = ''
+        if len(values) > 1:
+            valueStr = '%s,' * (len(values) - 1) + '%s'
+        dbCommand = """INSERT INTO %s(%s) VALUES (%s);""" % \
+                    (table, columnStr, valueStr)
+        return (dbCommand, tuple(values))
+
+    def createSQLUpdate(self, table, columnMap, whereMap):
+        setStr = ''
+        comma = ''
+        values = []
+        for column, value in columnMap.iteritems():
+#            if value is None:
+#                value = 'NULL'
+            setStr += '%s%s = %%s' % (comma, column)
+            comma = ', '
+            values.append(value)
+        whereStr = ''
+        whereClause = ''
+        for column, value in whereMap.iteritems():
+            whereStr += '%s%s = %%s' % (whereClause, column)
+            values.append(value)
+            whereClause = ' AND '
+        dbCommand = """UPDATE %s SET %s WHERE %s;""" % \
+                    (table, setStr, whereStr)
+        return (dbCommand, tuple(values))
+
+    def createSQLDelete(self, table, whereMap):
+        whereStr = ''
+        whereClause = ''
+        values = []
+        for column, value in whereMap.iteritems():
+            whereStr += '%s %s = %%s' % (whereClause, column)
+            values.append(value)
+            whereClause = ' AND '
+        dbCommand = """DELETE FROM %s WHERE %s;""" % \
+            (table, whereStr)
+        return (dbCommand, tuple(values))
+
+    def executeSQL(self, db, cmd_tuple, isFetch):
+        dbCommand, values = cmd_tuple
+        # print 'db: %s' % dbCommand
+        # print 'values:', values
+        data = None
+        cursor = db.cursor()
+        try:
+            cursor.execute(dbCommand, values)
+            if isFetch:
+                data = cursor.fetchall()
+            else:
+                data = cursor.lastrowid
+        except Exception, e:
+            raise VistrailsDBException('Command "%s" with values "%s" '
+                                       'failed: %s' % (dbCommand, values, e))
+        finally:
+            cursor.close()
+        return data
+
+    def executeSQLGroup(self, db, dbCommandList, isFetch):
+        """ Executes a command consisting of multiple SELECT statements
+            It returns a list of results from the SELECT statements
+        """
+        data = []
+        # break up into bundles
+        BUNDLE_SIZE = 10000
+        num_commands = len(dbCommandList)
+        n = 0
+        while n<num_commands:
+            dbCommands = dbCommandList[n:(n+BUNDLE_SIZE)]
+            commandString = ''
+            for prepared, values in dbCommands:
+                command = prepared % \
+                          tuple(db.escape(v, get_db_lib().converters.conversions)
+                           for v in values)
+                commandString += command
+            cur = db.cursor()
+            try:
+                result = cur.execute(commandString)
+                while True:
+                    r = cur.fetchall() if isFetch else cur.lastrowid
+                    data.append(r)
+                    next = cur.nextset()
+                    if not next:
+                        break
+            except Exception, e:
+                raise VistrailsDBException('Command failed: %s -- """ %s """' % 
+                                           (e, commandString))
+            finally:
+                cur.close()
+            
+            n += BUNDLE_SIZE
+        return data
+
+    def start_transaction(self, db):
+        db.begin()
+
+    def commit_transaction(self, db):
+        db.commit()
+
+    def rollback_transaction(self, db):
+        db.rollback()
diff --git a/vistrails/db/versions/v1_0_5/persistence/xml/__init__.py b/vistrails/db/versions/v1_0_5/persistence/xml/__init__.py
new file mode 100644
index 000000000..aa8ef81e8
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/xml/__init__.py
@@ -0,0 +1,39 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+pass
\ No newline at end of file
diff --git a/vistrails/db/versions/v1_0_5/persistence/xml/auto_gen.py b/vistrails/db/versions/v1_0_5/persistence/xml/auto_gen.py
new file mode 100644
index 000000000..9045c7f86
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/xml/auto_gen.py
@@ -0,0 +1,6511 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+"""generated automatically by auto_dao.py"""
+
+from vistrails.core.system import get_elementtree_library
+ElementTree = get_elementtree_library()
+
+from xml_dao import XMLDAO
+from vistrails.db.versions.v1_0_5.domain import *
+
+class DBOpmWasGeneratedByXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'wasGeneratedBy':
+            return None
+        
+        effect = None
+        role = None
+        cause = None
+        accounts = []
+        opm_times = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'effect':
+                _data = self.getDao('opm_artifact_id_effect').fromXML(child)
+                effect = _data
+            elif child_tag == 'role':
+                _data = self.getDao('opm_role').fromXML(child)
+                role = _data
+            elif child_tag == 'cause':
+                _data = self.getDao('opm_process_id_cause').fromXML(child)
+                cause = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                opm_times.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmWasGeneratedBy(effect=effect,
+                                  role=role,
+                                  cause=cause,
+                                  accounts=accounts,
+                                  opm_times=opm_times)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_was_generated_by, node=None):
+        if node is None:
+            node = ElementTree.Element('wasGeneratedBy')
+        
+        # set elements
+        effect = opm_was_generated_by.db_effect
+        if effect is not None:
+            if (effect is not None) and (effect != ""):
+                childNode = ElementTree.SubElement(node, 'effect')
+                self.getDao('opm_artifact_id_effect').toXML(effect, childNode)
+        role = opm_was_generated_by.db_role
+        if role is not None:
+            if (role is not None) and (role != ""):
+                childNode = ElementTree.SubElement(node, 'role')
+                self.getDao('opm_role').toXML(role, childNode)
+        cause = opm_was_generated_by.db_cause
+        if cause is not None:
+            if (cause is not None) and (cause != ""):
+                childNode = ElementTree.SubElement(node, 'cause')
+                self.getDao('opm_process_id_cause').toXML(cause, childNode)
+        accounts = opm_was_generated_by.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        opm_times = opm_was_generated_by.db_opm_times
+        for opm_time in opm_times:
+            if (opm_times is not None) and (opm_times != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(opm_time, childNode)
+        
+        return node
+
+class DBConfigKeyXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'key':
+            return None
+        
+        # read attributes
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        value = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'str':
+                _data = self.getDao('config_str').fromXML(child)
+                value = _data
+            elif child_tag == 'int':
+                _data = self.getDao('config_int').fromXML(child)
+                value = _data
+            elif child_tag == 'float':
+                _data = self.getDao('config_float').fromXML(child)
+                value = _data
+            elif child_tag == 'bool':
+                _data = self.getDao('config_bool').fromXML(child)
+                value = _data
+            elif child_tag == 'configuration':
+                _data = self.getDao('configuration').fromXML(child)
+                value = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBConfigKey(value=value,
+                          name=name)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, config_key, node=None):
+        if node is None:
+            node = ElementTree.Element('key')
+        
+        # set attributes
+        node.set('name',self.convertToStr(config_key.db_name, 'str'))
+        
+        # set elements
+        value = config_key.db_value
+        if value is not None:
+            if value.vtType == 'config_str':
+                childNode = ElementTree.SubElement(node, 'str')
+                self.getDao('config_str').toXML(value, childNode)
+            elif value.vtType == 'config_int':
+                childNode = ElementTree.SubElement(node, 'int')
+                self.getDao('config_int').toXML(value, childNode)
+            elif value.vtType == 'config_float':
+                childNode = ElementTree.SubElement(node, 'float')
+                self.getDao('config_float').toXML(value, childNode)
+            elif value.vtType == 'config_bool':
+                childNode = ElementTree.SubElement(node, 'bool')
+                self.getDao('config_bool').toXML(value, childNode)
+            elif value.vtType == 'configuration':
+                childNode = ElementTree.SubElement(node, 'configuration')
+                self.getDao('configuration').toXML(value, childNode)
+        
+        return node
+
+class DBMashupAliasXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'alias':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        component = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'component':
+                _data = self.getDao('mashup_component').fromXML(child)
+                component = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBMashupAlias(id=id,
+                            name=name,
+                            component=component)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashup_alias, node=None):
+        if node is None:
+            node = ElementTree.Element('alias')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashup_alias.db_id, 'long'))
+        node.set('name',self.convertToStr(mashup_alias.db_name, 'str'))
+        
+        # set elements
+        component = mashup_alias.db_component
+        if component is not None:
+            if (component is not None) and (component != ""):
+                childNode = ElementTree.SubElement(node, 'component')
+                self.getDao('mashup_component').toXML(component, childNode)
+        
+        return node
+
+class DBGroupXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'group':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('cache', None)
+        cache = self.convertFromStr(data, 'int')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        
+        workflow = None
+        location = None
+        functions = []
+        annotations = []
+        controlParameters = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'workflow':
+                _data = self.getDao('workflow').fromXML(child)
+                workflow = _data
+            elif child_tag == 'location':
+                _data = self.getDao('location').fromXML(child)
+                location = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                functions.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                controlParameters.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBGroup(id=id,
+                      workflow=workflow,
+                      cache=cache,
+                      name=name,
+                      namespace=namespace,
+                      package=package,
+                      version=version,
+                      location=location,
+                      functions=functions,
+                      annotations=annotations,
+                      controlParameters=controlParameters)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, group, node=None):
+        if node is None:
+            node = ElementTree.Element('group')
+        
+        # set attributes
+        node.set('id',self.convertToStr(group.db_id, 'long'))
+        node.set('cache',self.convertToStr(group.db_cache, 'int'))
+        node.set('name',self.convertToStr(group.db_name, 'str'))
+        node.set('namespace',self.convertToStr(group.db_namespace, 'str'))
+        node.set('package',self.convertToStr(group.db_package, 'str'))
+        node.set('version',self.convertToStr(group.db_version, 'str'))
+        
+        # set elements
+        workflow = group.db_workflow
+        if workflow is not None:
+            if (workflow is not None) and (workflow != ""):
+                childNode = ElementTree.SubElement(node, 'workflow')
+                self.getDao('workflow').toXML(workflow, childNode)
+        location = group.db_location
+        if location is not None:
+            if (location is not None) and (location != ""):
+                childNode = ElementTree.SubElement(node, 'location')
+                self.getDao('location').toXML(location, childNode)
+        functions = group.db_functions
+        for function in functions:
+            if (functions is not None) and (functions != ""):
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(function, childNode)
+        annotations = group.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        controlParameters = group.db_controlParameters
+        for controlParameter in controlParameters:
+            if (controlParameters is not None) and (controlParameters != ""):
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(controlParameter, childNode)
+        
+        return node
+
+class DBOpmWasControlledByXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'wasControlledBy':
+            return None
+        
+        effect = None
+        role = None
+        cause = None
+        accounts = []
+        starts = []
+        ends = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'effect':
+                _data = self.getDao('opm_process_id_effect').fromXML(child)
+                effect = _data
+            elif child_tag == 'role':
+                _data = self.getDao('opm_role').fromXML(child)
+                role = _data
+            elif child_tag == 'agent':
+                _data = self.getDao('opm_agent_id').fromXML(child)
+                cause = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                starts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                ends.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmWasControlledBy(effect=effect,
+                                   role=role,
+                                   cause=cause,
+                                   accounts=accounts,
+                                   starts=starts,
+                                   ends=ends)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_was_controlled_by, node=None):
+        if node is None:
+            node = ElementTree.Element('wasControlledBy')
+        
+        # set elements
+        effect = opm_was_controlled_by.db_effect
+        if effect is not None:
+            if (effect is not None) and (effect != ""):
+                childNode = ElementTree.SubElement(node, 'effect')
+                self.getDao('opm_process_id_effect').toXML(effect, childNode)
+        role = opm_was_controlled_by.db_role
+        if role is not None:
+            if (role is not None) and (role != ""):
+                childNode = ElementTree.SubElement(node, 'role')
+                self.getDao('opm_role').toXML(role, childNode)
+        cause = opm_was_controlled_by.db_cause
+        if cause is not None:
+            if (cause is not None) and (cause != ""):
+                childNode = ElementTree.SubElement(node, 'agent')
+                self.getDao('opm_agent_id').toXML(cause, childNode)
+        accounts = opm_was_controlled_by.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        starts = opm_was_controlled_by.db_starts
+        for start in starts:
+            if (starts is not None) and (starts != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(start, childNode)
+        ends = opm_was_controlled_by.db_ends
+        for end in ends:
+            if (ends is not None) and (ends != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(end, childNode)
+        
+        return node
+
+class DBAddXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'add':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('what', None)
+        what = self.convertFromStr(data, 'str')
+        data = node.get('objectId', None)
+        objectId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjId', None)
+        parentObjId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjType', None)
+        parentObjType = self.convertFromStr(data, 'str')
+        
+        data = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'module':
+                _data = self.getDao('module').fromXML(child)
+                data = _data
+            elif child_tag == 'location':
+                _data = self.getDao('location').fromXML(child)
+                data = _data
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                data = _data
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                data = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                data = _data
+            elif child_tag == 'connection':
+                _data = self.getDao('connection').fromXML(child)
+                data = _data
+            elif child_tag == 'port':
+                _data = self.getDao('port').fromXML(child)
+                data = _data
+            elif child_tag == 'parameter':
+                _data = self.getDao('parameter').fromXML(child)
+                data = _data
+            elif child_tag == 'portSpec':
+                _data = self.getDao('portSpec').fromXML(child)
+                data = _data
+            elif child_tag == 'abstraction':
+                _data = self.getDao('abstraction').fromXML(child)
+                data = _data
+            elif child_tag == 'group':
+                _data = self.getDao('group').fromXML(child)
+                data = _data
+            elif child_tag == 'other':
+                _data = self.getDao('other').fromXML(child)
+                data = _data
+            elif child_tag == 'plugin_data':
+                _data = self.getDao('plugin_data').fromXML(child)
+                data = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBAdd(data=data,
+                    id=id,
+                    what=what,
+                    objectId=objectId,
+                    parentObjId=parentObjId,
+                    parentObjType=parentObjType)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, add, node=None):
+        if node is None:
+            node = ElementTree.Element('add')
+        
+        # set attributes
+        node.set('id',self.convertToStr(add.db_id, 'long'))
+        node.set('what',self.convertToStr(add.db_what, 'str'))
+        node.set('objectId',self.convertToStr(add.db_objectId, 'long'))
+        node.set('parentObjId',self.convertToStr(add.db_parentObjId, 'long'))
+        node.set('parentObjType',self.convertToStr(add.db_parentObjType, 'str'))
+        
+        # set elements
+        data = add.db_data
+        if data is not None:
+            if data.vtType == 'module':
+                childNode = ElementTree.SubElement(node, 'module')
+                self.getDao('module').toXML(data, childNode)
+            elif data.vtType == 'location':
+                childNode = ElementTree.SubElement(node, 'location')
+                self.getDao('location').toXML(data, childNode)
+            elif data.vtType == 'annotation':
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(data, childNode)
+            elif data.vtType == 'controlParameter':
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(data, childNode)
+            elif data.vtType == 'function':
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(data, childNode)
+            elif data.vtType == 'connection':
+                childNode = ElementTree.SubElement(node, 'connection')
+                self.getDao('connection').toXML(data, childNode)
+            elif data.vtType == 'port':
+                childNode = ElementTree.SubElement(node, 'port')
+                self.getDao('port').toXML(data, childNode)
+            elif data.vtType == 'parameter':
+                childNode = ElementTree.SubElement(node, 'parameter')
+                self.getDao('parameter').toXML(data, childNode)
+            elif data.vtType == 'portSpec':
+                childNode = ElementTree.SubElement(node, 'portSpec')
+                self.getDao('portSpec').toXML(data, childNode)
+            elif data.vtType == 'abstraction':
+                childNode = ElementTree.SubElement(node, 'abstraction')
+                self.getDao('abstraction').toXML(data, childNode)
+            elif data.vtType == 'group':
+                childNode = ElementTree.SubElement(node, 'group')
+                self.getDao('group').toXML(data, childNode)
+            elif data.vtType == 'other':
+                childNode = ElementTree.SubElement(node, 'other')
+                self.getDao('other').toXML(data, childNode)
+            elif data.vtType == 'plugin_data':
+                childNode = ElementTree.SubElement(node, 'plugin_data')
+                self.getDao('plugin_data').toXML(data, childNode)
+        
+        return node
+
+class DBProvGenerationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:wasGeneratedBy':
+            return None
+        
+        prov_entity = None
+        prov_activity = None
+        prov_role = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:entity':
+                _data = self.getDao('ref_prov_entity').fromXML(child)
+                prov_entity = _data
+            elif child_tag == 'prov:activity':
+                _data = self.getDao('ref_prov_activity').fromXML(child)
+                prov_activity = _data
+            elif child_tag == 'prov:role':
+                _data = self.convertFromStr(child.text,'str')
+                prov_role = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvGeneration(prov_entity=prov_entity,
+                               prov_activity=prov_activity,
+                               prov_role=prov_role)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_generation, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:wasGeneratedBy')
+        
+        # set elements
+        prov_entity = prov_generation.db_prov_entity
+        if prov_entity is not None:
+            if (prov_entity is not None) and (prov_entity != ""):
+                childNode = ElementTree.SubElement(node, 'prov:entity')
+                self.getDao('ref_prov_entity').toXML(prov_entity, childNode)
+        prov_activity = prov_generation.db_prov_activity
+        if prov_activity is not None:
+            if (prov_activity is not None) and (prov_activity != ""):
+                childNode = ElementTree.SubElement(node, 'prov:activity')
+                self.getDao('ref_prov_activity').toXML(prov_activity, childNode)
+        prov_role = prov_generation.db_prov_role
+        if (prov_role is not None) and (prov_role != ""):
+            childNode = ElementTree.SubElement(node, 'prov:role')
+            childNode.text = self.convertToStr(prov_role, 'str')
+        
+        return node
+
+class DBOpmUsedXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'used':
+            return None
+        
+        effect = None
+        role = None
+        cause = None
+        accounts = []
+        opm_times = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'effect':
+                _data = self.getDao('opm_process_id_effect').fromXML(child)
+                effect = _data
+            elif child_tag == 'role':
+                _data = self.getDao('opm_role').fromXML(child)
+                role = _data
+            elif child_tag == 'cause':
+                _data = self.getDao('opm_artifact_id_cause').fromXML(child)
+                cause = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                opm_times.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmUsed(effect=effect,
+                        role=role,
+                        cause=cause,
+                        accounts=accounts,
+                        opm_times=opm_times)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_used, node=None):
+        if node is None:
+            node = ElementTree.Element('used')
+        
+        # set elements
+        effect = opm_used.db_effect
+        if effect is not None:
+            if (effect is not None) and (effect != ""):
+                childNode = ElementTree.SubElement(node, 'effect')
+                self.getDao('opm_process_id_effect').toXML(effect, childNode)
+        role = opm_used.db_role
+        if role is not None:
+            if (role is not None) and (role != ""):
+                childNode = ElementTree.SubElement(node, 'role')
+                self.getDao('opm_role').toXML(role, childNode)
+        cause = opm_used.db_cause
+        if cause is not None:
+            if (cause is not None) and (cause != ""):
+                childNode = ElementTree.SubElement(node, 'cause')
+                self.getDao('opm_artifact_id_cause').toXML(cause, childNode)
+        accounts = opm_used.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        opm_times = opm_used.db_opm_times
+        for opm_time in opm_times:
+            if (opm_times is not None) and (opm_times != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(opm_time, childNode)
+        
+        return node
+
+class DBOpmArtifactIdCauseXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'cause':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmArtifactIdCause(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_artifact_id_cause, node=None):
+        if node is None:
+            node = ElementTree.Element('cause')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_artifact_id_cause.db_id, 'str'))
+        
+        return node
+
+class DBRefProvEntityXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:entity':
+            return None
+        
+        # read attributes
+        data = node.get('prov:ref', None)
+        prov_ref = self.convertFromStr(data, 'str')
+        
+        obj = DBRefProvEntity(prov_ref=prov_ref)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, ref_prov_entity, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:entity')
+        
+        # set attributes
+        node.set('prov:ref',self.convertToStr(ref_prov_entity.db_prov_ref, 'str'))
+        
+        return node
+
+class DBVtConnectionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'vt:connection':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        vt_source = None
+        vt_dest = None
+        vt_source_port = None
+        vt_dest_port = None
+        vt_source_signature = None
+        vt_dest_signature = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'vt:source':
+                _data = self.convertFromStr(child.text,'str')
+                vt_source = _data
+            elif child_tag == 'vt:dest':
+                _data = self.convertFromStr(child.text,'str')
+                vt_dest = _data
+            elif child_tag == 'vt:source_port':
+                _data = self.convertFromStr(child.text,'str')
+                vt_source_port = _data
+            elif child_tag == 'vt:dest_port':
+                _data = self.convertFromStr(child.text,'str')
+                vt_dest_port = _data
+            elif child_tag == 'vt:source_signature':
+                _data = self.convertFromStr(child.text,'str')
+                vt_source_signature = _data
+            elif child_tag == 'vt:dest_signature':
+                _data = self.convertFromStr(child.text,'str')
+                vt_dest_signature = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBVtConnection(id=id,
+                             vt_source=vt_source,
+                             vt_dest=vt_dest,
+                             vt_source_port=vt_source_port,
+                             vt_dest_port=vt_dest_port,
+                             vt_source_signature=vt_source_signature,
+                             vt_dest_signature=vt_dest_signature)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, vt_connection, node=None):
+        if node is None:
+            node = ElementTree.Element('vt:connection')
+        
+        # set attributes
+        node.set('id',self.convertToStr(vt_connection.db_id, 'str'))
+        
+        # set elements
+        vt_source = vt_connection.db_vt_source
+        if (vt_source is not None) and (vt_source != ""):
+            childNode = ElementTree.SubElement(node, 'vt:source')
+            childNode.text = self.convertToStr(vt_source, 'str')
+        vt_dest = vt_connection.db_vt_dest
+        if (vt_dest is not None) and (vt_dest != ""):
+            childNode = ElementTree.SubElement(node, 'vt:dest')
+            childNode.text = self.convertToStr(vt_dest, 'str')
+        vt_source_port = vt_connection.db_vt_source_port
+        if (vt_source_port is not None) and (vt_source_port != ""):
+            childNode = ElementTree.SubElement(node, 'vt:source_port')
+            childNode.text = self.convertToStr(vt_source_port, 'str')
+        vt_dest_port = vt_connection.db_vt_dest_port
+        if (vt_dest_port is not None) and (vt_dest_port != ""):
+            childNode = ElementTree.SubElement(node, 'vt:dest_port')
+            childNode.text = self.convertToStr(vt_dest_port, 'str')
+        vt_source_signature = vt_connection.db_vt_source_signature
+        if (vt_source_signature is not None) and (vt_source_signature != ""):
+            childNode = ElementTree.SubElement(node, 'vt:source_signature')
+            childNode.text = self.convertToStr(vt_source_signature, 'str')
+        vt_dest_signature = vt_connection.db_vt_dest_signature
+        if (vt_dest_signature is not None) and (vt_dest_signature != ""):
+            childNode = ElementTree.SubElement(node, 'vt:dest_signature')
+            childNode.text = self.convertToStr(vt_dest_signature, 'str')
+        
+        return node
+
+class DBOpmAccountXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'account':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        value = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'value':
+                _data = self.convertFromStr(child.text,'str')
+                value = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmAccount(id=id,
+                           value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_account, node=None):
+        if node is None:
+            node = ElementTree.Element('account')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_account.db_id, 'str'))
+        
+        # set elements
+        value = opm_account.db_value
+        if (value is not None) and (value != ""):
+            childNode = ElementTree.SubElement(node, 'value')
+            childNode.text = self.convertToStr(value, 'str')
+        
+        return node
+
+class DBGroupExecXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'groupExec':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('tsStart', None)
+        ts_start = self.convertFromStr(data, 'datetime')
+        data = node.get('tsEnd', None)
+        ts_end = self.convertFromStr(data, 'datetime')
+        data = node.get('cached', None)
+        cached = self.convertFromStr(data, 'int')
+        data = node.get('moduleId', None)
+        module_id = self.convertFromStr(data, 'long')
+        data = node.get('groupName', None)
+        group_name = self.convertFromStr(data, 'str')
+        data = node.get('groupType', None)
+        group_type = self.convertFromStr(data, 'str')
+        data = node.get('completed', None)
+        completed = self.convertFromStr(data, 'int')
+        data = node.get('error', None)
+        error = self.convertFromStr(data, 'str')
+        data = node.get('machine_id', None)
+        machine_id = self.convertFromStr(data, 'long')
+        
+        annotations = []
+        item_execs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'moduleExec':
+                _data = self.getDao('module_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'groupExec':
+                _data = self.getDao('group_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'loopExec':
+                _data = self.getDao('loop_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBGroupExec(item_execs=item_execs,
+                          id=id,
+                          ts_start=ts_start,
+                          ts_end=ts_end,
+                          cached=cached,
+                          module_id=module_id,
+                          group_name=group_name,
+                          group_type=group_type,
+                          completed=completed,
+                          error=error,
+                          machine_id=machine_id,
+                          annotations=annotations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, group_exec, node=None):
+        if node is None:
+            node = ElementTree.Element('groupExec')
+        
+        # set attributes
+        node.set('id',self.convertToStr(group_exec.db_id, 'long'))
+        node.set('tsStart',self.convertToStr(group_exec.db_ts_start, 'datetime'))
+        node.set('tsEnd',self.convertToStr(group_exec.db_ts_end, 'datetime'))
+        node.set('cached',self.convertToStr(group_exec.db_cached, 'int'))
+        node.set('moduleId',self.convertToStr(group_exec.db_module_id, 'long'))
+        node.set('groupName',self.convertToStr(group_exec.db_group_name, 'str'))
+        node.set('groupType',self.convertToStr(group_exec.db_group_type, 'str'))
+        node.set('completed',self.convertToStr(group_exec.db_completed, 'int'))
+        node.set('error',self.convertToStr(group_exec.db_error, 'str'))
+        node.set('machine_id',self.convertToStr(group_exec.db_machine_id, 'long'))
+        
+        # set elements
+        annotations = group_exec.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        item_execs = group_exec.db_item_execs
+        for item_exec in item_execs:
+            if item_exec.vtType == 'module_exec':
+                childNode = ElementTree.SubElement(node, 'moduleExec')
+                self.getDao('module_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'group_exec':
+                childNode = ElementTree.SubElement(node, 'groupExec')
+                self.getDao('group_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'loop_exec':
+                childNode = ElementTree.SubElement(node, 'loopExec')
+                self.getDao('loop_exec').toXML(item_exec, childNode)
+        
+        return node
+
+class DBOpmAgentIdXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'agent':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmAgentId(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_agent_id, node=None):
+        if node is None:
+            node = ElementTree.Element('agent')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_agent_id.db_id, 'str'))
+        
+        return node
+
+class DBParameterXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'parameter':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('pos', None)
+        pos = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('type', None)
+        type = self.convertFromStr(data, 'str')
+        data = node.get('val', None)
+        val = self.convertFromStr(data, 'str')
+        data = node.get('alias', None)
+        alias = self.convertFromStr(data, 'str')
+        
+        obj = DBParameter(id=id,
+                          pos=pos,
+                          name=name,
+                          type=type,
+                          val=val,
+                          alias=alias)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, parameter, node=None):
+        if node is None:
+            node = ElementTree.Element('parameter')
+        
+        # set attributes
+        node.set('id',self.convertToStr(parameter.db_id, 'long'))
+        node.set('pos',self.convertToStr(parameter.db_pos, 'long'))
+        node.set('name',self.convertToStr(parameter.db_name, 'str'))
+        node.set('type',self.convertToStr(parameter.db_type, 'str'))
+        node.set('val',self.convertToStr(parameter.db_val, 'str'))
+        node.set('alias',self.convertToStr(parameter.db_alias, 'str'))
+        
+        return node
+
+class DBVistrailXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'vistrail':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        actions = []
+        tags = []
+        annotations = []
+        controlParameters = []
+        vistrailVariables = []
+        parameter_explorations = []
+        actionAnnotations = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'action':
+                _data = self.getDao('action').fromXML(child)
+                actions.append(_data)
+            elif child_tag == 'tag':
+                _data = self.getDao('tag').fromXML(child)
+                tags.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                controlParameters.append(_data)
+            elif child_tag == 'vistrailVariable':
+                _data = self.getDao('vistrailVariable').fromXML(child)
+                vistrailVariables.append(_data)
+            elif child_tag == 'parameterExploration':
+                _data = self.getDao('parameter_exploration').fromXML(child)
+                parameter_explorations.append(_data)
+            elif child_tag == 'actionAnnotation':
+                _data = self.getDao('actionAnnotation').fromXML(child)
+                actionAnnotations.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBVistrail(id=id,
+                         version=version,
+                         name=name,
+                         actions=actions,
+                         tags=tags,
+                         annotations=annotations,
+                         controlParameters=controlParameters,
+                         vistrailVariables=vistrailVariables,
+                         parameter_explorations=parameter_explorations,
+                         actionAnnotations=actionAnnotations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, vistrail, node=None):
+        if node is None:
+            node = ElementTree.Element('vistrail')
+        
+        # set attributes
+        node.set('id',self.convertToStr(vistrail.db_id, 'long'))
+        node.set('version',self.convertToStr(vistrail.db_version, 'str'))
+        node.set('name',self.convertToStr(vistrail.db_name, 'str'))
+        
+        # set elements
+        actions = vistrail.db_actions
+        for action in actions:
+            if (actions is not None) and (actions != ""):
+                childNode = ElementTree.SubElement(node, 'action')
+                self.getDao('action').toXML(action, childNode)
+        tags = vistrail.db_tags
+        for tag in tags:
+            if (tags is not None) and (tags != ""):
+                childNode = ElementTree.SubElement(node, 'tag')
+                self.getDao('tag').toXML(tag, childNode)
+        annotations = vistrail.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        controlParameters = vistrail.db_controlParameters
+        for controlParameter in controlParameters:
+            if (controlParameters is not None) and (controlParameters != ""):
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(controlParameter, childNode)
+        vistrailVariables = vistrail.db_vistrailVariables
+        for vistrailVariable in vistrailVariables:
+            if (vistrailVariables is not None) and (vistrailVariables != ""):
+                childNode = ElementTree.SubElement(node, 'vistrailVariable')
+                self.getDao('vistrailVariable').toXML(vistrailVariable, childNode)
+        parameter_explorations = vistrail.db_parameter_explorations
+        for parameter_exploration in parameter_explorations:
+            if (parameter_explorations is not None) and (parameter_explorations != ""):
+                childNode = ElementTree.SubElement(node, 'parameterExploration')
+                self.getDao('parameter_exploration').toXML(parameter_exploration, childNode)
+        actionAnnotations = vistrail.db_actionAnnotations
+        for actionAnnotation in actionAnnotations:
+            if (actionAnnotations is not None) and (actionAnnotations != ""):
+                childNode = ElementTree.SubElement(node, 'actionAnnotation')
+                self.getDao('actionAnnotation').toXML(actionAnnotation, childNode)
+        
+        return node
+
+class DBOpmArtifactValueXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'value':
+            return None
+        
+        value = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'portSpec':
+                _data = self.getDao('portSpec').fromXML(child)
+                value = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                value = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmArtifactValue(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_artifact_value, node=None):
+        if node is None:
+            node = ElementTree.Element('value')
+        
+        # set elements
+        value = opm_artifact_value.db_value
+        if value is not None:
+            if value.vtType == 'portSpec':
+                childNode = ElementTree.SubElement(node, 'portSpec')
+                self.getDao('portSpec').toXML(value, childNode)
+            elif value.vtType == 'function':
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(value, childNode)
+        
+        return node
+
+class DBConfigStrXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'str':
+            return None
+        
+        # read attributes
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBConfigStr(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, config_str, node=None):
+        if node is None:
+            node = ElementTree.Element('str')
+        
+        # set attributes
+        node.set('value',self.convertToStr(config_str.db_value, 'str'))
+        
+        return node
+
+class DBStartupXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'startup':
+            return None
+        
+        # read attributes
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        
+        configuration = None
+        enabled_packages = None
+        disabled_packages = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'configuration':
+                _data = self.getDao('configuration').fromXML(child)
+                configuration = _data
+            elif child_tag == 'packages':
+                _data = self.getDao('enabled_packages').fromXML(child)
+                enabled_packages = _data
+            elif child_tag == 'disabledpackages':
+                _data = self.getDao('disabled_packages').fromXML(child)
+                disabled_packages = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBStartup(version=version,
+                        configuration=configuration,
+                        enabled_packages=enabled_packages,
+                        disabled_packages=disabled_packages)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, startup, node=None):
+        if node is None:
+            node = ElementTree.Element('startup')
+        
+        # set attributes
+        node.set('version',self.convertToStr(startup.db_version, 'str'))
+        
+        # set elements
+        configuration = startup.db_configuration
+        if configuration is not None:
+            if (configuration is not None) and (configuration != ""):
+                childNode = ElementTree.SubElement(node, 'configuration')
+                self.getDao('configuration').toXML(configuration, childNode)
+        enabled_packages = startup.db_enabled_packages
+        if enabled_packages is not None:
+            if (enabled_packages is not None) and (enabled_packages != ""):
+                childNode = ElementTree.SubElement(node, 'packages')
+                self.getDao('enabled_packages').toXML(enabled_packages, childNode)
+        disabled_packages = startup.db_disabled_packages
+        if disabled_packages is not None:
+            if (disabled_packages is not None) and (disabled_packages != ""):
+                childNode = ElementTree.SubElement(node, 'disabledpackages')
+                self.getDao('disabled_packages').toXML(disabled_packages, childNode)
+        
+        return node
+
+class DBModuleXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'module':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('cache', None)
+        cache = self.convertFromStr(data, 'int')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        
+        location = None
+        functions = []
+        annotations = []
+        controlParameters = []
+        portSpecs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'location':
+                _data = self.getDao('location').fromXML(child)
+                location = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                functions.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                controlParameters.append(_data)
+            elif child_tag == 'portSpec':
+                _data = self.getDao('portSpec').fromXML(child)
+                portSpecs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBModule(id=id,
+                       cache=cache,
+                       name=name,
+                       namespace=namespace,
+                       package=package,
+                       version=version,
+                       location=location,
+                       functions=functions,
+                       annotations=annotations,
+                       controlParameters=controlParameters,
+                       portSpecs=portSpecs)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, module, node=None):
+        if node is None:
+            node = ElementTree.Element('module')
+        
+        # set attributes
+        node.set('id',self.convertToStr(module.db_id, 'long'))
+        node.set('cache',self.convertToStr(module.db_cache, 'int'))
+        node.set('name',self.convertToStr(module.db_name, 'str'))
+        node.set('namespace',self.convertToStr(module.db_namespace, 'str'))
+        node.set('package',self.convertToStr(module.db_package, 'str'))
+        node.set('version',self.convertToStr(module.db_version, 'str'))
+        
+        # set elements
+        location = module.db_location
+        if location is not None:
+            if (location is not None) and (location != ""):
+                childNode = ElementTree.SubElement(node, 'location')
+                self.getDao('location').toXML(location, childNode)
+        functions = module.db_functions
+        for function in functions:
+            if (functions is not None) and (functions != ""):
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(function, childNode)
+        annotations = module.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        controlParameters = module.db_controlParameters
+        for controlParameter in controlParameters:
+            if (controlParameters is not None) and (controlParameters != ""):
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(controlParameter, childNode)
+        portSpecs = module.db_portSpecs
+        for portSpec in portSpecs:
+            if (portSpecs is not None) and (portSpecs != ""):
+                childNode = ElementTree.SubElement(node, 'portSpec')
+                self.getDao('portSpec').toXML(portSpec, childNode)
+        
+        return node
+
+class DBPortXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'port':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('type', None)
+        type = self.convertFromStr(data, 'str')
+        data = node.get('moduleId', None)
+        moduleId = self.convertFromStr(data, 'long')
+        data = node.get('moduleName', None)
+        moduleName = self.convertFromStr(data, 'str')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('signature', None)
+        signature = self.convertFromStr(data, 'str')
+        
+        obj = DBPort(id=id,
+                     type=type,
+                     moduleId=moduleId,
+                     moduleName=moduleName,
+                     name=name,
+                     signature=signature)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, port, node=None):
+        if node is None:
+            node = ElementTree.Element('port')
+        
+        # set attributes
+        node.set('id',self.convertToStr(port.db_id, 'long'))
+        node.set('type',self.convertToStr(port.db_type, 'str'))
+        node.set('moduleId',self.convertToStr(port.db_moduleId, 'long'))
+        node.set('moduleName',self.convertToStr(port.db_moduleName, 'str'))
+        node.set('name',self.convertToStr(port.db_name, 'str'))
+        node.set('signature',self.convertToStr(port.db_signature, 'str'))
+        
+        return node
+
+class DBOpmAgentsXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'agents':
+            return None
+        
+        agents = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'agent':
+                _data = self.getDao('opm_agent').fromXML(child)
+                agents.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmAgents(agents=agents)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_agents, node=None):
+        if node is None:
+            node = ElementTree.Element('agents')
+        
+        # set elements
+        agents = opm_agents.db_agents
+        for agent in agents:
+            if (agents is not None) and (agents != ""):
+                childNode = ElementTree.SubElement(node, 'agent')
+                self.getDao('opm_agent').toXML(agent, childNode)
+        
+        return node
+
+class DBOpmDependenciesXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'causalDependencies':
+            return None
+        
+        dependencys = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'used':
+                _data = self.getDao('opm_used').fromXML(child)
+                dependencys.append(_data)
+            elif child_tag == 'wasGeneratedBy':
+                _data = self.getDao('opm_was_generated_by').fromXML(child)
+                dependencys.append(_data)
+            elif child_tag == 'wasTriggeredBy':
+                _data = self.getDao('opm_was_triggered_by').fromXML(child)
+                dependencys.append(_data)
+            elif child_tag == 'wasDerivedFrom':
+                _data = self.getDao('opm_was_derived_from').fromXML(child)
+                dependencys.append(_data)
+            elif child_tag == 'wasControlledBy':
+                _data = self.getDao('opm_was_controlled_by').fromXML(child)
+                dependencys.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmDependencies(dependencys=dependencys)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_dependencies, node=None):
+        if node is None:
+            node = ElementTree.Element('causalDependencies')
+        
+        # set elements
+        dependencys = opm_dependencies.db_dependencys
+        for dependency in dependencys:
+            if dependency.vtType == 'opm_used':
+                childNode = ElementTree.SubElement(node, 'used')
+                self.getDao('opm_used').toXML(dependency, childNode)
+            elif dependency.vtType == 'opm_was_generated_by':
+                childNode = ElementTree.SubElement(node, 'wasGeneratedBy')
+                self.getDao('opm_was_generated_by').toXML(dependency, childNode)
+            elif dependency.vtType == 'opm_was_triggered_by':
+                childNode = ElementTree.SubElement(node, 'wasTriggeredBy')
+                self.getDao('opm_was_triggered_by').toXML(dependency, childNode)
+            elif dependency.vtType == 'opm_was_derived_from':
+                childNode = ElementTree.SubElement(node, 'wasDerivedFrom')
+                self.getDao('opm_was_derived_from').toXML(dependency, childNode)
+            elif dependency.vtType == 'opm_was_controlled_by':
+                childNode = ElementTree.SubElement(node, 'wasControlledBy')
+                self.getDao('opm_was_controlled_by').toXML(dependency, childNode)
+        
+        return node
+
+class DBPEFunctionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'peFunction':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('moduleId', None)
+        module_id = self.convertFromStr(data, 'long')
+        data = node.get('port_name', None)
+        port_name = self.convertFromStr(data, 'str')
+        data = node.get('is_alias', None)
+        is_alias = self.convertFromStr(data, 'long')
+        
+        parameters = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'peParameter':
+                _data = self.getDao('pe_parameter').fromXML(child)
+                parameters.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBPEFunction(id=id,
+                           module_id=module_id,
+                           port_name=port_name,
+                           is_alias=is_alias,
+                           parameters=parameters)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, pe_function, node=None):
+        if node is None:
+            node = ElementTree.Element('peFunction')
+        
+        # set attributes
+        node.set('id',self.convertToStr(pe_function.db_id, 'long'))
+        node.set('moduleId',self.convertToStr(pe_function.db_module_id, 'long'))
+        node.set('port_name',self.convertToStr(pe_function.db_port_name, 'str'))
+        node.set('is_alias',self.convertToStr(pe_function.db_is_alias, 'long'))
+        
+        # set elements
+        parameters = pe_function.db_parameters
+        for parameter in parameters:
+            if (parameters is not None) and (parameters != ""):
+                childNode = ElementTree.SubElement(node, 'peParameter')
+                self.getDao('pe_parameter').toXML(parameter, childNode)
+        
+        return node
+
+class DBWorkflowXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'workflow':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('vistrail_id', None)
+        vistrail_id = self.convertFromStr(data, 'long')
+        
+        connections = []
+        annotations = []
+        plugin_datas = []
+        others = []
+        modules = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'connection':
+                _data = self.getDao('connection').fromXML(child)
+                connections.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'plugin_data':
+                _data = self.getDao('plugin_data').fromXML(child)
+                plugin_datas.append(_data)
+            elif child_tag == 'other':
+                _data = self.getDao('other').fromXML(child)
+                others.append(_data)
+            elif child_tag == 'module':
+                _data = self.getDao('module').fromXML(child)
+                modules.append(_data)
+            elif child_tag == 'abstraction':
+                _data = self.getDao('abstraction').fromXML(child)
+                modules.append(_data)
+            elif child_tag == 'group':
+                _data = self.getDao('group').fromXML(child)
+                modules.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBWorkflow(modules=modules,
+                         id=id,
+                         name=name,
+                         version=version,
+                         connections=connections,
+                         annotations=annotations,
+                         plugin_datas=plugin_datas,
+                         others=others,
+                         vistrail_id=vistrail_id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, workflow, node=None):
+        if node is None:
+            node = ElementTree.Element('workflow')
+        
+        # set attributes
+        node.set('id',self.convertToStr(workflow.db_id, 'long'))
+        node.set('name',self.convertToStr(workflow.db_name, 'str'))
+        node.set('version',self.convertToStr(workflow.db_version, 'str'))
+        node.set('vistrail_id',self.convertToStr(workflow.db_vistrail_id, 'long'))
+        
+        # set elements
+        connections = workflow.db_connections
+        for connection in connections:
+            if (connections is not None) and (connections != ""):
+                childNode = ElementTree.SubElement(node, 'connection')
+                self.getDao('connection').toXML(connection, childNode)
+        annotations = workflow.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        plugin_datas = workflow.db_plugin_datas
+        for plugin_data in plugin_datas:
+            if (plugin_datas is not None) and (plugin_datas != ""):
+                childNode = ElementTree.SubElement(node, 'plugin_data')
+                self.getDao('plugin_data').toXML(plugin_data, childNode)
+        others = workflow.db_others
+        for other in others:
+            if (others is not None) and (others != ""):
+                childNode = ElementTree.SubElement(node, 'other')
+                self.getDao('other').toXML(other, childNode)
+        modules = workflow.db_modules
+        for module in modules:
+            if module.vtType == 'module':
+                childNode = ElementTree.SubElement(node, 'module')
+                self.getDao('module').toXML(module, childNode)
+            elif module.vtType == 'abstraction':
+                childNode = ElementTree.SubElement(node, 'abstraction')
+                self.getDao('abstraction').toXML(module, childNode)
+            elif module.vtType == 'group':
+                childNode = ElementTree.SubElement(node, 'group')
+                self.getDao('group').toXML(module, childNode)
+        
+        return node
+
+class DBMashupActionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'action':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('prevId', None)
+        prevId = self.convertFromStr(data, 'long')
+        data = node.get('date', None)
+        date = self.convertFromStr(data, 'datetime')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        
+        mashup = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'mashup':
+                _data = self.getDao('mashup').fromXML(child)
+                mashup = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBMashupAction(id=id,
+                             prevId=prevId,
+                             date=date,
+                             user=user,
+                             mashup=mashup)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashup_action, node=None):
+        if node is None:
+            node = ElementTree.Element('action')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashup_action.db_id, 'long'))
+        node.set('prevId',self.convertToStr(mashup_action.db_prevId, 'long'))
+        node.set('date',self.convertToStr(mashup_action.db_date, 'datetime'))
+        node.set('user',self.convertToStr(mashup_action.db_user, 'str'))
+        
+        # set elements
+        mashup = mashup_action.db_mashup
+        if mashup is not None:
+            if (mashup is not None) and (mashup != ""):
+                childNode = ElementTree.SubElement(node, 'mashup')
+                self.getDao('mashup').toXML(mashup, childNode)
+        
+        return node
+
+class DBConfigurationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'configuration':
+            return None
+        
+        config_keys = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'key':
+                _data = self.getDao('config_key').fromXML(child)
+                config_keys.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBConfiguration(config_keys=config_keys)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, configuration, node=None):
+        if node is None:
+            node = ElementTree.Element('configuration')
+        
+        # set elements
+        config_keys = configuration.db_config_keys
+        for config_key in config_keys:
+            if (config_keys is not None) and (config_keys != ""):
+                childNode = ElementTree.SubElement(node, 'key')
+                self.getDao('config_key').toXML(config_key, childNode)
+        
+        return node
+
+class DBChangeXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'change':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('what', None)
+        what = self.convertFromStr(data, 'str')
+        data = node.get('oldObjId', None)
+        oldObjId = self.convertFromStr(data, 'long')
+        data = node.get('newObjId', None)
+        newObjId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjId', None)
+        parentObjId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjType', None)
+        parentObjType = self.convertFromStr(data, 'str')
+        
+        data = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'module':
+                _data = self.getDao('module').fromXML(child)
+                data = _data
+            elif child_tag == 'location':
+                _data = self.getDao('location').fromXML(child)
+                data = _data
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                data = _data
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                data = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                data = _data
+            elif child_tag == 'connection':
+                _data = self.getDao('connection').fromXML(child)
+                data = _data
+            elif child_tag == 'port':
+                _data = self.getDao('port').fromXML(child)
+                data = _data
+            elif child_tag == 'parameter':
+                _data = self.getDao('parameter').fromXML(child)
+                data = _data
+            elif child_tag == 'portSpec':
+                _data = self.getDao('portSpec').fromXML(child)
+                data = _data
+            elif child_tag == 'abstraction':
+                _data = self.getDao('abstraction').fromXML(child)
+                data = _data
+            elif child_tag == 'group':
+                _data = self.getDao('group').fromXML(child)
+                data = _data
+            elif child_tag == 'other':
+                _data = self.getDao('other').fromXML(child)
+                data = _data
+            elif child_tag == 'plugin_data':
+                _data = self.getDao('plugin_data').fromXML(child)
+                data = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBChange(data=data,
+                       id=id,
+                       what=what,
+                       oldObjId=oldObjId,
+                       newObjId=newObjId,
+                       parentObjId=parentObjId,
+                       parentObjType=parentObjType)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, change, node=None):
+        if node is None:
+            node = ElementTree.Element('change')
+        
+        # set attributes
+        node.set('id',self.convertToStr(change.db_id, 'long'))
+        node.set('what',self.convertToStr(change.db_what, 'str'))
+        node.set('oldObjId',self.convertToStr(change.db_oldObjId, 'long'))
+        node.set('newObjId',self.convertToStr(change.db_newObjId, 'long'))
+        node.set('parentObjId',self.convertToStr(change.db_parentObjId, 'long'))
+        node.set('parentObjType',self.convertToStr(change.db_parentObjType, 'str'))
+        
+        # set elements
+        data = change.db_data
+        if data is not None:
+            if data.vtType == 'module':
+                childNode = ElementTree.SubElement(node, 'module')
+                self.getDao('module').toXML(data, childNode)
+            elif data.vtType == 'location':
+                childNode = ElementTree.SubElement(node, 'location')
+                self.getDao('location').toXML(data, childNode)
+            elif data.vtType == 'annotation':
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(data, childNode)
+            elif data.vtType == 'controlParameter':
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(data, childNode)
+            elif data.vtType == 'function':
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(data, childNode)
+            elif data.vtType == 'connection':
+                childNode = ElementTree.SubElement(node, 'connection')
+                self.getDao('connection').toXML(data, childNode)
+            elif data.vtType == 'port':
+                childNode = ElementTree.SubElement(node, 'port')
+                self.getDao('port').toXML(data, childNode)
+            elif data.vtType == 'parameter':
+                childNode = ElementTree.SubElement(node, 'parameter')
+                self.getDao('parameter').toXML(data, childNode)
+            elif data.vtType == 'portSpec':
+                childNode = ElementTree.SubElement(node, 'portSpec')
+                self.getDao('portSpec').toXML(data, childNode)
+            elif data.vtType == 'abstraction':
+                childNode = ElementTree.SubElement(node, 'abstraction')
+                self.getDao('abstraction').toXML(data, childNode)
+            elif data.vtType == 'group':
+                childNode = ElementTree.SubElement(node, 'group')
+                self.getDao('group').toXML(data, childNode)
+            elif data.vtType == 'other':
+                childNode = ElementTree.SubElement(node, 'other')
+                self.getDao('other').toXML(data, childNode)
+            elif data.vtType == 'plugin_data':
+                childNode = ElementTree.SubElement(node, 'plugin_data')
+                self.getDao('plugin_data').toXML(data, childNode)
+        
+        return node
+
+class DBPackageXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'package':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('identifier', None)
+        identifier = self.convertFromStr(data, 'str')
+        data = node.get('codepath', None)
+        codepath = self.convertFromStr(data, 'str')
+        data = node.get('loadConfiguration', None)
+        load_configuration = self.convertFromStr(data, 'int')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('description', None)
+        description = self.convertFromStr(data, 'str')
+        
+        module_descriptors = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'moduleDescriptor':
+                _data = self.getDao('module_descriptor').fromXML(child)
+                module_descriptors.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBPackage(id=id,
+                        name=name,
+                        identifier=identifier,
+                        codepath=codepath,
+                        load_configuration=load_configuration,
+                        version=version,
+                        description=description,
+                        module_descriptors=module_descriptors)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, package, node=None):
+        if node is None:
+            node = ElementTree.Element('package')
+        
+        # set attributes
+        node.set('id',self.convertToStr(package.db_id, 'long'))
+        node.set('name',self.convertToStr(package.db_name, 'str'))
+        node.set('identifier',self.convertToStr(package.db_identifier, 'str'))
+        node.set('codepath',self.convertToStr(package.db_codepath, 'str'))
+        node.set('loadConfiguration',self.convertToStr(package.db_load_configuration, 'int'))
+        node.set('version',self.convertToStr(package.db_version, 'str'))
+        node.set('description',self.convertToStr(package.db_description, 'str'))
+        
+        # set elements
+        module_descriptors = package.db_module_descriptors
+        for module_descriptor in module_descriptors:
+            if (module_descriptors is not None) and (module_descriptors != ""):
+                childNode = ElementTree.SubElement(node, 'moduleDescriptor')
+                self.getDao('module_descriptor').toXML(module_descriptor, childNode)
+        
+        return node
+
+class DBLoopExecXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'loopExec':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('tsStart', None)
+        ts_start = self.convertFromStr(data, 'datetime')
+        data = node.get('tsEnd', None)
+        ts_end = self.convertFromStr(data, 'datetime')
+        
+        loop_iterations = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'loopIteration':
+                _data = self.getDao('loop_iteration').fromXML(child)
+                loop_iterations.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBLoopExec(id=id,
+                         ts_start=ts_start,
+                         ts_end=ts_end,
+                         loop_iterations=loop_iterations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, loop_exec, node=None):
+        if node is None:
+            node = ElementTree.Element('loopExec')
+        
+        # set attributes
+        node.set('id',self.convertToStr(loop_exec.db_id, 'long'))
+        node.set('tsStart',self.convertToStr(loop_exec.db_ts_start, 'datetime'))
+        node.set('tsEnd',self.convertToStr(loop_exec.db_ts_end, 'datetime'))
+        
+        # set elements
+        loop_iterations = loop_exec.db_loop_iterations
+        for loop_iteration in loop_iterations:
+            if (loop_iterations is not None) and (loop_iterations != ""):
+                childNode = ElementTree.SubElement(node, 'loopIteration')
+                self.getDao('loop_iteration').toXML(loop_iteration, childNode)
+        
+        return node
+
+class DBConnectionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'connection':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        
+        ports = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'port':
+                _data = self.getDao('port').fromXML(child)
+                ports.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBConnection(id=id,
+                           ports=ports)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, connection, node=None):
+        if node is None:
+            node = ElementTree.Element('connection')
+        
+        # set attributes
+        node.set('id',self.convertToStr(connection.db_id, 'long'))
+        
+        # set elements
+        ports = connection.db_ports
+        for port in ports:
+            if (ports is not None) and (ports != ""):
+                childNode = ElementTree.SubElement(node, 'port')
+                self.getDao('port').toXML(port, childNode)
+        
+        return node
+
+class DBConfigBoolXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'bool':
+            return None
+        
+        # read attributes
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBConfigBool(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, config_bool, node=None):
+        if node is None:
+            node = ElementTree.Element('bool')
+        
+        # set attributes
+        node.set('value',self.convertToStr(config_bool.db_value, 'str'))
+        
+        return node
+
+class DBActionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'action':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('prevId', None)
+        prevId = self.convertFromStr(data, 'long')
+        data = node.get('date', None)
+        date = self.convertFromStr(data, 'datetime')
+        data = node.get('session', None)
+        session = self.convertFromStr(data, 'long')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        
+        annotations = []
+        operations = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'add':
+                _data = self.getDao('add').fromXML(child)
+                operations.append(_data)
+            elif child_tag == 'delete':
+                _data = self.getDao('delete').fromXML(child)
+                operations.append(_data)
+            elif child_tag == 'change':
+                _data = self.getDao('change').fromXML(child)
+                operations.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBAction(operations=operations,
+                       id=id,
+                       prevId=prevId,
+                       date=date,
+                       session=session,
+                       user=user,
+                       annotations=annotations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, action, node=None):
+        if node is None:
+            node = ElementTree.Element('action')
+        
+        # set attributes
+        node.set('id',self.convertToStr(action.db_id, 'long'))
+        node.set('prevId',self.convertToStr(action.db_prevId, 'long'))
+        node.set('date',self.convertToStr(action.db_date, 'datetime'))
+        node.set('session',self.convertToStr(action.db_session, 'long'))
+        node.set('user',self.convertToStr(action.db_user, 'str'))
+        
+        # set elements
+        annotations = action.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        operations = action.db_operations
+        for operation in operations:
+            if operation.vtType == 'add':
+                childNode = ElementTree.SubElement(node, 'add')
+                self.getDao('add').toXML(operation, childNode)
+            elif operation.vtType == 'delete':
+                childNode = ElementTree.SubElement(node, 'delete')
+                self.getDao('delete').toXML(operation, childNode)
+            elif operation.vtType == 'change':
+                childNode = ElementTree.SubElement(node, 'change')
+                self.getDao('change').toXML(operation, childNode)
+        
+        return node
+
+class DBStartupPackageXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'package':
+            return None
+        
+        # read attributes
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        configuration = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'configuration':
+                _data = self.getDao('configuration').fromXML(child)
+                configuration = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBStartupPackage(name=name,
+                               configuration=configuration)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, startup_package, node=None):
+        if node is None:
+            node = ElementTree.Element('package')
+        
+        # set attributes
+        node.set('name',self.convertToStr(startup_package.db_name, 'str'))
+        
+        # set elements
+        configuration = startup_package.db_configuration
+        if configuration is not None:
+            if (configuration is not None) and (configuration != ""):
+                childNode = ElementTree.SubElement(node, 'configuration')
+                self.getDao('configuration').toXML(configuration, childNode)
+        
+        return node
+
+class DBConfigIntXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'int':
+            return None
+        
+        # read attributes
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'int')
+        
+        obj = DBConfigInt(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, config_int, node=None):
+        if node is None:
+            node = ElementTree.Element('int')
+        
+        # set attributes
+        node.set('value',self.convertToStr(config_int.db_value, 'int'))
+        
+        return node
+
+class DBOpmProcessIdEffectXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'effect':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmProcessIdEffect(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_process_id_effect, node=None):
+        if node is None:
+            node = ElementTree.Element('effect')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_process_id_effect.db_id, 'str'))
+        
+        return node
+
+class DBRefProvPlanXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:plan':
+            return None
+        
+        # read attributes
+        data = node.get('prov:ref', None)
+        prov_ref = self.convertFromStr(data, 'str')
+        
+        obj = DBRefProvPlan(prov_ref=prov_ref)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, ref_prov_plan, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:plan')
+        
+        # set attributes
+        node.set('prov:ref',self.convertToStr(ref_prov_plan.db_prov_ref, 'str'))
+        
+        return node
+
+class DBOpmAccountsXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'accounts':
+            return None
+        
+        accounts = []
+        opm_overlapss = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'account':
+                _data = self.getDao('opm_account').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'overlaps':
+                _data = self.getDao('opm_overlaps').fromXML(child)
+                opm_overlapss.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmAccounts(accounts=accounts,
+                            opm_overlapss=opm_overlapss)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_accounts, node=None):
+        if node is None:
+            node = ElementTree.Element('accounts')
+        
+        # set elements
+        accounts = opm_accounts.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account').toXML(account, childNode)
+        opm_overlapss = opm_accounts.db_opm_overlapss
+        for opm_overlaps in opm_overlapss:
+            if (opm_overlapss is not None) and (opm_overlapss != ""):
+                childNode = ElementTree.SubElement(node, 'overlaps')
+                self.getDao('opm_overlaps').toXML(opm_overlaps, childNode)
+        
+        return node
+
+class DBRefProvAgentXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:agent':
+            return None
+        
+        # read attributes
+        data = node.get('prov:ref', None)
+        prov_ref = self.convertFromStr(data, 'str')
+        
+        obj = DBRefProvAgent(prov_ref=prov_ref)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, ref_prov_agent, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:agent')
+        
+        # set attributes
+        node.set('prov:ref',self.convertToStr(ref_prov_agent.db_prov_ref, 'str'))
+        
+        return node
+
+class DBPortSpecXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'portSpec':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('type', None)
+        type = self.convertFromStr(data, 'str')
+        data = node.get('optional', None)
+        optional = self.convertFromStr(data, 'int')
+        data = node.get('depth', None)
+        depth = self.convertFromStr(data, 'int')
+        data = node.get('union', None)
+        union = self.convertFromStr(data, 'str')
+        data = node.get('sortKey', None)
+        sort_key = self.convertFromStr(data, 'int')
+        data = node.get('minConns', None)
+        min_conns = self.convertFromStr(data, 'int')
+        data = node.get('maxConns', None)
+        max_conns = self.convertFromStr(data, 'int')
+        
+        portSpecItems = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'portSpecItem':
+                _data = self.getDao('portSpecItem').fromXML(child)
+                portSpecItems.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBPortSpec(id=id,
+                         name=name,
+                         type=type,
+                         optional=optional,
+                         depth=depth,
+                         union=union,
+                         sort_key=sort_key,
+                         portSpecItems=portSpecItems,
+                         min_conns=min_conns,
+                         max_conns=max_conns)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, portSpec, node=None):
+        if node is None:
+            node = ElementTree.Element('portSpec')
+        
+        # set attributes
+        node.set('id',self.convertToStr(portSpec.db_id, 'long'))
+        node.set('name',self.convertToStr(portSpec.db_name, 'str'))
+        node.set('type',self.convertToStr(portSpec.db_type, 'str'))
+        node.set('optional',self.convertToStr(portSpec.db_optional, 'int'))
+        node.set('depth',self.convertToStr(portSpec.db_depth, 'int'))
+        node.set('union',self.convertToStr(portSpec.db_union, 'str'))
+        node.set('sortKey',self.convertToStr(portSpec.db_sort_key, 'int'))
+        node.set('minConns',self.convertToStr(portSpec.db_min_conns, 'int'))
+        node.set('maxConns',self.convertToStr(portSpec.db_max_conns, 'int'))
+        
+        # set elements
+        portSpecItems = portSpec.db_portSpecItems
+        for portSpecItem in portSpecItems:
+            if (portSpecItems is not None) and (portSpecItems != ""):
+                childNode = ElementTree.SubElement(node, 'portSpecItem')
+                self.getDao('portSpecItem').toXML(portSpecItem, childNode)
+        
+        return node
+
+class DBEnabledPackagesXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'packages':
+            return None
+        
+        packages = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'package':
+                _data = self.getDao('startup_package').fromXML(child)
+                packages.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBEnabledPackages(packages=packages)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, enabled_packages, node=None):
+        if node is None:
+            node = ElementTree.Element('packages')
+        
+        # set elements
+        packages = enabled_packages.db_packages
+        for package in packages:
+            if (packages is not None) and (packages != ""):
+                childNode = ElementTree.SubElement(node, 'package')
+                self.getDao('startup_package').toXML(package, childNode)
+        
+        return node
+
+class DBOpmArtifactXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'artifact':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        value = None
+        accounts = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'value':
+                _data = self.getDao('opm_artifact_value').fromXML(child)
+                value = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmArtifact(id=id,
+                            value=value,
+                            accounts=accounts)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_artifact, node=None):
+        if node is None:
+            node = ElementTree.Element('artifact')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_artifact.db_id, 'str'))
+        
+        # set elements
+        value = opm_artifact.db_value
+        if value is not None:
+            if (value is not None) and (value != ""):
+                childNode = ElementTree.SubElement(node, 'value')
+                self.getDao('opm_artifact_value').toXML(value, childNode)
+        accounts = opm_artifact.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        
+        return node
+
+class DBLogXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'log':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('vistrail_id', None)
+        vistrail_id = self.convertFromStr(data, 'long')
+        
+        workflow_execs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'workflowExec':
+                _data = self.getDao('workflow_exec').fromXML(child)
+                workflow_execs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBLog(id=id,
+                    version=version,
+                    name=name,
+                    workflow_execs=workflow_execs,
+                    vistrail_id=vistrail_id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, log, node=None):
+        if node is None:
+            node = ElementTree.Element('log')
+        
+        # set attributes
+        node.set('id',self.convertToStr(log.db_id, 'long'))
+        node.set('version',self.convertToStr(log.db_version, 'str'))
+        node.set('name',self.convertToStr(log.db_name, 'str'))
+        node.set('vistrail_id',self.convertToStr(log.db_vistrail_id, 'long'))
+        
+        # set elements
+        workflow_execs = log.db_workflow_execs
+        for workflow_exec in workflow_execs:
+            if (workflow_execs is not None) and (workflow_execs != ""):
+                childNode = ElementTree.SubElement(node, 'workflowExec')
+                self.getDao('workflow_exec').toXML(workflow_exec, childNode)
+        
+        return node
+
+class DBLoopIterationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'loopIteration':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('tsStart', None)
+        ts_start = self.convertFromStr(data, 'datetime')
+        data = node.get('tsEnd', None)
+        ts_end = self.convertFromStr(data, 'datetime')
+        data = node.get('iteration', None)
+        iteration = self.convertFromStr(data, 'int')
+        data = node.get('completed', None)
+        completed = self.convertFromStr(data, 'int')
+        data = node.get('error', None)
+        error = self.convertFromStr(data, 'str')
+        
+        item_execs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'moduleExec':
+                _data = self.getDao('module_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'groupExec':
+                _data = self.getDao('group_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'loopExec':
+                _data = self.getDao('loop_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBLoopIteration(item_execs=item_execs,
+                              id=id,
+                              ts_start=ts_start,
+                              ts_end=ts_end,
+                              iteration=iteration,
+                              completed=completed,
+                              error=error)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, loop_iteration, node=None):
+        if node is None:
+            node = ElementTree.Element('loopIteration')
+        
+        # set attributes
+        node.set('id',self.convertToStr(loop_iteration.db_id, 'long'))
+        node.set('tsStart',self.convertToStr(loop_iteration.db_ts_start, 'datetime'))
+        node.set('tsEnd',self.convertToStr(loop_iteration.db_ts_end, 'datetime'))
+        node.set('iteration',self.convertToStr(loop_iteration.db_iteration, 'int'))
+        node.set('completed',self.convertToStr(loop_iteration.db_completed, 'int'))
+        node.set('error',self.convertToStr(loop_iteration.db_error, 'str'))
+        
+        # set elements
+        item_execs = loop_iteration.db_item_execs
+        for item_exec in item_execs:
+            if item_exec.vtType == 'module_exec':
+                childNode = ElementTree.SubElement(node, 'moduleExec')
+                self.getDao('module_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'group_exec':
+                childNode = ElementTree.SubElement(node, 'groupExec')
+                self.getDao('group_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'loop_exec':
+                childNode = ElementTree.SubElement(node, 'loopExec')
+                self.getDao('loop_exec').toXML(item_exec, childNode)
+        
+        return node
+
+class DBOpmProcessIdCauseXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'cause':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmProcessIdCause(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_process_id_cause, node=None):
+        if node is None:
+            node = ElementTree.Element('cause')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_process_id_cause.db_id, 'str'))
+        
+        return node
+
+class DBOpmArtifactsXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'artifacts':
+            return None
+        
+        artifacts = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'artifact':
+                _data = self.getDao('opm_artifact').fromXML(child)
+                artifacts.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmArtifacts(artifacts=artifacts)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_artifacts, node=None):
+        if node is None:
+            node = ElementTree.Element('artifacts')
+        
+        # set elements
+        artifacts = opm_artifacts.db_artifacts
+        for artifact in artifacts:
+            if (artifacts is not None) and (artifacts != ""):
+                childNode = ElementTree.SubElement(node, 'artifact')
+                self.getDao('opm_artifact').toXML(artifact, childNode)
+        
+        return node
+
+class DBPEParameterXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'peParameter':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('pos', None)
+        pos = self.convertFromStr(data, 'long')
+        data = node.get('interpolator', None)
+        interpolator = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        data = node.get('dimension', None)
+        dimension = self.convertFromStr(data, 'long')
+        
+        obj = DBPEParameter(id=id,
+                            pos=pos,
+                            interpolator=interpolator,
+                            value=value,
+                            dimension=dimension)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, pe_parameter, node=None):
+        if node is None:
+            node = ElementTree.Element('peParameter')
+        
+        # set attributes
+        node.set('id',self.convertToStr(pe_parameter.db_id, 'long'))
+        node.set('pos',self.convertToStr(pe_parameter.db_pos, 'long'))
+        node.set('interpolator',self.convertToStr(pe_parameter.db_interpolator, 'str'))
+        node.set('value',self.convertToStr(pe_parameter.db_value, 'str'))
+        node.set('dimension',self.convertToStr(pe_parameter.db_dimension, 'long'))
+        
+        return node
+
+class DBWorkflowExecXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'workflowExec':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        data = node.get('ip', None)
+        ip = self.convertFromStr(data, 'str')
+        data = node.get('session', None)
+        session = self.convertFromStr(data, 'long')
+        data = node.get('vtVersion', None)
+        vt_version = self.convertFromStr(data, 'str')
+        data = node.get('tsStart', None)
+        ts_start = self.convertFromStr(data, 'datetime')
+        data = node.get('tsEnd', None)
+        ts_end = self.convertFromStr(data, 'datetime')
+        data = node.get('parentId', None)
+        parent_id = self.convertFromStr(data, 'long')
+        data = node.get('parentType', None)
+        parent_type = self.convertFromStr(data, 'str')
+        data = node.get('parentVersion', None)
+        parent_version = self.convertFromStr(data, 'long')
+        data = node.get('completed', None)
+        completed = self.convertFromStr(data, 'int')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        annotations = []
+        machines = []
+        item_execs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'machine':
+                _data = self.getDao('machine').fromXML(child)
+                machines.append(_data)
+            elif child_tag == 'moduleExec':
+                _data = self.getDao('module_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'groupExec':
+                _data = self.getDao('group_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child_tag == 'loopExec':
+                _data = self.getDao('loop_exec').fromXML(child)
+                item_execs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBWorkflowExec(item_execs=item_execs,
+                             id=id,
+                             user=user,
+                             ip=ip,
+                             session=session,
+                             vt_version=vt_version,
+                             ts_start=ts_start,
+                             ts_end=ts_end,
+                             parent_id=parent_id,
+                             parent_type=parent_type,
+                             parent_version=parent_version,
+                             completed=completed,
+                             name=name,
+                             annotations=annotations,
+                             machines=machines)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, workflow_exec, node=None):
+        if node is None:
+            node = ElementTree.Element('workflowExec')
+        
+        # set attributes
+        node.set('id',self.convertToStr(workflow_exec.db_id, 'long'))
+        node.set('user',self.convertToStr(workflow_exec.db_user, 'str'))
+        node.set('ip',self.convertToStr(workflow_exec.db_ip, 'str'))
+        node.set('session',self.convertToStr(workflow_exec.db_session, 'long'))
+        node.set('vtVersion',self.convertToStr(workflow_exec.db_vt_version, 'str'))
+        node.set('tsStart',self.convertToStr(workflow_exec.db_ts_start, 'datetime'))
+        node.set('tsEnd',self.convertToStr(workflow_exec.db_ts_end, 'datetime'))
+        node.set('parentId',self.convertToStr(workflow_exec.db_parent_id, 'long'))
+        node.set('parentType',self.convertToStr(workflow_exec.db_parent_type, 'str'))
+        node.set('parentVersion',self.convertToStr(workflow_exec.db_parent_version, 'long'))
+        node.set('completed',self.convertToStr(workflow_exec.db_completed, 'int'))
+        node.set('name',self.convertToStr(workflow_exec.db_name, 'str'))
+        
+        # set elements
+        annotations = workflow_exec.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        machines = workflow_exec.db_machines
+        for machine in machines:
+            if (machines is not None) and (machines != ""):
+                childNode = ElementTree.SubElement(node, 'machine')
+                self.getDao('machine').toXML(machine, childNode)
+        item_execs = workflow_exec.db_item_execs
+        for item_exec in item_execs:
+            if item_exec.vtType == 'module_exec':
+                childNode = ElementTree.SubElement(node, 'moduleExec')
+                self.getDao('module_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'group_exec':
+                childNode = ElementTree.SubElement(node, 'groupExec')
+                self.getDao('group_exec').toXML(item_exec, childNode)
+            elif item_exec.vtType == 'loop_exec':
+                childNode = ElementTree.SubElement(node, 'loopExec')
+                self.getDao('loop_exec').toXML(item_exec, childNode)
+        
+        return node
+
+class DBLocationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'location':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('x', None)
+        x = self.convertFromStr(data, 'float')
+        data = node.get('y', None)
+        y = self.convertFromStr(data, 'float')
+        
+        obj = DBLocation(id=id,
+                         x=x,
+                         y=y)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, location, node=None):
+        if node is None:
+            node = ElementTree.Element('location')
+        
+        # set attributes
+        node.set('id',self.convertToStr(location.db_id, 'long'))
+        node.set('x',self.convertToStr(location.db_x, 'float'))
+        node.set('y',self.convertToStr(location.db_y, 'float'))
+        
+        return node
+
+class DBFunctionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'function':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('pos', None)
+        pos = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        parameters = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'parameter':
+                _data = self.getDao('parameter').fromXML(child)
+                parameters.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBFunction(id=id,
+                         pos=pos,
+                         name=name,
+                         parameters=parameters)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, function, node=None):
+        if node is None:
+            node = ElementTree.Element('function')
+        
+        # set attributes
+        node.set('id',self.convertToStr(function.db_id, 'long'))
+        node.set('pos',self.convertToStr(function.db_pos, 'long'))
+        node.set('name',self.convertToStr(function.db_name, 'str'))
+        
+        # set elements
+        parameters = function.db_parameters
+        for parameter in parameters:
+            if (parameters is not None) and (parameters != ""):
+                childNode = ElementTree.SubElement(node, 'parameter')
+                self.getDao('parameter').toXML(parameter, childNode)
+        
+        return node
+
+class DBActionAnnotationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'actionAnnotation':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('key', None)
+        key = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        data = node.get('actionId', None)
+        action_id = self.convertFromStr(data, 'long')
+        data = node.get('date', None)
+        date = self.convertFromStr(data, 'datetime')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        
+        obj = DBActionAnnotation(id=id,
+                                 key=key,
+                                 value=value,
+                                 action_id=action_id,
+                                 date=date,
+                                 user=user)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, actionAnnotation, node=None):
+        if node is None:
+            node = ElementTree.Element('actionAnnotation')
+        
+        # set attributes
+        node.set('id',self.convertToStr(actionAnnotation.db_id, 'long'))
+        node.set('key',self.convertToStr(actionAnnotation.db_key, 'str'))
+        node.set('value',self.convertToStr(actionAnnotation.db_value, 'str'))
+        node.set('actionId',self.convertToStr(actionAnnotation.db_action_id, 'long'))
+        node.set('date',self.convertToStr(actionAnnotation.db_date, 'datetime'))
+        node.set('user',self.convertToStr(actionAnnotation.db_user, 'str'))
+        
+        return node
+
+class DBProvActivityXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:activity':
+            return None
+        
+        # read attributes
+        data = node.get('prov:id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        startTime = None
+        endTime = None
+        vt_id = None
+        vt_type = None
+        vt_cached = None
+        vt_completed = None
+        vt_machine_id = None
+        vt_error = None
+        is_part_of = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:startTime':
+                _data = self.convertFromStr(child.text,'str')
+                startTime = _data
+            elif child_tag == 'prov:endTime':
+                _data = self.convertFromStr(child.text,'str')
+                endTime = _data
+            elif child_tag == 'vt:id':
+                _data = self.convertFromStr(child.text,'str')
+                vt_id = _data
+            elif child_tag == 'vt:type':
+                _data = self.convertFromStr(child.text,'str')
+                vt_type = _data
+            elif child_tag == 'vt:cached':
+                _data = self.convertFromStr(child.text,'str')
+                vt_cached = _data
+            elif child_tag == 'vt:completed':
+                _data = self.convertFromStr(child.text,'str')
+                vt_completed = _data
+            elif child_tag == 'vt:machine_id':
+                _data = self.convertFromStr(child.text,'str')
+                vt_machine_id = _data
+            elif child_tag == 'vt:error':
+                _data = self.convertFromStr(child.text,'str')
+                vt_error = _data
+            elif child_tag == 'dcterms:isPartOf':
+                _data = self.getDao('is_part_of').fromXML(child)
+                is_part_of = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvActivity(id=id,
+                             startTime=startTime,
+                             endTime=endTime,
+                             vt_id=vt_id,
+                             vt_type=vt_type,
+                             vt_cached=vt_cached,
+                             vt_completed=vt_completed,
+                             vt_machine_id=vt_machine_id,
+                             vt_error=vt_error,
+                             is_part_of=is_part_of)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_activity, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:activity')
+        
+        # set attributes
+        node.set('prov:id',self.convertToStr(prov_activity.db_id, 'str'))
+        
+        # set elements
+        startTime = prov_activity.db_startTime
+        if (startTime is not None) and (startTime != ""):
+            childNode = ElementTree.SubElement(node, 'prov:startTime')
+            childNode.text = self.convertToStr(startTime, 'str')
+        endTime = prov_activity.db_endTime
+        if (endTime is not None) and (endTime != ""):
+            childNode = ElementTree.SubElement(node, 'prov:endTime')
+            childNode.text = self.convertToStr(endTime, 'str')
+        vt_id = prov_activity.db_vt_id
+        if (vt_id is not None) and (vt_id != ""):
+            childNode = ElementTree.SubElement(node, 'vt:id')
+            childNode.text = self.convertToStr(vt_id, 'str')
+        vt_type = prov_activity.db_vt_type
+        if (vt_type is not None) and (vt_type != ""):
+            childNode = ElementTree.SubElement(node, 'vt:type')
+            childNode.text = self.convertToStr(vt_type, 'str')
+        vt_cached = prov_activity.db_vt_cached
+        if (vt_cached is not None) and (vt_cached != ""):
+            childNode = ElementTree.SubElement(node, 'vt:cached')
+            childNode.text = self.convertToStr(vt_cached, 'str')
+        vt_completed = prov_activity.db_vt_completed
+        if (vt_completed is not None) and (vt_completed != ""):
+            childNode = ElementTree.SubElement(node, 'vt:completed')
+            childNode.text = self.convertToStr(vt_completed, 'str')
+        vt_machine_id = prov_activity.db_vt_machine_id
+        if (vt_machine_id is not None) and (vt_machine_id != ""):
+            childNode = ElementTree.SubElement(node, 'vt:machine_id')
+            childNode.text = self.convertToStr(vt_machine_id, 'str')
+        vt_error = prov_activity.db_vt_error
+        if (vt_error is not None) and (vt_error != ""):
+            childNode = ElementTree.SubElement(node, 'vt:error')
+            childNode.text = self.convertToStr(vt_error, 'str')
+        is_part_of = prov_activity.db_is_part_of
+        if is_part_of is not None:
+            if (is_part_of is not None) and (is_part_of != ""):
+                childNode = ElementTree.SubElement(node, 'dcterms:isPartOf')
+                self.getDao('is_part_of').toXML(is_part_of, childNode)
+        
+        return node
+
+class DBProvUsageXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:used':
+            return None
+        
+        prov_activity = None
+        prov_entity = None
+        prov_role = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:activity':
+                _data = self.getDao('ref_prov_activity').fromXML(child)
+                prov_activity = _data
+            elif child_tag == 'prov:entity':
+                _data = self.getDao('ref_prov_entity').fromXML(child)
+                prov_entity = _data
+            elif child_tag == 'prov:role':
+                _data = self.convertFromStr(child.text,'str')
+                prov_role = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvUsage(prov_activity=prov_activity,
+                          prov_entity=prov_entity,
+                          prov_role=prov_role)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_usage, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:used')
+        
+        # set elements
+        prov_activity = prov_usage.db_prov_activity
+        if prov_activity is not None:
+            if (prov_activity is not None) and (prov_activity != ""):
+                childNode = ElementTree.SubElement(node, 'prov:activity')
+                self.getDao('ref_prov_activity').toXML(prov_activity, childNode)
+        prov_entity = prov_usage.db_prov_entity
+        if prov_entity is not None:
+            if (prov_entity is not None) and (prov_entity != ""):
+                childNode = ElementTree.SubElement(node, 'prov:entity')
+                self.getDao('ref_prov_entity').toXML(prov_entity, childNode)
+        prov_role = prov_usage.db_prov_role
+        if (prov_role is not None) and (prov_role != ""):
+            childNode = ElementTree.SubElement(node, 'prov:role')
+            childNode.text = self.convertToStr(prov_role, 'str')
+        
+        return node
+
+class DBOpmArtifactIdEffectXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'effect':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmArtifactIdEffect(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_artifact_id_effect, node=None):
+        if node is None:
+            node = ElementTree.Element('effect')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_artifact_id_effect.db_id, 'str'))
+        
+        return node
+
+class DBOpmGraphXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'opmGraph':
+            return None
+        
+        accounts = None
+        processes = None
+        artifacts = None
+        agents = None
+        dependencies = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'accounts':
+                _data = self.getDao('opm_accounts').fromXML(child)
+                accounts = _data
+            elif child_tag == 'processes':
+                _data = self.getDao('opm_processes').fromXML(child)
+                processes = _data
+            elif child_tag == 'artifacts':
+                _data = self.getDao('opm_artifacts').fromXML(child)
+                artifacts = _data
+            elif child_tag == 'agents':
+                _data = self.getDao('opm_agents').fromXML(child)
+                agents = _data
+            elif child_tag == 'causalDependencies':
+                _data = self.getDao('opm_dependencies').fromXML(child)
+                dependencies = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmGraph(accounts=accounts,
+                         processes=processes,
+                         artifacts=artifacts,
+                         agents=agents,
+                         dependencies=dependencies)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_graph, node=None):
+        if node is None:
+            node = ElementTree.Element('opmGraph')
+        
+        # set elements
+        accounts = opm_graph.db_accounts
+        if accounts is not None:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'accounts')
+                self.getDao('opm_accounts').toXML(accounts, childNode)
+        processes = opm_graph.db_processes
+        if processes is not None:
+            if (processes is not None) and (processes != ""):
+                childNode = ElementTree.SubElement(node, 'processes')
+                self.getDao('opm_processes').toXML(processes, childNode)
+        artifacts = opm_graph.db_artifacts
+        if artifacts is not None:
+            if (artifacts is not None) and (artifacts != ""):
+                childNode = ElementTree.SubElement(node, 'artifacts')
+                self.getDao('opm_artifacts').toXML(artifacts, childNode)
+        agents = opm_graph.db_agents
+        if agents is not None:
+            if (agents is not None) and (agents != ""):
+                childNode = ElementTree.SubElement(node, 'agents')
+                self.getDao('opm_agents').toXML(agents, childNode)
+        dependencies = opm_graph.db_dependencies
+        if dependencies is not None:
+            if (dependencies is not None) and (dependencies != ""):
+                childNode = ElementTree.SubElement(node, 'causalDependencies')
+                self.getDao('opm_dependencies').toXML(dependencies, childNode)
+        
+        return node
+
+class DBIsPartOfXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'dcterms:isPartOf':
+            return None
+        
+        # read attributes
+        data = node.get('prov:ref', None)
+        prov_ref = self.convertFromStr(data, 'str')
+        
+        obj = DBIsPartOf(prov_ref=prov_ref)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, is_part_of, node=None):
+        if node is None:
+            node = ElementTree.Element('dcterms:isPartOf')
+        
+        # set attributes
+        node.set('prov:ref',self.convertToStr(is_part_of.db_prov_ref, 'str'))
+        
+        return node
+
+class DBOpmWasDerivedFromXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'wasDerivedFrom':
+            return None
+        
+        effect = None
+        role = None
+        cause = None
+        accounts = []
+        opm_times = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'effect':
+                _data = self.getDao('opm_artifact_id_effect').fromXML(child)
+                effect = _data
+            elif child_tag == 'role':
+                _data = self.getDao('opm_role').fromXML(child)
+                role = _data
+            elif child_tag == 'cause':
+                _data = self.getDao('opm_artifact_id_cause').fromXML(child)
+                cause = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                opm_times.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmWasDerivedFrom(effect=effect,
+                                  role=role,
+                                  cause=cause,
+                                  accounts=accounts,
+                                  opm_times=opm_times)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_was_derived_from, node=None):
+        if node is None:
+            node = ElementTree.Element('wasDerivedFrom')
+        
+        # set elements
+        effect = opm_was_derived_from.db_effect
+        if effect is not None:
+            if (effect is not None) and (effect != ""):
+                childNode = ElementTree.SubElement(node, 'effect')
+                self.getDao('opm_artifact_id_effect').toXML(effect, childNode)
+        role = opm_was_derived_from.db_role
+        if role is not None:
+            if (role is not None) and (role != ""):
+                childNode = ElementTree.SubElement(node, 'role')
+                self.getDao('opm_role').toXML(role, childNode)
+        cause = opm_was_derived_from.db_cause
+        if cause is not None:
+            if (cause is not None) and (cause != ""):
+                childNode = ElementTree.SubElement(node, 'cause')
+                self.getDao('opm_artifact_id_cause').toXML(cause, childNode)
+        accounts = opm_was_derived_from.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        opm_times = opm_was_derived_from.db_opm_times
+        for opm_time in opm_times:
+            if (opm_times is not None) and (opm_times != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(opm_time, childNode)
+        
+        return node
+
+class DBControlParameterXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'controlParameter':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBControlParameter(id=id,
+                                 name=name,
+                                 value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, controlParameter, node=None):
+        if node is None:
+            node = ElementTree.Element('controlParameter')
+        
+        # set attributes
+        node.set('id',self.convertToStr(controlParameter.db_id, 'long'))
+        node.set('name',self.convertToStr(controlParameter.db_name, 'str'))
+        node.set('value',self.convertToStr(controlParameter.db_value, 'str'))
+        
+        return node
+
+class DBPluginDataXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'plugin_data':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('data', None)
+        data = self.convertFromStr(data, 'str')
+        
+        obj = DBPluginData(id=id,
+                           data=data)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, plugin_data, node=None):
+        if node is None:
+            node = ElementTree.Element('plugin_data')
+        
+        # set attributes
+        node.set('id',self.convertToStr(plugin_data.db_id, 'long'))
+        node.set('data',self.convertToStr(plugin_data.db_data, 'str'))
+        
+        return node
+
+class DBDeleteXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'delete':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('what', None)
+        what = self.convertFromStr(data, 'str')
+        data = node.get('objectId', None)
+        objectId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjId', None)
+        parentObjId = self.convertFromStr(data, 'long')
+        data = node.get('parentObjType', None)
+        parentObjType = self.convertFromStr(data, 'str')
+        
+        obj = DBDelete(id=id,
+                       what=what,
+                       objectId=objectId,
+                       parentObjId=parentObjId,
+                       parentObjType=parentObjType)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, delete, node=None):
+        if node is None:
+            node = ElementTree.Element('delete')
+        
+        # set attributes
+        node.set('id',self.convertToStr(delete.db_id, 'long'))
+        node.set('what',self.convertToStr(delete.db_what, 'str'))
+        node.set('objectId',self.convertToStr(delete.db_objectId, 'long'))
+        node.set('parentObjId',self.convertToStr(delete.db_parentObjId, 'long'))
+        node.set('parentObjType',self.convertToStr(delete.db_parentObjType, 'str'))
+        
+        return node
+
+class DBVistrailVariableXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'vistrailVariable':
+            return None
+        
+        # read attributes
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('uuid', None)
+        uuid = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('module', None)
+        module = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBVistrailVariable(name=name,
+                                 uuid=uuid,
+                                 package=package,
+                                 module=module,
+                                 namespace=namespace,
+                                 value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, vistrailVariable, node=None):
+        if node is None:
+            node = ElementTree.Element('vistrailVariable')
+        
+        # set attributes
+        node.set('name',self.convertToStr(vistrailVariable.db_name, 'str'))
+        node.set('uuid',self.convertToStr(vistrailVariable.db_uuid, 'str'))
+        node.set('package',self.convertToStr(vistrailVariable.db_package, 'str'))
+        node.set('module',self.convertToStr(vistrailVariable.db_module, 'str'))
+        node.set('namespace',self.convertToStr(vistrailVariable.db_namespace, 'str'))
+        node.set('value',self.convertToStr(vistrailVariable.db_value, 'str'))
+        
+        return node
+
+class DBOpmOverlapsXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'overlaps':
+            return None
+        
+        opm_account_ids = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                opm_account_ids.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmOverlaps(opm_account_ids=opm_account_ids)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_overlaps, node=None):
+        if node is None:
+            node = ElementTree.Element('overlaps')
+        
+        # set elements
+        opm_account_ids = opm_overlaps.db_opm_account_ids
+        for opm_account_id in opm_account_ids:
+            if (opm_account_ids is not None) and (opm_account_ids != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(opm_account_id, childNode)
+        
+        return node
+
+class DBOpmWasTriggeredByXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'wasTriggeredBy':
+            return None
+        
+        effect = None
+        role = None
+        cause = None
+        accounts = []
+        opm_times = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'effect':
+                _data = self.getDao('opm_process_id_effect').fromXML(child)
+                effect = _data
+            elif child_tag == 'role':
+                _data = self.getDao('opm_role').fromXML(child)
+                role = _data
+            elif child_tag == 'cause':
+                _data = self.getDao('opm_process_id_cause').fromXML(child)
+                cause = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child_tag == 'time':
+                _data = self.getDao('opm_time').fromXML(child)
+                opm_times.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmWasTriggeredBy(effect=effect,
+                                  role=role,
+                                  cause=cause,
+                                  accounts=accounts,
+                                  opm_times=opm_times)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_was_triggered_by, node=None):
+        if node is None:
+            node = ElementTree.Element('wasTriggeredBy')
+        
+        # set elements
+        effect = opm_was_triggered_by.db_effect
+        if effect is not None:
+            if (effect is not None) and (effect != ""):
+                childNode = ElementTree.SubElement(node, 'effect')
+                self.getDao('opm_process_id_effect').toXML(effect, childNode)
+        role = opm_was_triggered_by.db_role
+        if role is not None:
+            if (role is not None) and (role != ""):
+                childNode = ElementTree.SubElement(node, 'role')
+                self.getDao('opm_role').toXML(role, childNode)
+        cause = opm_was_triggered_by.db_cause
+        if cause is not None:
+            if (cause is not None) and (cause != ""):
+                childNode = ElementTree.SubElement(node, 'cause')
+                self.getDao('opm_process_id_cause').toXML(cause, childNode)
+        accounts = opm_was_triggered_by.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        opm_times = opm_was_triggered_by.db_opm_times
+        for opm_time in opm_times:
+            if (opm_times is not None) and (opm_times != ""):
+                childNode = ElementTree.SubElement(node, 'time')
+                self.getDao('opm_time').toXML(opm_time, childNode)
+        
+        return node
+
+class DBModuleDescriptorXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'moduleDescriptor':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('packageVersion', None)
+        package_version = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('baseDescriptorId', None)
+        base_descriptor_id = self.convertFromStr(data, 'long')
+        
+        portSpecs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'portSpec':
+                _data = self.getDao('portSpec').fromXML(child)
+                portSpecs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBModuleDescriptor(id=id,
+                                 name=name,
+                                 package=package,
+                                 namespace=namespace,
+                                 package_version=package_version,
+                                 version=version,
+                                 base_descriptor_id=base_descriptor_id,
+                                 portSpecs=portSpecs)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, module_descriptor, node=None):
+        if node is None:
+            node = ElementTree.Element('moduleDescriptor')
+        
+        # set attributes
+        node.set('id',self.convertToStr(module_descriptor.db_id, 'long'))
+        node.set('name',self.convertToStr(module_descriptor.db_name, 'str'))
+        node.set('package',self.convertToStr(module_descriptor.db_package, 'str'))
+        node.set('namespace',self.convertToStr(module_descriptor.db_namespace, 'str'))
+        node.set('packageVersion',self.convertToStr(module_descriptor.db_package_version, 'str'))
+        node.set('version',self.convertToStr(module_descriptor.db_version, 'str'))
+        node.set('baseDescriptorId',self.convertToStr(module_descriptor.db_base_descriptor_id, 'long'))
+        
+        # set elements
+        portSpecs = module_descriptor.db_portSpecs
+        for portSpec in portSpecs:
+            if (portSpecs is not None) and (portSpecs != ""):
+                childNode = ElementTree.SubElement(node, 'portSpec')
+                self.getDao('portSpec').toXML(portSpec, childNode)
+        
+        return node
+
+class DBTagXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'tag':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        
+        obj = DBTag(id=id,
+                    name=name)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, tag, node=None):
+        if node is None:
+            node = ElementTree.Element('tag')
+        
+        # set attributes
+        node.set('id',self.convertToStr(tag.db_id, 'long'))
+        node.set('name',self.convertToStr(tag.db_name, 'str'))
+        
+        return node
+
+class DBOpmRoleXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'role':
+            return None
+        
+        # read attributes
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmRole(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_role, node=None):
+        if node is None:
+            node = ElementTree.Element('role')
+        
+        # set attributes
+        node.set('value',self.convertToStr(opm_role.db_value, 'str'))
+        
+        return node
+
+class DBProvDocumentXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:document':
+            return None
+        
+        prov_entitys = []
+        prov_activitys = []
+        prov_agents = []
+        vt_connections = []
+        prov_usages = []
+        prov_generations = []
+        prov_associations = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:entity':
+                _data = self.getDao('prov_entity').fromXML(child)
+                prov_entitys.append(_data)
+            elif child_tag == 'prov:activity':
+                _data = self.getDao('prov_activity').fromXML(child)
+                prov_activitys.append(_data)
+            elif child_tag == 'prov:agent':
+                _data = self.getDao('prov_agent').fromXML(child)
+                prov_agents.append(_data)
+            elif child_tag == 'vt:connection':
+                _data = self.getDao('vt_connection').fromXML(child)
+                vt_connections.append(_data)
+            elif child_tag == 'prov:used':
+                _data = self.getDao('prov_usage').fromXML(child)
+                prov_usages.append(_data)
+            elif child_tag == 'prov:wasGeneratedBy':
+                _data = self.getDao('prov_generation').fromXML(child)
+                prov_generations.append(_data)
+            elif child_tag == 'prov:wasAssociatedWith':
+                _data = self.getDao('prov_association').fromXML(child)
+                prov_associations.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvDocument(prov_entitys=prov_entitys,
+                             prov_activitys=prov_activitys,
+                             prov_agents=prov_agents,
+                             vt_connections=vt_connections,
+                             prov_usages=prov_usages,
+                             prov_generations=prov_generations,
+                             prov_associations=prov_associations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_document, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:document')
+        
+        # set elements
+        prov_entitys = prov_document.db_prov_entitys
+        for prov_entity in prov_entitys:
+            if (prov_entitys is not None) and (prov_entitys != ""):
+                childNode = ElementTree.SubElement(node, 'prov:entity')
+                self.getDao('prov_entity').toXML(prov_entity, childNode)
+        prov_activitys = prov_document.db_prov_activitys
+        for prov_activity in prov_activitys:
+            if (prov_activitys is not None) and (prov_activitys != ""):
+                childNode = ElementTree.SubElement(node, 'prov:activity')
+                self.getDao('prov_activity').toXML(prov_activity, childNode)
+        prov_agents = prov_document.db_prov_agents
+        for prov_agent in prov_agents:
+            if (prov_agents is not None) and (prov_agents != ""):
+                childNode = ElementTree.SubElement(node, 'prov:agent')
+                self.getDao('prov_agent').toXML(prov_agent, childNode)
+        vt_connections = prov_document.db_vt_connections
+        for vt_connection in vt_connections:
+            if (vt_connections is not None) and (vt_connections != ""):
+                childNode = ElementTree.SubElement(node, 'vt:connection')
+                self.getDao('vt_connection').toXML(vt_connection, childNode)
+        prov_usages = prov_document.db_prov_usages
+        for prov_usage in prov_usages:
+            if (prov_usages is not None) and (prov_usages != ""):
+                childNode = ElementTree.SubElement(node, 'prov:used')
+                self.getDao('prov_usage').toXML(prov_usage, childNode)
+        prov_generations = prov_document.db_prov_generations
+        for prov_generation in prov_generations:
+            if (prov_generations is not None) and (prov_generations != ""):
+                childNode = ElementTree.SubElement(node, 'prov:wasGeneratedBy')
+                self.getDao('prov_generation').toXML(prov_generation, childNode)
+        prov_associations = prov_document.db_prov_associations
+        for prov_association in prov_associations:
+            if (prov_associations is not None) and (prov_associations != ""):
+                childNode = ElementTree.SubElement(node, 'prov:wasAssociatedWith')
+                self.getDao('prov_association').toXML(prov_association, childNode)
+        
+        return node
+
+class DBOpmProcessesXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'processes':
+            return None
+        
+        processs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'process':
+                _data = self.getDao('opm_process').fromXML(child)
+                processs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmProcesses(processs=processs)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_processes, node=None):
+        if node is None:
+            node = ElementTree.Element('processes')
+        
+        # set elements
+        processs = opm_processes.db_processs
+        for process in processs:
+            if (processs is not None) and (processs != ""):
+                childNode = ElementTree.SubElement(node, 'process')
+                self.getDao('opm_process').toXML(process, childNode)
+        
+        return node
+
+class DBOpmAccountIdXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'account':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmAccountId(id=id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_account_id, node=None):
+        if node is None:
+            node = ElementTree.Element('account')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_account_id.db_id, 'str'))
+        
+        return node
+
+class DBPortSpecItemXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'portSpecItem':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('pos', None)
+        pos = self.convertFromStr(data, 'long')
+        data = node.get('module', None)
+        module = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('label', None)
+        label = self.convertFromStr(data, 'str')
+        data = node.get('default', None)
+        default = self.convertFromStr(data, 'str')
+        data = node.get('values', None)
+        values = self.convertFromStr(data, 'str')
+        data = node.get('entryType', None)
+        entry_type = self.convertFromStr(data, 'str')
+        
+        obj = DBPortSpecItem(id=id,
+                             pos=pos,
+                             module=module,
+                             package=package,
+                             namespace=namespace,
+                             label=label,
+                             default=default,
+                             values=values,
+                             entry_type=entry_type)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, portSpecItem, node=None):
+        if node is None:
+            node = ElementTree.Element('portSpecItem')
+        
+        # set attributes
+        node.set('id',self.convertToStr(portSpecItem.db_id, 'long'))
+        node.set('pos',self.convertToStr(portSpecItem.db_pos, 'long'))
+        node.set('module',self.convertToStr(portSpecItem.db_module, 'str'))
+        node.set('package',self.convertToStr(portSpecItem.db_package, 'str'))
+        node.set('namespace',self.convertToStr(portSpecItem.db_namespace, 'str'))
+        node.set('label',self.convertToStr(portSpecItem.db_label, 'str'))
+        node.set('default',self.convertToStr(portSpecItem.db_default, 'str'))
+        node.set('values',self.convertToStr(portSpecItem.db_values, 'str'))
+        node.set('entryType',self.convertToStr(portSpecItem.db_entry_type, 'str'))
+        
+        return node
+
+class DBMashupComponentXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'component':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('vtid', None)
+        vtid = self.convertFromStr(data, 'long')
+        data = node.get('vttype', None)
+        vttype = self.convertFromStr(data, 'str')
+        data = node.get('vtparent_type', None)
+        vtparent_type = self.convertFromStr(data, 'str')
+        data = node.get('vtparent_id', None)
+        vtparent_id = self.convertFromStr(data, 'long')
+        data = node.get('vtpos', None)
+        vtpos = self.convertFromStr(data, 'long')
+        data = node.get('vtmid', None)
+        vtmid = self.convertFromStr(data, 'long')
+        data = node.get('pos', None)
+        pos = self.convertFromStr(data, 'long')
+        data = node.get('type', None)
+        type = self.convertFromStr(data, 'str')
+        data = node.get('val', None)
+        val = self.convertFromStr(data, 'str')
+        data = node.get('minVal', None)
+        minVal = self.convertFromStr(data, 'str')
+        data = node.get('maxVal', None)
+        maxVal = self.convertFromStr(data, 'str')
+        data = node.get('stepSize', None)
+        stepSize = self.convertFromStr(data, 'str')
+        data = node.get('valueList', None)
+        strvaluelist = self.convertFromStr(data, 'str')
+        data = node.get('widget', None)
+        widget = self.convertFromStr(data, 'str')
+        data = node.get('seq', None)
+        seq = self.convertFromStr(data, 'int')
+        data = node.get('parent', None)
+        parent = self.convertFromStr(data, 'str')
+        
+        obj = DBMashupComponent(id=id,
+                                vtid=vtid,
+                                vttype=vttype,
+                                vtparent_type=vtparent_type,
+                                vtparent_id=vtparent_id,
+                                vtpos=vtpos,
+                                vtmid=vtmid,
+                                pos=pos,
+                                type=type,
+                                val=val,
+                                minVal=minVal,
+                                maxVal=maxVal,
+                                stepSize=stepSize,
+                                strvaluelist=strvaluelist,
+                                widget=widget,
+                                seq=seq,
+                                parent=parent)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashup_component, node=None):
+        if node is None:
+            node = ElementTree.Element('component')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashup_component.db_id, 'long'))
+        node.set('vtid',self.convertToStr(mashup_component.db_vtid, 'long'))
+        node.set('vttype',self.convertToStr(mashup_component.db_vttype, 'str'))
+        node.set('vtparent_type',self.convertToStr(mashup_component.db_vtparent_type, 'str'))
+        node.set('vtparent_id',self.convertToStr(mashup_component.db_vtparent_id, 'long'))
+        node.set('vtpos',self.convertToStr(mashup_component.db_vtpos, 'long'))
+        node.set('vtmid',self.convertToStr(mashup_component.db_vtmid, 'long'))
+        node.set('pos',self.convertToStr(mashup_component.db_pos, 'long'))
+        node.set('type',self.convertToStr(mashup_component.db_type, 'str'))
+        node.set('val',self.convertToStr(mashup_component.db_val, 'str'))
+        node.set('minVal',self.convertToStr(mashup_component.db_minVal, 'str'))
+        node.set('maxVal',self.convertToStr(mashup_component.db_maxVal, 'str'))
+        node.set('stepSize',self.convertToStr(mashup_component.db_stepSize, 'str'))
+        node.set('valueList',self.convertToStr(mashup_component.db_strvaluelist, 'str'))
+        node.set('widget',self.convertToStr(mashup_component.db_widget, 'str'))
+        node.set('seq',self.convertToStr(mashup_component.db_seq, 'int'))
+        node.set('parent',self.convertToStr(mashup_component.db_parent, 'str'))
+        
+        return node
+
+class DBMashupXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'mashup':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'long')
+        data = node.get('type', None)
+        type = self.convertFromStr(data, 'str')
+        data = node.get('vtid', None)
+        vtid = self.convertFromStr(data, 'long')
+        data = node.get('has_seq', None)
+        has_seq = self.convertFromStr(data, 'int')
+        
+        aliases = []
+        layout = None
+        geometry = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'alias':
+                _data = self.getDao('mashup_alias').fromXML(child)
+                aliases.append(_data)
+            elif child_tag == 'layout':
+                _data = self.convertFromStr(child.text,'str')
+                layout = _data
+            elif child_tag == 'geometry':
+                _data = self.convertFromStr(child.text,'str')
+                geometry = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBMashup(id=id,
+                       name=name,
+                       version=version,
+                       aliases=aliases,
+                       type=type,
+                       vtid=vtid,
+                       layout=layout,
+                       geometry=geometry,
+                       has_seq=has_seq)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashup, node=None):
+        if node is None:
+            node = ElementTree.Element('mashup')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashup.db_id, 'long'))
+        node.set('name',self.convertToStr(mashup.db_name, 'str'))
+        node.set('version',self.convertToStr(mashup.db_version, 'long'))
+        node.set('type',self.convertToStr(mashup.db_type, 'str'))
+        node.set('vtid',self.convertToStr(mashup.db_vtid, 'long'))
+        node.set('has_seq',self.convertToStr(mashup.db_has_seq, 'int'))
+        
+        # set elements
+        aliases = mashup.db_aliases
+        for alias in aliases:
+            if (aliases is not None) and (aliases != ""):
+                childNode = ElementTree.SubElement(node, 'alias')
+                self.getDao('mashup_alias').toXML(alias, childNode)
+        layout = mashup.db_layout
+        if (layout is not None) and (layout != ""):
+            childNode = ElementTree.SubElement(node, 'layout')
+            childNode.text = self.convertToStr(layout, 'str')
+        geometry = mashup.db_geometry
+        if (geometry is not None) and (geometry != ""):
+            childNode = ElementTree.SubElement(node, 'geometry')
+            childNode.text = self.convertToStr(geometry, 'str')
+        
+        return node
+
+class DBMachineXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'machine':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('os', None)
+        os = self.convertFromStr(data, 'str')
+        data = node.get('architecture', None)
+        architecture = self.convertFromStr(data, 'str')
+        data = node.get('processor', None)
+        processor = self.convertFromStr(data, 'str')
+        data = node.get('ram', None)
+        ram = self.convertFromStr(data, 'int')
+        
+        obj = DBMachine(id=id,
+                        name=name,
+                        os=os,
+                        architecture=architecture,
+                        processor=processor,
+                        ram=ram)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, machine, node=None):
+        if node is None:
+            node = ElementTree.Element('machine')
+        
+        # set attributes
+        node.set('id',self.convertToStr(machine.db_id, 'long'))
+        node.set('name',self.convertToStr(machine.db_name, 'str'))
+        node.set('os',self.convertToStr(machine.db_os, 'str'))
+        node.set('architecture',self.convertToStr(machine.db_architecture, 'str'))
+        node.set('processor',self.convertToStr(machine.db_processor, 'str'))
+        node.set('ram',self.convertToStr(machine.db_ram, 'int'))
+        
+        return node
+
+class DBConfigFloatXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'float':
+            return None
+        
+        # read attributes
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'float')
+        
+        obj = DBConfigFloat(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, config_float, node=None):
+        if node is None:
+            node = ElementTree.Element('float')
+        
+        # set attributes
+        node.set('value',self.convertToStr(config_float.db_value, 'float'))
+        
+        return node
+
+class DBOtherXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'other':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('key', None)
+        key = self.convertFromStr(data, 'str')
+        
+        value = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'value':
+                _data = self.convertFromStr(child.text,'str')
+                value = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOther(id=id,
+                      key=key,
+                      value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, other, node=None):
+        if node is None:
+            node = ElementTree.Element('other')
+        
+        # set attributes
+        node.set('id',self.convertToStr(other.db_id, 'long'))
+        node.set('key',self.convertToStr(other.db_key, 'str'))
+        
+        # set elements
+        value = other.db_value
+        if (value is not None) and (value != ""):
+            childNode = ElementTree.SubElement(node, 'value')
+            childNode.text = self.convertToStr(value, 'str')
+        
+        return node
+
+class DBRefProvActivityXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:activity':
+            return None
+        
+        # read attributes
+        data = node.get('prov:ref', None)
+        prov_ref = self.convertFromStr(data, 'str')
+        
+        obj = DBRefProvActivity(prov_ref=prov_ref)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, ref_prov_activity, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:activity')
+        
+        # set attributes
+        node.set('prov:ref',self.convertToStr(ref_prov_activity.db_prov_ref, 'str'))
+        
+        return node
+
+class DBAbstractionXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'abstraction':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('cache', None)
+        cache = self.convertFromStr(data, 'int')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('namespace', None)
+        namespace = self.convertFromStr(data, 'str')
+        data = node.get('package', None)
+        package = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('internalVersion', None)
+        internal_version = self.convertFromStr(data, 'str')
+        
+        location = None
+        functions = []
+        annotations = []
+        controlParameters = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'location':
+                _data = self.getDao('location').fromXML(child)
+                location = _data
+            elif child_tag == 'function':
+                _data = self.getDao('function').fromXML(child)
+                functions.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'controlParameter':
+                _data = self.getDao('controlParameter').fromXML(child)
+                controlParameters.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBAbstraction(id=id,
+                            cache=cache,
+                            name=name,
+                            namespace=namespace,
+                            package=package,
+                            version=version,
+                            internal_version=internal_version,
+                            location=location,
+                            functions=functions,
+                            annotations=annotations,
+                            controlParameters=controlParameters)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, abstraction, node=None):
+        if node is None:
+            node = ElementTree.Element('abstraction')
+        
+        # set attributes
+        node.set('id',self.convertToStr(abstraction.db_id, 'long'))
+        node.set('cache',self.convertToStr(abstraction.db_cache, 'int'))
+        node.set('name',self.convertToStr(abstraction.db_name, 'str'))
+        node.set('namespace',self.convertToStr(abstraction.db_namespace, 'str'))
+        node.set('package',self.convertToStr(abstraction.db_package, 'str'))
+        node.set('version',self.convertToStr(abstraction.db_version, 'str'))
+        node.set('internalVersion',self.convertToStr(abstraction.db_internal_version, 'str'))
+        
+        # set elements
+        location = abstraction.db_location
+        if location is not None:
+            if (location is not None) and (location != ""):
+                childNode = ElementTree.SubElement(node, 'location')
+                self.getDao('location').toXML(location, childNode)
+        functions = abstraction.db_functions
+        for function in functions:
+            if (functions is not None) and (functions != ""):
+                childNode = ElementTree.SubElement(node, 'function')
+                self.getDao('function').toXML(function, childNode)
+        annotations = abstraction.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        controlParameters = abstraction.db_controlParameters
+        for controlParameter in controlParameters:
+            if (controlParameters is not None) and (controlParameters != ""):
+                childNode = ElementTree.SubElement(node, 'controlParameter')
+                self.getDao('controlParameter').toXML(controlParameter, childNode)
+        
+        return node
+
+class DBProvAgentXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:agent':
+            return None
+        
+        # read attributes
+        data = node.get('prov:id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        vt_id = None
+        prov_type = None
+        prov_label = None
+        vt_machine_os = None
+        vt_machine_architecture = None
+        vt_machine_processor = None
+        vt_machine_ram = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'vt:id':
+                _data = self.convertFromStr(child.text,'str')
+                vt_id = _data
+            elif child_tag == 'prov:type':
+                _data = self.convertFromStr(child.text,'str')
+                prov_type = _data
+            elif child_tag == 'prov:label':
+                _data = self.convertFromStr(child.text,'str')
+                prov_label = _data
+            elif child_tag == 'vt:machine_os':
+                _data = self.convertFromStr(child.text,'str')
+                vt_machine_os = _data
+            elif child_tag == 'vt:machine_architecture':
+                _data = self.convertFromStr(child.text,'str')
+                vt_machine_architecture = _data
+            elif child_tag == 'vt:machine_processor':
+                _data = self.convertFromStr(child.text,'str')
+                vt_machine_processor = _data
+            elif child_tag == 'vt:machine_ram':
+                _data = self.convertFromStr(child.text,'str')
+                vt_machine_ram = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvAgent(id=id,
+                          vt_id=vt_id,
+                          prov_type=prov_type,
+                          prov_label=prov_label,
+                          vt_machine_os=vt_machine_os,
+                          vt_machine_architecture=vt_machine_architecture,
+                          vt_machine_processor=vt_machine_processor,
+                          vt_machine_ram=vt_machine_ram)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_agent, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:agent')
+        
+        # set attributes
+        node.set('prov:id',self.convertToStr(prov_agent.db_id, 'str'))
+        
+        # set elements
+        vt_id = prov_agent.db_vt_id
+        if (vt_id is not None) and (vt_id != ""):
+            childNode = ElementTree.SubElement(node, 'vt:id')
+            childNode.text = self.convertToStr(vt_id, 'str')
+        prov_type = prov_agent.db_prov_type
+        if (prov_type is not None) and (prov_type != ""):
+            childNode = ElementTree.SubElement(node, 'prov:type')
+            childNode.text = self.convertToStr(prov_type, 'str')
+        prov_label = prov_agent.db_prov_label
+        if (prov_label is not None) and (prov_label != ""):
+            childNode = ElementTree.SubElement(node, 'prov:label')
+            childNode.text = self.convertToStr(prov_label, 'str')
+        vt_machine_os = prov_agent.db_vt_machine_os
+        if (vt_machine_os is not None) and (vt_machine_os != ""):
+            childNode = ElementTree.SubElement(node, 'vt:machine_os')
+            childNode.text = self.convertToStr(vt_machine_os, 'str')
+        vt_machine_architecture = prov_agent.db_vt_machine_architecture
+        if (vt_machine_architecture is not None) and (vt_machine_architecture != ""):
+            childNode = ElementTree.SubElement(node, 'vt:machine_architecture')
+            childNode.text = self.convertToStr(vt_machine_architecture, 'str')
+        vt_machine_processor = prov_agent.db_vt_machine_processor
+        if (vt_machine_processor is not None) and (vt_machine_processor != ""):
+            childNode = ElementTree.SubElement(node, 'vt:machine_processor')
+            childNode.text = self.convertToStr(vt_machine_processor, 'str')
+        vt_machine_ram = prov_agent.db_vt_machine_ram
+        if (vt_machine_ram is not None) and (vt_machine_ram != ""):
+            childNode = ElementTree.SubElement(node, 'vt:machine_ram')
+            childNode.text = self.convertToStr(vt_machine_ram, 'str')
+        
+        return node
+
+class DBMashuptrailXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'mashuptrail':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('vtVersion', None)
+        vtVersion = self.convertFromStr(data, 'long')
+        
+        actions = []
+        annotations = []
+        actionAnnotations = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'action':
+                _data = self.getDao('mashup_action').fromXML(child)
+                actions.append(_data)
+            elif child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'actionAnnotation':
+                _data = self.getDao('mashup_actionAnnotation').fromXML(child)
+                actionAnnotations.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBMashuptrail(name=name,
+                            version=version,
+                            vtVersion=vtVersion,
+                            actions=actions,
+                            annotations=annotations,
+                            actionAnnotations=actionAnnotations)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashuptrail, node=None):
+        if node is None:
+            node = ElementTree.Element('mashuptrail')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashuptrail.db_name, 'str'))
+        node.set('version',self.convertToStr(mashuptrail.db_version, 'str'))
+        node.set('vtVersion',self.convertToStr(mashuptrail.db_vtVersion, 'long'))
+        
+        # set elements
+        actions = mashuptrail.db_actions
+        for action in actions:
+            if (actions is not None) and (actions != ""):
+                childNode = ElementTree.SubElement(node, 'action')
+                self.getDao('mashup_action').toXML(action, childNode)
+        annotations = mashuptrail.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        actionAnnotations = mashuptrail.db_actionAnnotations
+        for actionAnnotation in actionAnnotations:
+            if (actionAnnotations is not None) and (actionAnnotations != ""):
+                childNode = ElementTree.SubElement(node, 'actionAnnotation')
+                self.getDao('mashup_actionAnnotation').toXML(actionAnnotation, childNode)
+        
+        return node
+
+class DBRegistryXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'registry':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('version', None)
+        version = self.convertFromStr(data, 'str')
+        data = node.get('rootDescriptorId', None)
+        root_descriptor_id = self.convertFromStr(data, 'long')
+        
+        packages = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'package':
+                _data = self.getDao('package').fromXML(child)
+                packages.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBRegistry(id=id,
+                         version=version,
+                         root_descriptor_id=root_descriptor_id,
+                         packages=packages)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, registry, node=None):
+        if node is None:
+            node = ElementTree.Element('registry')
+        
+        # set attributes
+        node.set('id',self.convertToStr(registry.db_id, 'long'))
+        node.set('version',self.convertToStr(registry.db_version, 'str'))
+        node.set('rootDescriptorId',self.convertToStr(registry.db_root_descriptor_id, 'long'))
+        
+        # set elements
+        packages = registry.db_packages
+        for package in packages:
+            if (packages is not None) and (packages != ""):
+                childNode = ElementTree.SubElement(node, 'package')
+                self.getDao('package').toXML(package, childNode)
+        
+        return node
+
+class DBOpmAgentXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'agent':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        value = None
+        accounts = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'value':
+                _data = self.convertFromStr(child.text,'str')
+                value = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmAgent(id=id,
+                         value=value,
+                         accounts=accounts)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_agent, node=None):
+        if node is None:
+            node = ElementTree.Element('agent')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_agent.db_id, 'str'))
+        
+        # set elements
+        value = opm_agent.db_value
+        if (value is not None) and (value != ""):
+            childNode = ElementTree.SubElement(node, 'value')
+            childNode.text = self.convertToStr(value, 'str')
+        accounts = opm_agent.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        
+        return node
+
+class DBProvEntityXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:entity':
+            return None
+        
+        # read attributes
+        data = node.get('prov:id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        prov_type = None
+        prov_label = None
+        prov_value = None
+        vt_id = None
+        vt_type = None
+        vt_desc = None
+        vt_package = None
+        vt_version = None
+        vt_cache = None
+        vt_location_x = None
+        vt_location_y = None
+        is_part_of = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:type':
+                _data = self.convertFromStr(child.text,'str')
+                prov_type = _data
+            elif child_tag == 'prov:label':
+                _data = self.convertFromStr(child.text,'str')
+                prov_label = _data
+            elif child_tag == 'prov:value':
+                _data = self.convertFromStr(child.text,'str')
+                prov_value = _data
+            elif child_tag == 'vt:id':
+                _data = self.convertFromStr(child.text,'str')
+                vt_id = _data
+            elif child_tag == 'vt:type':
+                _data = self.convertFromStr(child.text,'str')
+                vt_type = _data
+            elif child_tag == 'vt:desc':
+                _data = self.convertFromStr(child.text,'str')
+                vt_desc = _data
+            elif child_tag == 'vt:package':
+                _data = self.convertFromStr(child.text,'str')
+                vt_package = _data
+            elif child_tag == 'vt:version':
+                _data = self.convertFromStr(child.text,'str')
+                vt_version = _data
+            elif child_tag == 'vt:cache':
+                _data = self.convertFromStr(child.text,'str')
+                vt_cache = _data
+            elif child_tag == 'vt:location_x':
+                _data = self.convertFromStr(child.text,'str')
+                vt_location_x = _data
+            elif child_tag == 'vt:location_y':
+                _data = self.convertFromStr(child.text,'str')
+                vt_location_y = _data
+            elif child_tag == 'dcterms:isPartOf':
+                _data = self.getDao('is_part_of').fromXML(child)
+                is_part_of = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvEntity(id=id,
+                           prov_type=prov_type,
+                           prov_label=prov_label,
+                           prov_value=prov_value,
+                           vt_id=vt_id,
+                           vt_type=vt_type,
+                           vt_desc=vt_desc,
+                           vt_package=vt_package,
+                           vt_version=vt_version,
+                           vt_cache=vt_cache,
+                           vt_location_x=vt_location_x,
+                           vt_location_y=vt_location_y,
+                           is_part_of=is_part_of)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_entity, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:entity')
+        
+        # set attributes
+        node.set('prov:id',self.convertToStr(prov_entity.db_id, 'str'))
+        
+        # set elements
+        prov_type = prov_entity.db_prov_type
+        if (prov_type is not None) and (prov_type != ""):
+            childNode = ElementTree.SubElement(node, 'prov:type')
+            childNode.text = self.convertToStr(prov_type, 'str')
+        prov_label = prov_entity.db_prov_label
+        if (prov_label is not None) and (prov_label != ""):
+            childNode = ElementTree.SubElement(node, 'prov:label')
+            childNode.text = self.convertToStr(prov_label, 'str')
+        prov_value = prov_entity.db_prov_value
+        if (prov_value is not None) and (prov_value != ""):
+            childNode = ElementTree.SubElement(node, 'prov:value')
+            childNode.text = self.convertToStr(prov_value, 'str')
+        vt_id = prov_entity.db_vt_id
+        if (vt_id is not None) and (vt_id != ""):
+            childNode = ElementTree.SubElement(node, 'vt:id')
+            childNode.text = self.convertToStr(vt_id, 'str')
+        vt_type = prov_entity.db_vt_type
+        if (vt_type is not None) and (vt_type != ""):
+            childNode = ElementTree.SubElement(node, 'vt:type')
+            childNode.text = self.convertToStr(vt_type, 'str')
+        vt_desc = prov_entity.db_vt_desc
+        if (vt_desc is not None) and (vt_desc != ""):
+            childNode = ElementTree.SubElement(node, 'vt:desc')
+            childNode.text = self.convertToStr(vt_desc, 'str')
+        vt_package = prov_entity.db_vt_package
+        if (vt_package is not None) and (vt_package != ""):
+            childNode = ElementTree.SubElement(node, 'vt:package')
+            childNode.text = self.convertToStr(vt_package, 'str')
+        vt_version = prov_entity.db_vt_version
+        if (vt_version is not None) and (vt_version != ""):
+            childNode = ElementTree.SubElement(node, 'vt:version')
+            childNode.text = self.convertToStr(vt_version, 'str')
+        vt_cache = prov_entity.db_vt_cache
+        if (vt_cache is not None) and (vt_cache != ""):
+            childNode = ElementTree.SubElement(node, 'vt:cache')
+            childNode.text = self.convertToStr(vt_cache, 'str')
+        vt_location_x = prov_entity.db_vt_location_x
+        if (vt_location_x is not None) and (vt_location_x != ""):
+            childNode = ElementTree.SubElement(node, 'vt:location_x')
+            childNode.text = self.convertToStr(vt_location_x, 'str')
+        vt_location_y = prov_entity.db_vt_location_y
+        if (vt_location_y is not None) and (vt_location_y != ""):
+            childNode = ElementTree.SubElement(node, 'vt:location_y')
+            childNode.text = self.convertToStr(vt_location_y, 'str')
+        is_part_of = prov_entity.db_is_part_of
+        if is_part_of is not None:
+            if (is_part_of is not None) and (is_part_of != ""):
+                childNode = ElementTree.SubElement(node, 'dcterms:isPartOf')
+                self.getDao('is_part_of').toXML(is_part_of, childNode)
+        
+        return node
+
+class DBAnnotationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'annotation':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('key', None)
+        key = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        
+        obj = DBAnnotation(id=id,
+                           key=key,
+                           value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, annotation, node=None):
+        if node is None:
+            node = ElementTree.Element('annotation')
+        
+        # set attributes
+        node.set('id',self.convertToStr(annotation.db_id, 'long'))
+        node.set('key',self.convertToStr(annotation.db_key, 'str'))
+        node.set('value',self.convertToStr(annotation.db_value, 'str'))
+        
+        return node
+
+class DBOpmTimeXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'time':
+            return None
+        
+        # read attributes
+        data = node.get('noLaterThan', None)
+        no_later_than = self.convertFromStr(data, 'datetime')
+        data = node.get('noEarlierThan', None)
+        no_earlier_than = self.convertFromStr(data, 'datetime')
+        data = node.get('clockId', None)
+        clock_id = self.convertFromStr(data, 'str')
+        
+        obj = DBOpmTime(no_later_than=no_later_than,
+                        no_earlier_than=no_earlier_than,
+                        clock_id=clock_id)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_time, node=None):
+        if node is None:
+            node = ElementTree.Element('time')
+        
+        # set attributes
+        node.set('noLaterThan',self.convertToStr(opm_time.db_no_later_than, 'datetime'))
+        node.set('noEarlierThan',self.convertToStr(opm_time.db_no_earlier_than, 'datetime'))
+        node.set('clockId',self.convertToStr(opm_time.db_clock_id, 'str'))
+        
+        return node
+
+class DBParameterExplorationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'parameterExploration':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('actionId', None)
+        action_id = self.convertFromStr(data, 'long')
+        data = node.get('name', None)
+        name = self.convertFromStr(data, 'str')
+        data = node.get('date', None)
+        date = self.convertFromStr(data, 'datetime')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        data = node.get('dims', None)
+        dims = self.convertFromStr(data, 'str')
+        data = node.get('layout', None)
+        layout = self.convertFromStr(data, 'str')
+        
+        functions = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'peFunction':
+                _data = self.getDao('pe_function').fromXML(child)
+                functions.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBParameterExploration(id=id,
+                                     action_id=action_id,
+                                     name=name,
+                                     date=date,
+                                     user=user,
+                                     dims=dims,
+                                     layout=layout,
+                                     functions=functions)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, parameter_exploration, node=None):
+        if node is None:
+            node = ElementTree.Element('parameterExploration')
+        
+        # set attributes
+        node.set('id',self.convertToStr(parameter_exploration.db_id, 'long'))
+        node.set('actionId',self.convertToStr(parameter_exploration.db_action_id, 'long'))
+        node.set('name',self.convertToStr(parameter_exploration.db_name, 'str'))
+        node.set('date',self.convertToStr(parameter_exploration.db_date, 'datetime'))
+        node.set('user',self.convertToStr(parameter_exploration.db_user, 'str'))
+        node.set('dims',self.convertToStr(parameter_exploration.db_dims, 'str'))
+        node.set('layout',self.convertToStr(parameter_exploration.db_layout, 'str'))
+        
+        # set elements
+        functions = parameter_exploration.db_functions
+        for function in functions:
+            if (functions is not None) and (functions != ""):
+                childNode = ElementTree.SubElement(node, 'peFunction')
+                self.getDao('pe_function').toXML(function, childNode)
+        
+        return node
+
+class DBMashupActionAnnotationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'actionAnnotation':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('key', None)
+        key = self.convertFromStr(data, 'str')
+        data = node.get('value', None)
+        value = self.convertFromStr(data, 'str')
+        data = node.get('action_id', None)
+        action_id = self.convertFromStr(data, 'long')
+        data = node.get('date', None)
+        date = self.convertFromStr(data, 'datetime')
+        data = node.get('user', None)
+        user = self.convertFromStr(data, 'str')
+        
+        obj = DBMashupActionAnnotation(id=id,
+                                       key=key,
+                                       value=value,
+                                       action_id=action_id,
+                                       date=date,
+                                       user=user)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, mashup_actionAnnotation, node=None):
+        if node is None:
+            node = ElementTree.Element('actionAnnotation')
+        
+        # set attributes
+        node.set('id',self.convertToStr(mashup_actionAnnotation.db_id, 'long'))
+        node.set('key',self.convertToStr(mashup_actionAnnotation.db_key, 'str'))
+        node.set('value',self.convertToStr(mashup_actionAnnotation.db_value, 'str'))
+        node.set('action_id',self.convertToStr(mashup_actionAnnotation.db_action_id, 'long'))
+        node.set('date',self.convertToStr(mashup_actionAnnotation.db_date, 'datetime'))
+        node.set('user',self.convertToStr(mashup_actionAnnotation.db_user, 'str'))
+        
+        return node
+
+class DBOpmProcessXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'process':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'str')
+        
+        value = None
+        accounts = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'value':
+                _data = self.getDao('opm_process_value').fromXML(child)
+                value = _data
+            elif child_tag == 'account':
+                _data = self.getDao('opm_account_id').fromXML(child)
+                accounts.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmProcess(id=id,
+                           value=value,
+                           accounts=accounts)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_process, node=None):
+        if node is None:
+            node = ElementTree.Element('process')
+        
+        # set attributes
+        node.set('id',self.convertToStr(opm_process.db_id, 'str'))
+        
+        # set elements
+        value = opm_process.db_value
+        if value is not None:
+            if (value is not None) and (value != ""):
+                childNode = ElementTree.SubElement(node, 'value')
+                self.getDao('opm_process_value').toXML(value, childNode)
+        accounts = opm_process.db_accounts
+        for account in accounts:
+            if (accounts is not None) and (accounts != ""):
+                childNode = ElementTree.SubElement(node, 'account')
+                self.getDao('opm_account_id').toXML(account, childNode)
+        
+        return node
+
+class DBDisabledPackagesXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'disabledpackages':
+            return None
+        
+        packages = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'package':
+                _data = self.getDao('startup_package').fromXML(child)
+                packages.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBDisabledPackages(packages=packages)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, disabled_packages, node=None):
+        if node is None:
+            node = ElementTree.Element('disabledpackages')
+        
+        # set elements
+        packages = disabled_packages.db_packages
+        for package in packages:
+            if (packages is not None) and (packages != ""):
+                childNode = ElementTree.SubElement(node, 'package')
+                self.getDao('startup_package').toXML(package, childNode)
+        
+        return node
+
+class DBModuleExecXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'moduleExec':
+            return None
+        
+        # read attributes
+        data = node.get('id', None)
+        id = self.convertFromStr(data, 'long')
+        data = node.get('tsStart', None)
+        ts_start = self.convertFromStr(data, 'datetime')
+        data = node.get('tsEnd', None)
+        ts_end = self.convertFromStr(data, 'datetime')
+        data = node.get('cached', None)
+        cached = self.convertFromStr(data, 'int')
+        data = node.get('moduleId', None)
+        module_id = self.convertFromStr(data, 'long')
+        data = node.get('moduleName', None)
+        module_name = self.convertFromStr(data, 'str')
+        data = node.get('completed', None)
+        completed = self.convertFromStr(data, 'int')
+        data = node.get('error', None)
+        error = self.convertFromStr(data, 'str')
+        data = node.get('machine_id', None)
+        machine_id = self.convertFromStr(data, 'long')
+        
+        annotations = []
+        loop_execs = []
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'annotation':
+                _data = self.getDao('annotation').fromXML(child)
+                annotations.append(_data)
+            elif child_tag == 'loopExec':
+                _data = self.getDao('loop_exec').fromXML(child)
+                loop_execs.append(_data)
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBModuleExec(id=id,
+                           ts_start=ts_start,
+                           ts_end=ts_end,
+                           cached=cached,
+                           module_id=module_id,
+                           module_name=module_name,
+                           completed=completed,
+                           error=error,
+                           machine_id=machine_id,
+                           annotations=annotations,
+                           loop_execs=loop_execs)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, module_exec, node=None):
+        if node is None:
+            node = ElementTree.Element('moduleExec')
+        
+        # set attributes
+        node.set('id',self.convertToStr(module_exec.db_id, 'long'))
+        node.set('tsStart',self.convertToStr(module_exec.db_ts_start, 'datetime'))
+        node.set('tsEnd',self.convertToStr(module_exec.db_ts_end, 'datetime'))
+        node.set('cached',self.convertToStr(module_exec.db_cached, 'int'))
+        node.set('moduleId',self.convertToStr(module_exec.db_module_id, 'long'))
+        node.set('moduleName',self.convertToStr(module_exec.db_module_name, 'str'))
+        node.set('completed',self.convertToStr(module_exec.db_completed, 'int'))
+        node.set('error',self.convertToStr(module_exec.db_error, 'str'))
+        node.set('machine_id',self.convertToStr(module_exec.db_machine_id, 'long'))
+        
+        # set elements
+        annotations = module_exec.db_annotations
+        for annotation in annotations:
+            if (annotations is not None) and (annotations != ""):
+                childNode = ElementTree.SubElement(node, 'annotation')
+                self.getDao('annotation').toXML(annotation, childNode)
+        loop_execs = module_exec.db_loop_execs
+        for loop_exec in loop_execs:
+            if (loop_execs is not None) and (loop_execs != ""):
+                childNode = ElementTree.SubElement(node, 'loopExec')
+                self.getDao('loop_exec').toXML(loop_exec, childNode)
+        
+        return node
+
+class DBProvAssociationXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'prov:wasAssociatedWith':
+            return None
+        
+        prov_activity = None
+        prov_agent = None
+        prov_plan = None
+        prov_role = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'prov:activity':
+                _data = self.getDao('ref_prov_activity').fromXML(child)
+                prov_activity = _data
+            elif child_tag == 'prov:agent':
+                _data = self.getDao('ref_prov_agent').fromXML(child)
+                prov_agent = _data
+            elif child_tag == 'prov:plan':
+                _data = self.getDao('ref_prov_plan').fromXML(child)
+                prov_plan = _data
+            elif child_tag == 'prov:role':
+                _data = self.convertFromStr(child.text,'str')
+                prov_role = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBProvAssociation(prov_activity=prov_activity,
+                                prov_agent=prov_agent,
+                                prov_plan=prov_plan,
+                                prov_role=prov_role)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, prov_association, node=None):
+        if node is None:
+            node = ElementTree.Element('prov:wasAssociatedWith')
+        
+        # set elements
+        prov_activity = prov_association.db_prov_activity
+        if prov_activity is not None:
+            if (prov_activity is not None) and (prov_activity != ""):
+                childNode = ElementTree.SubElement(node, 'prov:activity')
+                self.getDao('ref_prov_activity').toXML(prov_activity, childNode)
+        prov_agent = prov_association.db_prov_agent
+        if prov_agent is not None:
+            if (prov_agent is not None) and (prov_agent != ""):
+                childNode = ElementTree.SubElement(node, 'prov:agent')
+                self.getDao('ref_prov_agent').toXML(prov_agent, childNode)
+        prov_plan = prov_association.db_prov_plan
+        if prov_plan is not None:
+            if (prov_plan is not None) and (prov_plan != ""):
+                childNode = ElementTree.SubElement(node, 'prov:plan')
+                self.getDao('ref_prov_plan').toXML(prov_plan, childNode)
+        prov_role = prov_association.db_prov_role
+        if (prov_role is not None) and (prov_role != ""):
+            childNode = ElementTree.SubElement(node, 'prov:role')
+            childNode.text = self.convertToStr(prov_role, 'str')
+        
+        return node
+
+class DBOpmProcessValueXMLDAOBase(XMLDAO):
+
+    def __init__(self, daoList):
+        self.daoList = daoList
+
+    def getDao(self, dao):
+        return self.daoList[dao]
+
+    def fromXML(self, node):
+        if node.tag[0] == "{":
+            node_tag = node.tag.split("}")[1]
+        else:
+            node_tag = node.tag
+        if node_tag != 'value':
+            return None
+        
+        value = None
+        
+        # read children
+        for child in node.getchildren():
+            if child.tag[0] == "{":
+                child_tag = child.tag.split("}")[1]
+            else:
+                child_tag = child.tag
+            if child_tag == 'moduleExec':
+                _data = self.getDao('module_exec').fromXML(child)
+                value = _data
+            elif child_tag == 'groupExec':
+                _data = self.getDao('group_exec').fromXML(child)
+                value = _data
+            elif child_tag == 'loopExec':
+                _data = self.getDao('loop_exec').fromXML(child)
+                value = _data
+            elif child.text is None or child.text.strip() == '':
+                pass
+            else:
+                print '*** ERROR *** tag = %s' % child.tag
+        
+        obj = DBOpmProcessValue(value=value)
+        obj.is_dirty = False
+        return obj
+    
+    def toXML(self, opm_process_value, node=None):
+        if node is None:
+            node = ElementTree.Element('value')
+        
+        # set elements
+        value = opm_process_value.db_value
+        if value is not None:
+            if value.vtType == 'module_exec':
+                childNode = ElementTree.SubElement(node, 'moduleExec')
+                self.getDao('module_exec').toXML(value, childNode)
+            elif value.vtType == 'group_exec':
+                childNode = ElementTree.SubElement(node, 'groupExec')
+                self.getDao('group_exec').toXML(value, childNode)
+            elif value.vtType == 'loop_exec':
+                childNode = ElementTree.SubElement(node, 'loopExec')
+                self.getDao('loop_exec').toXML(value, childNode)
+        
+        return node
+
+"""generated automatically by auto_dao.py"""
+
+class XMLDAOListBase(dict):
+
+    def __init__(self, daos=None):
+        if daos is not None:
+            dict.update(self, daos)
+
+        if 'opm_was_generated_by' not in self:
+            self['opm_was_generated_by'] = DBOpmWasGeneratedByXMLDAOBase(self)
+        if 'config_key' not in self:
+            self['config_key'] = DBConfigKeyXMLDAOBase(self)
+        if 'mashup_alias' not in self:
+            self['mashup_alias'] = DBMashupAliasXMLDAOBase(self)
+        if 'group' not in self:
+            self['group'] = DBGroupXMLDAOBase(self)
+        if 'opm_was_controlled_by' not in self:
+            self['opm_was_controlled_by'] = DBOpmWasControlledByXMLDAOBase(self)
+        if 'add' not in self:
+            self['add'] = DBAddXMLDAOBase(self)
+        if 'prov_generation' not in self:
+            self['prov_generation'] = DBProvGenerationXMLDAOBase(self)
+        if 'opm_used' not in self:
+            self['opm_used'] = DBOpmUsedXMLDAOBase(self)
+        if 'opm_artifact_id_cause' not in self:
+            self['opm_artifact_id_cause'] = DBOpmArtifactIdCauseXMLDAOBase(self)
+        if 'ref_prov_entity' not in self:
+            self['ref_prov_entity'] = DBRefProvEntityXMLDAOBase(self)
+        if 'vt_connection' not in self:
+            self['vt_connection'] = DBVtConnectionXMLDAOBase(self)
+        if 'opm_account' not in self:
+            self['opm_account'] = DBOpmAccountXMLDAOBase(self)
+        if 'group_exec' not in self:
+            self['group_exec'] = DBGroupExecXMLDAOBase(self)
+        if 'opm_agent_id' not in self:
+            self['opm_agent_id'] = DBOpmAgentIdXMLDAOBase(self)
+        if 'parameter' not in self:
+            self['parameter'] = DBParameterXMLDAOBase(self)
+        if 'vistrail' not in self:
+            self['vistrail'] = DBVistrailXMLDAOBase(self)
+        if 'opm_artifact_value' not in self:
+            self['opm_artifact_value'] = DBOpmArtifactValueXMLDAOBase(self)
+        if 'config_str' not in self:
+            self['config_str'] = DBConfigStrXMLDAOBase(self)
+        if 'startup' not in self:
+            self['startup'] = DBStartupXMLDAOBase(self)
+        if 'module' not in self:
+            self['module'] = DBModuleXMLDAOBase(self)
+        if 'port' not in self:
+            self['port'] = DBPortXMLDAOBase(self)
+        if 'opm_agents' not in self:
+            self['opm_agents'] = DBOpmAgentsXMLDAOBase(self)
+        if 'opm_dependencies' not in self:
+            self['opm_dependencies'] = DBOpmDependenciesXMLDAOBase(self)
+        if 'pe_function' not in self:
+            self['pe_function'] = DBPEFunctionXMLDAOBase(self)
+        if 'workflow' not in self:
+            self['workflow'] = DBWorkflowXMLDAOBase(self)
+        if 'mashup_action' not in self:
+            self['mashup_action'] = DBMashupActionXMLDAOBase(self)
+        if 'configuration' not in self:
+            self['configuration'] = DBConfigurationXMLDAOBase(self)
+        if 'change' not in self:
+            self['change'] = DBChangeXMLDAOBase(self)
+        if 'package' not in self:
+            self['package'] = DBPackageXMLDAOBase(self)
+        if 'loop_exec' not in self:
+            self['loop_exec'] = DBLoopExecXMLDAOBase(self)
+        if 'connection' not in self:
+            self['connection'] = DBConnectionXMLDAOBase(self)
+        if 'config_bool' not in self:
+            self['config_bool'] = DBConfigBoolXMLDAOBase(self)
+        if 'action' not in self:
+            self['action'] = DBActionXMLDAOBase(self)
+        if 'startup_package' not in self:
+            self['startup_package'] = DBStartupPackageXMLDAOBase(self)
+        if 'config_int' not in self:
+            self['config_int'] = DBConfigIntXMLDAOBase(self)
+        if 'opm_process_id_effect' not in self:
+            self['opm_process_id_effect'] = DBOpmProcessIdEffectXMLDAOBase(self)
+        if 'ref_prov_plan' not in self:
+            self['ref_prov_plan'] = DBRefProvPlanXMLDAOBase(self)
+        if 'opm_accounts' not in self:
+            self['opm_accounts'] = DBOpmAccountsXMLDAOBase(self)
+        if 'ref_prov_agent' not in self:
+            self['ref_prov_agent'] = DBRefProvAgentXMLDAOBase(self)
+        if 'portSpec' not in self:
+            self['portSpec'] = DBPortSpecXMLDAOBase(self)
+        if 'enabled_packages' not in self:
+            self['enabled_packages'] = DBEnabledPackagesXMLDAOBase(self)
+        if 'opm_artifact' not in self:
+            self['opm_artifact'] = DBOpmArtifactXMLDAOBase(self)
+        if 'log' not in self:
+            self['log'] = DBLogXMLDAOBase(self)
+        if 'loop_iteration' not in self:
+            self['loop_iteration'] = DBLoopIterationXMLDAOBase(self)
+        if 'opm_process_id_cause' not in self:
+            self['opm_process_id_cause'] = DBOpmProcessIdCauseXMLDAOBase(self)
+        if 'opm_artifacts' not in self:
+            self['opm_artifacts'] = DBOpmArtifactsXMLDAOBase(self)
+        if 'pe_parameter' not in self:
+            self['pe_parameter'] = DBPEParameterXMLDAOBase(self)
+        if 'workflow_exec' not in self:
+            self['workflow_exec'] = DBWorkflowExecXMLDAOBase(self)
+        if 'location' not in self:
+            self['location'] = DBLocationXMLDAOBase(self)
+        if 'function' not in self:
+            self['function'] = DBFunctionXMLDAOBase(self)
+        if 'actionAnnotation' not in self:
+            self['actionAnnotation'] = DBActionAnnotationXMLDAOBase(self)
+        if 'prov_activity' not in self:
+            self['prov_activity'] = DBProvActivityXMLDAOBase(self)
+        if 'prov_usage' not in self:
+            self['prov_usage'] = DBProvUsageXMLDAOBase(self)
+        if 'opm_artifact_id_effect' not in self:
+            self['opm_artifact_id_effect'] = DBOpmArtifactIdEffectXMLDAOBase(self)
+        if 'opm_graph' not in self:
+            self['opm_graph'] = DBOpmGraphXMLDAOBase(self)
+        if 'is_part_of' not in self:
+            self['is_part_of'] = DBIsPartOfXMLDAOBase(self)
+        if 'opm_was_derived_from' not in self:
+            self['opm_was_derived_from'] = DBOpmWasDerivedFromXMLDAOBase(self)
+        if 'controlParameter' not in self:
+            self['controlParameter'] = DBControlParameterXMLDAOBase(self)
+        if 'plugin_data' not in self:
+            self['plugin_data'] = DBPluginDataXMLDAOBase(self)
+        if 'delete' not in self:
+            self['delete'] = DBDeleteXMLDAOBase(self)
+        if 'vistrailVariable' not in self:
+            self['vistrailVariable'] = DBVistrailVariableXMLDAOBase(self)
+        if 'opm_overlaps' not in self:
+            self['opm_overlaps'] = DBOpmOverlapsXMLDAOBase(self)
+        if 'opm_was_triggered_by' not in self:
+            self['opm_was_triggered_by'] = DBOpmWasTriggeredByXMLDAOBase(self)
+        if 'module_descriptor' not in self:
+            self['module_descriptor'] = DBModuleDescriptorXMLDAOBase(self)
+        if 'tag' not in self:
+            self['tag'] = DBTagXMLDAOBase(self)
+        if 'opm_role' not in self:
+            self['opm_role'] = DBOpmRoleXMLDAOBase(self)
+        if 'prov_document' not in self:
+            self['prov_document'] = DBProvDocumentXMLDAOBase(self)
+        if 'opm_processes' not in self:
+            self['opm_processes'] = DBOpmProcessesXMLDAOBase(self)
+        if 'opm_account_id' not in self:
+            self['opm_account_id'] = DBOpmAccountIdXMLDAOBase(self)
+        if 'portSpecItem' not in self:
+            self['portSpecItem'] = DBPortSpecItemXMLDAOBase(self)
+        if 'mashup_component' not in self:
+            self['mashup_component'] = DBMashupComponentXMLDAOBase(self)
+        if 'mashup' not in self:
+            self['mashup'] = DBMashupXMLDAOBase(self)
+        if 'machine' not in self:
+            self['machine'] = DBMachineXMLDAOBase(self)
+        if 'config_float' not in self:
+            self['config_float'] = DBConfigFloatXMLDAOBase(self)
+        if 'other' not in self:
+            self['other'] = DBOtherXMLDAOBase(self)
+        if 'ref_prov_activity' not in self:
+            self['ref_prov_activity'] = DBRefProvActivityXMLDAOBase(self)
+        if 'abstraction' not in self:
+            self['abstraction'] = DBAbstractionXMLDAOBase(self)
+        if 'prov_agent' not in self:
+            self['prov_agent'] = DBProvAgentXMLDAOBase(self)
+        if 'mashuptrail' not in self:
+            self['mashuptrail'] = DBMashuptrailXMLDAOBase(self)
+        if 'registry' not in self:
+            self['registry'] = DBRegistryXMLDAOBase(self)
+        if 'opm_agent' not in self:
+            self['opm_agent'] = DBOpmAgentXMLDAOBase(self)
+        if 'prov_entity' not in self:
+            self['prov_entity'] = DBProvEntityXMLDAOBase(self)
+        if 'annotation' not in self:
+            self['annotation'] = DBAnnotationXMLDAOBase(self)
+        if 'opm_time' not in self:
+            self['opm_time'] = DBOpmTimeXMLDAOBase(self)
+        if 'parameter_exploration' not in self:
+            self['parameter_exploration'] = DBParameterExplorationXMLDAOBase(self)
+        if 'mashup_actionAnnotation' not in self:
+            self['mashup_actionAnnotation'] = DBMashupActionAnnotationXMLDAOBase(self)
+        if 'opm_process' not in self:
+            self['opm_process'] = DBOpmProcessXMLDAOBase(self)
+        if 'disabled_packages' not in self:
+            self['disabled_packages'] = DBDisabledPackagesXMLDAOBase(self)
+        if 'module_exec' not in self:
+            self['module_exec'] = DBModuleExecXMLDAOBase(self)
+        if 'prov_association' not in self:
+            self['prov_association'] = DBProvAssociationXMLDAOBase(self)
+        if 'opm_process_value' not in self:
+            self['opm_process_value'] = DBOpmProcessValueXMLDAOBase(self)
diff --git a/vistrails/db/versions/v1_0_5/persistence/xml/xml_dao.py b/vistrails/db/versions/v1_0_5/persistence/xml/xml_dao.py
new file mode 100644
index 000000000..f66024cb7
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/persistence/xml/xml_dao.py
@@ -0,0 +1,93 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+from datetime import date, datetime
+
+from vistrails.core.system import strftime, time_strptime
+
+class XMLDAO:
+    def __init__(self):
+        pass
+
+    def hasAttribute(self, node, attr):
+        return node.hasAttribute(attr)
+
+    def getAttribute(self, node, attr):
+        try:
+            attribute = node.attributes.get(attr)
+            if attribute is not None:
+                return attribute.value
+        except KeyError:
+            pass
+        return None
+
+    def convertFromStr(self, value, type):
+        if value is not None:
+            if type == 'str':
+                return str(value)
+            elif value.strip() != '':
+                if type == 'long':
+                    try:
+                        return long(value)
+                    except ValueError:
+                        return -1
+                elif type == 'float':
+                    return float(value)
+                elif type == 'int':
+                    try:
+                        return int(value)
+                    except ValueError:
+                        if 'False' == value:
+                            return -1
+                        else:
+                            return 0
+                elif type == 'date':
+                    return date(*time_strptime(value, '%Y-%m-%d')[0:3])
+                elif type == 'datetime':
+                    return datetime(*time_strptime(value, '%Y-%m-%d %H:%M:%S')[0:6])
+        return None
+
+    def convertToStr(self, value, type):
+        if value is not None:
+            if type == 'date':
+                return value.isoformat()
+            elif type == 'datetime':
+                return strftime(value, '%Y-%m-%d %H:%M:%S')
+            else:
+                return str(value)
+        return ''
diff --git a/vistrails/db/versions/v1_0_5/schemas/sql/vistrails.sql b/vistrails/db/versions/v1_0_5/schemas/sql/vistrails.sql
new file mode 100644
index 000000000..1feac2054
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/sql/vistrails.sql
@@ -0,0 +1,550 @@
+--#############################################################################
+--
+-- Copyright (C) 2014-2016, New York University.
+-- Copyright (C) 2011-2014, NYU-Poly.
+-- Copyright (C) 2006-2011, University of Utah.
+-- All rights reserved.
+-- Contact: contact@vistrails.org
+--
+-- This file is part of VisTrails.
+--
+-- "Redistribution and use in source and binary forms, with or without
+-- modification, are permitted provided that the following conditions are met:
+--
+--  - Redistributions of source code must retain the above copyright notice,
+--    this list of conditions and the following disclaimer.
+--  - Redistributions in binary form must reproduce the above copyright
+--    notice, this list of conditions and the following disclaimer in the
+--    documentation and/or other materials provided with the distribution.
+--  - Neither the name of the New York University nor the names of its
+--    contributors may be used to endorse or promote products derived from
+--    this software without specific prior written permission.
+--
+-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+-- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+-- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+-- PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+-- CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+-- OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+-- WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+-- OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+-- ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+--
+--#############################################################################
+
+CREATE TABLE `vistrails_version`(`version` char(16)) engine=InnoDB;
+INSERT INTO `vistrails_version`(`version`) VALUES ('1.0.5');
+
+CREATE TABLE thumbnail(
+    id int not null auto_increment primary key,
+    file_name varchar(255),
+    image_bytes mediumblob,
+    last_modified datetime
+) engine=InnoDB;
+
+-- generated automatically by auto_dao.py
+
+CREATE TABLE mashup_alias(
+    id int,
+    name varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE group_tbl(
+    id int,
+    cache int,
+    name varchar(255),
+    namespace varchar(255),
+    package varchar(511),
+    version varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE add_tbl(
+    id int,
+    what varchar(255),
+    object_id int,
+    par_obj_id int,
+    par_obj_type char(16),
+    action_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE group_exec(
+    id int,
+    ts_start datetime,
+    ts_end datetime,
+    cached int,
+    module_id int,
+    group_name varchar(255),
+    group_type varchar(255),
+    completed int,
+    error varchar(1023),
+    machine_id int,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE parameter(
+    id int,
+    pos int,
+    name varchar(255),
+    type varchar(255),
+    val mediumtext,
+    alias varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE vistrail(
+    id int not null auto_increment primary key,
+    entity_type char(16),
+    version char(16),
+    name varchar(255),
+    last_modified datetime
+) engine=InnoDB;
+
+CREATE TABLE module(
+    id int,
+    cache int,
+    name varchar(255),
+    namespace varchar(255),
+    package varchar(511),
+    version varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE port(
+    id int,
+    type varchar(255),
+    moduleId int,
+    moduleName varchar(255),
+    name varchar(255),
+    signature varchar(4095),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE pe_function(
+    id int,
+    module_id int,
+    port_name varchar(255),
+    is_alias int,
+    parent_type char(32),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE workflow(
+    id int not null auto_increment primary key,
+    entity_id int,
+    entity_type char(16),
+    name varchar(255),
+    version char(16),
+    last_modified datetime,
+    vistrail_id int,
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE mashup_action(
+    id int,
+    prev_id int,
+    date datetime,
+    user varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE change_tbl(
+    id int,
+    what varchar(255),
+    old_obj_id int,
+    new_obj_id int,
+    par_obj_id int,
+    par_obj_type char(16),
+    action_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE package(
+    id int not null auto_increment primary key,
+    name varchar(255),
+    identifier varchar(1023),
+    codepath varchar(1023),
+    load_configuration int,
+    version varchar(255),
+    description varchar(1023),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE loop_exec(
+    id int,
+    ts_start datetime,
+    ts_end datetime,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE connection_tbl(
+    id int,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE action(
+    id int,
+    prev_id int,
+    date datetime,
+    session int,
+    user varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE port_spec(
+    id int,
+    name varchar(255),
+    type varchar(255),
+    optional int,
+    depth int,
+    union varchar(255),
+    sort_key int,
+    min_conns int,
+    max_conns int,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE log_tbl(
+    id int not null auto_increment primary key,
+    entity_type char(16),
+    version char(16),
+    name varchar(255),
+    last_modified datetime,
+    vistrail_id int
+) engine=InnoDB;
+
+CREATE TABLE loop_iteration(
+    id int,
+    ts_start datetime,
+    ts_end datetime,
+    iteration int,
+    completed int,
+    error varchar(1023),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE pe_parameter(
+    id int,
+    pos int,
+    interpolator varchar(255),
+    value mediumtext,
+    dimension int,
+    parent_type char(32),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE workflow_exec(
+    id int,
+    user varchar(255),
+    ip varchar(255),
+    session int,
+    vt_version varchar(255),
+    ts_start datetime,
+    ts_end datetime,
+    parent_id int,
+    parent_type varchar(255),
+    parent_version int,
+    completed int,
+    name varchar(255),
+    log_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE location(
+    id int,
+    x DECIMAL(18,12),
+    y DECIMAL(18,12),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE function(
+    id int,
+    pos int,
+    name varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE action_annotation(
+    id int,
+    akey varchar(255),
+    value varchar(8191),
+    action_id int,
+    date datetime,
+    user varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE control_parameter(
+    id int,
+    name varchar(255),
+    value mediumtext,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE plugin_data(
+    id int,
+    data varchar(8191),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE delete_tbl(
+    id int,
+    what varchar(255),
+    object_id int,
+    par_obj_id int,
+    par_obj_type char(16),
+    action_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE vistrail_variable(
+    name varchar(255),
+    uuid char(36),
+    package varchar(255),
+    module varchar(255),
+    namespace varchar(255),
+    value varchar(8191),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE module_descriptor(
+    id int,
+    name varchar(255),
+    package varchar(255),
+    namespace varchar(255),
+    package_version varchar(255),
+    version varchar(255),
+    base_descriptor_id int,
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE tag(
+    id int,
+    name varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE port_spec_item(
+    id int,
+    pos int,
+    module varchar(255),
+    package varchar(255),
+    namespace varchar(255),
+    label varchar(4095),
+    _default varchar(4095),
+    _values mediumtext,
+    entry_type varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE mashup_component(
+    id int,
+    vtid int,
+    vttype varchar(255),
+    vtparent_type char(32),
+    vtparent_id int,
+    vtpos int,
+    vtmid int,
+    pos int,
+    type varchar(255),
+    val mediumtext,
+    minVal varchar(255),
+    maxVal varchar(255),
+    stepSize varchar(255),
+    strvaluelist mediumtext,
+    widget varchar(255),
+    seq int,
+    parent varchar(255),
+    alias_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE mashup(
+    id int,
+    name varchar(255),
+    version int,
+    type varchar(255),
+    vtid int,
+    layout mediumtext,
+    geometry mediumtext,
+    has_seq int,
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE machine(
+    id int,
+    name varchar(255),
+    os varchar(255),
+    architecture varchar(255),
+    processor varchar(255),
+    ram bigint,
+    vt_id int,
+    log_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE other(
+    id int,
+    okey varchar(255),
+    value varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE abstraction(
+    id int,
+    cache int,
+    name varchar(255),
+    namespace varchar(255),
+    package varchar(511),
+    version varchar(255),
+    internal_version varchar(255),
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE mashuptrail(
+    id int not null auto_increment primary key,
+    name char(36),
+    version char(16),
+    vt_version int,
+    last_modified datetime,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE registry(
+    id int not null auto_increment primary key,
+    entity_type char(16),
+    version char(16),
+    root_descriptor_id int,
+    name varchar(255),
+    last_modified datetime
+) engine=InnoDB;
+
+CREATE TABLE annotation(
+    id int,
+    akey varchar(255),
+    value mediumtext,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
+CREATE TABLE parameter_exploration(
+    id int,
+    action_id int,
+    name varchar(255),
+    date datetime,
+    user varchar(255),
+    dims varchar(255),
+    layout varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE mashup_action_annotation(
+    id int,
+    akey varchar(255),
+    value varchar(8191),
+    action_id int,
+    date datetime,
+    user varchar(255),
+    parent_id int,
+    entity_id int,
+    entity_type char(16)
+) engine=InnoDB;
+
+CREATE TABLE module_exec(
+    id int,
+    ts_start datetime,
+    ts_end datetime,
+    cached int,
+    module_id int,
+    module_name varchar(255),
+    completed int,
+    error varchar(1023),
+    machine_id int,
+    parent_type char(32),
+    entity_id int,
+    entity_type char(16),
+    parent_id int
+) engine=InnoDB;
+
diff --git a/vistrails/db/versions/v1_0_5/schemas/sql/vistrails_drop.sql b/vistrails/db/versions/v1_0_5/schemas/sql/vistrails_drop.sql
new file mode 100644
index 000000000..afcfd5fca
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/sql/vistrails_drop.sql
@@ -0,0 +1,43 @@
+--#############################################################################
+--
+-- Copyright (C) 2014-2016, New York University.
+-- Copyright (C) 2011-2014, NYU-Poly.
+-- Copyright (C) 2006-2011, University of Utah.
+-- All rights reserved.
+-- Contact: contact@vistrails.org
+--
+-- This file is part of VisTrails.
+--
+-- "Redistribution and use in source and binary forms, with or without
+-- modification, are permitted provided that the following conditions are met:
+--
+--  - Redistributions of source code must retain the above copyright notice,
+--    this list of conditions and the following disclaimer.
+--  - Redistributions in binary form must reproduce the above copyright
+--    notice, this list of conditions and the following disclaimer in the
+--    documentation and/or other materials provided with the distribution.
+--  - Neither the name of the New York University nor the names of its
+--    contributors may be used to endorse or promote products derived from
+--    this software without specific prior written permission.
+--
+-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+-- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+-- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+-- PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+-- CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+-- EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+-- OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+-- WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+-- OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+-- ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+--
+--#############################################################################
+
+DROP TABLE IF EXISTS `vistrails_version`;
+
+DROP TABLE IF EXISTS thumbnail;
+
+-- genereated automatically by generate.py
+
+DROP TABLE IF EXISTS mashup_alias, group_tbl, add_tbl, group_exec, parameter, vistrail, module, port, pe_function, workflow, mashup_action, change_tbl, package, loop_exec, connection_tbl, action, port_spec, log_tbl, loop_iteration, pe_parameter, workflow_exec, location, function, action_annotation, control_parameter, plugin_data, delete_tbl, vistrail_variable, module_descriptor, tag, port_spec_item, mashup_component, mashup, machine, other, abstraction, mashuptrail, registry, annotation, parameter_exploration, mashup_action_annotation, module_exec;
diff --git a/vistrails/db/versions/v1_0_5/schemas/xml/log.xsd b/vistrails/db/versions/v1_0_5/schemas/xml/log.xsd
new file mode 100644
index 000000000..96fe47aac
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/xml/log.xsd
@@ -0,0 +1,157 @@
+<!--###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+-->
+
+<?xml version="1.0"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
+  <xs:element name="log">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="workflow_exec" ref="workflowExec" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="vistrail_id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="workflowExec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="machine" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:choice>
+          <xs:element name="module_exec" ref="moduleExec" minOccurs="0" maxOccurs="1"/>
+          <xs:element name="group_exec" ref="groupExec" minOccurs="0" maxOccurs="1"/>
+          <xs:element name="loop_exec" ref="loopExec" minOccurs="0" maxOccurs="1"/>
+        </xs:choice>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="user" type="xs:string"/>
+      <xs:attribute name="ip" type="xs:string"/>
+      <xs:attribute name="session" type="xs:int"/>
+      <xs:attribute name="vtVersion" type="xs:string"/>
+      <xs:attribute name="tsStart" type="xs:dateTime"/>
+      <xs:attribute name="tsEnd" type="xs:dateTime"/>
+      <xs:attribute name="parentId" type="xs:int"/>
+      <xs:attribute name="parentType" type="xs:string"/>
+      <xs:attribute name="parentVersion" type="xs:int"/>
+      <xs:attribute name="completed" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="annotation">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="machine">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="os" type="xs:string"/>
+      <xs:attribute name="architecture" type="xs:string"/>
+      <xs:attribute name="processor" type="xs:string"/>
+      <xs:attribute name="ram" type="xs:long"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="moduleExec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element name="loop_exec" ref="loopExec" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="tsStart" type="xs:dateTime"/>
+      <xs:attribute name="tsEnd" type="xs:dateTime"/>
+      <xs:attribute name="cached" type="xs:int"/>
+      <xs:attribute name="moduleId" type="xs:int"/>
+      <xs:attribute name="moduleName" type="xs:string"/>
+      <xs:attribute name="completed" type="xs:int"/>
+      <xs:attribute name="error" type="xs:string"/>
+      <xs:attribute name="machine_id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="groupExec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:choice>
+          <xs:element name="module_exec" ref="moduleExec" minOccurs="0" maxOccurs="1"/>
+          <xs:element name="group_exec" ref="groupExec" minOccurs="0" maxOccurs="1"/>
+          <xs:element name="loop_exec" ref="loopExec" minOccurs="0" maxOccurs="1"/>
+        </xs:choice>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="tsStart" type="xs:dateTime"/>
+      <xs:attribute name="tsEnd" type="xs:dateTime"/>
+      <xs:attribute name="cached" type="xs:int"/>
+      <xs:attribute name="moduleId" type="xs:int"/>
+      <xs:attribute name="groupName" type="xs:string"/>
+      <xs:attribute name="groupType" type="xs:string"/>
+      <xs:attribute name="completed" type="xs:int"/>
+      <xs:attribute name="error" type="xs:string"/>
+      <xs:attribute name="machine_id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="loopExec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="loop_iteration" ref="loopIteration" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="tsStart" type="xs:dateTime"/>
+      <xs:attribute name="tsEnd" type="xs:dateTime"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="loopIteration">
+    <xs:complexType>
+      <xs:choice>
+        <xs:element name="module_exec" ref="moduleExec" minOccurs="0" maxOccurs="1"/>
+        <xs:element name="group_exec" ref="groupExec" minOccurs="0" maxOccurs="1"/>
+        <xs:element name="loop_exec" ref="loopExec" minOccurs="0" maxOccurs="1"/>
+      </xs:choice>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="tsStart" type="xs:dateTime"/>
+      <xs:attribute name="tsEnd" type="xs:dateTime"/>
+      <xs:attribute name="iteration" type="xs:int"/>
+      <xs:attribute name="completed" type="xs:int"/>
+      <xs:attribute name="error" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+</xs:schema>
diff --git a/vistrails/db/versions/v1_0_5/schemas/xml/vistrail.xsd b/vistrails/db/versions/v1_0_5/schemas/xml/vistrail.xsd
new file mode 100644
index 000000000..3373d5778
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/xml/vistrail.xsd
@@ -0,0 +1,364 @@
+<!--###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+-->
+
+<?xml version="1.0"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
+  <xs:element name="vistrail">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="action" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="tag" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="vistrailVariable" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element name="parameter_exploration" ref="parameterExploration" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="actionAnnotation" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="action">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:choice>
+          <xs:element ref="add" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="delete" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="change" minOccurs="0" maxOccurs="1"/>
+        </xs:choice>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="prevId" type="xs:int"/>
+      <xs:attribute name="date" type="xs:dateTime"/>
+      <xs:attribute name="session" type="xs:int"/>
+      <xs:attribute name="user" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="tag">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="annotation">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="controlParameter">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="vistrailVariable">
+    <xs:complexType>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="uuid" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="module" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="parameterExploration">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="function" ref="peFunction" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="actionId" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="date" type="xs:dateTime"/>
+      <xs:attribute name="user" type="xs:string"/>
+      <xs:attribute name="dims" type="xs:string"/>
+      <xs:attribute name="layout" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="actionAnnotation">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+      <xs:attribute name="actionId" type="xs:int"/>
+      <xs:attribute name="date" type="xs:dateTime"/>
+      <xs:attribute name="user" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="add">
+    <xs:complexType>
+      <xs:choice>
+        <xs:element ref="module" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="connection" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="port" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="parameter" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="portSpec" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="abstraction" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="group" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="other" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="plugin_data" minOccurs="0" maxOccurs="1"/>
+      </xs:choice>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="what" type="xs:string"/>
+      <xs:attribute name="objectId" type="xs:int"/>
+      <xs:attribute name="parentObjId" type="xs:int"/>
+      <xs:attribute name="parentObjType" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="delete">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="what" type="xs:string"/>
+      <xs:attribute name="objectId" type="xs:int"/>
+      <xs:attribute name="parentObjId" type="xs:int"/>
+      <xs:attribute name="parentObjType" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="change">
+    <xs:complexType>
+      <xs:choice>
+        <xs:element ref="module" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="connection" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="port" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="parameter" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="portSpec" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="abstraction" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="group" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="other" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="plugin_data" minOccurs="0" maxOccurs="1"/>
+      </xs:choice>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="what" type="xs:string"/>
+      <xs:attribute name="oldObjId" type="xs:int"/>
+      <xs:attribute name="newObjId" type="xs:int"/>
+      <xs:attribute name="parentObjId" type="xs:int"/>
+      <xs:attribute name="parentObjType" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="peFunction">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="parameter" ref="peParameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="moduleId" type="xs:int"/>
+      <xs:attribute name="port_name" type="xs:string"/>
+      <xs:attribute name="is_alias" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="module">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="portSpec" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="location">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="x" type="xs:float"/>
+      <xs:attribute name="y" type="xs:float"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="function">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="connection">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="port" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="port">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="moduleId" type="xs:int"/>
+      <xs:attribute name="moduleName" type="xs:string"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="signature" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="parameter">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="val" type="xs:string"/>
+      <xs:attribute name="alias" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="portSpec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="portSpecItem" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="optional" type="xs:int"/>
+      <xs:attribute name="depth" type="xs:int"/>
+      <xs:attribute name="union" type="xs:string"/>
+      <xs:attribute name="sortKey" type="xs:int"/>
+      <xs:attribute name="minConns" type="xs:int"/>
+      <xs:attribute name="maxConns" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="abstraction">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="internalVersion" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="group">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="workflow" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="other">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="value" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="plugin_data">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="data" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="peParameter">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="interpolator" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+      <xs:attribute name="dimension" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="portSpecItem">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="module" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="label" type="xs:string"/>
+      <xs:attribute name="default" type="xs:string"/>
+      <xs:attribute name="values" type="xs:string"/>
+      <xs:attribute name="entryType" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="workflow">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="connection" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="plugin_data" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="other" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:choice>
+          <xs:element ref="module" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="abstraction" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="group" minOccurs="0" maxOccurs="1"/>
+        </xs:choice>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="vistrail_id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+</xs:schema>
diff --git a/vistrails/db/versions/v1_0_5/schemas/xml/vtlink.xsd b/vistrails/db/versions/v1_0_5/schemas/xml/vtlink.xsd
new file mode 100644
index 000000000..45913a87d
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/xml/vtlink.xsd
@@ -0,0 +1,70 @@
+<!--###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+-->
+<?xml version="1.0" encoding="UTF-8"?>
+
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
+<xs:element name="vtlink">
+<xs:complexType>
+<!-- if the vistrail is in a DB use host, database, port and vtid -->
+<xs:attribute name="host" type="xs:string"></xs:attribute>
+<xs:attribute name="database" type="xs:string"></xs:attribute>
+<xs:attribute name="port" type="xs:int"></xs:attribute>
+<xs:attribute name="vtid" type="xs:int"></xs:attribute>
+<!-- if the vistrail is a file use filename below -->
+<xs:attribute name="filename" type="xs:string"></xs:attribute>
+<!-- this is the workflow version -->
+<xs:attribute name="version" type="xs:int"></xs:attribute>
+<!-- this is the workflow tag -->
+<xs:attribute name="tag" type="xs:string"></xs:attribute>
+<xs:attribute name="url" type="xs:string"></xs:attribute>
+<!--  vtcontent can be a workflow in xml or a .vt file base64 encoded -->
+<xs:attribute name="vtcontent" type="xs:string"></xs:attribute>
+<!--  if execute is true the workflow will be executed -->
+<xs:attribute name="execute" type="xs:boolean"></xs:attribute>
+<!--  if showSpreadsheetOnly is True we will hide the builder -->
+<xs:attribute name="showSpreadsheetOnly" type="xs:boolean"></xs:attribute>
+<!--  if there's database information and a workflow is embedded, it will
+force loading from the db instead of using the emebedded version -->
+<xs:attribute name="forceDB" type="xs:boolean"></xs:attribute>
+<!--  if mashuptrail and mashupVersion are set, VisTrails will execute the
+mashup -->
+<xs:attribute name="mashuptrail" type="xs:string"></xs:attribute>
+<xs:attribute name="mashupVersion" type="xs:int"></xs:attribute>
+</xs:complexType>
+</xs:element>
+
+</xs:schema>
diff --git a/vistrails/db/versions/v1_0_5/schemas/xml/workflow.xsd b/vistrails/db/versions/v1_0_5/schemas/xml/workflow.xsd
new file mode 100644
index 000000000..391e9b860
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/schemas/xml/workflow.xsd
@@ -0,0 +1,213 @@
+<!--###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+-->
+
+<?xml version="1.0"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
+  <xs:element name="workflow">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="connection" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="plugin_data" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="other" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:choice>
+          <xs:element ref="module" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="abstraction" minOccurs="0" maxOccurs="1"/>
+          <xs:element ref="group" minOccurs="0" maxOccurs="1"/>
+        </xs:choice>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="vistrail_id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="connection">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="port" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="annotation">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="plugin_data">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="data" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="other">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element name="value" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="key" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="module">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="portSpec" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="abstraction">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+      <xs:attribute name="internalVersion" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="group">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="workflow" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="location" minOccurs="0" maxOccurs="1"/>
+        <xs:element ref="function" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="annotation" minOccurs="0" maxOccurs="unbounded"/>
+        <xs:element ref="controlParameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="cache" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="version" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="port">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="moduleId" type="xs:int"/>
+      <xs:attribute name="moduleName" type="xs:string"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="signature" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="location">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="x" type="xs:float"/>
+      <xs:attribute name="y" type="xs:float"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="function">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="controlParameter">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="value" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="portSpec">
+    <xs:complexType>
+      <xs:sequence>
+        <xs:element ref="portSpecItem" minOccurs="0" maxOccurs="unbounded"/>
+      </xs:sequence>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="optional" type="xs:int"/>
+      <xs:attribute name="depth" type="xs:int"/>
+      <xs:attribute name="union" type="xs:string"/>
+      <xs:attribute name="sortKey" type="xs:int"/>
+      <xs:attribute name="minConns" type="xs:int"/>
+      <xs:attribute name="maxConns" type="xs:int"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="parameter">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="name" type="xs:string"/>
+      <xs:attribute name="type" type="xs:string"/>
+      <xs:attribute name="val" type="xs:string"/>
+      <xs:attribute name="alias" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+  <xs:element name="portSpecItem">
+    <xs:complexType>
+      <xs:attribute name="id" type="xs:int"/>
+      <xs:attribute name="pos" type="xs:int"/>
+      <xs:attribute name="module" type="xs:string"/>
+      <xs:attribute name="package" type="xs:string"/>
+      <xs:attribute name="namespace" type="xs:string"/>
+      <xs:attribute name="label" type="xs:string"/>
+      <xs:attribute name="default" type="xs:string"/>
+      <xs:attribute name="values" type="xs:string"/>
+      <xs:attribute name="entryType" type="xs:string"/>
+    </xs:complexType>
+  </xs:element>
+</xs:schema>
diff --git a/vistrails/db/versions/v1_0_5/specs/all.xml b/vistrails/db/versions/v1_0_5/specs/all.xml
new file mode 100644
index 000000000..ff238cdc7
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/specs/all.xml
@@ -0,0 +1,4144 @@
+<!--###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+-->
+<objects>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ABSTRACTION +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="abstraction">
+    <layout>
+      <xml name="abstraction" nodeType="xs:element"/>
+      <sql table="abstraction"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="cache" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(511)"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="internal_version" type="str">
+      <xml name="internalVersion" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="location" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="function" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property ref="true" object="controlParameter" type="list" mapping="one-to-many"
+	          index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ACTION ++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="action">
+    <layout>
+      <xml name="action" nodeType="xs:element"/>
+      <sql table="action"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="prevId" type="long" foreignKey="true" object="action">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="prev_id" type="int"/>
+    </property>
+
+    <property name="date" type="datetime">
+      <xml nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="session" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <choice name="operation" type="list" mapping="one-to-many">
+      <property name="add" ref="true" object="add">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="delete" ref="true" object="delete">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="change" ref="true" object="change">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+    
+    <property ref="true" object="vistrail" type="long" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ADD +++++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="add">
+    <layout>
+      <xml name="add" nodeType="xs:element"/>
+      <sql table="add_tbl"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="what" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="objectId" type="long" foreignKey="true" discriminator="what">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="object_id" type="int"/>
+    </property>
+
+    <property name="parentObjId" type="long" foreignKey="true"
+	      discriminator="parentObjType">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="par_obj_id" type="int"/>
+    </property>
+
+    <property name="parentObjType" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="par_obj_type" type="char(16)"/>
+    </property>
+    
+    <choice name="data" type="object" discriminator="what">
+      <property ref="true" object="module" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="location" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="annotation" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="controlParameter" mapping="one-to-one">
+        <xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="function" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="connection" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="port" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="parameter" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="portSpec" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="abstraction" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="group" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="other" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="plugin_data" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+
+    <property name="action" type="long" ref="true" object="action" 
+	      mapping="many-to-one" inverse="true">
+      <sql column="action_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ACTION_ANNOTATION +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="actionAnnotation">
+    <layout>
+      <xml nodeType="xs:element"/>
+      <sql table="action_annotation"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="key" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="akey" type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(8191)"/>
+    </property>
+
+    <property name="action_id" type="long" foreignKey="true" object="action">
+      <xml name="actionId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="date" type="datetime">
+      <xml nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>    
+
+    <property ref="true" type="long" object="vistrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ANNOTATION ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="annotation">
+    <layout>
+      <xml name="annotation" nodeType="xs:element"/>
+      <sql table="annotation"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="key" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="akey" type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="vistrail">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="module">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="workflow_exec">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="module_exec">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group_exec">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="action">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="abstraction">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="mashuptrail">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONTROL PARAMETER +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="controlParameter">
+    <layout>
+      <xml nodeType="xs:element"/>
+      <sql table="control_parameter"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="name" type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="vistrail">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="module">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="abstraction">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+    </choice>
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- VISTRAIL_VARIABLE +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="vistrailVariable">
+    <layout>
+      <xml nodeType="xs:element"/>
+      <sql table="vistrail_variable"/>
+    </layout>
+
+    <property name="name" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="name" type="varchar(255)"/>
+    </property>
+
+    <property name="uuid" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="uuid" type="char(36)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="package" type="varchar(255)"/>
+    </property>
+
+    <property name="module" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="module" type="varchar(255)"/>
+    </property>
+
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="namespace" type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="value" type="varchar(8191)"/>
+    </property>
+
+    <property ref="true" type="long" object="vistrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CHANGE ++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="change">
+    <layout>
+      <xml name="change" nodeType="xs:element"/>
+      <sql table="change_tbl"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="what" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="oldObjId" type="long" foreignKey="true" discriminator="what">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="old_obj_id" type="int"/>
+    </property>
+
+    <property name="newObjId" type="long" foreignKey="true" discriminator="what">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="new_obj_id" type="int"/>
+    </property>
+
+    <property name="parentObjId" type="long" foreignKey="true" 
+	      discriminator="parentObjType">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="par_obj_id" type="int"/>
+    </property>
+
+    <property name="parentObjType" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="par_obj_type" type="char(16)"/>
+    </property>
+
+    <choice name="data" type="object" discriminator="what">
+      <property ref="true" object="module" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="location" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="annotation" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+	  <property ref="true" object="controlParameter" mapping="one-to-one">
+        <xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="function" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="connection" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="port" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="parameter" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="portSpec" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="abstraction" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="group" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="other" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+      <property ref="true" object="plugin_data" mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+    
+    <property name="action" type="long" ref="true" object="action" 
+	      mapping="many-to-one" inverse="true">
+      <sql column="action_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONNECTION ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="connection">
+    <layout>
+      <xml name="connection" nodeType="xs:element"/>
+      <sql table="connection_tbl"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="port" type="list" mapping="one-to-many"
+	      index="type">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+    
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- DELETE ++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="delete">
+    <layout>
+      <xml name="delete" nodeType="xs:element"/>
+      <sql table="delete_tbl"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="what" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="objectId" type="long" foreignKey="true" discriminator="what">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="object_id" type="int"/>
+    </property>
+
+    <property name="parentObjId" type="long" foreignKey="true" 
+	      discriminator="parentObjType">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="par_obj_id" type="int"/>
+    </property>
+
+    <property name="parentObjType" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="par_obj_type" type="char(16)"/>
+    </property>
+
+    <property name="action" type="long" ref="true" object="action" 
+	      mapping="many-to-one" inverse="true">
+      <sql column="action_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- FUNCTION ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="function">
+    <layout>
+      <xml name="function" nodeType="xs:element"/>
+      <sql table="function"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="pos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="parameter" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="module">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="abstraction">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="group">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- GROUP +++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="group" parentClass="module">
+    <layout>
+      <xml name="group" nodeType="xs:element"/>
+      <sql table="group_tbl"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="workflow" type="object" mapping="one-to-one" 
+	      expand="false">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="cache" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(511)"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="location" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="function" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property ref="true" object="controlParameter" type="list" mapping="one-to-many"
+	          index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- LOCATION ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="location">
+    <layout>
+      <xml name="location" nodeType="xs:element"/>
+      <sql table="location"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="x" type="float">
+      <xml nodeType="xs:attribute" type="xs:float"/>
+      <sql type="DECIMAL(18,12)"/>
+    </property>
+
+    <property name="y" type="float">
+      <xml nodeType="xs:attribute" type="xs:float"/>
+      <sql type="DECIMAL(18,12)"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="module">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="abstraction">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="group">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- LOG +++++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="log">
+    <layout>
+      <xml name="log" nodeType="xs:element"/>
+      <sql table="log_tbl"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int" autoInc="true" global="true" globalName="entity_id"/>
+    </property>
+
+    <property name="entity_type" type="str">
+      <sql type="char(16)" global="true" globalName="entity_type"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(16)"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="last_modified" type="datetime">
+      <sql type="datetime"/>
+    </property>
+
+    <property ref="true" object="workflow_exec" cascade="false" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="vistrail_id" type="long" foreignKey="true" object="vistrail">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MACHINE +++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="machine">
+    <layout>
+      <xml name="machine" nodeType="xs:element"/>
+      <sql table="machine"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="os" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="architecture" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="processor" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="ram" type="int">
+      <xml nodeType="xs:attribute" type="xs:long"/>
+      <sql type="bigint"/>
+    </property>
+
+    <property name="vistrailId" type="long" inverse="true"
+	      foreignKey="true" object="vistrail">
+      <sql column="vt_id" type="int"/>
+    </property>
+
+    <property ref="true" object="workflow_exec" type="long" 
+	      mapping="many-to-one" inverse="true">
+      <sql column="log_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MODULE ++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="module">
+    <layout>
+      <xml name="module" nodeType="xs:element"/>
+      <sql table="module"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="cache" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(511)"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="location" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="function" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="controlParameter" type="list" mapping="one-to-many"
+	      index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="portSpec" type="list" mapping="one-to-many"
+	      index="name:type">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- LOOP_EXEC +++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="loop_exec">
+    <layout>
+      <xml name="loopExec" nodeType="xs:element"/>
+      <sql table="loop_exec"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="ts_start" type="datetime">
+      <xml name="tsStart" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="ts_end" type="datetime">
+      <xml name="tsEnd" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="workflow_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+            
+      <property ref="true" object="module_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property ref="true" object="loop_iteration" type="list"
+            mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- LOOP_ITERATION ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="loop_iteration">
+    <layout>
+      <xml name="loopIteration" nodeType="xs:element"/>
+      <sql table="loop_iteration"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="ts_start" type="datetime">
+      <xml name="tsStart" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="ts_end" type="datetime">
+      <xml name="tsEnd" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="iteration" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="completed" type="int">
+      <xml name="completed" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="error" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <choice name="item_exec" type="list" mapping="one-to-many">
+      <property name="module_exec" ref="true" object="module_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="group_exec" ref="true" object="group_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+      
+      <property name="loop_exec" ref="true" object="loop_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+
+    <property name="parent" ref="true" object="loop_exec"
+            mapping="many-to-one" inverse="true">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- GROUP_EXEC ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="group_exec">
+    <layout>
+      <xml name="groupExec" nodeType="xs:element"/>
+      <sql table="group_exec"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="ts_start" type="datetime">
+      <xml name="tsStart" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="ts_end" type="datetime">
+      <xml name="tsEnd" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="cached" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql nodeType="int"/>
+    </property>
+
+    <property name="module_id" type="long" foreignKey="true" object="module">
+      <xml name="moduleId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="group_name" type="str">
+      <xml name="groupName" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="group_type" type="str">
+      <xml name="groupType" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="completed" type="int">
+      <xml name="completed" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="error" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <property name="machine_id" type="long" foreignKey="true" object="machine">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <choice name="item_exec" type="list" mapping="one-to-many">
+      <property name="module_exec" ref="true" object="module_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="group_exec" ref="true" object="group_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="loop_exec" ref="true" object="loop_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="workflow_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="loop_iteration" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <!--<property ref="true" object="workflow_exec" type="long" mapping="many-to-one" 
+	      inverse="true">
+      <sql column="wf_exec_id" type="int"/>
+    </property>-->
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- MODULE_EXEC +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="module_exec">
+    <layout>
+      <xml name="moduleExec" nodeType="xs:element"/>
+      <sql table="module_exec"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="ts_start" type="datetime">
+      <xml name="tsStart" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="ts_end" type="datetime">
+      <xml name="tsEnd" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="cached" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql nodeType="int"/>
+    </property>
+
+    <property name="module_id" type="long" foreignKey="true" object="module">
+      <xml name="moduleId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="module_name" type="str">
+      <xml name="moduleName" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="completed" type="int">
+      <xml name="completed" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="error" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <property name="machine_id" type="long" foreignKey="true" object="machine">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="loop_exec" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="workflow_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="group_exec" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+
+      <property ref="true" object="loop_iteration" type="long" 
+		mapping="many-to-one" inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OTHER +++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="other">
+    <layout>
+      <xml name="other" nodeType="xs:element"/>
+      <sql table="other"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="key" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="okey" type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PARAMETER +++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="parameter">
+    <layout>
+      <xml name="parameter" nodeType="xs:element"/>
+      <sql table="parameter"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="pos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="val" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="alias" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="function">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PLUGIN DATA +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="plugin_data">
+    <layout>
+      <xml name="plugin_data" nodeType="xs:element"/>
+      <sql table="plugin_data"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="data" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(8191)"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="workflow">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PORT ++++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="port">
+    <layout>
+      <xml name="port" nodeType="xs:element"/>
+      <sql table="port"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="moduleId" type="long" foreignKey="true" object="module">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="moduleName" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="signature" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(4095)"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="connection" type="long" mapping="many-to-one" 
+		inverse="true">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PORTSPEC ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="portSpec">
+    <layout>
+      <xml name="portSpec" nodeType="xs:element"/>
+      <sql table="port_spec"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="optional" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="depth" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="union" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="sort_key" type="int">
+      <xml name="sortKey" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="portSpecItem" type="list" 
+	      mapping="one-to-many" expandAction="false">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="min_conns" type="int">
+      <xml name="minConns" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="max_conns" type="int">
+      <xml name="maxConns" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+	    mapping="many-to-one">
+      <property ref="true" object="module">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="module_descriptor">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="add">
+	<sql column="parent_id" type="int"/>
+      </property>
+      <property ref="true" object="change">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PORTSPECITEM ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="portSpecItem">
+    <layout>
+      <xml name="portSpecItem" nodeType="xs:element"/>
+      <sql table="port_spec_item"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="pos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="module" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="label" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(4095)"/>
+    </property>
+
+    <property name="default" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="_default" type="varchar(4095)"/>
+    </property>
+
+    <property name="values" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="_values" type="mediumtext"/>
+    </property>
+
+    <property name="entry_type" type="str">
+      <xml name="entryType" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" type="long" object="portSpec" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MODULE_DESCRIPTOR +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="module_descriptor">
+    <layout>
+      <xml name="moduleDescriptor" nodeType="xs:element"/>
+      <sql table="module_descriptor"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+	   
+    <property name="namespace" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="package_version" type="str">
+      <xml name="packageVersion" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="base_descriptor_id" type="long" foreignKey="true" 
+	      object="module_descriptor">
+      <xml name="baseDescriptorId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="portSpec" type="list" mapping="one-to-many"
+	      index="name:type">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" type="long" object="package" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+    <!--
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <choice name="parent" type="long" discriminator="parentType" inverse="true" 
+            mapping="many-to-one">
+      <property ref="true" object="registry">
+	<sql column="parent_id" type="int"/>
+      </property>
+      
+      <property ref="true" object="package">
+	<sql column="parent_id" type="int"/>
+      </property>
+    </choice>
+    -->
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PACKAGE +++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="package">
+    <layout>
+      <xml name="package" nodeType="xs:element"/>
+      <sql table="package"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int" autoInc="true"/>
+    </property>
+    
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="identifier" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <property name="codepath" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+      
+    <property name="load_configuration" type="int">
+      <xml name="loadConfiguration" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>      
+
+    <property name="description" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <property ref="true" object="module_descriptor" type="list" 
+	      mapping="one-to-many" index="name:namespace:version">
+      <xml name="moduleDescriptor" nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" type="long" object="registry" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- REGISTRY ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="registry">
+    <layout>
+      <xml name="registry" nodeType="xs:element"/>
+      <sql table="registry"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int" autoInc="true" global="true" globalName="entity_id"/>
+    </property>
+
+    <property name="entity_type" type="str">
+      <sql type="char(16)" global="true" globalName="entity_type"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(16)"/>
+    </property>
+
+    <property name="root_descriptor_id" type="long" foreignKey="true" 
+	      object="module_descriptor">
+      <xml name="rootDescriptorId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <!-- <xml nodeType="xs:attribute" type="xs:string"/> -->
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="last_modified" type="datetime">
+      <sql type="datetime"/>
+    </property>
+
+    <property ref="true" object="package" type="list"
+	      mapping="one-to-many" index="identifier:version">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- TAG +++++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="tag">
+    <layout>
+      <xml name="tag" nodeType="xs:element"/>
+      <sql table="tag"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true" foreignKey="true" 
+	      object="action">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" type="long" object="vistrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- VISTRAIL ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="vistrail">
+    <layout>
+      <xml name="vistrail" nodeType="xs:element"/>
+      <sql table="vistrail"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int" autoInc="true" global="true" globalName="entity_id"/>
+    </property>
+    
+    <property name="entity_type" type="str">
+      <sql type="char(16)" global="true" globalName="entity_type"/>
+    </property>
+
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(16)"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="last_modified" type="datetime">
+      <sql type="datetime"/>
+    </property>
+
+    <property ref="true" object="action" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="tag" type="list" mapping="one-to-many"
+	      index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="controlParameter" type="list" mapping="one-to-many"
+	      index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="vistrailVariable" type="list" mapping="one-to-many"
+	      index="uuid">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="parameter_exploration" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property ref="true" object="actionAnnotation" type="list" 
+	      mapping="one-to-many" index="action_id:key !key:value">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- WORKFLOW ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="workflow">
+    <layout>
+      <xml name="workflow" nodeType="xs:element"/>
+      <sql table="workflow"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int" autoInc="true" global="true" globalName="entity_id"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str">
+      <sql type="char(16)" global="true" globalName="entity_type"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(16)"/>
+    </property>
+
+    <property name="last_modified" type="datetime">
+      <sql type="datetime"/>
+    </property>
+
+    <choice name="module" type="list" mapping="one-to-many">
+      <property name="module" ref="true" object="module">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="abstraction" ref="true" object="abstraction">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="group" ref="true" object="group">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+    
+    <property ref="true" object="connection" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="plugin_data" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="other" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="vistrail_id" type="long" foreignKey="true" object="vistrail">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" object="group" type="long" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- WORKFLOW_EXEC +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="workflow_exec">
+    <layout>
+      <xml name="workflowExec" nodeType="xs:element"/>
+      <sql table="workflow_exec"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="ip" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="session" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="vt_version" type="str">
+      <xml name="vtVersion" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="ts_start" type="datetime">
+      <xml name="tsStart" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="ts_end" type="datetime">
+      <xml name="tsEnd" nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="parent_id" type="long">
+      <xml name="parentId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="parent_type" type="str">
+      <xml name="parentType" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="parent_version" type="long">
+      <xml name="parentVersion" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="completed" type="int">
+      <xml name="completed" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="log" type="long" mapping="many-to-one" 
+	      inverse="true">
+      <sql column="log_id" type="int"/>
+    </property>
+    
+    <property ref="true" object="annotation" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="machine" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <choice name="item_exec" type="list" mapping="one-to-many">
+      <property name="module_exec" ref="true" object="module_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="group_exec" ref="true" object="group_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="loop_exec" ref="true" object="loop_exec">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PE_PARAMETER ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="pe_parameter" className="DBPEParameter">
+    <layout>
+      <xml name="peParameter" nodeType="xs:element"/>
+      <sql table="pe_parameter"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="pos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="interpolator" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="dimension" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <property ref="true" type="long" object="pe_function" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PE_FUNCTION +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="pe_function" className="DBPEFunction">
+    <layout>
+      <xml name="peFunction" nodeType="xs:element"/>
+      <sql table="pe_function"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="module_id" type="long" foreignKey="true" object="module">
+      <xml name="moduleId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="port_name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="is_alias" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property ref="true" name="parameter" object="pe_parameter" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="parentType" type="str" inverse="true">
+      <sql column="parent_type" type="char(32)"/>
+    </property>
+
+    <property ref="true" type="long" object="parameter_exploration" 
+	      inverse="true" mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PARAMETER_EXPLORATION +++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="parameter_exploration">
+    <layout>
+      <xml name="parameterExploration" nodeType="xs:element"/>
+      <sql table="parameter_exploration"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="action_id" type="long" foreignKey="true" object="action">
+      <xml name="actionId" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="date" type="datetime">
+      <xml nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="dims" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="layout" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" name="function" object="pe_function" type="list" 
+	      mapping="one-to-many" index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" type="long" object="vistrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- MASHUP_ACTION +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="mashup_action">
+    <layout>
+      <xml name="action" nodeType="xs:element"/>
+      <sql table="mashup_action"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="prevId" type="long" foreignKey="true" object="mashup_action">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql column="prev_id" type="int"/>
+    </property>
+
+    <property name="date" type="datetime">
+      <xml nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property ref="true" object="mashup" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" type="long" object="mashuptrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+	<property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+    
+  </object>
+
+  <!--+++++++++++++++++++++++++++++-->
+  <!-- MASHUP_ACTION_ANNOTATION +++-->
+  <!--+++++++++++++++++++++++++++++-->
+
+  <object name="mashup_actionAnnotation">
+    <layout>
+      <xml name="actionAnnotation" nodeType="xs:element"/>
+      <sql table="mashup_action_annotation"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="key" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql column="akey" type="varchar(255)"/>
+     </property>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(8191)"/>
+    </property>
+
+    <property name="action_id" type="long" foreignKey="true" object="mashup_action">
+      <xml name="action_id" nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="date" type="datetime">
+      <xml nodeType="xs:attribute" type="xs:dateTime"/>
+      <sql type="datetime"/>
+    </property>
+
+    <property name="user" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>    
+
+    <property ref="true" type="long" object="mashuptrail" inverse="true" 
+	      mapping="many-to-one">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MASHUPTRAIL +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="mashuptrail">
+    <layout>
+      <xml name="mashuptrail" nodeType="xs:element"/>
+      <sql table="mashuptrail"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <sql type="int" autoInc="true" global="true" globalName="entity_id"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml name="id" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(36)"/>
+    </property>
+    
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(16)"/>
+    </property>
+    
+    <property name="vtVersion" type="long">
+      <xml name="vtVersion" nodeType="xs:attribute" type="xs:int"/>
+      <sql column="vt_version" type="int"/>
+    </property>
+
+    <property name="last_modified" type="datetime">
+      <sql type="datetime"/>
+    </property>
+
+    <property name="action" ref="true" object="mashup_action" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="annotation" type="list" mapping="one-to-many"
+	      index="key">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="actionAnnotation" ref="true" object="mashup_actionAnnotation" type="list" 
+	      mapping="one-to-many" index="action_id:key !key:value">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--+++++++++++++++++++++++++++++-->
+  <!-- MASHUP_ALIAS +++++++++++++++-->
+  <!--+++++++++++++++++++++++++++++-->
+
+  <object name="mashup_alias">
+    <layout>
+      <xml name="alias" nodeType="xs:element"/>
+      <sql table="mashup_alias"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="component" ref="true" object="mashup_component" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+    
+    <property name="parent" ref="true" object="mashup" type="long" 
+	      mapping="many-to-one" inverse="true">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MASHUP_COMPONENT ++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="mashup_component">
+    <layout>
+      <xml name="component" nodeType="xs:element"/>
+      <sql table="mashup_component"/>
+    </layout>
+    
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="vtid" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+     <property name="vttype" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="vtparent_type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="char(32)"/>
+    </property>
+    
+    <property name="vtparent_id" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="vtpos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="vtmid" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="pos" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="val" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+    
+    <property name="minVal" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="maxVal" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="stepSize" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="strvaluelist" type="str">
+      <xml name="valueList" nodeType="xs:attribute" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+    
+    <property name="widget" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="seq" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="parent" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property ref="true" object="mashup_alias" type="long" mapping="one-to-one" 
+	      inverse="true">
+      <sql column="alias_id" type="int"/>
+    </property>
+
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- MASHUP ++++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="mashup">
+    <layout>
+      <xml name="mashup" nodeType="xs:element"/>
+      <sql table="mashup"/>
+    </layout>
+
+    <property name="id" type="long" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+    
+    <property name="version" type="long">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+
+    <property name="alias" pluralName="aliases" type= "list" ref="true" 
+              object="mashup_alias" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="type" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(255)"/>
+    </property>
+
+    <property name="vtid" type="long" foreignKey="true" object="vistrail">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="layout" type="str">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="geometry" type="str">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <sql type="mediumtext"/>
+    </property>
+
+    <property name="has_seq" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+      <sql type="int"/>
+    </property>
+    
+    <property name="parent" ref="true" object="mashup_action" type="long" 
+		mapping="one-to-one" inverse="true">
+      <sql column="parent_id" type="int"/>
+    </property>
+    
+    <property name="entity_id" type="long" inverse="true">
+      <sql type="int"/>
+    </property>
+
+    <property name="entity_type" type="str" inverse="true">
+      <sql type="char(16)"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_GRAPH +++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_graph">
+    <layout>
+      <xml name="opmGraph" nodeType="xs:element"/>
+      <!-- <sql table="opm_graph"/> -->
+    </layout>
+
+    <property name="accounts" ref="true" object="opm_accounts" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="processes" ref="true" object="opm_processes" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="artifacts" ref="true" object="opm_artifacts" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="agents" ref="true" object="opm_agents" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="dependencies" ref="true" object="opm_dependencies" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ACCOUNTS ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_accounts">
+    <layout>
+      <xml name="accounts" nodeType="xs:element"/>
+      <!-- <sql table="accounts"/> -->
+    </layout>
+
+    <property name="account" ref="true" object="opm_account" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="opm_overlaps" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ACCOUNT +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_account">
+    <layout>
+      <xml name="account" nodeType="xs:element"/>
+      <!-- <sql table="account"/> -->
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+    
+    <property name="value" type="str">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_OVERLAPS ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_overlaps">
+    <layout>
+      <xml name="overlaps" nodeType="xs:element"/>
+      <!-- <sql table="overlaps"/> -->
+    </layout>
+
+    <property ref="true" object="opm_account_id" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ARTIFACTS +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_artifacts">
+    <layout>
+      <xml name="artifacts" nodeType="xs:element"/>
+      <!-- <sql table="artifacts"/> -->
+    </layout>
+
+    <property name="artifact" ref="true" object="opm_artifact" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ARTIFACT_VALUE ++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_artifact_value">
+    <layout>
+      <xml name="value" nodeType="xs:element"/>
+      <!-- <sql table="artifact_value"/> -->
+    </layout>
+    
+    <choice name="value" type="object" mapping="one-to-one">
+      <property ref="true" object="portSpec" type="object" 
+		mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="function" type="object" 
+		mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ARTIFACT ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_artifact">
+    <layout>
+      <xml name="artifact" nodeType="xs:element"/>
+      <!-- <sql table="artifact"/> -->
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+    
+    <property name="value" ref="true" object="opm_artifact_value" type="object" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_PROCESSES +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_processes">
+    <layout>
+      <xml name="processes" nodeType="xs:element"/>
+      <!-- <sql table="processes"/> -->
+    </layout>
+
+    <property name="process" ref="true" object="opm_process" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_PROCESS_VALUE +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_process_value">
+    <layout>
+      <xml name="value" nodeType="xs:element"/>
+      <!-- <sql table="process_value"/> -->
+    </layout>
+    
+    <choice name="value" type="object" mapping="one-to-one">
+      <property ref="true" object="module_exec" type="object" 
+		mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="group_exec" type="object" 
+		mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="loop_exec" type="object" 
+		mapping="one-to-one">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_PROCESS +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_process">
+    <layout>
+      <xml name="process" nodeType="xs:element"/>
+      <!-- <sql table="process"/> -->
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="value" ref="true" object="opm_process_value" type="object" 
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_AGENTS ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_agents">
+    <layout>
+      <xml name="agents" nodeType="xs:element"/>
+      <!-- <sql table="agents"/> -->
+    </layout>
+
+    <property name="agent" ref="true" object="opm_agent" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_AGENT +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_agent">
+    <layout>
+      <xml name="agent" nodeType="xs:element"/>
+      <!-- <sql table="agent"/> -->
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+    
+    <property name="value" type="str">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type=""/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_DEPENDENCIES ++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="opm_dependencies">
+    <layout>
+      <xml name="causalDependencies" nodeType="xs:element"/>
+      <!-- <sql table="causal_dependencies"/> -->
+    </layout>
+
+    <choice name="dependency" type="list" mapping="one-to-many">
+      <property name="used" ref="true" object="opm_used">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="was_generated_by" ref="true" 
+		object="opm_was_generated_by">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="was_triggered_by" ref="true" 
+		object="opm_was_triggered_by">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="was_derived_from" ref="true" 
+		object="opm_was_derived_from">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property name="was_controlled_by" ref="true" 
+		object="opm_was_controlled_by">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_TIME ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_time">
+    <layout>
+      <xml name="time" nodeType="xs:element"/>
+      <!-- <sql table="time"/> -->
+    </layout>
+
+    <property name="no_later_than" type="datetime">
+      <xml name="noLaterThan" nodeType="xs:attribute" type="xs:dateTime"/>
+      <!-- <sql type="datetime"/> -->
+    </property>
+
+    <property name="no_earlier_than" type="datetime">
+      <xml name="noEarlierThan" nodeType="xs:attribute" type="xs:dateTime"/>
+      <!-- <sql type="datetime"/> -->
+    </property>
+
+    <property name="clock_id" type="str">
+      <xml name="clockId" nodeType="xs:attribute" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ACCOUNT_ID ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_account_id">
+    <layout>
+      <xml name="account" nodeType="xs:element"/>
+      <!-- <sql table="account_id"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_account">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_PROCESS_ID_CAUSE ++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_process_id_cause">
+    <layout>
+      <xml name="cause" nodeType="xs:element"/>
+      <!-- <sql table="process_id_cause"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_process">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_PROCESS_ID_EFFECT +++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_process_id_effect">
+    <layout>
+      <xml name="effect" nodeType="xs:element"/>
+      <!-- <sql table="process_id_effect"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_process">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ARTIFACT_ID_CAUSE +++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_artifact_id_cause">
+    <layout>
+      <xml name="cause" nodeType="xs:element"/>
+      <!-- <sql table="artifact_id_cause"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_artifact">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ARTIFACT_ID_EFFECT ++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_artifact_id_effect">
+    <layout>
+      <xml name="effect" nodeType="xs:element"/>
+      <!-- <sql table="artifact_id_effect"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_artifact">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_AGENT_ID ++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_agent_id">
+    <layout>
+      <xml name="agent" nodeType="xs:element"/>
+      <!-- <sql table="agent_id"/> -->
+    </layout>
+
+    <property name="id" type="str" foreignKey="true" object="opm_agent">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_ROLE ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_role">
+    <layout>
+      <xml name="role" nodeType="xs:element"/>
+      <!-- <sql table="role"/> -->
+    </layout>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute"/>
+      <!-- <sql type="varchar(4095)"/> -->
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_USED ++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_used">
+    <layout>
+      <xml name="used" nodeType="xs:element"/>
+      <!-- <sql table="used"/> -->
+    </layout>
+
+    <property name="effect" ref="true" object="opm_process_id_effect"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="role" ref="true" object="opm_role" type="str"
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="cause" ref="true" object="opm_artifact_id_cause"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property ref="true" object="opm_time" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_WAS_GENERATED_BY ++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_was_generated_by">
+    <layout>
+      <xml name="wasGeneratedBy" nodeType="xs:element"/>
+      <!-- <sql table="was_generated_by"/> -->
+    </layout>
+
+    <property name="effect" ref="true" object="opm_artifact_id_effect"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="role" ref="true" object="opm_role" type="str"
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="cause" ref="true" object="opm_process_id_cause"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property ref="true" object="opm_time" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_WAS_CONTROLLED_BY +++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_was_controlled_by">
+    <layout>
+      <xml name="wasControlledBy" nodeType="xs:element"/>
+      <!-- <sql table="was_controlled_by"/> -->
+    </layout>
+
+    <property name="effect" ref="true" object="opm_process_id_effect"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="role" ref="true" object="opm_role" type="str"
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="cause" ref="true" object="opm_agent_id"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="start" ref="true" object="opm_time" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property name="end" ref="true" object="opm_time" type="list" 
+	      mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_WAS_DERIVED_FROM ++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_was_derived_from">
+    <layout>
+      <xml name="wasDerivedFrom" nodeType="xs:element"/>
+      <!-- <sql table="was_derived_from"/> -->
+    </layout>
+
+    <property name="effect" ref="true" object="opm_artifact_id_effect"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="role" ref="true" object="opm_role" type="str"
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="cause" ref="true" object="opm_artifact_id_cause"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property ref="true" object="opm_time" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- OPM_WAS_TRIGGERED_BY ++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="opm_was_triggered_by">
+    <layout>
+      <xml name="wasTriggeredBy" nodeType="xs:element"/>
+      <!-- <sql table="was_triggered_by"/> -->
+    </layout>
+
+    <property name="effect" ref="true" object="opm_process_id_effect"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="role" ref="true" object="opm_role" type="str"
+	      mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="cause" ref="true" object="opm_process_id_cause"
+	      type="str" mapping="one-to-one">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property name="account" ref="true" object="opm_account_id"
+	      type="list" mapping="one-to-many">
+      <xml nodeType="xs:element" type="xs:string"/>
+      <!-- <sql type="varchar(255)"/> -->
+    </property>
+
+    <property ref="true" object="opm_time" type="list" mapping="one-to-many">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_DOCUMENT +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_document">
+    <layout>
+      <xml name="prov:document" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_entity" ref="true" object="prov_entity" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:entity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_activity" ref="true" object="prov_activity" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_agent" ref="true" object="prov_agent" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:agent" nodeType="xs:element"/>
+    </property>
+    
+    <property name="vt_connection" ref="true" object="vt_connection" type="list" 
+          mapping="one-to-many">
+      <xml name="vt:connection" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_usage" ref="true" object="prov_usage" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:used" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_generation" ref="true" object="prov_generation" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:wasGeneratedBy" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_association" ref="true" object="prov_association" type="list" 
+          mapping="one-to-many">
+      <xml name="prov:wasAssociatedWith" nodeType="xs:element"/>
+    </property>
+    
+    <!--<property name="vt_part" ref="true" object="vt_part" type="list" 
+          mapping="one-to-many">
+      <xml name="vt:isPartOf" nodeType="xs:element"/>
+    </property>-->
+    
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_ENTITY +++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_entity">
+    <layout>
+      <xml name="prov:entity" nodeType="xs:element"/>
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml name="prov:id" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+    
+    <property name="prov_type" type="str">
+      <xml name="prov:type" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="prov_label" type="str">
+      <xml name="prov:label" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="prov_value" type="str">
+      <xml name="prov:value" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_id" type="str">
+      <xml name="vt:id" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_type" type="str">
+      <xml name="vt:type" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_desc" type="str">
+      <xml name="vt:desc" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_package" type="str">
+      <xml name="vt:package" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_version" type="str">
+      <xml name="vt:version" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_cache" type="str">
+      <xml name="vt:cache" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_location_x" type="str">
+      <xml name="vt:location_x" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_location_y" type="str">
+      <xml name="vt:location_y" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="is_part_of" ref="true" object="is_part_of" type="str">
+      <xml name="dcterms:isPartOf" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- REF_PROV_ENTITY +++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="ref_prov_entity">
+    <layout>
+      <xml name="prov:entity" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_ref" type="str" foreignKey="true" object="prov_entity">
+      <xml name="prov:ref" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- REF_PROV_PLAN +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="ref_prov_plan">
+    <layout>
+      <xml name="prov:plan" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_ref" type="str" foreignKey="true" object="prov_entity">
+      <xml name="prov:ref" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_ACTIVITY +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_activity">
+    <layout>
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml name="prov:id" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+    
+    <property name="startTime" type="str">
+      <xml name="prov:startTime" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="endTime" type="str">
+      <xml name="prov:endTime" nodeType="xs:element" type="xs:string"/>
+    </property>
+
+    <property name="vt_id" type="str" primaryKey="true">
+      <xml name="vt:id" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_type" type="str">
+      <xml name="vt:type" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_cached" type="str">
+      <xml name="vt:cached" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_completed" type="str">
+      <xml name="vt:completed" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_machine_id" type="str">
+      <xml name="vt:machine_id" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_error" type="str">
+      <xml name="vt:error" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="is_part_of" ref="true" object="is_part_of" type="str">
+      <xml name="dcterms:isPartOf" nodeType="xs:element" type="xs:string"/>
+    </property>
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- REF_PROV_ACTIVITY +++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="ref_prov_activity">
+    <layout>
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_ref" type="str" foreignKey="true" object="prov_activity">
+      <xml name="prov:ref" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_AGENT ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_agent">
+    <layout>
+      <xml name="prov:agent" nodeType="xs:element"/>
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml name="prov:id" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+
+    <property name="vt_id" type="str">
+      <xml name="vt:id" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="prov_type" type="str">
+      <xml name="prov:type" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="prov_label" type="str">
+      <xml name="prov:label" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_machine_os" type="str">
+      <xml name="vt:machine_os" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_machine_architecture" type="str">
+      <xml name="vt:machine_architecture" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_machine_processor" type="str">
+      <xml name="vt:machine_processor" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_machine_ram" type="str">
+      <xml name="vt:machine_ram" nodeType="xs:element" type="xs:string"/>
+    </property>
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- REF_PROV_AGENT ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+  
+  <object name="ref_prov_agent">
+    <layout>
+      <xml name="prov:agent" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_ref" type="str" foreignKey="true" object="prov_agent">
+      <xml name="prov:ref" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- VT_CONNECTION +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="vt_connection">
+    <layout>
+      <xml name="vt:connection" nodeType="xs:element"/>
+    </layout>
+
+    <property name="id" type="str" primaryKey="true">
+      <xml name="id" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+
+    <property name="vt_source" type="str">
+      <xml name="vt:source" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_dest" type="str">
+      <xml name="vt:dest" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_source_port" type="str">
+      <xml name="vt:source_port" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_dest_port" type="str">
+      <xml name="vt:dest_port" nodeType="xs:element" type="xs:string"/>
+    </property>
+      
+    <property name="vt_source_signature" type="str">
+      <xml name="vt:source_signature" nodeType="xs:element" type="xs:string"/>
+    </property>
+    
+    <property name="vt_dest_signature" type="str">
+      <xml name="vt:dest_signature" nodeType="xs:element" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_USAGE ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_usage">
+    <layout>
+      <xml name="prov:used" nodeType="xs:element"/>
+    </layout>
+
+    <!--<property name="id" type="str" primaryKey="true">
+      <xml name="id" nodeType="xs:attribute" type="xs:string"/>
+    </property>-->
+    
+    <property name="prov_activity" ref="true" object="ref_prov_activity" type="str">
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_entity" ref="true" object="ref_prov_entity" type="str">
+      <xml name="prov:entity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_role" type="str">
+      <xml name="prov:role" nodeType="xs:element" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_GENERATION +++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_generation">
+    <layout>
+      <xml name="prov:wasGeneratedBy" nodeType="xs:element"/>
+    </layout>
+
+    <!--<property name="id" type="str" primaryKey="true">
+      <xml name="id" nodeType="xs:attribute" type="xs:string"/>
+    </property>-->
+    
+    <property name="prov_entity" ref="true" object="ref_prov_entity" type="str">
+      <xml name="prov:entity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_activity" ref="true" object="ref_prov_activity" type="str">
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_role" type="str">
+      <xml name="prov:role" nodeType="xs:element" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- PROV_ASSOCIATION ++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="prov_association">
+    <layout>
+      <xml name="prov:wasAssociatedWith" nodeType="xs:element"/>
+    </layout>
+
+    <!--<property name="id" type="str" primaryKey="true">
+      <xml name="id" nodeType="xs:attribute" type="xs:string"/>
+    </property>-->
+    
+    <property name="prov_activity" ref="true" object="ref_prov_activity" type="str">
+      <xml name="prov:activity" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_agent" ref="true" object="ref_prov_agent" type="str">
+      <xml name="prov:agent" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_plan" ref="true" object="ref_prov_plan" type="str">
+      <xml name="prov:plan" nodeType="xs:element"/>
+    </property>
+    
+    <property name="prov_role" type="str">
+      <xml name="prov:role" nodeType="xs:element" type="xs:string"/>
+    </property>  
+  </object>
+  
+  <!--++++++++++++++++++++++++++-->
+  <!-- IS_PART_OF ++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="is_part_of">
+    <layout>
+      <xml name="dcterms:isPartOf" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="prov_ref" type="str">
+      <xml name="prov:ref" nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- STARTUP +++++++++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="startup">
+    <layout>
+      <xml name="startup" nodeType="xs:element"/>
+    </layout>
+    
+    <property name="version" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+    </property>
+
+    <property ref="true" object="configuration" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>
+
+    <property ref="true" object="enabled_packages" type="list" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>    
+
+    <property ref="true" object="disabled_packages" type="list" mapping="one-to-one">
+      <xml nodeType="xs:element"/>
+    </property>    
+
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- ENABLED_PACKAGES ++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="enabled_packages">
+    <layout>
+      <xml name="packages" nodeType="xs:element"/>
+    </layout>
+  
+    <property name="package" ref="true" object="startup_package" type="list" 
+	      mapping="one-to-many" index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- DISABLED_PACKAGES +++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="disabled_packages">
+    <layout>
+      <xml name="disabledpackages" nodeType="xs:element"/>
+    </layout>
+  
+    <property name="package" ref="true" object="startup_package" type="list" 
+	      mapping="one-to-many" index="name">
+      <xml nodeType="xs:element"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- STARTUP_PACKAGE +++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="startup_package">
+    <layout>
+      <xml name="package" nodeType="xs:element"/>
+    </layout>
+
+    <property name="name" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+      <sql type="varchar(1023)"/>
+    </property>
+
+    <property ref="true" object="configuration" type="object" mapping="one-to-one">
+      <xml nodeType="xs:element" name="configuration"/>
+    </property>    
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIGURATION +++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="configuration">
+    <layout>
+      <xml name="configuration" nodeType="xs:element"/>
+    </layout>
+
+    <property ref="true" object="config_key" type="list" 
+	      mapping="one-to-many">
+      <xml name="key" nodeType="xs:element"/>
+    </property>    
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIG_KEY ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="config_key">
+    <layout>
+      <xml name="key" nodeType="xs:element"/>
+    </layout>
+
+    <property name="name" type="str" primaryKey="true">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+    </property>
+
+    <choice name="value" type="object" mapping="one-to-one">
+      <property ref="true" object="config_str">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="config_int">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="config_float">
+	<xml nodeType="xs:element"/>
+      </property>
+
+      <property ref="true" object="config_bool">
+	<xml nodeType="xs:element"/>
+      </property>
+      
+      <property ref="true" object="configuration">
+	<xml nodeType="xs:element"/>
+      </property>
+    </choice>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIG_STR ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="config_str">
+    <layout>
+      <xml name="str" nodeType="xs:element"/>
+    </layout>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIG_INT ++++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="config_int">
+    <layout>
+      <xml name="int" nodeType="xs:element"/>
+    </layout>
+
+    <property name="value" type="int">
+      <xml nodeType="xs:attribute" type="xs:int"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIG_FLOAT ++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="config_float">
+    <layout>
+      <xml name="float" nodeType="xs:element"/>
+    </layout>
+
+    <property name="value" type="float">
+      <xml nodeType="xs:attribute" type="xs:float"/>
+    </property>
+  </object>
+
+  <!--++++++++++++++++++++++++++-->
+  <!-- CONFIG_BOOL +++++++++-->
+  <!--++++++++++++++++++++++++++-->
+
+  <object name="config_bool">
+    <layout>
+      <xml name="bool" nodeType="xs:element"/>
+    </layout>
+
+    <property name="value" type="str">
+      <xml nodeType="xs:attribute" type="xs:string"/>
+    </property>
+  </object>
+</objects>
diff --git a/vistrails/db/versions/v1_0_5/translate/__init__.py b/vistrails/db/versions/v1_0_5/translate/__init__.py
new file mode 100644
index 000000000..83f9e2281
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/translate/__init__.py
@@ -0,0 +1,39 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+
+from __future__ import division
+
+version = '1.0.5'
diff --git a/vistrails/db/versions/v1_0_5/translate/v1_0_4.py b/vistrails/db/versions/v1_0_5/translate/v1_0_4.py
new file mode 100644
index 000000000..fea85d977
--- /dev/null
+++ b/vistrails/db/versions/v1_0_5/translate/v1_0_4.py
@@ -0,0 +1,110 @@
+###############################################################################
+##
+## Copyright (C) 2014-2016, New York University.
+## Copyright (C) 2011-2014, NYU-Poly.
+## Copyright (C) 2006-2011, University of Utah.
+## All rights reserved.
+## Contact: contact@vistrails.org
+##
+## This file is part of VisTrails.
+##
+## "Redistribution and use in source and binary forms, with or without
+## modification, are permitted provided that the following conditions are met:
+##
+##  - Redistributions of source code must retain the above copyright notice,
+##    this list of conditions and the following disclaimer.
+##  - Redistributions in binary form must reproduce the above copyright
+##    notice, this list of conditions and the following disclaimer in the
+##    documentation and/or other materials provided with the distribution.
+##  - Neither the name of the New York University nor the names of its
+##    contributors may be used to endorse or promote products derived from
+##    this software without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+## THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+## PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+## CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+## EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+## PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+## OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+## WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+## OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+## ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
+##
+###############################################################################
+from __future__ import division
+
+from vistrails.db.versions.v1_0_5.domain import DBVistrail, DBVistrailVariable, \
+                                      DBWorkflow, DBLog, DBRegistry, \
+                                      DBAdd, DBChange, DBDelete, \
+                                      DBPortSpec, DBPortSpecItem, \
+                                      DBParameterExploration, \
+                                      DBPEParameter, DBPEFunction, \
+                                      IdScope, DBAbstraction, \
+                                      DBModule, DBGroup, DBAnnotation, \
+                                      DBActionAnnotation, DBStartup, \
+                                      DBConfigKey, DBConfigBool, DBConfigStr, \
+                                      DBConfigInt, DBConfigFloat, \
+                                      DBConfiguration, DBStartupPackage, \
+                                      DBLoopIteration, DBLoopExec, \
+                                      DBModuleExec, DBGroupExec
+
+id_scope = None
+
+def translateVistrail(_vistrail):
+    """ Translate old annotation based vistrail variables to new
+        DBVistrailVariable class """
+    global id_scope
+
+    def update_workflow(old_obj, trans_dict):
+        return DBWorkflow.update_version(old_obj.db_workflow, 
+                                         trans_dict, DBWorkflow())
+
+    translate_dict = {'DBGroup': {'workflow': update_workflow}}
+    vistrail = DBVistrail()
+    id_scope = vistrail.idScope
+    vistrail = DBVistrail.update_version(_vistrail, translate_dict, vistrail)
+
+    vistrail.db_version = '1.0.5'
+    return vistrail
+
+def translateWorkflow(_workflow):
+    global id_scope
+    def update_workflow(old_obj, translate_dict):
+        return DBWorkflow.update_version(old_obj.db_workflow, translate_dict)
+    translate_dict = {'DBGroup': {'workflow': update_workflow}}
+
+    workflow = DBWorkflow()
+    id_scope = IdScope(remap={DBAbstraction.vtType: DBModule.vtType, DBGroup.vtType: DBModule.vtType})
+    workflow = DBWorkflow.update_version(_workflow, translate_dict, workflow)
+    workflow.db_version = '1.0.5'
+    return workflow
+
+def translateLog(_log):
+    translate_dict = {}
+    log = DBLog.update_version(_log, translate_dict)
+    log.db_version = '1.0.5'
+    return log
+
+def translateRegistry(_registry):
+    global id_scope
+    translate_dict = {}
+    registry = DBRegistry()
+    id_scope = registry.idScope
+    registry = DBRegistry.update_version(_registry, translate_dict, registry)
+    registry.db_version = '1.0.5'
+    return registry
+
+def translateStartup(_startup):
+    # format is {<old_name>: <new_name>} or
+    # {<old_name>: (<new_name> | None, [conversion_f | None, inner_d | None])
+    # conversion_f is a function that mutates the value and
+    # inner_d recurses the translation for inner configurations
+
+    translate_dict = {}
+    startup = DBStartup()
+    startup = DBStartup.update_version(_startup, translate_dict, startup)
+
+    startup.db_version = '1.0.5'
+    return startup
diff --git a/vistrails/gui/application.py b/vistrails/gui/application.py
index 5c675be89..1506fd2ee 100644
--- a/vistrails/gui/application.py
+++ b/vistrails/gui/application.py
@@ -43,6 +43,7 @@
 import copy
 import os.path
 import getpass
+import platform
 import sys
 import StringIO
 import usagestats
@@ -65,7 +66,25 @@
 import vistrails.gui.theme
 
 
-################################################################################
+def global_ui_fixes():
+    # Prevent Mac OS 10.7 from restoring windows state since it would make Qt
+    # 4.7.3 unstable due to its lack of handling Cocoa's Main Window.
+    if platform.system() == 'Darwin':
+        release = platform.mac_ver()[0].split('.')
+        if len(release) >= 2 and (int(release[0]), int(release[1])) >= (10, 7):
+            ss_path = os.path.expanduser('~/Library/Saved Application State/'
+                                         'org.vistrails.savedState')
+            if os.path.exists(ss_path):
+                os.system('rm -rf "%s"' % ss_path)
+            os.system('defaults write org.vistrails NSQuitAlwaysKeepsWindows '
+                      '-bool false')
+
+    # font bugfix for Qt 4.8 and OS X 10.9
+    if platform.system() == 'Darwin':
+        release = platform.mac_ver()[0].split('.')
+        if len(release) >= 2 and (int(release[0]), int(release[1])) >= (1, 9):
+            QtGui.QFont.insertSubstitution(".Lucida Grande UI", "Lucida Grande")
+
 
 class VistrailsApplicationSingleton(VistrailsApplicationInterface,
                                     QtGui.QApplication):
@@ -76,6 +95,8 @@ class VistrailsApplicationSingleton(VistrailsApplicationInterface,
     """
 
     use_event_filter = system.systemType in ['Darwin']
+    timeout = 15000
+    execution_timeout = 600000
 
     def __call__(self):
         """ __call__() -> VistrailsApplicationSingleton
@@ -87,12 +108,8 @@ def __call__(self):
         return self
 
     def __init__(self):
-        # font bugfix for Qt 4.8 and OS X 10.9
-        import platform
-        if platform.system()=='Darwin':
-            release = platform.mac_ver()[0].split('.')
-            if len(release)>=2 and int(release[0])*100+int(release[1])>=1009:
-                QtGui.QFont.insertSubstitution(".Lucida Grande UI", "Lucida Grande")
+        global_ui_fixes()
+
         QtGui.QApplication.__init__(self, sys.argv)
         VistrailsApplicationInterface.__init__(self)
 
@@ -116,7 +133,6 @@ def run_single_instance(self, args):
         # based on the C++ solution available at
         # http://wiki.qtcentre.org/index.php?title=SingleApplication
         if QtCore.QT_VERSION >= 0x40400:
-            self.timeout = 600000
             self._unique_key = os.path.join(system.home_directory(),
                        "vistrails-single-instance-check-%s"%getpass.getuser())
             self.shared_memory = QtCore.QSharedMemory(self._unique_key)
@@ -139,8 +155,10 @@ def run_single_instance(self, args):
                 else:
                     if self.found_another_instance_running(local_socket, args):
                         return APP_DONE # success, we should shut down
-                    else:
-                        return APP_FAIL  # error, we should shut down
+                    else:  # This is bad, but not fatal. Let's keep going...
+                        debug.critical("Failed to communicate with existing "
+                                       "instance")
+                        return
 
             if not self.shared_memory.create(1):
                 debug.critical("Unable to create single instance "
@@ -778,8 +796,6 @@ def message_received(self):
                 sys.stdout.close()
                 sys.stdout = old_stdout
             except Exception, e:
-                import traceback
-                traceback.print_exc()
                 debug.unexpected_exception(e)
                 debug.critical("Unknown error", e)
                 result = debug.format_exc()
@@ -811,7 +827,7 @@ def send_message(self, local_socket, message):
             debug.critical("Writing failed: %s" %
                            local_socket.errorString())
             return False
-        if not local_socket.waitForReadyRead(self.timeout):
+        if not local_socket.waitForReadyRead(self.execution_timeout):
             debug.critical("Read error: %s" %
                            local_socket.errorString())
             return False
diff --git a/vistrails/gui/application_server.py b/vistrails/gui/application_server.py
index ad8b13def..3a623f4df 100644
--- a/vistrails/gui/application_server.py
+++ b/vistrails/gui/application_server.py
@@ -808,13 +808,12 @@ def executeMedley(self, xml_medley, extra_info=None):
                                             result += str(errors[i])
                                 if ok:
                                     self.server_logger.info("renaming files")
-                                    for root, dirs, file_names in os.walk(extra_info['pathDumpCells']):
-                                        break
-                                    for f in file_names:
-                                        if f.lower().endswith(".png"):
+                                    dump_path = extra_info['pathDumpCells']
+                                    for f in os.listdir(dump_path):
+                                        if os.path.isfile(f) and f.lower().endswith(".png"):
                                             fmask = "%s_"+mask+"%s"
-                                            os.renames(os.path.join(root,f),
-                                                       os.path.join(root,"%s" % f[:-4],
+                                            os.renames(os.path.join(dump_path,f),
+                                                       os.path.join(dump_path,"%s" % f[:-4],
                                                                     fmask% (f[:-4],val,f[-4:])))
                                 if val < maxval:
                                     val += XMLObject.convert_from_str(v._component._stepSize,
diff --git a/vistrails/gui/base_view.py b/vistrails/gui/base_view.py
index 9b586a2e8..169fd26b7 100644
--- a/vistrails/gui/base_view.py
+++ b/vistrails/gui/base_view.py
@@ -115,3 +115,6 @@ def changeEvent(self, event):
         if event.type() == QtCore.QEvent.WindowTitleChange:
             self.emit(QtCore.SIGNAL("windowTitleChanged"), self)
         QtGui.QWidget.changeEvent(self, event)
+
+    def viewSelected(self):
+        pass
diff --git a/vistrails/gui/bundles/installbundle.py b/vistrails/gui/bundles/installbundle.py
index c0c729e87..50dca20a4 100644
--- a/vistrails/gui/bundles/installbundle.py
+++ b/vistrails/gui/bundles/installbundle.py
@@ -74,11 +74,11 @@ def shell_escape(arg):
 
 
 def run_install_command(graphical, cmd, args, as_root=True):
-    if isinstance(args, str):
+    if isinstance(args, basestring):
         cmd += ' %s' % shell_escape(args)
     elif isinstance(args, list):
         for package in args:
-            if not isinstance(package, str):
+            if not isinstance(package, basestring):
                 raise TypeError("Expected string or list of strings")
             cmd += ' %s' % shell_escape(package)
     else:
@@ -113,7 +113,7 @@ def run_install_command(graphical, cmd, args, as_root=True):
             print line,
             lines.append(line)
     except IOError, e:
-        print "Ignoring IOError:", str(e)
+        print "Ignoring IOError: %s" % e
     result = p.wait()
 
     if result != 0:
@@ -179,7 +179,7 @@ def pip_install(package_name):
     return run_install_command(qt_available(), cmd, package_name, use_root)
 
 def show_question(which_files, has_distro_pkg, has_pip):
-    if isinstance(which_files, str):
+    if isinstance(which_files, basestring):
         which_files = [which_files]
     if qt_available():
         from PyQt4 import QtCore, QtGui
diff --git a/vistrails/gui/controlflow_assist.py b/vistrails/gui/controlflow_assist.py
index 5257b0ae0..7491a2833 100644
--- a/vistrails/gui/controlflow_assist.py
+++ b/vistrails/gui/controlflow_assist.py
@@ -175,7 +175,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
             for connection in input_connections:
                 self.connection_ids.remove(connection.id)
                 self.controller.delete_connection(connection.id)
-            group_inport_module = self.controller.add_module(input_module.location.x-offset[input_module], input_module.location.y, bm_identifier, 'InputPort')
+            group_inport_module = self.controller.add_module(bm_identifier, 'InputPort',
+                                                             x=input_module.location.x-offset[input_module],
+                                                             y=input_module.location.y)
             io_modules.append(group_inport_module)
             offset[input_module] += 130
             for p in group_inport_module.sourcePorts():
@@ -190,7 +192,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
         for connection in output_connections:
             self.connection_ids.remove(connection.id)
             self.controller.delete_connection(connection.id)
-        group_outport_module = self.controller.add_module(output_module.location.x+halfwidth+75, output_module.location.y, bm_identifier, 'OutputPort')
+        group_outport_module = self.controller.add_module(bm_identifier, 'OutputPort',
+                                                          x=output_module.location.x+halfwidth+75,
+                                                          y=output_module.location.y)
         io_modules.append(group_outport_module)
         for p in group_outport_module.destinationPorts():
             if p.name == 'InternalPipe':
@@ -207,7 +211,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
         io_connections.extend(self.controller.get_connections_to_and_from(self.controller.current_pipeline, [inner_group.id]))
         
         # Add Map module
-        map_module = self.controller.add_module(inner_group.location.x-120, inner_group.location.y, cf_identifier, 'Map')
+        map_module = self.controller.add_module(cf_identifier, 'Map',
+                                                x=inner_group.location.x-120,
+                                                y=inner_group.location.y)
         io_modules.append(map_module)
         
         # Get group 'self' port object
@@ -217,7 +223,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
                 break
         
         # Add PythonSource
-        py_source_module = self.controller.add_module(inner_group.location.x, inner_group.location.y+75, bm_identifier, 'PythonSource')
+        py_source_module = self.controller.add_module(bm_identifier, 'PythonSource',
+                                                      x=inner_group.location.x,
+                                                      y=inner_group.location.y+75)
         io_modules.append(py_source_module)
         group_type = '('+bm_identifier+':Group)'
         bool_type = '('+bm_identifier+':Boolean)'
@@ -274,7 +282,6 @@ def createControlFlow(self, input_ports_info, output_ports_info):
     # Compact list format used when only one input port present
     if len(input_ports) == 1:
         InputList = [x[0] for x in InputList]
-print 'InputList: %%s' %% InputList
 ''' % output_portspec.name
         functions = [('source', [source_code])]
         self.controller.update_ports_and_functions(py_source_module.id, [], base_input_ports + add_input_ports + base_output_ports, functions)
@@ -301,7 +308,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
         # Create and connect InputPort for each of the PythonSource inputs to force it to exist on group
         offset = 165
         for port_type, port_name, list_type, sortkey in add_input_ports:
-            group_inport_module = self.controller.add_module(py_source_module.location.x-offset, py_source_module.location.y+75, bm_identifier, 'InputPort')
+            group_inport_module = self.controller.add_module(bm_identifier, 'InputPort',
+                                                             x=py_source_module.location.x-offset,
+                                                             y=py_source_module.location.y+75)
             if (port_type, port_name) in [('input', 'UseCartesianProduct'), ('input', 'UserDefinedInputList')]:
                 self.controller.update_ports_and_functions(group_inport_module.id, [], [], [('optional', [True])])
             io_modules.append(group_inport_module)
@@ -314,7 +323,9 @@ def createControlFlow(self, input_ports_info, output_ports_info):
                     break
         
         # Create and connect OutputPort from Map to force it to exist on group
-        group_outport_module = self.controller.add_module(map_module.location.x, map_module.location.y-75, bm_identifier, 'OutputPort')
+        group_outport_module = self.controller.add_module(bm_identifier, 'OutputPort',
+                                                          x=map_module.location.x,
+                                                          y=map_module.location.y-75)
         io_modules.append(group_outport_module)
         output_portspec = map_module.get_port_spec('Result', 'output')
         for p in group_outport_module.destinationPorts():
diff --git a/vistrails/gui/mashups/alias_parameter_view.py b/vistrails/gui/mashups/alias_parameter_view.py
index 8eeb32a85..a7e544354 100644
--- a/vistrails/gui/mashups/alias_parameter_view.py
+++ b/vistrails/gui/mashups/alias_parameter_view.py
@@ -101,7 +101,6 @@ def updateMshpController(self, mshpController):
         #self.pipeline_view.scene().setupScene(self.mshpController.vtPipeline)
         self.pipeline_view.scene().clear()
         self.pipeline_view.version_changed()
-        self.pipeline_view.zoomToFit()
         self.pipeline_view.updateAnnotatedIds(
                         self.mshpController.vtPipeline)
         #_app.notify('mashup_pipeline_view_set')
@@ -207,6 +206,7 @@ def updateFromPipeline(self, pipeline):
             if len(module.functions)>0:
                 mLabel = [module.name]
                 moduleItem = None
+                port_dict = dict((p.name, p) for p in module.destinationPorts())
                 for fId in xrange(len(module.functions)):
                     function = module.functions[fId]
                     if len(function.params)==0: continue
@@ -219,7 +219,8 @@ def updateFromPipeline(self, pipeline):
                             moduleItem = QAliasParameterTreeWidgetItem(None,
                                                                   self, mLabel)
                     #v = ', '.join([p.strValue for p in function.params])
-                    label = ['%s'%function.name]
+                    port_spec = port_dict[function.name]
+                    label = ['%s' % (port_spec.union or function.name)]
                     
                     pList = [InstanceObject(type=function.params[pId].type,
                                            identifier=function.params[pId].identifier,
diff --git a/vistrails/gui/module_options.py b/vistrails/gui/module_options.py
index abe469fed..28f805aa3 100644
--- a/vistrails/gui/module_options.py
+++ b/vistrails/gui/module_options.py
@@ -102,7 +102,7 @@ def createButtons(self):
         self.layout().addLayout(layout)
         self.layout().setStretch(0, 0)
 
-        self.portCombiner = QPortCombineTreeWidget()
+        self.portCombiner = QPortCombineTreeWidget(self.stateChanged)
         self.layout().addWidget(self.portCombiner)
         self.portCombiner.setVisible(False)
         
@@ -217,7 +217,7 @@ def sizeHint(self):
         """
         return QtCore.QSize(512, 256)
 
-    def saveTriggered(self, checked = False):
+    def saveTriggered(self, checked=False):
         """ saveTriggered(checked: bool) -> None
         Update vistrail controller and module when the user click Ok
         
@@ -232,7 +232,7 @@ def saveTriggered(self, checked = False):
     def resetTriggered(self, checked = False):
         self.update_module(self.module)
 
-    def stateChanged(self, state=False, other=None):
+    def stateChanged(self, *args):
         self.saveButton.setEnabled(True)
         self.resetButton.setEnabled(True)
         self.state_changed = True
@@ -288,7 +288,7 @@ def set_controller(self, controller):
 
     def update_module(self, module=None):
         self.module = module
-        if not module:
+        if module is None:
             self.pairwiseButton.setEnabled(False)
             self.cartesianButton.setEnabled(False)
             self.customButton.setEnabled(False)
@@ -339,8 +339,8 @@ def update_module(self, module=None):
             self.portCombiner.setVisible(type not in ['pairwise', 'cartesian'])
             if type not in ['pairwise', 'cartesian']:
                 self.portCombiner.setValue(type)
-        if module.has_control_parameter_with_name(ModuleControlParam.WHILE_COND_KEY) or \
-           module.has_control_parameter_with_name(ModuleControlParam.WHILE_MAX_KEY):
+        if (module.has_control_parameter_with_name(ModuleControlParam.WHILE_COND_KEY) or
+                module.has_control_parameter_with_name(ModuleControlParam.WHILE_MAX_KEY)):
             self.whileButton.setChecked(True)
         if module.has_control_parameter_with_name(ModuleControlParam.WHILE_COND_KEY):
             cond = module.get_control_parameter_by_name(ModuleControlParam.WHILE_COND_KEY).value
@@ -429,8 +429,9 @@ def __init__(self, parent=None):
         self.setText(0, 'Cross')
 
 class QPortCombineTreeWidget(QtGui.QTreeWidget):
-    def __init__(self, parent=None):
-        QtGui.QTreeWidget.__init__(self, parent)
+    def __init__(self, callback):
+        QtGui.QTreeWidget.__init__(self)
+        self._callback = callback
         self.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
         self.header().hide()
         self.setExpandsOnDoubleClick(False)
@@ -444,14 +445,15 @@ def __init__(self, parent=None):
     def dropEvent(self, event):
         QtGui.QTreeWidget.dropEvent(self, event)
         self.expandAll()
+        self._callback()
 
     def loadNode(self, parent, node):
         # populate widget from json struct
         if isinstance(node, basestring):
             PortItem(node, parent)
         else:
-            item = DotItem(parent) if node[0] == 'pairwise' \
-                                   else CrossItem(parent)
+            item = (DotItem(parent) if node[0] == 'pairwise'
+                                    else CrossItem(parent))
             for i in node[1:]:
                 self.loadNode(item, i)
         
@@ -505,9 +507,11 @@ def contextMenuEvent(self, event):
 
     def addDot(self):
         DotItem(self)
+        self._callback()
 
     def addCross(self):
         CrossItem(self)
+        self._callback()
 
     def keyPressEvent(self, event):
         """ keyPressEvent(event: QKeyEvent) -> None
@@ -516,21 +520,22 @@ def keyPressEvent(self, event):
         
         """
         items = self.selectedItems()
-        if (len(items)==1 and \
-            event.key() in [QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete]) and \
-            type(items[0]) in [DotItem, CrossItem] and\
-            not items[0].childCount():
+        if (len(items)==1 and
+                event.key() in [QtCore.Qt.Key_Backspace, QtCore.Qt.Key_Delete] and
+                type(items[0]) in [DotItem, CrossItem] and
+                not items[0].childCount()):
             item = items[0]
             if item.parent():
                 item.parent().takeChild(item.parent().indexOfChild(item))
             else:
                 self.takeTopLevelItem(self.indexOfTopLevelItem(item))
+            self._callback()
         else:
             QtGui.QTreeWidget.keyPressEvent(self, event)
 
 class TestIterationGui(unittest.TestCase):
     def testGetSet(self):
-        p = QPortCombineTreeWidget()
+        p = QPortCombineTreeWidget(lambda: None)
         v = '["cartesian", ["pairwise", "a", "b"], "c"]'
         p.setValue(v)
         self.assertEqual(v, p.getValue())
diff --git a/vistrails/gui/module_palette.py b/vistrails/gui/module_palette.py
index 5668f3467..8297530d3 100644
--- a/vistrails/gui/module_palette.py
+++ b/vistrails/gui/module_palette.py
@@ -270,7 +270,7 @@ def onItemPressed(self, item, column):
             self.setItemExpanded(item, not self.isItemExpanded(item))
 
     def contextMenuEvent(self, event):
-        # Just dispatches the menu event to the widget item
+        """Just dispatches the menu event to the widget item"""
         item = self.itemAt(event.pos())
         if item:
             # find top level
diff --git a/vistrails/gui/paramexplore/param_view.py b/vistrails/gui/paramexplore/param_view.py
index cbb3cd9f3..461474037 100644
--- a/vistrails/gui/paramexplore/param_view.py
+++ b/vistrails/gui/paramexplore/param_view.py
@@ -65,7 +65,8 @@ class ParameterInfo(InstanceObject):
     #                   pos=,
     #                   value=,
     #                   spec=,
-    #                   is_alias=)
+    #                   is_alias=,
+    #                   union=)
     pass
 
 ################################################################################
@@ -195,7 +196,8 @@ def updateFromPipeline(self, pipeline, controller):
                                       pos=parameter.pos,
                                       value=v,
                                       spec=port_spec_item,
-                                      is_alias=True)
+                                      is_alias=True,
+                                      union=port_spec.union)
                 QParameterTreeWidgetItem((alias, [pInfo]),
                                          aliasRoot, label)
             aliasRoot.setExpanded(True)
@@ -235,13 +237,16 @@ def updateFromPipeline(self, pipeline, controller):
                                        pos=port_spec.port_spec_items[pId].pos,
                                        value="",
                                        spec=port_spec.port_spec_items[pId],
-                                       is_alias=False)
+                                       is_alias=False,
+                                       union=port_spec.union)
                          for pId in xrange(len(port_spec.port_spec_items))]
                 QParameterTreeWidgetItem((vv.name, pList),
                                          vistrailVarsRoot,
                                          label)
                 continue
                 
+            if module.is_valid:
+                port_dict = dict((p.name, p) for p in module.destinationPorts())
             function_names = {}
             # Add existing parameters
             mLabel = [module.name]
@@ -259,33 +264,37 @@ def updateFromPipeline(self, pipeline, controller):
                         else:
                             moduleItem = QParameterTreeWidgetItem(None,
                                                                   self, mLabel)
-                    v = ', '.join([p.strValue for p in function.params])
-                    label = ['%s(%s)' % (function.name, v)]
-                    
+
                     try:
-                        port_spec = function.get_spec('input')
+                        if module.is_valid:
+                            port_spec = port_dict[function.name]
+                        else:
+                            port_spec = function.get_spec('input')
                     except Exception:
                         debug.critical("get_spec failed: %s %s %s" % \
                                        (module, function, function.sigstring))
                         continue
+                    v = ', '.join([p.strValue for p in function.params])
+                    label = ['%s(%s)' % (port_spec.union or function.name, v)]
                     port_spec_items = port_spec.port_spec_items
                     pList = [ParameterInfo(module_id=mId,
                                            name=function.name,
                                            pos=function.params[pId].pos,
                                            value=function.params[pId].strValue,
                                            spec=port_spec_items[pId],
-                                           is_alias=False)
+                                           is_alias=False,
+                                           union=port_spec.union)
                              for pId in xrange(len(function.params))]
                     mName = module.name
                     if moduleItem.parameter is not None:
                         mName += '(%d)' % moduleItem.parameter
-                    fName = '%s :: %s' % (mName, function.name)
+                    fName = '%s :: %s' % (mName, port_spec.union or function.name)
                     QParameterTreeWidgetItem((fName, pList),
                                              moduleItem,
                                              label)
             # Add available parameters
             if module.is_valid:
-                for port_spec in module.destinationPorts():
+                for port_spec in port_dict.itervalues():
                     if (port_spec.name in function_names or
                         not port_spec.is_valid or 
                         not len(port_spec.port_spec_items) or
@@ -304,18 +313,19 @@ def updateFromPipeline(self, pipeline, controller):
                             moduleItem = QParameterTreeWidgetItem(None, self,
                                                                   mLabel, False)
                     v = ', '.join([p.module for p in port_spec.port_spec_items])
-                    label = ['%s(%s)' % (port_spec.name, v)]
+                    label = ['%s(%s)' % (port_spec.union or port_spec.name, v)]
                     pList = [ParameterInfo(module_id=mId,
                                            name=port_spec.name,
                                            pos=port_spec.port_spec_items[pId].pos,
                                            value="",
                                            spec=port_spec.port_spec_items[pId],
-                                           is_alias=False)
+                                           is_alias=False,
+                                           union=port_spec.union)
                              for pId in xrange(len(port_spec.port_spec_items))]
                     mName = module.name
                     if moduleItem.parameter is not None:
                         mName += '(%d)' % moduleItem.parameter
-                    fName = '%s :: %s' % (mName, port_spec.name)
+                    fName = '%s :: %s' % (mName, port_spec.union or port_spec.name)
                     QParameterTreeWidgetItem((fName, pList),
                                              moduleItem,
                                              label, False)
diff --git a/vistrails/gui/pipeline_view.py b/vistrails/gui/pipeline_view.py
index 208a0d89c..34791d581 100644
--- a/vistrails/gui/pipeline_view.py
+++ b/vistrails/gui/pipeline_view.py
@@ -104,11 +104,12 @@ class QAbstractGraphicsPortItem(QtGui.QAbstractGraphicsShapeItem):
     specific qgraphicsitem type.
     
     """
-    def __init__(self, port, x, y, ghosted=False, parent=None):
+    def __init__(self, port, x, y, ghosted=False, parent=None, union_group=None):
         """ QAbstractGraphicsPortItem(port: PortSpec,
                                       x: float,
                                       y: float,
                                       ghosted: bool,
+                                      union: [PortSpec],
                                       parent: QGraphicsItem)
                                       -> QAbstractGraphicsPortItem
         Create the shape, initialize its pen and brush accordingly
@@ -121,6 +122,7 @@ def __init__(self, port, x, y, ghosted=False, parent=None):
         self.setFlags(QtGui.QGraphicsItem.ItemIsSelectable)
         self.controller = None
         self.port = port
+        self.union_group = union_group
         self.dragging = False
         self.tmp_connection_item = None
 
@@ -266,7 +268,7 @@ def updateToolTip(self):
         tooltip = ""
         if (self.port is not None and self.port.is_valid and
             hasattr(self.port, 'toolTip')):
-            tooltip = self.port.toolTip()
+            tooltip = self.port.toolTip(self.union_group)
         for vistrail_var in self.vistrail_vars.itervalues():
             tooltip += '\nConnected to vistrail var "%s"' % vistrail_var
         self.setToolTip(tooltip)
@@ -378,30 +380,39 @@ def mouseMoveEvent(self, event):
         if self.dragging:
             if not self.tmp_connection_item:
                 z_val = max(self.controller.current_pipeline.modules) + 1
-                self.tmp_connection_item = QGraphicsTmpConnItem(self, z_val,
-                                                                True)
+                self.tmp_connection_item = \
+                    QGraphicsTmpConnItem(self,
+                                         self.union_group or [self],
+                                         z_val,
+                                         True)
                 self.scene().addItem(self.tmp_connection_item)
             self.tmp_connection_item.setCurrentPos(event.scenePos())
-            snapPort = None
+            snapPortItem = None
+            snapPorts = None
             snapModule = self.scene().findModuleUnder(event.scenePos())
             converters = []
             if snapModule and snapModule != self.parentItem():
                 if self.port.type == 'output':
                     portMatch = self.scene().findPortMatch(
-                        [self], snapModule.inputPorts.values(),
+                        [self], set(snapModule.inputPorts.values()),
                         fixed_out_pos=event.scenePos(),
                         allow_conversion=True, out_converters=converters)
                     if portMatch[1] is not None:
-                        snapPort = portMatch[1]
+                        snapPortItem = portMatch[1]
+                        snapPorts = portMatch[2]
                 elif self.port.type == 'input':
                     portMatch = self.scene().findPortMatch(
                         snapModule.outputPorts.values(), [self],
                         fixed_in_pos=event.scenePos(),
                         allow_conversion=True, out_converters=converters)
                     if portMatch[0] is not None:
-                        snapPort = portMatch[0]
-            self.tmp_connection_item.setSnapPort(snapPort)
-            if snapPort:
+                        snapPortItem = portMatch[0]
+                        snapPorts = portMatch[0].port
+                        # select matching ports in input union
+                        self.tmp_connection_item.setStartPort(portMatch[1],
+                                                              portMatch[2])
+            self.tmp_connection_item.setSnapPort(snapPortItem, snapPorts)
+            if snapPortItem:
                 tooltip = self.tmp_connection_item.snapPortItem.toolTip()
                 if converters:
                     tooltip = ('<strong>conversion required</strong><br/>\n'
@@ -409,7 +420,7 @@ def mouseMoveEvent(self, event):
                 QtGui.QToolTip.showText(event.screenPos(), tooltip)
             else:
                 QtGui.QToolTip.hideText()
-            self.tmp_connection_item.setConverting(snapPort and converters)
+            self.tmp_connection_item.setConverting(snapPortItem and converters)
         QtGui.QAbstractGraphicsShapeItem.mouseMoveEvent(self, event)
         
     def findSnappedPort(self, pos):
@@ -773,12 +784,14 @@ def upgradeAbstraction(self):
                 self.controller.invalidate_version_tree()
         
 class QGraphicsTmpConnItem(QtGui.QGraphicsLineItem):
-    def __init__(self, startPortItem, zValue=1, alwaysDraw=False, parent=None):
+    def __init__(self, startPortItem, startPorts, zValue=1, alwaysDraw=False, parent=None):
         QtGui.QGraphicsLineItem.__init__(self, parent)
         self.startPortItem = startPortItem
+        self.startPorts = startPorts
         self.setPen(CurrentTheme.CONNECTION_SELECTED_PEN)
         self.setZValue(zValue)
         self.snapPortItem = None
+        self.snapPort = None
         self.alwaysDraw = alwaysDraw
         self.currentPos = None
 
@@ -796,12 +809,14 @@ def updateLine(self):
                 return
         self.disconnect()
 
-    def setStartPort(self, port):
-        self.startPortItem = port
+    def setStartPort(self, portItem, ports=None):
+        self.startPortItem = portItem
+        self.startPorts = ports
         self.updateLine()
 
-    def setSnapPort(self, port):
-        self.snapPortItem = port
+    def setSnapPort(self, portItem, ports=None):
+        self.snapPortItem = portItem
+        self.snapPorts = ports
         self.updateLine()
 
     def setCurrentPos(self, pos):
@@ -1067,6 +1082,9 @@ def __init__(self, parent=None, scene=None):
         self.description = ''
         self.inputPorts = {}
         self.outputPorts = {}
+        self.union_ports = {}
+        self.to_union = {}
+        self.port_groups = []
         self.controller = None
         self.module = None
         self.ghosted = False
@@ -1471,6 +1489,12 @@ def setupModule(self, module, read_only=False):
         self.id = module.id
         self.setZValue(float(self.id))
         self.module = module
+        self.union_ports = module.unionPorts() if module.is_valid else {}
+
+        # reverse map
+        self.to_union = dict((p.name, self.union_ports[union])
+                             for union, p_list in self.union_ports.items()
+                             for p in p_list)
         self.center = copy.copy(module.center)
         if '__desc__' in module.db_annotations_key_index:
             self.label = module.get_annotation_by_key('__desc__').value.strip()
@@ -1514,9 +1538,14 @@ def setupModule(self, module, read_only=False):
                     if not p.optional:
                         inputPorts.append(p)
                     elif p.name in module.visible_input_ports:
-                        visibleOptionalInputPorts.append(p)
+                        # add all in union if one is marked as visible
+                        for up in self.to_union.get(p.name, [p]):
+                            if up not in visibleOptionalInputPorts:
+                                visibleOptionalInputPorts.append(up)
                     else:
-                        self.optionalInputPorts.append(p)
+                        # Make sure it was not added with union
+                        if p.name not in visibleOptionalInputPorts:
+                            self.optionalInputPorts.append(p)
                 inputPorts += visibleOptionalInputPorts
 
                 for p in module.sourcePorts():
@@ -1530,12 +1559,25 @@ def setupModule(self, module, read_only=False):
             except ModuleRegistryException, e:
                 error = e
 
+        # group unions while keeping order
+        pos_to_name = {}
+        name_to_ports = {}
+        for port_spec in inputPorts:
+            name = port_spec.union or port_spec.name
+            if name not in pos_to_name.itervalues():
+                pos = (max(pos_to_name) + 1) if pos_to_name else 0
+                pos_to_name[pos] = name
+                name_to_ports[name] = []
+            name_to_ports[name].append(port_spec)
+
+        self.port_groups = [name_to_ports[name]
+                            for _, name in sorted(pos_to_name.iteritems())]
         # Local dictionary lookups are faster than global ones..
         t = CurrentTheme
         (mpm0, mpm1, mpm2, mpm3) = t.MODULE_PORT_MARGIN
 
         # Adjust the width to fit all ports
-        maxPortCount = max(len(inputPorts), len(outputPorts))
+        maxPortCount = max(len(self.port_groups), len(outputPorts))
         minWidth = (mpm0 +
                     t.PORT_WIDTH*maxPortCount +
                     t.MODULE_PORT_SPACE*(maxPortCount-1) +
@@ -1552,8 +1594,11 @@ def setupModule(self, module, read_only=False):
 
         # Update input ports
         [x, y] = self.nextInputPortPos
-        for port in inputPorts:
-            self.inputPorts[port] = self.createPortItem(port, x, y)
+        for ports in self.port_groups:
+            item = self.createPortItem(ports[0], x, y,
+                                       ports if len(ports)>1 else [])
+            for port in ports:
+                self.inputPorts[port] = item
             x += t.PORT_WIDTH + t.MODULE_PORT_SPACE
         self.nextInputPortPos = [x,y]
 
@@ -1647,7 +1692,7 @@ def create_shape_from_fringe(self, fringe):
         module_shape.append(module_shape[0])
         return module_shape
 
-    def createPortItem(self, port, x, y):
+    def createPortItem(self, port, x, y, union_group=None):
         """ createPortItem(port: Port, x: int, y: int) -> QGraphicsPortItem
         Create a item from the port spec
         
@@ -1665,9 +1710,12 @@ def createPortItem(self, port, x, y):
         # portShape = QGraphicsPortDiamondItem(x, y, self.ghosted, self, 
         #                                      port.optional, port.min_conns,
         #                                      port.max_conns)
-    
+        if not union_group and port.union and port.union in self.union_ports:
+            union_group = self.union_ports[port.union]
         port_klass = QGraphicsPortRectItem
         kwargs = {}
+        if union_group:
+            kwargs['union_group'] = union_group
         shape = port.shape()
         if shape is not None:
             if isinstance(shape, basestring):
@@ -1762,8 +1810,9 @@ def buildPortItem(self, port, port_dict, optional_ports, visible_ports,
             for p in optional_ports:
                 if registry.port_and_port_spec_match(port, p):
                     item = self.createPortItem(p, *next_pos)
-                    visible_ports.add(port.name)
-                    port_dict[p] = item
+                    for union_port in self.to_union.get(port.name, [port]):
+                        visible_ports.add(union_port.name)
+                        port_dict[union_port] = item
                     next_pos[0] = next_op(next_pos[0], 
                                           (CurrentTheme.PORT_WIDTH +
                                            CurrentTheme.MODULE_PORT_SPACE))
@@ -2186,6 +2235,7 @@ def clear(self):
         self._old_module_ids = set()
         self._old_connection_ids = set()
         self.unselect_all()
+
         self.clearItems()
         
     def remove_module(self, m_id):
@@ -2472,9 +2522,8 @@ def findPortMatch(self, output_ports, input_ports, x_trans=0,
         this case, we extend the optional 'out_converters' list with the
         possible Converters' ModuleDescriptors.
         """
-
         reg = get_module_registry()
-        result = (None, None)
+        result = (None, None, None)
         min_dis = None
         selected_convs = None
         for o_item in output_ports:
@@ -2483,25 +2532,52 @@ def findPortMatch(self, output_ports, input_ports, x_trans=0,
             for i_item in input_ports:
                 if i_item.invalid:
                     continue
+                # Check all union types
+                # add all matches to iports
+                # check without converters first
+                for iport in i_item.union_group or [i_item.port]:
+                    if reg.ports_can_connect(o_item.port, iport):
+                        if fixed_out_pos is not None:
+                            out_pos = fixed_out_pos
+                        else:
+                            out_pos = o_item.getPosition()
+                        if fixed_in_pos is not None:
+                            in_pos = fixed_in_pos
+                        else:
+                            in_pos = i_item.getPosition()
+                        vector = (out_pos - in_pos)
+                        dis = (vector.x()-x_trans)*(vector.x()-x_trans) + \
+                            vector.y()*vector.y()
+                        if (result[0] is not None and result[0] == o_item and
+                                                      result[1] == i_item):
+                            # additional match in same union
+                            result[2].append(iport)
+                        elif result[1] is None or dis < min_dis:
+                            min_dis = dis
+                            result = (o_item, i_item, [iport])
+                if result[0] == o_item and result[1] == i_item:
+                    continue
                 convs = []
-                if reg.ports_can_connect(o_item.port, i_item.port,
-                                         allow_conversion=True,
-                                         out_converters=convs):
-                    if fixed_out_pos is not None:
-                        out_pos = fixed_out_pos
-                    else:
-                        out_pos = o_item.getPosition()
-                    if fixed_in_pos is not None:
-                        in_pos = fixed_in_pos
-                    else:
-                        in_pos = i_item.getPosition()
-                    vector = (out_pos - in_pos)
-                    dis = (vector.x()-x_trans)*(vector.x()-x_trans) + \
-                        vector.y()*vector.y()
-                    if result[0] is None or dis < min_dis:
-                        min_dis = dis
-                        result = (o_item, i_item)
-                        selected_convs = convs
+                # this selects only the first match in a union
+                for iport in i_item.union_group or [i_item.port]:
+                    if reg.ports_can_connect(o_item.port, iport,
+                                             allow_conversion=True,
+                                             out_converters=convs):
+                        if fixed_out_pos is not None:
+                            out_pos = fixed_out_pos
+                        else:
+                            out_pos = o_item.getPosition()
+                        if fixed_in_pos is not None:
+                            in_pos = fixed_in_pos
+                        else:
+                            in_pos = i_item.getPosition()
+                        vector = (out_pos - in_pos)
+                        dis = (vector.x()-x_trans)*(vector.x()-x_trans) + \
+                            vector.y()*vector.y()
+                        if result[0] is None or dis < min_dis:
+                            min_dis = dis
+                            result = (o_item, i_item, [iport])
+                            selected_convs = convs
         if selected_convs and out_converters is not None:
             out_converters.extend(selected_convs)
         return result
@@ -2510,21 +2586,25 @@ def updateTmpConnection(self, pos, tmp_connection_item, tmp_module_ports,
                             where_mult, order_f):
         near_ports = self.findPortsNear(pos, where_mult)
         if len(near_ports) > 0:
-            (src_item, dst_item) = \
+            (src_item, dst_item, dst_ports) = \
                 self.findPortMatch(*order_f([near_ports,tmp_module_ports]),
                                     x_trans=-50)
             if src_item is not None:
                 if tmp_connection_item is None:
-                    tmp_connection_item = QGraphicsTmpConnItem(dst_item, 1000)
+                    tmp_connection_item = QGraphicsTmpConnItem(dst_item, dst_ports, 1000)
                     self.addItem(tmp_connection_item)
                 # We are assuming the first view is the real pipeline view
                 v = self.views()[0]
-                tmp_connection_item.setStartPort(dst_item)
+                tmp_connection_item.setStartPort(dst_item, dst_ports)
                 tmp_connection_item.setSnapPort(src_item)
-                tooltip = "%s %s\n  -> %s %s" % (src_item.port.name, 
-                                              src_item.port.short_sigstring,
-                                              dst_item.port.name, 
-                                              dst_item.port.short_sigstring)
+                dst_type_str = ' or '.join([('List of ' * dst_port.depth +
+                                             dst_port.short_sigstring)
+                                            for dst_port in dst_ports])
+                tooltip = "%s %s\n  -> %s %s" % (src_item.port.name,
+                                                 'List of ' * src_item.port.depth +
+                                                 src_item.port.short_sigstring,
+                                                 dst_port.union or dst_port.name,
+                                                 dst_type_str)
                 QtGui.QToolTip.showText(v.mapToGlobal(
                         v.mapFromScene((dst_item.getPosition() + 
                                         src_item.getPosition())/2.0)),
@@ -2540,13 +2620,13 @@ def updateTmpConnection(self, pos, tmp_connection_item, tmp_module_ports,
     def updateTmpInputConnection(self, pos):
         self.tmp_input_conn = \
             self.updateTmpConnection(pos, self.tmp_input_conn, 
-                                     self.tmp_module_item.inputPorts.values(), 
+                                     set(self.tmp_module_item.inputPorts.values()),
                                      -1, lambda x: x)
             
     def updateTmpOutputConnection(self, pos):
         self.tmp_output_conn = \
             self.updateTmpConnection(pos, self.tmp_output_conn, 
-                                     self.tmp_module_item.outputPorts.values(), 
+                                     set(self.tmp_module_item.outputPorts.values()),
                                      1, reversed)
 
     def dragEnterEvent(self, event):
@@ -2597,9 +2677,9 @@ def dragMoveEvent(self, event):
                 if snapModule is not None:
                     tmp_port = QAbstractGraphicsPortItem(None, 0, 0)
                     tmp_port.port = data.variableData[0]
-                    (_, nearest_port) = \
-                        self.findPortMatch([tmp_port], \
-                                               snapModule.inputPorts.values(), \
+                    (_, nearest_port, iport) = \
+                        self.findPortMatch([tmp_port],
+                                               set(snapModule.inputPorts.values()),
                                                fixed_out_pos=event.scenePos())
                     del tmp_port
                 # Unhighlight previous nearest port
@@ -2644,12 +2724,40 @@ def unselect_all(self):
 
     def createConnectionFromTmp(self, tmp_connection_item, module, 
                                 start_is_src=False):
+        def select_type(ports):
+            selected_port_spec = [None]
+            def add_selector(ps):
+                def triggered(*args, **kwargs):
+                    selected_port_spec[0] = ps
+                return triggered
+            menu = QtGui.QMenu(self.parent())
+            for port_spec in ports:
+                type_name = port_spec.type_name()
+                label = 'Select destination port type: ' + type_name
+                act = QtGui.QAction(label, self.parent())
+                act.setStatusTip(label)
+                act.triggered.connect(add_selector(port_spec))
+                menu.addAction(act)
+            menu.exec_(QtGui.QCursor.pos())
+            return selected_port_spec[0]
         if start_is_src:
             src_port_item = tmp_connection_item.startPortItem
             dst_port_item = tmp_connection_item.snapPortItem
+            if len(tmp_connection_item.snapPorts) > 1:
+                dst_port = select_type(tmp_connection_item.snapPorts)
+                if not dst_port:
+                    return
+            else:
+                dst_port = tmp_connection_item.snapPorts[0]
         else:
             src_port_item = tmp_connection_item.snapPortItem
             dst_port_item = tmp_connection_item.startPortItem
+            if len(tmp_connection_item.startPorts) > 1:
+                dst_port = select_type(tmp_connection_item.startPorts)
+                if not dst_port:
+                    return
+            else:
+                dst_port = tmp_connection_item.startPorts[0]
 
         if src_port_item.parentItem().id < 0 or start_is_src:
             src_module_id = module.id
@@ -2667,17 +2775,17 @@ def createConnectionFromTmp(self, tmp_connection_item, module,
 
         reg = get_module_registry()
 
-        if reg.ports_can_connect(src_port_item.port, dst_port_item.port):
+        if reg.ports_can_connect(src_port_item.port, dst_port):
             # Direct connection
             conn = self.controller.add_connection(src_module_id,
                                                   src_port_item.port,
                                                   dst_module_id,
-                                                  dst_port_item.port)
+                                                  dst_port)
             self.addConnection(conn)
         else:
             # Add a converter module
             converters = reg.get_converters(src_port_item.port.descriptors(),
-                                            dst_port_item.port.descriptors())
+                                            dst_port.descriptors())
             converter = choose_converter(converters)
             if converter is None:
                 return
@@ -2698,7 +2806,7 @@ def createConnectionFromTmp(self, tmp_connection_item, module,
             conn2 = self.controller.create_connection(
                     mod, 'out_value',
                     self.controller.current_pipeline.modules[dst_module_id],
-                    dst_port_item.port)
+                    dst_port)
             operations = [('add', mod), ('add', conn1), ('add', conn2)]
 
             action = create_action(operations)
@@ -3580,6 +3688,7 @@ def __init__(self, parent=None):
         self.set_title('Pipeline')
         self.controller = None
         self.detachable = True
+        self._view_fitted = False
 
     def set_default_layout(self):
         from vistrails.gui.module_palette import QModulePalette
@@ -3758,6 +3867,7 @@ def get_controller(self):
         return self.controller
 
     def version_changed(self):
+        self._view_fitted = False
         self.scene().setupScene(self.controller.current_pipeline)
 
     def run_control_flow_assist(self):
@@ -3792,6 +3902,12 @@ def paintModuleToPixmap(self, module_item):
         m = self.matrix()
         return module_item.paintToPixmap(m.m11(), m.m22())
 
+    def viewSelected(self):
+        if not self._view_fitted and self.isVisible():
+            # We only do this once after a version_changed() call
+            self.zoomToFit()
+            self._view_fitted = True
+
 ################################################################################
 # Testing
 
diff --git a/vistrails/gui/ports_pane.py b/vistrails/gui/ports_pane.py
index b86ad69d0..8e21126e4 100644
--- a/vistrails/gui/ports_pane.py
+++ b/vistrails/gui/ports_pane.py
@@ -313,7 +313,7 @@ class PortItem(QtGui.QTreeWidgetItem):
                                  'gui/resources/images/connection.png'))
 
     def __init__(self, port_spec, is_connected, is_optional, is_visible,
-                 is_editable=False, parent=None):
+                 is_editable=False, parent=None, union_items=None):
         QtGui.QTreeWidgetItem.__init__(self, parent)
         # self.setFlags(QtCore.Qt.ItemIsUserCheckable | QtCore.Qt.ItemIsEnabled)
         self.setFlags(QtCore.Qt.ItemIsEnabled)
@@ -324,8 +324,9 @@ def __init__(self, port_spec, is_connected, is_optional, is_visible,
         self.is_visible = is_visible
         self.is_editable = is_editable
         self.is_unset = False
+        self.union_items = union_items
         self.build_item(port_spec, is_connected, is_optional, is_visible,
-                        is_editable)
+                        is_editable, union_items)
 
     def visible(self):
         return not self.is_optional or self.is_visible
@@ -333,9 +334,9 @@ def visible(self):
     def set_visible(self, visible):
         self.is_visible = visible
         if visible:
-            self.setIcon(0, PortItem.eye_open_icon)
+            self.setIcon(1, PortItem.eye_open_icon)
         else:
-            self.setIcon(0, PortItem.eye_closed_icon)
+            self.setIcon(1, PortItem.eye_closed_icon)
 
     def set_editable(self, edit):
         self.is_editable = edit
@@ -350,9 +351,11 @@ def get_visible(self):
     def get_connected(self):
         return self.connected_checkbox
 
-    def is_constant(self):
-        return (self.port_spec.is_valid and 
-                get_module_registry().is_constant(self.port_spec))
+    def is_constant(self, port_spec=None):
+        if port_spec is None:
+            port_spec = self.port_spec
+        return (port_spec.is_valid and
+                get_module_registry().is_constant(port_spec))
 
     def calcUnset(self):
         self.is_unset = self.is_constant() and \
@@ -364,7 +367,7 @@ def calcUnset(self):
             font.setWeight(QtGui.QFont.Bold)
             self.setFont(3, font)
 
-    def build_item(self, port_spec, is_connected, is_optional, is_visible, is_editable):
+    def build_item(self, port_spec, is_connected, is_optional, is_visible, is_editable, union_items):
         if not is_optional:
             self.setIcon(1, PortItem.eye_disabled_icon)
         elif is_visible:
@@ -374,7 +377,7 @@ def build_item(self, port_spec, is_connected, is_optional, is_visible, is_editab
 
         if is_connected:
             self.setIcon(2, PortItem.conn_icon)
-        self.setText(3, port_spec.name)
+        self.setText(3, port_spec.union if union_items else port_spec.name)
 
         if self.is_constant():
             if len(self.port_spec.port_spec_items)>0:
@@ -470,7 +473,7 @@ def update_module(self, module):
             reg = get_module_registry()
             descriptor = module.module_descriptor
             if self.port_type == 'input':
-                self.setColumnHidden(0,not get_vistrails_configuration(
+                self.setColumnHidden(0, not get_vistrails_configuration(
                                         ).check('showInlineParameterWidgets'))
                 port_specs = module.destinationPorts()
                 connected_ports = module.connected_input_ports
@@ -482,18 +485,34 @@ def update_module(self, module):
             else:
                 raise TypeError("Unknown port type: '%s'" % self.port_type)
             
-            for port_spec in sorted(port_specs, key=lambda x: x.name):
-                connected = port_spec.name in connected_ports and \
-                    connected_ports[port_spec.name] > 0
+            # Create common portitem for union ports
+            ps_groups = {'': []}
+            for port_spec in port_specs:
+                if port_spec.union not in ps_groups:
+                    ps_groups[port_spec.union] = []
+                ps_groups[port_spec.union].append(port_spec)
+            non_unions = ps_groups.pop('')
+            ps_groups = ps_groups.values() + [[ps] for ps in non_unions]
+            for port_specs in sorted(ps_groups, key=lambda x: x[0].union or x[0].name):
+                first_port_spec = port_specs[0]
+                connected = True in [port_spec.name in connected_ports and \
+                    connected_ports[port_spec.name] > 0 for port_spec in port_specs]
+                visible = True in [port_spec.name in visible_ports
+                                   for port_spec in port_specs]
+                editable = True in [port_spec.name in module.editable_input_ports
+                                    for port_spec in port_specs]
                 item = PortItem(port_spec,
                                 connected,
-                                port_spec.optional,
-                                port_spec.name in visible_ports,
-                                port_spec.name in module.editable_input_ports)
+                                first_port_spec.optional,
+                                visible,
+                                editable,
+                                union_items=port_specs if len(port_specs) > 1 else None)
                 self.addTopLevelItem(item)
-                self.port_spec_items[port_spec.name] = (port_spec, item)
+                for port_spec in port_specs:
+                    self.port_spec_items[port_spec.name] = (port_spec, item)
 
             if self.port_type == 'input':
+                # add functions to port items
                 for function in module.functions:
                     if not function.is_valid:
                         continue
@@ -603,9 +622,35 @@ def item_clicked(self, item, col):
             if item.is_constant() and len(item.port_spec.port_spec_items)>0:
                 item.set_editable(not item.is_editable)
                 if item.is_editable:
-                    editable_ports.add(item.port_spec.name)
+                    if item.union_items:
+                        candidates = [ps for ps in item.union_items
+                                      if item.is_constant(ps)]
+                        if len(candidates) == 0:
+                            return
+                        elif len(candidates) == 1:
+                            port_spec = candidates[0]
+                        else:
+                            port_spec = self.select_type(candidates,
+                                                    'Show on module as type:')
+                        if not port_spec:
+                            try:
+                                item.set_editable(False)
+                            except:
+                                # item may have been deleted on focus change
+                                pass
+                            return
+                    else:
+                        port_spec = item.port_spec
+                    editable_ports.add(port_spec.name)
                 else:
-                    editable_ports.discard(item.port_spec.name)
+                    if item.union_items:
+                        # iterate items
+                        for port_spec in item.union_items:
+                            if port_spec.name in editable_ports:
+                                break
+                    else:
+                        port_spec = item.port_spec
+                    editable_ports.discard(port_spec.name)
                 self.controller.flush_delayed_actions()
                 self.controller.add_annotation((self.module.INLINE_WIDGET_ANNOTATION,
                                                 ','.join(editable_ports)),
@@ -616,20 +661,44 @@ def item_clicked(self, item, col):
             if item.is_optional and not item.is_connected:
                 item.set_visible(not item.is_visible)
                 if item.is_visible:
-                    visible_ports.add(item.port_spec.name)
+                    if item.union_items:
+                        # show all of them
+                        for port_spec in item.union_items:
+                            visible_ports.add(port_spec.name)
+                    else:
+                        visible_ports.add(item.port_spec.name)
                 else:
-                    visible_ports.discard(item.port_spec.name)
+                    if item.union_items:
+                        for port_spec in item.union_items:
+                            visible_ports.discard(port_spec.name)
+                    else:
+                        visible_ports.discard(item.port_spec.name)
                 self.controller.flush_delayed_actions()
                 self.controller.current_pipeline_scene.recreate_module(
                     self.controller.current_pipeline, self.module.id)
         if col == 3:
-            if item.isExpanded():
+            if not item.union_items and item.isExpanded():
                 item.setExpanded(False)
-            elif item.childCount() > 0:
+            elif not item.union_items and item.childCount() > 0:
                 item.setExpanded(True)
-            elif item.childCount() == 0 and item.is_constant():
+            elif (not item.union_items and item.childCount() == 0 and
+                  item.is_constant()):
                 self.do_add_method(item.port_spec, item)
-        
+            elif item.union_items:
+                # union port always ask to add new port when clicked
+                candidates = [ps for ps in item.union_items
+                              if item.is_constant(ps)]
+                if len(candidates) == 0:
+                    return
+                elif len(candidates) == 1:
+                    port_spec = candidates[0]
+                else:
+                    port_spec = self.select_type(candidates, 'Add as:')
+                if not port_spec:
+                    return
+                self.do_add_method(port_spec, item)
+
+
     def set_controller(self, controller):
         self.controller = controller
 
@@ -711,6 +780,26 @@ def contextMenuEvent(self, event):
         if item:
             item.contextMenuEvent(event, self)
 
+    def select_type(self, port_specs, text):
+        """ Prompts user to select a specific type in a union type
+        """
+        selected_port_spec = [None]
+        def add_selector(ps):
+            def triggered(*args, **kwargs):
+                selected_port_spec[0] = ps
+            return triggered
+        menu = QtGui.QMenu(self)
+        for port_spec in port_specs:
+            type_name = port_spec.type_name()
+            label = text + ' ' + type_name
+            act = QtGui.QAction(label, self)
+            act.setStatusTip(label)
+            act.triggered.connect(add_selector(port_spec))
+            menu.addAction(act)
+        menu.exec_(QtGui.QCursor.pos())
+        return selected_port_spec[0]
+
+
 class QPortsPane(QtGui.QWidget, QToolWindowInterface):
     def __init__(self, port_type, parent=None, flags=QtCore.Qt.Widget):
         QtGui.QWidget.__init__(self, parent, flags)
diff --git a/vistrails/gui/resources/images/vistrails_splash.png b/vistrails/gui/resources/images/vistrails_splash.png
index 38857f848..ced9a5aef 100644
Binary files a/vistrails/gui/resources/images/vistrails_splash.png and b/vistrails/gui/resources/images/vistrails_splash.png differ
diff --git a/vistrails/gui/version_view.py b/vistrails/gui/version_view.py
index 503da880d..d959ffa17 100644
--- a/vistrails/gui/version_view.py
+++ b/vistrails/gui/version_view.py
@@ -1110,6 +1110,7 @@ def __init__(self, parent=None):
         self.setScene(QVersionTreeScene(self))
         self.versionProp = QVersionPropOverlay(self, self.viewport())
         self.versionProp.hide()
+        self._view_fitted = False
 
     def set_default_layout(self):
         from vistrails.gui.collection.workspace import QWorkspaceWindow
@@ -1199,6 +1200,7 @@ def set_title(self, title):
         self.setWindowTitle(title)
 
     def set_controller(self, controller):
+        self._view_fitted = False
         oldController = self.controller
         if oldController != controller:
             if oldController is not None:
@@ -1272,3 +1274,9 @@ def notesChanged(self):
 
     def select_current_version(self):
         self.scene().setupScene(self.controller)
+
+    def viewSelected(self):
+        if not self._view_fitted and self.isVisible():
+            # We only do this once after a set_controller() call
+            self.zoomToFit()
+            self._view_fitted = True
diff --git a/vistrails/gui/vistrail_controller.py b/vistrails/gui/vistrail_controller.py
index e8af29707..ccd9686c6 100644
--- a/vistrails/gui/vistrail_controller.py
+++ b/vistrails/gui/vistrail_controller.py
@@ -36,8 +36,6 @@
 
 from __future__ import division
 
-import copy
-import math
 import os
 import uuid
 
@@ -48,6 +46,7 @@
 from vistrails.core.data_structures.graph import Graph
 from vistrails.core import debug
 import vistrails.core.db.action
+import vistrails.core.db.io
 from vistrails.core.interpreter.default import get_default_interpreter
 from vistrails.core.vistrail.job import Workflow as JobWorkflow
 from vistrails.core.layout.version_tree_layout import VistrailsTreeLayoutLW
@@ -184,6 +183,10 @@ def __init__(self, vistrail=None, locator=None, abstractions=None,
         if self._auto_save:
             self.setup_timer()
 
+        # the redo stack stores the undone action ids
+        # (undo is automatic with us, through the version tree)
+        self.redo_stack = []
+
         def width_f(text):
             return CurrentTheme.VERSION_FONT_METRIC.width(text)
         self._current_graph_layout = \
@@ -239,6 +242,41 @@ def stop_timer(self):
         if self.timer:
             self.disconnect(self.timer, QtCore.SIGNAL("timeout()"), self.write_temporary)
             self.timer.stop()
+
+    def reset_redo_stack(self):
+        self.redo_stack = []
+
+    def undo(self):
+        """Performs one undo step, moving up the version tree."""
+        action_map = self.vistrail.actionMap
+        old_action = action_map.get(self.current_version, None)
+        self.redo_stack.append(self.current_version)
+        self.show_parent_version()  # missing in core controller
+        new_action = action_map.get(self.current_version, None)
+        return (old_action, new_action)
+        # self.set_pipeline_selection(old_action, new_action, 'undo')
+        # return self.current_version
+
+    def redo(self):
+        """Performs one redo step if possible, moving down the version tree."""
+        action_map = self.vistrail.actionMap
+        old_action = action_map.get(self.current_version, None)
+        if len(self.redo_stack) < 1:
+            debug.critical("Redo on an empty redo stack. Ignoring.")
+            return
+        next_version = self.redo_stack[-1]
+        self.redo_stack = self.redo_stack[:-1]
+        self.show_child_version(next_version)  # missing in core controller
+        new_action = action_map[self.current_version]
+        return (old_action, new_action)
+        # self.set_pipeline_selection(old_action, new_action, 'redo')
+        # return next_version
+
+    def can_redo(self):
+        return (len(self.redo_stack) > 0)
+
+    def can_undo(self):
+        return self.current_version > 0
             
     ##########################################################################
     # Signal vistrail relayout / redraw
@@ -249,7 +287,7 @@ def replace_unnamed_node_in_version_tree(self, old_version, new_version):
         self.reset_version_view = False
         try:
             self.emit(QtCore.SIGNAL('invalidateSingleNodeInVersionTree'),
-                                    old_version, new_version)
+                      old_version, new_version)
         finally:
             self.reset_version_view = True
 
@@ -288,7 +326,7 @@ def disable_autosave(self):
     def get_locator(self):
         from vistrails.gui.application import get_vistrails_application
         if (self._auto_save and 
-            get_vistrails_application().configuration.check('autoSave')):
+                get_vistrails_application().configuration.check('autoSave')):
             if self.locator is None:
                 raise ValueError("locator is None")
             return self.locator
@@ -307,11 +345,11 @@ def cleanup(self):
             if app and app.view == self.vistrail_view:
                 app.close()
 
-
     ##########################################################################
     # Actions, etc
     
-    def perform_action(self, action, quiet=None):
+    def perform_action(self, action, do_validate=True, raise_exception=False,
+                       quiet=None):
         """ performAction(action: Action, quiet=None) -> timestep
 
         performs given action on current pipeline.
@@ -325,7 +363,9 @@ def perform_action(self, action, quiet=None):
         
         """
         if action is not None:
-            BaseController.perform_action(self,action)
+            BaseController.perform_action(self, action,
+                                          do_validate=do_validate,
+                                          raise_exception=raise_exception)
 
             if quiet is None:
                 if not self.quiet:
@@ -353,11 +393,6 @@ def add_new_action(self, action, description=None):
 
     ##########################################################################
 
-    def add_module(self, x, y, identifier, name, namespace='', 
-                   internal_version=-1):
-        return BaseController.add_module(self, identifier, name, namespace, x, y,
-                                         internal_version)
-
     def create_abstraction_with_prompt(self, module_ids, connection_ids, 
                                        name=""):
         name = self.get_abstraction_name(name)
@@ -432,20 +467,19 @@ def execute_current_workflow(self, custom_aliases=None, custom_params=None,
                 locator.save_temporary(self.vistrail)
             try:
                 return self.execute_workflow_list([(self.locator,
-                                             self.current_version,
-                                             self.current_pipeline,
-                                             self.current_pipeline_scene,
-                                             custom_aliases,
-                                             custom_params,
-                                             reason,
-                                             sinks,
-                                             extra_info)])
+                                                    self.current_version,
+                                                    self.current_pipeline,
+                                                    self.current_pipeline_scene,
+                                                    custom_aliases,
+                                                    custom_params,
+                                                    reason,
+                                                    sinks,
+                                                    extra_info)])
             except Exception, e:
                 debug.unexpected_exception(e)
                 raise
         return ([], False)
 
-
     def execute_user_workflow(self, reason='Pipeline Execution', sinks=None):
         """ execute_user_workflow() -> None
         Execute the current workflow (if exists) and monitors it if it contains jobs
@@ -468,7 +502,7 @@ def execute_user_workflow(self, reason='Pipeline Execution', sinks=None):
             if not self.jobMonitor.currentWorkflow():
                 self.create_job = True
 
-            result =  self.execute_current_workflow(reason=reason, sinks=sinks)
+            result = self.execute_current_workflow(reason=reason, sinks=sinks)
 
             self.progress.setValue(100)
         finally:
@@ -637,7 +671,7 @@ def set_refine(self, refine):
         Set the refine state to True or False
         
         """
-        if self.refine!=refine:
+        if self.refine != refine:
             self.refine = refine
             # need to recompute the graph because the refined items might
             # have changed since last time
@@ -714,7 +748,6 @@ def _change_version_short_hop(self, new_version):
                 # bail, for now
                 self.recompute_terse_graph()
                 self.invalidate_version_tree(False)
-        
 
     def show_parent_version(self):
         """ show_parent_version() -> None
@@ -1121,7 +1154,7 @@ def set_file_name(self, file_name):
         """
         old_name = self.file_name
         BaseController.set_file_name(self, file_name)
-        if old_name!=file_name:
+        if old_name != file_name:
             self.emit(QtCore.SIGNAL('stateChanged'))
 
     def write_vistrail(self, locator, version=None, export=False):
@@ -1134,8 +1167,9 @@ def write_vistrail(self, locator, version=None, export=False):
     def write_opm(self, locator):
         if self.log:
             if self.vistrail.db_log_filename is not None:
-                log = vistrails.core.db.io.merge_logs(self.log, 
-                                            self.vistrail.db_log_filename)
+                log = vistrails.core.db.io.merge_logs(
+                        self.log,
+                        self.vistrail.db_log_filename)
             else:
                 log = self.log
             opm_graph = OpmGraph(log=log, 
@@ -1147,8 +1181,9 @@ def write_opm(self, locator):
     def write_prov(self, locator):
         if self.log:
             if self.vistrail.db_log_filename is not None:
-                log = vistrails.core.db.io.merge_logs(self.log, 
-                                            self.vistrail.db_log_filename)
+                log = vistrails.core.db.io.merge_logs(
+                        self.log,
+                        self.vistrail.db_log_filename)
             else:
                 log = self.log
             prov_document = ProvDocument(log=log, 
@@ -1162,7 +1197,7 @@ def query_by_example(self, pipeline):
         Perform visual query on the current vistrail
         
         """
-        if len(pipeline.modules)==0:
+        if len(pipeline.modules) == 0:
             search = TrueSearch()
         else:
             if not self._current_terse_graph:
@@ -1275,7 +1310,7 @@ def executeParameterExploration(self, pe, view=None, extra_info={}, showProgress
 
             mCount = []
             for p in modifiedPipelines:
-                if len(mCount)==0:
+                if len(mCount) == 0:
                     mCount.append(0)
                 else:
                     mCount.append(len(p.modules)+mCount[len(mCount)-1])
@@ -1377,10 +1412,10 @@ def moduleExecuted(objId):
             _app.notify('execution_updated')
             return errors
 
+
 ################################################################################
 # Testing
 
-
 class TestVistrailController(vistrails.gui.utils.TestVisTrailsGUI):
 
     # def test_add_module(self):
@@ -1399,9 +1434,10 @@ def test_create_functions(self):
                                         pipeline_view=DummyView(),
                                         auto_save=False)
         controller.change_selected_version(0L)
-        module = controller.add_module(0.0,0.0, 
-                        vistrails.core.system.get_vistrails_basic_pkg_id(), 
-                        'ConcatenateString')
+        module = controller.add_module(
+                vistrails.core.system.get_vistrails_basic_pkg_id(),
+                'ConcatenateString',
+                0.0, 0.0)
         functions = [('str1', ['foo'], -1, True),
                      ('str2', ['bar'], -1, True)]
         controller.update_functions(module, functions)
diff --git a/vistrails/gui/vistrail_view.py b/vistrails/gui/vistrail_view.py
index 4ea2d8226..cd39e239c 100644
--- a/vistrails/gui/vistrail_view.py
+++ b/vistrails/gui/vistrail_view.py
@@ -243,7 +243,10 @@ def reset_tab_view_to_current(self):
         view = self.stack.widget(self.tab_to_stack_idx[index])
         #print "view changed: ", view
         self.set_to_current(view)
-         
+
+    def showEvent(self, event):
+        self.stack.currentWidget().viewSelected()
+
     def pipeline_selected(self):
         from vistrails.gui.vistrails_window import _app
         if hasattr(self.window(), 'qactions'):
@@ -257,6 +260,7 @@ def pipeline_selected(self):
                              self.stack.currentWidget().get_title())
         self.tab_state[self.tabs.currentIndex()] = window.qactions['pipeline']
         self.tab_to_view[self.tabs.currentIndex()] = self.get_current_tab()
+        self.stack.currentWidget().viewSelected()
 
     def pipeline_unselected(self):
         #print "PIPELINE UN"
@@ -279,6 +283,7 @@ def history_selected(self):
         self.tabs.setTabText(self.tabs.currentIndex(), "History")
         self.tab_state[self.tabs.currentIndex()] = window.qactions['history']
         self.tab_to_view[self.tabs.currentIndex()] = self.get_current_tab()
+        self.stack.currentWidget().viewSelected()
 
     def history_unselected(self):
         #print "VERSION UN"
diff --git a/vistrails/gui/vistrails_window.py b/vistrails/gui/vistrails_window.py
index 888be87a3..d93578c55 100644
--- a/vistrails/gui/vistrails_window.py
+++ b/vistrails/gui/vistrails_window.py
@@ -1582,7 +1582,6 @@ def add_vistrail(self, *objs):
         self.view_changed(view)
         self.reset_toolbar_for_view(view)
         self.qactions['history'].trigger()
-        view.version_view.zoomToFit()
         return view.controller
 
     def remove_vistrail(self, locator):
diff --git a/vistrails/packages/CLTools/init.py b/vistrails/packages/CLTools/init.py
index ed3f3707b..40ca5dfe1 100644
--- a/vistrails/packages/CLTools/init.py
+++ b/vistrails/packages/CLTools/init.py
@@ -439,6 +439,9 @@ def remove_all_scripts():
 def reload_scripts(initial=False, name=None):
     reg = vistrails.core.modules.module_registry.get_module_registry()
     if not initial:
+        from vistrails.core.interpreter.cached import CachedInterpreter
+        CachedInterpreter.clear_package(identifiers.identifier)
+
         if name is None:
             remove_all_scripts()
         else:
@@ -476,9 +479,6 @@ def reload_scripts(initial=False, name=None):
             add_tool(path)
 
     if not initial:
-        from vistrails.core.interpreter.cached import CachedInterpreter
-        CachedInterpreter.clear_package(identifiers.identifier)
-
         from vistrails.gui.vistrails_window import _app
         _app.invalidate_pipelines()
 
diff --git a/vistrails/packages/SUDSWebServices/init.py b/vistrails/packages/SUDSWebServices/init.py
index 3bed15d0a..bca6d9a69 100644
--- a/vistrails/packages/SUDSWebServices/init.py
+++ b/vistrails/packages/SUDSWebServices/init.py
@@ -727,13 +727,8 @@ def handle_module_upgrade_request(controller, module_id, pipeline):
                                                     namespace)
         if not new_descriptor:
             return []
-        try:
-            return UpgradeWorkflowHandler.replace_module(controller, pipeline,
-                                                    module_id, new_descriptor)
-        except Exception, e:
-            import traceback
-            traceback.print_exc()
-            raise
+        return UpgradeWorkflowHandler.replace_module(controller, pipeline,
+                                                module_id, new_descriptor)
 
     return UpgradeWorkflowHandler.attempt_automatic_upgrade(controller, 
                                                             pipeline,
diff --git a/vistrails/packages/matplotlib/figure_cell.py b/vistrails/packages/matplotlib/figure_cell.py
index 593c076b8..53c426cd7 100644
--- a/vistrails/packages/matplotlib/figure_cell.py
+++ b/vistrails/packages/matplotlib/figure_cell.py
@@ -126,11 +126,9 @@ def updateContents(self, inputPorts):
             self.layout().addWidget(self.canvas)
 
     def keyPressEvent(self, event):
-        print "KEY PRESS:",  event.key()
         self.canvas.keyPressEvent(event)
 
     def keyReleaseEvent(self, event):
-        print "KEY RELEASE:", event.key()
         self.canvas.keyReleaseEvent(event)
 
     def deleteLater(self):
@@ -140,8 +138,6 @@ def deleteLater(self):
         """
         # Destroy the old one if possible
         if self.figure is not None:
-            print "pylab:", pylab
-            print "self.figure:", self.figure
             pylab.close(self.figure)
 
         QCellWidget.deleteLater(self)
@@ -219,11 +215,8 @@ def createToolBar(self):
                 exclusive_actions[text] = action
 
         def get_callback(act, cb, txt):
-            print "CONSTRUCTING CALLBACK!", act, cb, txt
             def callback():
-                print "GOT CALLBACK!!"
                 cellWidget = act.toolBar.getSnappedWidget()
-                print "CALLING callback", cb
                 getattr(cellWidget.mplToolbar, cb)()
                 if txt in exclusive_actions:
                     for t, a in exclusive_actions.iteritems():
diff --git a/vistrails/packages/spreadsheet/init.py b/vistrails/packages/spreadsheet/init.py
index dc7d63bf5..47726e1bd 100644
--- a/vistrails/packages/spreadsheet/init.py
+++ b/vistrails/packages/spreadsheet/init.py
@@ -129,15 +129,6 @@ def initialize(*args, **keywords):
         basicWidgets = addWidget('vistrails.packages.spreadsheet.basic_widgets')
     importWidgetModules(basicWidgets)
 
-    # Create application if there is no one available
-    global app
-    app = QtCore.QCoreApplication.instance()
-    if app==None:
-        app = QtGui.QApplication(sys.argv)
-    if hasattr(app, 'builderWindow'):
-        global spreadsheetWindow
-        spreadsheetWindow = spreadsheetController.findSpreadsheetWindow(show=False)
-
 
 def menu_items():
     """menu_items() -> tuple of (str,function)
@@ -146,6 +137,7 @@ def menu_items():
 
     """
     def show_spreadsheet():
+        spreadsheetWindow = spreadsheetController.findSpreadsheetWindow()
         spreadsheetWindow.show()
         spreadsheetWindow.activateWindow()
         spreadsheetWindow.raise_()
diff --git a/vistrails/packages/spreadsheet/spreadsheet_cell.py b/vistrails/packages/spreadsheet/spreadsheet_cell.py
index 7c6969092..e2674429d 100644
--- a/vistrails/packages/spreadsheet/spreadsheet_cell.py
+++ b/vistrails/packages/spreadsheet/spreadsheet_cell.py
@@ -1290,11 +1290,21 @@ def mousePressEvent(self, event):
         self.startPos = QtCore.QPoint(event.pos())
         QtGui.QLabel.mousePressEvent(self, event)
 
+    def mouseReleaseEvent(self, event):
+        """ mouseReleaseEvent(event: QMouseEvent) -> None
+        Note that dragging ended
+
+        """
+        self.startPos = None
+
     def mouseMoveEvent(self, event):
         """ mouseMoveEvent(event: QMouseEvent) -> None
         Prepare to drag
 
         """
+        if self.startPos is None:
+            return
+
         p = event.pos() - self.startPos
         if p.manhattanLength()>=QtGui.QApplication.startDragDistance():
             drag = QtGui.QDrag(self)
diff --git a/vistrails/packages/spreadsheet/spreadsheet_tab.py b/vistrails/packages/spreadsheet/spreadsheet_tab.py
index 7cb0a7d90..bc9a6d5d4 100644
--- a/vistrails/packages/spreadsheet/spreadsheet_tab.py
+++ b/vistrails/packages/spreadsheet/spreadsheet_tab.py
@@ -335,8 +335,6 @@ def setCellPipelineInfo(self, row, col, info):
         information, info, for the cell (row, col)
 
         """
-        if not (row,col) in self.pipelineInfo:
-            self.pipelineInfo[(row,col)] = {}
         self.pipelineInfo[(row,col)] = info
 
     def getCellPipelineInfo(self, row, col):
@@ -345,9 +343,7 @@ def getCellPipelineInfo(self, row, col):
         information, info, for the cell (row, col)
 
         """
-        if not (row,col) in self.pipelineInfo:
-            return None
-        return self.pipelineInfo[(row,col)]
+        return self.pipelineInfo.get((row, col), None)
 
     def getSelectedLocations(self):
         """ getSelectedLocations() -> list
@@ -654,7 +650,9 @@ def setDimension(self, rc, cc):
 
         """
         self.toolBar.rowCountSpinBox().setValue(rc)
+        self.rowSpinBoxChanged()
         self.toolBar.colCountSpinBox().setValue(cc)
+        self.colSpinBoxChanged()
 
     def getCellWidget(self, row, col):
         """ getCellWidget(row: int, col: int) -> QWidget
diff --git a/vistrails/packages/spreadsheet/spreadsheet_tabcontroller.py b/vistrails/packages/spreadsheet/spreadsheet_tabcontroller.py
index 2e9cc1bb7..8422dc416 100644
--- a/vistrails/packages/spreadsheet/spreadsheet_tabcontroller.py
+++ b/vistrails/packages/spreadsheet/spreadsheet_tabcontroller.py
@@ -117,10 +117,7 @@ def getMonitoredLocations(self, spec):
 
         """
         key = ((spec[0]['locator'], spec[0]['version']), spec[1], spec[2])
-        if key in self.monitoredPipelines:
-            return self.monitoredPipelines[key]
-        else:
-            return []
+        return self.monitoredPipelines.get(key, [])
 
     def appendMonitoredLocations(self, spec, value):
         """ getMonitoredLocations(spec: tuple, value: location) -> None
diff --git a/vistrails/packages/webServices/init.py b/vistrails/packages/webServices/init.py
index 7dd4dc10c..1cc69276d 100644
--- a/vistrails/packages/webServices/init.py
+++ b/vistrails/packages/webServices/init.py
@@ -1484,35 +1484,30 @@ def get_wsdl_from_namespace(m_namespace):
             except:
                 print "Error loading configuration file"
                 return False
-        try:
-            (res,not_loaded) = load_wsdl_no_config(updated_list)
-            #print "done loading_no_config"
-            if not res:
-                outdated_list.extend([wsdl])
-        
-            (res, not_loaded) = load_wsdl_with_config(outdated_list)
-            #print "done loading_with_config"
-            if res:
-                #add new url to package config file
-                wsdlList = []
-                if configuration.check('wsdlList'):
-                    wsdlList = configuration.wsdlList.split(";")
-                if wsdl not in wsdlList:
-                    wsdlList.append(wsdl)    
-                swsdlList = ";".join(wsdlList)
-                configuration.wsdlList = swsdlList
-                print "done."
-                return True
-            else:
-                msg = """ There were problems loading the webservice.
+        (res,not_loaded) = load_wsdl_no_config(updated_list)
+        #print "done loading_no_config"
+        if not res:
+            outdated_list.extend([wsdl])
+
+        (res, not_loaded) = load_wsdl_with_config(outdated_list)
+        #print "done loading_with_config"
+        if res:
+            #add new url to package config file
+            wsdlList = []
+            if configuration.check('wsdlList'):
+                wsdlList = configuration.wsdlList.split(";")
+            if wsdl not in wsdlList:
+                wsdlList.append(wsdl)
+            swsdlList = ";".join(wsdlList)
+            configuration.wsdlList = swsdlList
+            print "done."
+            return True
+        else:
+            msg = """ There were problems loading the webservice.
 The following could not be loaded:\n"""
-                error_list.extend(not_loaded)
-                for (w,e) in error_list:
-                    msg += "Url: '%s', error: '%s'\n"%(w,e)
-                    pm.show_error_message(pm.get_package(identifier),msg)
-        except Exception, e:
-            print e
-            import traceback
-            traceback.print_stack()
+            error_list.extend(not_loaded)
+            for (w,e) in error_list:
+                msg += "Url: '%s', error: '%s'\n"%(w,e)
+                pm.show_error_message(pm.get_package(identifier),msg)
     print "An error occurred. Could not add missing wsdl."
     return False
diff --git a/vistrails/run.py b/vistrails/run.py
index 4f60a0ea9..d7bc9418d 100644
--- a/vistrails/run.py
+++ b/vistrails/run.py
@@ -61,23 +61,6 @@
         sys.stderr.write("Couldn't import VISTRAILS_USERPACKAGES_DIR (%s), "
                          "continuing\n" % userpackages_dir)
 
-def disable_lion_restore():
-    """ Prevent Mac OS 10.7 to restore windows state since it would
-    make Qt 4.7.3 unstable due to its lack of handling Cocoa's Main
-    Window. """
-    import platform
-    if platform.system()!='Darwin': return
-    release = platform.mac_ver()[0].split('.')
-    if len(release)<2: return
-    major = int(release[0])
-    minor = int(release[1])
-    if major*100+minor<107: return
-    ssPath = os.path.expanduser('~/Library/Saved Application State/org.vistrails.savedState')
-    if os.path.exists(ssPath):
-        os.system('rm -rf "%s"' % ssPath)
-    os.system('defaults write org.vistrails NSQuitAlwaysKeepsWindows -bool false')
-
-
 def fix_site():
     # py2app ships a stripped version of site.py
     # USER_BASE and USER_SITE is not set,
@@ -115,7 +98,6 @@ def fix_paths():
 
 def main():
     fix_paths()
-    disable_lion_restore()
     fix_site()
 
     # Load the default locale (from environment)
diff --git a/vistrails/tests/runtestsuite.py b/vistrails/tests/runtestsuite.py
index 7db89925d..3e0e673a1 100755
--- a/vistrails/tests/runtestsuite.py
+++ b/vistrails/tests/runtestsuite.py
@@ -402,7 +402,7 @@ def module_filter(name):
         if suite.countTestCases() == 0 and verbose >= 1:
             print >>sys.stderr, "WARNING: module has no tests: %s" % module
         elif verbose >= 2:
-            print >>sys.stderr, "OK: module as %d test cases: %s" % (
+            print >>sys.stderr, "OK: module has %d test cases: %s" % (
                     suite.countTestCases(),
                     module)
 
