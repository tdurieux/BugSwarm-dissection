diff --git a/src/edu/washington/escience/myria/accessmethod/AccessMethod.java b/src/edu/washington/escience/myria/accessmethod/AccessMethod.java
index fd3f2106b..681eb9f0a 100644
--- a/src/edu/washington/escience/myria/accessmethod/AccessMethod.java
+++ b/src/edu/washington/escience/myria/accessmethod/AccessMethod.java
@@ -153,6 +153,12 @@ public void init() throws DbException {
    */
   public abstract void dropTableIfExists(RelationKey relationKey) throws DbException;
 
+  /**
+   * @param relationKey the relation to drop
+   * @throws DbException if there is an error dropping the table.
+   */
+  public abstract void dropTableIfExistsCascade(RelationKey relationKey) throws DbException;
+
   /**
    * Creates the specified indexes on the provided temporary table, but uses the real table name for their names.
    * 
diff --git a/src/edu/washington/escience/myria/accessmethod/JdbcAccessMethod.java b/src/edu/washington/escience/myria/accessmethod/JdbcAccessMethod.java
index 2a7dc021c..fed140616 100644
--- a/src/edu/washington/escience/myria/accessmethod/JdbcAccessMethod.java
+++ b/src/edu/washington/escience/myria/accessmethod/JdbcAccessMethod.java
@@ -424,6 +424,22 @@ public void dropAndRenameTables(final RelationKey oldRelation, final RelationKey
     }
   }
 
+  @Override
+  public void dropTableIfExistsCascade(final RelationKey relationKey) throws DbException {
+    switch (jdbcInfo.getDbms()) {
+      case MyriaConstants.STORAGE_SYSTEM_MYSQL:
+        LOGGER.warn("MySQL does not implement CASCADE");
+        execute("DROP TABLE IF EXISTS " + quote(relationKey));
+        break;
+      case MyriaConstants.STORAGE_SYSTEM_POSTGRESQL:
+        execute("DROP TABLE IF EXISTS " + quote(relationKey) + " CASCADE");
+        break;
+      default:
+        throw new UnsupportedOperationException("Don't know whether " + jdbcInfo.getDbms()
+            + " can DROP IF EXISTS a table");
+    }
+  }
+
   @Override
   public void dropTableIfExists(final RelationKey relationKey) throws DbException {
     switch (jdbcInfo.getDbms()) {
diff --git a/src/edu/washington/escience/myria/accessmethod/SQLiteAccessMethod.java b/src/edu/washington/escience/myria/accessmethod/SQLiteAccessMethod.java
index 184906d6a..86e95702c 100644
--- a/src/edu/washington/escience/myria/accessmethod/SQLiteAccessMethod.java
+++ b/src/edu/washington/escience/myria/accessmethod/SQLiteAccessMethod.java
@@ -400,6 +400,11 @@ public void dropTableIfExists(final RelationKey relationKey) throws DbException
     execute("DROP TABLE IF EXISTS " + relationKey.toString(MyriaConstants.STORAGE_SYSTEM_SQLITE));
   }
 
+  @Override
+  public void dropTableIfExistsCascade(final RelationKey relationKey) throws DbException {
+    execute("DROP TABLE IF EXISTS " + relationKey.toString(MyriaConstants.STORAGE_SYSTEM_SQLITE));
+  }
+
   @Override
   public void createIndexes(final RelationKey relationKey, final Schema schema, final List<List<IndexRef>> indexes)
       throws DbException {
diff --git a/src/edu/washington/escience/myria/api/DatasetResource.java b/src/edu/washington/escience/myria/api/DatasetResource.java
index 928bba4c0..88ccd28c6 100644
--- a/src/edu/washington/escience/myria/api/DatasetResource.java
+++ b/src/edu/washington/escience/myria/api/DatasetResource.java
@@ -10,6 +10,7 @@
 
 import javax.annotation.Nonnull;
 import javax.ws.rs.Consumes;
+import javax.ws.rs.DELETE;
 import javax.ws.rs.GET;
 import javax.ws.rs.POST;
 import javax.ws.rs.PUT;
@@ -337,6 +338,33 @@ public Response replaceDataset(final InputStream is, @PathParam("userName") fina
     return doIngest(relationKey, source, howPartitioned.getWorkers(), null, true, builder, pf);
   }
 
+  /**
+   * @param userName the user who owns the target relation.
+   * @param programName the program to which the target relation belongs.
+   * @param relationName the name of the target relation.
+   * @return metadata
+   * @throws DbException if there is an error in the database.
+   */
+  @DELETE
+  @Path("/user-{userName}/program-{programName}/relation-{relationName}/")
+  public Response deleteDataset(@PathParam("userName") final String userName,
+      @PathParam("programName") final String programName, @PathParam("relationName") final String relationName)
+      throws DbException {
+    DatasetStatus status = server.getDatasetStatus(RelationKey.of(userName, programName, relationName));
+    if (status == null) {
+      /* Dataset not found, throw a 404 (Not Found) */
+      throw new MyriaApiException(Status.NOT_FOUND, "That dataset was not found");
+    }
+    RelationKey relationKey = status.getRelationKey();
+    // delete command
+    try {
+      status = server.deleteDataset(relationKey);
+    } catch (Exception e) {
+      throw new DbException();
+    }
+    return Response.noContent().build();
+  }
+
   /**
    * @param dataset the dataset to be ingested.
    * @return the created dataset resource.
diff --git a/src/edu/washington/escience/myria/coordinator/catalog/MasterCatalog.java b/src/edu/washington/escience/myria/coordinator/catalog/MasterCatalog.java
index ca1377b39..13062851d 100644
--- a/src/edu/washington/escience/myria/coordinator/catalog/MasterCatalog.java
+++ b/src/edu/washington/escience/myria/coordinator/catalog/MasterCatalog.java
@@ -1790,6 +1790,9 @@ protected Long job(final SQLiteConnection sqliteConnection) throws CatalogExcept
         }
       }).get();
     } catch (InterruptedException | ExecutionException e) {
+      if (e instanceof InterruptedException) {
+        Thread.currentThread().interrupt();
+      }
       throw new CatalogException(e);
     }
   }
@@ -1817,6 +1820,41 @@ private void deleteRelationIfExists(@Nonnull final SQLiteConnection sqliteConnec
     }
   }
 
+  /**
+   * Connects to SQLite to delete relation from the catalog if it exists.
+   * 
+   * @param relationKey the relation to be deleted from the catalog.
+   * @throws CatalogException if there is an error in the catalog.
+   */
+  public void deleteRelationFromCatalog(final RelationKey relationKey) throws CatalogException {
+    if (isClosed) {
+      throw new CatalogException("Catalog is closed.");
+    }
+    /* Do the work */
+    try {
+      queue.execute(new SQLiteJob<Void>() {
+        @Override
+        protected Void job(final SQLiteConnection sqliteConnection) throws CatalogException, SQLiteException {
+          sqliteConnection.exec("BEGIN TRANSACTION;");
+          try {
+            deleteRelationIfExists(sqliteConnection, relationKey);
+            sqliteConnection.exec("COMMIT TRANSACTION;");
+          } catch (SQLiteException e) {
+            try {
+              sqliteConnection.exec("ROLLBACK TRANSACTION;");
+            } catch (SQLiteException e2) {
+              assert true; /* Do nothing */
+            }
+            throw e;
+          }
+          return null;
+        }
+      }).get();
+    } catch (InterruptedException | ExecutionException e) {
+      throw new CatalogException(e);
+    }
+  }
+
   /**
    * Add the metadata for one or more relations to the catalog.
    * 
diff --git a/src/edu/washington/escience/myria/operator/DbDelete.java b/src/edu/washington/escience/myria/operator/DbDelete.java
new file mode 100644
index 000000000..9b9421d78
--- /dev/null
+++ b/src/edu/washington/escience/myria/operator/DbDelete.java
@@ -0,0 +1,74 @@
+/**
+ *
+ */
+package edu.washington.escience.myria.operator;
+
+import com.google.common.collect.ImmutableMap;
+
+import edu.washington.escience.myria.DbException;
+import edu.washington.escience.myria.MyriaConstants;
+import edu.washington.escience.myria.RelationKey;
+import edu.washington.escience.myria.accessmethod.AccessMethod;
+import edu.washington.escience.myria.accessmethod.ConnectionInfo;
+import edu.washington.escience.myria.storage.TupleBatch;
+
+/**
+ * 
+ */
+public class DbDelete extends RootOperator {
+
+  /** The connection to the database database. */
+  private AccessMethod accessMethod;
+  /** The information for the database connection. */
+  private ConnectionInfo connectionInfo;
+  /** The name of the table the tuples should be inserted into. */
+  private final RelationKey relationKey;
+
+  /**
+   * @param child the source of tuples to be inserted.
+   * @param relationKey the key of the table the tuples should be inserted into.
+   * @param connectionInfo the parameters of the database connection.
+   */
+  public DbDelete(final Operator child, final RelationKey relationKey, final ConnectionInfo connectionInfo) {
+    super(child);
+    this.connectionInfo = connectionInfo;
+    this.relationKey = relationKey;
+  }
+
+  @Override
+  protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException {
+    /* Retrieve connection information from the environment variables, if not already set */
+    if (connectionInfo == null && execEnvVars != null) {
+      connectionInfo = (ConnectionInfo) execEnvVars.get(MyriaConstants.EXEC_ENV_VAR_DATABASE_CONN_INFO);
+    }
+    /* Open the database connection */
+    accessMethod = AccessMethod.of(connectionInfo.getDbms(), connectionInfo, false);
+
+    /* Drop the table */
+    accessMethod.dropTableIfExistsCascade(relationKey);
+  }
+
+  @Override
+  public void cleanup() {
+    try {
+      if (accessMethod != null) {
+        accessMethod.close();
+      }
+    } catch (DbException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @Override
+  protected void consumeTuples(final TupleBatch tuples) throws DbException {
+  }
+
+  @Override
+  protected void childEOS() throws DbException {
+  }
+
+  @Override
+  protected void childEOI() throws DbException {
+  }
+
+}
diff --git a/src/edu/washington/escience/myria/parallel/Server.java b/src/edu/washington/escience/myria/parallel/Server.java
index d769dd3f4..ce652a379 100644
--- a/src/edu/washington/escience/myria/parallel/Server.java
+++ b/src/edu/washington/escience/myria/parallel/Server.java
@@ -67,6 +67,7 @@
 import edu.washington.escience.myria.expression.WorkerIdExpression;
 import edu.washington.escience.myria.operator.Apply;
 import edu.washington.escience.myria.operator.DataOutput;
+import edu.washington.escience.myria.operator.DbDelete;
 import edu.washington.escience.myria.operator.DbInsert;
 import edu.washington.escience.myria.operator.DbQueryScan;
 import edu.washington.escience.myria.operator.DuplicateTBGenerator;
@@ -1035,6 +1036,45 @@ public void importDataset(final RelationKey relationKey, final Schema schema, fi
     }
   }
 
+  /**
+   * @param relationKey the relationKey of the dataset to delete
+   * @return the status
+   * @throws DbException if there is an error
+   * @throws InterruptedException interrupted
+   */
+  public DatasetStatus deleteDataset(final RelationKey relationKey) throws DbException, InterruptedException {
+
+    /* Delete from postgres at each worker by calling the DbDelete operator */
+    try {
+      Map<Integer, SubQueryPlan> workerPlans = new HashMap<>();
+      for (Integer workerId : getWorkersForRelation(relationKey, null)) {
+        workerPlans.put(workerId, new SubQueryPlan(new DbDelete(EmptyRelation.of(catalog.getSchema(relationKey)),
+            relationKey, null)));
+      }
+      ListenableFuture<Query> qf =
+          queryManager.submitQuery("delete " + relationKey.toString(), "delete " + relationKey.toString(),
+              "deleting from " + relationKey.toString(getDBMS()), new SubQueryPlan(new SinkRoot(new EOSSource())),
+              workerPlans);
+      try {
+        qf.get();
+      } catch (ExecutionException e) {
+        throw new DbException("Error executing query", e.getCause());
+      }
+    } catch (CatalogException e) {
+      throw new DbException(e);
+    }
+
+    /* Deleting from the catalog */
+    try {
+      catalog.deleteRelationFromCatalog(relationKey);
+    } catch (CatalogException e) {
+      throw new DbException(e);
+    }
+
+    return getDatasetStatus(relationKey);
+
+  }
+
   /**
    * @param relationKey the key of the desired relation.
    * @return the schema of the specified relation, or null if not found.
diff --git a/src/edu/washington/escience/myria/util/JsonAPIUtils.java b/src/edu/washington/escience/myria/util/JsonAPIUtils.java
index ba2c8b8c0..3994afeb6 100644
--- a/src/edu/washington/escience/myria/util/JsonAPIUtils.java
+++ b/src/edu/washington/escience/myria/util/JsonAPIUtils.java
@@ -179,4 +179,28 @@ public static HttpURLConnection ingestData(final String masterHostname, final in
     conn.getResponseCode();
     return conn;
   }
+
+  /**
+   * @param masterHostname master hostname
+   * @param apiPort rest api port
+   * @param user user parameter of the dataset
+   * @param program program parameter of the dataset
+   * @param relation relation parameter of the dataset
+   * @return a HTTPURLConnection instance of retrieving responses.
+   * @throws IOException if IO errors
+   * */
+  public static HttpURLConnection deleteDataset(final String masterHostname, final int apiPort, final String user,
+      final String program, final String relation) throws IOException {
+    String type = "application/json";
+    URL u =
+        new URL(String.format("http://%s:%d/dataset/user-%s/program-%s/relation-%s/", masterHostname, apiPort, user,
+            program, relation));
+    HttpURLConnection conn = (HttpURLConnection) u.openConnection();
+    conn.setRequestMethod("DELETE");
+    conn.setRequestProperty("Content-Type", type);
+    conn.connect();
+    conn.getResponseCode();
+    conn.disconnect();
+    return conn;
+  }
 }
diff --git a/src/edu/washington/escience/myria/util/SQLiteUtils.java b/src/edu/washington/escience/myria/util/SQLiteUtils.java
index 2e5a6932b..61cf85eae 100644
--- a/src/edu/washington/escience/myria/util/SQLiteUtils.java
+++ b/src/edu/washington/escience/myria/util/SQLiteUtils.java
@@ -119,4 +119,81 @@ public static void createTable(final String dbFileAbsolutePath, final RelationKe
       }
     }
   }
+
+  /**
+   * Deletes a relation in SQLite.
+   * 
+   * @throws SQLiteException if SQLite error occur
+   * @param dbFileAbsolutePath the SQLite file absolute path
+   * @param relationKey the relation key to delete
+   * */
+  public static void deleteTable(final String dbFileAbsolutePath, final RelationKey relationKey) throws IOException,
+      SQLiteException {
+    SQLiteConnection sqliteConnection = null;
+    SQLiteStatement statement = null;
+    try {
+      final File f = new File(dbFileAbsolutePath);
+
+      if (!f.getParentFile().exists()) {
+        f.getParentFile().mkdirs();
+      }
+
+      /* Connect to the database */
+      sqliteConnection = new SQLiteConnection(f);
+      sqliteConnection.open(true);
+
+      statement =
+          sqliteConnection
+              .prepare("drop table if exists " + relationKey.toString(MyriaConstants.STORAGE_SYSTEM_SQLITE));
+      statement.step();
+
+    } finally {
+      if (statement != null) {
+        statement.dispose();
+      }
+      if (sqliteConnection != null) {
+        sqliteConnection.dispose();
+      }
+    }
+  }
+
+  /**
+   * Checks if a relation exists in the SQLite database
+   * 
+   * @throws SQLiteException if SQLite error occur
+   * @param dbFileAbsolutePath the SQLite file absolute path
+   * @param relationKey the relation key to check
+   * */
+  public static boolean existsTable(final String dbFileAbsolutePath, final RelationKey relationKey) throws IOException,
+      SQLiteException {
+    boolean exists = false;
+    SQLiteConnection sqliteConnection = null;
+    SQLiteStatement statement = null;
+    try {
+      final File f = new File(dbFileAbsolutePath);
+
+      if (!f.getParentFile().exists()) {
+        f.getParentFile().mkdirs();
+      }
+
+      /* Connect to the database */
+      sqliteConnection = new SQLiteConnection(f);
+      sqliteConnection.open(true);
+      statement =
+          sqliteConnection.prepare("SELECT * FROM sqlite_master WHERE type='table' AND name="
+              + relationKey.toString(MyriaConstants.STORAGE_SYSTEM_SQLITE));
+      if (statement.step()) {
+        return true;
+      }
+
+    } finally {
+      if (statement != null) {
+        statement.dispose();
+      }
+      if (sqliteConnection != null) {
+        sqliteConnection.dispose();
+      }
+    }
+    return exists;
+  }
 }
diff --git a/systemtest/edu/washington/escience/myria/systemtest/DbDeleteTest.java b/systemtest/edu/washington/escience/myria/systemtest/DbDeleteTest.java
new file mode 100644
index 000000000..00c83a6ef
--- /dev/null
+++ b/systemtest/edu/washington/escience/myria/systemtest/DbDeleteTest.java
@@ -0,0 +1,105 @@
+/**
+ *
+ */
+package edu.washington.escience.myria.systemtest;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.nio.file.Paths;
+import java.util.Set;
+
+import org.junit.Test;
+
+import com.google.common.collect.ImmutableList;
+
+import edu.washington.escience.myria.RelationKey;
+import edu.washington.escience.myria.Schema;
+import edu.washington.escience.myria.Type;
+import edu.washington.escience.myria.io.DataSource;
+import edu.washington.escience.myria.io.FileSource;
+import edu.washington.escience.myria.operator.TupleSource;
+import edu.washington.escience.myria.operator.network.partition.RoundRobinPartitionFunction;
+import edu.washington.escience.myria.util.JsonAPIUtils;
+
+/**
+ * Test DbDelete Operator
+ * 
+ * This test performs a DbDelete under two different scenarios:
+ * 
+ * testDeleteRelationInCatalog(): This tests whether the Catalog deletes the relation after calling deleteDataset() from
+ * the server
+ * 
+ * testDeleteNonExistentRelation(): This tests whether deleteDataset() is able to delete the tables from the underlying
+ * database even if it does not exist in all workers expressed by the Catalog.
+ * 
+ */
+public class DbDeleteTest extends SystemTestBase {
+  /**
+   * Source of tuples
+   */
+  TupleSource relationSource;
+
+  /**
+   * The relation to ingest
+   */
+  RelationKey relationKey;
+
+  /**
+   * Schema of the ingested relation
+   */
+  Schema relationSchema;
+
+  /**
+   * Tests if the relation has been deleted from the Catalog successfully.
+   * 
+   * @throws Exception
+   */
+  @Test
+  public void testDeleteRelationInCatalog() throws Exception {
+    ingestTestDataset();
+
+    Set<Integer> workers = server.getWorkersForRelation(relationKey, null);
+    assertTrue(workers.size() == workerIDs.length);
+
+    JsonAPIUtils.deleteDataset("localhost", masterDaemonPort, relationKey.getUserName(), relationKey.getProgramName(),
+        relationKey.getRelationName());
+
+    workers = server.getWorkersForRelation(relationKey, null);
+    assertTrue(workers == null);
+  }
+
+  /**
+   * Tests if the relation has been deleted successfully from the underlying databases on all the workers even if a
+   * worker does not contain the dataset to begin with.
+   * 
+   * @throws Exception
+   */
+  @Test
+  public void testDeleteNonExistentRelation() throws Exception {
+    ingestTestDataset();
+
+    /* delete relation in one worker only */
+    deleteTable(workerIDs[0], relationKey);
+
+    assertFalse(existsTable(workerIDs[0], relationKey));
+    assertTrue(existsTable(workerIDs[1], relationKey));
+
+    JsonAPIUtils.deleteDataset("localhost", masterDaemonPort, relationKey.getUserName(), relationKey.getProgramName(),
+        relationKey.getRelationName());
+
+    assertFalse(existsTable(workerIDs[0], relationKey));
+    assertFalse(existsTable(workerIDs[1], relationKey));
+  }
+
+  /**
+   * Ingest a test dataset.
+   */
+  public void ingestTestDataset() throws Exception {
+    DataSource relationSource = new FileSource(Paths.get("testdata", "filescan", "simple_two_col_int.txt").toString());
+    relationKey = RelationKey.of("public", "adhoc", "testIngest");
+    relationSchema = Schema.of(ImmutableList.of(Type.INT_TYPE, Type.INT_TYPE), ImmutableList.of("x", "y"));
+    JsonAPIUtils.ingestData("localhost", masterDaemonPort, ingest(relationKey, relationSchema, relationSource, ' ',
+        new RoundRobinPartitionFunction(workerIDs.length)));
+  }
+}
diff --git a/systemtest/edu/washington/escience/myria/systemtest/SystemTestBase.java b/systemtest/edu/washington/escience/myria/systemtest/SystemTestBase.java
index 028a2dff0..c9e02fdca 100644
--- a/systemtest/edu/washington/escience/myria/systemtest/SystemTestBase.java
+++ b/systemtest/edu/washington/escience/myria/systemtest/SystemTestBase.java
@@ -143,6 +143,24 @@ public static void createTable(final int workerID, final RelationKey relationKey
     }
   }
 
+  public static void deleteTable(final int workerID, final RelationKey relationKey) throws IOException,
+      CatalogException {
+    try {
+      SQLiteUtils.deleteTable(getAbsoluteDBFile(workerID).getAbsolutePath(), relationKey);
+    } catch (SQLiteException e) {
+      throw new CatalogException(e);
+    }
+  }
+
+  public static boolean existsTable(final int workerID, final RelationKey relationKey) throws IOException,
+      CatalogException {
+    try {
+      return SQLiteUtils.existsTable(getAbsoluteDBFile(workerID).getAbsolutePath(), relationKey);
+    } catch (SQLiteException e) {
+      throw new CatalogException(e);
+    }
+  }
+
   public static File getAbsoluteDBFile(final int workerID) throws CatalogException, FileNotFoundException {
     final String workerDir = getWorkerFolder(workerID);
     final WorkerCatalog wc = WorkerCatalog.open(FilenameUtils.concat(workerDir, "worker.catalog"));
