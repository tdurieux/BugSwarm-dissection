diff --git a/netCDF4/_netCDF4.c b/netCDF4/_netCDF4.c
index 0aec3e4cd9..d4d94becb3 100755
--- a/netCDF4/_netCDF4.c
+++ b/netCDF4/_netCDF4.c
@@ -1878,9 +1878,9 @@ static char __pyx_k_Class_for_reading_multi_file_ne[] = "\nClass for reading mul
 static char __pyx_k_Class_providing_an_interface_to[] = "\nClass providing an interface to a MFDataset time Variable by imposing a unique common\ntime unit to all files. \n\nExample usage (See `netCDF4.MFTime.__init__` for more details):\n\n    :::python\n    >>> import numpy\n    >>> f1 = Dataset(\"mftest_1.nc\",\"w\", format=\"NETCDF4_CLASSIC\")\n    >>> f2 = Dataset(\"mftest_2.nc\",\"w\", format=\"NETCDF4_CLASSIC\")\n    >>> f1.createDimension(\"time\",None)\n    >>> f2.createDimension(\"time\",None)\n    >>> t1 = f1.createVariable(\"time\",\"i\",(\"time\",))\n    >>> t2 = f2.createVariable(\"time\",\"i\",(\"time\",))\n    >>> t1.units = \"days since 2000-01-01\"\n    >>> t2.units = \"days since 2000-02-01\"\n    >>> t1.calendar = \"standard\"\n    >>> t2.calendar = \"standard\"\n    >>> t1[:] = numpy.arange(31)\n    >>> t2[:] = numpy.arange(30)\n    >>> f1.close()\n    >>> f2.close()\n    >>> # Read the two files in at once, in one Dataset.\n    >>> f = MFDataset(\"mftest*nc\")\n    >>> t = f.variables[\"time\"]\n    >>> print t.units\n    days since 2000-01-01\n    >>> print t[32] # The value written in the file, inconsistent with the MF time units.\n    1\n    >>> T = MFTime(t)\n    >>> print T[32]\n    32\n    ";
 static char __pyx_k_FillValue_attribute_must_be_set[] = "_FillValue attribute must be set when variable is ";
 static char __pyx_k_The_vltypes_dictionary_maps_the[] = "The `vltypes` dictionary maps the names of\n    variable-length types defined for the `netCDF4.Group` or `netCDF4.Dataset` to instances of the\n    `netCDF4.VLType` class.";
+static char __pyx_k_Users_jsw_python_netcdf4_python[] = "/Users/jsw/python/netcdf4-python.git/netCDF4/_netCDF4.pyx";
 static char __pyx_k_Variable_object_no_longer_valid[] = "Variable object no longer valid";
 static char __pyx_k_Version_1_2_4_Introduction_netc[] = "\nVersion 1.2.4\n-------------\n- - - \n\nIntroduction\n============\n\nnetcdf4-python is a Python interface to the netCDF C library.  \n\n[netCDF](http://www.unidata.ucar.edu/software/netcdf/) version 4 has many features\nnot found in earlier versions of the library and is implemented on top of\n[HDF5](http://www.hdfgroup.org/HDF5). This module can read and write\nfiles in both the new netCDF 4 and the old netCDF 3 format, and can create\nfiles that are readable by HDF5 clients. The API modelled after\n[Scientific.IO.NetCDF](http://dirac.cnrs-orleans.fr/ScientificPython/),\nand should be familiar to users of that module.\n\nMost new features of netCDF 4 are implemented, such as multiple\nunlimited dimensions, groups and zlib data compression.  All the new\nnumeric data types (such as 64 bit and unsigned integer types) are\nimplemented. Compound (struct), variable length (vlen) and\nenumerated (enum) data types are supported, but not the opaque data type.\nMixtures of compound, vlen and enum data types (such as\ncompound types containing enums, or vlens containing compound\ntypes) are not supported.\n\nDownload\n========\n\n - Latest bleeding-edge code from the \n   [github repository](http://github.com/Unidata/netcdf4-python).\n - Latest [releases](https://pypi.python.org/pypi/netCDF4)\n   (source code and windows installers).\n\nRequires\n========\n\n - Python 2.6 or later (python 3 works too).\n - [numpy array module](http://numpy.scipy.org), version 1.7.0 or later.\n - [Cython](http://cython.org), version 0.19 or later, is optional - if it is installed setup.py will\n   use it to recompile the Cython source code into C, using conditional compilation\n   to enable features in the netCDF API that have been added since version 4.1.1.  If\n   Cython is not installed, these features (such as the ability to rename Group objects)\n   will be disabled to preserve backward compatibility with older versions of the netCDF\n   library.\n - For python < 2.7, the [ordereddict"" module](http://python.org/pypi/ordereddict).\n - The HDF5 C library version 1.8.4-patch1 or higher (1.8.8 or higher\n recommended) from [](ftp://ftp.hdfgroup.org/HDF5/current/src).\n Be sure to build with `--enable-hl --enable-shared`.\n - [Libcurl](http://curl.haxx.se/libcurl), if you want\n [OPeNDAP](http://opendap.org) support.\n - [HDF4](http://www.hdfgroup.org/products/hdf4), if you want\n to be able to read HDF4 \"Scientific Dataset\" (SD) files.\n - The netCDF-4 C library from \n [ftp://ftp.unidata.ucar.edu/pub/netcdf](ftp://ftp.unidata.ucar.edu/pub/netcdf).\n Version 4.1.1 or higher is required (4.2 or higher recommended).\n Be sure to build with `--enable-netcdf-4 --enable-shared`, and set\n `CPPFLAGS=\"-I $HDF5_DIR/include\"` and `LDFLAGS=\"-L $HDF5_DIR/lib\"`,\n where `$HDF5_DIR` is the directory where HDF5 was installed.\n If you want [OPeNDAP](http://opendap.org) support, add `--enable-dap`.\n If you want HDF4 SD support, add `--enable-hdf4` and add\n the location of the HDF4 headers and library to `$CPPFLAGS` and `$LDFLAGS`.\n\n\nInstall\n=======\n\n - install the requisite python modules and C libraries (see above). It's\n easiest if all the C libs are built as shared libraries.\n - By default, the utility `nc-config`, installed with netcdf 4.1.2 or higher,\n will be run used to determine where all the dependencies live.\n - If `nc-config` is not in your default `$PATH`, rename the\n file `setup.cfg.template` to `setup.cfg`, then edit\n in a text editor (follow the instructions in the comments).\n In addition to specifying the path to `nc-config`,\n you can manually set the paths to all the libraries and their include files\n (in case `nc-config` does not do the right thing).\n - run `python setup.py build`, then `python setup.py install` (as root if\n necessary).\n - [`pip install`](https://pip.pypa.io/en/latest/reference/pip_install.html) can\n   also be used, with library paths set with environment variables. To make\n   this work, the `USE_SETUPC""FG` environment variable must be used to tell \n   setup.py not to use `setup.cfg`.\n   For example, `USE_SETUPCFG=0 HDF5_INCDIR=/usr/include/hdf5/serial\n   HDF5_LIBDIR=/usr/lib/x86_64-linux-gnu/hdf5/serial pip install` has been\n   shown to work on an Ubuntu/Debian linux system. Similarly, environment variables\n   (all capitalized) can be used to set the include and library paths for\n   `hdf5`, `netCDF4`, `hdf4`, `szip`, `jpeg`, `curl` and `zlib`. If the\n   libraries are installed in standard places (e.g. `/usr` or `/usr/local`), \n   the environment variables do not need to be set.\n - run the tests in the 'test' directory by running `python run_all.py`.\n\nTutorial\n========\n\n1. [Creating/Opening/Closing a netCDF file.](#section1)\n2. [Groups in a netCDF file.](#section2)\n3. [Dimensions in a netCDF file.](#section3)\n4. [Variables in a netCDF file.](#section4)\n5. [Attributes in a netCDF file.](#section5)\n6. [Writing data to and retrieving data from a netCDF variable.](#section6)\n7. [Dealing with time coordinates.](#section7)\n8. [Reading data from a multi-file netCDF dataset.](#section8)\n9. [Efficient compression of netCDF variables.](#section9)\n10. [Beyond homogeneous arrays of a fixed type - compound data types.](#section10)\n11. [Variable-length (vlen) data types.](#section11)\n12. [Enum data type.](#section12)\n\n\n## <div id='section1'>1) Creating/Opening/Closing a netCDF file.\n\nTo create a netCDF file from python, you simply call the `netCDF4.Dataset`\nconstructor. This is also the method used to open an existing netCDF\nfile.  If the file is open for write access (`mode='w', 'r+'` or `'a'`), you may\nwrite any type of data including new dimensions, groups, variables and\nattributes.  netCDF files come in five flavors (`NETCDF3_CLASSIC,\nNETCDF3_64BIT_OFFSET, NETCDF3_64BIT_DATA, NETCDF4_CLASSIC`, and `NETCDF4`). \n`NETCDF3_CLASSIC` was the original netcdf binary format, and was limited \nto file sizes less than 2 Gb. `NETCDF3_64BIT_OFFSET` was"" introduced\nin version 3.6.0 of the library, and extended the original binary format\nto allow for file sizes greater than 2 Gb. \n`NETCDF3_64BIT_DATA` is a new format that requires version 4.4.0 of\nthe C library - it extends the `NETCDF3_64BIT_OFFSET` binary format to\nallow for unsigned/64 bit integer data types and 64-bit dimension sizes.\n`NETCDF3_64BIT` is an alias for `NETCDF3_64BIT_OFFSET`.\n`NETCDF4_CLASSIC` files use the version 4 disk format (HDF5), but omits features\nnot found in the version 3 API. They can be read by netCDF 3 clients\nonly if they have been relinked against the netCDF 4 library. They can\nalso be read by HDF5 clients. `NETCDF4` files use the version 4 disk\nformat (HDF5) and use the new features of the version 4 API.  The\n`netCDF4` module can read and write files in any of these formats. When\ncreating a new file, the format may be specified using the `format`\nkeyword in the `Dataset` constructor.  The default format is\n`NETCDF4`. To see how a given file is formatted, you can examine the\n`data_model` attribute.  Closing the netCDF file is\naccomplished via the `netCDF4.Dataset.close` method of the `netCDF4.Dataset`\ninstance.\n\nHere's an example:\n\n    :::python\n    >>> from netCDF4 import Dataset\n    >>> rootgrp = Dataset(\"test.nc\", \"w\", format=\"NETCDF4\")\n    >>> print rootgrp.data_model\n    NETCDF4\n    >>> rootgrp.close()\n\nRemote [OPeNDAP](http://opendap.org)-hosted datasets can be accessed for\nreading over http if a URL is provided to the `netCDF4.Dataset` constructor instead of a\nfilename.  However, this requires that the netCDF library be built with\nOPenDAP support, via the `--enable-dap` configure option (added in\nversion 4.0.1).\n\n\n## <div id='section2'>2) Groups in a netCDF file.\n\nnetCDF version 4 added support for organizing data in hierarchical\ngroups, which are analogous to directories in a filesystem. Groups serve\nas containers for variables, dimensions and attributes, as well as other\ngroups.""  A `netCDF4.Dataset` defines creates a special group, called\nthe 'root group', which is similar to the root directory in a unix\nfilesystem.  To create `netCDF4.Group` instances, use the\n`netCDF4.Dataset.createGroup` method of a `netCDF4.Dataset` or `netCDF4.Group`\ninstance. `netCDF4.Dataset.createGroup` takes a single argument, a\npython string containing the name of the new group. The new `netCDF4.Group`\ninstances contained within the root group can be accessed by name using\nthe `groups` dictionary attribute of the `netCDF4.Dataset` instance.  Only\n`NETCDF4` formatted files support Groups, if you try to create a Group\nin a netCDF 3 file you will get an error message.\n\n    :::python\n    >>> rootgrp = Dataset(\"test.nc\", \"a\")\n    >>> fcstgrp = rootgrp.createGroup(\"forecasts\")\n    >>> analgrp = rootgrp.createGroup(\"analyses\")\n    >>> print rootgrp.groups\n    OrderedDict([(\"forecasts\", \n                  <netCDF4._netCDF4.Group object at 0x1b4b7b0>),\n                 (\"analyses\", \n                  <netCDF4._netCDF4.Group object at 0x1b4b970>)])\n\nGroups can exist within groups in a `netCDF4.Dataset`, just as directories\nexist within directories in a unix filesystem. Each `netCDF4.Group` instance\nhas a `groups` attribute dictionary containing all of the group\ninstances contained within that group. Each `netCDF4.Group` instance also has a\n`path` attribute that contains a simulated unix directory path to\nthat group.  To simplify the creation of nested groups, you can\nuse a unix-like path as an argument to `netCDF4.Dataset.createGroup`.\n\n    :::python\n    >>> fcstgrp1 = rootgrp.createGroup(\"/forecasts/model1\")\n    >>> fcstgrp2 = rootgrp.createGroup(\"/forecasts/model2\")\n\nIf any of the intermediate elements of the path do not exist, they are created,\njust as with the unix command `'mkdir -p'`. If you try to create a group\nthat already exists, no error will be raised, and the existing group will be \nreturned.\n\nHere's an exa""mple that shows how to navigate all the groups in a\n`netCDF4.Dataset`. The function `walktree` is a Python generator that is used\nto walk the directory tree. Note that printing the `netCDF4.Dataset` or `netCDF4.Group`\nobject yields summary information about it's contents.\n\n    :::python\n    >>> def walktree(top):\n    >>>     values = top.groups.values()\n    >>>     yield values\n    >>>     for value in top.groups.values():\n    >>>         for children in walktree(value):\n    >>>             yield children\n    >>> print rootgrp\n    >>> for children in walktree(rootgrp):\n    >>>      for child in children:\n    >>>          print child\n    <type \"netCDF4._netCDF4.Dataset\">\n    root group (NETCDF4 file format):\n        dimensions:\n        variables:\n        groups: forecasts, analyses\n    <type \"netCDF4._netCDF4.Group\">\n    group /forecasts:\n        dimensions:\n        variables:\n        groups: model1, model2\n    <type \"netCDF4._netCDF4.Group\">\n    group /analyses:\n        dimensions:\n        variables:\n        groups:\n    <type \"netCDF4._netCDF4.Group\">\n    group /forecasts/model1:\n        dimensions:\n        variables:\n        groups:\n    <type \"netCDF4._netCDF4.Group\">\n    group /forecasts/model2:\n        dimensions:\n        variables:\n        groups:\n\n## <div id='section3'>3) Dimensions in a netCDF file.\n\nnetCDF defines the sizes of all variables in terms of dimensions, so\nbefore any variables can be created the dimensions they use must be\ncreated first. A special case, not often used in practice, is that of a\nscalar variable, which has no dimensions. A dimension is created using\nthe `netCDF4.Dataset.createDimension` method of a `netCDF4.Dataset`\nor `netCDF4.Group` instance. A Python string is used to set the name of the\ndimension, and an integer value is used to set the size. To create an\nunlimited dimension (a dimension that can be appended to), the size\nvalue is set to `None` or 0. In this example, th""ere both the `time` and\n`level` dimensions are unlimited.  Having more than one unlimited\ndimension is a new netCDF 4 feature, in netCDF 3 files there may be only\none, and it must be the first (leftmost) dimension of the variable.\n\n    :::python\n    >>> level = rootgrp.createDimension(\"level\", None)\n    >>> time = rootgrp.createDimension(\"time\", None)\n    >>> lat = rootgrp.createDimension(\"lat\", 73)\n    >>> lon = rootgrp.createDimension(\"lon\", 144)\n\n\nAll of the `netCDF4.Dimension` instances are stored in a python dictionary.\n\n    :::python\n    >>> print rootgrp.dimensions\n    OrderedDict([(\"level\", <netCDF4._netCDF4.Dimension object at 0x1b48030>),\n                 (\"time\", <netCDF4._netCDF4.Dimension object at 0x1b481c0>),\n                 (\"lat\", <netCDF4._netCDF4.Dimension object at 0x1b480f8>),\n                 (\"lon\", <netCDF4._netCDF4.Dimension object at 0x1b48a08>)])\n\nCalling the python `len` function with a `netCDF4.Dimension` instance returns\nthe current size of that dimension.\nThe `netCDF4.Dimension.isunlimited` method of a `netCDF4.Dimension` instance\ncan be used to determine if the dimensions is unlimited, or appendable.\n\n    :::python\n    >>> print len(lon)\n    144\n    >>> print lon.isunlimited()\n    False\n    >>> print time.isunlimited()\n    True\n\nPrinting the `netCDF4.Dimension` object\nprovides useful summary info, including the name and length of the dimension,\nand whether it is unlimited.\n\n    :::python\n    >>> for dimobj in rootgrp.dimensions.values():\n    >>>    print dimobj\n    <type \"netCDF4._netCDF4.Dimension\"> (unlimited): name = \"level\", size = 0\n    <type \"netCDF4._netCDF4.Dimension\"> (unlimited): name = \"time\", size = 0\n    <type \"netCDF4._netCDF4.Dimension\">: name = \"lat\", size = 73\n    <type \"netCDF4._netCDF4.Dimension\">: name = \"lon\", size = 144\n    <type \"netCDF4._netCDF4.Dimension\"> (unlimited): name = \"time\", size = 0\n\n`netCDF4.Dimension` names can be c""hanged using the\n`netCDF4.Datatset.renameDimension` method of a `netCDF4.Dataset` or\n`netCDF4.Group` instance.\n\n## <div id='section4'>4) Variables in a netCDF file.\n\nnetCDF variables behave much like python multidimensional array objects\nsupplied by the [numpy module](http://numpy.scipy.org). However,\nunlike numpy arrays, netCDF4 variables can be appended to along one or\nmore 'unlimited' dimensions. To create a netCDF variable, use the\n`netCDF4.Dataset.createVariable` method of a `netCDF4.Dataset` or\n`netCDF4.Group` instance. The `netCDF4.Dataset.createVariable` method\nhas two mandatory arguments, the variable name (a Python string), and\nthe variable datatype. The variable's dimensions are given by a tuple\ncontaining the dimension names (defined previously with\n`netCDF4.Dataset.createDimension`). To create a scalar\nvariable, simply leave out the dimensions keyword. The variable\nprimitive datatypes correspond to the dtype attribute of a numpy array.\nYou can specify the datatype as a numpy dtype object, or anything that\ncan be converted to a numpy dtype object.  Valid datatype specifiers\ninclude: `'f4'` (32-bit floating point), `'f8'` (64-bit floating\npoint), `'i4'` (32-bit signed integer), `'i2'` (16-bit signed\ninteger), `'i8'` (64-bit singed integer), `'i1'` (8-bit signed\ninteger), `'u1'` (8-bit unsigned integer), `'u2'` (16-bit unsigned\ninteger), `'u4'` (32-bit unsigned integer), `'u8'` (64-bit unsigned\ninteger), or `'S1'` (single-character string).  The old Numeric\nsingle-character typecodes (`'f'`,`'d'`,`'h'`,\n`'s'`,`'b'`,`'B'`,`'c'`,`'i'`,`'l'`), corresponding to\n(`'f4'`,`'f8'`,`'i2'`,`'i2'`,`'i1'`,`'i1'`,`'S1'`,`'i4'`,`'i4'`),\nwill also work. The unsigned integer types and the 64-bit integer type\ncan only be used if the file format is `NETCDF4`.\n\nThe dimensions themselves are usually also defined as variables, called\ncoordinate variables. The `netCDF4.Dataset.createVariable`\nmethod returns an instance of the `netCDF4.Variable` ""class whose methods can be\nused later to access and set variable data and attributes.\n\n    :::python\n    >>> times = rootgrp.createVariable(\"time\",\"f8\",(\"time\",))\n    >>> levels = rootgrp.createVariable(\"level\",\"i4\",(\"level\",))\n    >>> latitudes = rootgrp.createVariable(\"latitude\",\"f4\",(\"lat\",))\n    >>> longitudes = rootgrp.createVariable(\"longitude\",\"f4\",(\"lon\",))\n    >>> # two dimensions unlimited\n    >>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n\nTo get summary info on a `netCDF4.Variable` instance in an interactive session, just print it.\n\n    :::python\n    >>> print temp\n    <type \"netCDF4._netCDF4.Variable\">\n    float32 temp(time, level, lat, lon)\n        least_significant_digit: 3\n        units: K\n    unlimited dimensions: time, level\n    current shape = (0, 0, 73, 144)\n\nYou can use a path to create a Variable inside a hierarchy of groups.\n\n    :::python\n    >>> ftemp = rootgrp.createVariable(\"/forecasts/model1/temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n\nIf the intermediate groups do not yet exist, they will be created.\n\nYou can also query a `netCDF4.Dataset` or `netCDF4.Group` instance directly to obtain `netCDF4.Group` or \n`netCDF4.Variable` instances using paths.\n\n    :::python\n    >>> print rootgrp[\"/forecasts/model1\"] # a Group instance\n    <type \"netCDF4._netCDF4.Group\">\n    group /forecasts/model1:\n        dimensions(sizes):\n        variables(dimensions): float32 temp(time,level,lat,lon)\n        groups:\n    >>> print rootgrp[\"/forecasts/model1/temp\"] # a Variable instance\n    <type \"netCDF4._netCDF4.Variable\">\n    float32 temp(time, level, lat, lon)\n    path = /forecasts/model1\n    unlimited dimensions: time, level\n    current shape = (0, 0, 73, 144)\n    filling on, default _FillValue of 9.96920996839e+36 used\n\nAll of the variables in the `netCDF4.Dataset` or `netCDF4.Group` are stored in a\nPython dictionary, in the sa""me way as the dimensions:\n\n    :::python\n    >>> print rootgrp.variables\n    OrderedDict([(\"time\", <netCDF4.Variable object at 0x1b4ba70>),\n                 (\"level\", <netCDF4.Variable object at 0x1b4bab0>),\n                 (\"latitude\", <netCDF4.Variable object at 0x1b4baf0>),\n                 (\"longitude\", <netCDF4.Variable object at 0x1b4bb30>),\n                 (\"temp\", <netCDF4.Variable object at 0x1b4bb70>)])\n\n`netCDF4.Variable` names can be changed using the\n`netCDF4.Dataset.renameVariable` method of a `netCDF4.Dataset`\ninstance.\n\n\n## <div id='section5'>5) Attributes in a netCDF file.\n\nThere are two types of attributes in a netCDF file, global and variable.\nGlobal attributes provide information about a group, or the entire\ndataset, as a whole. `netCDF4.Variable` attributes provide information about\none of the variables in a group. Global attributes are set by assigning\nvalues to `netCDF4.Dataset` or `netCDF4.Group` instance variables. `netCDF4.Variable`\nattributes are set by assigning values to `netCDF4.Variable` instances\nvariables. Attributes can be strings, numbers or sequences. Returning to\nour example,\n\n    :::python\n    >>> import time\n    >>> rootgrp.description = \"bogus example script\"\n    >>> rootgrp.history = \"Created \" + time.ctime(time.time())\n    >>> rootgrp.source = \"netCDF4 python module tutorial\"\n    >>> latitudes.units = \"degrees north\"\n    >>> longitudes.units = \"degrees east\"\n    >>> levels.units = \"hPa\"\n    >>> temp.units = \"K\"\n    >>> times.units = \"hours since 0001-01-01 00:00:00.0\"\n    >>> times.calendar = \"gregorian\"\n\nThe `netCDF4.Dataset.ncattrs` method of a `netCDF4.Dataset`, `netCDF4.Group` or\n`netCDF4.Variable` instance can be used to retrieve the names of all the netCDF\nattributes. This method is provided as a convenience, since using the\nbuilt-in `dir` Python function will return a bunch of private methods\nand attributes that cannot (or should not) be modified ""by the user.\n\n    :::python\n    >>> for name in rootgrp.ncattrs():\n    >>>     print \"Global attr\", name, \"=\", getattr(rootgrp,name)\n    Global attr description = bogus example script\n    Global attr history = Created Mon Nov  7 10.30:56 2005\n    Global attr source = netCDF4 python module tutorial\n\nThe `__dict__` attribute of a `netCDF4.Dataset`, `netCDF4.Group` or `netCDF4.Variable`\ninstance provides all the netCDF attribute name/value pairs in a python\ndictionary:\n\n    :::python\n    >>> print rootgrp.__dict__\n    OrderedDict([(u\"description\", u\"bogus example script\"),\n                 (u\"history\", u\"Created Thu Mar  3 19:30:33 2011\"),\n                 (u\"source\", u\"netCDF4 python module tutorial\")])\n\nAttributes can be deleted from a netCDF `netCDF4.Dataset`, `netCDF4.Group` or\n`netCDF4.Variable` using the python `del` statement (i.e. `del grp.foo`\nremoves the attribute `foo` the the group `grp`).\n\n## <div id='section6'>6) Writing data to and retrieving data from a netCDF variable.\n\nNow that you have a netCDF `netCDF4.Variable` instance, how do you put data\ninto it? You can just treat it like an array and assign data to a slice.\n\n    :::python\n    >>> import numpy\n    >>> lats =  numpy.arange(-90,91,2.5)\n    >>> lons =  numpy.arange(-180,180,2.5)\n    >>> latitudes[:] = lats\n    >>> longitudes[:] = lons\n    >>> print \"latitudes =\\n\",latitudes[:]\n    latitudes =\n    [-90.  -87.5 -85.  -82.5 -80.  -77.5 -75.  -72.5 -70.  -67.5 -65.  -62.5\n     -60.  -57.5 -55.  -52.5 -50.  -47.5 -45.  -42.5 -40.  -37.5 -35.  -32.5\n     -30.  -27.5 -25.  -22.5 -20.  -17.5 -15.  -12.5 -10.   -7.5  -5.   -2.5\n       0.    2.5   5.    7.5  10.   12.5  15.   17.5  20.   22.5  25.   27.5\n      30.   32.5  35.   37.5  40.   42.5  45.   47.5  50.   52.5  55.   57.5\n      60.   62.5  65.   67.5  70.   72.5  75.   77.5  80.   82.5  85.   87.5\n      90. ]\n\nUnlike NumPy's array objects, netCDF `netCDF4.Variable`\nobjects with unlimite""d dimensions will grow along those dimensions if you\nassign data outside the currently defined range of indices.\n\n    :::python\n    >>> # append along two unlimited dimensions by assigning to slice.\n    >>> nlats = len(rootgrp.dimensions[\"lat\"])\n    >>> nlons = len(rootgrp.dimensions[\"lon\"])\n    >>> print \"temp shape before adding data = \",temp.shape\n    temp shape before adding data =  (0, 0, 73, 144)\n    >>>\n    >>> from numpy.random import uniform\n    >>> temp[0:5,0:10,:,:] = uniform(size=(5,10,nlats,nlons))\n    >>> print \"temp shape after adding data = \",temp.shape\n    temp shape after adding data =  (6, 10, 73, 144)\n    >>>\n    >>> # levels have grown, but no values yet assigned.\n    >>> print \"levels shape after adding pressure data = \",levels.shape\n    levels shape after adding pressure data =  (10,)\n\nNote that the size of the levels variable grows when data is appended\nalong the `level` dimension of the variable `temp`, even though no\ndata has yet been assigned to levels.\n\n    :::python\n    >>> # now, assign data to levels dimension variable.\n    >>> levels[:] =  [1000.,850.,700.,500.,300.,250.,200.,150.,100.,50.]\n\nHowever, that there are some differences between NumPy and netCDF\nvariable slicing rules. Slices behave as usual, being specified as a\n`start:stop:step` triplet. Using a scalar integer index `i` takes the ith\nelement and reduces the rank of the output array by one. Boolean array and\ninteger sequence indexing behaves differently for netCDF variables\nthan for numpy arrays.  Only 1-d boolean arrays and integer sequences are\nallowed, and these indices work independently along each dimension (similar\nto the way vector subscripts work in fortran).  This means that\n\n    :::python\n    >>> temp[0, 0, [0,1,2,3], [0,1,2,3]]\n\nreturns an array of shape (4,4) when slicing a netCDF variable, but for a\nnumpy array it returns an array of shape (4,).\nSimilarly, a netCDF variable of shape `(2,3,4,5)` indexed\nwith `""[0, array([True, False, True]), array([False, True, True, True]), :]`\nwould return a `(2, 3, 5)` array. In NumPy, this would raise an error since\nit would be equivalent to `[0, [0,1], [1,2,3], :]`. When slicing with integer\nsequences, the indices ***need not be sorted*** and ***may contain\nduplicates*** (both of these are new features in version 1.2.1).\nWhile this behaviour may cause some confusion for those used to NumPy's 'fancy indexing' rules,\nit provides a very powerful way to extract data from multidimensional netCDF\nvariables by using logical operations on the dimension arrays to create slices.\n\nFor example,\n\n    :::python\n    >>> tempdat = temp[::2, [1,3,6], lats>0, lons>0]\n\nwill extract time indices 0,2 and 4, pressure levels\n850, 500 and 200 hPa, all Northern Hemisphere latitudes and Eastern\nHemisphere longitudes, resulting in a numpy array of shape  (3, 3, 36, 71).\n\n    :::python\n    >>> print \"shape of fancy temp slice = \",tempdat.shape\n    shape of fancy temp slice =  (3, 3, 36, 71)\n\n***Special note for scalar variables***: To extract data from a scalar variable\n`v` with no associated dimensions, use `np.asarray(v)` or `v[...]`. The result\nwill be a numpy scalar array.\n\n## <div id='section7'>7) Dealing with time coordinates.\n\nTime coordinate values pose a special challenge to netCDF users.  Most\nmetadata standards (such as CF) specify that time should be\nmeasure relative to a fixed date using a certain calendar, with units\nspecified like `hours since YY:MM:DD hh-mm-ss`.  These units can be\nawkward to deal with, without a utility to convert the values to and\nfrom calendar dates.  The function called `netCDF4.num2date` and `netCDF4.date2num` are\nprovided with this package to do just that.  Here's an example of how they\ncan be used:\n\n    :::python\n    >>> # fill in times.\n    >>> from datetime import datetime, timedelta\n    >>> from netCDF4 import num2date, date2num\n    >>> dates = [datetime(2001,3,1)+n*timedelta(""hours=12) for n in range(temp.shape[0])]\n    >>> times[:] = date2num(dates,units=times.units,calendar=times.calendar)\n    >>> print \"time values (in units %s): \" % times.units+\"\\n\",times[:]\n    time values (in units hours since January 1, 0001):\n    [ 17533056.  17533068.  17533080.  17533092.  17533104.]\n    >>> dates = num2date(times[:],units=times.units,calendar=times.calendar)\n    >>> print \"dates corresponding to time values:\\n\",dates\n    dates corresponding to time values:\n    [2001-03-01 00:00:00 2001-03-01 12:00:00 2001-03-02 00:00:00\n     2001-03-02 12:00:00 2001-03-03 00:00:00]\n\n`netCDF4.num2date` converts numeric values of time in the specified `units`\nand `calendar` to datetime objects, and `netCDF4.date2num` does the reverse.\nAll the calendars currently defined in the\n[CF metadata convention](http://cfconventions.org) are supported.\nA function called `netCDF4.date2index` is also provided which returns the indices\nof a netCDF time variable corresponding to a sequence of datetime instances.\n\n\n## <div id='section8'>8) Reading data from a multi-file netCDF dataset.\n\nIf you want to read data from a variable that spans multiple netCDF files,\nyou can use the `netCDF4.MFDataset` class to read the data as if it were\ncontained in a single file. Instead of using a single filename to create\na `netCDF4.Dataset` instance, create a `netCDF4.MFDataset` instance with either a list\nof filenames, or a string with a wildcard (which is then converted to\na sorted list of files using the python glob module).\nVariables in the list of files that share the same unlimited\ndimension are aggregated together, and can be sliced across multiple\nfiles.  To illustrate this, let's first create a bunch of netCDF files with\nthe same variable (with the same unlimited dimension).  The files\nmust in be in `NETCDF3_64BIT_OFFSET`, `NETCDF3_64BIT_DATA`, `NETCDF3_CLASSIC` or\n`NETCDF4_CLASSIC` format (`NETCDF4` formatted multi-file\ndatasets are not supporte""d).\n\n    :::python\n    >>> for nf in range(10):\n    >>>     f = Dataset(\"mftest%s.nc\" % nf,\"w\")\n    >>>     f.createDimension(\"x\",None)\n    >>>     x = f.createVariable(\"x\",\"i\",(\"x\",))\n    >>>     x[0:10] = numpy.arange(nf*10,10*(nf+1))\n    >>>     f.close()\n\nNow read all the files back in at once with `netCDF4.MFDataset`\n\n    :::python\n    >>> from netCDF4 import MFDataset\n    >>> f = MFDataset(\"mftest*nc\")\n    >>> print f.variables[\"x\"][:]\n    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n     25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49\n     50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74\n     75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]\n\nNote that `netCDF4.MFDataset` can only be used to read, not write, multi-file\ndatasets.\n\n## <div id='section9'>9) Efficient compression of netCDF variables.\n\nData stored in netCDF 4 `netCDF4.Variable` objects can be compressed and\ndecompressed on the fly. The parameters for the compression are\ndetermined by the `zlib`, `complevel` and `shuffle` keyword arguments\nto the `netCDF4.Dataset.createVariable` method. To turn on\ncompression, set `zlib=True`.  The `complevel` keyword regulates the\nspeed and efficiency of the compression (1 being fastest, but lowest\ncompression ratio, 9 being slowest but best compression ratio). The\ndefault value of `complevel` is 4. Setting `shuffle=False` will turn\noff the HDF5 shuffle filter, which de-interlaces a block of data before\ncompression by reordering the bytes.  The shuffle filter can\nsignificantly improve compression ratios, and is on by default.  Setting\n`fletcher32` keyword argument to\n`netCDF4.Dataset.createVariable` to `True` (it's `False` by\ndefault) enables the Fletcher32 checksum algorithm for error detection.\nIt's also possible to set the HDF5 chunking parameters and endian-ness\nof the binary data stored in the H""DF5 file with the `chunksizes`\nand `endian` keyword arguments to\n`netCDF4.Dataset.createVariable`.  These keyword arguments only\nare relevant for `NETCDF4` and `NETCDF4_CLASSIC` files (where the\nunderlying file format is HDF5) and are silently ignored if the file\nformat is `NETCDF3_CLASSIC`, `NETCDF3_64BIT_OFFSET` or `NETCDF3_64BIT_DATA`.\n\nIf your data only has a certain number of digits of precision (say for\nexample, it is temperature data that was measured with a precision of\n0.1 degrees), you can dramatically improve zlib compression by\nquantizing (or truncating) the data using the `least_significant_digit`\nkeyword argument to `netCDF4.Dataset.createVariable`. The least\nsignificant digit is the power of ten of the smallest decimal place in\nthe data that is a reliable value. For example if the data has a\nprecision of 0.1, then setting `least_significant_digit=1` will cause\ndata the data to be quantized using `numpy.around(scale*data)/scale`, where\nscale = 2**bits, and bits is determined so that a precision of 0.1 is\nretained (in this case bits=4).  Effectively, this makes the compression\n'lossy' instead of 'lossless', that is some precision in the data is\nsacrificed for the sake of disk space.\n\nIn our example, try replacing the line\n\n    :::python\n    >>> temp = rootgrp.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",))\n\nwith\n\n    :::python\n    >>> temp = dataset.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",),zlib=True)\n\nand then\n\n    :::python\n    >>> temp = dataset.createVariable(\"temp\",\"f4\",(\"time\",\"level\",\"lat\",\"lon\",),zlib=True,least_significant_digit=3)\n\nand see how much smaller the resulting files are.\n\n## <div id='section10'>10) Beyond homogeneous arrays of a fixed type - compound data types.\n\nCompound data types map directly to numpy structured (a.k.a 'record'\narrays).  Structured arrays are akin to C structs, or derived types\nin Fortran. They allow for the cons""truction of table-like structures\ncomposed of combinations of other data types, including other\ncompound types. Compound types might be useful for representing multiple\nparameter values at each point on a grid, or at each time and space\nlocation for scattered (point) data. You can then access all the\ninformation for a point by reading one variable, instead of reading\ndifferent parameters from different variables.  Compound data types\nare created from the corresponding numpy data type using the\n`netCDF4.Dataset.createCompoundType` method of a `netCDF4.Dataset` or `netCDF4.Group` instance.\nSince there is no native complex data type in netcdf, compound types are handy\nfor storing numpy complex arrays.  Here's an example:\n\n    :::python\n    >>> f = Dataset(\"complex.nc\",\"w\")\n    >>> size = 3 # length of 1-d complex array\n    >>> # create sample complex data.\n    >>> datac = numpy.exp(1j*(1.+numpy.linspace(0, numpy.pi, size)))\n    >>> # create complex128 compound data type.\n    >>> complex128 = numpy.dtype([(\"real\",numpy.float64),(\"imag\",numpy.float64)])\n    >>> complex128_t = f.createCompoundType(complex128,\"complex128\")\n    >>> # create a variable with this data type, write some data to it.\n    >>> f.createDimension(\"x_dim\",None)\n    >>> v = f.createVariable(\"cmplx_var\",complex128_t,\"x_dim\")\n    >>> data = numpy.empty(size,complex128) # numpy structured array\n    >>> data[\"real\"] = datac.real; data[\"imag\"] = datac.imag\n    >>> v[:] = data # write numpy structured array to netcdf compound var\n    >>> # close and reopen the file, check the contents.\n    >>> f.close(); f = Dataset(\"complex.nc\")\n    >>> v = f.variables[\"cmplx_var\"]\n    >>> datain = v[:] # read in all the data into a numpy structured array\n    >>> # create an empty numpy complex array\n    >>> datac2 = numpy.empty(datain.shape,numpy.complex128)\n    >>> # .. fill it with contents of structured array.\n    >>> datac2.real = datain[\"real\"]; datac2.imag = ""datain[\"imag\"]\n    >>> print datac.dtype,datac # original data\n    complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]\n    >>>\n    >>> print datac2.dtype,datac2 # data from file\n    complex128 [ 0.54030231+0.84147098j -0.84147098+0.54030231j  -0.54030231-0.84147098j]\n\nCompound types can be nested, but you must create the 'inner'\nones first. All of the compound types defined for a `netCDF4.Dataset` or `netCDF4.Group` are stored in a\nPython dictionary, just like variables and dimensions. As always, printing\nobjects gives useful summary information in an interactive session:\n\n    :::python\n    >>> print f\n    <type \"netCDF4._netCDF4.Dataset\">\n    root group (NETCDF4 file format):\n        dimensions: x_dim\n        variables: cmplx_var\n        groups:\n    <type \"netCDF4._netCDF4.Variable\">\n    >>> print f.variables[\"cmplx_var\"]\n    compound cmplx_var(x_dim)\n    compound data type: [(\"real\", \"<f8\"), (\"imag\", \"<f8\")]\n    unlimited dimensions: x_dim\n    current shape = (3,)\n    >>> print f.cmptypes\n    OrderedDict([(\"complex128\", <netCDF4.CompoundType object at 0x1029eb7e8>)])\n    >>> print f.cmptypes[\"complex128\"]\n    <type \"netCDF4._netCDF4.CompoundType\">: name = \"complex128\", numpy dtype = [(u\"real\",\"<f8\"), (u\"imag\", \"<f8\")]\n\n## <div id='section11'>11) Variable-length (vlen) data types.\n\nNetCDF 4 has support for variable-length or \"ragged\" arrays.  These are arrays\nof variable length sequences having the same type. To create a variable-length\ndata type, use the `netCDF4.Dataset.createVLType` method\nmethod of a `netCDF4.Dataset` or `netCDF4.Group` instance.\n\n    :::python\n    >>> f = Dataset(\"tst_vlen.nc\",\"w\")\n    >>> vlen_t = f.createVLType(numpy.int32, \"phony_vlen\")\n\nThe numpy datatype of the variable-length sequences and the name of the\nnew datatype must be specified. Any of the primitive datatypes can be\nused (signed and unsigned integers, 32 and 64 bit"" floats, and characters),\nbut compound data types cannot.\nA new variable can then be created using this datatype.\n\n    :::python\n    >>> x = f.createDimension(\"x\",3)\n    >>> y = f.createDimension(\"y\",4)\n    >>> vlvar = f.createVariable(\"phony_vlen_var\", vlen_t, (\"y\",\"x\"))\n\nSince there is no native vlen datatype in numpy, vlen arrays are represented\nin python as object arrays (arrays of dtype `object`). These are arrays whose\nelements are Python object pointers, and can contain any type of python object.\nFor this application, they must contain 1-D numpy arrays all of the same type\nbut of varying length.\nIn this case, they contain 1-D numpy `int32` arrays of random length betwee\n1 and 10.\n\n    :::python\n    >>> import random\n    >>> data = numpy.empty(len(y)*len(x),object)\n    >>> for n in range(len(y)*len(x)):\n    >>>    data[n] = numpy.arange(random.randint(1,10),dtype=\"int32\")+1\n    >>> data = numpy.reshape(data,(len(y),len(x)))\n    >>> vlvar[:] = data\n    >>> print \"vlen variable =\\n\",vlvar[:]\n    vlen variable =\n    [[[ 1  2  3  4  5  6  7  8  9 10] [1 2 3 4 5] [1 2 3 4 5 6 7 8]]\n     [[1 2 3 4 5 6 7] [1 2 3 4 5 6] [1 2 3 4 5]]\n     [[1 2 3 4 5] [1 2 3 4] [1]]\n     [[ 1  2  3  4  5  6  7  8  9 10] [ 1  2  3  4  5  6  7  8  9 10]\n      [1 2 3 4 5 6 7 8]]]\n    >>> print f\n    <type \"netCDF4._netCDF4.Dataset\">\n    root group (NETCDF4 file format):\n        dimensions: x, y\n        variables: phony_vlen_var\n        groups:\n    >>> print f.variables[\"phony_vlen_var\"]\n    <type \"netCDF4._netCDF4.Variable\">\n    vlen phony_vlen_var(y, x)\n    vlen data type: int32\n    unlimited dimensions:\n    current shape = (4, 3)\n    >>> print f.VLtypes[\"phony_vlen\"]\n    <type \"netCDF4._netCDF4.VLType\">: name = \"phony_vlen\", numpy dtype = int32\n\nNumpy object arrays containing python strings can also be written as vlen\nvariables,  For vlen strings, you don't need to create a vlen data type.\nInstead, simply use the"" python `str` builtin (or a numpy string datatype\nwith fixed length greater than 1) when calling the\n`netCDF4.Dataset.createVariable` method.\n\n    :::python\n    >>> z = f.createDimension(\"z\",10)\n    >>> strvar = rootgrp.createVariable(\"strvar\", str, \"z\")\n\nIn this example, an object array is filled with random python strings with\nrandom lengths between 2 and 12 characters, and the data in the object\narray is assigned to the vlen string variable.\n\n    :::python\n    >>> chars = \"1234567890aabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    >>> data = numpy.empty(10,\"O\")\n    >>> for n in range(10):\n    >>>     stringlen = random.randint(2,12)\n    >>>     data[n] = \"\".join([random.choice(chars) for i in range(stringlen)])\n    >>> strvar[:] = data\n    >>> print \"variable-length string variable:\\n\",strvar[:]\n    variable-length string variable:\n    [aDy29jPt 5DS9X8 jd7aplD b8t4RM jHh8hq KtaPWF9cQj Q1hHN5WoXSiT MMxsVeq tdLUzvVTzj]\n    >>> print f\n    <type \"netCDF4._netCDF4.Dataset\">\n    root group (NETCDF4 file format):\n        dimensions: x, y, z\n        variables: phony_vlen_var, strvar\n        groups:\n    >>> print f.variables[\"strvar\"]\n    <type \"netCDF4._netCDF4.Variable\">\n    vlen strvar(z)\n    vlen data type: <type \"str\">\n    unlimited dimensions:\n    current size = (10,)\n\nIt is also possible to set contents of vlen string variables with numpy arrays\nof any string or unicode data type. Note, however, that accessing the contents\nof such variables will always return numpy arrays with dtype `object`.\n\n## <div id='section12'>12) Enum data type.\n\nnetCDF4 has an enumerated data type, which is an integer datatype that is\nrestricted to certain named values. Since Enums don't map directly to\na numpy data type, they are read and written as integer arrays.\n\nHere's an example of using an Enum type to hold cloud type data. \nThe base integer data type and a python dictionary describing the allowed\nvalues"" and their names are used to define an Enum data type using\n`netCDF4.Dataset.createEnumType`.\n\n    :::python\n    >>> nc = Dataset('clouds.nc','w')\n    >>> # python dict with allowed values and their names.\n    >>> enum_dict = {u'Altocumulus': 7, u'Missing': 255, \n    >>> u'Stratus': 2, u'Clear': 0,\n    >>> u'Nimbostratus': 6, u'Cumulus': 4, u'Altostratus': 5,\n    >>> u'Cumulonimbus': 1, u'Stratocumulus': 3}\n    >>> # create the Enum type called 'cloud_t'.\n    >>> cloud_type = nc.createEnumType(numpy.uint8,'cloud_t',enum_dict)\n    >>> print cloud_type\n    <type 'netCDF4._netCDF4.EnumType'>: name = 'cloud_t',\n    numpy dtype = uint8, fields/values ={u'Cumulus': 4,\n    u'Altocumulus': 7, u'Missing': 255,\n    u'Stratus': 2, u'Clear': 0,\n    u'Cumulonimbus': 1, u'Stratocumulus': 3,\n    u'Nimbostratus': 6, u'Altostratus': 5}\n\nA new variable can be created in the usual way using this data type.\nInteger data is written to the variable that represents the named\ncloud types in enum_dict. A `ValueError` will be raised if an attempt\nis made to write an integer value not associated with one of the\nspecified names.\n\n    :::python\n    >>> time = nc.createDimension('time',None)\n    >>> # create a 1d variable of type 'cloud_type'.\n    >>> # The fill_value is set to the 'Missing' named value.\n    >>> cloud_var =\n    >>> nc.createVariable('primary_cloud',cloud_type,'time',\n    >>> fill_value=enum_dict['Missing'])\n    >>> # write some data to the variable.\n    >>> cloud_var[:] = [enum_dict['Clear'],enum_dict['Stratus'],\n    >>> enum_dict['Cumulus'],enum_dict['Missing'],\n    >>> enum_dict['Cumulonimbus']]\n    >>> nc.close()\n    >>> # reopen the file, read the data.\n    >>> nc = Dataset('clouds.nc')\n    >>> cloud_var = nc.variables['primary_cloud']\n    >>> print cloud_var\n    <type 'netCDF4._netCDF4.Variable'>\n    enum primary_cloud(time)\n        _FillValue: 255\n    enum data type: uint8\n    unlimited dimensions: time\n    current shape = (5,"")\n    >>> print cloud_var.datatype.enum_dict\n    {u'Altocumulus': 7, u'Missing': 255, u'Stratus': 2,\n    u'Clear': 0, u'Nimbostratus': 6, u'Cumulus': 4,\n    u'Altostratus': 5, u'Cumulonimbus': 1,\n    u'Stratocumulus': 3}\n    >>> print cloud_var[:]\n    [0 2 4 -- 1]\n    >>> nc.close()\n\nAll of the code in this tutorial is available in `examples/tutorial.py`,\nUnit tests are in the `test` directory.\n\n**contact**: Jeffrey Whitaker <jeffrey.s.whitaker@noaa.gov>\n\n**copyright**: 2008 by Jeffrey Whitaker.\n\n**license**: Permission to use, copy, modify, and distribute this software and\nits documentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth the copyright notice and this permission notice appear in\nsupporting documentation.\nTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO\nEVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\nUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n- - -\n";
-static char __pyx_k_Volumes_Drobo_python_netcdf4_py[] = "/Volumes/Drobo/python/netcdf4-python.git/netCDF4/_netCDF4.pyx";
 static char __pyx_k_assign_vlen_method_only_for_use[] = "_assign_vlen method only for use with VLEN variables";
 static char __pyx_k_cannot_set__FillValue_attribute[] = "cannot set _FillValue attribute for VLEN or compound variable";
 static char __pyx_k_cannot_specify_chunksizes_for_a[] = "cannot specify chunksizes for a contiguous dataset";
@@ -2087,6 +2087,7 @@ static PyObject *__pyx_n_s_UNDEFINED;
 static PyObject *__pyx_n_s_UnicodeDecodeError;
 static PyObject *__pyx_n_s_UnicodeError;
 static PyObject *__pyx_kp_s_Unsupported_compound_type_elemen;
+static PyObject *__pyx_kp_s_Users_jsw_python_netcdf4_python;
 static PyObject *__pyx_n_s_V;
 static PyObject *__pyx_kp_s_VLType_dtype;
 static PyObject *__pyx_kp_s_VLType_name;
@@ -2114,7 +2115,6 @@ static PyObject *__pyx_n_s_Variable_set_auto_maskandscale;
 static PyObject *__pyx_kp_s_Variable_shape;
 static PyObject *__pyx_kp_s_Variable_size;
 static PyObject *__pyx_n_s_Variable_typecode;
-static PyObject *__pyx_kp_s_Volumes_Drobo_python_netcdf4_py;
 static PyObject *__pyx_kp_s_WARNING_unsupported_Compound_typ;
 static PyObject *__pyx_kp_s_WARNING_unsupported_Enum_type_sk;
 static PyObject *__pyx_kp_s_WARNING_unsupported_VLEN_type_sk;
@@ -33436,7 +33436,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
  *         ierr = nc_del_att(self._grpid, self._varid, attname)
  *         if self._grp.data_model != 'NETCDF4': self._grp._enddef()             # <<<<<<<<<<<<<<
  *         if ierr != NC_NOERR:
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
  */
   __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_self->_grp, __pyx_n_s_data_model); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
@@ -33470,7 +33470,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
  *         ierr = nc_del_att(self._grpid, self._varid, attname)
  *         if self._grp.data_model != 'NETCDF4': self._grp._enddef()
  *         if ierr != NC_NOERR:             # <<<<<<<<<<<<<<
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
  * 
  */
   __pyx_t_3 = ((__pyx_v_ierr != NC_NOERR) != 0);
@@ -33479,7 +33479,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
     /* "netCDF4/_netCDF4.pyx":3464
  *         if self._grp.data_model != 'NETCDF4': self._grp._enddef()
  *         if ierr != NC_NOERR:
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))             # <<<<<<<<<<<<<<
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))             # <<<<<<<<<<<<<<
  * 
  *     def filters(self):
  */
@@ -33492,7 +33492,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
     __Pyx_GIVEREF(__pyx_t_1);
     PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);
     __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
-    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_AttributeError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_RuntimeError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 3464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
     __Pyx_Raise(__pyx_t_1, 0, 0, 0);
@@ -33503,7 +33503,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
  *         ierr = nc_del_att(self._grpid, self._varid, attname)
  *         if self._grp.data_model != 'NETCDF4': self._grp._enddef()
  *         if ierr != NC_NOERR:             # <<<<<<<<<<<<<<
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
  * 
  */
   }
@@ -33533,7 +33533,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_24delncattr(struct __pyx_
 }
 
 /* "netCDF4/_netCDF4.pyx":3466
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
  * 
  *     def filters(self):             # <<<<<<<<<<<<<<
  *         """
@@ -33892,7 +33892,7 @@ static PyObject *__pyx_pf_7netCDF4_8_netCDF4_8Variable_26filters(struct __pyx_ob
   goto __pyx_L0;
 
   /* "netCDF4/_netCDF4.pyx":3466
- *             raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+ *             raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
  * 
  *     def filters(self):             # <<<<<<<<<<<<<<
  *         """
@@ -73913,6 +73913,7 @@ static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_n_s_UnicodeDecodeError, __pyx_k_UnicodeDecodeError, sizeof(__pyx_k_UnicodeDecodeError), 0, 0, 1, 1},
   {&__pyx_n_s_UnicodeError, __pyx_k_UnicodeError, sizeof(__pyx_k_UnicodeError), 0, 0, 1, 1},
   {&__pyx_kp_s_Unsupported_compound_type_elemen, __pyx_k_Unsupported_compound_type_elemen, sizeof(__pyx_k_Unsupported_compound_type_elemen), 0, 0, 1, 0},
+  {&__pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_k_Users_jsw_python_netcdf4_python, sizeof(__pyx_k_Users_jsw_python_netcdf4_python), 0, 0, 1, 0},
   {&__pyx_n_s_V, __pyx_k_V, sizeof(__pyx_k_V), 0, 0, 1, 1},
   {&__pyx_kp_s_VLType_dtype, __pyx_k_VLType_dtype, sizeof(__pyx_k_VLType_dtype), 0, 0, 1, 0},
   {&__pyx_kp_s_VLType_name, __pyx_k_VLType_name, sizeof(__pyx_k_VLType_name), 0, 0, 1, 0},
@@ -73940,7 +73941,6 @@ static __Pyx_StringTabEntry __pyx_string_tab[] = {
   {&__pyx_kp_s_Variable_shape, __pyx_k_Variable_shape, sizeof(__pyx_k_Variable_shape), 0, 0, 1, 0},
   {&__pyx_kp_s_Variable_size, __pyx_k_Variable_size, sizeof(__pyx_k_Variable_size), 0, 0, 1, 0},
   {&__pyx_n_s_Variable_typecode, __pyx_k_Variable_typecode, sizeof(__pyx_k_Variable_typecode), 0, 0, 1, 1},
-  {&__pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_k_Volumes_Drobo_python_netcdf4_py, sizeof(__pyx_k_Volumes_Drobo_python_netcdf4_py), 0, 0, 1, 0},
   {&__pyx_kp_s_WARNING_unsupported_Compound_typ, __pyx_k_WARNING_unsupported_Compound_typ, sizeof(__pyx_k_WARNING_unsupported_Compound_typ), 0, 0, 1, 0},
   {&__pyx_kp_s_WARNING_unsupported_Enum_type_sk, __pyx_k_WARNING_unsupported_Enum_type_sk, sizeof(__pyx_k_WARNING_unsupported_Enum_type_sk), 0, 0, 1, 0},
   {&__pyx_kp_s_WARNING_unsupported_VLEN_type_sk, __pyx_k_WARNING_unsupported_VLEN_type_sk, sizeof(__pyx_k_WARNING_unsupported_VLEN_type_sk), 0, 0, 1, 0},
@@ -75766,7 +75766,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__129 = PyTuple_Pack(4, __pyx_n_s_majorvers, __pyx_n_s_minorvers, __pyx_n_s_releasevers, __pyx_n_s_patchstring); if (unlikely(!__pyx_tuple__129)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__129);
   __Pyx_GIVEREF(__pyx_tuple__129);
-  __pyx_codeobj__130 = (PyObject*)__Pyx_PyCode_New(0, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__129, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_gethdf5libversion, 954, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__130)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__130 = (PyObject*)__Pyx_PyCode_New(0, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__129, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_gethdf5libversion, 954, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__130)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 954; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":964
  *         return '%d.%d.%d-%s' % (majorvers,minorvers,releasevers,patchstring)
@@ -75775,7 +75775,7 @@ static int __Pyx_InitCachedConstants(void) {
  *     """
  * **`getlibversion()`**
  */
-  __pyx_codeobj__131 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_getlibversion, 964, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__131)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 964; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__131 = (PyObject*)__Pyx_PyCode_New(0, 0, 0, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_getlibversion, 964, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__131)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 964; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":980
  * __has_cdf5__ = HAS_CDF5_FORMAT
@@ -75820,7 +75820,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__135 = PyTuple_Pack(1, __pyx_n_s_format); if (unlikely(!__pyx_tuple__135)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__135);
   __Pyx_GIVEREF(__pyx_tuple__135);
-  __pyx_codeobj__136 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_set_default_format, 1156, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__136)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__136 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__135, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_set_default_format, 1156, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__136)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":4960
  *         return pystr # already bytes or unicode?
@@ -75832,7 +75832,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__137 = PyTuple_Pack(1, __pyx_n_s_bytestr); if (unlikely(!__pyx_tuple__137)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__137);
   __Pyx_GIVEREF(__pyx_tuple__137);
-  __pyx_codeobj__138 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__137, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_to_ascii, 4960, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__138)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__138 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__137, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_to_ascii, 4960, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__138)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4960; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":4975
  * 
@@ -75855,7 +75855,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__140 = PyTuple_Pack(13, __pyx_n_s_timestr, __pyx_n_s_timestr_split, __pyx_n_s_units, __pyx_n_s_n, __pyx_n_s_isostring, __pyx_n_s_year, __pyx_n_s_month, __pyx_n_s_day, __pyx_n_s_hour, __pyx_n_s_minute, __pyx_n_s_second, __pyx_n_s_utc_offset, __pyx_n_s_basedate); if (unlikely(!__pyx_tuple__140)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__140);
   __Pyx_GIVEREF(__pyx_tuple__140);
-  __pyx_codeobj__141 = (PyObject*)__Pyx_PyCode_New(1, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__140, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_dateparse, 4977, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__141)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__141 = (PyObject*)__Pyx_PyCode_New(1, 0, 13, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__140, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_dateparse, 4977, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__141)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 4977; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5002
  *     return basedate
@@ -75867,7 +75867,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__142 = PyTuple_Pack(4, __pyx_n_s_string, __pyx_n_s_NUMCHARS, __pyx_n_s_dtype, __pyx_n_s_arr); if (unlikely(!__pyx_tuple__142)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__142);
   __Pyx_GIVEREF(__pyx_tuple__142);
-  __pyx_codeobj__143 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__142, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_stringtoarr, 5002, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__143)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__143 = (PyObject*)__Pyx_PyCode_New(3, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__142, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_stringtoarr, 5002, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__143)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5002; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5025
  *     return arr
@@ -75879,7 +75879,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__144 = PyTuple_Pack(3, __pyx_n_s_a, __pyx_n_s_dtype, __pyx_n_s_b); if (unlikely(!__pyx_tuple__144)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__144);
   __Pyx_GIVEREF(__pyx_tuple__144);
-  __pyx_codeobj__145 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__144, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_stringtochar, 5025, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__145)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__145 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__144, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_stringtochar, 5025, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__145)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5025; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5044
  *     return b
@@ -75891,7 +75891,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__146 = PyTuple_Pack(6, __pyx_n_s_b, __pyx_n_s_dtype, __pyx_n_s_bs, __pyx_n_s_slen, __pyx_n_s_a, __pyx_n_s_n1); if (unlikely(!__pyx_tuple__146)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__146);
   __Pyx_GIVEREF(__pyx_tuple__146);
-  __pyx_codeobj__147 = (PyObject*)__Pyx_PyCode_New(1, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__146, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_chartostring, 5044, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__147)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__147 = (PyObject*)__Pyx_PyCode_New(1, 0, 6, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__146, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_chartostring, 5044, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__147)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5044; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5065
  *     return a
@@ -75903,7 +75903,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__148 = PyTuple_Pack(15, __pyx_n_s_dates, __pyx_n_s_units, __pyx_n_s_calendar, __pyx_n_s_basedate, __pyx_n_s_unit, __pyx_n_s_msg, __pyx_n_s_isscalar, __pyx_n_s_shape, __pyx_n_s_ismasked, __pyx_n_s_mask, __pyx_n_s_times, __pyx_n_s_date, __pyx_n_s_td, __pyx_n_s_totaltime, __pyx_n_s_cdftime); if (unlikely(!__pyx_tuple__148)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__148);
   __Pyx_GIVEREF(__pyx_tuple__148);
-  __pyx_codeobj__149 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__148, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_date2num, 5065, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__149)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__149 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__148, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_date2num, 5065, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__149)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5065; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5153
  *         return cdftime.date2num(dates)
@@ -75915,7 +75915,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__150 = PyTuple_Pack(20, __pyx_n_s_times, __pyx_n_s_units, __pyx_n_s_calendar, __pyx_n_s_basedate, __pyx_n_s_unit, __pyx_n_s_msg, __pyx_n_s_isscalar, __pyx_n_s_shape, __pyx_n_s_ismasked, __pyx_n_s_mask, __pyx_n_s_dates, __pyx_n_s_time, __pyx_n_s_tsecs, __pyx_n_s_days, __pyx_n_s_msecsd, __pyx_n_s_secs, __pyx_n_s_msecs, __pyx_n_s_td, __pyx_n_s_date, __pyx_n_s_cdftime); if (unlikely(!__pyx_tuple__150)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__150);
   __Pyx_GIVEREF(__pyx_tuple__150);
-  __pyx_codeobj__151 = (PyObject*)__Pyx_PyCode_New(3, 0, 20, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__150, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_num2date, 5153, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__151)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__151 = (PyObject*)__Pyx_PyCode_New(3, 0, 20, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__150, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_num2date, 5153, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__151)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5153; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5256
  *         return cdftime.num2date(times)
@@ -75927,7 +75927,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__152 = PyTuple_Pack(7, __pyx_n_s_dates, __pyx_n_s_nctime, __pyx_n_s_calendar, __pyx_n_s_select, __pyx_n_s_basedate, __pyx_n_s_msg, __pyx_n_s_times); if (unlikely(!__pyx_tuple__152)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__152);
   __Pyx_GIVEREF(__pyx_tuple__152);
-  __pyx_codeobj__153 = (PyObject*)__Pyx_PyCode_New(4, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__152, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_date2index, 5256, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__153)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__153 = (PyObject*)__Pyx_PyCode_New(4, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__152, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_date2index, 5256, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__153)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5256; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5342
  *     """
@@ -75939,7 +75939,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__154 = PyTuple_Pack(36, __pyx_n_s_self, __pyx_n_s_files, __pyx_n_s_check, __pyx_n_s_aggdim, __pyx_n_s_exclude, __pyx_n_s_msg, __pyx_n_s_master, __pyx_n_s_cdfm, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_aggDimId, __pyx_n_s_dimname, __pyx_n_s_dim, __pyx_n_s_aggDimName, __pyx_n_s_masterRecVar, __pyx_n_s_vName, __pyx_n_s_v, __pyx_n_s_dims_2, __pyx_n_s_shape, __pyx_n_s_dtype, __pyx_n_s_cdf_2, __pyx_n_s_cdfVLen_2, __pyx_n_s_cdfRecVar_2, __pyx_n_s_f, __pyx_n_s_part, __pyx_n_s_varInfo, __pyx_n_s_masterDims, __pyx_n_s_masterShape, __pyx_n_s_masterType, __pyx_n_s_extDims, __pyx_n_s_extShape, __pyx_n_s_extType, __pyx_n_s_vInst, __pyx_n_s_varname, __pyx_n_s_var, __pyx_n_s_dset); if (unlikely(!__pyx_tuple__154)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__154);
   __Pyx_GIVEREF(__pyx_tuple__154);
-  __pyx_codeobj__155 = (PyObject*)__Pyx_PyCode_New(5, 0, 36, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__154, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_init, 5342, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__155)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__155 = (PyObject*)__Pyx_PyCode_New(5, 0, 36, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__154, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_init, 5342, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__155)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5515
  *         self._path = '/'
@@ -75951,7 +75951,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__156 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_name, __pyx_n_s_value); if (unlikely(!__pyx_tuple__156)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__156);
   __Pyx_GIVEREF(__pyx_tuple__156);
-  __pyx_codeobj__157 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__156, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_setattr, 5515, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__157)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__157 = (PyObject*)__Pyx_PyCode_New(3, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__156, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_setattr, 5515, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__157)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5519
  *         self.__dict__[name] = value
@@ -75963,7 +75963,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__158 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_name); if (unlikely(!__pyx_tuple__158)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__158);
   __Pyx_GIVEREF(__pyx_tuple__158);
-  __pyx_codeobj__159 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__158, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_getattribute, 5519, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__159)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__159 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__158, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_getattribute, 5519, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__159)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5532
  *             return Dataset.__getattribute__(self, name)
@@ -75975,7 +75975,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__160 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__160)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__160);
   __Pyx_GIVEREF(__pyx_tuple__160);
-  __pyx_codeobj__161 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__160, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_ncattrs, 5532, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__161)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__161 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__160, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_ncattrs, 5532, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__161)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5532; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5540
  *         return self._cdf[0].__dict__.keys()
@@ -75987,7 +75987,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__162 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_dset); if (unlikely(!__pyx_tuple__162)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__162);
   __Pyx_GIVEREF(__pyx_tuple__162);
-  __pyx_codeobj__163 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__162, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_close, 5540, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__163)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__163 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__162, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_close, 5540, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__163)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5540; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5549
  *             dset.close()
@@ -75999,7 +75999,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__164 = PyTuple_Pack(9, __pyx_n_s_self, __pyx_n_s_ncdump, __pyx_n_s_dimnames, __pyx_n_s_varnames, __pyx_n_s_grpnames, __pyx_n_s_attrs, __pyx_n_s_dimname, __pyx_n_s_varname, __pyx_n_s_name); if (unlikely(!__pyx_tuple__164)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__164);
   __Pyx_GIVEREF(__pyx_tuple__164);
-  __pyx_codeobj__165 = (PyObject*)__Pyx_PyCode_New(1, 0, 9, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__164, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_repr, 5549, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__165)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__165 = (PyObject*)__Pyx_PyCode_New(1, 0, 9, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__164, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_repr, 5549, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__165)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5568
  * 
@@ -76011,7 +76011,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__166 = PyTuple_Pack(5, __pyx_n_s_self, __pyx_n_s_dimname, __pyx_n_s_dim, __pyx_n_s_dimlens, __pyx_n_s_dimtotlen); if (unlikely(!__pyx_tuple__166)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__166);
   __Pyx_GIVEREF(__pyx_tuple__166);
-  __pyx_codeobj__167 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__166, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_init, 5568, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__167)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__167 = (PyObject*)__Pyx_PyCode_New(5, 0, 5, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__166, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_init, 5568, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__167)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5568; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5572
  *         self.dimtotlen = dimtotlen
@@ -76023,7 +76023,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__168 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__168)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__168);
   __Pyx_GIVEREF(__pyx_tuple__168);
-  __pyx_codeobj__169 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__168, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_len, 5572, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__169)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__169 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__168, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_len, 5572, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__169)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5572; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5574
  *     def __len__(self):
@@ -76035,7 +76035,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__170 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__170)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__170);
   __Pyx_GIVEREF(__pyx_tuple__170);
-  __pyx_codeobj__171 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__170, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_isunlimited, 5574, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__171)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__171 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__170, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_isunlimited, 5574, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__171)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5576
  *     def isunlimited(self):
@@ -76047,7 +76047,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__172 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__172)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__172);
   __Pyx_GIVEREF(__pyx_tuple__172);
-  __pyx_codeobj__173 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__172, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_repr, 5576, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__173)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__173 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__172, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_repr, 5576, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__173)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5583
  * 
@@ -76059,7 +76059,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__174 = PyTuple_Pack(7, __pyx_n_s_self, __pyx_n_s_dset, __pyx_n_s_varname, __pyx_n_s_var, __pyx_n_s_recdimname, __pyx_n_s_name, __pyx_n_s_value); if (unlikely(!__pyx_tuple__174)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__174);
   __Pyx_GIVEREF(__pyx_tuple__174);
-  __pyx_codeobj__175 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__174, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_init, 5583, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__175)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__175 = (PyObject*)__Pyx_PyCode_New(5, 0, 7, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__174, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_init, 5583, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__175)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5583; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5596
  *         for name, value in var.__dict__.items():
@@ -76071,7 +76071,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__176 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__176)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__176);
   __Pyx_GIVEREF(__pyx_tuple__176);
-  __pyx_codeobj__177 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__176, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_typecode, 5596, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__177)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__177 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__176, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_typecode, 5596, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__177)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5596; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5598
  *     def typecode(self):
@@ -76083,7 +76083,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__178 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__178)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__178);
   __Pyx_GIVEREF(__pyx_tuple__178);
-  __pyx_codeobj__179 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__178, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_ncattrs, 5598, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__179)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__179 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__178, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_ncattrs, 5598, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__179)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5600
  *     def ncattrs(self):
@@ -76095,7 +76095,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__180 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_name); if (unlikely(!__pyx_tuple__180)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__180);
   __Pyx_GIVEREF(__pyx_tuple__180);
-  __pyx_codeobj__181 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__180, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_getattr, 5600, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__181)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__181 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__180, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_getattr, 5600, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__181)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5607
  *         except:
@@ -76107,7 +76107,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__182 = PyTuple_Pack(8, __pyx_n_s_self, __pyx_n_s_ncdump_var, __pyx_n_s_dimnames, __pyx_n_s_attrs, __pyx_n_s_unlimdims, __pyx_n_s_dimname, __pyx_n_s_dim, __pyx_n_s_name); if (unlikely(!__pyx_tuple__182)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__182);
   __Pyx_GIVEREF(__pyx_tuple__182);
-  __pyx_codeobj__183 = (PyObject*)__Pyx_PyCode_New(1, 0, 8, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__182, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_repr, 5607, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__183)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__183 = (PyObject*)__Pyx_PyCode_New(1, 0, 8, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__182, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_repr, 5607, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__183)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5607; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5623
  *         ncdump_var.append('current size = %s\n' % repr(self.shape))
@@ -76119,7 +76119,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__184 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__184)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__184);
   __Pyx_GIVEREF(__pyx_tuple__184);
-  __pyx_codeobj__185 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__184, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_len, 5623, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__185)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__185 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__184, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_len, 5623, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__185)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5623; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5628
  *         else:
@@ -76131,7 +76131,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__186 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_recdimlen); if (unlikely(!__pyx_tuple__186)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__186);
   __Pyx_GIVEREF(__pyx_tuple__186);
-  __pyx_codeobj__187 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__186, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_shape_2, 5628, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__187)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__187 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__186, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_shape_2, 5628, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__187)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5628; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5631
  *         recdimlen = len(self._dset.dimensions[self._recdimname])
@@ -76143,7 +76143,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__188 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_val, __pyx_n_s_v); if (unlikely(!__pyx_tuple__188)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__188);
   __Pyx_GIVEREF(__pyx_tuple__188);
-  __pyx_codeobj__189 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__188, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_set_auto_maskandscale, 5631, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__189)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__189 = (PyObject*)__Pyx_PyCode_New(2, 0, 3, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__188, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_set_auto_maskandscale, 5631, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__189)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5631; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5634
  *         for v in self._recVar:
@@ -76155,7 +76155,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__190 = PyTuple_Pack(30, __pyx_n_s_self, __pyx_n_s_elem, __pyx_n_s_start, __pyx_n_s_count, __pyx_n_s_stride, __pyx_n_s_put_ind, __pyx_n_s_datashape, __pyx_n_s_data, __pyx_n_s_squeeze, __pyx_n_s_i, __pyx_n_s_n, __pyx_n_s_strt, __pyx_n_s_cnt, __pyx_n_s_strd, __pyx_n_s_nv, __pyx_n_s_ind, __pyx_n_s_sta, __pyx_n_s_step, __pyx_n_s_stop, __pyx_n_s_idx, __pyx_n_s_vid, __pyx_n_s_k, __pyx_n_s_lst, __pyx_n_s_newSlice, __pyx_n_s_s_2, __pyx_n_s_lstArr, __pyx_n_s_ismasked, __pyx_n_s_dat, __pyx_n_s_fill_value, __pyx_n_s_numv); if (unlikely(!__pyx_tuple__190)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__190);
   __Pyx_GIVEREF(__pyx_tuple__190);
-  __pyx_codeobj__191 = (PyObject*)__Pyx_PyCode_New(2, 0, 30, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__190, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_getitem, 5634, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__191)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__191 = (PyObject*)__Pyx_PyCode_New(2, 0, 30, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__190, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_getitem, 5634, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__191)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5634; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
 
   /* "netCDF4/_netCDF4.pyx":5773
  *     """
@@ -76167,7 +76167,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__192 = PyTuple_Pack(15, __pyx_n_s_self, __pyx_n_s_time, __pyx_n_s_units, __pyx_n_s_datetime, __pyx_n_s_name, __pyx_n_s_value, __pyx_n_s_t, __pyx_n_s_ref_date, __pyx_n_s_ref_num, __pyx_n_s_i0, __pyx_n_s_i1, __pyx_n_s_i, __pyx_n_s_v, __pyx_n_s_n, __pyx_n_s_num); if (unlikely(!__pyx_tuple__192)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__192);
   __Pyx_GIVEREF(__pyx_tuple__192);
-  __pyx_codeobj__193 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__192, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_init, 5773, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__193)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__193 = (PyObject*)__Pyx_PyCode_New(3, 0, 15, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__192, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_init, 5773, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__193)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_tuple__194 = PyTuple_Pack(1, ((PyObject *)Py_None)); if (unlikely(!__pyx_tuple__194)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5773; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__194);
   __Pyx_GIVEREF(__pyx_tuple__194);
@@ -76181,7 +76181,7 @@ static int __Pyx_InitCachedConstants(void) {
   __pyx_tuple__195 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_elem); if (unlikely(!__pyx_tuple__195)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_tuple__195);
   __Pyx_GIVEREF(__pyx_tuple__195);
-  __pyx_codeobj__196 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__195, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Volumes_Drobo_python_netcdf4_py, __pyx_n_s_getitem, 5821, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__196)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_codeobj__196 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__195, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_Users_jsw_python_netcdf4_python, __pyx_n_s_getitem, 5821, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__196)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 5821; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
diff --git a/netCDF4/_netCDF4.pyx b/netCDF4/_netCDF4.pyx
index dcb76496d8..f93e44733b 100755
--- a/netCDF4/_netCDF4.pyx
+++ b/netCDF4/_netCDF4.pyx
@@ -3461,7 +3461,7 @@ attributes."""
         ierr = nc_del_att(self._grpid, self._varid, attname)
         if self._grp.data_model != 'NETCDF4': self._grp._enddef()
         if ierr != NC_NOERR:
-            raise AttributeError((<char *>nc_strerror(ierr)).decode('ascii'))
+            raise RuntimeError((<char *>nc_strerror(ierr)).decode('ascii'))
 
     def filters(self):
         """
