diff --git a/its/ruling/src/test/resources/jdk6/squid-S3330.json b/its/ruling/src/test/resources/jdk6/squid-S3330.json
new file mode 100755
index 0000000000..43fd692140
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S3330.json
@@ -0,0 +1,5 @@
+{
+'jdk6:java/net/HttpCookie.java':[
+904,
+],
+}
diff --git a/java-checks/pom.xml b/java-checks/pom.xml
index 34fb5e6e8a..6080092735 100755
--- a/java-checks/pom.xml
+++ b/java-checks/pom.xml
@@ -146,6 +146,11 @@
                   <version>4.3.7.RELEASE</version>
                   <type>jar</type>
                 </artifactItem>
+                <artifactItem>
+                    <groupId>com.typesafe.play</groupId>
+                    <artifactId>play_2.12</artifactId>
+                    <version>2.6.14</version>
+                </artifactItem>
                 <artifactItem>
                   <groupId>org.springframework</groupId>
                   <artifactId>spring-test</artifactId>
@@ -190,6 +195,12 @@
                   <version>7.0</version>
                   <type>jar</type>
                 </artifactItem>
+                <artifactItem>
+                  <groupId>javax.ws.rs</groupId>
+                  <artifactId>javax.ws.rs-api</artifactId>
+                  <version>2.1</version>
+                  <type>jar</type>
+                </artifactItem>
                 <artifactItem>
                   <groupId>com.google.guava</groupId>
                   <artifactId>guava</artifactId>
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
index 6527d47a95..244ddf51fc 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
@@ -51,7 +51,6 @@
   private static final String FEST_ASSERT_SUPERTYPE = "org.fest.assertions.Assert";
   private static final String ASSERTJ_SUPERTYPE = "org.assertj.core.api.AbstractAssert";
   private static final String TRUTH_SUPERTYPE = "com.google.common.truth.TestVerb";
-  private static final String TRUTH_8_SUPERTYPE = "com.google.common.truth.StandardSubjectBuilder";
   private static final MethodMatcher MOCKITO_VERIFY = MethodMatcher.create()
     .typeDefinition("org.mockito.Mockito").name("verify").withAnyParameters();
   private static final MethodMatcher ASSERTJ_ASSERT_ALL = MethodMatcher.create()
@@ -75,6 +74,7 @@
     assertThatOnType("org.assertj.core.api.StrictAssertions"),
     // Truth 0.29
     methodWithName("com.google.common.truth.Truth", NameCriteria.startsWith("assert")),
+    // Truth8 0.39
     methodWithName("com.google.common.truth.Truth8", NameCriteria.startsWith("assert"))
   );
 
@@ -89,8 +89,8 @@
     methodWithName(ASSERTJ_SUPERTYPE, NameCriteria.startsWith("with")),
     methodWithName(ASSERTJ_SUPERTYPE, NameCriteria.is("describedAs")),
     methodWithName(ASSERTJ_SUPERTYPE, NameCriteria.is("overridingErrorMessage")),
-    methodWithName(TRUTH_SUPERTYPE, NameCriteria.is("that")),
-    methodWithName(TRUTH_8_SUPERTYPE, NameCriteria.is("that"))
+    // Truth has assertWithMessage, Truth8 does not
+    methodWithName(TRUTH_SUPERTYPE, NameCriteria.is("that"))
   );
 
   private Boolean chainedToAnyMethodButFestExclusions = null;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
index 45e9360280..7c2359dceb 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
@@ -44,13 +44,15 @@
 import org.sonar.java.checks.naming.MethodNamedHashcodeOrEqualCheck;
 import org.sonar.java.checks.security.AESAlgorithmCheck;
 import org.sonar.java.checks.security.CipherBlockChainingCheck;
+import org.sonar.java.checks.security.CookieHttpOnlyCheck;
 import org.sonar.java.checks.security.CookieShouldNotContainSensitiveDataCheck;
+import org.sonar.java.checks.security.CryptographicKeySizeCheck;
 import org.sonar.java.checks.security.HostnameVerifierImplementationCheck;
 import org.sonar.java.checks.security.IntegerToHexStringCheck;
+import org.sonar.java.checks.security.LDAPAuthenticatedConnectionCheck;
 import org.sonar.java.checks.security.LDAPDeserializationCheck;
 import org.sonar.java.checks.security.SecureXmlTransformerCheck;
 import org.sonar.java.checks.security.TrustManagerCertificateCheck;
-import org.sonar.java.checks.security.LDAPAuthenticatedConnectionCheck;
 import org.sonar.java.checks.serialization.CustomSerializationMethodCheck;
 import org.sonar.java.checks.serialization.ExternalizableClassConstructorCheck;
 import org.sonar.java.checks.serialization.PrivateReadResolveCheck;
@@ -307,6 +309,7 @@ private CheckList() {
       .add(ToStringReturningNullCheck.class)
       .add(TransactionalMethodVisibilityCheck.class)
       .add(CompareToResultTestCheck.class)
+      .add(CookieHttpOnlyCheck.class)
       .add(CookieShouldNotContainSensitiveDataCheck.class)
       .add(SecureCookieCheck.class)
       .add(CatchIllegalMonitorStateExceptionCheck.class)
@@ -557,6 +560,7 @@ private CheckList() {
       .add(SpecializedFunctionalInterfacesCheck.class)
       .add(IndentationAfterConditionalCheck.class)
       .add(CipherBlockChainingCheck.class)
+      .add(CryptographicKeySizeCheck.class)
       .build();
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java b/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
index 67c71e1bf8..eb9dd15ed6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
@@ -35,7 +35,7 @@
 @Rule(key = "S1313")
 public class HardcodedIpCheck extends BaseTreeVisitor implements JavaFileScanner {
 
-  private static final Matcher IP = Pattern.compile("([^\\d.]*\\/)?(?<ip>(?:\\d{1,3}\\.){3}\\d{1,3}(?!\\d|\\.))(\\/.*)?").matcher("");
+  private static final Matcher IP = Pattern.compile("([^\\d.]*\\/)?((?<ip>(?:\\d{1,3}\\.){3}\\d{1,3})(:\\d{1,5})?(?!\\d|\\.))(\\/.*)?").matcher("");
 
   private JavaFileScannerContext context;
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
index 808587e936..6c1d14e6bf 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
@@ -20,7 +20,12 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.Deque;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -34,16 +39,17 @@
 import org.sonar.plugins.java.api.tree.ThrowStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TryStatementTree;
-
-import javax.annotation.Nullable;
-
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.List;
+import org.sonar.plugins.java.api.tree.TypeTree;
+import org.sonar.plugins.java.api.tree.UnionTypeTree;
+import org.sonar.plugins.java.api.tree.VariableTree;
 
 @Rule(key = "S2142")
 public class InterruptedExceptionCheck extends IssuableSubscriptionVisitor {
 
+  private static final Predicate<Type> INTERRUPTING_TYPE_PREDICATE = catchType ->
+      catchType.is("java.lang.InterruptedException") ||
+      catchType.is("java.lang.ThreadDeath");
+
   private Deque<Boolean> withinInterruptingFinally = new LinkedList<>();
 
   @Override
@@ -64,17 +70,31 @@ public void visitNode(Tree tree) {
     TryStatementTree tryStatementTree = (TryStatementTree) tree;
     withinInterruptingFinally.addFirst(isFinallyInterrupting(tryStatementTree.finallyBlock()));
     for (CatchTree catchTree : tryStatementTree.catches()) {
-      Type catchType = catchTree.parameter().symbol().type();
-      if(catchType.is("java.lang.InterruptedException") || catchType.is("java.lang.ThreadDeath")) {
+      Optional<Type> interruptType = findInterruptingType(catchTree.parameter());
+      if(interruptType.isPresent()) {
         BlockVisitor blockVisitor = new BlockVisitor(catchTree.parameter().symbol());
         catchTree.block().accept(blockVisitor);
         if(!blockVisitor.threadInterrupted && !isWithinInterruptingFinally()) {
-          reportIssue(catchTree.parameter(), "Either re-interrupt this method or rethrow the \""+catchType.name()+"\".");
+          reportIssue(catchTree.parameter(), "Either re-interrupt this method" +
+            " or rethrow the \""+interruptType.get().name()+"\".");
         }
       }
     }
   }
 
+  private static Optional<Type> findInterruptingType(VariableTree parameter) {
+    if (parameter.type().is(Tree.Kind.UNION_TYPE)) {
+      return ((UnionTypeTree) parameter.type()).typeAlternatives().stream()
+        .map(TypeTree::symbolType)
+        .filter(INTERRUPTING_TYPE_PREDICATE)
+        .findFirst();
+    }
+    return Optional.of(parameter)
+      .map(VariableTree::symbol)
+      .map(Symbol::type)
+      .filter(INTERRUPTING_TYPE_PREDICATE);
+  }
+
   private boolean isWithinInterruptingFinally() {
     for (Boolean aBoolean : withinInterruptingFinally) {
       if(aBoolean) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
index 682979d698..258f391052 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
@@ -22,11 +22,13 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import org.sonar.check.Rule;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
 import org.sonar.java.model.LiteralUtils;
+import org.sonar.java.resolve.ArrayJavaType;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -170,9 +172,30 @@ private boolean checkEmptyParams(MethodInvocationTree mit, Collection<?> params)
   private void checkToStringInvocation(List<ExpressionTree> args) {
     args.stream()
       .filter(arg -> arg.is(Tree.Kind.METHOD_INVOCATION) && TO_STRING.matches((MethodInvocationTree) arg))
-      .forEach(arg -> reportIssue(arg, "No need to call toString \"method()\" as formatting and string conversion is done by the Formatter."));
+      .forEach(arg -> reportIssue(arg, getToStringMessage(arg)));
   }
 
+  private static String getToStringMessage(ExpressionTree arg) {
+    if (isInStringArrayInitializer(arg)) {
+      return "No need to call \"toString()\" method since an array of Objects can be used here.";
+    }
+    return "No need to call \"toString()\" method as formatting and string conversion is done by the Formatter.";
+  }
+
+  private static boolean isInStringArrayInitializer(ExpressionTree arg) {
+    return Optional.of(arg)
+      .map(Tree::parent)
+      .filter(tree -> tree.is(Tree.Kind.LIST))
+      .map(Tree::parent)
+      .filter(tree -> tree.is(Tree.Kind.NEW_ARRAY))
+      .map(NewArrayTree.class::cast)
+      .map(ExpressionTree::symbolType)
+      .filter(Type::isArray)
+      .map(ArrayJavaType.class::cast)
+      .map(ArrayJavaType::elementType)
+      .filter(type -> type.is("java.lang.String"))
+      .isPresent();
+  }
 
   private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> args, Set<Integer> indexes) {
     List<ExpressionTree> unusedArgs = new ArrayList<>(args);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/CookieHttpOnlyCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/CookieHttpOnlyCheck.java
new file mode 100755
index 0000000000..de8f8a2163
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/CookieHttpOnlyCheck.java
@@ -0,0 +1,257 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import java.util.Arrays;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.semantic.Symbol.VariableSymbol;
+import org.sonar.plugins.java.api.tree.Arguments;
+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.NewClassTree;
+import org.sonar.plugins.java.api.tree.ReturnStatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+@Rule(key = "S3330")
+public class CookieHttpOnlyCheck extends IssuableSubscriptionVisitor {
+  private final List<Symbol.VariableSymbol> compliantConstructorInitializations = Lists.newArrayList();
+  private final List<Symbol.VariableSymbol> variablesToReport = Lists.newArrayList();
+  private final List<MethodInvocationTree> settersToReport = Lists.newArrayList();
+  private final List<NewClassTree> newClassToReport = Lists.newArrayList();
+
+  private static final String CONSTRUCTOR = "<init>";
+  private static final String JAVA_LANG_STRING = "java.lang.String";
+  private static final String JAVA_UTIL_DATE = "java.util.Date";
+  private static final String INT = "int";
+  private static final String BOOLEAN = "boolean";
+
+  private static final String MESSAGE = "Add the \"HttpOnly\" cookie attribute.";
+
+  private static final class ClassName {
+    private static final String SERVLET_COOKIE = "javax.servlet.http.Cookie";
+    private static final String NET_HTTP_COOKIE = "java.net.HttpCookie";
+    private static final String JAX_RS_COOKIE = "javax.ws.rs.core.Cookie";
+    private static final String JAX_RS_NEW_COOKIE = "javax.ws.rs.core.NewCookie";
+    private static final String SHIRO_COOKIE = "org.apache.shiro.web.servlet.SimpleCookie";
+    private static final String PLAY_COOKIE = "play.mvc.Http$Cookie";
+    private static final String PLAY_COOKIE_BUILDER = "play.mvc.Http$CookieBuilder";
+  }
+
+  private static final List<String> SETTER_NAMES = Arrays.asList("setHttpOnly", "withHttpOnly");
+
+  private static final List<String> CLASSES = Arrays.asList(
+        ClassName.SERVLET_COOKIE,
+        ClassName.NET_HTTP_COOKIE,
+        ClassName.JAX_RS_COOKIE,
+        ClassName.SHIRO_COOKIE,
+        ClassName.PLAY_COOKIE,
+        ClassName.PLAY_COOKIE_BUILDER);
+
+  private static final List<MethodMatcher> CONSTRUCTORS_WITH_HTTP_ONLY_PARAM = Arrays.asList(
+        MethodMatcher.create()
+          .typeDefinition(TypeCriteria.subtypeOf(ClassName.JAX_RS_NEW_COOKIE)).name(CONSTRUCTOR)
+          .parameters(ClassName.JAX_RS_COOKIE, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN),
+        MethodMatcher.create()
+          .typeDefinition(TypeCriteria.subtypeOf(ClassName.JAX_RS_NEW_COOKIE)).name(CONSTRUCTOR)
+          .parameters(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, JAVA_LANG_STRING, INT, JAVA_UTIL_DATE, BOOLEAN, BOOLEAN),
+        MethodMatcher.create()
+          .typeDefinition(TypeCriteria.subtypeOf(ClassName.JAX_RS_NEW_COOKIE)).name(CONSTRUCTOR)
+          .parameters(JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, JAVA_LANG_STRING, INT, BOOLEAN, BOOLEAN),
+        MethodMatcher.create()
+          .typeDefinition(TypeCriteria.subtypeOf(ClassName.PLAY_COOKIE)).name(CONSTRUCTOR)
+          .parameters(JAVA_LANG_STRING, JAVA_LANG_STRING, "java.lang.Integer", JAVA_LANG_STRING, JAVA_LANG_STRING, BOOLEAN, BOOLEAN));
+
+  private static final List<MethodMatcher> CONSTRUCTORS_WITH_GOOD_DEFAULT = Arrays.asList(
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SHIRO_COOKIE)).name(CONSTRUCTOR).withoutParameter(),
+      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(ClassName.SHIRO_COOKIE)).name(CONSTRUCTOR).parameters(JAVA_LANG_STRING));
+
+  @Override
+  public void scanFile(JavaFileScannerContext context) {
+    compliantConstructorInitializations.clear();
+    variablesToReport.clear();
+    settersToReport.clear();
+    newClassToReport.clear();
+    super.scanFile(context);
+    for (VariableSymbol var : variablesToReport) {
+      VariableTree declaration = var.declaration();
+      if (declaration != null) {
+        reportIssue(declaration.simpleName(), MESSAGE);
+      }
+    }
+    for (MethodInvocationTree mit : settersToReport) {
+      reportIssue(mit.arguments(), MESSAGE);
+    }
+    for (NewClassTree newClassTree : newClassToReport) {
+      reportIssue(newClassTree, MESSAGE);
+    }
+  }
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(
+        Tree.Kind.VARIABLE,
+        Tree.Kind.ASSIGNMENT,
+        Tree.Kind.METHOD_INVOCATION,
+        Tree.Kind.RETURN_STATEMENT);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (hasSemantic()) {
+      if (tree.is(Tree.Kind.VARIABLE)) {
+        categorizeBasedOnConstructor((VariableTree) tree);
+      } else if (tree.is(Tree.Kind.ASSIGNMENT)) {
+        categorizeBasedOnConstructor((AssignmentExpressionTree) tree);
+      } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
+        checkSetterInvocation((MethodInvocationTree) tree);
+      } else {
+        categorizeBasedOnConstructor((ReturnStatementTree) tree);
+      }
+    }
+  }
+
+  private void categorizeBasedOnConstructor(VariableTree declaration) {
+    if (shouldVerify(declaration)) {
+      categorizeBasedOnConstructor((NewClassTree) declaration.initializer(),
+          (VariableSymbol) declaration.symbol());
+    }
+  }
+
+  private void categorizeBasedOnConstructor(AssignmentExpressionTree assignment) {
+    if (shouldVerify(assignment)) {
+      categorizeBasedOnConstructor((NewClassTree) assignment.expression(),
+          (VariableSymbol) ((IdentifierTree) assignment.variable()).symbol());
+    }
+  }
+
+  private void categorizeBasedOnConstructor(ReturnStatementTree returnStatement) {
+    ExpressionTree returnedExpression = returnStatement.expression();
+    if (returnedExpression != null && returnedExpression.is(Tree.Kind.NEW_CLASS)) {
+      NewClassTree newClass = (NewClassTree) returnedExpression;
+      if (!isCompliantConstructorCall(newClass) && CLASSES.stream().anyMatch(newClass.symbolType()::isSubtypeOf)) {
+        newClassToReport.add(newClass);
+      }
+    }
+  }
+
+  private void categorizeBasedOnConstructor(NewClassTree newClassTree, VariableSymbol variableSymbol) {
+    if (isCompliantConstructorCall(newClassTree)) {
+      compliantConstructorInitializations.add(variableSymbol);
+    } else {
+      variablesToReport.add(variableSymbol);
+    }
+  }
+
+  private static boolean shouldVerify(VariableTree variableDeclaration) {
+    ExpressionTree initializer = variableDeclaration.initializer();
+    if (initializer != null && initializer.is(Tree.Kind.NEW_CLASS)) {
+      boolean isSupportedClass = CLASSES.stream().anyMatch(variableDeclaration.type().symbolType()::isSubtypeOf)
+          || CLASSES.stream().anyMatch(initializer.symbolType()::isSubtypeOf);
+      return variableDeclaration.symbol().owner().isMethodSymbol() && isSupportedClass;
+    }
+    return false;
+  }
+
+  private static boolean shouldVerify(AssignmentExpressionTree assignment) {
+    if (assignment.expression().is(Tree.Kind.NEW_CLASS) && assignment.variable().is(Tree.Kind.IDENTIFIER)) {
+      IdentifierTree identifier = (IdentifierTree) assignment.variable();
+      boolean isMethodVariable = identifier.symbol().isVariableSymbol()
+          && identifier.symbol().owner().isMethodSymbol();
+      boolean isSupportedClass = CLASSES.stream().anyMatch(identifier.symbolType()::isSubtypeOf)
+          || CLASSES.stream().anyMatch(assignment.expression().symbolType()::isSubtypeOf);
+      return isMethodVariable && isSupportedClass;
+    }
+    return false;
+  }
+
+  private static boolean isCompliantConstructorCall(NewClassTree newClassTree) {
+    if (CONSTRUCTORS_WITH_HTTP_ONLY_PARAM.stream().anyMatch(matcher -> matcher.matches(newClassTree))) {
+      Arguments arguments = newClassTree.arguments();
+      ExpressionTree lastArgument = arguments.get(arguments.size() - 1);
+      return LiteralUtils.isTrue(lastArgument);
+    } else {
+      return CONSTRUCTORS_WITH_GOOD_DEFAULT.stream().anyMatch(matcher -> matcher.matches(newClassTree));
+    }
+  }
+
+  private void checkSetterInvocation(MethodInvocationTree mit) {
+    if (isExpectedSetter(mit)) {
+      if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
+        boolean isCalledOnIdentifier = ((MemberSelectExpressionTree) mit.methodSelect()).expression().is(Tree.Kind.IDENTIFIER);
+        if (isCalledOnIdentifier) {
+          updateIssuesToReport(mit);
+        } else if (!setterArgumentHasCompliantValue(mit.arguments())) {
+          // builder method
+          settersToReport.add(mit);
+        }
+      } else if (!setterArgumentHasCompliantValue(mit.arguments())) {
+        // sub-class method
+        settersToReport.add(mit);
+      }
+    }
+  }
+
+  private static boolean isExpectedSetter(MethodInvocationTree mit) {
+    return mit.arguments().size() == 1
+        && mit.symbol().isMethodSymbol()
+        && CLASSES.stream().anyMatch(mit.symbol().owner().type()::isSubtypeOf)
+        && SETTER_NAMES.contains(getIdentifier(mit).name());
+  }
+
+  private void updateIssuesToReport(MethodInvocationTree mit) {
+    MemberSelectExpressionTree mse = (MemberSelectExpressionTree) mit.methodSelect();
+    VariableSymbol reference = (VariableSymbol) ((IdentifierTree) mse.expression()).symbol();
+    if (setterArgumentHasCompliantValue(mit.arguments())) {
+      variablesToReport.remove(reference);
+    } else if (compliantConstructorInitializations.contains(reference)) {
+      variablesToReport.add(reference);
+    } else if (!variablesToReport.contains(reference)) {
+      settersToReport.add(mit);
+    }
+  }
+
+  private static boolean setterArgumentHasCompliantValue(Arguments arguments) {
+    ExpressionTree expressionTree = arguments.get(0);
+    return !LiteralUtils.isFalse(expressionTree);
+  }
+
+  private static IdentifierTree getIdentifier(MethodInvocationTree mit) {
+    IdentifierTree id;
+    if (mit.methodSelect().is(Tree.Kind.IDENTIFIER)) {
+      id = (IdentifierTree) mit.methodSelect();
+    } else {
+      id = ((MemberSelectExpressionTree) mit.methodSelect()).identifier();
+    }
+    return id;
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java
new file mode 100755
index 0000000000..267ee60c16
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java
@@ -0,0 +1,99 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.CheckForNull;
+import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.ConstantUtils;
+import org.sonar.java.checks.methods.AbstractMethodDetection;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S4426")
+public class CryptographicKeySizeCheck extends AbstractMethodDetection {
+
+  private static final String KEY_PAIR_GENERATOR = "java.security.KeyPairGenerator";
+  private static final String KEY_GENERATOR = "javax.crypto.KeyGenerator";
+  private static final String GET_INSTANCE_METHOD = "getInstance";
+  private static final String STRING = "java.lang.String";
+
+  @Override
+  protected List<MethodMatcher> getMethodInvocationMatchers() {
+    return ImmutableList.of(
+      MethodMatcher.create().typeDefinition(KEY_GENERATOR).name(GET_INSTANCE_METHOD).addParameter(STRING),
+      MethodMatcher.create().typeDefinition(KEY_PAIR_GENERATOR).name(GET_INSTANCE_METHOD).addParameter(STRING));
+  }
+
+  @Override
+  protected void onMethodInvocationFound(MethodInvocationTree mit) {
+    MethodTree methodTree = findEnclosingMethod(mit);
+    String getInstanceArg = ConstantUtils.resolveAsStringConstant(mit.arguments().get(0));
+    if (methodTree != null && getInstanceArg != null) {
+      MethodVisitor methodVisitor = new MethodVisitor(getInstanceArg);
+      methodTree.accept(methodVisitor);
+    }
+  }
+
+  @CheckForNull
+  public static MethodTree findEnclosingMethod(Tree tree) {
+    while (!tree.is(Tree.Kind.CLASS, Tree.Kind.METHOD)) {
+      tree = tree.parent();
+    }
+    if (tree.is(Tree.Kind.CLASS)) {
+      return null;
+    }
+    return (MethodTree) tree;
+  }
+
+  private class MethodVisitor extends BaseTreeVisitor {
+
+    private final String algorithm;
+
+    public MethodVisitor(String getInstanceArg) {
+      this.algorithm = getInstanceArg;
+    }
+
+    private final Map<String, Integer> algorithmKeySizeMap = ImmutableMap.of("Blowfish", 128, "RSA", 2048);
+
+    private final MethodMatcher keyGenInit = MethodMatcher.create().typeDefinition(KEY_GENERATOR).name("init").addParameter("int");
+    private final MethodMatcher keyPairGenInitialize = MethodMatcher.create().typeDefinition(KEY_PAIR_GENERATOR).name("initialize").addParameter("int");
+
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree mit) {
+      if (keyGenInit.matches(mit) || keyPairGenInitialize.matches(mit)) {
+        Integer minKeySize = algorithmKeySizeMap.get(this.algorithm);
+        if (minKeySize != null) {
+          Integer keySize = LiteralUtils.intLiteralValue(mit.arguments().get(0));
+          if (keySize != null && keySize < minKeySize) {
+            reportIssue(mit, "Use a key length of at least " + minKeySize + " bits.");
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.html
new file mode 100755
index 0000000000..7c898c5878
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.html
@@ -0,0 +1,23 @@
+<p>The <code>HttpOnly</code> cookie attribute tells the browser to prevent client-side scripts from reading cookies with the attribute, and its use
+can go a long way to defending against Cross-Site Scripting (XSS) attacks. Thus, as a precaution, the attribute should be set by default on all
+cookies set server-side, such as session id cookies.</p>
+<p>Setting the attribute can be done either programmatically, or globally via configuration files. </p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+Cookie cookie = new Cookie("myCookieName"); // Noncompliant; by default cookie.isHttpOnly() is returning false
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+Cookie cookie = new Cookie("myCookieName");
+cookie.setHttpOnly(true); // Compliant
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/79.html">CWE-79</a> - Improper Neutralization of Input During Web Page Generation ('Cross-site
+  Scripting') </li>
+  <li> <a href="https://cwe.mitre.org/data/definitions/1004.html">CWE-1004</a> - Sensitive Cookie Without 'HttpOnly' Flag </li>
+  <li> OWASP Top 10 2017 Category A7 - Cross-Site Scripting (XSS) </li>
+  <li> <a href="https://www.owasp.org/index.php/HttpOnly">OWASP HttpOnly</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE">HTTPONLY_COOKIE</a> </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.json
new file mode 100755
index 0000000000..8367951385
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3330_java.json
@@ -0,0 +1,23 @@
+{
+  "title": "\"HttpOnly\" should be set on cookies",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "10min"
+  },
+  "tags": [
+    "cwe",
+    "sans-top25-insecure",
+    "owasp-a7"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten",
+    "SANS Top 25"
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-3330",
+  "sqKey": "S3330",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html
new file mode 100755
index 0000000000..16e2d02b27
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html
@@ -0,0 +1,28 @@
+<p>When generating cryptograpic keys (or key pairs), it is important to use a key length that provides enough entropy against brute-force attacks. For
+the <code>Blowfish</code> algorithm the key should be at least 128 bits long, while for the <code>RSA</code> algorithm it should be at least 2048 bits
+long.</p>
+<p>This rule raises an issue when a Blowfish key generator, or RSA key-pair generator is initialized with too small a length parameter.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+keyGen.init(64); // Noncompliant
+
+KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
+keyPairGen.initialize(512); // Noncompliant
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+keyGen.init(128);
+
+KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
+keyPairGen.initialize(2048);
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE, CWE-326</a> - Inadequate Encryption Strength </li>
+  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#BLOWFISH_KEY_SIZE">BLOWFISH_KEY_SIZE</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#RSA_KEY_SIZE">RSA_KEY_SIZE</a> </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json
new file mode 100755
index 0000000000..23b227ba7b
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json
@@ -0,0 +1,21 @@
+{
+  "title": "Cryptographic keys should not be too short",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "2min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a3"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
+  "defaultSeverity": "Blocker",
+  "ruleSpecification": "RSPEC-4426",
+  "sqKey": "S4426",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
index 63d1716abc..77bbdfea8d 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
@@ -306,6 +306,7 @@
     "S4423",
     "S4424",
     "S4425",
+    "S4426",
     "S4432",
     "S4433",
     "S4434",
diff --git a/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java b/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
index dc9a120311..ee97eacd47 100755
--- a/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
+++ b/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
@@ -21,7 +21,7 @@
   @MyAnnotation(myName="foo", myInteger=2)
   @MyAnnotation2("defaultValue") // Noncompliant
   @MyAnnotation2("someValue")
-  @MyAnnotation3(myHexaInteger = 0x000) // false negative : unsupported reading of hexadecimal literal value.
+  @MyAnnotation3(myHexaInteger = 0x000) // Noncompliant {{Remove this default value assigned to parameter "myHexaInteger".}}
   @MyUnknownAnnotation("value")
   void goodMethod() {
 
diff --git a/java-checks/src/test/files/checks/AssertionsCompletenessCheck.java b/java-checks/src/test/files/checks/AssertionsCompletenessCheck.java
index 8c73c7680c..e0eb4b8940 100755
--- a/java-checks/src/test/files/checks/AssertionsCompletenessCheck.java
+++ b/java-checks/src/test/files/checks/AssertionsCompletenessCheck.java
@@ -8,7 +8,8 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
-import java.util.Stream;
+import java.util.OptionalInt;
+import java.util.stream.Stream;
 
 public class AssertionsCompletenessCheck {
 
diff --git a/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java b/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
index 392cf5a0c2..c72906cfd8 100755
--- a/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
+++ b/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
@@ -14,7 +14,7 @@
   long l2 = 0xFFFF_FFFF_FFFF_FFFFL;
   long l3;
   long l4 = 0x0000_0000_0000_0000L; // Noncompliant {{Remove this initialization to "0x0000_0000_0000_0000L", the compiler will do that for you.}}
-  long l5 = 0b00000000_00000000_00000000_00000000; // Know limitation, this 0 initialisation not supported
+  long l5 = 0b00000000_00000000_00000000_00000000; // Noncompliant {{Remove this initialization to "0b00000000_00000000_00000000_00000000", the compiler will do that for you.}}
   float f = 0; // Noncompliant {{Remove this initialization to "0", the compiler will do that for you.}}
   float f1 = 0.f; // Noncompliant {{Remove this initialization to "0.f", the compiler will do that for you.}}
   float f2 = 1.f;
diff --git a/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java b/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
index 3b3b33d63f..efae2ac8b2 100755
--- a/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
+++ b/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
@@ -24,5 +24,6 @@ void myMethod(int x, int y, int z) {
     for (int i = 1;      ; ) {}
     for (int i = 0; i < 0x10; ) {}
     for (int i = 0; i < 0b10; ) {}
+    for (int i = 1; i <= 0Xffff; i++) {}
   }
 }
diff --git a/java-checks/src/test/files/checks/HardcodedIpCheck.java b/java-checks/src/test/files/checks/HardcodedIpCheck.java
index d8cf740b77..c6322be244 100755
--- a/java-checks/src/test/files/checks/HardcodedIpCheck.java
+++ b/java-checks/src/test/files/checks/HardcodedIpCheck.java
@@ -1,6 +1,8 @@
 class A {
   String ip = "0.0.0.0"; // Noncompliant [[sc=15;ec=24]] {{Make this IP "0.0.0.0" address configurable.}}
+  String ipAndPort = "0.0.0.0:0"; // Noncompliant [[sc=22;ec=33]] {{Make this IP "0.0.0.0" address configurable.}}
   String url = "http://192.168.0.1/admin.html"; // Noncompliant {{Make this IP "192.168.0.1" address configurable.}}
+  String urlWithPort = "http://192.168.0.1:8000/admin.html"; // Noncompliant {{Make this IP "192.168.0.1" address configurable.}}
   String url2 = "http://www.example.org";
   int a = 42;
   String notAnIp1 = "0.0.0.1234";
diff --git a/java-checks/src/test/files/checks/InterruptedExceptionCheck.java b/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
index fe6db31270..487ce22ef8 100755
--- a/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
+++ b/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
@@ -32,6 +32,16 @@ public void runUnknownSymbol () {
     }
   }
 
+  public void catchUnionType () {
+    try {
+      while (true) {
+        // do stuff
+      }
+    } catch (InterruptedException | java.io.IOException e) { // Noncompliant [[sc=14;ec=58]] {{Either re-interrupt this method or rethrow the "InterruptedException".}}
+      unknownField.log(Level.WARN, "Interrupted!", e);
+    }
+  }
+
   public void run () throws InterruptedException{
     try {
       while (true) {
diff --git a/java-checks/src/test/files/checks/PrintfMisuseCheck.java b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
index 274c7f02e8..301ceabe96 100755
--- a/java-checks/src/test/files/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
@@ -2,10 +2,10 @@
 import java.io.PrintWriter;
 import java.text.FieldPosition;
 import java.text.MessageFormat;
+import java.util.Calendar;
 import java.util.Formatter;
 import java.util.GregorianCalendar;
 import java.util.Locale;
-import java.util.Calendar;
 
 class A {
   void foo(Calendar c){
@@ -98,7 +98,7 @@ void foo(Calendar c){
     MessageFormat.format("Result '{0}'", 14); // Noncompliant {{String contains no format specifiers.}}
     MessageFormat.format("Result ' {0}", 14);
     MessageFormat.format("Result {{{0}}.", 14);
-    MessageFormat.format("Result {0}!", myObject.toString()); // Noncompliant {{No need to call toString "method()" as formatting and string conversion is done by the Formatter.}}
+    MessageFormat.format("Result {0}!", myObject.toString()); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
     MessageFormat.format("Result {0}!", myObject.hashCode()); // Compliant
     MessageFormat.format("Result yeah!", 14); // Noncompliant {{String contains no format specifiers.}}
     MessageFormat.format("Result {1}!", 14);
@@ -119,7 +119,7 @@ void foo(Calendar c){
     logger.log(java.util.logging.Level.SEVERE, "Result '{0}'", 14); // Noncompliant {{String contains no format specifiers.}}
     logger.log(java.util.logging.Level.SEVERE, "Result ' {0}", 14);
     logger.log(java.util.logging.Level.SEVERE, "Result {{{0}}.", 14);
-    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.toString()); // Noncompliant {{No need to call toString "method()" as formatting and string conversion is done by the Formatter.}}
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.toString()); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
     logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.hashCode()); // Compliant
     logger.log(java.util.logging.Level.SEVERE, "Result yeah!", 14); // Noncompliant {{String contains no format specifiers.}}
     logger.log(java.util.logging.Level.SEVERE, "Result yeah!", new Exception()); // compliant, throwable parameter
@@ -131,6 +131,8 @@ void foo(Calendar c){
     logger.log(java.util.logging.Level.SEVERE, "{0,number,#.#}{1}", new Object[42]); // Compliant - Not considered
     logger.log(java.util.logging.Level.SEVERE, "value=\"'{'{0}'}'{1}\"", new Object[] {"value 1", "value 2"});
     logger.log(java.util.logging.Level.SEVERE, "value=\"{0}'{'{1}'}'\"", new Object[] {"value 1", "value 2"});
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", new Object[] {myObject.toString()}); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", new String[] {myObject.toString()}); // Noncompliant {{No need to call "toString()" method since an array of Objects can be used here.}}
 
     org.slf4j.Logger slf4jLog;
     org.slf4j.Marker marker;
diff --git a/java-checks/src/test/files/checks/SecureCookieCheck.java b/java-checks/src/test/files/checks/SecureCookieCheck.java
index 90d3565628..63e2af1f42 100755
--- a/java-checks/src/test/files/checks/SecureCookieCheck.java
+++ b/java-checks/src/test/files/checks/SecureCookieCheck.java
@@ -4,6 +4,8 @@
 
   Cookie cookie = new Cookie("name", "value");
 
+  private static final boolean FALSE_CONSTANT = false;
+
   void foo(Cookie cookie) {
     int age = cookie.getMaxAge();
   }
@@ -19,5 +21,14 @@ void qix() {
     Cookie cookie = new Cookie("name", "value"); // Noncompliant {{Add the "secure" attribute to this cookie}}
     cookie.setSecure(false);
   }
-
+  void baw(Cookie cookie) {
+    cookie.setSecure(false); // FN
+  }
+  void qiz() {
+    Cookie cookie = new Cookie("name", "value");
+    cookie.setSecure(FALSE_CONSTANT); // FN
+  }
+  Cookie qfn() {
+    return new Cookie("name", "value"); // FN
+  }
 }
diff --git a/java-checks/src/test/files/checks/security/CookieHttpOnlyCheck.java b/java-checks/src/test/files/checks/security/CookieHttpOnlyCheck.java
new file mode 100755
index 0000000000..2e2064affb
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/CookieHttpOnlyCheck.java
@@ -0,0 +1,212 @@
+import java.util.Date;
+import java.net.HttpCookie;
+import javax.servlet.http.Cookie;
+import javax.servlet.http.HttpServletResponse;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.core.NewCookie;
+import org.apache.shiro.web.servlet.SimpleCookie;
+import org.springframework.security.web.savedrequest.SavedCookie;
+import play.mvc.Http.CookieBuilder;
+
+class S3330 {
+
+  private static final boolean FALSE_CONSTANT = false;
+
+  Cookie field1 = new Cookie("name", "value"); // FN
+  HttpCookie field2 = new HttpCookie("name", "value"); // FN
+  javax.ws.rs.core.Cookie field3 = new javax.ws.rs.core.Cookie("name", "value"); // FN
+  Cookie field4;
+  HttpCookie field5;
+  Cookie field6;
+  UnknownCookie field7;
+
+  void servletCookie(boolean param, Cookie c0) {
+
+    c0.setHttpOnly(false); // Noncompliant [[sc=19;ec=26]] {{Add the "HttpOnly" cookie attribute.}}
+    field6.setHttpOnly(false); // Noncompliant
+    field7.setHttpOnly(false);
+
+    Cookie c1 = new Cookie("name", "value");
+    if (param) {
+      c1.setHttpOnly(false); // FN
+    }
+    else {
+      c1.setHttpOnly(true);
+    }
+
+    Cookie c2 = new Cookie("name", "value"); // Noncompliant [[sc=12;ec=14]]
+
+    Cookie c3 = new Cookie("name", "value"); // Noncompliant
+    c3.setHttpOnly(false);
+
+    Cookie c4 = new Cookie("name", "value");
+    c4.setHttpOnly(FALSE_CONSTANT); // FN, would require SE
+
+    Cookie c5 = new Cookie("name", "value");
+    boolean b = true;
+    c5.setHttpOnly(b); // FN, would require SE
+
+    Cookie c6 = new Cookie("name", "value");
+    c6.setHttpOnly(param);
+
+    Cookie c7 = new UnknownCookie("name", "value"); // Noncompliant
+    Object c8 = new Cookie("name", "value"); // Noncompliant
+
+    Cookie c9; // Noncompliant
+    c9 = new Cookie("name", "value");
+    c9.setHttpOnly(false);
+
+    Cookie c10;  // Noncompliant
+    c10 = new Cookie("name", "value");
+
+    Cookie c11;
+    c11 = new Cookie("name", "value");
+    c11.setHttpOnly(true);
+
+    Object c12; // Noncompliant
+    c12 = new Cookie("name", "value");
+
+    Cookie c13; // Noncompliant
+    c13 = new UnknownCookie("name", "value");
+
+    field4 = new Cookie("name, value"); // FN
+
+    X x;
+    x = new X("name", "value");
+  }
+
+  Cookie getC0() {
+    return new UnknownCookie("name", "value"); // FN
+  }
+
+  Cookie getC1() {
+    return new Cookie("name", "value"); // Noncompliant [[sc=12;ec=39]]
+  }
+
+  void httpCookie() {
+    HttpCookie c1 = new HttpCookie("name", "value");
+    c1.setHttpOnly(true);
+
+    HttpCookie c2 = new HttpCookie("name", "value"); // Noncompliant
+
+    HttpCookie c3 = new HttpCookie("name", "value"); // Noncompliant
+    c3.setHttpOnly(false);
+
+    HttpCookie c4 = new HttpCookie("name", "value");
+    c4.setHttpOnly(FALSE_CONSTANT); // FN, would require SE
+
+    HttpCookie c5; // Noncompliant
+    c5 = new HttpCookie("name", "value");
+    c3.setHttpOnly(false);
+
+    field5 = new HttpCookie("name, value"); // FN
+  }
+
+  HttpCookie getC2() {
+    return new HttpCookie("name", "value"); // Noncompliant
+  }
+
+  void jaxRsCookie() {
+    javax.ws.rs.core.Cookie c1 = new javax.ws.rs.core.Cookie("name", "value"); // Noncompliant
+    javax.ws.rs.core.Cookie c2 = new javax.ws.rs.core.Cookie("name", "value", "path", "domain"); // Noncompliant
+  }
+
+  void jaxRsNewCookie(javax.ws.rs.core.Cookie cookie) {
+    NewCookie c1 = new NewCookie("name", "value", "path", "domain", "comment", 1, true); // Noncompliant
+    NewCookie c2 = new NewCookie(cookie, "comment", 2, true); // Noncompliant
+    NewCookie c3 = new NewCookie(cookie); // Noncompliant
+    NewCookie c4 = new NewCookie(cookie, "c", 1, true); // Noncompliant
+
+    NewCookie c5 = new NewCookie(cookie, "c", 1, new Date(), false, true); // last param is HttpOnly
+    NewCookie c6 = new NewCookie("1", "2", "3", "4", 5, "6", 7, new Date(), false, true);
+    NewCookie c7 = new NewCookie("1", "2", "3", "4", "5", 6, false, true);
+  }
+
+  NewCookie getC3() {
+    return new NewCookie("name", "value", "path", "domain", "comment", 1, true); // Noncompliant
+  }
+
+  void apacheShiro(SimpleCookie unknownCookie) {
+    SimpleCookie c1 = new SimpleCookie(unknownCookie); // Noncompliant
+    SimpleCookie c2 = new SimpleCookie(); // Noncompliant
+    c2.setHttpOnly(false);
+    SimpleCookie c3 = new SimpleCookie(); // Apache Shiro cookies have HttpOnly 'true' value by default
+    SimpleCookie c4 = new SimpleCookie("name");
+  }
+
+  SimpleCookie getC4() {
+    return new SimpleCookie(); // compliant
+  }
+
+  void playFw() {
+    play.mvc.Http.Cookie c1 = new play.mvc.Http.Cookie("1", "2", 3, "4", "5", true, false); // Noncompliant
+    play.mvc.Http.Cookie c2 = new play.mvc.Http.Cookie("1", "2", 3, "4", "5", true, true);
+    CookieBuilder cb1 = Cookie.builder("1", "2");
+    cb1.withHttpOnly(false); // Noncompliant
+    cb1.withHttpOnly(true); // is ignored, so above is a FN
+    CookieBuilder cb2 = Cookie.builder("1", "2");
+    cb2.withHttpOnly(true);
+    play.mvc.Http.Cookie.builder("1", "2")
+        .withMaxAge(1)
+        .withPath("x")
+        .withDomain("x")
+        .withSecure(true)
+        .withHttpOnly(false) // Noncompliant
+        .build();
+    play.mvc.Http.Cookie.builder("theme", "blue").withHttpOnly(true);
+  }
+
+  play.mvc.Http.Cookie getC5() {
+    return new play.mvc.Http.Cookie("1", "2", 3, "4", "5", true, false); // Noncompliant
+  }
+
+  play.mvc.Http.Cookie getC6() {
+    return play.mvc.Http.Cookie.builder("theme", "blue").withHttpOnly(false); // Noncompliant
+  }
+
+  void compliant(Cookie c1, HttpCookie c2, javax.ws.rs.core.Cookie c3, NewCookie c4, SimpleCookie c5) {
+    c1.isHttpOnly();
+    c2.isHttpOnly();
+    c3.isHttpOnly();
+    c4.isHttpOnly();
+    c5.isHttpOnly();
+    SavedCookie c6 = new SavedCookie(c1); // Spring cookies are HttpOnly, without possibility to change that
+    SavedCookie c7 = new SavedCookie("n", "v", "c", "d", 1, "p", false, 1);
+  }
+
+  SavedCookie getC7() {
+    return new SavedCookie("n", "v", "c", "d", 1, "p", false, 1); // compliant
+  }
+}
+
+class A extends Cookie {
+  public Cookie c;
+  public void setHttpOnly(boolean isHttpOnly) { }
+  void foo() {
+    setHttpOnly(false); // Noncompliant
+  }
+  void bar(boolean x) {
+    setHttpOnly(x);
+  }
+  void baz() {
+    setHttpOnly(true);
+  }
+}
+
+class B {
+  A a;
+  public void setHttpOnly(boolean isHttpOnly) { }
+  void foo() {
+    setHttpOnly(false);
+  }
+  void bar() { return; }
+  A getA() {
+    return new A(); // Noncompliant
+  }
+  void baw() {
+    int i;
+    i = 1;
+    a.c = new Cookie("1", "2"); // FN
+    unknown = new A("1", "2");
+  }
+}
diff --git a/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java
new file mode 100755
index 0000000000..15c53c3123
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java
@@ -0,0 +1,110 @@
+import B.Blowfish;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.KeyGenerator;
+
+class Blowfish {
+
+  KeyGenerator keyG;
+  private static final Integer CONSTANT_INT = 64;
+
+  public Blowfish() throws NoSuchAlgorithmException {
+    keyG = KeyGenerator.getInstance("Blowfish");
+  }
+
+  public void key_variable() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant [[sc=5;ec=20]] {{Use a key length of at least 128 bits.}}
+  }
+
+  public void key_variable_compliant() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(128); // Compliant
+  }
+
+  public void identifier_parameter() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    int x = 64;
+    keyGen.init(x); // FN requires following variable's values with SE-based engine
+  }
+
+  public void identifier_parameter2() throws NoSuchAlgorithmException {
+    String algorithm = "Blowfish";
+    KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);
+    keyGen.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void key_assignment() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen;
+    keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant {{Use a key length of at least 128 bits.}}
+  }
+
+  public void key_assignment_compliant() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen;
+    keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(128); // Compliant
+  }
+
+  public void false_negative() {
+    keyG.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void different_algorithm() throws NoSuchAlgorithmException {
+    keyG = KeyGenerator.getInstance("AES");
+    keyG.init(64); // Compliant
+  }
+
+  private KeyGenerator createGen() throws NoSuchAlgorithmException {
+    return KeyGenerator.getInstance("Blowfish");
+  }
+
+  public void false_negative2() throws NoSuchAlgorithmException {
+    keyG = createGen();
+    keyG.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void lambda_expr() {
+    Runnable task2 = () -> {
+      KeyGenerator keyGen;
+      try {
+        keyGen = KeyGenerator.getInstance("Blowfish");
+        keyGen.init(64); // Noncompliant
+      } catch (NoSuchAlgorithmException e) {
+        e.printStackTrace();
+      }
+    };
+  }
+
+  public void anonymous_class() {
+    new Runnable() {
+      @Override
+      public void run() {
+        KeyGenerator keyGen;
+        try {
+          keyGen = KeyGenerator.getInstance("Blowfish");
+          keyGen.init(64); // Noncompliant
+        } catch (NoSuchAlgorithmException e) {
+          e.printStackTrace();
+        }
+      }
+    };
+  }
+
+  public void false_positive() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("AES");
+    KeyGenerator keyGen2 = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant FP
+  }
+
+  public void constant_key_value() {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(CONSTANT_INT); // FN requires following variable's values with SE-based engine
+  }
+
+  public void big_key_value() {
+    KeyGenerator keyG;
+    keyG = KeyGenerator.getInstance("Blowfish");
+    keyG.init(256); // Compliant
+  }
+}
diff --git a/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java
new file mode 100755
index 0000000000..b9cbc53836
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java
@@ -0,0 +1,22 @@
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.KeyGenerator;
+
+class RSA {
+
+  public void key_variable() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(1024); // Noncompliant [[sc=5;ec=28]]  {{Use a key length of at least 2048 bits.}}
+  }
+
+  public void key_variable_compliant() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(2048); // Compliant
+  }
+
+  public void report_twice() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(1024); // Noncompliant
+    keyGen.initialize(1023); // Noncompliant
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/security/CookieHttpOnlyCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/security/CookieHttpOnlyCheckTest.java
new file mode 100755
index 0000000000..58935b0640
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/security/CookieHttpOnlyCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class CookieHttpOnlyCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/CookieHttpOnlyCheck.java", new CookieHttpOnlyCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/CookieHttpOnlyCheck.java", new CookieHttpOnlyCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java
new file mode 100755
index 0000000000..1cc7d8ff3b
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java
@@ -0,0 +1,42 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class CryptographicKeySizeCheckTest {
+
+  @Test
+  public void test_RSA() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java", new CryptographicKeySizeCheck());
+  }
+
+  @Test
+  public void test_Blowfish() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java", new CryptographicKeySizeCheck());
+  }
+
+  @Test
+  public void test_no_semantic() {
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java", new CryptographicKeySizeCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java", new CryptographicKeySizeCheck());
+  }
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
index 4b0fd08167..9024084720 100755
--- a/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
@@ -43,6 +43,7 @@
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.AnnotationTree;
+import org.sonar.plugins.java.api.tree.Arguments;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
@@ -52,6 +53,7 @@
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.ReturnStatementTree;
 import org.sonar.plugins.java.api.tree.SyntaxToken;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -68,6 +70,7 @@
 import static org.sonar.plugins.java.api.tree.Tree.Kind.CONSTRUCTOR;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.MEMBER_SELECT;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD_INVOCATION;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.NEW_CLASS;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS_ASSIGNMENT;
 import static org.sonar.ucfg.UCFGBuilder.call;
@@ -224,6 +227,9 @@ private void buildCall(Tree element, UCFGBuilder.BlockBuilder blockBuilder, Iden
     if (element.is(METHOD_INVOCATION)) {
       MethodInvocationTree methodInvocationTree = (MethodInvocationTree) element;
       buildMethodInvocation(blockBuilder, idGenerator, methodInvocationTree);
+    } else if (element.is(NEW_CLASS)) {
+      NewClassTree newClassTree = (NewClassTree) element;
+      buildConstructorInvocation(blockBuilder, idGenerator, newClassTree);
     } else if (element.is(PLUS, PLUS_ASSIGNMENT, ASSIGNMENT) && isString(((ExpressionTree) element).symbolType())) {
       if (element.is(PLUS)) {
         BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) element;
@@ -248,35 +254,48 @@ private void buildCall(Tree element, UCFGBuilder.BlockBuilder blockBuilder, Iden
     }
   }
 
-  private void buildMethodInvocation(UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator, MethodInvocationTree mit) {
-    if (mit.symbol().isUnknown()) {
+  private void buildConstructorInvocation(BlockBuilder blockBuilder, IdentifierGenerator idGenerator, NewClassTree tree) {
+    Symbol constructorSymbol = tree.constructorSymbol();
+    if (constructorSymbol.isUnknown()) {
       return;
     }
 
-    List<String> arguments = null;
+    if(isString(constructorSymbol.owner().type()) || tree.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
+      List<Expression> arguments = argumentIds(idGenerator, tree.arguments());
+      buildAssignCall(blockBuilder, idGenerator, arguments, tree, (Symbol.MethodSymbol) constructorSymbol);
+    }
+  }
+
+  private void buildMethodInvocation(UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator, MethodInvocationTree tree) {
+    if (tree.symbol().isUnknown()) {
+      return;
+    }
+
+    List<Expression> arguments = null;
 
-    if (isString(mit.symbol().owner().type())) {
+    if (isString(tree.symbol().owner().type())) {
       // myStr.myMethod(args) -> myMethod(myStr, args)
       arguments = new ArrayList<>();
-      if (mit.methodSelect().is(MEMBER_SELECT)) {
-        arguments.add(idGenerator.lookupIdFor(((MemberSelectExpressionTree) mit.methodSelect()).expression()));
+      if (tree.methodSelect().is(MEMBER_SELECT)) {
+        arguments.add(idGenerator.lookupExpressionFor(((MemberSelectExpressionTree) tree.methodSelect()).expression()));
       }
-      arguments.addAll(argumentIds(idGenerator, mit));
-    } else if (isString(mit.symbolType()) || mit.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
-      arguments = argumentIds(idGenerator, mit);
+      arguments.addAll(argumentIds(idGenerator, tree.arguments()));
+    } else if (isString(tree.symbolType()) || tree.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
+      arguments = argumentIds(idGenerator, tree.arguments());
     }
 
     if (arguments != null) {
-      String destination = idGenerator.newIdFor(mit);
-      blockBuilder.assignTo(variableWithId(destination),
-        UCFGBuilder.call(signatureFor((Symbol.MethodSymbol) mit.symbol()))
-          .withArgs(arguments.stream().map(UCFGBuilder::variableWithId).toArray(Expression.Variable[]::new)),
-        location(mit));
+      buildAssignCall(blockBuilder, idGenerator, arguments, tree, (Symbol.MethodSymbol) tree.symbol());
     }
   }
 
-  private static List<String> argumentIds(IdentifierGenerator idGenerator, MethodInvocationTree mit) {
-    return mit.arguments().stream().map(idGenerator::lookupIdFor).collect(Collectors.toList());
+  private void buildAssignCall(BlockBuilder blockBuilder, IdentifierGenerator idGenerator,  List<Expression> arguments, Tree tree, Symbol.MethodSymbol symbol) {
+    String destination = idGenerator.newIdFor(tree);
+    blockBuilder.assignTo(variableWithId(destination), UCFGBuilder.call(signatureFor(symbol)).withArgs(arguments.toArray(new Expression[0])), location(tree));
+  }
+
+  private static List<Expression> argumentIds(IdentifierGenerator idGenerator, Arguments arguments) {
+    return arguments.stream().map(idGenerator::lookupExpressionFor).collect(Collectors.toList());
   }
 
   private static String signatureFor(Symbol.MethodSymbol methodSymbol) {
diff --git a/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java b/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
index 30e7b8540d..ede19d6830 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
@@ -50,10 +50,10 @@ public static Integer intLiteralValue(ExpressionTree expression) {
   @CheckForNull
   private static Integer intLiteralValue(LiteralTree literal) {
     String literalValue = literal.value().replaceAll("_", "");
-    if (literalValue.startsWith("0x") || literalValue.startsWith("0b")) {
-      return null;
+    if (literalValue.startsWith("0b") || literalValue.startsWith("0B")) {
+      return Integer.valueOf(literalValue.substring(2), 2);
     }
-    return Integer.valueOf(literalValue);
+    return Integer.decode(literalValue);
   }
 
   @CheckForNull
@@ -70,6 +70,9 @@ public static Long longLiteralValue(ExpressionTree tree) {
       // long as hexadecimal can be written using underscore to separate groups
       value = value.replaceAll("\\_", "");
       try {
+        if (value.startsWith("0b") || value.startsWith("0B")) {
+          return sign * Long.valueOf(value.substring(2), 2);
+        }
         return sign * Long.decode(value);
       } catch (NumberFormatException e) {
         // Long.decode() may fail in case of very large long number written in hexadecimal. In such situation, we ignore the number.
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
index 11eaca23b4..d9eec87c59 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
@@ -109,6 +109,15 @@ private void complete(JavaSymbol.TypeJavaSymbol symbol) {
 
     if ((symbol.flags() & Flags.INTERFACE) == 0) {
       symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type.supertype, symbol));
+    } else {
+      // JLS9 - 15.12.1 : Used in form 'TypeName.super.foo()', where 'TypeName' is an interface. To support invocation
+      // of default methods from super-interfaces, 'TypeName' may also refer to a direct super-interface of the current
+      // class or interface. The method being invoked ('foo()') has to be searched in that super-interface.
+      symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type, symbol));
+      // Note: The above "super" symbol will always be qualified when referenced. e.g. A.super.hashCode()
+      // because it's a compilation error to use unqualified "super" in default method. e.g. super.hashCode()
+      // Note: interface/class can extend/implement multiple interfaces containing default methods with the same
+      // signature. Mentioning the super-interfaces explicitly removes any ambiguity.
     }
 
     // Register default constructor
diff --git a/java-frontend/src/test/files/sym/references/SuperMethodCall.java b/java-frontend/src/test/files/sym/references/SuperMethodCall.java
new file mode 100755
index 0000000000..d63f9289f4
--- /dev/null
+++ b/java-frontend/src/test/files/sym/references/SuperMethodCall.java
@@ -0,0 +1,30 @@
+public interface A {
+  default String f() {
+    return "A";
+  }
+}
+
+public interface B {
+  default String f() {
+    return "B";
+  }
+}
+
+public class C {
+  public String f() {
+    return "C";
+  }
+}
+
+public class D extends C implements A, B {
+  public void call() {
+    f();
+  }
+  @Override
+  public String f() {
+    return super.f() +
+           A.super.f() +
+           B.super.f();
+  }
+
+}
diff --git a/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
index aa1f7c4a03..460c881739 100755
--- a/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
@@ -23,6 +23,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import org.junit.BeforeClass;
@@ -405,6 +406,34 @@ protected void serializeUCFG(MethodTree tree, CFG cfg) {
     UCFGJavaVisitor.scanFile(context);
   }
 
+  @Test
+  public void null_literal_should_produce_a_constant_expression() {
+    UCFG ucfg = createUCFG("class A {String foo(String s) {return foo(null);}}");
+    BasicBlock basicBlock = ucfg.entryBlocks().iterator().next();
+    Expression argExpression = basicBlock.calls().get(0).getArgExpressions().get(0);
+    assertThat(argExpression.isConstant()).isTrue();
+  }
+
+  @Test
+  public void string_literal_should_produce_a_constant_expression() {
+    UCFG ucfg = createUCFG("class A {String foo(String s) {return foo(\"plop\");}}");
+    BasicBlock basicBlock = ucfg.entryBlocks().iterator().next();
+    Expression argExpression = basicBlock.calls().get(0).getArgExpressions().get(0);
+    assertThat(argExpression.isConstant()).isTrue();
+  }
+
+  @Test
+  public void constructors_should_have_a_ucfg() {
+    UCFG ucfg = createUCFG("class A { Object foo(String s) {new A(s); new Object(); new Unknown(\"\"); return new String();} A(String s) {} }");
+    assertThat(ucfg.methodId()).isEqualTo("A#foo(Ljava/lang/String;)Ljava/lang/Object;");
+    List<Instruction.AssignCall> calls = ucfg.entryBlocks().iterator().next().calls();
+    assertThat(calls).hasSize(2);
+    Instruction.AssignCall assignCall0 = calls.get(0);
+    assertThat(assignCall0.getMethodId()).isEqualTo("A#<init>(Ljava/lang/String;)V");
+    Instruction.AssignCall assignCall1 = calls.get(1);
+    assertThat(assignCall1.getMethodId()).isEqualTo("java.lang.String#<init>()V");
+  }
+
   private CompilationUnitTree getCompilationUnitTreeWithSemantics(String source) {
     CompilationUnitTree cut = (CompilationUnitTree) JavaParser.createParser().parse(source);
     SemanticModel.createFor(cut, squidClassLoader);
diff --git a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
index 213f58b6d0..8408e3aa5b 100755
--- a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
@@ -70,6 +70,8 @@ public static void setUp() {
   int x6 = 0xff;
   int x7 = 0b0100;
   int x8 = 56_78;
+  int x9 = 0XFF;
+  int x10 = 0B1100110;
 
   long y1 = 42;
   long y2 = 42L;
@@ -87,6 +89,8 @@ public static void setUp() {
   long y14 = 0x7FFF_FFFF_FFFF_FFFFL;
   long y15 = 0b11010010_01101001_10010100_10010010;
   long y16 = 100_10;
+  long y17 = 0XFFL;
+  long y18 = 0B1100110L;
 
   String s1 = "";
   String s2 = " ";
@@ -104,8 +108,9 @@ public void private_constructor() throws Exception {
 
   @Test
   public void test_int_and_long_value() throws Exception {
-    Integer[] expectedIntegerValues = {42, -7, 3, null, null, null, null, 5678};
-    Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 255L, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, null, 10010L};
+    Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110};
+    Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null,
+      Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 0b1100110L};
     int i = 0;
     int j = 0;
 
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
index 56943d84d3..6adc95ff8d 100755
--- a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
@@ -383,7 +383,7 @@ public void InterfaceDeclaration() {
       result.symbol("FirstInterface").type,
       result.symbol("SecondInterface").type);
     assertThat(interfaceSymbol.members.lookup("this")).hasSize(1);
-    assertThat(interfaceSymbol.members.lookup("super")).isEmpty();
+    assertThat(interfaceSymbol.members.lookup("super")).hasSize(1);
 
     JavaSymbol.VariableJavaSymbol variableSymbol = (JavaSymbol.VariableJavaSymbol) result.symbol("FIRST_CONSTANT");
     assertThat(variableSymbol.owner()).isSameAs(interfaceSymbol);
@@ -1110,6 +1110,42 @@ public void MethodCall() {
 
   }
 
+  @Test
+  public void SuperMethodCall() {
+    Result result = Result.createFor("references/SuperMethodCall");
+
+    JavaSymbol fOfD = result.reference(21, 5);
+    assertThat(fOfD.name()).isEqualTo("f");
+    assertThat(fOfD.owner().name()).isEqualTo("D");
+
+    JavaSymbol superOfD = result.reference(25, 12);
+    assertThat(superOfD.name()).isEqualTo("super");
+    assertThat(superOfD.isVariableSymbol()).isTrue();
+    assertThat(superOfD.type().fullyQualifiedName()).isEqualTo("C");
+    assertThat(superOfD.owner().name()).isEqualTo("D");
+
+    JavaSymbol fOfC = result.reference(25, 18);
+    assertThat(fOfC.name()).isEqualTo("f");
+    assertThat(fOfC.owner().name()).isEqualTo("C");
+
+    JavaSymbol refA = result.reference(26, 12);
+    assertThat(refA.name()).isEqualTo("A");
+    assertThat(refA.isTypeSymbol()).isTrue();
+
+    JavaSymbol superOfA = result.reference(26, 14);
+    assertThat(superOfA.name()).isEqualTo("super");
+    assertThat(superOfA.isVariableSymbol()).isTrue();
+    assertThat(superOfA.type().fullyQualifiedName()).isEqualTo("A");
+
+    JavaSymbol fOfA = result.reference(26, 20);
+    assertThat(fOfA.name()).isEqualTo("f");
+    assertThat(fOfA.owner().name()).isEqualTo("A");
+
+    JavaSymbol fOfB = result.reference(27, 20);
+    assertThat(fOfB.name()).isEqualTo("f");
+    assertThat(fOfB.owner().name()).isEqualTo("B");
+  }
+
   @Test
   public void FieldTypes() {
     Result result = Result.createFor("FieldTypes");
