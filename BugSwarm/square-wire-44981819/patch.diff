diff --git a/checkstyle.xml b/checkstyle.xml
index ab2b00bb5b..285c6bc2b2 100755
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -65,10 +65,6 @@
       <property name="max" value="100"/>
     </module>
     <module name="MethodLength"/>
-    <module name="ParameterNumber">
-      <property name="max" value="10"/>
-      <property name="tokens" value="CTOR_DEF"/>
-    </module>
 
 
     <!-- Checks for whitespace                               -->
diff --git a/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java b/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java
new file mode 100755
index 0000000000..1e70b7227d
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java
@@ -0,0 +1,168 @@
+package com.squareup.wire;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Scanner;
+import java.util.Set;
+
+final class CommandLineOptions {
+  public static final String PROTO_PATH_FLAG = "--proto_path=";
+  public static final String JAVA_OUT_FLAG = "--java_out=";
+  public static final String FILES_FLAG = "--files=";
+  public static final String ROOTS_FLAG = "--roots=";
+  public static final String REGISTRY_CLASS_FLAG = "--registry_class=";
+  public static final String NO_OPTIONS_FLAG = "--no_options";
+  public static final String ENUM_OPTIONS_FLAG = "--enum_options=";
+  public static final String SERVICE_WRITER_FLAG = "--service_writer=";
+  public static final String SERVICE_WRITER_OPT_FLAG = "--service_writer_opt=";
+  public static final String QUIET_FLAG = "--quiet";
+  public static final String DRY_RUN_FLAG = "--dry_run";
+
+  final String protoPath;
+  final String javaOut;
+  final List<String> sourceFileNames;
+  final List<String> roots;
+  final String registryClass;
+  final boolean emitOptions;
+  final Set<String> enumOptions;
+  final String serviceWriter;
+  final List<String> serviceWriterOptions;
+  final boolean quiet;
+  final boolean dryRun;
+
+  CommandLineOptions(String protoPath, String javaOut,
+      List<String> sourceFileNames, List<String> roots,
+      String registryClass, boolean emitOptions,
+      Set<String> enumOptions,
+      String serviceWriter,
+      List<String> serviceWriterOptions,
+      boolean quiet,
+      boolean dryRun) {
+    this.protoPath = protoPath;
+    this.javaOut = javaOut;
+    this.sourceFileNames = sourceFileNames;
+    this.roots = roots;
+    this.registryClass = registryClass;
+    this.emitOptions = emitOptions;
+    this.enumOptions = enumOptions;
+    this.serviceWriter = serviceWriter;
+    this.serviceWriterOptions = serviceWriterOptions;
+    this.quiet = quiet;
+    this.dryRun = dryRun;
+  }
+
+  /**
+   * Usage:
+   *
+   * <pre>
+   * java WireCompiler --proto_path=&lt;path&gt; --java_out=&lt;path&gt;
+   *     [--files=&lt;protos.include&gt;] [--roots=&lt;message_name&gt;[,&lt;message_name&gt;...]]
+   *     [--registry_class=&lt;class_name&gt;] [--no_options]
+   *     [--enum_options=&lt;option_name&gt;[,&lt;option_name&gt;...]]
+   *     [--service_writer=&lt;class_name&gt;]
+   *     [--service_writer_opt=&lt;value&gt;] [--service_writer_opt=&lt;value&gt;]...]
+   *     [--quiet] [--dry_run]
+   *     [file [file...]]
+   * </pre>
+   *
+   * If the {@code --roots} flag is present, its argument must be a comma-separated list
+   * of fully-qualified message or enum names. The output will be limited to those messages
+   * and enums that are (transitive) dependencies of the listed names.  If you are using
+   * {@code --service_writer} to generate an interface for a Service, your roots can also take the
+   * form 'fully.qualified.Service#MethodName` to limit what endpoints are generated.
+   * <p>
+   * If the {@code --registry_class} flag is present, its argument must be a Java class name. A
+   * class with the given name will be generated, containing a constant list of all extension
+   * classes generated during the compile. This list is suitable for passing to Wire's constructor
+   * at runtime for constructing its internal extension registry.
+   * <p>
+   * Unless the {@code --no_options} flag is supplied, code will be emitted for options on messages
+   * and fields.  The presence of options on a message will result in a static member named
+   * "MESSAGE_OPTIONS", initialized with the options and their values.   The presence of options on
+   * a field (other than the standard options "default", "deprecated", and "packed") will result in
+   * a static member named "FIELD_OPTIONS_&lt;field name&gt;" in the generated code, initialized
+   * with the field option values.
+   * <p>
+   * Regardless of the value of the {@code --no_options} flag, code will be emitted for all
+   * enum value options listed in the {@code --enum_options} flag. The resulting code will contain
+   * a public static field for each option used within a particular enum type.
+   * </p>
+   * <p>
+   * If {@code --quiet} is specified, diagnostic messages to stdout are suppressed.
+   * </p>
+   * <p>
+   * The {@code --dry_run} flag causes the compile to just emit the names of the source files that
+   * would be generated to stdout.
+   */
+  CommandLineOptions(String... args) throws WireException {
+    int index = 0;
+
+    List<String> sourceFileNames = new ArrayList<String>();
+    List<String> serviceWriterOptions = new ArrayList<String>();
+    List<String> roots = new ArrayList<String>();
+    boolean emitOptions = true;
+    String protoPath = null;
+    String javaOut = null;
+    String registryClass = null;
+    List<String> enumOptionsList = new ArrayList<String>();
+    String serviceWriter = null;
+    boolean quiet = false;
+    boolean dryRun = false;
+
+    while (index < args.length) {
+      if (args[index].startsWith(PROTO_PATH_FLAG)) {
+        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
+      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
+        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
+      } else if (args[index].startsWith(FILES_FLAG)) {
+        File files = new File(args[index].substring(FILES_FLAG.length()));
+        String[] fileNames;
+        try {
+          fileNames = new Scanner(files, "UTF-8").useDelimiter("\\A").next().split("\n");
+        } catch (FileNotFoundException ex) {
+          throw new WireException("Error processing argument " + args[index], ex);
+        }
+        sourceFileNames.addAll(Arrays.asList(fileNames));
+      } else if (args[index].startsWith(ROOTS_FLAG)) {
+        roots.addAll(splitArg(args[index], ROOTS_FLAG.length()));
+      } else if (args[index].startsWith(REGISTRY_CLASS_FLAG)) {
+        registryClass = args[index].substring(REGISTRY_CLASS_FLAG.length());
+      } else if (args[index].equals(NO_OPTIONS_FLAG)) {
+        emitOptions = false;
+      } else if (args[index].startsWith(ENUM_OPTIONS_FLAG)) {
+        enumOptionsList.addAll(splitArg(args[index], ENUM_OPTIONS_FLAG.length()));
+      } else if (args[index].startsWith(SERVICE_WRITER_FLAG)) {
+        serviceWriter = args[index].substring(SERVICE_WRITER_FLAG.length());
+      } else if (args[index].startsWith(SERVICE_WRITER_OPT_FLAG)) {
+        serviceWriterOptions.add(args[index].substring(SERVICE_WRITER_OPT_FLAG.length()));
+      } else if (args[index].startsWith(QUIET_FLAG)) {
+        quiet = true;
+      } else if (args[index].startsWith(DRY_RUN_FLAG)) {
+        dryRun = true;
+      } else {
+        sourceFileNames.add(args[index]);
+      }
+      index++;
+    }
+
+    this.protoPath = protoPath;
+    this.javaOut = javaOut;
+    this.sourceFileNames = sourceFileNames;
+    this.roots = roots;
+    this.registryClass = registryClass;
+    this.emitOptions = emitOptions;
+    this.enumOptions = new LinkedHashSet<String>(enumOptionsList);
+    this.serviceWriter = serviceWriter;
+    this.serviceWriterOptions = serviceWriterOptions;
+    this.quiet = quiet;
+    this.dryRun = dryRun;
+  }
+
+  private static List<String> splitArg(String arg, int flagLength) {
+    return Arrays.asList(arg.substring(flagLength).split(","));
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/IO.java b/wire-compiler/src/main/java/com/squareup/wire/IO.java
index f78f185f20..5e801520ca 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/IO.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/IO.java
@@ -5,9 +5,6 @@
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.ProtoSchemaParser;
 
-import com.squareup.wire.logger.WireLogger;
-import com.squareup.wire.logger.WireLoggerFactory;
-import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -39,7 +36,6 @@ JavaWriter getJavaWriter(OutputArtifact outputArtifact)
    * Concrete implementation of the IO interface that proxies to the file system.
    */
   class FileIO implements IO {
-    private static final WireLogger log = WireLoggerFactory.get();
     private static final Charset UTF_8 = Charset.forName("UTF8");
 
     @Override
@@ -51,14 +47,8 @@ public ProtoFile parse(String filename) throws IOException {
     @Override
     public JavaWriter getJavaWriter(OutputArtifact artifact)
         throws IOException {
-      File directory = artifact.getArtifactDir();
-      boolean created = directory.mkdirs();
-      if (created) {
-        log.info("Created output directory " + directory);
-      }
-
-      File outputFile = artifact.getArtifactFile();
-      return new JavaWriter(new OutputStreamWriter(new FileOutputStream(outputFile), UTF_8));
+      artifact.dir().mkdirs();
+      return new JavaWriter(new OutputStreamWriter(new FileOutputStream(artifact.file()), UTF_8));
     }
   }
 }
diff --git a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
index 74d9c36508..defdf54662 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
@@ -94,7 +94,8 @@ public void emitHeader(JavaWriter writer, Set<String> imports,
     }
   }
 
-  public void emitType(JavaWriter writer, Type type, String currentType, Map<String, ?> optionsMap, boolean topLevel)
+  public void emitType(JavaWriter writer, Type type, String currentType, Map<String, ?> optionsMap,
+      boolean topLevel)
       throws IOException {
     writer.emitEmptyLine();
     if (type instanceof MessageType) {
@@ -238,7 +239,8 @@ private String join(List<String> values, String separator) {
     return sb.toString();
   }
 
-  private void emitAll(JavaWriter writer, MessageType messageType, Map<String, ?> optionsMap, boolean topLevel)
+  private void emitAll(JavaWriter writer, MessageType messageType, Map<String, ?> optionsMap,
+      boolean topLevel)
       throws IOException {
     Set<Modifier> modifiers = EnumSet.of(PUBLIC, FINAL);
     if (!topLevel) {
@@ -256,8 +258,8 @@ private void emitAll(JavaWriter writer, MessageType messageType, Map<String, ?>
     }
     emitMessageFieldDefaults(writer, messageType);
     emitMessageFields(writer, messageType);
-    emitMessageFieldsConstructor(writer,messageType);
-    emitMessageBuilderConstructor(writer,messageType);
+    emitMessageFieldsConstructor(writer, messageType);
+    emitMessageBuilderConstructor(writer, messageType);
     emitMessageEquals(writer, messageType);
     emitMessageHashCode(writer, messageType);
     emitBuilder(writer, messageType);
@@ -301,7 +303,8 @@ private void emitEnumOptions(JavaWriter writer, Map<String, ?> optionsMap) throw
     }
   }
 
-  private void emitMessageFieldOptions(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitMessageFieldOptions(JavaWriter writer, MessageType messageType)
+      throws IOException {
     Map<String, List<Option>> fieldOptions = new LinkedHashMap<String, List<Option>>();
 
     for (Field field : messageType.getFields()) {
@@ -329,7 +332,8 @@ private void emitMessageFieldOptions(JavaWriter writer, MessageType messageType)
     }
   }
 
-  private void emitFieldOptions(JavaWriter writer, String fieldName, Map<String, ?> optionsMap) throws IOException {
+  private void emitFieldOptions(JavaWriter writer, String fieldName, Map<String, ?> optionsMap)
+      throws IOException {
     if (optionsMap == null) return;
 
     StringBuilder sb = new StringBuilder();
@@ -354,7 +358,8 @@ private void emitFieldOptions(JavaWriter writer, String fieldName, Map<String, ?
   //
   // public static final Integer DEFAULT_OPT_INT32 = 123;
   //
-  private void emitMessageFieldDefaults(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitMessageFieldDefaults(JavaWriter writer, MessageType messageType)
+      throws IOException {
     List<Field> defaultFields = new ArrayList<Field>();
     for (Field field : messageType.getFields()) {
       // Message types cannot have defaults
@@ -450,7 +455,8 @@ private void emitMessageFields(JavaWriter writer, MessageType messageType) throw
   //   this.optional_int64 = optional_int64;
   // }
   //
-  private void emitMessageFieldsConstructor(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitMessageFieldsConstructor(JavaWriter writer, MessageType messageType)
+      throws IOException {
     List<String> params = new ArrayList<String>();
     for (Field field : messageType.getFields()) {
       String javaName = getJavaFieldType(messageType, field);
@@ -478,7 +484,8 @@ private void emitMessageFieldsConstructor(JavaWriter writer, MessageType message
   //   setBuilder(builder);
   // }
   //
-  private void emitMessageBuilderConstructor(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitMessageBuilderConstructor(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.beginMethod(null, messageType.getName(), EnumSet.of(PRIVATE), "Builder", "builder");
     StringBuilder params = new StringBuilder();
@@ -558,7 +565,8 @@ private void emitMessageEquals(JavaWriter writer, MessageType messageType) throw
   // For repeated fields, the final "0" in the example above changes to a "1"
   // in order to be the same as the system hash code for an empty list.
   //
-  private void emitMessageHashCode(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitMessageHashCode(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod("int", "hashCode", EnumSet.of(PUBLIC));
@@ -642,7 +650,8 @@ private void emitBuilderFields(JavaWriter writer, MessageType messageType) throw
   //   ...
   // }
   //
-  private void emitBuilderConstructors(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitBuilderConstructors(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC));
     writer.endMethod();
@@ -698,7 +707,8 @@ private void emitBuilderSetters(JavaWriter writer, MessageType messageType) thro
   //   return this;
   // }
   //
-  private void emitBuilderSetExtension(JavaWriter writer, MessageType messageType) throws IOException {
+  private void emitBuilderSetExtension(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod("<E> Builder", "setExtension", EnumSet.of(PUBLIC),
diff --git a/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java b/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java
index d440acd7cd..e73a1b89c0 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java
@@ -5,40 +5,41 @@
 /**
  * A container class that represents an artifact output from the compiler.
  */
-public class OutputArtifact {
+public final class OutputArtifact {
   private final String outputDirectory;
   private final String className;
   private final String javaPackage;
-  private final File artifactFile;
 
   public OutputArtifact(String outputDirectory, String javaPackage, String className) {
     this.outputDirectory = outputDirectory;
     this.className = className;
     this.javaPackage = javaPackage;
-    String dir = outputDirectory + File.separator
-        + javaPackage.replace(".", File.separator);
-    artifactFile = new File(dir, className + ".java");
   }
 
-  public String getOutputDirectory() {
+
+  public String outputDirectory() {
     return outputDirectory;
   }
 
-  public String getClassName() {
+  public String className() {
     return className;
   }
 
-  public String getJavaPackage() {
+  public String javaPackage() {
     return javaPackage;
   }
 
-  public File getArtifactFile() {
-    return artifactFile;
+  public File file() {
+    String dir = outputDirectory + File.separator
+        + javaPackage.replace(".", File.separator);
+    return new File(dir, className + ".java");
   }
 
-  public File getArtifactDir() {
-    return artifactFile.getParentFile();
+  public File dir() {
+    return file().getParentFile();
   }
 
-  public String getFullClassName() { return javaPackage + "." + className; }
+  public String fullClassName() {
+    return javaPackage + "." + className;
+  }
 }
diff --git a/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java b/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
index 1fb99c544a..f61fd03ed7 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
@@ -23,8 +23,8 @@
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.Service;
 import com.squareup.protoparser.Type;
+import com.squareup.wire.logger.ConsoleWireLogger;
 import com.squareup.wire.logger.WireLogger;
-import com.squareup.wire.logger.WireLoggerFactory;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
@@ -38,7 +38,6 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Scanner;
 import java.util.Set;
 import java.util.TreeSet;
 import okio.ByteString;
@@ -54,6 +53,7 @@
 /** Compiler for Wire protocol buffers. */
 public class WireCompiler {
   static final String LINE_WRAP_INDENT = "    ";
+
   /**
    * Field options that don't trigger generation of a FIELD_OPTIONS_* field.
    */
@@ -61,22 +61,10 @@
       new LinkedHashSet<String>(Arrays.asList("default", "deprecated", "packed"));
 
   private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
-  private static final String PROTO_PATH_FLAG = "--proto_path=";
-  private static final String JAVA_OUT_FLAG = "--java_out=";
-  private static final String FILES_FLAG = "--files=";
-  private static final String REGISTRY_CLASS_FLAG = "--registry_class=";
-  private static final String ROOTS_FLAG = "--roots=";
-  private static final String NO_OPTIONS_FLAG = "--no_options";
-  private static final String ENUM_OPTIONS_FLAG = "--enum_options=";
-  private static final String SERVICE_WRITER_FLAG = "--service_writer=";
-  private static final String SERVICE_WRITER_OPT_FLAG = "--service_writer_opt=";
-  private static final String QUIET_FLAG = "--quiet";
-  private static final String DRY_RUN_FLAG = "--dry-run";
   private static final String CODE_GENERATED_BY_WIRE =
       "Code generated by Wire protocol buffer compiler, do not edit.";
 
   private final String repoPath;
-  private final List<String> sourceFileNames;
   private final IO io;
   private final Set<String> typesToEmit = new LinkedHashSet<String>();
   private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
@@ -86,204 +74,108 @@
   private final Map<String, ExtensionInfo> extensionInfo =
       new LinkedHashMap<String, ExtensionInfo>();
   private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();
-  private final String outputDirectory;
-  private final String registryClass;
+
   private final List<String> extensionClasses = new ArrayList<String>();
   private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);
+  private final CommandLineOptions options;
 
-  private static WireLogger log = WireLoggerFactory.get();
+  private final WireLogger log;
 
   private ProtoFile protoFile;
   private String sourceFileName;
   private String protoFileName;
   private String typeBeingGenerated = "";
-  private boolean emitOptions = false;
-  private Set<String> enumOptions;
-  boolean dryRun;
 
   private Constructor<?> serviceWriterConstructor;
-  private List<String> serviceWriterOptions;
 
   /**
-   * Runs the compiler. Usage:
-   *
-   * <pre>
-   * java WireCompiler --proto_path=&lt;path&gt; --java_out=&lt;path&gt;
-   *     [--files=&lt;protos.include&gt;] [--roots=&lt;message_name&gt;[,&lt;message_name&gt;...]]
-   *     [--registry_class=&lt;class_name&gt;] [--no_options]
-   *     [--enum_options=&lt;option_name&gt;[,&lt;option_name&gt;...]]
-   *     [--service_writer=&lt;class_name&gt;]
-   *     [--service_writer_opt=&lt;value&gt;] [--service_writer_opt=&lt;value&gt;]...]
-   *     [--quiet] [--dry-run]
-   *     [file [file...]]
-   * </pre>
-   *
-   * If the {@code --roots} flag is present, its argument must be a comma-separated list
-   * of fully-qualified message or enum names. The output will be limited to those messages
-   * and enums that are (transitive) dependencies of the listed names.  If you are using
-   * {@code --service_writer} to generate an interface for a Service, your roots can also take the
-   * form 'fully.qualified.Service#MethodName` to limit what endpoints are generated.
-   * <p>
-   * If the {@code --registry_class} flag is present, its argument must be a Java class name. A
-   * class with the given name will be generated, containing a constant list of all extension
-   * classes generated during the compile. This list is suitable for passing to Wire's constructor
-   * at runtime for constructing its internal extension registry.
-   * <p>
-   * Unless the {@code --no_options} flag is supplied, code will be emitted for options on messages
-   * and fields.  The presence of options on a message will result in a static member named
-   * "MESSAGE_OPTIONS", initialized with the options and their values.   The presence of options on
-   * a field (other than the standard options "default", "deprecated", and "packed") will result in
-   * a static member named "FIELD_OPTIONS_&lt;field name&gt;" in the generated code, initialized
-   * with the field option values.
-   * <p>
-   * Regardless of the value of the {@code --no_options} flag, code will be emitted for all
-   * enum value options listed in the {@code --enum_options} flag. The resulting code will contain
-   * a public static field for each option used within a particular enum type.
-   * </p>
-   * <p>
-   * If {@code --quiet} is specified, diagnostic messages to stdout are suppressed.
-   * </p>
-   * <p>
-   * The {@code --dry_run} flag causes the compile to just emit the names of the source files that
-   * would be generated to stdout.
-   * </p>
+   * Runs the compiler.  See {@link CommandLineOptions} for command line options.
    */
-  public static void main(String... args) throws Exception {
-    // Reinitialize the logger in case its being diverted for testing.
-    log = WireLoggerFactory.get();
-
-    String protoPath = null;
-    String javaOut = null;
-    String registryClass = null;
-    List<String> sourceFileNames = new ArrayList<String>();
-    List<String> roots = new ArrayList<String>();
-    boolean emitOptions = true;
-    List<String> enumOptions = new ArrayList<String>();
-    Constructor<?> serviceWriterConstructor = null;
-    List<String> serviceWriterOptions = new ArrayList<String>();
-    boolean dryRun = false;
-
-    int index = 0;
-    while (index < args.length) {
-      if (args[index].startsWith(PROTO_PATH_FLAG)) {
-        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
-      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
-        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
-      } else if (args[index].startsWith(FILES_FLAG)) {
-        File files = new File(args[index].substring(FILES_FLAG.length()));
-        String[] fileNames = new Scanner(files, "UTF-8").useDelimiter("\\A").next().split("\n");
-        sourceFileNames.addAll(Arrays.asList(fileNames));
-      } else if (args[index].startsWith(ROOTS_FLAG)) {
-        roots.addAll(splitArg(args[index], ROOTS_FLAG.length()));
-      } else if (args[index].startsWith(REGISTRY_CLASS_FLAG)) {
-        registryClass = args[index].substring(REGISTRY_CLASS_FLAG.length());
-      } else if (args[index].equals(NO_OPTIONS_FLAG)) {
-        emitOptions = false;
-      } else if (args[index].startsWith(ENUM_OPTIONS_FLAG)) {
-        enumOptions.addAll(splitArg(args[index], ENUM_OPTIONS_FLAG.length()));
-      } else if (args[index].startsWith(SERVICE_WRITER_FLAG)) {
-        serviceWriterConstructor =
-            loadServiceWriter(args[index].substring(SERVICE_WRITER_FLAG.length()));
-      } else if (args[index].startsWith(SERVICE_WRITER_OPT_FLAG)) {
-        serviceWriterOptions.add(args[index].substring(SERVICE_WRITER_OPT_FLAG.length()));
-      } else if (args[index].startsWith(QUIET_FLAG)) {
-        log.setQuiet(true);
-      } else if (args[index].startsWith(DRY_RUN_FLAG)) {
-        dryRun = true;
-      } else {
-        sourceFileNames.add(args[index]);
-      }
-      index++;
-    }
-    if (javaOut == null) {
-      log.error("Must specify " + JAVA_OUT_FLAG + " flag");
+  public static void main(String... args) {
+    try {
+      new WireCompiler(new CommandLineOptions(args)).compile();
+    } catch (WireException e) {
+      System.err.print("Fatal: ");
+      e.printStackTrace(System.err);
       System.exit(1);
     }
-    if (protoPath == null) {
-      protoPath = System.getProperty("user.dir");
-      log.error(PROTO_PATH_FLAG + " flag not specified, using current dir " + protoPath);
-    }
-    WireCompiler wireCompiler =
-        new WireCompiler(protoPath, sourceFileNames, roots, javaOut, registryClass, emitOptions,
-            enumOptions, serviceWriterConstructor, serviceWriterOptions, new IO.FileIO(),
-            dryRun);
-    wireCompiler.compile();
-  }
-
-  private static List<String> splitArg(String arg, int flagLength) {
-    return Arrays.asList(arg.substring(flagLength).split(","));
   }
 
-  private static Constructor<?> loadServiceWriter(String serviceWriterClassName) {
+  private static Constructor<?> loadServiceWriter(String serviceWriterClassName)
+      throws WireException {
     Class<?> serviceWriterClass = null;
     try {
       serviceWriterClass = Class.forName(serviceWriterClassName);
     } catch (ClassNotFoundException e) {
-      log.error("Unable to load ServiceWriter class " + serviceWriterClassName + ".");
-      System.exit(1);
+      throw new WireException("Unable to load ServiceWriter class "
+          + serviceWriterClassName + ".", e);
     }
 
     if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
-      log.error(
+      throw new WireException(
           "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
-      System.exit(0);
     }
 
     try {
       return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
     } catch (NoSuchMethodException e) {
-      log.error("ServiceWriter class "
+      throw new WireException("ServiceWriter class "
           + serviceWriterClassName
           + " needs a constructor 'public "
           + serviceWriterClassName
-          + "(JavaWriter writer, List<String> options)'.");
-      System.exit(1);
+          + "(JavaWriter writer, List<String> options)'.", e);
     }
-
-    return null;
   }
 
+  @Deprecated
   public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
       String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
-      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions) {
-    this(protoPath, sourceFileNames, roots, outputDirectory, registryClass, emitOptions,
-        enumOptions, serviceWriterConstructor, serviceWriterOptions, new IO.FileIO(), false);
+      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions)
+      throws WireException {
+    this(new CommandLineOptions(protoPath, outputDirectory, sourceFileNames, roots,  registryClass,
+        emitOptions,  new LinkedHashSet<String>(enumOptions), serviceWriterConstructor.getName(),
+        serviceWriterOptions, false, false));
   }
 
-  @Deprecated
-  WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
-      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
-      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions, IO io) {
-    this(protoPath, sourceFileNames, roots, outputDirectory, registryClass, emitOptions,
-        enumOptions, serviceWriterConstructor, serviceWriterOptions, io, false);
+  public WireCompiler(CommandLineOptions options) throws WireException {
+    this(options, new IO.FileIO(), new ConsoleWireLogger(options.quiet));
   }
 
-  WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
-      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
-      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions, IO io,
-      boolean dryRun) {
-    this.repoPath = protoPath;
-    this.typesToEmit.addAll(roots);
-    this.sourceFileNames = sourceFileNames;
-    this.outputDirectory = outputDirectory;
-    this.registryClass = registryClass;
-    this.emitOptions = emitOptions;
-    this.enumOptions = new LinkedHashSet<String>(enumOptions);
-    this.serviceWriterConstructor = serviceWriterConstructor;
-    this.serviceWriterOptions = serviceWriterOptions;
+  WireCompiler(CommandLineOptions options, IO io, WireLogger logger) throws WireException {
+    this.options = options;
     this.io = io;
-    this.dryRun = dryRun;
+    this.log = logger;
+
+    String protoPath = options.protoPath;
+    if (options.javaOut == null) {
+      throw new WireException("Must specify " + CommandLineOptions.JAVA_OUT_FLAG + " flag");
+    }
+    if (options.protoPath == null) {
+      protoPath = System.getProperty("user.dir");
+      System.err.println(
+          CommandLineOptions.PROTO_PATH_FLAG + " flag not specified, using current dir "
+              + protoPath);
+    }
+    if (options.serviceWriter != null) {
+      serviceWriterConstructor =
+          WireCompiler.loadServiceWriter(options.serviceWriter);
+    }
+    this.repoPath = protoPath;
+    this.typesToEmit.addAll(options.roots);
   }
 
-  public void compile() throws IOException {
+  public void compile() throws WireException {
     Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();
 
-    for (String sourceFilename : sourceFileNames) {
+    for (String sourceFilename : options.sourceFileNames) {
       String sourcePath = repoPath + File.separator + sourceFilename;
-      ProtoFile protoFile = io.parse(sourcePath);
-      parsedFiles.put(sourcePath, protoFile);
-
-      loadSymbols(protoFile);
+      try {
+        ProtoFile protoFile = io.parse(sourcePath);
+        parsedFiles.put(sourcePath, protoFile);
+        loadSymbols(protoFile);
+      } catch (IOException e) {
+        throw new WireException("Error loading symbols for " + sourcePath, e);
+      }
     }
 
     if (!typesToEmit.isEmpty()) {
@@ -296,28 +188,35 @@ public void compile() throws IOException {
       this.protoFile = entry.getValue();
       this.protoFileName = protoFileName(protoFile.getFileName());
       log.info("Compiling proto source file " + sourceFileName);
-      compileOne();
+      try {
+        compileOne();
+      } catch (IOException e) {
+        throw new WireException("Error compiling " + entry.getKey(), e);
+      }
     }
 
-    if (registryClass != null) {
-      int packageClassSep = registryClass.lastIndexOf(".");
-      String javaPackage = registryClass.substring(0, packageClassSep);
-      String className = registryClass.substring(packageClassSep + 1);
-      OutputArtifact artifact = new OutputArtifact(outputDirectory, javaPackage, className);
+    if (options.registryClass != null) {
+      int packageClassSep = options.registryClass.lastIndexOf(".");
+      String javaPackage = options.registryClass.substring(0, packageClassSep);
+      String className = options.registryClass.substring(packageClassSep + 1);
+      OutputArtifact artifact = new OutputArtifact(options.javaOut, javaPackage, className);
       log.artifact(artifact);
-
-      if (!dryRun) {
-        emitRegistry(artifact);
+      if (!options.dryRun) {
+        try {
+          emitRegistry(artifact);
+        } catch (IOException e) {
+          throw new WireException("Error emitting registry class " + options.registryClass, e);
+        }
       }
     }
   }
 
   boolean shouldEmitOptions() {
-    return emitOptions;
+    return options.emitOptions;
   }
 
   Set<String> enumOptions() {
-    return enumOptions;
+    return options.enumOptions;
   }
 
   ProtoFile getProtoFile() {
@@ -429,18 +328,17 @@ boolean isRedacted(Option option) {
     return option.getName().endsWith(".redacted") && "true".equals(option.getValue());
   }
 
-
   private void compileOne() throws IOException {
     typeBeingGenerated = "";
 
     if (hasExtends()) {
-      OutputArtifact artifact = new OutputArtifact(outputDirectory, getJavaPackage(),
+      OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
           "Ext_" + protoFileName);
       log.artifact(artifact);
 
-      if (!dryRun) {
+      if (!options.dryRun) {
         emitExtensionClass(artifact);
-        extensionClasses.add(artifact.getFullClassName());
+        extensionClasses.add(artifact.fullClassName());
       }
     }
 
@@ -448,9 +346,10 @@ private void compileOne() throws IOException {
       if (shouldEmitType(type.getFullyQualifiedName())) {
         String savedType = typeBeingGenerated;
         typeBeingGenerated += type.getName() + ".";
-        OutputArtifact artifact = new OutputArtifact(outputDirectory, getJavaPackage(), type.getName());
+        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
+            type.getName());
         log.artifact(artifact);
-        if (!dryRun) {
+        if (!options.dryRun) {
           emitMessageClass(type, artifact);
         }
         typeBeingGenerated = savedType;
@@ -467,9 +366,10 @@ private void compileOne() throws IOException {
         }
         Service limitedService = new Service(service.getName(), service.getFullyQualifiedName(),
             service.getDocumentation(), service.getOptions(), limitedMethods);
-        OutputArtifact artifact = new OutputArtifact(outputDirectory, getJavaPackage(), service.getName());
+        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
+            service.getName());
         log.artifact(artifact);
-        if (!dryRun) {
+        if (!options.dryRun) {
           emitServiceInterface(limitedService, artifact);
         }
       }
@@ -521,7 +421,7 @@ private void emitRegistry(OutputArtifact artifact) throws IOException {
     try {
       writer = io.getJavaWriter(artifact);
       writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
-      writer.emitPackage(artifact.getJavaPackage());
+      writer.emitPackage(artifact.javaPackage());
 
       writer.emitImports("java.util.List");
       writer.emitEmptyLine();
@@ -534,7 +434,7 @@ private void emitRegistry(OutputArtifact artifact) throws IOException {
             "java.util.Collections.unmodifiableList");
       }
       writer.emitEmptyLine();
-      writer.beginType(artifact.getClassName(), "class", EnumSet.of(PUBLIC, FINAL));
+      writer.beginType(artifact.className(), "class", EnumSet.of(PUBLIC, FINAL));
       writer.emitEmptyLine();
 
       String classes;
@@ -558,7 +458,7 @@ private void emitRegistry(OutputArtifact artifact) throws IOException {
       writer.emitEmptyLine();
 
       // Private no-args constructor
-      writer.beginMethod(null, artifact.getClassName(), EnumSet.of(PRIVATE));
+      writer.beginMethod(null, artifact.className(), EnumSet.of(PRIVATE));
       writer.endMethod();
       writer.endType();
     } finally {
@@ -593,7 +493,7 @@ private boolean shouldEmitServiceMethod(String serviceName, String method) {
         || typesToEmit.contains(serviceName + "#" + method);
   }
 
-  private void findDependencies(Collection<ProtoFile> protoFiles) throws IOException {
+  private void findDependencies(Collection<ProtoFile> protoFiles) throws WireException {
     Set<String> loadedDependencies = new LinkedHashSet<String>();
     int count = typesToEmit.size();
     while (true) {
@@ -609,13 +509,17 @@ private void findDependencies(Collection<ProtoFile> protoFiles) throws IOExcepti
   }
 
   private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
-      throws IOException {
+      throws WireException {
     // Load symbols from imports
     for (String dependency : protoFile.getDependencies()) {
       if (!loadedDependencies.contains(dependency)) {
         String dep = repoPath + File.separator + dependency;
-        ProtoFile dependencyFile = io.parse(dep);
-        loadSymbols(dependencyFile);
+        try {
+          ProtoFile dependencyFile = io.parse(dep);
+          loadSymbols(dependencyFile);
+        } catch (IOException e) {
+          throw new WireException("Error loading symbols for " + dep, e);
+        }
         loadedDependencies.add(dependency);
       }
     }
@@ -881,7 +785,7 @@ private void emitMessageClass(Type type, OutputArtifact artifact) throws IOExcep
         imports.add("com.squareup.wire.ExtendableMessage");
         imports.add("com.squareup.wire.Extension");
       }
-      if (emitOptions) {
+      if (options.emitOptions) {
         if (hasFieldOption(types)) {
           imports.add("com.google.protobuf.FieldOptions");
         }
@@ -897,7 +801,7 @@ private void emitMessageClass(Type type, OutputArtifact artifact) throws IOExcep
       getExternalTypes(type, externalTypes);
 
       Map<String, ?> optionsMap = null;
-      if (emitOptions) {
+      if (options.emitOptions) {
         if (type instanceof MessageType) {
           optionsMap = optionsMapMaker.createMessageOptionsMap((MessageType) type);
           optionsMapMaker.getOptionTypes(optionsMap, externalTypes);
@@ -935,8 +839,8 @@ private void emitServiceInterface(Service service, OutputArtifact artifact) thro
       writer = io.getJavaWriter(artifact);
       ServiceWriter serviceWriter;
       try {
-        List<String> options = new ArrayList<String>(serviceWriterOptions);
-        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer, options);
+        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
+            new ArrayList<String>(options.serviceWriterOptions));
       } catch (Exception e) {
         throw new IllegalStateException(
             "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
@@ -945,7 +849,7 @@ private void emitServiceInterface(Service service, OutputArtifact artifact) thro
 
       writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
       writer.emitSingleLineComment("Source file: %s", sourceFileName);
-      writer.emitPackage(artifact.getJavaPackage());
+      writer.emitPackage(artifact.javaPackage());
 
       Set<String> imports = new LinkedHashSet<String>();
       List<String> externalTypes = new ArrayList<String>();
@@ -1083,7 +987,6 @@ private void emitExtensionClass(OutputArtifact artifact) throws IOException {
         writer.close();
       }
     }
-
   }
 
   private void emitExtensions(JavaWriter writer) throws IOException {
diff --git a/wire-compiler/src/main/java/com/squareup/wire/WireException.java b/wire-compiler/src/main/java/com/squareup/wire/WireException.java
new file mode 100755
index 0000000000..be42ec24d8
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/WireException.java
@@ -0,0 +1,11 @@
+package com.squareup.wire;
+
+public class WireException extends Exception {
+  public WireException(String message) {
+    super(message);
+  }
+
+  public WireException(String message, Throwable throwable) {
+    super(message, throwable);
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java b/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java
index d1fcd160b7..5143c9e7d8 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java
@@ -2,14 +2,12 @@
 
 import com.squareup.wire.OutputArtifact;
 
-/**
- * Created by zundel on 12/23/14.
- */
-public class ConsoleWireLogger implements WireLogger {
-  private boolean isQuiet = false;
 
-  public void setQuiet(boolean isQuiet) {
-    this.isQuiet = isQuiet;
+public final class ConsoleWireLogger implements WireLogger {
+  private final boolean isQuiet;
+
+  public ConsoleWireLogger(boolean quiet) {
+    this.isQuiet = quiet;
   }
 
   public void info(String message) {
@@ -21,9 +19,9 @@ public void info(String message) {
   public void artifact(OutputArtifact artifact) {
     String msg;
     if (isQuiet) {
-      msg = artifact.getArtifactFile().toString();
+      msg = artifact.file().toString();
     } else {
-      msg = "Writing generated code to " + artifact.getArtifactFile().toString();
+      msg = "Writing generated code to " + artifact.file().toString();
     }
     System.out.println(msg);
   }
diff --git a/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java b/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java
index 64bdfe7055..fdc1e35748 100755
--- a/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java
@@ -3,8 +3,7 @@
 import com.squareup.wire.OutputArtifact;
 
 public interface WireLogger {
-  public void setQuiet(boolean isQuiet);
-  public void error(String message);
-  public void artifact(OutputArtifact artifact);
-  public void info(String message);
+  void error(String message);
+  void artifact(OutputArtifact artifact);
+  void info(String message);
 }
diff --git a/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java b/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java
new file mode 100755
index 0000000000..935cf5815a
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java
@@ -0,0 +1,132 @@
+package com.squareup.wire;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public class CommandLineOptionsTest {
+
+  @Test public void protoPath() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.protoPath);
+
+    options = new CommandLineOptions("--proto_path=foo/bar");
+    assertEquals("foo/bar", options.protoPath);
+  }
+
+  @Test public void javaOut() throws Exception{
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.javaOut);
+
+    options = new CommandLineOptions("--java_out=baz/qux");
+    assertEquals("baz/qux", options.javaOut);
+  }
+
+  @Test public void sourceFileNames() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.sourceFileNames.isEmpty());
+
+    List<String> expected = new ArrayList<String>();
+    options = new CommandLineOptions("baz", "qux");
+    expected.add("baz");
+    expected.add("qux");
+    assertEquals(expected, options.sourceFileNames);
+  }
+
+  @Test public void sourceFileNamesFromInclude() throws Exception {
+    File tmpFile = File.createTempFile("proto", ".include");
+    try {
+      PrintWriter out = new PrintWriter(new FileOutputStream(tmpFile));
+      out.println("foo");
+      out.println("bar");
+      out.close();
+
+      CommandLineOptions options = new CommandLineOptions("--files=" + tmpFile.getAbsolutePath());
+      List<String> expected = new ArrayList<String>();
+      expected.add("foo");
+      expected.add("bar");
+      assertEquals(expected, options.sourceFileNames);
+
+      // Test both --files and bare filenames together
+      options = new CommandLineOptions("--files=" + tmpFile.getAbsolutePath(), "baz");
+      expected.add("baz");
+      assertEquals(expected, options.sourceFileNames);
+    } finally {
+      tmpFile.delete();
+    }
+  }
+
+  @Test public void roots() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.roots.isEmpty());
+
+    options = new CommandLineOptions("--roots=com.example.foo");
+    List<String> expected = new ArrayList<String>();
+    expected.add("com.example.foo");
+    assertEquals(expected, options.roots);
+    options = new CommandLineOptions("--roots=com.example.foo,com.example.bar");
+    expected.add("com.example.bar");
+    assertEquals(expected, options.roots);
+  }
+
+  @Test public void registryClass() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.registryClass);
+    options = new CommandLineOptions("--registry_class=com.example.RegistryClass");
+    assertEquals("com.example.RegistryClass", options.registryClass);
+  }
+
+  @Test public void  emitOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.emitOptions);
+
+    options = new CommandLineOptions("--no_options");
+    assertFalse(options.emitOptions);
+  }
+
+  @Test public void enumOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.enumOptions.isEmpty());
+
+    options = new CommandLineOptions("--enum_options=foo");
+    Set<String> expected = new HashSet<String>();
+    expected.add("foo");
+    assertEquals(expected, options.enumOptions);
+    options = new CommandLineOptions("--enum_options=foo,bar");
+    expected.add("bar");
+    assertEquals(expected, options.enumOptions);
+  }
+
+  @Test public void serviceWriter() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.serviceWriter);
+
+    String name = SimpleServiceWriter.class.getName();
+    options = new CommandLineOptions("--service_writer=" + name);
+    assertEquals("com.squareup.wire.SimpleServiceWriter", options.serviceWriter);
+  }
+
+  @Test public void serviceWriterOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.serviceWriterOptions.isEmpty());
+
+    options = new CommandLineOptions("--service_writer_opt=foo");
+    List<String> expected = new ArrayList<String>();
+    expected.add("foo");
+    assertEquals(expected, options.serviceWriterOptions);
+    options = new CommandLineOptions("--service_writer_opt=foo", "--service_writer_opt=bar");
+    expected.add("bar");
+    assertEquals(expected, options.serviceWriterOptions);
+  }
+
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java b/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java
index 849972985f..3a8ac61ee1 100755
--- a/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java
@@ -6,16 +6,13 @@
 
 public class OutputArtifactTest {
 
-  @Test
-  public void testOutputArtifact() {
-
+  @Test public void testOutputArtifact() {
     OutputArtifact artifact = new OutputArtifact("foo/bar", "com.company", "Foo");
-    assertEquals("foo/bar", artifact.getOutputDirectory());
-    assertEquals("com.company", artifact.getJavaPackage());
-    assertEquals("Foo", artifact.getClassName());
-
-    assertEquals("foo/bar/com/company", artifact.getArtifactDir().toString());
-    assertEquals("foo/bar/com/company/Foo.java", artifact.getArtifactFile().toString());
-    assertEquals("com.company.Foo", artifact.getFullClassName());
+    assertEquals("foo/bar", artifact.outputDirectory());
+    assertEquals("com.company", artifact.javaPackage());
+    assertEquals("Foo", artifact.className());
+    assertEquals("foo/bar/com/company", artifact.dir().toString());
+    assertEquals("foo/bar/com/company/Foo.java", artifact.file().toString());
+    assertEquals("com.company.Foo", artifact.fullClassName());
   }
 }
diff --git a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
index 5df212a4d5..10f121ab98 100755
--- a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
@@ -18,6 +18,7 @@
 import com.squareup.javawriter.JavaWriter;
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.ProtoSchemaParser;
+import com.squareup.wire.logger.MockWireLogger;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.StringReader;
@@ -59,7 +60,7 @@ public ProtoFile parse(String filename) throws IOException {
     public JavaWriter getJavaWriter(OutputArtifact outputArtifact)
         throws IOException {
       StringWriter writer = new StringWriter();
-      writers.put(outputArtifact.getFullClassName(), writer);
+      writers.put(outputArtifact.fullClassName(), writer);
       return new JavaWriter(writer);
     }
 
@@ -79,13 +80,14 @@ public JavaWriter getJavaWriter(OutputArtifact outputArtifact)
   private Map<String, String> compile(String source) {
     StringIO io = new StringIO("test.proto", source);
 
-    @SuppressWarnings("unchecked")
-    WireCompiler compiler = new WireCompiler(".", Arrays.asList("test.proto"),
-        new ArrayList<String>(), ".", null, true, Collections.EMPTY_LIST, null,
-        Collections.EMPTY_LIST, io);
+    CommandLineOptions options = new CommandLineOptions(".",  ".", Arrays.asList("test.proto"),
+        new ArrayList<String>(), null, true, Collections.<String>emptySet(), null,
+        Collections.<String>emptyList(), false, false);
+
+
     try {
-      compiler.compile();
-    } catch (IOException e) {
+      new WireCompiler(options, io, new MockWireLogger()).compile();
+    } catch (WireException e) {
       fail();
     }
     return io.getOutput();
diff --git a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
index 7d2109dada..d8ba21b835 100755
--- a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
@@ -18,8 +18,6 @@
 import com.squareup.javawriter.JavaWriter;
 import com.squareup.protoparser.Service;
 import com.squareup.wire.logger.StringWireLogger;
-import com.squareup.wire.logger.WireLogger;
-import com.squareup.wire.logger.WireLoggerFactory;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -37,7 +35,7 @@
 import static org.junit.Assert.fail;
 
 public class WireCompilerTest {
-
+  private StringWireLogger logger;
   private File testDir;
 
   @Before public void setUp() {
@@ -56,7 +54,6 @@ private File makeTestDirectory(String path) {
 
   @After public void tearDown() {
     cleanupAndDelete(testDir);
-    WireLoggerFactory.reset();
   }
 
   private void cleanupAndDelete(File dir) {
@@ -91,7 +88,7 @@ private void testProto(String[] sources, String[] outputs, String serviceWriter,
     }
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(filesAfter.toString(), outputs.length, filesAfter.size());
@@ -111,7 +108,7 @@ private void testProtoNoOptions(String[] sources, String[] outputs) throws Excep
     args[3] = "--java_out=" + testDir.getAbsolutePath();
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(outputs.length, filesAfter.size());
@@ -130,7 +127,7 @@ private void testProtoWithRegistry(String[] sources, String registryClass, Strin
     args[2] = "--registry_class=" + registryClass;
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(outputs.length, filesAfter.size());
@@ -161,7 +158,7 @@ private void testProtoWithRoots(String[] sources, String roots, String[] outputs
     }
     System.arraycopy(sources, 0, args, index, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals("Wrong number of files written", outputs.length, filesAfter.size());
@@ -182,7 +179,7 @@ private void testLimitedServiceGeneration(String[] sources, String roots, String
     args[4] = "--roots=" + roots;
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(filesAfter.toString(), outputs.length, filesAfter.size());
@@ -192,6 +189,7 @@ private void testLimitedServiceGeneration(String[] sources, String roots, String
     }
   }
 
+
   @Test public void testPerson() throws Exception {
     String[] sources = {
         "person.proto"
@@ -603,18 +601,16 @@ public TestServiceWriter(JavaWriter writer, List<String> options) {
   }
 
   @Test public void testDryRun() throws Exception {
-    StringWireLogger logger = new StringWireLogger();
-    WireLoggerFactory.set(logger);
     String[] sources = {
         "service_root.proto"
     };
 
     String[] outputs = { };
     String roots = "squareup.wire.protos.roots.TheService";
-    // When running with the --dry-run flag and --quiet, only the names of the output
-    // files should be printed to the log
+    // When running with the --dry_run flag and --quiet, only the names of the output
+    // files should be printed to the log.
     String[] extraArgs = {
-        "--dry-run",
+        "--dry_run",
         "--quiet"
     };
     testProtoWithRoots(sources, roots, outputs, extraArgs);
@@ -686,6 +682,12 @@ private void getAllFilesHelper(File root, List<String> files) {
     }
   }
 
+  private void invokeCompiler(String[] args) throws WireException {
+    CommandLineOptions options = new CommandLineOptions(args);
+    logger = new StringWireLogger(options.quiet);
+    new WireCompiler(options, new IO.FileIO(), logger).compile();
+  }
+
   private void assertFilesMatch(File outputDir, String path) throws FileNotFoundException {
     File expectedFile = new File("../wire-runtime/src/test/java/" + path);
     File actualFile = new File(outputDir, path);
diff --git a/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java b/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java
new file mode 100755
index 0000000000..d0e21b96a9
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java
@@ -0,0 +1,16 @@
+package com.squareup.wire.logger;
+
+import com.squareup.wire.OutputArtifact;
+
+
+public class MockWireLogger implements WireLogger {
+
+  @Override public void error(String message) {
+  }
+
+  @Override public void artifact(OutputArtifact artifact) {
+  }
+
+  @Override public void info(String message) {
+  }
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java b/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java
index d914404b1b..2dd89ee276 100755
--- a/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java
@@ -2,26 +2,22 @@
 
 import com.squareup.wire.OutputArtifact;
 
-/**
- * Created by zundel on 12/23/14.
- */
-public class StringWireLogger implements WireLogger {
-  private boolean isQuiet = false;
+
+public final class StringWireLogger implements WireLogger {
+  private final boolean isQuiet;
   private StringBuilder buffer = new StringBuilder();
 
-  @Override
-  public void setQuiet(boolean isQuiet) {
-    this.isQuiet = isQuiet;
+  public StringWireLogger(boolean quiet) {
+    this.isQuiet = quiet;
   }
 
   @Override public void error(String message) {
     buffer.append(message);
     buffer.append('\n');
-
   }
 
   @Override public void artifact(OutputArtifact artifact) {
-    buffer.append(artifact.getArtifactFile().toString());
+    buffer.append(artifact.file().toString());
     buffer.append('\n');
   }
 
