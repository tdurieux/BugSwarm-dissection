diff --git a/.ackrc b/.ackrc
new file mode 100644
index 000000000..94fc84ab5
--- /dev/null
+++ b/.ackrc
@@ -0,0 +1,2 @@
+# Skip top-level docs dir as it's just a rendered artifact.
+--ignore-dir=docs
diff --git a/dev-requirements.txt b/dev-requirements.txt
index 00ff1c6e7..27cd91b65 100644
--- a/dev-requirements.txt
+++ b/dev-requirements.txt
@@ -8,4 +8,4 @@ wheel==0.24
 twine==1.9.1
 flake8==2.6.2
 pytest==3.2.1
-pytest_relaxed==1.0.0
+pytest_relaxed==1.1.0
diff --git a/paramiko/auth_handler.py b/paramiko/auth_handler.py
index a1ce5e3b8..3b894de74 100644
--- a/paramiko/auth_handler.py
+++ b/paramiko/auth_handler.py
@@ -39,7 +39,7 @@
     cMSG_USERAUTH_BANNER
 )
 from paramiko.message import Message
-from paramiko.py3compat import bytestring
+from paramiko.py3compat import b
 from paramiko.ssh_exception import (
     SSHException, AuthenticationException, BadAuthenticationType,
     PartialAuthentication,
@@ -256,7 +256,7 @@ def _parse_service_accept(self, m):
             m.add_string(self.auth_method)
             if self.auth_method == 'password':
                 m.add_boolean(False)
-                password = bytestring(self.password)
+                password = b(self.password)
                 m.add_string(password)
             elif self.auth_method == 'publickey':
                 m.add_boolean(True)
diff --git a/paramiko/client.py b/paramiko/client.py
index 6f0cb847a..de0a495ed 100644
--- a/paramiko/client.py
+++ b/paramiko/client.py
@@ -463,6 +463,9 @@ def exec_command(
             Python
         :param int timeout:
             set command's channel timeout. See `.Channel.settimeout`
+        :param bool get_pty:
+            Request a pseudo-terminal from the server (default ``False``).
+            See `.Channel.get_pty`
         :param dict environment:
             a dict of shell environment variables, to be merged into the
             default environment that the remote command executes within.
@@ -476,6 +479,9 @@ def exec_command(
             3-tuple
 
         :raises: `.SSHException` -- if the server fails to execute the command
+
+        .. versionchanged:: 1.10
+            Added the ``get_pty`` kwarg.
         """
         chan = self._transport.open_session(timeout=timeout)
         if get_pty:
diff --git a/paramiko/common.py b/paramiko/common.py
index 0012372a2..3a251d94d 100644
--- a/paramiko/common.py
+++ b/paramiko/common.py
@@ -20,7 +20,7 @@
 Common constants and global variables.
 """
 import logging
-from paramiko.py3compat import byte_chr, PY2, bytes_types, text_type, long
+from paramiko.py3compat import byte_chr, PY2, long, b
 
 MSG_DISCONNECT, MSG_IGNORE, MSG_UNIMPLEMENTED, MSG_DEBUG, \
     MSG_SERVICE_REQUEST, MSG_SERVICE_ACCEPT = range(1, 7)
@@ -161,17 +161,24 @@
 
 
 def asbytes(s):
-    """Coerce to bytes if possible or return unchanged."""
-    if isinstance(s, bytes_types):
-        return s
-    if isinstance(s, text_type):
-        # Accept text and encode as utf-8 for compatibility only.
-        return s.encode("utf-8")
-    asbytes = getattr(s, "asbytes", None)
-    if asbytes is not None:
-        return asbytes()
-    # May be an object that implements the buffer api, let callers handle.
-    return s
+    """
+    Coerce to bytes if possible or return unchanged.
+    """
+    try:
+        # Attempt to run through our version of b(), which does the Right Thing
+        # for string/unicode/buffer (Py2) or bytes/str (Py3), and raises
+        # TypeError if it's not one of those types.
+        return b(s)
+    except TypeError:
+        try:
+            # If it wasn't a string/byte/buffer type object, try calling an
+            # asbytes() method, which many of our internal classes implement.
+            return s.asbytes()
+        except AttributeError:
+            # Finally, just do nothing & assume this object is sufficiently
+            # byte-y or buffer-y that everything will work out (or that callers
+            # are capable of handling whatever it is.)
+            return s
 
 
 xffffffff = long(0xffffffff)
diff --git a/paramiko/ed25519key.py b/paramiko/ed25519key.py
index 418a822d0..8ad71d083 100644
--- a/paramiko/ed25519key.py
+++ b/paramiko/ed25519key.py
@@ -25,6 +25,7 @@
 
 from paramiko.message import Message
 from paramiko.pkey import PKey
+from paramiko.py3compat import b
 from paramiko.ssh_exception import SSHException, PasswordRequiredException
 
 
@@ -132,7 +133,7 @@ def _parse_signing_key_data(self, data, password):
         else:
             cipher = Transport._cipher_info[ciphername]
             key = bcrypt.kdf(
-                password=password,
+                password=b(password),
                 salt=bcrypt_salt,
                 desired_key_bytes=cipher["key-size"] + cipher["block-size"],
                 rounds=bcrypt_rounds,
diff --git a/paramiko/py3compat.py b/paramiko/py3compat.py
index cb9de412e..67c0f200f 100644
--- a/paramiko/py3compat.py
+++ b/paramiko/py3compat.py
@@ -1,11 +1,12 @@
 import sys
 import base64
 
-__all__ = ['PY2', 'string_types', 'integer_types', 'text_type', 'bytes_types',
-           'bytes', 'long', 'input', 'decodebytes', 'encodebytes',
-           'bytestring', 'byte_ord', 'byte_chr', 'byte_mask', 'b', 'u', 'b2s',
-           'StringIO', 'BytesIO', 'is_callable', 'MAXSIZE',
-           'next', 'builtins']
+__all__ = [
+    'BytesIO', 'MAXSIZE', 'PY2', 'StringIO', 'b', 'b2s', 'builtins',
+    'byte_chr', 'byte_mask', 'byte_ord', 'bytes', 'bytes_types', 'decodebytes',
+    'encodebytes', 'input', 'integer_types', 'is_callable', 'long', 'next',
+    'string_types', 'text_type', 'u',
+]
 
 PY2 = sys.version_info[0] < 3
 
@@ -23,12 +24,6 @@
     import __builtin__ as builtins
 
 
-    def bytestring(s):  # NOQA
-        if isinstance(s, unicode):  # NOQA
-            return s.encode('utf-8')
-        return s
-
-
     byte_ord = ord  # NOQA
     byte_chr = chr  # NOQA
 
@@ -111,9 +106,6 @@ class long(int):
     decodebytes = base64.decodebytes
     encodebytes = base64.encodebytes
 
-    def bytestring(s):
-        return s
-
     def byte_ord(c):
         # In case we're handed a string instead of an int.
         if not isinstance(c, int):
diff --git a/paramiko/sftp_client.py b/paramiko/sftp_client.py
index b344dff33..31dc234c6 100644
--- a/paramiko/sftp_client.py
+++ b/paramiko/sftp_client.py
@@ -28,7 +28,7 @@
 from paramiko.channel import Channel
 from paramiko.message import Message
 from paramiko.common import INFO, DEBUG, o777
-from paramiko.py3compat import bytestring, b, u, long
+from paramiko.py3compat import b, u, long
 from paramiko.sftp import (
     BaseSFTP, CMD_OPENDIR, CMD_HANDLE, SFTPError, CMD_READDIR, CMD_NAME,
     CMD_CLOSE, SFTP_FLAG_READ, SFTP_FLAG_WRITE, SFTP_FLAG_CREATE,
@@ -489,7 +489,7 @@ def symlink(self, source, dest):
         """
         dest = self._adjust_cwd(dest)
         self._log(DEBUG, 'symlink({!r}, {!r})'.format(source, dest))
-        source = bytestring(source)
+        source = b(source)
         self._request(CMD_SYMLINK, source, dest)
 
     def chmod(self, path, mode):
diff --git a/paramiko/transport.py b/paramiko/transport.py
index 68519f90f..380707ea6 100644
--- a/paramiko/transport.py
+++ b/paramiko/transport.py
@@ -1100,6 +1100,8 @@ def accept(self, timeout=None):
             self.lock.release()
         return chan
 
+    # TODO: consider removing this, it feels either vestigial or overlaps too
+    # much (and very poorly) with `SSHClient`'s domain.
     def connect(
         self,
         hostkey=None,
diff --git a/setup.cfg b/setup.cfg
index 00e34ca3c..50e0ff452 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -13,6 +13,5 @@ ignore = E124,E125,E128,E261,E301,E302,E303,E402
 max-line-length = 79
 
 [tool:pytest]
-# We use pytest-relaxed just for its utils at the moment, so disable it at the
-# plugin level until we adapt test organization to really use it.
-addopts = -p no:relaxed
+testpaths = tests
+python_files = *
diff --git a/sites/www/changelog.rst b/sites/www/changelog.rst
index 41721713a..d415aa927 100644
--- a/sites/www/changelog.rst
+++ b/sites/www/changelog.rst
@@ -2,6 +2,9 @@
 Changelog
 =========
 
+* :bug:`1039` Ed25519 auth key decryption raised an unexpected exception when
+  given a unicode password string (typical in python 3). Report by Theodor van
+  Nahl and fix by Pierce Lopez.
 * :release:`2.4.0 <2017-11-14>`
 * :feature:`-` Add a new ``passphrase`` kwarg to `SSHClient.connect
   <paramiko.client.SSHClient.connect>` so users may disambiguate key-decryption
diff --git a/tasks.py b/tasks.py
index d5ed25b12..ad818cf87 100644
--- a/tasks.py
+++ b/tasks.py
@@ -1,5 +1,6 @@
 import os
-from os.path import join
+import sys
+from os.path import join, exists
 from shutil import rmtree, copytree
 
 from invoke import Collection, task
@@ -46,8 +47,13 @@ def test(
         opts += ' -x'
     modstr = ""
     if module is not None:
-        # NOTE: implicit test_ prefix as we're not on pytest-relaxed yet
-        modstr = " tests/test_{}.py".format(module)
+        # Fall back to test_*.py for the legacy parts of the suite
+        path = "tests/{}.py".format(module)
+        if not exists(path):
+            path = "tests/test_{}.py".format(module)
+        if not exists(path):
+            sys.exit("There's no '{}' to test!".format(path))
+        modstr = " {}".format(path)
     # Switch runner depending on coverage or no coverage.
     # TODO: get pytest's coverage plugin working, IIRC it has issues?
     runner = "pytest"
diff --git a/tests/loop.py b/tests/_loop.py
similarity index 99%
rename from tests/loop.py
rename to tests/_loop.py
index 6c4328674..68b759f56 100644
--- a/tests/loop.py
+++ b/tests/_loop.py
@@ -96,5 +96,3 @@ def __unlink(self):
             self.__lock.release()
         if m is not None:
             m.__unlink()
-
-
diff --git a/tests/stub_sftp.py b/tests/_stub_sftp.py
similarity index 100%
rename from tests/stub_sftp.py
rename to tests/_stub_sftp.py
diff --git a/tests/_util.py b/tests/_util.py
new file mode 100644
index 000000000..9a9bf6f6b
--- /dev/null
+++ b/tests/_util.py
@@ -0,0 +1,210 @@
+from os.path import dirname, realpath, join
+from time import sleep
+import logging
+import socket
+
+import pytest
+
+from paramiko import (
+    AUTH_FAILED,
+    AUTH_PARTIALLY_SUCCESSFUL,
+    AUTH_SUCCESSFUL,
+    OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED,
+    OPEN_SUCCEEDED,
+    DSSKey,
+    InteractiveQuery,
+    ServerInterface,
+)
+from paramiko.py3compat import builtins, u
+
+
+def _support(filename):
+    return join(dirname(realpath(__file__)), filename)
+
+
+# TODO: consider using pytest.importorskip('gssapi') instead? We presumably
+# still need CLI configurability for the Kerberos parameters, though, so can't
+# JUST key off presence of GSSAPI optional dependency...
+# TODO: anyway, s/True/os.environ.get('RUN_GSSAPI', False)/ or something.
+needs_gssapi = pytest.mark.skipif(True, reason="No GSSAPI to test")
+
+
+def needs_builtin(name):
+    """
+    Skip decorated test if builtin name does not exist.
+    """
+    reason = "Test requires a builtin '{}'".format(name)
+    return pytest.mark.skipif(not hasattr(builtins, name), reason=reason)
+
+
+slow = pytest.mark.slow
+
+
+utf8_password = u('\u2022')
+
+
+FINGERPRINTS = {
+    'ssh-dss': b'\x44\x78\xf0\xb9\xa2\x3c\xc5\x18\x20\x09\xff\x75\x5b\xc1\xd2\x6c', # noqa
+    'ssh-rsa': b'\x60\x73\x38\x44\xcb\x51\x86\x65\x7f\xde\xda\xa2\x2b\x5a\x57\xd5', # noqa
+    'ecdsa-sha2-nistp256': b'\x25\x19\xeb\x55\xe6\xa1\x47\xff\x4f\x38\xd2\x75\x6f\xa5\xd5\x60', # noqa
+    'ssh-ed25519': b'\xb3\xd5"\xaa\xf9u^\xe8\xcd\x0e\xea\x02\xb9)\xa2\x80',
+}
+
+
+class NullServer(ServerInterface):
+    paranoid_did_password = False
+    paranoid_did_public_key = False
+    paranoid_key = DSSKey.from_private_key_file(_support('test_dss.key'))
+
+    def __init__(self, *args, **kwargs):
+        # Allow tests to enable/disable specific key types
+        self.__allowed_keys = kwargs.pop('allowed_keys', [])
+        # And allow them to set a (single...meh) expected public blob (cert)
+        self.__expected_public_blob = kwargs.pop('public_blob', None)
+        super(NullServer, self).__init__(*args, **kwargs)
+        self.logger = logging.getLogger('test-server')
+
+    def _log(self, message):
+        self.logger.debug(message)
+
+    def get_allowed_auths(self, username):
+        if username == 'slowdive':
+            return 'publickey,password'
+        if username == 'paranoid':
+            if (
+                not self.paranoid_did_password and
+                not self.paranoid_did_public_key
+            ):
+                return 'publickey,password'
+            elif self.paranoid_did_password:
+                return 'publickey'
+            else:
+                return 'password'
+        if username == 'commie':
+            return 'keyboard-interactive'
+        if username == 'utf8':
+            return 'password'
+        if username == 'non-utf8':
+            return 'password'
+        return 'publickey'
+
+    def check_auth_password(self, username, password):
+        if (username == 'slowdive') and (password == 'pygmalion'):
+            return AUTH_SUCCESSFUL
+        if (username == 'paranoid') and (password == 'paranoid'):
+            # 2-part auth (even openssh doesn't support this)
+            self.paranoid_did_password = True
+            if self.paranoid_did_public_key:
+                return AUTH_SUCCESSFUL
+            return AUTH_PARTIALLY_SUCCESSFUL
+        if (username == 'utf8') and (password == utf8_password):
+            return AUTH_SUCCESSFUL
+        if (username == 'non-utf8') and (password == '\xff'):
+            return AUTH_SUCCESSFUL
+        if username == 'bad-server':
+            raise Exception("Ack!")
+        if (username == 'slowdive') and (password == 'unresponsive-server'):
+            sleep(5)
+            return AUTH_SUCCESSFUL
+        return AUTH_FAILED
+
+    def check_auth_publickey(self, username, key):
+        # NOTE: this is for an existing multipart auth test.
+        if (username == 'paranoid') and (key == self.paranoid_key):
+            # 2-part auth
+            self.paranoid_did_public_key = True
+            if self.paranoid_did_password:
+                return AUTH_SUCCESSFUL
+            return AUTH_PARTIALLY_SUCCESSFUL
+        # NOTE: these bits below are mostly used by client tests or
+        # straightforward key tests.
+        try:
+            expected = FINGERPRINTS[key.get_name()]
+        except KeyError:
+            return AUTH_FAILED
+        # Base check: allowed auth type & fingerprint matches
+        happy = (
+            key.get_name() in self.__allowed_keys and
+            key.get_fingerprint() == expected
+        )
+        # Secondary check: if test wants assertions about cert data
+        if (
+            self.__expected_public_blob is not None and
+            key.public_blob != self.__expected_public_blob
+        ):
+            happy = False
+        return AUTH_SUCCESSFUL if happy else AUTH_FAILED
+
+    def check_auth_interactive(self, username, submethods):
+        if username == 'commie':
+            self.username = username
+            return InteractiveQuery(
+                'password',
+                'Please enter a password.',
+                ('Password', False),
+            )
+        return AUTH_FAILED
+
+    def check_auth_interactive_response(self, responses):
+        if self.username == 'commie':
+            if (len(responses) == 1) and (responses[0] == 'cat'):
+                return AUTH_SUCCESSFUL
+        return AUTH_FAILED
+
+    def check_auth_none(self, username):
+        return AUTH_SUCCESSFUL if username == 'nobody' else AUTH_FAILED
+
+    def check_channel_request(self, kind, chanid):
+        if kind == 'bogus':
+            return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED
+        return OPEN_SUCCEEDED
+
+    def check_channel_exec_request(self, channel, command):
+        if command != b'yes':
+            return False
+        return True
+
+    def check_channel_env_request(self, channel, name, value):
+        if name == 'INVALID_ENV':
+            return False
+
+        if not hasattr(channel, 'env'):
+            setattr(channel, 'env', {})
+
+        channel.env[name] = value
+        return True
+
+    def check_channel_shell_request(self, channel):
+        return True
+
+    def check_global_request(self, kind, msg):
+        self._global_request = kind
+        return False
+
+    def check_channel_x11_request(
+        self,
+        channel,
+        single_connection,
+        auth_protocol,
+        auth_cookie,
+        screen_number,
+    ):
+        self._x11_single_connection = single_connection
+        self._x11_auth_protocol = auth_protocol
+        self._x11_auth_cookie = auth_cookie
+        self._x11_screen_number = screen_number
+        return True
+
+    def check_port_forward_request(self, addr, port):
+        self._listen = socket.socket()
+        self._listen.bind(('127.0.0.1', 0))
+        self._listen.listen(1)
+        return self._listen.getsockname()[1]
+
+    def cancel_port_forward_request(self, addr, port):
+        self._listen.close()
+        self._listen = None
+
+    def check_channel_direct_tcpip_request(self, chanid, origin, destination):
+        self._tcpip_dest = destination
+        return OPEN_SUCCEEDED
diff --git a/tests/authentication.py b/tests/authentication.py
new file mode 100644
index 000000000..6238a8bbc
--- /dev/null
+++ b/tests/authentication.py
@@ -0,0 +1,151 @@
+from pytest import skip, raises
+
+from paramiko import BadAuthenticationType, AuthenticationException
+
+from ._util import slow, utf8_password
+
+
+# NOTE: GSSAPI is kind of a standalone feature and has its own tests in
+# test_kex_gss.py, test_ssh_gss.py and test_gssapi.py.
+
+# NOTE: test arguments are pytest fixtures, which can be found in conftest.py
+
+
+#
+# Edge/error cases that aren't strongly tied to a given success case
+#
+
+class EdgeCases:
+    def server_does_not_support_our_requested_auth_type(self, trans):
+        with raises(BadAuthenticationType) as info:
+            # TODO: Authenticator(trans).authenticate('unknown',
+            # PasswordAuth('error'))
+            trans.connect(username='unknown', password='error')
+        # TODO: new hybrid subclass w/ single PasswordAuth->failure pairing,
+        # value is BadAuthType w/ some list of allowed_types
+        assert info.value.allowed_types == ['publickey']
+
+    def disconnections(self, trans):
+        # Disconnections during auth step show up as an auth exception
+        trans.connect()
+        with raises(AuthenticationException):
+            trans.auth_password('bad-server', 'hello')
+
+    @slow
+    def non_responsive_servers_raise_auth_exception_with_timeout(self, trans):
+        trans.auth_timeout = 1  # 1 second, to speed up test
+        trans.start_client()
+        with raises(AuthenticationException, match='Authentication timeout'):
+            trans.auth_password('slowdive', 'unresponsive-server')
+
+
+#
+# Single auth sources
+#
+
+class None_:
+    def raises_BadAuthenticationType_if_server_rejects(self, trans):
+        # TODO: given this is usually called just as a no-op to check what a
+        # server allows, we may want to offer a wrapper for this instead of
+        # requiring oddball exception flow?
+        with raises(BadAuthenticationType) as info:
+            # TODO: Authenticator(trans).authenticate('paranoid',
+            # NoneAuthOrWhatever())
+            trans.start_client()
+            trans.auth_none('paranoid')
+        # TODO: the new overarching exception instead of a
+        # BadAuthenticationType
+        assert info.value.allowed_types == ['publickey', 'password']
+
+    def may_be_accepted_by_extremely_naughty_servers(self, trans):
+        # Yes, this is a thing that exists in reality & it's supported by the
+        # RFC as well!
+        # TODO: Authenticator(trans).authenticate('whatever',
+        # NoneAuthOrWhatever())
+        # TODO: return value would be our hybrid result object whose iterable
+        # is the single NoneAuthOrWhatever + success signifier
+        trans.start_client()
+        assert trans.auth_none('nobody') == []
+
+
+class Password:
+    pass
+
+
+class Interactive:
+    # TODO: how exactly is auth_interactive different from auth_password?
+    # TODO: and what's the diff between transport's interactive vs
+    # interactive_dumb?
+    # TODO: and how (is?) it different from what's used for TOTP
+    pass
+
+
+class UnencryptedPubKey:
+    pass
+
+
+class EncryptedPubKey:
+    pass
+
+
+#
+# Multiple auth sources, of which only one is needed/valid
+#
+
+class ManyAuthsEnterOneAuthLeaves:
+    pass
+
+
+#
+# True multi-factor auth, where more than one source is needed/required
+#
+
+class MultiFactor:
+    pass
+
+
+#
+# Unit-style tests for actual new auth APIs, insofar as they're not 100% tested
+# in the above tests.
+#
+
+class Authenticator_:
+    class init:
+        def requires_a_Transport(self):
+            skip()   
+
+        def transport_must_already_be_started(self):
+            skip()
+
+    class authenticate_with_kwargs:
+        def one_kwarg_becomes_an_auth_source(self):
+            skip()
+
+        def another_kwarg_becomes_another_auth_source(self):
+            skip()
+
+        # ...
+
+    class authenticate:
+        # TODO: @raises(AuthenticationError or subclass)
+        def must_be_given_at_least_one_auth_source(self):
+            # a.authenticate()
+            skip()
+
+        # TODO: @raises(TypeError or ValueError or w/e)
+        def args_must_be_AuthSource_objects(self):
+            # a.authenticate(object())
+            skip()
+
+        def tries_given_sources_in_order(self):
+            # a.authenticate(password, key) calls auth_password (which should
+            # fail), then auth_publickey (& succeed, I guess)
+            skip()
+
+        def returns_AuthenticationResult(self):
+            skip()
+
+
+# TODO: name it AuthResult instead?
+class AuthenticationResult_:
+    pass
diff --git a/tests/conftest.py b/tests/conftest.py
index d1967a733..d927b93f0 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -6,9 +6,9 @@
 import pytest
 from paramiko import RSAKey, SFTPServer, SFTP, Transport
 
-from .loop import LoopSocket
-from .stub_sftp import StubServer, StubSFTPServer
-from .util import _support
+from ._loop import LoopSocket
+from ._stub_sftp import StubServer, StubSFTPServer
+from ._util import _support, NullServer
 
 
 # TODO: not a huge fan of conftest.py files, see if we can move these somewhere
@@ -28,6 +28,40 @@
     )
 
 
+@pytest.fixture
+def trans():
+    """
+    Create `LoopSocket`-based server/client `Transport`s, yielding the latter.
+
+    Uses `NullServer` under the hood.
+    """
+    # NOTE: based on the setup/teardown/start_server/verify_finished methods
+    # found in ye olde test_auth.py
+
+    # "Network" setup
+    socks = LoopSocket()
+    sockc = LoopSocket()
+    sockc.link(socks)
+    tc = Transport(sockc)
+    ts = Transport(socks)
+
+    # Start up the in-memory server
+    host_key = RSAKey.from_private_key_file(_support('test_rsa.key'))
+    ts.add_server_key(host_key)
+    event = threading.Event()
+    server = NullServer()
+    ts.start_server(event, server)
+
+    # Tests frequently need to call Transport.connect on the client side, etc
+    yield tc
+
+    # Close things down
+    tc.close()
+    ts.close()
+    socks.close()
+    sockc.close()
+
+
 def make_sftp_folder():
     """
     Ensure expected target temp folder exists on the remote end.
diff --git a/tests/test_auth.py b/tests/test_auth.py
index dacdd654c..c79b482d0 100644
--- a/tests/test_auth.py
+++ b/tests/test_auth.py
@@ -20,238 +20,91 @@
 Some unit tests for authenticating over a Transport.
 """
 
-import sys
-import threading
-import unittest
-from time import sleep
-
 from paramiko import (
-    Transport, ServerInterface, RSAKey, DSSKey, BadAuthenticationType,
-    InteractiveQuery, AuthenticationException,
+    DSSKey, BadAuthenticationType, AuthenticationException,
 )
-from paramiko import AUTH_FAILED, AUTH_PARTIALLY_SUCCESSFUL, AUTH_SUCCESSFUL
-from paramiko.py3compat import u
-
-from .loop import LoopSocket
-from .util import _support, slow
-
-
-_pwd = u('\u2022')
-
-
-class NullServer (ServerInterface):
-    paranoid_did_password = False
-    paranoid_did_public_key = False
-    paranoid_key = DSSKey.from_private_key_file(_support('test_dss.key'))
-
-    def get_allowed_auths(self, username):
-        if username == 'slowdive':
-            return 'publickey,password'
-        if username == 'paranoid':
-            if not self.paranoid_did_password and not self.paranoid_did_public_key:
-                return 'publickey,password'
-            elif self.paranoid_did_password:
-                return 'publickey'
-            else:
-                return 'password'
-        if username == 'commie':
-            return 'keyboard-interactive'
-        if username == 'utf8':
-            return 'password'
-        if username == 'non-utf8':
-            return 'password'
-        return 'publickey'
-
-    def check_auth_password(self, username, password):
-        if (username == 'slowdive') and (password == 'pygmalion'):
-            return AUTH_SUCCESSFUL
-        if (username == 'paranoid') and (password == 'paranoid'):
-            # 2-part auth (even openssh doesn't support this)
-            self.paranoid_did_password = True
-            if self.paranoid_did_public_key:
-                return AUTH_SUCCESSFUL
-            return AUTH_PARTIALLY_SUCCESSFUL
-        if (username == 'utf8') and (password == _pwd):
-            return AUTH_SUCCESSFUL
-        if (username == 'non-utf8') and (password == '\xff'):
-            return AUTH_SUCCESSFUL
-        if username == 'bad-server':
-            raise Exception("Ack!")
-        if username == 'unresponsive-server':
-            sleep(5)
-            return AUTH_SUCCESSFUL
-        return AUTH_FAILED
-
-    def check_auth_publickey(self, username, key):
-        if (username == 'paranoid') and (key == self.paranoid_key):
-            # 2-part auth
-            self.paranoid_did_public_key = True
-            if self.paranoid_did_password:
-                return AUTH_SUCCESSFUL
-            return AUTH_PARTIALLY_SUCCESSFUL
-        return AUTH_FAILED
-
-    def check_auth_interactive(self, username, submethods):
-        if username == 'commie':
-            self.username = username
-            return InteractiveQuery('password', 'Please enter a password.', ('Password', False))
-        return AUTH_FAILED
+from pytest import raises
 
-    def check_auth_interactive_response(self, responses):
-        if self.username == 'commie':
-            if (len(responses) == 1) and (responses[0] == 'cat'):
-                return AUTH_SUCCESSFUL
-        return AUTH_FAILED
+from ._util import _support, slow, utf8_password
 
 
-class AuthTest (unittest.TestCase):
-
-    def setUp(self):
-        self.socks = LoopSocket()
-        self.sockc = LoopSocket()
-        self.sockc.link(self.socks)
-        self.tc = Transport(self.sockc)
-        self.ts = Transport(self.socks)
-
-    def tearDown(self):
-        self.tc.close()
-        self.ts.close()
-        self.socks.close()
-        self.sockc.close()
-
-    def start_server(self):
-        host_key = RSAKey.from_private_key_file(_support('test_rsa.key'))
-        self.public_host_key = RSAKey(data=host_key.asbytes())
-        self.ts.add_server_key(host_key)
-        self.event = threading.Event()
-        self.server = NullServer()
-        self.assertTrue(not self.event.is_set())
-        self.ts.start_server(self.event, self.server)
-
-    def verify_finished(self):
-        self.event.wait(1.0)
-        self.assertTrue(self.event.is_set())
-        self.assertTrue(self.ts.is_active())
-
-    def test_bad_auth_type(self):
-        """
-        verify that we get the right exception when an unsupported auth
-        type is requested.
-        """
-        self.start_server()
-        try:
-            self.tc.connect(hostkey=self.public_host_key,
-                            username='unknown', password='error')
-            self.assertTrue(False)
-        except:
-            etype, evalue, etb = sys.exc_info()
-            self.assertEqual(BadAuthenticationType, etype)
-            self.assertEqual(['publickey'], evalue.allowed_types)
-
-    def test_bad_password(self):
+class TestPasswordAuth:
+    # TODO: store as new suite along w/ successful password tests (The utf8
+    # ones below I think)
+    def test_bad_password(self, trans):
         """
         verify that a bad password gets the right exception, and that a retry
         with the right password works.
         """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        try:
-            self.tc.auth_password(username='slowdive', password='error')
-            self.assertTrue(False)
-        except:
-            etype, evalue, etb = sys.exc_info()
-            self.assertTrue(issubclass(etype, AuthenticationException))
-        self.tc.auth_password(username='slowdive', password='pygmalion')
-        self.verify_finished()
+        trans.connect()
+        with raises(AuthenticationException):
+            trans.auth_password(username='slowdive', password='error')
+        trans.auth_password(username='slowdive', password='pygmalion')
 
-    def test_multipart_auth(self):
-        """
-        verify that multipart auth works.
-        """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        remain = self.tc.auth_password(username='paranoid', password='paranoid')
-        self.assertEqual(['publickey'], remain)
-        key = DSSKey.from_private_key_file(_support('test_dss.key'))
-        remain = self.tc.auth_publickey(username='paranoid', key=key)
-        self.assertEqual([], remain)
-        self.verify_finished()
-
-    def test_interactive_auth(self):
-        """
-        verify keyboard-interactive auth works.
-        """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-
-        def handler(title, instructions, prompts):
-            self.got_title = title
-            self.got_instructions = instructions
-            self.got_prompts = prompts
-            return ['cat']
-        remain = self.tc.auth_interactive('commie', handler)
-        self.assertEqual(self.got_title, 'password')
-        self.assertEqual(self.got_prompts, [('Password', False)])
-        self.assertEqual([], remain)
-        self.verify_finished()
-
-    def test_interactive_auth_fallback(self):
+    def test_interactive_auth_fallback(self, trans):
         """
         verify that a password auth attempt will fallback to "interactive"
         if password auth isn't supported but interactive is.
         """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        remain = self.tc.auth_password('commie', 'cat')
-        self.assertEqual([], remain)
-        self.verify_finished()
+        trans.connect()
+        remains = trans.auth_password('commie', 'cat')
+        assert remains == []
 
-    def test_auth_utf8(self):
+    def test_auth_utf8(self, trans):
         """
         verify that utf-8 encoding happens in authentication.
         """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        remain = self.tc.auth_password('utf8', _pwd)
-        self.assertEqual([], remain)
-        self.verify_finished()
+        trans.connect()
+        remains = trans.auth_password('utf8', utf8_password)
+        assert remains == []
 
-    def test_auth_non_utf8(self):
+    def test_auth_non_utf8(self, trans):
         """
         verify that non-utf-8 encoded passwords can be used for broken
         servers.
         """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        remain = self.tc.auth_password('non-utf8', '\xff')
-        self.assertEqual([], remain)
-        self.verify_finished()
+        trans.connect()
+        remains = trans.auth_password('non-utf8', '\xff')
+        assert remains == []
+
 
-    def test_auth_gets_disconnected(self):
+class TestInteractiveAuth:
+    # TODO: identify other test cases to expand around this one
+    def test_interactive_auth(self, trans):
         """
-        verify that we catch a server disconnecting during auth, and report
-        it as an auth failure.
+        verify keyboard-interactive auth works.
         """
-        self.start_server()
-        self.tc.connect(hostkey=self.public_host_key)
-        try:
-            remain = self.tc.auth_password('bad-server', 'hello')
-        except:
-            etype, evalue, etb = sys.exc_info()
-            self.assertTrue(issubclass(etype, AuthenticationException))
+        trans.connect()
+        # TODO: mock the server transport harder instead of using these
+        # globals, ew.
+        global got_title, got_instructions, got_prompts
+        got_title, got_instructions, got_prompts = None, None, None
+        def handler(title, instructions, prompts):
+            # Big meh.
+            global got_title, got_instructions, got_prompts
+            got_title = title
+            got_instructions = instructions
+            got_prompts = prompts
+            return ['cat']
+        remains = trans.auth_interactive('commie', handler)
+        assert got_title == 'password'
+        assert got_prompts == [('Password', False)]
+        assert remains == []
+
 
-    @slow
-    def test_auth_non_responsive(self):
+class TestMultipartAuth:
+    # TODO: clarify the name of this to show it's only one specific multipart
+    # auth style
+    def test_multipart_auth(self, trans):
         """
-        verify that authentication times out if server takes to long to
-        respond (or never responds).
+        verify that multipart auth works.
         """
-        self.tc.auth_timeout = 1  # 1 second, to speed up test
-        self.start_server()
-        self.tc.connect()
-        try:
-            remain = self.tc.auth_password('unresponsive-server', 'hello')
-        except:
-            etype, evalue, etb = sys.exc_info()
-            self.assertTrue(issubclass(etype, AuthenticationException))
-            self.assertTrue('Authentication timeout' in str(evalue))
+        trans.connect()
+        remains = trans.auth_password(
+            username='paranoid',
+            password='paranoid',
+        )
+        assert remains == ['publickey']
+        key = DSSKey.from_private_key_file(_support('test_dss.key'))
+        remains = trans.auth_publickey(username='paranoid', key=key)
+        assert remains == []
diff --git a/tests/test_client.py b/tests/test_client.py
index 7163fdcfb..60dab3abe 100644
--- a/tests/test_client.py
+++ b/tests/test_client.py
@@ -40,78 +40,13 @@
 from paramiko.common import PY2
 from paramiko.ssh_exception import SSHException, AuthenticationException
 
-from .util import _support, slow
+from ._util import _support, slow, NullServer, FINGERPRINTS
 
 
 requires_gss_auth = unittest.skipUnless(
     paramiko.GSS_AUTH_AVAILABLE, "GSS auth not available"
 )
 
-FINGERPRINTS = {
-    'ssh-dss': b'\x44\x78\xf0\xb9\xa2\x3c\xc5\x18\x20\x09\xff\x75\x5b\xc1\xd2\x6c',
-    'ssh-rsa': b'\x60\x73\x38\x44\xcb\x51\x86\x65\x7f\xde\xda\xa2\x2b\x5a\x57\xd5',
-    'ecdsa-sha2-nistp256': b'\x25\x19\xeb\x55\xe6\xa1\x47\xff\x4f\x38\xd2\x75\x6f\xa5\xd5\x60',
-    'ssh-ed25519': b'\xb3\xd5"\xaa\xf9u^\xe8\xcd\x0e\xea\x02\xb9)\xa2\x80',
-}
-
-
-class NullServer(paramiko.ServerInterface):
-    def __init__(self, *args, **kwargs):
-        # Allow tests to enable/disable specific key types
-        self.__allowed_keys = kwargs.pop('allowed_keys', [])
-        # And allow them to set a (single...meh) expected public blob (cert)
-        self.__expected_public_blob = kwargs.pop('public_blob', None)
-        super(NullServer, self).__init__(*args, **kwargs)
-
-    def get_allowed_auths(self, username):
-        if username == 'slowdive':
-            return 'publickey,password'
-        return 'publickey'
-
-    def check_auth_password(self, username, password):
-        if (username == 'slowdive') and (password == 'pygmalion'):
-            return paramiko.AUTH_SUCCESSFUL
-        if (username == 'slowdive') and (password == 'unresponsive-server'):
-            time.sleep(5)
-            return paramiko.AUTH_SUCCESSFUL
-        return paramiko.AUTH_FAILED
-
-    def check_auth_publickey(self, username, key):
-        try:
-            expected = FINGERPRINTS[key.get_name()]
-        except KeyError:
-            return paramiko.AUTH_FAILED
-        # Base check: allowed auth type & fingerprint matches
-        happy = (
-            key.get_name() in self.__allowed_keys and
-            key.get_fingerprint() == expected
-        )
-        # Secondary check: if test wants assertions about cert data
-        if (
-            self.__expected_public_blob is not None and
-            key.public_blob != self.__expected_public_blob
-        ):
-            happy = False
-        return paramiko.AUTH_SUCCESSFUL if happy else paramiko.AUTH_FAILED
-
-    def check_channel_request(self, kind, chanid):
-        return paramiko.OPEN_SUCCEEDED
-
-    def check_channel_exec_request(self, channel, command):
-        if command != b'yes':
-            return False
-        return True
-
-    def check_channel_env_request(self, channel, name, value):
-        if name == 'INVALID_ENV':
-            return False
-
-        if not hasattr(channel, 'env'):
-            setattr(channel, 'env', {})
-
-        channel.env[name] = value
-        return True
-
 
 class ClientTest(unittest.TestCase):
     def setUp(self):
diff --git a/tests/test_file.py b/tests/test_file.py
index 3d2c94e6d..86d244769 100644
--- a/tests/test_file.py
+++ b/tests/test_file.py
@@ -27,7 +27,7 @@
 from paramiko.file import BufferedFile
 from paramiko.py3compat import BytesIO
 
-from .util import needs_builtin
+from ._util import needs_builtin
 
 
 class LoopbackFile (BufferedFile):
diff --git a/tests/test_gssapi.py b/tests/test_gssapi.py
index d4b632be4..583532bcf 100644
--- a/tests/test_gssapi.py
+++ b/tests/test_gssapi.py
@@ -25,7 +25,7 @@
 import unittest
 import socket
 
-from .util import needs_gssapi
+from ._util import needs_gssapi
 
 
 @needs_gssapi
diff --git a/tests/test_kex_gss.py b/tests/test_kex_gss.py
index 025d1faac..a4f6a65c2 100644
--- a/tests/test_kex_gss.py
+++ b/tests/test_kex_gss.py
@@ -31,7 +31,7 @@
 
 import paramiko
 
-from .util import needs_gssapi
+from ._util import needs_gssapi
 
 
 class NullServer (paramiko.ServerInterface):
diff --git a/tests/test_packetizer.py b/tests/test_packetizer.py
index 414b7e38f..c477cb700 100644
--- a/tests/test_packetizer.py
+++ b/tests/test_packetizer.py
@@ -30,7 +30,7 @@
 from paramiko import Message, Packetizer, util
 from paramiko.common import byte_chr, zero_byte
 
-from .loop import LoopSocket
+from ._loop import LoopSocket
 
 
 x55 = byte_chr(0x55)
diff --git a/tests/test_pkey.py b/tests/test_pkey.py
index c745232b8..c76aa854f 100644
--- a/tests/test_pkey.py
+++ b/tests/test_pkey.py
@@ -30,7 +30,7 @@
 from paramiko import RSAKey, DSSKey, ECDSAKey, Ed25519Key, Message, util
 from paramiko.py3compat import StringIO, byte_chr, b, bytes, PY2
 
-from .util import _support
+from ._util import _support
 
 
 # from openssh's ssh-keygen
@@ -467,6 +467,16 @@ def test_ed25519_compare(self):
         self.assertTrue(not pub.can_sign())
         self.assertEqual(key, pub)
 
+    def test_ed25519_nonbytes_password(self):
+        # https://github.com/paramiko/paramiko/issues/1039
+        key = Ed25519Key.from_private_key_file(
+            _support('test_ed25519_password.key'),
+            # NOTE: not a bytes. Amusingly, the test above for same key DOES
+            # explicitly cast to bytes...code smell!
+            'abc123',
+        )
+        # No exception -> it's good. Meh.
+
     def test_ed25519_load_from_file_obj(self):
         with open(_support('test_ed25519.key')) as pkey_fileobj:
             key = Ed25519Key.from_private_key(pkey_fileobj)
diff --git a/tests/test_sftp.py b/tests/test_sftp.py
index 09a50453b..d4c0df77b 100644
--- a/tests/test_sftp.py
+++ b/tests/test_sftp.py
@@ -40,9 +40,9 @@
 from paramiko.common import o777, o600, o666, o644
 from paramiko.sftp_attr import SFTPAttributes
 
-from .util import needs_builtin
-from .stub_sftp import StubServer, StubSFTPServer
-from .util import _support, slow
+from ._util import needs_builtin
+from ._stub_sftp import StubServer, StubSFTPServer
+from ._util import _support, slow
 
 
 ARTICLE = '''
diff --git a/tests/test_sftp_big.py b/tests/test_sftp_big.py
index a659098d0..a54a10cc1 100644
--- a/tests/test_sftp_big.py
+++ b/tests/test_sftp_big.py
@@ -32,7 +32,7 @@
 
 from paramiko.common import o660
 
-from .util import slow
+from ._util import slow
 
 
 @slow
diff --git a/tests/test_ssh_gss.py b/tests/test_ssh_gss.py
index f0645e0e6..06bdb211b 100644
--- a/tests/test_ssh_gss.py
+++ b/tests/test_ssh_gss.py
@@ -29,7 +29,7 @@
 
 import paramiko
 
-from .util import _support, needs_gssapi
+from ._util import _support, needs_gssapi
 from .test_client import FINGERPRINTS
 
 
diff --git a/tests/test_transport.py b/tests/test_transport.py
index 00639d047..3944b06e0 100644
--- a/tests/test_transport.py
+++ b/tests/test_transport.py
@@ -44,8 +44,8 @@
 from paramiko.py3compat import bytes
 from paramiko.message import Message
 
-from .util import needs_builtin, _support, slow
-from .loop import LoopSocket
+from ._util import needs_builtin, _support, slow, NullServer
+from ._loop import LoopSocket
 
 
 LONG_BANNER = """\
@@ -61,60 +61,6 @@
 """
 
 
-class NullServer (ServerInterface):
-    paranoid_did_password = False
-    paranoid_did_public_key = False
-    paranoid_key = DSSKey.from_private_key_file(_support('test_dss.key'))
-
-    def get_allowed_auths(self, username):
-        if username == 'slowdive':
-            return 'publickey,password'
-        return 'publickey'
-
-    def check_auth_password(self, username, password):
-        if (username == 'slowdive') and (password == 'pygmalion'):
-            return AUTH_SUCCESSFUL
-        return AUTH_FAILED
-
-    def check_channel_request(self, kind, chanid):
-        if kind == 'bogus':
-            return OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED
-        return OPEN_SUCCEEDED
-
-    def check_channel_exec_request(self, channel, command):
-        if command != b'yes':
-            return False
-        return True
-
-    def check_channel_shell_request(self, channel):
-        return True
-
-    def check_global_request(self, kind, msg):
-        self._global_request = kind
-        return False
-
-    def check_channel_x11_request(self, channel, single_connection, auth_protocol, auth_cookie, screen_number):
-        self._x11_single_connection = single_connection
-        self._x11_auth_protocol = auth_protocol
-        self._x11_auth_cookie = auth_cookie
-        self._x11_screen_number = screen_number
-        return True
-
-    def check_port_forward_request(self, addr, port):
-        self._listen = socket.socket()
-        self._listen.bind(('127.0.0.1', 0))
-        self._listen.listen(1)
-        return self._listen.getsockname()[1]
-
-    def cancel_port_forward_request(self, addr, port):
-        self._listen.close()
-        self._listen = None
-
-    def check_channel_direct_tcpip_request(self, chanid, origin, destination):
-        self._tcpip_dest = destination
-        return OPEN_SUCCEEDED
-
-
 class TransportTest(unittest.TestCase):
     def setUp(self):
         self.socks = LoopSocket()
@@ -143,8 +89,7 @@ def setup_test_server(self, client_options=None, server_options=None):
         self.server = NullServer()
         self.assertTrue(not event.is_set())
         self.ts.start_server(event, self.server)
-        self.tc.connect(hostkey=public_host_key,
-                        username='slowdive', password='pygmalion')
+        self.tc.connect(username='slowdive', password='pygmalion')
         event.wait(1.0)
         self.assertTrue(event.is_set())
         self.assertTrue(self.ts.is_active())
@@ -200,8 +145,7 @@ def test_3_simple(self):
         self.assertEqual(False, self.tc.is_authenticated())
         self.assertEqual(False, self.ts.is_authenticated())
         self.ts.start_server(event, server)
-        self.tc.connect(hostkey=public_host_key,
-                        username='slowdive', password='pygmalion')
+        self.tc.connect(username='slowdive', password='pygmalion')
         event.wait(1.0)
         self.assertTrue(event.is_set())
         self.assertTrue(self.ts.is_active())
@@ -222,8 +166,7 @@ def test_3a_long_banner(self):
         self.assertTrue(not event.is_set())
         self.socks.send(LONG_BANNER)
         self.ts.start_server(event, server)
-        self.tc.connect(hostkey=public_host_key,
-                        username='slowdive', password='pygmalion')
+        self.tc.connect(username='slowdive', password='pygmalion')
         event.wait(1.0)
         self.assertTrue(event.is_set())
         self.assertTrue(self.ts.is_active())
@@ -840,7 +783,6 @@ def read_message(self):
         self.tc.handshake_timeout = 0.000000000001
         self.ts.start_server(event, server)
         self.assertRaises(EOFError, self.tc.connect,
-                          hostkey=public_host_key,
                           username='slowdive',
                           password='pygmalion')
 
diff --git a/tests/util.py b/tests/util.py
deleted file mode 100644
index 4ca023743..000000000
--- a/tests/util.py
+++ /dev/null
@@ -1,27 +0,0 @@
-from os.path import dirname, realpath, join
-
-import pytest
-
-from paramiko.py3compat import builtins
-
-
-def _support(filename):
-    return join(dirname(realpath(__file__)), filename)
-
-
-# TODO: consider using pytest.importorskip('gssapi') instead? We presumably
-# still need CLI configurability for the Kerberos parameters, though, so can't
-# JUST key off presence of GSSAPI optional dependency...
-# TODO: anyway, s/True/os.environ.get('RUN_GSSAPI', False)/ or something.
-needs_gssapi = pytest.mark.skipif(True, reason="No GSSAPI to test")
-
-
-def needs_builtin(name):
-    """
-    Skip decorated test if builtin name does not exist.
-    """
-    reason = "Test requires a builtin '{}'".format(name)
-    return pytest.mark.skipif(not hasattr(builtins, name), reason=reason)
-
-
-slow = pytest.mark.slow
