diff --git a/examples/src/main/java/org/mp4parser/examples/exportraw/ExtractRawH264.java b/examples/src/main/java/org/mp4parser/examples/exportraw/ExtractRawH264.java
index 92e0d3d711..e7b79d004a 100755
--- a/examples/src/main/java/org/mp4parser/examples/exportraw/ExtractRawH264.java
+++ b/examples/src/main/java/org/mp4parser/examples/exportraw/ExtractRawH264.java
@@ -41,7 +41,7 @@ public static void main(String[] args) throws IOException {
 
         fc.write((ByteBuffer) separator.rewind());
         // Write SPS
-        fc.write(ByteBuffer.wrap(
+        fc.write((
                 ((AvcConfigurationBox) Path.getPath(trackBox, "mdia/minf/stbl/stsd/avc1/avcC")
                 ).getSequenceParameterSets().get(0)));
         // Warning:
@@ -49,7 +49,7 @@ public static void main(String[] args) throws IOException {
 
         fc.write((ByteBuffer) separator.rewind());
         // Write PPS
-        fc.write(ByteBuffer.wrap(
+        fc.write((
                 ((AvcConfigurationBox) Path.getPath(trackBox, "mdia/minf/stbl/stsd/avc1/avcC")
                 ).getPictureParameterSets().get(0)));
         // Warning:
diff --git a/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java b/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java
new file mode 100755
index 0000000000..57c11159fe
--- /dev/null
+++ b/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java
@@ -0,0 +1,24 @@
+package org.mp4parser.examples.mux.filebased;
+
+import org.mp4parser.Container;
+import org.mp4parser.muxer.FileDataSourceImpl;
+import org.mp4parser.muxer.Movie;
+import org.mp4parser.muxer.builder.DefaultMp4Builder;
+import org.mp4parser.muxer.tracks.h264.H264TrackImpl;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+/**
+ * Created by sannies on 26.10.2015.
+ */
+public class MuxMe {
+    public static void main(String[] args) throws IOException {
+        H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl("C:\\dev\\mp4parser\\streaming\\src\\test\\resources\\org\\mp4parser\\streaming\\input\\h264\\tos.h264"));
+        Movie m = new Movie();
+        m.addTrack(h264Track);
+        DefaultMp4Builder builder = new DefaultMp4Builder();
+        Container c = builder.build(m);
+        c.writeContainer(new FileOutputStream("output-old.mp4").getChannel());
+    }
+}
diff --git a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcConfigurationBox.java b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcConfigurationBox.java
index cf5ee875f2..ea6b544f3c 100755
--- a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcConfigurationBox.java
+++ b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcConfigurationBox.java
@@ -81,19 +81,19 @@ public void setLengthSizeMinusOne(int lengthSizeMinusOne) {
         this.avcDecoderConfigurationRecord.lengthSizeMinusOne = lengthSizeMinusOne;
     }
 
-    public List<byte[]> getSequenceParameterSets() {
+    public List<ByteBuffer> getSequenceParameterSets() {
         return Collections.unmodifiableList(avcDecoderConfigurationRecord.sequenceParameterSets);
     }
 
-    public void setSequenceParameterSets(List<byte[]> sequenceParameterSets) {
+    public void setSequenceParameterSets(List<ByteBuffer> sequenceParameterSets) {
         this.avcDecoderConfigurationRecord.sequenceParameterSets = sequenceParameterSets;
     }
 
-    public List<byte[]> getPictureParameterSets() {
+    public List<ByteBuffer> getPictureParameterSets() {
         return Collections.unmodifiableList(avcDecoderConfigurationRecord.pictureParameterSets);
     }
 
-    public void setPictureParameterSets(List<byte[]> pictureParameterSets) {
+    public void setPictureParameterSets(List<ByteBuffer> pictureParameterSets) {
         this.avcDecoderConfigurationRecord.pictureParameterSets = pictureParameterSets;
     }
 
@@ -121,11 +121,11 @@ public void setBitDepthChromaMinus8(int bitDepthChromaMinus8) {
         this.avcDecoderConfigurationRecord.bitDepthChromaMinus8 = bitDepthChromaMinus8;
     }
 
-    public List<byte[]> getSequenceParameterSetExts() {
+    public List<ByteBuffer> getSequenceParameterSetExts() {
         return avcDecoderConfigurationRecord.sequenceParameterSetExts;
     }
 
-    public void setSequenceParameterSetExts(List<byte[]> sequenceParameterSetExts) {
+    public void setSequenceParameterSetExts(List<ByteBuffer> sequenceParameterSetExts) {
         this.avcDecoderConfigurationRecord.sequenceParameterSetExts = sequenceParameterSetExts;
     }
 
diff --git a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcDecoderConfigurationRecord.java b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcDecoderConfigurationRecord.java
index 3722e19f5d..b90e2310c7 100755
--- a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcDecoderConfigurationRecord.java
+++ b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part15/AvcDecoderConfigurationRecord.java
@@ -19,14 +19,14 @@
     public int profileCompatibility;
     public int avcLevelIndication;
     public int lengthSizeMinusOne;
-    public List<byte[]> sequenceParameterSets = new ArrayList<byte[]>();
-    public List<byte[]> pictureParameterSets = new ArrayList<byte[]>();
+    public List<ByteBuffer> sequenceParameterSets = new ArrayList<ByteBuffer>();
+    public List<ByteBuffer> pictureParameterSets = new ArrayList<ByteBuffer>();
 
     public boolean hasExts = true;
     public int chromaFormat = 1;
     public int bitDepthLumaMinus8 = 0;
     public int bitDepthChromaMinus8 = 0;
-    public List<byte[]> sequenceParameterSetExts = new ArrayList<byte[]>();
+    public List<ByteBuffer> sequenceParameterSetExts = new ArrayList<ByteBuffer>();
 
     /**
      * Just for non-spec-conform encoders
@@ -55,14 +55,14 @@ public AvcDecoderConfigurationRecord(ByteBuffer content) {
 
             byte[] sequenceParameterSetNALUnit = new byte[sequenceParameterSetLength];
             content.get(sequenceParameterSetNALUnit);
-            sequenceParameterSets.add(sequenceParameterSetNALUnit);
+            sequenceParameterSets.add(ByteBuffer.wrap(sequenceParameterSetNALUnit));
         }
         long numberOfPictureParameterSets = IsoTypeReader.readUInt8(content);
         for (int i = 0; i < numberOfPictureParameterSets; i++) {
             int pictureParameterSetLength = IsoTypeReader.readUInt16(content);
             byte[] pictureParameterSetNALUnit = new byte[pictureParameterSetLength];
             content.get(pictureParameterSetNALUnit);
-            pictureParameterSets.add(pictureParameterSetNALUnit);
+            pictureParameterSets.add(ByteBuffer.wrap(pictureParameterSetNALUnit));
         }
         if (content.remaining() < 4) {
             hasExts = false;
@@ -82,7 +82,7 @@ public AvcDecoderConfigurationRecord(ByteBuffer content) {
                 int sequenceParameterSetExtLength = IsoTypeReader.readUInt16(content);
                 byte[] sequenceParameterSetExtNALUnit = new byte[sequenceParameterSetExtLength];
                 content.get(sequenceParameterSetExtNALUnit);
-                sequenceParameterSetExts.add(sequenceParameterSetExtNALUnit);
+                sequenceParameterSetExts.add(ByteBuffer.wrap(sequenceParameterSetExtNALUnit));
             }
         } else {
             chromaFormat = -1;
@@ -101,14 +101,14 @@ public void getContent(ByteBuffer byteBuffer) {
         bwb.writeBits(lengthSizeMinusOne, 2);
         bwb.writeBits(numberOfSequenceParameterSetsPaddingBits, 3);
         bwb.writeBits(pictureParameterSets.size(), 5);
-        for (byte[] sequenceParameterSetNALUnit : sequenceParameterSets) {
-            IsoTypeWriter.writeUInt16(byteBuffer, sequenceParameterSetNALUnit.length);
-            byteBuffer.put(sequenceParameterSetNALUnit);
+        for (ByteBuffer sequenceParameterSetNALUnit : sequenceParameterSets) {
+            IsoTypeWriter.writeUInt16(byteBuffer, sequenceParameterSetNALUnit.limit());
+            byteBuffer.put((ByteBuffer) sequenceParameterSetNALUnit.rewind());
         }
         IsoTypeWriter.writeUInt8(byteBuffer, pictureParameterSets.size());
-        for (byte[] pictureParameterSetNALUnit : pictureParameterSets) {
-            IsoTypeWriter.writeUInt16(byteBuffer, pictureParameterSetNALUnit.length);
-            byteBuffer.put(pictureParameterSetNALUnit);
+        for (ByteBuffer pictureParameterSetNALUnit : pictureParameterSets) {
+            IsoTypeWriter.writeUInt16(byteBuffer, pictureParameterSetNALUnit.limit());
+            byteBuffer.put((ByteBuffer) pictureParameterSetNALUnit.rewind());
         }
         if (hasExts && (avcProfileIndication == 100 || avcProfileIndication == 110 || avcProfileIndication == 122 || avcProfileIndication == 144)) {
 
@@ -119,9 +119,9 @@ public void getContent(ByteBuffer byteBuffer) {
             bwb.writeBits(bitDepthLumaMinus8, 3);
             bwb.writeBits(bitDepthChromaMinus8PaddingBits, 5);
             bwb.writeBits(bitDepthChromaMinus8, 3);
-            for (byte[] sequenceParameterSetExtNALUnit : sequenceParameterSetExts) {
-                IsoTypeWriter.writeUInt16(byteBuffer, sequenceParameterSetExtNALUnit.length);
-                byteBuffer.put(sequenceParameterSetExtNALUnit);
+            for (ByteBuffer sequenceParameterSetExtNALUnit : sequenceParameterSetExts) {
+                IsoTypeWriter.writeUInt16(byteBuffer, sequenceParameterSetExtNALUnit.limit());
+                byteBuffer.put((ByteBuffer) sequenceParameterSetExtNALUnit.reset());
             }
         }
     }
@@ -129,20 +129,20 @@ public void getContent(ByteBuffer byteBuffer) {
     public long getContentSize() {
         long size = 5;
         size += 1; // sequenceParamsetLength
-        for (byte[] sequenceParameterSetNALUnit : sequenceParameterSets) {
+        for (ByteBuffer sequenceParameterSetNALUnit : sequenceParameterSets) {
             size += 2; //lengthSizeMinusOne field
-            size += sequenceParameterSetNALUnit.length;
+            size += sequenceParameterSetNALUnit.limit();
         }
         size += 1; // pictureParamsetLength
-        for (byte[] pictureParameterSetNALUnit : pictureParameterSets) {
+        for (ByteBuffer pictureParameterSetNALUnit : pictureParameterSets) {
             size += 2; //lengthSizeMinusOne field
-            size += pictureParameterSetNALUnit.length;
+            size += pictureParameterSetNALUnit.limit();
         }
         if (hasExts && (avcProfileIndication == 100 || avcProfileIndication == 110 || avcProfileIndication == 122 || avcProfileIndication == 144)) {
             size += 4;
-            for (byte[] sequenceParameterSetExtNALUnit : sequenceParameterSetExts) {
+            for (ByteBuffer sequenceParameterSetExtNALUnit : sequenceParameterSetExts) {
                 size += 2;
-                size += sequenceParameterSetExtNALUnit.length;
+                size += sequenceParameterSetExtNALUnit.limit();
             }
         }
 
@@ -152,7 +152,7 @@ public long getContentSize() {
 
     public List<String> getSequenceParameterSetsAsStrings() {
         List<String> result = new ArrayList<String>(sequenceParameterSets.size());
-        for (byte[] parameterSet : sequenceParameterSets) {
+        for (ByteBuffer parameterSet : sequenceParameterSets) {
             result.add(Hex.encodeHex(parameterSet));
         }
         return result;
@@ -160,7 +160,7 @@ public long getContentSize() {
 
     public List<String> getSequenceParameterSetExtsAsStrings() {
         List<String> result = new ArrayList<String>(sequenceParameterSetExts.size());
-        for (byte[] parameterSet : sequenceParameterSetExts) {
+        for (ByteBuffer parameterSet : sequenceParameterSetExts) {
             result.add(Hex.encodeHex(parameterSet));
         }
         return result;
@@ -168,7 +168,7 @@ public long getContentSize() {
 
     public List<String> getPictureParameterSetsAsStrings() {
         List<String> result = new ArrayList<String>(pictureParameterSets.size());
-        for (byte[] parameterSet : pictureParameterSets) {
+        for (ByteBuffer parameterSet : pictureParameterSets) {
             result.add(Hex.encodeHex(parameterSet));
         }
         return result;
diff --git a/isoparser/src/main/java/org/mp4parser/tools/Hex.java b/isoparser/src/main/java/org/mp4parser/tools/Hex.java
index cdda02780b..d0005e25d8 100755
--- a/isoparser/src/main/java/org/mp4parser/tools/Hex.java
+++ b/isoparser/src/main/java/org/mp4parser/tools/Hex.java
@@ -21,6 +21,7 @@
 package org.mp4parser.tools;
 
 import java.io.ByteArrayOutputStream;
+import java.nio.ByteBuffer;
 
 /**
  * Converts hexadecimal Strings.
@@ -32,6 +33,17 @@ public static String encodeHex(byte[] data) {
         return encodeHex(data, 0);
     }
 
+    public static String encodeHex(ByteBuffer data) {
+        ByteBuffer byteBuffer = data.duplicate();
+        StringBuilder sb = new StringBuilder();
+        while (byteBuffer.remaining() > 0) {
+            byte b = byteBuffer.get();
+            sb.append(DIGITS[(0xF0 & b) >>> 4]);
+            sb.append(DIGITS[0x0F & b]);
+        }
+        return sb.toString();
+    }
+
     public static String encodeHex(byte[] data, int group) {
         int l = data.length;
         char[] out = new char[(l << 1) + (group > 0 ? (l / group) : 0)];
@@ -47,6 +59,7 @@ public static String encodeHex(byte[] data, int group) {
         return new String(out);
     }
 
+
     public static byte[] decodeHex(String hexString) {
         ByteArrayOutputStream bas = new ByteArrayOutputStream();
         for (int i = 0; i < hexString.length(); i += 2) {
diff --git a/muxer/src/main/java/org/mp4parser/muxer/tracks/Avc1ToAvc3TrackImpl.java b/muxer/src/main/java/org/mp4parser/muxer/tracks/Avc1ToAvc3TrackImpl.java
index 4b9566b41b..0b4716c8d1 100755
--- a/muxer/src/main/java/org/mp4parser/muxer/tracks/Avc1ToAvc3TrackImpl.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/tracks/Avc1ToAvc3TrackImpl.java
@@ -74,20 +74,20 @@ public Sample get(final int index) {
 
                     public void writeTo(WritableByteChannel channel) throws IOException {
 
-                        for (byte[] bytes : avcC.getSequenceParameterSets()) {
-                            IsoTypeWriterVariable.write(bytes.length, (ByteBuffer) buf.rewind(), len);
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSets()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), (ByteBuffer) buf.rewind(), len);
                             channel.write((ByteBuffer) buf.rewind());
-                            channel.write(ByteBuffer.wrap(bytes));
+                            channel.write(bytes);
                         }
-                        for (byte[] bytes : avcC.getSequenceParameterSetExts()) {
-                            IsoTypeWriterVariable.write(bytes.length, (ByteBuffer) buf.rewind(), len);
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSetExts()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), (ByteBuffer) buf.rewind(), len);
                             channel.write((ByteBuffer) buf.rewind());
-                            channel.write(ByteBuffer.wrap(bytes));
+                            channel.write((bytes));
                         }
-                        for (byte[] bytes : avcC.getPictureParameterSets()) {
-                            IsoTypeWriterVariable.write(bytes.length, (ByteBuffer) buf.rewind(), len);
+                        for (ByteBuffer bytes : avcC.getPictureParameterSets()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), (ByteBuffer) buf.rewind(), len);
                             channel.write((ByteBuffer) buf.rewind());
-                            channel.write(ByteBuffer.wrap(bytes));
+                            channel.write((bytes));
                         }
                         orignalSample.writeTo(channel);
                     }
@@ -95,14 +95,14 @@ public void writeTo(WritableByteChannel channel) throws IOException {
                     public long getSize() {
 
                         int spsPpsSize = 0;
-                        for (byte[] bytes : avcC.getSequenceParameterSets()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSets()) {
+                            spsPpsSize += len + bytes.limit();
                         }
-                        for (byte[] bytes : avcC.getSequenceParameterSetExts()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSetExts()) {
+                            spsPpsSize += len + bytes.limit();
                         }
-                        for (byte[] bytes : avcC.getPictureParameterSets()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getPictureParameterSets()) {
+                            spsPpsSize += len + bytes.limit();
                         }
                         return orignalSample.getSize() + spsPpsSize;
                     }
@@ -110,28 +110,28 @@ public long getSize() {
                     public ByteBuffer asByteBuffer() {
 
                         int spsPpsSize = 0;
-                        for (byte[] bytes : avcC.getSequenceParameterSets()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSets()) {
+                            spsPpsSize += len + bytes.limit();
                         }
-                        for (byte[] bytes : avcC.getSequenceParameterSetExts()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSetExts()) {
+                            spsPpsSize += len + bytes.limit();
                         }
-                        for (byte[] bytes : avcC.getPictureParameterSets()) {
-                            spsPpsSize += len + bytes.length;
+                        for (ByteBuffer bytes : avcC.getPictureParameterSets()) {
+                            spsPpsSize += len + bytes.limit();
                         }
 
 
                         ByteBuffer data = ByteBuffer.allocate(l2i(orignalSample.getSize()) + spsPpsSize);
-                        for (byte[] bytes : avcC.getSequenceParameterSets()) {
-                            IsoTypeWriterVariable.write(bytes.length, data, len);
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSets()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), data, len);
                             data.put(bytes);
                         }
-                        for (byte[] bytes : avcC.getSequenceParameterSetExts()) {
-                            IsoTypeWriterVariable.write(bytes.length, data, len);
+                        for (ByteBuffer bytes : avcC.getSequenceParameterSetExts()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), data, len);
                             data.put(bytes);
                         }
-                        for (byte[] bytes : avcC.getPictureParameterSets()) {
-                            IsoTypeWriterVariable.write(bytes.length, data, len);
+                        for (ByteBuffer bytes : avcC.getPictureParameterSets()) {
+                            IsoTypeWriterVariable.write(bytes.limit(), data, len);
                             data.put(bytes);
                         }
                         data.put(orignalSample.asByteBuffer());
diff --git a/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java b/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
index 8016ab4257..fb244049af 100755
--- a/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
@@ -27,9 +27,9 @@
 public class H264TrackImpl extends AbstractH26XTrack {
     private static final Logger LOG = Logger.getLogger(H264TrackImpl.class.getName());
 
-    Map<Integer, byte[]> spsIdToSpsBytes = new HashMap<Integer, byte[]>();
+    Map<Integer, ByteBuffer> spsIdToSpsBytes = new HashMap<Integer, ByteBuffer>();
     Map<Integer, SeqParameterSet> spsIdToSps = new HashMap<Integer, SeqParameterSet>();
-    Map<Integer, byte[]> ppsIdToPpsBytes = new HashMap<Integer, byte[]>();
+    Map<Integer, ByteBuffer> ppsIdToPpsBytes = new HashMap<Integer, ByteBuffer>();
     Map<Integer, PictureParameterSet> ppsIdToPps = new HashMap<Integer, PictureParameterSet>();
 
     SampleDescriptionBox sampleDescriptionBox;
@@ -37,8 +37,8 @@
     PictureParameterSet firstPictureParameterSet = null;
     SeqParameterSet currentSeqParameterSet = null;
     PictureParameterSet currentPictureParameterSet = null;
-    RangeStartMap<Integer, byte[]> seqParameterRangeMap = new RangeStartMap<Integer, byte[]>();
-    RangeStartMap<Integer, byte[]> pictureParameterRangeMap = new RangeStartMap<Integer, byte[]>();
+    RangeStartMap<Integer, ByteBuffer> seqParameterRangeMap = new RangeStartMap<Integer, ByteBuffer>();
+    RangeStartMap<Integer, ByteBuffer> pictureParameterRangeMap = new RangeStartMap<Integer, ByteBuffer>();
     int frameNrInGop = 0;
     int[] pictureOrderCounts = new int[0];
     int prevPicOrderCntLsb = 0;
@@ -139,8 +139,8 @@ private void parse(LookAhead la) throws IOException {
 
         AvcConfigurationBox avcConfigurationBox = new AvcConfigurationBox();
 
-        avcConfigurationBox.setSequenceParameterSets(new ArrayList<byte[]>(spsIdToSpsBytes.values()));
-        avcConfigurationBox.setPictureParameterSets(new ArrayList<byte[]>(ppsIdToPpsBytes.values()));
+        avcConfigurationBox.setSequenceParameterSets(new ArrayList<ByteBuffer>(spsIdToSpsBytes.values()));
+        avcConfigurationBox.setPictureParameterSets(new ArrayList<ByteBuffer>(ppsIdToPpsBytes.values()));
         avcConfigurationBox.setAvcLevelIndication(firstSeqParameterSet.level_idc);
         avcConfigurationBox.setAvcProfileIndication(firstSeqParameterSet.profile_idc);
         avcConfigurationBox.setBitDepthLumaMinus8(firstSeqParameterSet.bit_depth_luma_minus8);
@@ -477,12 +477,12 @@ private void createSample(List<ByteBuffer> buffered) throws IOException {
         if (seiMessage == null || seiMessage.n_frames == 0) {
             frameNrInGop = 0;
         }
-        int offset = 0;
+
         if (sh.sps.pic_order_cnt_type == 0) {
             int max_pic_order_count_lsb = (1 << (sh.sps.log2_max_pic_order_cnt_lsb_minus4 + 4));
             // System.out.print(" pic_order_cnt_lsb " + pic_order_cnt_lsb + " " + max_pic_order_count);
             int picOrderCountLsb = sh.pic_order_cnt_lsb;
-            int picOrderCntMsb = 0;
+            int picOrderCntMsb;
             if ((picOrderCountLsb < prevPicOrderCntLsb) &&
                     ((prevPicOrderCntLsb - picOrderCountLsb) >= (max_pic_order_count_lsb / 2))) {
                 picOrderCntMsb = prevPicOrderCntMsb + max_pic_order_count_lsb;
@@ -522,73 +522,7 @@ private void createSample(List<ByteBuffer> buffered) throws IOException {
         }
     }
 
-    private int calcPoc(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
-        if (sh.sps.pic_order_cnt_type == 0) {
-            return calcPOC0(nu, sh);
-        } else if (sh.sps.pic_order_cnt_type == 1) {
-            return calcPOC1(absFrameNum, nu, sh);
-        } else {
-            return calcPOC2(absFrameNum, nu, sh);
-        }
-    }
-
-    private int calcPOC2(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
-
-        if (nu.nal_ref_idc == 0)
-            return 2 * absFrameNum - 1;
-        else
-            return 2 * absFrameNum;
-    }
-
-    private int calcPOC1(int absFrameNum, H264NalUnitHeader nu, SliceHeader sh) {
-
-        if (sh.sps.num_ref_frames_in_pic_order_cnt_cycle == 0)
-            absFrameNum = 0;
-        if (nu.nal_ref_idc == 0 && absFrameNum > 0)
-            absFrameNum = absFrameNum - 1;
-
-        int expectedDeltaPerPicOrderCntCycle = 0;
-        for (int i = 0; i < sh.sps.num_ref_frames_in_pic_order_cnt_cycle; i++)
-            expectedDeltaPerPicOrderCntCycle += sh.sps.offsetForRefFrame[i];
-
-        int expectedPicOrderCnt;
-        if (absFrameNum > 0) {
-            int picOrderCntCycleCnt = (absFrameNum - 1) / sh.sps.num_ref_frames_in_pic_order_cnt_cycle;
-            int frameNumInPicOrderCntCycle = (absFrameNum - 1) % sh.sps.num_ref_frames_in_pic_order_cnt_cycle;
 
-            expectedPicOrderCnt = picOrderCntCycleCnt * expectedDeltaPerPicOrderCntCycle;
-            for (int i = 0; i <= frameNumInPicOrderCntCycle; i++)
-                expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offsetForRefFrame[i];
-        } else {
-            expectedPicOrderCnt = 0;
-        }
-        if (nu.nal_ref_idc == 0)
-            expectedPicOrderCnt = expectedPicOrderCnt + sh.sps.offset_for_non_ref_pic;
-
-        return expectedPicOrderCnt + sh.delta_pic_order_cnt_0;
-    }
-
-    private int calcPOC0(H264NalUnitHeader nu, SliceHeader sh) {
-
-        int pocCntLsb = sh.pic_order_cnt_lsb;
-        int maxPicOrderCntLsb = 1 << (sh.sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
-
-        // TODO prevPicOrderCntMsb should be wrapped!!
-        int picOrderCntMsb;
-        if ((pocCntLsb < prevPicOrderCntLsb) && ((prevPicOrderCntLsb - pocCntLsb) >= (maxPicOrderCntLsb / 2)))
-            picOrderCntMsb = prevPicOrderCntMsb + maxPicOrderCntLsb;
-        else if ((pocCntLsb > prevPicOrderCntLsb) && ((pocCntLsb - prevPicOrderCntLsb) > (maxPicOrderCntLsb / 2)))
-            picOrderCntMsb = prevPicOrderCntMsb - maxPicOrderCntLsb;
-        else
-            picOrderCntMsb = prevPicOrderCntMsb;
-
-        if (nu.nal_ref_idc != 0) {
-            prevPicOrderCntMsb = picOrderCntMsb;
-            prevPicOrderCntLsb = pocCntLsb;
-        }
-
-        return picOrderCntMsb + pocCntLsb;
-    }
 
     private void handlePPS(ByteBuffer data) throws IOException {
         InputStream is = new ByteBufferBackedInputStream(data);
@@ -601,17 +535,17 @@ private void handlePPS(ByteBuffer data) throws IOException {
 
         currentPictureParameterSet = _pictureParameterSet;
 
-        byte[] ppsBytes = toArray((ByteBuffer) data.rewind());
-        byte[] oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
 
+        ByteBuffer oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
 
-        if (oldPpsSameId != null && !Arrays.equals(oldPpsSameId, ppsBytes)) {
+        data.rewind();
+        if (oldPpsSameId != null && !oldPpsSameId.equals(data)) {
             throw new RuntimeException("OMG - I got two SPS with same ID but different settings! (AVC3 is the solution)");
         } else {
             if (oldPpsSameId == null) {
-                pictureParameterRangeMap.put(samples.size(), ppsBytes);
+                pictureParameterRangeMap.put(samples.size(), data);
             }
-            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, ppsBytes);
+            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, data);
             ppsIdToPps.put(_pictureParameterSet.pic_parameter_set_id, _pictureParameterSet);
         }
 
@@ -628,15 +562,15 @@ private void handleSPS(ByteBuffer data) throws IOException {
         }
         currentSeqParameterSet = _seqParameterSet;
 
-        byte[] spsBytes = toArray((ByteBuffer) data.rewind());
-        byte[] oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
-        if (oldSpsSameId != null && !Arrays.equals(oldSpsSameId, spsBytes)) {
+        data.rewind();
+        ByteBuffer oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
+        if (oldSpsSameId != null && !oldSpsSameId.equals(data)) {
             throw new RuntimeException("OMG - I got two SPS with same ID but different settings!");
         } else {
             if (oldSpsSameId != null) {
-                seqParameterRangeMap.put(samples.size(), spsBytes);
+                seqParameterRangeMap.put(samples.size(), data);
             }
-            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, spsBytes);
+            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
             spsIdToSps.put(_seqParameterSet.seq_parameter_set_id, _seqParameterSet);
 
         }
diff --git a/streaming/pom.xml b/streaming/pom.xml
index 92a46a5660..555a7a1ac5 100755
--- a/streaming/pom.xml
+++ b/streaming/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.mp4parser</groupId>
     <artifactId>streaming</artifactId>
@@ -10,10 +11,17 @@
             <artifactId>isoparser</artifactId>
             <version>1.9.24-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>4.12</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>muxer</artifactId>
             <version>1.9.24-SNAPSHOT</version>
+            <scope>test</scope>
         </dependency>
     </dependencies>
     <name>Stream Muxer</name>
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/StreamingSampleImpl.java b/streaming/src/main/java/org/mp4parser/streaming/input/StreamingSampleImpl.java
index b1805456b8..b6b5f48073 100755
--- a/streaming/src/main/java/org/mp4parser/streaming/input/StreamingSampleImpl.java
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/StreamingSampleImpl.java
@@ -23,25 +23,22 @@ public StreamingSampleImpl(byte[] sample, long duration) {
         s = ByteBuffer.wrap(sample);
     }
 
-    public StreamingSampleImpl(List<byte[]> nals, long duration) {
+    public StreamingSampleImpl(List<ByteBuffer> nals, long duration) {
         this.duration = duration;
         int size = 0;
-        for (byte[] nal : nals) {
+        for (ByteBuffer nal : nals) {
             size += 4;
-            size += nal.length;
+            size += nal.limit();
         }
-        byte sample[] = new byte[size];
-        int pos = 0;
-        for (byte[] nal : nals) {
-            sample[pos] = (byte) ((nal.length & 0xff000000) >> 24);
-            sample[pos + 1] = (byte) ((nal.length & 0xff0000) >> 16);
-            sample[pos + 2] = (byte) ((nal.length & 0xff00) >> 8);
-            sample[pos + 3] = (byte) ((nal.length & 0xff));
-            pos += 4;
-            System.arraycopy(nal, 0, sample, pos, nal.length);
-            pos += nal.length;
+        s = ByteBuffer.allocate(size);
+
+        for (ByteBuffer nal : nals) {
+            s.put((byte) ((nal.limit() & 0xff000000) >> 24));
+            s.put((byte) ((nal.limit() & 0xff0000) >> 16));
+            s.put((byte) ((nal.limit() & 0xff00) >> 8));
+            s.put((byte) ((nal.limit() & 0xff)));
+            s.put((ByteBuffer) nal.rewind());
         }
-        s = ByteBuffer.wrap(sample);
 
 
     }
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/AbstractH264Track.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/AbstractH264Track.java
new file mode 100755
index 0000000000..f148d848e4
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/AbstractH264Track.java
@@ -0,0 +1,9 @@
+package org.mp4parser.streaming.input.h264;
+
+import org.mp4parser.streaming.input.AbstractStreamingTrack;
+
+/**
+ * Created by sannies on 23.10.2015.
+ */
+public abstract class AbstractH264Track extends AbstractStreamingTrack {
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264AnnexBTrack.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264AnnexBTrack.java
index 183f994fe5..fee645dc1f 100755
--- a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264AnnexBTrack.java
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264AnnexBTrack.java
@@ -6,9 +6,9 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.ByteBuffer;
 import java.util.Arrays;
 import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
@@ -16,8 +16,7 @@
  * Reads H264 data from an Annex B InputStream.
  */
 public class H264AnnexBTrack extends H264NalConsumingTrack implements Callable<Void> {
-    CountDownLatch countDownLatch = new CountDownLatch(1);
-    private boolean closed = false;
+
     private InputStream inputStream;
 
     public H264AnnexBTrack(InputStream inputStream) throws IOException {
@@ -25,31 +24,17 @@ public H264AnnexBTrack(InputStream inputStream) throws IOException {
         this.inputStream = new BufferedInputStream(inputStream);
     }
 
-    public boolean isClosed() {
-        return closed;
-    }
-
-    public void close() throws IOException {
-        closed = true;
-        try {
-            countDownLatch.await();
-        } catch (InterruptedException e) {
-            throw new IOException(e);
-        }
-    }
 
     public Void call() throws IOException, InterruptedException {
         byte[] nal;
         NalStreamTokenizer st = new NalStreamTokenizer(inputStream);
 
-        while ((nal = st.getNext()) != null && !closed) {
+        while ((nal = st.getNext()) != null) {
             //System.err.println("NAL before consume");
-            consumeNal(nal);
+            consumeNal(ByteBuffer.wrap(nal));
             //System.err.println("NAL after consume");
         }
-        drainDecPictureBuffer(true);
-        closed = true;
-        countDownLatch.countDown();
+        pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), true, true);
         return null;
     }
 
@@ -83,25 +68,31 @@ public NalStreamTokenizer(InputStream inputStream) {
 
 
             while ((c = inputStream.read()) != -1) {
-                next.write(c);
-                if (pattern == 0 && c == 0) {
-                    pattern = 1;
-                } else if (pattern == 1 && c == 0) {
-                    pattern = 2;
-                } else if (pattern == 2 && c == 0) {
-                    byte[] s = next.toByteArrayLess3();
-                    next.reset();
-                    if (s != null) {
-                        return s;
-                    }
-                } else if (pattern == 2 && c == 1) {
-                    byte[] s = next.toByteArrayLess3();
-                    next.reset();
-                    pattern = 0;
-                    if (s != null) {
-                        return s;
+                if (!(pattern == 2 && c == 3)) {
+                    next.write(c);
+
+
+                    if (pattern == 0 && c == 0) {
+                        pattern = 1;
+                    } else if (pattern == 1 && c == 0) {
+                        pattern = 2;
+                    } else if (pattern == 2 && c == 0) {
+                        byte[] s = next.toByteArrayLess3();
+                        next.reset();
+                        if (s != null) {
+                            return s;
+                        }
+                    } else if (pattern == 2 && c == 1) {
+                        byte[] s = next.toByteArrayLess3();
+                        next.reset();
+                        pattern = 0;
+                        if (s != null) {
+                            return s;
+                        }
+                    } else if (pattern != 0) {
+                        pattern = 0;
                     }
-                } else if (pattern != 0) {
+                } else {
                     pattern = 0;
                 }
             }
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalConsumingTrack.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalConsumingTrack.java
index 9e3f7e1a57..9dddba3be4 100755
--- a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalConsumingTrack.java
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalConsumingTrack.java
@@ -3,25 +3,19 @@
 import org.mp4parser.boxes.iso14496.part12.SampleDescriptionBox;
 import org.mp4parser.boxes.iso14496.part15.AvcConfigurationBox;
 import org.mp4parser.boxes.sampleentry.VisualSampleEntry;
-import org.mp4parser.muxer.tracks.CleanInputStream;
-import org.mp4parser.muxer.tracks.h264.H264NalUnitHeader;
-import org.mp4parser.muxer.tracks.h264.H264NalUnitTypes;
-import org.mp4parser.muxer.tracks.h264.SliceHeader;
-import org.mp4parser.muxer.tracks.h264.parsing.model.PictureParameterSet;
-import org.mp4parser.muxer.tracks.h264.parsing.model.SeqParameterSet;
 import org.mp4parser.streaming.StreamingSample;
 import org.mp4parser.streaming.extensions.CompositionTimeSampleExtension;
 import org.mp4parser.streaming.extensions.CompositionTimeTrackExtension;
 import org.mp4parser.streaming.extensions.DimensionTrackExtension;
 import org.mp4parser.streaming.extensions.SampleFlagsSampleExtension;
-import org.mp4parser.streaming.input.AbstractStreamingTrack;
 import org.mp4parser.streaming.input.StreamingSampleImpl;
+import org.mp4parser.streaming.input.h264.spspps.PictureParameterSet;
+import org.mp4parser.streaming.input.h264.spspps.SeqParameterSet;
+import org.mp4parser.streaming.input.h264.spspps.SliceHeader;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
-import java.io.InputStream;
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
@@ -30,14 +24,14 @@
 import java.util.logging.Logger;
 
 
-public abstract class H264NalConsumingTrack extends AbstractStreamingTrack {
+public abstract class H264NalConsumingTrack extends AbstractH264Track {
     private static final Logger LOG = Logger.getLogger(H264NalConsumingTrack.class.getName());
     int max_dec_frame_buffering = 16;
     List<StreamingSample> decFrameBuffer = new ArrayList<StreamingSample>();
     List<StreamingSample> decFrameBuffer2 = new ArrayList<StreamingSample>();
-    LinkedHashMap<Integer, byte[]> spsIdToSpsBytes = new LinkedHashMap<Integer, byte[]>();
+    LinkedHashMap<Integer, ByteBuffer> spsIdToSpsBytes = new LinkedHashMap<Integer, ByteBuffer>();
     LinkedHashMap<Integer, SeqParameterSet> spsIdToSps = new LinkedHashMap<Integer, SeqParameterSet>();
-    LinkedHashMap<Integer, byte[]> ppsIdToPpsBytes = new LinkedHashMap<Integer, byte[]>();
+    LinkedHashMap<Integer, ByteBuffer> ppsIdToPpsBytes = new LinkedHashMap<Integer, ByteBuffer>();
     LinkedHashMap<Integer, PictureParameterSet> ppsIdToPps = new LinkedHashMap<Integer, PictureParameterSet>();
     BlockingQueue<SeqParameterSet> spsForConfig = new LinkedBlockingDeque<SeqParameterSet>();
 
@@ -48,23 +42,23 @@
     SampleDescriptionBox stsd;
     SeqParameterSet currentSeqParameterSet = null;
     PictureParameterSet currentPictureParameterSet = null;
-    List<byte[]> buffered = new ArrayList<byte[]>();
+    List<ByteBuffer> buffered = new ArrayList<ByteBuffer>();
     FirstVclNalDetector fvnd = null;
+    H264NalUnitHeader sliceNalUnitHeader;
 
     public H264NalConsumingTrack() {
     }
 
-    public static H264NalUnitHeader getNalUnitHeader(byte[] nal) {
+    public static H264NalUnitHeader getNalUnitHeader(ByteBuffer nal) {
         H264NalUnitHeader nalUnitHeader = new H264NalUnitHeader();
-        int type = nal[0];
+        int type = nal.get(0);
         nalUnitHeader.nal_ref_idc = (type >> 5) & 3;
         nalUnitHeader.nal_unit_type = type & 0x1f;
 
         return nalUnitHeader;
     }
 
-
-    protected void consumeNal(byte[] nal) throws IOException {
+    protected void consumeNal(ByteBuffer nal) throws IOException {
         //LOG.finest("Consume NAL of " + nal.length + " bytes." + Hex.encodeHex(new byte[]{nal[0], nal[1], nal[2], nal[3], nal[4]}));
         H264NalUnitHeader nalUnitHeader = getNalUnitHeader(nal);
         switch (nalUnitHeader.nal_unit_type) {
@@ -75,9 +69,11 @@ protected void consumeNal(byte[] nal) throws IOException {
             case H264NalUnitTypes.CODED_SLICE_IDR:
                 FirstVclNalDetector current = new FirstVclNalDetector(nal,
                         nalUnitHeader.nal_ref_idc, nalUnitHeader.nal_unit_type);
+                sliceNalUnitHeader = nalUnitHeader;
                 if (fvnd != null && fvnd.isFirstInNew(current)) {
                     LOG.finer("Wrapping up cause of first vcl nal is found");
-                    createSample(buffered, fvnd.sliceHeader);
+                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
+                    buffered.clear();
                 }
                 fvnd = current;
                 //System.err.println("" + nalUnitHeader.nal_unit_type);
@@ -88,7 +84,8 @@ protected void consumeNal(byte[] nal) throws IOException {
             case H264NalUnitTypes.SEI:
                 if (fvnd != null) {
                     LOG.finer("Wrapping up cause of SEI after vcl marks new sample");
-                    createSample(buffered, fvnd.sliceHeader);
+                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
+                    buffered.clear();
                     fvnd = null;
                 }
                 //System.err.println("" + nalUnitHeader.nal_unit_type);
@@ -98,7 +95,8 @@ protected void consumeNal(byte[] nal) throws IOException {
             case H264NalUnitTypes.AU_UNIT_DELIMITER:
                 if (fvnd != null) {
                     LOG.finer("Wrapping up cause of AU after vcl marks new sample");
-                    createSample(buffered, fvnd.sliceHeader);
+                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
+                    buffered.clear();
                     fvnd = null;
                 }
                 //System.err.println("" + nalUnitHeader.nal_unit_type);
@@ -107,7 +105,8 @@ protected void consumeNal(byte[] nal) throws IOException {
             case H264NalUnitTypes.SEQ_PARAMETER_SET:
                 if (fvnd != null) {
                     LOG.finer("Wrapping up cause of SPS after vcl marks new sample");
-                    createSample(buffered, fvnd.sliceHeader);
+                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
+                    buffered.clear();
                     fvnd = null;
                 }
                 handleSPS(nal);
@@ -115,7 +114,8 @@ protected void consumeNal(byte[] nal) throws IOException {
             case 8:
                 if (fvnd != null) {
                     LOG.finer("Wrapping up cause of PPS after vcl marks new sample");
-                    createSample(buffered, fvnd.sliceHeader);
+                    pushSample(createSample(buffered, fvnd.sliceHeader, sliceNalUnitHeader), false, false);
+                    buffered.clear();
                     fvnd = null;
                 }
                 handlePPS(nal);
@@ -137,73 +137,49 @@ protected void consumeNal(byte[] nal) throws IOException {
 
     }
 
-    protected void drainDecPictureBuffer(boolean all) throws IOException {
+    protected void pushSample(StreamingSample ss, boolean all, boolean force) throws IOException {
+        if (ss != null) {
+            decFrameBuffer.add(ss);
+        }
         if (all) {
             while (decFrameBuffer.size() > 0) {
-                drainDecPictureBuffer(false);
+                pushSample(null, false, true);
             }
         } else {
-            StreamingSample first = decFrameBuffer.remove(0);
-            PictureOrderCountType0SampleExtension poct0se = first.getSampleExtension(PictureOrderCountType0SampleExtension.class);
-            int delay = 0;
-            for (StreamingSample streamingSample : decFrameBuffer) {
-                if (poct0se.getPoc() > streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
-                    delay++;
-                }
-            }
-            for (StreamingSample streamingSample : decFrameBuffer2) {
-                if (poct0se.getPoc() < streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
-                    delay--;
+            if ((decFrameBuffer.size() - 1 > max_dec_frame_buffering) || force) {
+                StreamingSample first = decFrameBuffer.remove(0);
+                PictureOrderCountType0SampleExtension poct0se = first.getSampleExtension(PictureOrderCountType0SampleExtension.class);
+                if (poct0se == null) {
+                    sampleSink.acceptSample(first, this);
+                } else {
+                    int delay = 0;
+                    for (StreamingSample streamingSample : decFrameBuffer) {
+                        if (poct0se.getPoc() > streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
+                            delay++;
+                        }
+                    }
+                    for (StreamingSample streamingSample : decFrameBuffer2) {
+                        if (poct0se.getPoc() < streamingSample.getSampleExtension(PictureOrderCountType0SampleExtension.class).getPoc()) {
+                            delay--;
+                        }
+                    }
+                    decFrameBuffer2.add(first);
+                    if (decFrameBuffer2.size() > max_dec_frame_buffering) {
+                        decFrameBuffer2.remove(0).removeSampleExtension(PictureOrderCountType0SampleExtension.class);
+                    }
+
+                    first.addSampleExtension(CompositionTimeSampleExtension.create(delay * frametick));
+                    //System.err.println("Adding sample");
+                    sampleSink.acceptSample(first, this);
                 }
             }
-            decFrameBuffer2.add(first);
-            if (decFrameBuffer2.size() > max_dec_frame_buffering) {
-                decFrameBuffer2.remove(0).removeSampleExtension(PictureOrderCountType0SampleExtension.class);
-            }
-
-            first.addSampleExtension(CompositionTimeSampleExtension.create(delay * frametick));
-            //System.err.println("Adding sample");
-            sampleSink.acceptSample(first, this);
         }
 
     }
 
 
-    protected StreamingSample createSample(List<byte[]> buffered, SliceHeader sliceHeader) throws IOException {
-        LOG.finer("Create Sample");
-        configure();
-        if (timescale == 0 || frametick == 0) {
-            throw new IOException("Frame Rate needs to be configured either by hand or by SPS before samples can be created");
-        }
+    protected SampleFlagsSampleExtension createSampleFlagsSampleExtension(H264NalUnitHeader nu, SliceHeader sliceHeader) {
         SampleFlagsSampleExtension sampleFlagsSampleExtension = new SampleFlagsSampleExtension();
-
-
-        boolean idrPicFlag = false;
-        H264NalUnitHeader nu = null;
-        byte[] slice = null;
-        buffered_loop:
-        for (byte[] nal : buffered) {
-            H264NalUnitHeader _nu = getNalUnitHeader(nal);
-
-            switch (_nu.nal_unit_type) {
-                case H264NalUnitTypes.CODED_SLICE_IDR:
-                    idrPicFlag = true;
-                case H264NalUnitTypes.CODED_SLICE_NON_IDR:
-                case H264NalUnitTypes.CODED_SLICE_DATA_PART_A:
-                case H264NalUnitTypes.CODED_SLICE_DATA_PART_B:
-                case H264NalUnitTypes.CODED_SLICE_DATA_PART_C:
-                    nu = _nu;
-                    slice = nal;
-                    break buffered_loop;
-            }
-        }
-        if (nu == null) {
-            LOG.warning("Sample without Slice");
-            return null;
-        }
-
-        assert slice != null;
-
         if (nu.nal_ref_idc == 0) {
             sampleFlagsSampleExtension.setSampleIsDependedOn(2);
         } else {
@@ -214,37 +190,44 @@ protected StreamingSample createSample(List<byte[]> buffered, SliceHeader sliceH
         } else {
             sampleFlagsSampleExtension.setSampleDependsOn(1);
         }
-        sampleFlagsSampleExtension.setSampleIsNonSyncSample(!idrPicFlag);
-
-        StreamingSampleImpl ssi = new StreamingSampleImpl(buffered, frametick);
-        ssi.addSampleExtension(sampleFlagsSampleExtension);
-
+        sampleFlagsSampleExtension.setSampleIsNonSyncSample(H264NalUnitTypes.CODED_SLICE_IDR != nu.nal_unit_type);
+        return sampleFlagsSampleExtension;
+    }
 
+    protected PictureOrderCountType0SampleExtension createPictureOrderCountType0SampleExtension(SliceHeader sliceHeader) {
         if (sliceHeader.sps.pic_order_cnt_type == 0) {
-            ssi.addSampleExtension(new PictureOrderCountType0SampleExtension(
+            return new PictureOrderCountType0SampleExtension(
                     sliceHeader, decFrameBuffer.size() > 0 ?
                     decFrameBuffer.get(decFrameBuffer.size() - 1).getSampleExtension(PictureOrderCountType0SampleExtension.class) :
-                    null));
-            decFrameBuffer.add(ssi);
+                    null);
+/*            decFrameBuffer.add(ssi);
             if (decFrameBuffer.size() - 1 > max_dec_frame_buffering) { // just added one
                 drainDecPictureBuffer(false);
-            }
+            }*/
         } else if (sliceHeader.sps.pic_order_cnt_type == 1) {
-                /*if (seiMessage != null && seiMessage.clock_timestamp_flag) {
-                    offset = seiMessage.n_frames - frameNrInGop;
-                } else if (seiMessage != null && seiMessage.removal_delay_flag) {
-                    offset = seiMessage.dpb_removal_delay / 2;
-                }
-
-                if (seiMessage == null) {
-                    LOG.warning("CTS timing in ctts box is most likely not OK");
-                }*/
-            throw new IOException("pic_order_cnt_type == 1 needs to be implemented");
+            throw new RuntimeException("pic_order_cnt_type == 1 needs to be implemented");
         } else if (sliceHeader.sps.pic_order_cnt_type == 2) {
-            sampleSink.acceptSample(ssi, this);
+            return null; // no ctts
+        }
+        throw new RuntimeException("I don't know sliceHeader.sps.pic_order_cnt_type of " + sliceHeader.sps.pic_order_cnt_type);
+    }
+
+
+    protected StreamingSample createSample(List<ByteBuffer> nals, SliceHeader sliceHeader, H264NalUnitHeader nu) throws IOException {
+        LOG.finer("Create Sample");
+        configure();
+        if (timescale == 0 || frametick == 0) {
+            throw new IOException("Frame Rate needs to be configured either by hand or by SPS before samples can be created");
         }
-        buffered.clear();
-        return ssi;
+
+
+        StreamingSample ss = new StreamingSampleImpl(
+                nals,
+                frametick);
+        ss.addSampleExtension(createSampleFlagsSampleExtension(nu, sliceHeader));
+        ss.addSampleExtension(createPictureOrderCountType0SampleExtension(sliceHeader));
+
+        return ss;
     }
 
 
@@ -254,9 +237,7 @@ public void setFrametick(int frametick) {
 
     public synchronized void configure() {
 
-        if (configured) {
-            return;
-        } else {
+        if (!configured) {
             SeqParameterSet sps;
             try {
                 sps = spsForConfig.poll(5L, TimeUnit.SECONDS);
@@ -314,8 +295,8 @@ public synchronized void configure() {
 
             AvcConfigurationBox avcConfigurationBox = new AvcConfigurationBox();
 
-            avcConfigurationBox.setSequenceParameterSets(new ArrayList<byte[]>(spsIdToSpsBytes.values()));
-            avcConfigurationBox.setPictureParameterSets(new ArrayList<byte[]>(ppsIdToPpsBytes.values()));
+            avcConfigurationBox.setSequenceParameterSets(new ArrayList<ByteBuffer>(spsIdToSpsBytes.values()));
+            avcConfigurationBox.setPictureParameterSets(new ArrayList<ByteBuffer>(ppsIdToPpsBytes.values()));
             avcConfigurationBox.setAvcLevelIndication(sps.level_idc);
             avcConfigurationBox.setAvcProfileIndication(sps.profile_idc);
             avcConfigurationBox.setBitDepthLumaMinus8(sps.bit_depth_luma_minus8);
@@ -369,6 +350,11 @@ public synchronized void configure() {
             if (frametick == 0) {
                 frametick = _frametick;
             }
+            if (sps.pic_order_cnt_type == 0) {
+                this.addTrackExtension(new CompositionTimeTrackExtension());
+            } else if (sps.pic_order_cnt_type == 1) {
+                throw new RuntimeException("Have not yet imlemented pic_order_cnt_type 1");
+            }
             configured = true;
         }
     }
@@ -396,42 +382,55 @@ public String getLanguage() {
         return "eng";
     }
 
-    private void handlePPS(byte[] data) throws IOException {
-        InputStream is = new ByteArrayInputStream(data, 1, data.length - 1);
-        PictureParameterSet _pictureParameterSet = PictureParameterSet.read(is);
-        currentPictureParameterSet = _pictureParameterSet;
+    protected void handlePPS(ByteBuffer nal) {
+        nal.position(1);
+        PictureParameterSet _pictureParameterSet = null;
+        try {
+            _pictureParameterSet = PictureParameterSet.read(nal);
+            currentPictureParameterSet = _pictureParameterSet;
 
 
-        byte[] oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
+            ByteBuffer oldPpsSameId = ppsIdToPpsBytes.get(_pictureParameterSet.pic_parameter_set_id);
 
 
-        if (oldPpsSameId != null && !Arrays.equals(oldPpsSameId, data)) {
-            throw new IOException("OMG - I got two SPS with same ID but different settings! (AVC3 is the solution)");
-        } else {
-            ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, data);
-            ppsIdToPps.put(_pictureParameterSet.pic_parameter_set_id, _pictureParameterSet);
+            if (oldPpsSameId != null && !oldPpsSameId.equals(nal)) {
+                throw new RuntimeException("OMG - I got two SPS with same ID but different settings! (AVC3 is the solution)");
+            } else {
+                ppsIdToPpsBytes.put(_pictureParameterSet.pic_parameter_set_id, nal);
+                ppsIdToPps.put(_pictureParameterSet.pic_parameter_set_id, _pictureParameterSet);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException("That's surprising to get IOException when working on ByteArrayInputStream", e);
         }
 
 
     }
 
-    private void handleSPS(byte[] data) throws IOException {
-        InputStream spsInputStream = new CleanInputStream(new ByteArrayInputStream(data, 1, data.length - 1));
-        SeqParameterSet _seqParameterSet = SeqParameterSet.read(spsInputStream);
+    protected void handleSPS(ByteBuffer data) {
+        data.position(1);
+        try {
+            SeqParameterSet _seqParameterSet = SeqParameterSet.read(data);
 
-        currentSeqParameterSet = _seqParameterSet;
+            currentSeqParameterSet = _seqParameterSet;
 
-        byte[] oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
-        if (oldSpsSameId != null && !Arrays.equals(oldSpsSameId, data)) {
-            throw new IOException("OMG - I got two SPS with same ID but different settings!");
-        } else {
-            spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
-            spsIdToSps.put(_seqParameterSet.seq_parameter_set_id, _seqParameterSet);
-            spsForConfig.add(_seqParameterSet);
+            ByteBuffer oldSpsSameId = spsIdToSpsBytes.get(_seqParameterSet.seq_parameter_set_id);
+            if (oldSpsSameId != null && !oldSpsSameId.equals(data)) {
+                throw new RuntimeException("OMG - I got two SPS with same ID but different settings!");
+            } else {
+                spsIdToSpsBytes.put(_seqParameterSet.seq_parameter_set_id, data);
+                spsIdToSps.put(_seqParameterSet.seq_parameter_set_id, _seqParameterSet);
+                spsForConfig.add(_seqParameterSet);
+            }
+        } catch (IOException e) {
+            throw new RuntimeException("That's surprising to get IOException when working on ByteArrayInputStream", e);
         }
 
     }
 
+    public void close() throws IOException {
+
+    }
+
     class FirstVclNalDetector {
 
         public final SliceHeader sliceHeader;
@@ -448,9 +447,9 @@ private void handleSPS(byte[] data) throws IOException {
         boolean idrPicFlag;
         int idr_pic_id;
 
-        public FirstVclNalDetector(byte[] nal, int nal_ref_idc, int nal_unit_type) {
-            InputStream bs = new CleanInputStream(new ByteArrayInputStream(nal));
-            SliceHeader sh = new SliceHeader(bs, spsIdToSps, ppsIdToPps, nal_unit_type == 5);
+        public FirstVclNalDetector(ByteBuffer nal, int nal_ref_idc, int nal_unit_type) {
+
+            SliceHeader sh = new SliceHeader(nal, spsIdToSps, ppsIdToPps, nal_unit_type == 5);
             this.sliceHeader = sh;
             this.frame_num = sh.frame_num;
             this.pic_parameter_set_id = sh.pic_parameter_set_id;
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitHeader.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitHeader.java
new file mode 100755
index 0000000000..302c66f513
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitHeader.java
@@ -0,0 +1,7 @@
+package org.mp4parser.streaming.input.h264;
+
+
+public class H264NalUnitHeader {
+    public int nal_ref_idc;
+    public int nal_unit_type;
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitTypes.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitTypes.java
new file mode 100755
index 0000000000..b43fdc164e
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/H264NalUnitTypes.java
@@ -0,0 +1,39 @@
+package org.mp4parser.streaming.input.h264;
+
+/**
+ * Created by sannies on 18.05.2015.
+ */
+public interface H264NalUnitTypes {
+    int UNSPECIFIED = 0;
+    int CODED_SLICE_NON_IDR = 1;
+    int CODED_SLICE_DATA_PART_A = 2;
+    int CODED_SLICE_DATA_PART_B = 3;
+    int CODED_SLICE_DATA_PART_C = 4;
+    int CODED_SLICE_IDR = 5;
+    int SEI = 6;
+    int SEQ_PARAMETER_SET = 7;
+    int PIC_PARAMETER_SET = 8;
+    int AU_UNIT_DELIMITER = 9;
+    int END_OF_SEQUENCE = 10;
+    int END_OF_STREAM = 11;
+    int FILLER_DATA = 12;
+    int SEQ_PARAMETER_SET_EXT = 13;
+    int PREFIX_NAL_UNIT = 14;
+    int SUBSET_SEQ_PARAMETER_SET = 15;
+    int RESERVERED_16 = 16;
+    int RESERVERED_17 = 17;
+    int RESERVERED_18 = 18;
+    int CODED_SLICE_AUX_PIC = 19;
+    int CODED_SLICE_EXT = 20;
+    int RESERVED_21 = 21;
+    int RESERVED_22 = 22;
+    int RESERVED_23 = 23;
+    int UNSPEC_24 = 24;
+    int UNSPEC_25 = 25;
+    int UNSPEC_26 = 26;
+    int UNSPEC_27 = 27;
+    int UNSPEC_28 = 28;
+    int UNSPEC_29 = 29;
+    int UNSPEC_30 = 30;
+    int UNSPEC_31 = 31;
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/PictureOrderCountType0SampleExtension.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/PictureOrderCountType0SampleExtension.java
index dc9ae8cc9c..82ea127c7b 100755
--- a/streaming/src/main/java/org/mp4parser/streaming/input/h264/PictureOrderCountType0SampleExtension.java
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/PictureOrderCountType0SampleExtension.java
@@ -1,11 +1,8 @@
 package org.mp4parser.streaming.input.h264;
 
-import org.mp4parser.muxer.tracks.h264.SliceHeader;
 import org.mp4parser.streaming.SampleExtension;
+import org.mp4parser.streaming.input.h264.spspps.SliceHeader;
 
-/**
- * Created by sannies on 17.08.2015.
- */
 class PictureOrderCountType0SampleExtension implements SampleExtension {
     int picOrderCntMsb;
     int picOrderCountLsb;
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/AspectRatio.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/AspectRatio.java
new file mode 100755
index 0000000000..d23f5a9c92
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/AspectRatio.java
@@ -0,0 +1,58 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+/**
+ * Aspect ratio
+ * <p>
+ * dynamic enum</p>
+ *
+ * @author Stanislav Vitvitskiy
+ */
+public class AspectRatio {
+
+    public static final AspectRatio Extended_SAR = new AspectRatio(255);
+
+    private int value;
+
+    private AspectRatio(int value) {
+        this.value = value;
+    }
+
+    public static AspectRatio fromValue(int value) {
+        if (value == Extended_SAR.value) {
+            return Extended_SAR;
+        }
+        return new AspectRatio(value);
+    }
+
+    public int getValue() {
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder sb = new StringBuilder("AspectRatio{");
+        sb.append("value=").append(value);
+        sb.append('}');
+        return sb.toString();
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ByteBufferBitreader.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ByteBufferBitreader.java
new file mode 100755
index 0000000000..a132a59a4b
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ByteBufferBitreader.java
@@ -0,0 +1,101 @@
+package org.mp4parser.streaming.input.h264.spspps;
+
+import java.io.IOException;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+
+public class ByteBufferBitreader {
+    ByteBuffer buffer;
+
+    int nBit;
+
+    private int currentByte;
+    private int nextByte;
+
+
+    public ByteBufferBitreader(ByteBuffer buffer) {
+        this.buffer = buffer;
+        currentByte = get();
+        nextByte = get();
+    }
+
+    public int get() {
+        try {
+            int i = buffer.get();
+            i = i < 0 ? i + 256 : i;
+            return i;
+        } catch (BufferUnderflowException e) {
+            return -1;
+        }
+    }
+
+    public int read1Bit() throws IOException {
+        if (nBit == 8) {
+            advance();
+            if (currentByte == -1) {
+                return -1;
+            }
+        }
+        int res = (currentByte >> (7 - nBit)) & 1;
+        nBit++;
+        return res;
+    }
+
+    private void advance() throws IOException {
+        currentByte = nextByte;
+        nextByte = get();
+        nBit = 0;
+    }
+
+    public int readUE() throws IOException {
+        int cnt = 0;
+        while (read1Bit() == 0) {
+            cnt++;
+        }
+
+        int res = 0;
+        if (cnt > 0) {
+            res = (int) ((1 << cnt) - 1 + readNBit(cnt));
+        }
+
+        return res;
+    }
+
+    public long readNBit(int n) throws IOException {
+        if (n > 64)
+            throw new IllegalArgumentException("Can not readByte more then 64 bit");
+
+        long val = 0;
+
+        for (int i = 0; i < n; i++) {
+            val <<= 1;
+            val |= read1Bit();
+        }
+
+        return val;
+    }
+
+    public boolean readBool() throws IOException {
+        return read1Bit() != 0;
+    }
+
+    public int readSE() throws IOException {
+        int val = readUE();
+        int sign = ((val & 0x1) << 1) - 1;
+        val = ((val >> 1) + (val & 0x1)) * sign;
+        return val;
+    }
+
+    public boolean moreRBSPData() throws IOException {
+        if (nBit == 8) {
+            advance();
+        }
+        int tail = 1 << (8 - nBit - 1);
+        int mask = ((tail << 1) - 1);
+        boolean hasTail = (currentByte & mask) == tail;
+
+        return !(currentByte == -1 || (nextByte == -1 && hasTail));
+    }
+
+
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ChromaFormat.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ChromaFormat.java
new file mode 100755
index 0000000000..f9c5556516
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ChromaFormat.java
@@ -0,0 +1,77 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+/**
+ * Chroma format enum
+ *
+ * @author Stanislav Vitvitskiy
+ */
+public class ChromaFormat {
+    public static ChromaFormat MONOCHROME = new ChromaFormat(0, 0, 0);
+    public static ChromaFormat YUV_420 = new ChromaFormat(1, 2, 2);
+    public static ChromaFormat YUV_422 = new ChromaFormat(2, 2, 1);
+    public static ChromaFormat YUV_444 = new ChromaFormat(3, 1, 1);
+
+    private int id;
+    private int subWidth;
+    private int subHeight;
+
+    public ChromaFormat(int id, int subWidth, int subHeight) {
+        this.id = id;
+        this.subWidth = subWidth;
+        this.subHeight = subHeight;
+    }
+
+    public static ChromaFormat fromId(int id) {
+        if (id == MONOCHROME.id) {
+            return MONOCHROME;
+        } else if (id == YUV_420.id) {
+            return YUV_420;
+        } else if (id == YUV_422.id) {
+            return YUV_422;
+        } else if (id == YUV_444.id) {
+            return YUV_444;
+        }
+        return null;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public int getSubWidth() {
+        return subWidth;
+    }
+
+    public int getSubHeight() {
+        return subHeight;
+    }
+
+    @Override
+    public String toString() {
+        return "ChromaFormat{" + "\n" +
+                "id=" + id + ",\n" +
+                " subWidth=" + subWidth + ",\n" +
+                " subHeight=" + subHeight +
+                '}';
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/HRDParameters.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/HRDParameters.java
new file mode 100755
index 0000000000..e1a96b1ecd
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/HRDParameters.java
@@ -0,0 +1,53 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+import java.util.Arrays;
+
+public class HRDParameters {
+
+    public int cpb_cnt_minus1;
+    public int bit_rate_scale;
+    public int cpb_size_scale;
+    public int[] bit_rate_value_minus1;
+    public int[] cpb_size_value_minus1;
+    public boolean[] cbr_flag;
+    public int initial_cpb_removal_delay_length_minus1;
+    public int cpb_removal_delay_length_minus1;
+    public int dpb_output_delay_length_minus1;
+    public int time_offset_length;
+
+    @Override
+    public String toString() {
+        return "HRDParameters{" +
+                "cpb_cnt_minus1=" + cpb_cnt_minus1 +
+                ", bit_rate_scale=" + bit_rate_scale +
+                ", cpb_size_scale=" + cpb_size_scale +
+                ", bit_rate_value_minus1=" + Arrays.toString(bit_rate_value_minus1) +
+                ", cpb_size_value_minus1=" + Arrays.toString(cpb_size_value_minus1) +
+                ", cbr_flag=" + Arrays.toString(cbr_flag) +
+                ", initial_cpb_removal_delay_length_minus1=" + initial_cpb_removal_delay_length_minus1 +
+                ", cpb_removal_delay_length_minus1=" + cpb_removal_delay_length_minus1 +
+                ", dpb_output_delay_length_minus1=" + dpb_output_delay_length_minus1 +
+                ", time_offset_length=" + time_offset_length +
+                '}';
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/PictureParameterSet.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/PictureParameterSet.java
new file mode 100755
index 0000000000..9df69bc29e
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/PictureParameterSet.java
@@ -0,0 +1,302 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Picture Parameter Set entity of H264 bitstream
+ * <p>
+ * capable to serialize / deserialize with CAVLC bitstream</p>
+ *
+ * @author Stanislav Vitvitskiy
+ */
+public class PictureParameterSet {
+
+    public boolean entropy_coding_mode_flag;
+    public int num_ref_idx_l0_active_minus1;
+    public int num_ref_idx_l1_active_minus1;
+    public int slice_group_change_rate_minus1;
+    public int pic_parameter_set_id;
+    public int seq_parameter_set_id;
+    public boolean bottom_field_pic_order_in_frame_present_flag;
+    public int num_slice_groups_minus1;
+    public int slice_group_map_type;
+    public boolean weighted_pred_flag;
+    public int weighted_bipred_idc;
+    public int pic_init_qp_minus26;
+    public int pic_init_qs_minus26;
+    public int chroma_qp_index_offset;
+    public boolean deblocking_filter_control_present_flag;
+    public boolean constrained_intra_pred_flag;
+    public boolean redundant_pic_cnt_present_flag;
+    public int[] top_left;
+    public int[] bottom_right;
+    public int[] run_length_minus1;
+    public boolean slice_group_change_direction_flag;
+    public int[] slice_group_id;
+    public PPSExt extended;
+
+    public static PictureParameterSet read(ByteBuffer bb) throws IOException {
+        ByteBufferBitreader reader = new ByteBufferBitreader(bb);
+        PictureParameterSet pps = new PictureParameterSet();
+
+        pps.pic_parameter_set_id = reader.readUE();
+        pps.seq_parameter_set_id = reader.readUE();
+        pps.entropy_coding_mode_flag = reader
+                .readBool();
+        pps.bottom_field_pic_order_in_frame_present_flag = reader
+                .readBool();
+        pps.num_slice_groups_minus1 = reader
+                .readUE();
+        if (pps.num_slice_groups_minus1 > 0) {
+            pps.slice_group_map_type = reader
+                    .readUE();
+            pps.top_left = new int[pps.num_slice_groups_minus1 + 1];
+            pps.bottom_right = new int[pps.num_slice_groups_minus1 + 1];
+            pps.run_length_minus1 = new int[pps.num_slice_groups_minus1 + 1];
+            if (pps.slice_group_map_type == 0)
+                for (int iGroup = 0; iGroup <= pps.num_slice_groups_minus1; iGroup++)
+                    pps.run_length_minus1[iGroup] = reader
+                            .readUE();
+            else if (pps.slice_group_map_type == 2)
+                for (int iGroup = 0; iGroup < pps.num_slice_groups_minus1; iGroup++) {
+                    pps.top_left[iGroup] = reader.readUE();
+                    pps.bottom_right[iGroup] = reader
+                            .readUE();
+                }
+            else if (pps.slice_group_map_type == 3
+                    || pps.slice_group_map_type == 4
+                    || pps.slice_group_map_type == 5) {
+                pps.slice_group_change_direction_flag = reader
+                        .readBool();
+                pps.slice_group_change_rate_minus1 = reader
+                        .readUE();
+            } else if (pps.slice_group_map_type == 6) {
+                int NumberBitsPerSliceGroupId;
+                if (pps.num_slice_groups_minus1 + 1 > 4)
+                    NumberBitsPerSliceGroupId = 3;
+                else if (pps.num_slice_groups_minus1 + 1 > 2)
+                    NumberBitsPerSliceGroupId = 2;
+                else
+                    NumberBitsPerSliceGroupId = 1;
+                int pic_size_in_map_units_minus1 = reader
+                        .readUE();
+                pps.slice_group_id = new int[pic_size_in_map_units_minus1 + 1];
+                for (int i = 0; i <= pic_size_in_map_units_minus1; i++) {
+                    pps.slice_group_id[i] = (int) reader.readNBit(
+                            NumberBitsPerSliceGroupId);
+                }
+            }
+        }
+        pps.num_ref_idx_l0_active_minus1 = reader
+                .readUE();
+        pps.num_ref_idx_l1_active_minus1 = reader
+                .readUE();
+        pps.weighted_pred_flag = reader.readBool();
+        pps.weighted_bipred_idc = (int) reader.readNBit(2);
+        pps.pic_init_qp_minus26 = reader.readSE();
+        pps.pic_init_qs_minus26 = reader.readSE();
+        pps.chroma_qp_index_offset = reader
+                .readSE();
+        pps.deblocking_filter_control_present_flag = reader
+                .readBool();
+        pps.constrained_intra_pred_flag = reader
+                .readBool();
+        pps.redundant_pic_cnt_present_flag = reader
+                .readBool();
+        if (reader.moreRBSPData()) {
+            pps.extended = new PictureParameterSet.PPSExt();
+            pps.extended.transform_8x8_mode_flag = reader
+                    .readBool();
+            boolean pic_scaling_matrix_present_flag = reader
+                    .readBool();
+            if (pic_scaling_matrix_present_flag) {
+                for (int i = 0; i < 6 + 2 * (pps.extended.transform_8x8_mode_flag ? 1
+                        : 0); i++) {
+                    boolean pic_scaling_list_present_flag = reader
+                            .readBool();
+                    if (pic_scaling_list_present_flag) {
+                        pps.extended.scalindMatrix.ScalingList4x4 = new ScalingList[8];
+                        pps.extended.scalindMatrix.ScalingList8x8 = new ScalingList[8];
+                        if (i < 6) {
+                            pps.extended.scalindMatrix.ScalingList4x4[i] = ScalingList
+                                    .read(reader, 16);
+                        } else {
+                            pps.extended.scalindMatrix.ScalingList8x8[i - 6] = ScalingList
+                                    .read(reader, 64);
+                        }
+                    }
+                }
+            }
+            pps.extended.second_chroma_qp_index_offset = reader
+                    .readSE();
+        }
+
+        // reader.readTrailingBits();
+
+        return pps;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + Arrays.hashCode(bottom_right);
+        result = prime * result + chroma_qp_index_offset;
+        result = prime * result + (constrained_intra_pred_flag ? 1231 : 1237);
+        result = prime * result
+                + (deblocking_filter_control_present_flag ? 1231 : 1237);
+        result = prime * result + (entropy_coding_mode_flag ? 1231 : 1237);
+        result = prime * result
+                + ((extended == null) ? 0 : extended.hashCode());
+        result = prime * result + num_ref_idx_l0_active_minus1;
+        result = prime * result + num_ref_idx_l1_active_minus1;
+        result = prime * result + num_slice_groups_minus1;
+        result = prime * result + pic_init_qp_minus26;
+        result = prime * result + pic_init_qs_minus26;
+        result = prime * result + (bottom_field_pic_order_in_frame_present_flag ? 1231 : 1237);
+        result = prime * result + pic_parameter_set_id;
+        result = prime * result
+                + (redundant_pic_cnt_present_flag ? 1231 : 1237);
+        result = prime * result + Arrays.hashCode(run_length_minus1);
+        result = prime * result + seq_parameter_set_id;
+        result = prime * result
+                + (slice_group_change_direction_flag ? 1231 : 1237);
+        result = prime * result + slice_group_change_rate_minus1;
+        result = prime * result + Arrays.hashCode(slice_group_id);
+        result = prime * result + slice_group_map_type;
+        result = prime * result + Arrays.hashCode(top_left);
+        result = prime * result + weighted_bipred_idc;
+        result = prime * result + (weighted_pred_flag ? 1231 : 1237);
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        PictureParameterSet other = (PictureParameterSet) obj;
+        if (!Arrays.equals(bottom_right, other.bottom_right))
+            return false;
+        if (chroma_qp_index_offset != other.chroma_qp_index_offset)
+            return false;
+        if (constrained_intra_pred_flag != other.constrained_intra_pred_flag)
+            return false;
+        if (deblocking_filter_control_present_flag != other.deblocking_filter_control_present_flag)
+            return false;
+        if (entropy_coding_mode_flag != other.entropy_coding_mode_flag)
+            return false;
+        if (extended == null) {
+            if (other.extended != null)
+                return false;
+        } else if (!extended.equals(other.extended))
+            return false;
+        if (num_ref_idx_l0_active_minus1 != other.num_ref_idx_l0_active_minus1)
+            return false;
+        if (num_ref_idx_l1_active_minus1 != other.num_ref_idx_l1_active_minus1)
+            return false;
+        if (num_slice_groups_minus1 != other.num_slice_groups_minus1)
+            return false;
+        if (pic_init_qp_minus26 != other.pic_init_qp_minus26)
+            return false;
+        if (pic_init_qs_minus26 != other.pic_init_qs_minus26)
+            return false;
+        if (bottom_field_pic_order_in_frame_present_flag != other.bottom_field_pic_order_in_frame_present_flag)
+            return false;
+        if (pic_parameter_set_id != other.pic_parameter_set_id)
+            return false;
+        if (redundant_pic_cnt_present_flag != other.redundant_pic_cnt_present_flag)
+            return false;
+        if (!Arrays.equals(run_length_minus1, other.run_length_minus1))
+            return false;
+        if (seq_parameter_set_id != other.seq_parameter_set_id)
+            return false;
+        if (slice_group_change_direction_flag != other.slice_group_change_direction_flag)
+            return false;
+        if (slice_group_change_rate_minus1 != other.slice_group_change_rate_minus1)
+            return false;
+        if (!Arrays.equals(slice_group_id, other.slice_group_id))
+            return false;
+        if (slice_group_map_type != other.slice_group_map_type)
+            return false;
+        if (!Arrays.equals(top_left, other.top_left))
+            return false;
+        if (weighted_bipred_idc != other.weighted_bipred_idc)
+            return false;
+        if (weighted_pred_flag != other.weighted_pred_flag)
+            return false;
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "PictureParameterSet{" +
+                "\n       entropy_coding_mode_flag=" + entropy_coding_mode_flag +
+                ",\n       num_ref_idx_l0_active_minus1=" + num_ref_idx_l0_active_minus1 +
+                ",\n       num_ref_idx_l1_active_minus1=" + num_ref_idx_l1_active_minus1 +
+                ",\n       slice_group_change_rate_minus1=" + slice_group_change_rate_minus1 +
+                ",\n       pic_parameter_set_id=" + pic_parameter_set_id +
+                ",\n       seq_parameter_set_id=" + seq_parameter_set_id +
+                ",\n       pic_order_present_flag=" + bottom_field_pic_order_in_frame_present_flag +
+                ",\n       num_slice_groups_minus1=" + num_slice_groups_minus1 +
+                ",\n       slice_group_map_type=" + slice_group_map_type +
+                ",\n       weighted_pred_flag=" + weighted_pred_flag +
+                ",\n       weighted_bipred_idc=" + weighted_bipred_idc +
+                ",\n       pic_init_qp_minus26=" + pic_init_qp_minus26 +
+                ",\n       pic_init_qs_minus26=" + pic_init_qs_minus26 +
+                ",\n       chroma_qp_index_offset=" + chroma_qp_index_offset +
+                ",\n       deblocking_filter_control_present_flag=" + deblocking_filter_control_present_flag +
+                ",\n       constrained_intra_pred_flag=" + constrained_intra_pred_flag +
+                ",\n       redundant_pic_cnt_present_flag=" + redundant_pic_cnt_present_flag +
+                ",\n       top_left=" + top_left +
+                ",\n       bottom_right=" + bottom_right +
+                ",\n       run_length_minus1=" + run_length_minus1 +
+                ",\n       slice_group_change_direction_flag=" + slice_group_change_direction_flag +
+                ",\n       slice_group_id=" + slice_group_id +
+                ",\n       extended=" + extended +
+                '}';
+    }
+
+    public static class PPSExt {
+        public boolean transform_8x8_mode_flag;
+        public ScalingMatrix scalindMatrix = new ScalingMatrix();
+        public int second_chroma_qp_index_offset;
+        public boolean[] pic_scaling_list_present_flag;
+
+        @Override
+        public String toString() {
+            return "PPSExt{" +
+                    "transform_8x8_mode_flag=" + transform_8x8_mode_flag +
+                    ", scalindMatrix=" + scalindMatrix +
+                    ", second_chroma_qp_index_offset=" + second_chroma_qp_index_offset +
+                    ", pic_scaling_list_present_flag=" + pic_scaling_list_present_flag +
+                    '}';
+        }
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingList.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingList.java
new file mode 100755
index 0000000000..c36f07e2f9
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingList.java
@@ -0,0 +1,65 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+import java.io.IOException;
+
+/**
+ * Scaling list entity
+ * <p>
+ * capable to serialize / deserialize with CAVLC bitstream</p>
+ *
+ * @author Stanislav Vitvitskiy
+ */
+public class ScalingList {
+
+    public int[] scalingList;
+    public boolean useDefaultScalingMatrixFlag;
+
+    public static ScalingList read(ByteBufferBitreader is, int sizeOfScalingList)
+            throws IOException {
+
+        ScalingList sl = new ScalingList();
+        sl.scalingList = new int[sizeOfScalingList];
+        int lastScale = 8;
+        int nextScale = 8;
+        for (int j = 0; j < sizeOfScalingList; j++) {
+            if (nextScale != 0) {
+                int deltaScale = is.readSE();
+                nextScale = (lastScale + deltaScale + 256) % 256;
+                sl.useDefaultScalingMatrixFlag = (j == 0 && nextScale == 0);
+            }
+            sl.scalingList[j] = nextScale == 0 ? lastScale : nextScale;
+            lastScale = sl.scalingList[j];
+        }
+        return sl;
+    }
+
+
+    @Override
+    public String toString() {
+        return "ScalingList{" +
+                "scalingList=" + scalingList +
+                ", useDefaultScalingMatrixFlag=" + useDefaultScalingMatrixFlag +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingMatrix.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingMatrix.java
new file mode 100755
index 0000000000..95c72acb7c
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/ScalingMatrix.java
@@ -0,0 +1,38 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+import java.util.Arrays;
+
+public class ScalingMatrix {
+
+    public ScalingList[] ScalingList4x4;
+    public ScalingList[] ScalingList8x8;
+
+    @Override
+    public String toString() {
+        return "ScalingMatrix{" +
+                "ScalingList4x4=" + (ScalingList4x4 == null ? null : Arrays.asList(ScalingList4x4)) + "\n" +
+                ", ScalingList8x8=" + (ScalingList8x8 == null ? null : Arrays.asList(ScalingList8x8)) + "\n" +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SeqParameterSet.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SeqParameterSet.java
new file mode 100755
index 0000000000..4bfb7816e7
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SeqParameterSet.java
@@ -0,0 +1,352 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/**
+ * Sequence Parameter Set structure of h264 bitstream
+ * <p>
+ * capable to serialize and deserialize with CAVLC bitstream</p>
+ *
+ * @author Stanislav Vitvitskiy
+ */
+public class SeqParameterSet {
+    public int pic_order_cnt_type;
+    public boolean field_pic_flag;
+    public boolean delta_pic_order_always_zero_flag;
+    public boolean weighted_pred_flag;
+    public int weighted_bipred_idc;
+    public boolean entropy_coding_mode_flag;
+    public boolean mb_adaptive_frame_field_flag;
+    public boolean direct_8x8_inference_flag;
+    public ChromaFormat chroma_format_idc;
+    public int log2_max_frame_num_minus4;
+    public int log2_max_pic_order_cnt_lsb_minus4;
+    public int pic_height_in_map_units_minus1;
+    public int pic_width_in_mbs_minus1;
+    public int bit_depth_luma_minus8;
+    public int bit_depth_chroma_minus8;
+    public boolean qpprime_y_zero_transform_bypass_flag;
+    public int profile_idc;
+    public long reserved_zero_2bits;
+    public boolean constraint_set_0_flag;
+    public boolean constraint_set_1_flag;
+    public boolean constraint_set_2_flag;
+    public boolean constraint_set_3_flag;
+    public boolean constraint_set_4_flag;
+    public boolean constraint_set_5_flag;
+    public int level_idc;
+    public int seq_parameter_set_id;
+    public boolean residual_color_transform_flag;
+    public int offset_for_non_ref_pic;
+    public int offset_for_top_to_bottom_field;
+    public int num_ref_frames;
+    public boolean gaps_in_frame_num_value_allowed_flag;
+    public boolean frame_mbs_only_flag;
+    public boolean frame_cropping_flag;
+    public int frame_crop_left_offset;
+    public int frame_crop_right_offset;
+    public int frame_crop_top_offset;
+    public int frame_crop_bottom_offset;
+    public int[] offsetForRefFrame;
+    public VUIParameters vuiParams;
+    public ScalingMatrix scalingMatrix;
+    public int num_ref_frames_in_pic_order_cnt_cycle;
+
+
+    public static SeqParameterSet read(ByteBuffer b) throws IOException {
+        ByteBufferBitreader reader = new ByteBufferBitreader(b);
+        SeqParameterSet sps = new SeqParameterSet();
+
+        sps.profile_idc = (int) reader.readNBit(8);
+        sps.constraint_set_0_flag = reader
+                .readBool();
+        sps.constraint_set_1_flag = reader
+                .readBool();
+        sps.constraint_set_2_flag = reader
+                .readBool();
+        sps.constraint_set_3_flag = reader
+                .readBool();
+        sps.constraint_set_4_flag = reader
+                .readBool();
+        sps.constraint_set_5_flag = reader
+                .readBool();
+
+        sps.reserved_zero_2bits = reader.readNBit(2);
+        sps.level_idc = (int) reader.readNBit(8);
+        sps.seq_parameter_set_id = reader.readUE();
+
+        if (sps.profile_idc == 100 || sps.profile_idc == 110
+                || sps.profile_idc == 122 || sps.profile_idc == 144) {
+            sps.chroma_format_idc = ChromaFormat.fromId(reader
+                    .readUE());
+            if (sps.chroma_format_idc == ChromaFormat.YUV_444) {
+                sps.residual_color_transform_flag = reader
+                        .readBool();
+            }
+            sps.bit_depth_luma_minus8 = reader
+                    .readUE();
+            sps.bit_depth_chroma_minus8 = reader
+                    .readUE();
+            sps.qpprime_y_zero_transform_bypass_flag = reader
+                    .readBool();
+            boolean seqScalingMatrixPresent = reader
+                    .readBool();
+            if (seqScalingMatrixPresent) {
+                readScalingListMatrix(reader, sps);
+            }
+        } else {
+            sps.chroma_format_idc = ChromaFormat.YUV_420;
+        }
+        sps.log2_max_frame_num_minus4 = reader
+                .readUE();
+        sps.pic_order_cnt_type = reader.readUE();
+        if (sps.pic_order_cnt_type == 0) {
+            sps.log2_max_pic_order_cnt_lsb_minus4 = reader
+                    .readUE();
+        } else if (sps.pic_order_cnt_type == 1) {
+            sps.delta_pic_order_always_zero_flag = reader
+                    .readBool();
+            sps.offset_for_non_ref_pic = reader
+                    .readSE();
+            sps.offset_for_top_to_bottom_field = reader
+                    .readSE();
+            sps.num_ref_frames_in_pic_order_cnt_cycle = reader
+                    .readUE();
+            sps.offsetForRefFrame = new int[sps.num_ref_frames_in_pic_order_cnt_cycle];
+            for (int i = 0; i < sps.num_ref_frames_in_pic_order_cnt_cycle; i++) {
+                sps.offsetForRefFrame[i] = reader
+                        .readSE();
+            }
+        }
+        sps.num_ref_frames = reader.readUE();
+        sps.gaps_in_frame_num_value_allowed_flag = reader
+                .readBool();
+        sps.pic_width_in_mbs_minus1 = reader
+                .readUE();
+        sps.pic_height_in_map_units_minus1 = reader
+                .readUE();
+        sps.frame_mbs_only_flag = reader.readBool();
+        if (!sps.frame_mbs_only_flag) {
+            sps.mb_adaptive_frame_field_flag = reader
+                    .readBool();
+        }
+        sps.direct_8x8_inference_flag = reader
+                .readBool();
+        sps.frame_cropping_flag = reader.readBool();
+        if (sps.frame_cropping_flag) {
+            sps.frame_crop_left_offset = reader
+                    .readUE();
+            sps.frame_crop_right_offset = reader
+                    .readUE();
+            sps.frame_crop_top_offset = reader
+                    .readUE();
+            sps.frame_crop_bottom_offset = reader
+                    .readUE();
+        }
+        boolean vui_parameters_present_flag = reader
+                .readBool();
+        if (vui_parameters_present_flag)
+            sps.vuiParams = ReadVUIParameters(reader);
+
+        // reader.readTrailingBits();
+
+        return sps;
+    }
+
+    private static void readScalingListMatrix(ByteBufferBitreader reader,
+                                              SeqParameterSet sps) throws IOException {
+        sps.scalingMatrix = new ScalingMatrix();
+        for (int i = 0; i < 8; i++) {
+            boolean seqScalingListPresentFlag = reader
+                    .readBool();
+            if (seqScalingListPresentFlag) {
+                sps.scalingMatrix.ScalingList4x4 = new ScalingList[8];
+                sps.scalingMatrix.ScalingList8x8 = new ScalingList[8];
+                if (i < 6) {
+                    sps.scalingMatrix.ScalingList4x4[i] = ScalingList.read(
+                            reader, 16);
+                } else {
+                    sps.scalingMatrix.ScalingList8x8[i - 6] = ScalingList.read(
+                            reader, 64);
+                }
+            }
+        }
+    }
+
+    private static VUIParameters ReadVUIParameters(ByteBufferBitreader reader)
+            throws IOException {
+        VUIParameters vuip = new VUIParameters();
+        vuip.aspect_ratio_info_present_flag = reader
+                .readBool();
+        if (vuip.aspect_ratio_info_present_flag) {
+            vuip.aspect_ratio = AspectRatio.fromValue((int) reader.readNBit(8));
+            if (vuip.aspect_ratio == AspectRatio.Extended_SAR) {
+                vuip.sar_width = (int) reader.readNBit(16);
+                vuip.sar_height = (int) reader.readNBit(16);
+            }
+        }
+        vuip.overscan_info_present_flag = reader
+                .readBool();
+        if (vuip.overscan_info_present_flag) {
+            vuip.overscan_appropriate_flag = reader
+                    .readBool();
+        }
+        vuip.video_signal_type_present_flag = reader
+                .readBool();
+        if (vuip.video_signal_type_present_flag) {
+            vuip.video_format = (int) reader.readNBit(3);
+            vuip.video_full_range_flag = reader
+                    .readBool();
+            vuip.colour_description_present_flag = reader
+                    .readBool();
+            if (vuip.colour_description_present_flag) {
+                vuip.colour_primaries = (int) reader.readNBit(8);
+                vuip.transfer_characteristics = (int) reader.readNBit(8);
+                vuip.matrix_coefficients = (int) reader.readNBit(8);
+            }
+        }
+        vuip.chroma_loc_info_present_flag = reader
+                .readBool();
+        if (vuip.chroma_loc_info_present_flag) {
+            vuip.chroma_sample_loc_type_top_field = reader
+                    .readUE();
+            vuip.chroma_sample_loc_type_bottom_field = reader
+                    .readUE();
+        }
+        vuip.timing_info_present_flag = reader
+                .readBool();
+        if (vuip.timing_info_present_flag) {
+            vuip.num_units_in_tick = (int) reader.readNBit(32);
+            vuip.time_scale = (int) reader.readNBit(32);
+            vuip.fixed_frame_rate_flag = reader
+                    .readBool();
+        }
+        boolean nal_hrd_parameters_present_flag = reader
+                .readBool();
+        if (nal_hrd_parameters_present_flag)
+            vuip.nalHRDParams = readHRDParameters(reader);
+        boolean vcl_hrd_parameters_present_flag = reader
+                .readBool();
+        if (vcl_hrd_parameters_present_flag)
+            vuip.vclHRDParams = readHRDParameters(reader);
+        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {
+            vuip.low_delay_hrd_flag = reader
+                    .readBool();
+        }
+        vuip.pic_struct_present_flag = reader
+                .readBool();
+        boolean bitstream_restriction_flag = reader
+                .readBool();
+        if (bitstream_restriction_flag) {
+            vuip.bitstreamRestriction = new VUIParameters.BitstreamRestriction();
+            vuip.bitstreamRestriction.motion_vectors_over_pic_boundaries_flag = reader
+                    .readBool();
+            vuip.bitstreamRestriction.max_bytes_per_pic_denom = reader
+                    .readUE();
+            vuip.bitstreamRestriction.max_bits_per_mb_denom = reader
+                    .readUE();
+            vuip.bitstreamRestriction.log2_max_mv_length_horizontal = reader
+                    .readUE();
+            vuip.bitstreamRestriction.log2_max_mv_length_vertical = reader
+                    .readUE();
+            vuip.bitstreamRestriction.num_reorder_frames = reader
+                    .readUE();
+            vuip.bitstreamRestriction.max_dec_frame_buffering = reader
+                    .readUE();
+        }
+
+        return vuip;
+    }
+
+    private static HRDParameters readHRDParameters(ByteBufferBitreader reader)
+            throws IOException {
+        HRDParameters hrd = new HRDParameters();
+        hrd.cpb_cnt_minus1 = reader.readUE();
+        hrd.bit_rate_scale = (int) reader.readNBit(4);
+        hrd.cpb_size_scale = (int) reader.readNBit(4);
+        hrd.bit_rate_value_minus1 = new int[hrd.cpb_cnt_minus1 + 1];
+        hrd.cpb_size_value_minus1 = new int[hrd.cpb_cnt_minus1 + 1];
+        hrd.cbr_flag = new boolean[hrd.cpb_cnt_minus1 + 1];
+
+        for (int SchedSelIdx = 0; SchedSelIdx <= hrd.cpb_cnt_minus1; SchedSelIdx++) {
+            hrd.bit_rate_value_minus1[SchedSelIdx] = reader
+                    .readUE();
+            hrd.cpb_size_value_minus1[SchedSelIdx] = reader
+                    .readUE();
+            hrd.cbr_flag[SchedSelIdx] = reader.readBool();
+        }
+        hrd.initial_cpb_removal_delay_length_minus1 = (int) reader.readNBit(5);
+        hrd.cpb_removal_delay_length_minus1 = (int) reader.readNBit(5);
+        hrd.dpb_output_delay_length_minus1 = (int) reader.readNBit(5);
+        hrd.time_offset_length = (int) reader.readNBit(5);
+        return hrd;
+    }
+
+    @Override
+    public String toString() {
+        return "SeqParameterSet{ " +
+                "\n        pic_order_cnt_type=" + pic_order_cnt_type +
+                ", \n        field_pic_flag=" + field_pic_flag +
+                ", \n        delta_pic_order_always_zero_flag=" + delta_pic_order_always_zero_flag +
+                ", \n        weighted_pred_flag=" + weighted_pred_flag +
+                ", \n        weighted_bipred_idc=" + weighted_bipred_idc +
+                ", \n        entropy_coding_mode_flag=" + entropy_coding_mode_flag +
+                ", \n        mb_adaptive_frame_field_flag=" + mb_adaptive_frame_field_flag +
+                ", \n        direct_8x8_inference_flag=" + direct_8x8_inference_flag +
+                ", \n        chroma_format_idc=" + chroma_format_idc +
+                ", \n        log2_max_frame_num_minus4=" + log2_max_frame_num_minus4 +
+                ", \n        log2_max_pic_order_cnt_lsb_minus4=" + log2_max_pic_order_cnt_lsb_minus4 +
+                ", \n        pic_height_in_map_units_minus1=" + pic_height_in_map_units_minus1 +
+                ", \n        pic_width_in_mbs_minus1=" + pic_width_in_mbs_minus1 +
+                ", \n        bit_depth_luma_minus8=" + bit_depth_luma_minus8 +
+                ", \n        bit_depth_chroma_minus8=" + bit_depth_chroma_minus8 +
+                ", \n        qpprime_y_zero_transform_bypass_flag=" + qpprime_y_zero_transform_bypass_flag +
+                ", \n        profile_idc=" + profile_idc +
+                ", \n        constraint_set_0_flag=" + constraint_set_0_flag +
+                ", \n        constraint_set_1_flag=" + constraint_set_1_flag +
+                ", \n        constraint_set_2_flag=" + constraint_set_2_flag +
+                ", \n        constraint_set_3_flag=" + constraint_set_3_flag +
+                ", \n        constraint_set_4_flag=" + constraint_set_4_flag +
+                ", \n        constraint_set_5_flag=" + constraint_set_5_flag +
+                ", \n        level_idc=" + level_idc +
+                ", \n        seq_parameter_set_id=" + seq_parameter_set_id +
+                ", \n        residual_color_transform_flag=" + residual_color_transform_flag +
+                ", \n        offset_for_non_ref_pic=" + offset_for_non_ref_pic +
+                ", \n        offset_for_top_to_bottom_field=" + offset_for_top_to_bottom_field +
+                ", \n        num_ref_frames=" + num_ref_frames +
+                ", \n        gaps_in_frame_num_value_allowed_flag=" + gaps_in_frame_num_value_allowed_flag +
+                ", \n        frame_mbs_only_flag=" + frame_mbs_only_flag +
+                ", \n        frame_cropping_flag=" + frame_cropping_flag +
+                ", \n        frame_crop_left_offset=" + frame_crop_left_offset +
+                ", \n        frame_crop_right_offset=" + frame_crop_right_offset +
+                ", \n        frame_crop_top_offset=" + frame_crop_top_offset +
+                ", \n        frame_crop_bottom_offset=" + frame_crop_bottom_offset +
+                ", \n        offsetForRefFrame=" + offsetForRefFrame +
+                ", \n        vuiParams=" + vuiParams +
+                ", \n        scalingMatrix=" + scalingMatrix +
+                ", \n        num_ref_frames_in_pic_order_cnt_cycle=" + num_ref_frames_in_pic_order_cnt_cycle +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SliceHeader.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SliceHeader.java
new file mode 100755
index 0000000000..1275a56c40
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/SliceHeader.java
@@ -0,0 +1,128 @@
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Map;
+
+public class SliceHeader {
+
+    public int first_mb_in_slice;
+    public SliceType slice_type;
+    public int pic_parameter_set_id;
+    public int colour_plane_id;
+    public int frame_num;
+    public boolean field_pic_flag = false;
+    public boolean bottom_field_flag = false;
+    public int idr_pic_id = -1;
+    public int pic_order_cnt_lsb;
+    public int delta_pic_order_cnt_bottom;
+    public int delta_pic_order_cnt_0;
+    public int delta_pic_order_cnt_1;
+    public PictureParameterSet pps;
+    public SeqParameterSet sps;
+
+    public SliceHeader(ByteBuffer in, Map<Integer, SeqParameterSet> spss, Map<Integer, PictureParameterSet> ppss, boolean IdrPicFlag) {
+        try {
+            in.position(1);
+            ByteBufferBitreader reader = new ByteBufferBitreader(in);
+            first_mb_in_slice = reader.readUE();
+            int sliceTypeInt = reader.readUE();
+            switch (sliceTypeInt) {
+                case 0:
+                case 5:
+                    slice_type = SliceType.P;
+                    break;
+
+                case 1:
+                case 6:
+                    slice_type = SliceType.B;
+                    break;
+
+                case 2:
+                case 7:
+                    slice_type = SliceType.I;
+                    break;
+
+                case 3:
+                case 8:
+                    slice_type = SliceType.SP;
+                    break;
+
+                case 4:
+                case 9:
+                    slice_type = SliceType.SI;
+                    break;
+
+            }
+
+            pic_parameter_set_id = reader.readUE();
+            pps = ppss.get(pic_parameter_set_id);
+            if (pps == null) {
+                String ids = "";
+                for (Integer integer : ppss.keySet()) {
+                    ids += integer + ", ";
+                }
+                throw new RuntimeException("PPS with ids " + ids + " available but not " + pic_parameter_set_id);
+            }
+            sps = spss.get(pps.seq_parameter_set_id);
+            if (sps == null) {
+                String ids = "";
+                for (Integer integer : spss.keySet()) {
+                    ids += integer + ", ";
+                }
+                throw new RuntimeException("SPS with ids " + ids + " available but not " + pps.seq_parameter_set_id);
+            }
+            if (sps.residual_color_transform_flag) {
+                colour_plane_id = (int) reader.readNBit(2);
+            }
+            frame_num = (int) reader.readNBit(sps.log2_max_frame_num_minus4 + 4);
+            if (!sps.frame_mbs_only_flag) {
+                field_pic_flag = reader.readBool();
+                if (field_pic_flag) {
+                    bottom_field_flag = reader.readBool();
+                }
+            }
+            if (IdrPicFlag) {
+                idr_pic_id = reader.readUE();
+            }
+            if (sps.pic_order_cnt_type == 0) {
+                pic_order_cnt_lsb = (int) reader.readNBit(sps.log2_max_pic_order_cnt_lsb_minus4 + 4);
+                if (pps.bottom_field_pic_order_in_frame_present_flag && !field_pic_flag) {
+                    delta_pic_order_cnt_bottom = reader.readSE();
+                }
+            }
+
+            if (sps.pic_order_cnt_type == 1 && !sps.delta_pic_order_always_zero_flag) {
+
+                delta_pic_order_cnt_0 = reader.readSE();
+                if (pps.bottom_field_pic_order_in_frame_present_flag && !field_pic_flag) {
+                    delta_pic_order_cnt_1 = reader.readSE();
+                }
+            }
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    @Override
+    public String toString() {
+        return "SliceHeader{" +
+                "first_mb_in_slice=" + first_mb_in_slice +
+                ", slice_type=" + slice_type +
+                ", pic_parameter_set_id=" + pic_parameter_set_id +
+                ", colour_plane_id=" + colour_plane_id +
+                ", frame_num=" + frame_num +
+                ", field_pic_flag=" + field_pic_flag +
+                ", bottom_field_flag=" + bottom_field_flag +
+                ", idr_pic_id=" + idr_pic_id +
+                ", pic_order_cnt_lsb=" + pic_order_cnt_lsb +
+                ", delta_pic_order_cnt_bottom=" + delta_pic_order_cnt_bottom +
+                '}';
+    }
+
+    public enum SliceType {
+        P, B, I, SP, SI
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/VUIParameters.java b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/VUIParameters.java
new file mode 100755
index 0000000000..36ac8565b1
--- /dev/null
+++ b/streaming/src/main/java/org/mp4parser/streaming/input/h264/spspps/VUIParameters.java
@@ -0,0 +1,107 @@
+/*
+Copyright (c) 2011 Stanislav Vitvitskiy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this
+software and associated documentation files (the "Software"), to deal in the Software
+without restriction, including without limitation the rights to use, copy, modify,
+merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
+PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
+FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
+OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+package org.mp4parser.streaming.input.h264.spspps;
+
+
+public class VUIParameters {
+
+    public boolean aspect_ratio_info_present_flag;
+    public int sar_width;
+    public int sar_height;
+    public boolean overscan_info_present_flag;
+    public boolean overscan_appropriate_flag;
+    public boolean video_signal_type_present_flag;
+    public int video_format;
+    public boolean video_full_range_flag;
+    public boolean colour_description_present_flag;
+    public int colour_primaries;
+    public int transfer_characteristics;
+    public int matrix_coefficients;
+    public boolean chroma_loc_info_present_flag;
+    public int chroma_sample_loc_type_top_field;
+    public int chroma_sample_loc_type_bottom_field;
+    public boolean timing_info_present_flag;
+    public int num_units_in_tick;
+    public int time_scale;
+    public boolean fixed_frame_rate_flag;
+    public boolean low_delay_hrd_flag;
+    public boolean pic_struct_present_flag;
+    public HRDParameters nalHRDParams;
+    public HRDParameters vclHRDParams;
+    public BitstreamRestriction bitstreamRestriction;
+    public AspectRatio aspect_ratio;
+
+    @Override
+    public String toString() {
+        return "VUIParameters{" + "\n" +
+                "aspect_ratio_info_present_flag=" + aspect_ratio_info_present_flag + "\n" +
+                ", sar_width=" + sar_width + "\n" +
+                ", sar_height=" + sar_height + "\n" +
+                ", overscan_info_present_flag=" + overscan_info_present_flag + "\n" +
+                ", overscan_appropriate_flag=" + overscan_appropriate_flag + "\n" +
+                ", video_signal_type_present_flag=" + video_signal_type_present_flag + "\n" +
+                ", video_format=" + video_format + "\n" +
+                ", video_full_range_flag=" + video_full_range_flag + "\n" +
+                ", colour_description_present_flag=" + colour_description_present_flag + "\n" +
+                ", colour_primaries=" + colour_primaries + "\n" +
+                ", transfer_characteristics=" + transfer_characteristics + "\n" +
+                ", matrix_coefficients=" + matrix_coefficients + "\n" +
+                ", chroma_loc_info_present_flag=" + chroma_loc_info_present_flag + "\n" +
+                ", chroma_sample_loc_type_top_field=" + chroma_sample_loc_type_top_field + "\n" +
+                ", chroma_sample_loc_type_bottom_field=" + chroma_sample_loc_type_bottom_field + "\n" +
+                ", timing_info_present_flag=" + timing_info_present_flag + "\n" +
+                ", num_units_in_tick=" + num_units_in_tick + "\n" +
+                ", time_scale=" + time_scale + "\n" +
+                ", fixed_frame_rate_flag=" + fixed_frame_rate_flag + "\n" +
+                ", low_delay_hrd_flag=" + low_delay_hrd_flag + "\n" +
+                ", pic_struct_present_flag=" + pic_struct_present_flag + "\n" +
+                ", nalHRDParams=" + nalHRDParams + "\n" +
+                ", vclHRDParams=" + vclHRDParams + "\n" +
+                ", bitstreamRestriction=" + bitstreamRestriction + "\n" +
+                ", aspect_ratio=" + aspect_ratio + "\n" +
+                '}';
+    }
+
+    public static class BitstreamRestriction {
+
+        public boolean motion_vectors_over_pic_boundaries_flag;
+        public int max_bytes_per_pic_denom;
+        public int max_bits_per_mb_denom;
+        public int log2_max_mv_length_horizontal;
+        public int log2_max_mv_length_vertical;
+        public int num_reorder_frames;
+        public int max_dec_frame_buffering;
+
+        @Override
+        public String toString() {
+            final StringBuilder sb = new StringBuilder("BitstreamRestriction{");
+            sb.append("motion_vectors_over_pic_boundaries_flag=").append(motion_vectors_over_pic_boundaries_flag);
+            sb.append(", max_bytes_per_pic_denom=").append(max_bytes_per_pic_denom);
+            sb.append(", max_bits_per_mb_denom=").append(max_bits_per_mb_denom);
+            sb.append(", log2_max_mv_length_horizontal=").append(log2_max_mv_length_horizontal);
+            sb.append(", log2_max_mv_length_vertical=").append(log2_max_mv_length_vertical);
+            sb.append(", num_reorder_frames=").append(num_reorder_frames);
+            sb.append(", max_dec_frame_buffering=").append(max_dec_frame_buffering);
+            sb.append('}');
+            return sb.toString();
+        }
+    }
+}
diff --git a/streaming/src/main/java/org/mp4parser/streaming/output/mp4/StandardMp4Writer.java b/streaming/src/main/java/org/mp4parser/streaming/output/mp4/StandardMp4Writer.java
index 3423fcdd99..e03424259d 100755
--- a/streaming/src/main/java/org/mp4parser/streaming/output/mp4/StandardMp4Writer.java
+++ b/streaming/src/main/java/org/mp4parser/streaming/output/mp4/StandardMp4Writer.java
@@ -4,6 +4,8 @@
 import org.mp4parser.boxes.iso14496.part12.*;
 import org.mp4parser.streaming.StreamingSample;
 import org.mp4parser.streaming.StreamingTrack;
+import org.mp4parser.streaming.extensions.CompositionTimeSampleExtension;
+import org.mp4parser.streaming.extensions.CompositionTimeTrackExtension;
 import org.mp4parser.streaming.extensions.SampleFlagsSampleExtension;
 import org.mp4parser.streaming.extensions.TrackIdTrackExtension;
 import org.mp4parser.streaming.output.SampleSink;
@@ -20,6 +22,8 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import static org.mp4parser.tools.CastUtils.l2i;
+
 /**
  * Creates an MP4
  */
@@ -269,6 +273,7 @@ public void acceptSample(StreamingSample streamingSample, StreamingTrack streami
     }
 
     private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
+
         List<StreamingSample> samples = sampleBuffers.get(streamingTrack);
         long chunkNumber = chunkNumbers.get(streamingTrack);
         chunkNumbers.put(streamingTrack, chunkNumber + 1);
@@ -277,7 +282,9 @@ private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
         cc.mdat = new Mdat(samples);
         cc.duration = nextSampleStartTime.get(streamingTrack) - nextChunkCreateStartTime.get(streamingTrack);
         TrackBox tb = trackBoxes.get(streamingTrack);
-        SampleToChunkBox stsc = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]/stsc[0]");
+        SampleTableBox stbl = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]");
+        assert stbl != null;
+        SampleToChunkBox stsc = Path.getPath(stbl, "stsc[0]");
         assert stsc != null;
         if (stsc.getEntries().isEmpty()) {
             List<SampleToChunkBox.Entry> entries = new ArrayList<SampleToChunkBox.Entry>();
@@ -291,15 +298,30 @@ private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
         }
         long sampleNumber = sampleNumbers.get(streamingTrack);
 
-        SampleSizeBox stsz = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]/stsz[0]");
-        TimeToSampleBox stts = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]/stts[0]");
-        SyncSampleBox stss = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]/stss[0]");
+        SampleSizeBox stsz = Path.getPath(stbl, "stsz[0]");
+        TimeToSampleBox stts = Path.getPath(stbl, "stts[0]");
+        SyncSampleBox stss = Path.getPath(stbl, "stss[0]");
+        CompositionTimeToSample ctts = Path.getPath(stbl, "ctts[0]");
+        if (streamingTrack.getTrackExtension(CompositionTimeTrackExtension.class) != null) {
+            if (ctts == null) {
+                ctts = new CompositionTimeToSample();
+                ctts.setEntries(new ArrayList<CompositionTimeToSample.Entry>());
+
+                ArrayList<Box> bs = new ArrayList<Box>(stbl.getBoxes());
+                bs.add(bs.indexOf(stts), ctts);
+            }
+        }
 
         long[] sampleSizes = new long[samples.size()];
         int i = 0;
         for (StreamingSample sample : samples) {
             sampleSizes[i++] = sample.getContent().limit();
 
+            if (ctts != null) {
+                ctts.getEntries().add(
+                        new CompositionTimeToSample.Entry(1, l2i(sample.getSampleExtension(CompositionTimeSampleExtension.class).getCompositionTimeOffset())));
+            }
+
             assert stts != null;
             if (stts.getEntries().isEmpty()) {
                 ArrayList<TimeToSampleBox.Entry> entries = new ArrayList<TimeToSampleBox.Entry>(stts.getEntries());
@@ -315,11 +337,8 @@ private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
             }
             SampleFlagsSampleExtension sampleFlagsSampleExtension = sample.getSampleExtension(SampleFlagsSampleExtension.class);
             if (sampleFlagsSampleExtension != null && sampleFlagsSampleExtension.isSyncSample()) {
-
                 if (stss == null) {
-                    SampleTableBox stbl = Path.getPath(tb, "mdia[0]/minf[0]/stbl[0]");
                     stss = new SyncSampleBox();
-                    assert stbl != null;
                     stbl.addBox(stss);
                 }
                 stss.setSampleNumber(Mp4Arrays.copyOfAndAppend(stss.getSampleNumber(), sampleNumber));
@@ -332,6 +351,7 @@ private ChunkContainer createChunkContainer(StreamingTrack streamingTrack) {
 
         sampleNumbers.put(streamingTrack, sampleNumber);
         samples.clear();
+        System.err.println("CC created. mdat size: " + cc.mdat.size);
         return cc;
     }
 
@@ -375,7 +395,7 @@ public void getBox(WritableByteChannel writableByteChannel) throws IOException {
 
             }));
             for (StreamingSample sample : samples) {
-                writableByteChannel.write(sample.getContent());
+                writableByteChannel.write((ByteBuffer) sample.getContent().rewind());
             }
 
 
diff --git a/streaming/src/test/java/org/mp4parser/streaming/input/h264/H264AnnexBTrackTest.java b/streaming/src/test/java/org/mp4parser/streaming/input/h264/H264AnnexBTrackTest.java
index 0e61f14f7d..fe53a98bde 100755
--- a/streaming/src/test/java/org/mp4parser/streaming/input/h264/H264AnnexBTrackTest.java
+++ b/streaming/src/test/java/org/mp4parser/streaming/input/h264/H264AnnexBTrackTest.java
@@ -4,12 +4,12 @@
 import org.mp4parser.IsoFile;
 import org.mp4parser.muxer.InMemRandomAccessSourceImpl;
 import org.mp4parser.muxer.Sample;
-import org.mp4parser.muxer.container.mp4.MovieCreator;
 import org.mp4parser.muxer.samples.SampleList;
 import org.mp4parser.streaming.StreamingTrack;
 import org.mp4parser.streaming.output.mp4.FragmentedMp4Writer;
 
-import java.io.*;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.nio.channels.Channels;
 import java.util.Collections;
 import java.util.List;
diff --git a/streaming/src/test/java/org/mp4parser/streaming/input/h264/NalStreamTokenizerTest.java b/streaming/src/test/java/org/mp4parser/streaming/input/h264/NalStreamTokenizerTest.java
index b951698f60..5a14e1bd04 100755
--- a/streaming/src/test/java/org/mp4parser/streaming/input/h264/NalStreamTokenizerTest.java
+++ b/streaming/src/test/java/org/mp4parser/streaming/input/h264/NalStreamTokenizerTest.java
@@ -2,6 +2,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
+import org.mp4parser.tools.Hex;
 
 /**
  * Created by sannies on 15.08.2015.
@@ -19,7 +20,7 @@ public void testTokenize() throws Exception {
 
         int i = 0;
         while ((nal = nst.getNext()) != null) {
-            //System.err.println(Hex.encodeHex(nal));
+            System.err.println(Hex.encodeHex(nal));
             i++;
         }
         Assert.assertEquals(1019, i);
diff --git a/streaming/src/test/java/org/mp4parser/streaming/output/mp4/StandardMp4WriterTest.java b/streaming/src/test/java/org/mp4parser/streaming/output/mp4/StandardMp4WriterTest.java
index d3083e9c69..dc7a3c36e7 100755
--- a/streaming/src/test/java/org/mp4parser/streaming/output/mp4/StandardMp4WriterTest.java
+++ b/streaming/src/test/java/org/mp4parser/streaming/output/mp4/StandardMp4WriterTest.java
@@ -4,7 +4,6 @@
 import org.mp4parser.streaming.StreamingTrack;
 import org.mp4parser.streaming.input.h264.H264AnnexBTrack;
 
-import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
 import java.nio.channels.Channels;
@@ -17,7 +16,7 @@
 
     @Test
     public void testMuxing() throws Exception {
-        H264AnnexBTrack b = new H264AnnexBTrack(new FileInputStream("C:\\dev\\mp4parser\\out.264"));
+        H264AnnexBTrack b = new H264AnnexBTrack(StandardMp4WriterTest.class.getResourceAsStream("/org/mp4parser/streaming/input/h264/tos.h264"));
         OutputStream baos = new FileOutputStream("output.mp4");
         StandardMp4Writer writer = new StandardMp4Writer(Collections.<StreamingTrack>singletonList(b), Channels.newChannel(baos));
         //MultiTrackFragmentedMp4Writer writer = new MultiTrackFragmentedMp4Writer(new StreamingTrack[]{b}, new ByteArrayOutputStream());
