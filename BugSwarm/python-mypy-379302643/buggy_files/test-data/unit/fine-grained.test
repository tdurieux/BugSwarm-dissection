-- Test cases for fine-grained incremental checking
--
-- Test cases may define multiple versions of a file
-- (e.g. m.py, m.py.2). There is always an initial batch
-- pass that processes all files present initially, followed
-- by one or more fine-grained incremental passes that use
-- alternative versions of files, if available. If a file
-- just has a single .py version, it is used for all passes.

-- TODO: what if version for some passes but not all

-- Output is laid out like this:
--
--   [out]
--   <optional output from batch pass>
--   ==
--   <optional output from first incremental pass>
--
--
-- Modules that are expected to be detected as changed by dmypy_server
-- can be checked with [stale ...]
-- Generally this should mean added, deleted, or changed files, though there
-- are important edge cases related to the cache: deleted files won't be detected
-- as changed in the initial run with the cache while modules that depended on them
-- should be.
--
-- Modules that are require a full-module reprocessing by update can be checked with
-- [rechecked ...]. This should include any files detected as having changed as well
-- as any files that contain targets that need to be reprocessed but which haven't
-- been loaded yet. If there is no [rechecked...] directive, it inherits the value of
-- [stale ...].
--
-- Specifications for later runs can be given with [stale2 ...], [stale3 ...], etc.
--
-- Test runner can parse options from mypy.ini file. Updating this file in between
-- incremental runs is not yet supported.
--
-- Each test case run without caching and with caching (if the initial run passes),
-- unless it has one a --skip-cache or --skip-nocache suffix. We sometimes
-- skip caching test cases to speed up tests, if the caching variant is not useful.
-- The caching test case variants get an implicit _cached suffix.

[case testReprocessFunction]
import m
def g() -> int:
    return m.f()
[file m.py]
def f() -> int:
    pass
[file m.py.2]
def f() -> str:
    pass
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testReprocessTopLevel]
import m
m.f(1)
def g() -> None: pass
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def f(x: str) -> None: pass
[out]
==
main:2: error: Argument 1 to "f" has incompatible type "int"; expected "str"

[case testReprocessMethod]
import m
class B:
    def f(self, a: m.A) -> None:
        a.g() # E
[file m.py]
class A:
    def g(self) -> None: pass
[file m.py.2]
class A:
    def g(self, a: A) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "A"

[case testFunctionMissingModuleAttribute]
import m
def h() -> None:
    m.f(1)
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def g(x: str) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "f"

[case testTopLevelMissingModuleAttribute]
import m
m.f(1)
def g() -> None: pass
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def g(x: int) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:2: error: Module has no attribute "f"

[case testClassChangedIntoFunction]
import m
def f(a: m.A) -> None:
    pass
[file m.py]
class A: pass
[file m.py.2]
def A() -> None: pass
[out]
==
main:2: error: Invalid type "m.A"

[case testClassChangedIntoFunction2]
import m
class B:
    def f(self, a: m.A) -> None: pass
[file m.py]
class A: pass
[file m.py.2]
def A() -> None: pass
[file n.py.3]
[out]
==
main:3: error: Invalid type "m.A"
==
main:3: error: Invalid type "m.A"

[case testAttributeTypeChanged]
import m
def f(a: m.A) -> int:
    return a.x
[file m.py]
class A:
    def f(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def f(self) -> None:
        self.x = 'x'
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testAttributeRemoved]
import m
def f(a: m.A) -> int:
    return a.x
[file m.py]
class A:
    def f(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "x"

[case testVariableTypeBecomesInvalid]
import m
def f() -> None:
    a = None # type: m.A
[file m.py]
class A: pass
[file m.py.2]
[out]
==
main:3: error: Name 'm.A' is not defined

[case testTwoIncrementalSteps]
import m
import n
[file m.py]
def f() -> None: pass
[file n.py]
import m
def g() -> None:
    m.f() # E
[file m.py.2]
import n
def f(x: int) -> None:
    n.g() # E
[file n.py.3]
import m
def g(a: str) -> None:
    m.f('') # E
[out]
==
n.py:3: error: Too few arguments for "f"
==
n.py:3: error: Argument 1 to "f" has incompatible type "str"; expected "int"
m.py:3: error: Too few arguments for "g"

[case testTwoRounds]
import m
def h(a: m.A) -> int:
    return a.x
[file m.py]
import n
class A:
    def g(self, b: n.B) -> None:
        self.x = b.f()
[file n.py]
class B:
    def f(self) -> int: pass
[file n.py.2]
class B:
    def f(self) -> str: pass
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testFixTypeError]
import m
def f(a: m.A) -> None:
    a.f(a)
[file m.py]
class A:
    def f(self, a: 'A') -> None: pass
[file m.py.2]
class A:
    def f(self) -> None: pass
[file m.py.3]
class A:
    def f(self, a: 'A') -> None: pass
[out]
==
main:3: error: Too many arguments for "f" of "A"
==

[case testFixTypeError2]
import m
def f(a: m.A) -> None:
    a.f()
[file m.py]
class A:
    def f(self) -> None: pass
[file m.py.2]
class A:
    def g(self) -> None: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
==

[case testFixSemanticAnalysisError]
import m
def f() -> None:
    m.A()
[file m.py]
class A: pass
[file m.py.2]
class B: pass
[file m.py.3]
class A: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "A"
==

[case testContinueToReportTypeCheckError]
import m
def f(a: m.A) -> None:
    a.f()
def g(a: m.A) -> None:
    a.g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
main:5: error: "A" has no attribute "g"
==
main:5: error: "A" has no attribute "g"

[case testContinueToReportSemanticAnalysisError]
import m
def f() -> None:
    m.A()
def g() -> None:
    m.B()
[file m.py]
class A: pass
class B: pass
[file m.py.2]
[file m.py.3]
class A: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "A"
main:5: error: Module has no attribute "B"
==
main:5: error: Module has no attribute "B"

[case testContinueToReportErrorAtTopLevel-skip-cache]
-- Different cache/no-cache tests because:
-- Error message ordering differs
import n
import m
m.A().f()
[file n.py]
import m
m.A().g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
n.py:2: error: "A" has no attribute "g"
==
n.py:2: error: "A" has no attribute "g"

[case testContinueToReportErrorAtTopLevel-skip-nocache]
-- Different cache/no-cache tests because:
-- Error message ordering differs
import n
import m
m.A().f()
[file n.py]
import m
m.A().g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
n.py:2: error: "A" has no attribute "g"
main:3: error: "A" has no attribute "f"
==
n.py:2: error: "A" has no attribute "g"

[case testContinueToReportErrorInMethod]
import m
class C:
    def f(self, a: m.A) -> None:
        a.f()
    def g(self, a: m.A) -> None:
        a.g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:4: error: "A" has no attribute "f"
main:6: error: "A" has no attribute "g"
==
main:6: error: "A" has no attribute "g"

[case testInitialBatchGeneratedError]
import m
def g() -> None:
    m.f()
def h() -> None:
    m.g()
[file m.py]
def f(x: object) -> None: pass
[file m.py.2]
def f() -> None: pass
[file m.py.3]
def f() -> None: pass
def g() -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Too few arguments for "f"
main:5: error: Module has no attribute "g"
==
main:5: error: Module has no attribute "g"
==

[case testKeepReportingErrorIfNoChanges]
import m
def h() -> None:
    m.g()
[file m.py]
[file m.py.2]
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Module has no attribute "g"
==
main:3: error: Module has no attribute "g"

[case testFixErrorAndReintroduce]
import m
def h() -> None:
    m.g()
[file m.py]
[file m.py.2]
def g() -> None: pass
[file m.py.3]
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Module has no attribute "g"
==
==
main:3: error: Module has no attribute "g"

[case testIgnoreWorksAfterUpdate]
import a
[file a.py]
import b
int() + str()  # type: ignore
[file b.py]
x = 1
[file b.py.2]
x = 2
[file b.py.3]
x = 3
[delete b.py.4]
[out]
==
==
==
a.py:1: error: Cannot find module named 'b'
a.py:1: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)

[case testIgnoreWorksWithMissingImports]
import a
[file a.py]
import b
import xyz  # type: ignore
xyz.whatever
[file b.py]
x = 1
[file b.py.2]
x = 2
[file b.py.3]
x = 3
[file xyz.py.4]
[out]
==
==
==
a.py:3: error: "object" has no attribute "whatever"

[case testAddedIgnoreWithMissingImports]
import a
[file a.py]
from b import x
y: int = x
[file b.py]
from xyz import x
[file b.py.2]
from xyz import x  # type: ignore
[file xyz.py.3]
x = str()
[out]
b.py:1: error: Cannot find module named 'xyz'
b.py:1: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
==
a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRemovedIgnoreWithMissingImport]
import a
[file a.py]
from b import x
y: int = x
[file b.py]
from xyz import x  # type: ignore
[file b.py.2]
from xyz import x
[file xyz.py.3]
x = str()
[out]
==
b.py:1: error: Cannot find module named 'xyz'
b.py:1: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testRemovedModuleUnderIgnore]
import a
[file a.py]
import c
from b import x  # type: ignore
y: int = x
[file b.py]
x = str()
[file c.py]
x = 1
[delete b.py.2]
[file c.py.3]
x = 3
[out]
a.py:3: error: Incompatible types in assignment (expression has type "str", variable has type "int")
==
==

[case AddedModuleUnderIgnore]
import a
[file a.py]
import c
from b import x  # type: ignore
y: int = x
[file c.py]
x = 1
[file c.py.2]
x = 2
[file b.py.3]
# empty
[out]
==
==

[case testIgnoreInBetween]
import a
[file a.py]
import b
x: int = b.x
[file b.py]
import c
x = c.C.x  # type: ignore
[file c.py]
class C:
    pass
[file c.py.2]
class C:
    x: int
[file c.py.3]
# empty
[file c.py.4]
class C:
    x: str
[out]
==
==
==
a.py:2: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testIgnoredAttrReprocessedModule-skip]
# See https://github.com/python/mypy/issues/4782
import a
[file a.py]
import b
x = b.x  # type: ignore
y: int = x
[file b.py]
import c
[file b.py.2]
import c
x = c.x
[file c.py]
x: str
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testIgnoredAttrReprocessedBase]
import a
[file a.py]
import b
def fun() -> None:
    x = b.C.x  # type: ignore
    y: int = x
[file b.py]
import c
class C:
    pass
[file b.py.2]
import c
class C(c.B):
    pass
[file c.py]
class B:
    x: str
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testIgnoredAttrReprocessedMeta]
import a
[file a.py]
import b
def fun() -> None:
    x = b.C.x  # type: ignore
    y: int = x
[file b.py]
import c
class C:
    pass
[file b.py.2]
import c
class C(metaclass=c.M):
    pass
[file c.py]
class M(type):
    x: str
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testAddBaseClassMethodCausingInvalidOverride]
import m
class B(m.A):
    def f(self) -> str: pass
[file m.py]
class A: pass
[file m.py.2]
class A:
    def f(self) -> int: pass
[file n.py.3]
[out]
==
main:3: error: Return type of "f" incompatible with supertype "A"
==
main:3: error: Return type of "f" incompatible with supertype "A"

[case testModifyBaseClassMethodCausingInvalidOverride]
import m
class B(m.A):
    def f(self) -> str: pass
[file m.py]
class A:
    def f(self) -> str: pass
[file m.py.2]
class A:
    def f(self) -> int: pass
[out]
==
main:3: error: Return type of "f" incompatible with supertype "A"

[case testAddBaseClassAttributeCausingErrorInSubclass]
import m
class B(m.A):
    def a(self) -> None:
        x = 1
        x = self.x

    def f(self) -> None:
        self.x = 1

    def z(self) -> None:
        x = 1
        x = self.x
[file m.py]
class A: pass
[file m.py.2]
class A:
    def g(self) -> None:
        self.x = 'a'
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:8: error: Incompatible types in assignment (expression has type "int", variable has type "str")
main:12: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testChangeBaseClassAttributeType]
import m
class B(m.A):
    def f(sel) -> None:
        sel.x = 1
[file m.py]
class A:
    def g(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def g(self) -> None:
        self.x = 'a'
[out]
==
main:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testRemoveAttributeInBaseClass]
import m
class B(m.A):
    def f(self) -> None:
        a = 1
        a = self.x
[file m.py]
class A:
    def g(self) -> None:
        self.x = 1
[file m.py.2]
class A: pass
[out]
==
main:5: error: "B" has no attribute "x"

[case testTestSignatureOfInheritedMethod]
import m
class B(m.A):
    def f(self) -> None:
        self.g()
[file m.py]
class A:
    def g(self) -> None: pass
[file m.py.2]
class A:
    def g(self, a: 'A') -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "A"

[case testRemoveBaseClass]
import m
class A(m.B):
    def f(self) -> None:
        self.g()
        self.x
        self.y = 1
[file m.py]
class C:
    def g(self) -> None:
        self.x = 1
class B(C): pass
[file m.py.2]
class C: pass
class B: pass
[out]
==
main:4: error: "A" has no attribute "g"
main:5: error: "A" has no attribute "x"

[case testRemoveBaseClass2]
import m
class A(m.B):
    def f(self) -> None:
        self.g()
        self.x
        self.y = 1
[file m.py]
class C:
    def g(self) -> None:
        self.x = 1
class B(C): pass
[file m.py.2]
class C:
    def g(self) -> None:
        self.x = 1
class B: pass
[out]
==
main:4: error: "A" has no attribute "g"
main:5: error: "A" has no attribute "x"

[case testChangeInPackage]
import m.n
def f() -> None:
    m.n.g()
[file m/__init__.py]
[file m/n.py]
def g() -> None: pass
[file m/n.py.2]
def g(x: int) -> None: pass
[out]
==
main:3: error: Too few arguments for "g"

[case testTriggerTargetInPackage]
import m.n
[file m/__init__.py]
[file m/n.py]
import a
def f() -> None:
    a.g()
[file a.py]
def g() -> None: pass
[file a.py.2]
def g(x: int) -> None: pass
[out]
==
m/n.py:3: error: Too few arguments for "g"

[case testChangeInPackage__init__]
import m
import m.n
def f() -> None:
    m.g()
[file m/__init__.py]
def g() -> None: pass
[file m/__init__.py.2]
def g(x: int) -> None: pass
[file m/n.py]
[out]
==
main:4: error: Too few arguments for "g"

[case testTriggerTargetInPackage__init__]
import m
import m.n
[file m/__init__.py]
import a
def f() -> None:
    a.g()
[file a.py]
def g() -> None: pass
[file a.py.2]
def g(x: int) -> None: pass
[file m/n.py]
[out]
==
m/__init__.py:3: error: Too few arguments for "g"

[case testModuleAttributeTypeChanges]
import m
def f() -> None:
    x = 1
    x = m.x
[file m.py]
x = 1
[file m.py.2]
x = ''
[out]
==
main:4: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoStepsDueToModuleAttribute]
import m
x = m.f()

def g() -> None:
    y = 1
    y = x # E
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[out]
==
main:6: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoStepsDueToMultipleNamespaces]
import m

x = m.f()

def g() -> None:
    xx = 1
    xx = x

class A:
    def a(self) -> None:
        self.y = m.f()
    def b(self) -> None:
        yy = 1
        yy = self.y

class B:
    def c(self) -> None:
        self.z = m.f()
    def b(self) -> None:
        zz = 1
        zz = self.z
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[out]
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:14: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:21: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testConstructorSignatureChanged]
import m

def f() -> None:
    m.A()
[file m.py]
class A:
    def __init__(self) -> None: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "A"

[case testConstructorSignatureChanged2]
from typing import Callable
import m

def use(x: Callable[[], m.A]) -> None:
    x()
def f() -> None:
    use(m.A)
[file m.py]
class A:
    def __init__(self) -> None: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
-- This is a bad error message
main:7: error: Argument 1 to "use" has incompatible type "Type[A]"; expected "Callable[[], A]"

[case testConstructorSignatureChanged3]
from a import C
class D(C):
    def g(self) -> None:
        super().__init__()
D()
[file a.py]
class C:
    def __init__(self) -> None: pass
[file a.py.2]
class C:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "__init__" of "C"
main:5: error: Too few arguments for "D"

[case testConstructorAdded]
import m

def f() -> None:
    m.A()
[file m.py]
class A: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "A"

[case testConstructorDeleted]
import m

def f() -> None:
    m.A(1)
[file m.py]
class A:
    def __init__(self, x: int) -> None: pass
[file m.py.2]
class A: pass
[out]
==
main:4: error: Too many arguments for "A"

[case testBaseClassConstructorChanged]
import m

def f() -> None:
    m.B()
[file m.py]
class A:
    def __init__(self) -> None: pass
class B(A): pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
class B(A): pass
[out]
==
main:4: error: Too few arguments for "B"

[case testSuperField]
from a import C
class D(C):
    def g(self) -> int:
        return super().x
[file a.py]
class C:
    def __init__(self) -> None: self.x = 12
[file a.py.2]
class C:
    def __init__(self) -> None: self.x = 'ar'
[out]
==
main:4: error: Incompatible return value type (got "str", expected "int")

[case testImportFrom]
from m import f

def g() -> None:
    f()
[file m.py]
def f() -> None: pass
[file m.py.2]
def f(x: int) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:4: error: Too few arguments for "f"

[case testImportFrom2]
from m import f
f()
[file m.py]
def f() -> None: pass
[file m.py.2]
def f(x: int) -> None: pass
[out]
==
main:2: error: Too few arguments for "f"

[case testImportFromTargetsClass]
from m import C

def f(c: C) -> None:
    c.g()
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
class C:
    def g(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "C"

[case testImportFromTargetsVariable]
from m import x

def f() -> None:
    y = 1
    y = x
[file m.py]
x = 1
[file m.py.2]
x = ''
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testImportFromSubmoduleOfPackage]
from m import n

def f() -> None:
    n.g()
[file m/__init__.py]
[file m/n.py]
def g() -> None: pass
[file m/n.py.2]
def g(x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g"

[case testImportedFunctionGetsImported]
from m import f

def g() -> None:
    f()
[file m.py]
from n import f
[file n.py]
def f() -> None: pass
[file n.py.2]
def f(x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "f"

[case testNestedClassMethodSignatureChanges]
from m import A

def f(x: A.B) -> None:
    x.g()
[file m.py]
class A:
    class B:
        def g(self) -> None: pass
[file m.py.2]
class A:
    class B:
        def g(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "B"

[case testNestedClassAttributeTypeChanges]
from m import A

def f(x: A.B) -> None:
    z = 1
    z = x.y
[file m.py]
class A:
    class B:
        def g(self) -> None:
            self.y = 1
[file m.py.2]
class A:
    class B:
        def g(self) -> None:
            self.y = ''
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testReprocessMethodInNestedClass]
from m import f

class A:
    class B:
        def g(self) -> None:
            x = 1
            x = f()
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[file n.py.3]
[out]
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testReprocessMethodInNestedClassSemanal]
import a
[file a.py]
class A:
    class B:
        def g() -> None: pass
    def foo(self) -> int: return 12
[file b.py.2]
[file b.py.3]
2
[out]
a.py:3: error: Method must have at least one argument
==
a.py:3: error: Method must have at least one argument
==
a.py:3: error: Method must have at least one argument

[case testBaseClassDeleted]
import m

class A(m.C):
    def f(self) -> None:
        self.g()  # No error here because m.C becomes an Any base class
    def g(self) -> None:
        self.x
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
[out]
main:7: error: "A" has no attribute "x"
==
main:3: error: Name 'm.C' is not defined

[case testBaseClassOfNestedClassDeleted]
import m

class A:
    class B(m.C):
        def f(self) -> None:
            self.g()  # No error here because m.C becomes an Any base class
        def g(self) -> None:
            self.x
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
[out]
main:8: error: "B" has no attribute "x"
==
main:4: error: Name 'm.C' is not defined

[case testImportQualifiedModuleName]
import a
[file a.py]
import b.c
b.c.f()
[file a.py.2]
import b.c
b.c.f() # dummy change
[file b/__init__.py]
[file b/c.py]
def f() -> None: pass
[out]
==

[case testTypeAliasRefresh]
from typing import Callable
from a import f
C = Callable[[int], str]
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testTypeVarRefresh]
from typing import TypeVar
from a import f
T = TypeVar('T')
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testNamedTupleRefresh]
from typing import NamedTuple
from a import f
N = NamedTuple('N', [('x', int)])
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testModuleLevelAttributeRefresh]
from typing import Callable
from a import f
x = 1
y = ''  # type: str
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testClassBodyRefresh]
from a import f
class A:
    x = 1
    y = '' # type: str

    def f(self) -> None:
        self.x = 1
[file a.py]
f = 1
[file a.py.2]
[out]
==
main:1: error: Module 'a' has no attribute 'f'

[case testDecoratedMethodRefresh]
from typing import Iterator, Callable, List
from a import f
import a

def dec(f: Callable[['A'], Iterator[int]]) -> Callable[[int], int]: pass

class A:
    @dec
    def f(self) -> Iterator[int]:
        self.x = a.g()  # type: int
        return None
[builtins fixtures/list.pyi]
[file a.py]
f = 1
def g() -> int: pass
[file a.py.2]
def f() -> None: pass
def g() -> int: pass
[file a.py.3]
def f() -> None: pass
def g() -> str: pass
[out]
==
==
main:10: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoPassTypeChecking]
import a
[file a.py]
[file a.py.2]
class A:
    def __init__(self, b: B) -> None:
        self.a = b.a

class B:
    def __init__(self) -> None:
        self.a = int()
[file a.py.3]
class A:
    def __init__(self, b: B) -> None:
        self.a = b.a
        reveal_type(self.a) # E

class B:
    def __init__(self) -> None:
        self.a = int()
[out]
==
==
a.py:4: error: Revealed type is 'builtins.int'

[case testStripRevealType]
import a
reveal_type(a.f())
[file a.py]
def f() -> int: pass
[file a.py.2]
def f() -> str: pass
[out]
main:2: error: Revealed type is 'builtins.int'
==
main:2: error: Revealed type is 'builtins.str'

[case testDecoratorTypeAfterReprocessing]
import a
reveal_type(a.f())
[file a.py]
from contextlib import contextmanager
from typing import Iterator
import b
@contextmanager
def f() -> Iterator[None]:
    yield
[file b.py]
[delete b.py.2]
[file b.py.3]
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[triggered]
2: <b>, __main__
3: <b>, __main__, a
[out]
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'
==
a.py:3: error: Cannot find module named 'b'
a.py:3: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'
==
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'

[case testDecoratorSpecialCase1]
import a
[file a.py]
import contextlib
from typing import List, Iterator

@contextlib.contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield

def g() -> None:
    import b
    b.h(1)
[file b.py]
def h() -> None: pass
[delete b.py.2]
[file b.py.3]
def h() -> None: pass
[file a.py.4]
import contextlib
from typing import List, Iterator

@contextlib.contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield

def g() -> None:
    import b
    b.h(1)
    pass
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[triggered]
2: <b.h>, <b>, <b[wildcard]>, a.g
3: <b.h>, <b>, <b[wildcard]>, a
4: a.g
[out]
a.py:11: error: Too many arguments for "h"
==
a.py:10: error: Cannot find module named 'b'
a.py:10: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
a.py:11: error: Too many arguments for "h"
==
a.py:11: error: Too many arguments for "h"

[case testDecoratorSpecialCase2]
import a
[file a.py]
from contextlib import contextmanager
from typing import Iterator, List
import b

@contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield
[file b.py]
[delete b.py.2]
[file b.py.3]
[file a.py.4]
from contextlib import contextmanager
from typing import Iterator, List
import b

@contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[out]
==
a.py:3: error: Cannot find module named 'b'
a.py:3: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
==

[case testDecoratorMethodCompat]
from typing import Callable, List, TypeVar
import x

class Base: pass
_Base = TypeVar('_Base', bound=Base)

def dec(f: Callable[[_Base], int]) -> Callable[[_Base], List[int]]: pass

class B(Base):
    def foo(self) -> List[int]: pass

class A(B):
    @dec
    def foo(self) -> int:
        x.lol()
        return 12

[file x.py]
def lol() -> str: pass
[file x.py.2]
def lol() -> int: pass
[file x.py.3]
def lol() -> str: pass

[builtins fixtures/list.pyi]
[out]
==
==

[case testPreviousErrorInDecoratedFunction]
import a
[file a.py]
from typing import Callable
import b

def dec(x: Callable[[], None]) -> Callable[[], None]:
    return x

@dec
def f() -> None:
    1 + ''
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import Callable
import b

def dec(f: Callable[[], None]) -> Callable[[], None]:
    return f

@dec
def f() -> None:
    1 + 2
[out]
a.py:9: error: Unsupported operand types for + ("int" and "str")
==
a.py:9: error: Unsupported operand types for + ("int" and "str")
==
a.py:9: error: Unsupported operand types for + ("int" and "str")
==

[case testPreviousErrorInDecoratedMethodOverride]
import a
[file a.py]
from typing import Callable
from b import B

def dec(x: Callable[['A'], int]) -> Callable[['A'], int]:
    return x

class A(B):
    @dec
    def foo(self) -> int: return 12

[file b.py]
class B:
    def foo(self) -> str: return 'hi'
[file c.py.2]
[file c.py.3]
1
[file b.py.4]
class B:
    def foo(self) -> int: return 12
[out]
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==

[case testPreviousErrorInMethodSemanal1]
import a
[file a.py]
class A:
    def foo() -> int: pass
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
class A:
    def foo(self) -> int: pass
[out]
a.py:2: error: Method must have at least one argument
==
a.py:2: error: Method must have at least one argument
==
a.py:2: error: Method must have at least one argument
==

[case testPreviousErrorInMethodSemanal2]
import a
[file a.py]
class A:
    def foo(self) -> None:
        nothing
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
class A:
    def foo(self) -> int: pass
[out]
a.py:3: error: Name 'nothing' is not defined
==
a.py:3: error: Name 'nothing' is not defined
==
a.py:3: error: Name 'nothing' is not defined
==

[case testPreviousErrorInMethodSemanalPass3]
import a
[file a.py]
from typing import List
class A:
    def __init__(self) -> None:
        self.x = []  # type: List[int, str]
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
from typing import List
class A:
    def __init__(self) -> None:
        self.x = []  # type: List[int]
[builtins fixtures/list.pyi]
[out]
a.py:4: error: "list" expects 1 type argument, but 2 given
==
a.py:4: error: "list" expects 1 type argument, but 2 given
==
a.py:4: error: "list" expects 1 type argument, but 2 given
==

[case testPreviousErrorInOverloadedFunctionSemanalPass3]
import a
[file a.py]
from typing import overload, List
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> List[int, str]: ...
def f(x: object) -> object:
    pass
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
from typing import overload, List
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> List[int]: ...
def f(x: object) -> object:
    pass
[builtins fixtures/list.pyi]
[out]
a.py:5: error: "list" expects 1 type argument, but 2 given
==
a.py:5: error: "list" expects 1 type argument, but 2 given
==
a.py:5: error: "list" expects 1 type argument, but 2 given
==

[case testPreviousErrorInOverloadedFunction]
import a
[file a.py]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> int: ...
def f(x: object) -> None:
	pass
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
	pass
[out]
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==

[case testPreviousErrorInOverloadedFunctionSemanal]
import a
[file a.py]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
	pass
[out]
a.py:2: error: An overloaded function outside a stub file must have an implementation
==
a.py:2: error: An overloaded function outside a stub file must have an implementation
==
a.py:2: error: An overloaded function outside a stub file must have an implementation
==

[case testPreviousErrorInDecoratedMethodSemanalPass3]
import a
[file a.py]
from typing import Callable, TypeVar, Any, List

T = TypeVar('T', bound=Callable)
def dec(x: T) -> T:
    return x

@dec
def foo(self) -> List[str, int]: return []

[file c.py.2]
[file c.py.3]
[file a.py.4]
from typing import Callable, TypeVar, Any, List

T = TypeVar('T', bound=Callable[..., Any])
def dec(x: T) -> T:
    return x

@dec
def foo(self) -> List[str]: return []
[builtins fixtures/list.pyi]
[out]
a.py:8: error: "list" expects 1 type argument, but 2 given
==
a.py:8: error: "list" expects 1 type argument, but 2 given
==
a.py:8: error: "list" expects 1 type argument, but 2 given
==

[case testDecoratorUpdateMod]
import a
[file a.py]
import mod

@mod.deca
@mod.decb(mod.C())
def func(x: mod.B) -> mod.B:
    x.x
    return x
[file mod.py]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.2]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[str], str]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.3]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    y: int
[file mod.py.4]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    def __init__(self, x: int) -> None:
        pass
class B:
    x: int
[out]
==
a.py:3: error: Argument 1 to "deca" has incompatible type "Callable[[B], B]"; expected "Callable[[str], str]"
==
a.py:6: error: "B" has no attribute "x"
==
a.py:4: error: Too few arguments for "C"

[case testDecoratorUpdateFunc]
import a
[file a.py]
import mod

def outer() -> None:
    @mod.deca
    @mod.decb(mod.C())
    def func(x: mod.B) -> mod.B:
        x.x
        return x
[file mod.py]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.2]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[str], str]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.3]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    y: int
[file mod.py.4]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[[B], B]) -> Callable[[str], str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    def __init__(self, x: int) -> None:
        pass
class B:
    x: int
[out]
==
a.py:4: error: Argument 1 to "deca" has incompatible type "Callable[[B], B]"; expected "Callable[[str], str]"
==
a.py:7: error: "B" has no attribute "x"
==
a.py:5: error: Too few arguments for "C"

[case DecoratorUpdateMethod]
import a
[file a.py]
import mod

class D:
    @mod.deca
    @mod.decb(mod.C())
    def func(self, x: mod.B) -> mod.B:
        x.x
        return x
[file mod.py]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[..., B]) -> Callable[..., str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.2]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[..., str]) -> Callable[..., str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    x: int
[file mod.py.3]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[..., B]) -> Callable[..., str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    pass
class B:
    y: int
[file mod.py.4]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)

def deca(func: Callable[..., B]) -> Callable[..., str]:
    pass
def decb(arg: C) -> Callable[[F], F]:
    pass
class C:
    def __init__(self, x: int) -> None:
        pass
class B:
    x: int
[out]
==
a.py:4: error: Argument 1 to "deca" has incompatible type "Callable[[D, B], B]"; expected "Callable[..., str]"
==
a.py:7: error: "B" has no attribute "x"
==
a.py:5: error: Too few arguments for "C"

[case testDecoratorUpdateDeeepNested]
import a
[file a.py]
import mod

def outer() -> None:
    def inner() -> None:
        @mod.dec
        def func(x: int) -> int:
            pass
[file mod.py]
from typing import Callable
def dec(func: Callable[[int], int]) -> Callable[[str], str]:
    pass
[file mod.py.2]
from typing import Callable
def dec(func: Callable[[str], str]) -> Callable[[str], str]:
    pass
[out]
==
a.py:5: error: Argument 1 to "dec" has incompatible type "Callable[[int], int]"; expected "Callable[[str], str]"

[case testDecoratorUpdateNestedClass]
import a
[file a.py]
import mod

class Outer:
    class Inner:
        c = mod.C()
        @c.dec
        def func(self, x: int) -> int:
            pass
[file mod.py]
from typing import Callable
class C:
    def dec(self, func: Callable[..., int]) -> Callable[..., str]:
        pass
[file mod.py.2]
from typing import Callable
class C:
    def dec(self, func: Callable[..., str]) -> Callable[..., str]:
        pass
[out]
==
a.py:6: error: Argument 1 to "dec" of "C" has incompatible type "Callable[[Inner, int], int]"; expected "Callable[..., str]"

[case testDecoratorUpdateClassInFunction]
import a
[file a.py]
import mod

def outer() -> None:
    class Inner:
        c = mod.C()
        @c.dec
        def func(self, x: mod.B) -> int:
            return x.x
[file mod.py]
from typing import Callable
class C:
    def dec(self, func: Callable[..., int]) -> Callable[..., str]:
        pass
class B:
    x: int
[file mod.py.2]
from typing import Callable
class C:
    def dec(self, func: Callable[..., str]) -> Callable[..., str]:
        pass
class B:
    x: int
[file mod.py.3]
from typing import Callable
class C:
    def dec(self, func: Callable[..., int]) -> Callable[..., str]:
        pass
class B:
    x: str
[out]
==
a.py:6: error: Argument 1 to "dec" of "C" has incompatible type "Callable[[Inner, B], int]"; expected "Callable[..., str]"
==
a.py:8: error: Incompatible return value type (got "str", expected "int")

[case testDecoratorUpdateMROUpdated]
import a
[file a.py]
import mod

@mod.dec
def func(x: mod.B) -> int:
    pass
[file mod.py]
from typing import Callable
class B:
    pass
class C(B):
    pass
def dec(f: Callable[[C], int]) -> Callable[[int], int]:
    pass
[file mod.py.2]
from typing import Callable
class B:
    pass
class C:
    pass
def dec(f: Callable[[C], int]) -> Callable[[int], int]:
    pass
[out]
==
a.py:3: error: Argument 1 to "dec" has incompatible type "Callable[[B], int]"; expected "Callable[[C], int]"

[case testOverloadRefresh]
from typing import overload
import m

@overload
def f(x: m.A) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
    from n import g
[file m.py]
class A: pass
[file n.py]
def g() -> None: pass
[delete m.py.2]
[delete n.py.2]
[out]
==
main:2: error: Cannot find module named 'm'
main:2: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
main:9: error: Cannot find module named 'n'

[case testOverloadSpecialCase]
from typing import overload
import m
import sys

class C:
    if sys.platform == 'nonexistent':
        def f(self, x): pass
    else:
        @overload
        def f(self, x: m.A) -> None: pass
        @overload
        def f(self, x: int) -> None: pass
        def f(self, x: object) -> None:
            from n import g
[file m.py]
class A: pass
[file n.py]
def g() -> None: pass
[delete m.py.2]
[delete n.py.2]
[builtins fixtures/ops.pyi]
[out]
==
main:2: error: Cannot find module named 'm'
main:2: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
main:14: error: Cannot find module named 'n'

[case testRefreshGenericClass]
from typing import TypeVar, Generic
from a import A

X = TypeVar('X')

class C(Generic[X]):
    def f(self, x: A) -> X: ...
[file a.py]
class A: pass
[file a.py.2]
[file a.py.3]
class A: pass
[out]
==
main:2: error: Module 'a' has no attribute 'A'
==

[case testRefreshGenericAndFailInPass3]
# Failure in semantic analysis pass 3
from a import C
a: C[int]
[file a.py]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]): pass
[file a.py.2]
from typing import TypeVar, Generic
T = TypeVar('T')
S = TypeVar('S')
class C(Generic[T, S]): pass
[file a.py.3]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]): pass
[out]
==
main:3: error: "C" expects 2 type arguments, but 1 given
==

[case testPrintStatement_python2]
# flags: --py2
import a
[file a.py]
def f(x): # type: (int) -> int
    return 1
print f(1)
[file a.py.2]
def f(x): # type: (int) -> int
    return 1
print f('')
[out]
==
a.py:3: error: Argument 1 to "f" has incompatible type "str"; expected "int"

[case testUnannotatedClass]
import a
[file a.py]
class A:
    def f(self, x):
        self.y = x
        self.g()

    def g(self): pass
[file a.py.2]
class A:
    def f(self, x, y):
        self.y = x
        self.z = y
        self.g()

    def g(self): pass
[triggered]
2: <a.A.f>, <a.A.z>, <a.A[wildcard]>
[out]
==

[case testSuperBasics]
import a
[file a.py]
class A:
    def f(self) -> None: pass
class B(A):
    def f(self) -> None:
        super(B, self).f()
[file a.py.2]
class A:
    def f(self) -> None: pass
class B(A):
    def f(self) -> None:
        super(B, self).f()
[out]
==

[case testErrorInTypeCheckSecondPassThroughPropagation]
import a

def f() -> None:
    x = a.C()
[file a.py]
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
class C(Generic[T]): pass
[out]
main:4: error: "object" has no attribute "C"
==
main:4: error: Need type annotation for 'x'

[case testPartialTypeInNestedClass]
import a
class C:
    def f(self) -> None:
        a.g()
        class D:
            def __init__(self) -> None:
                self.x = {}
                self.x['a'] = 'b'
[file a.py]
def g() -> None: pass
[file a.py.2]
def g() -> int: pass
[builtins fixtures/dict.pyi]
[out]
main:7: error: Need type annotation for 'x'
==
main:7: error: Need type annotation for 'x'

[case testRefreshPartialTypeInClass]
import a
class D:
    def __init__(self) -> None:
        a.g()
        self.x = {}
        self.x['a'] = 'b'
[file a.py]
def g() -> None: pass
[file a.py.2]
def g() -> int: pass
[builtins fixtures/dict.pyi]
[out]
main:5: error: Need type annotation for 'x'
==
main:5: error: Need type annotation for 'x'

[case testRefreshTryExcept]
import a
def f() -> None:
    a.g()
    try:
        pass
    except BaseException as e:
        e
[file a.py]
def g() -> int: pass
[file a.py.2]
def g() -> str: pass
[builtins fixtures/exception.pyi]
[out]
==

[case testMroSpecialCase]
import b
import a

[file a.py]
class C: pass
class D(C):
    1()
class E(D): pass

[file b.py]
import a

[file a.py.2]
class C: pass
class D(C):
    1()
class E(D): pass
# Something needs to change

[file b.py.2]
import a
# Something needs to change

[triggered]
2: a, a
[out]
a.py:3: error: "int" not callable
==
a.py:3: error: "int" not callable

[case testMetaclassDefinition_python2]
# flags: --py2
import abc
import m
m.f()

class A:
    __metaclass__ = abc.ABCMeta
[file m.py]
def f(): pass
[file m.py.2]
def f(x=1): pass
[out]
==

[case testMetaclassAttributes]
import a
[file a.py]
from mod import C
from typing import Type
def f(arg: Type[C]) -> None:
    arg.x = int()
[file mod.py]
import submod
class C(metaclass=submod.M):
    pass
[file submod.py]
class M(type):
    x: int
[file submod.py.2]
class M(type):
    x: str
[file submod.py.3]
class M(type):
    y: str
[file submod.py.4]
class M(type):
    x: int
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")
==
a.py:4: error: "Type[C]" has no attribute "x"
==

[case testMetaclassAttributesDirect]
import a
[file a.py]
from mod import C
def f() -> None:
    C.x = int()
[file mod.py]
import submod
class C(metaclass=submod.M):
    pass
[file submod.py]
class M(type):
    x: int
[file submod.py.2]
class M(type):
    x: str
[file submod.py.3]
class M(type):
    y: str
[file submod.py.4]
class M(type):
    x: int
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")
==
a.py:3: error: "Type[C]" has no attribute "x"
==

[case testMetaclassOperators]
import a
[file a.py]
from mod import C
from typing import Type
def f(arg: Type[C]) -> None:
    arg + arg
[file mod.py]
import submod
class C(metaclass=submod.M):
    pass
[file submod.py]
class M(type):
    def __add__(self, other: M) -> M:
        pass
[file submod.py.2]
class M(type):
    def __add__(self, other: int) -> M:
        pass
[out]
==
a.py:4: error: Unsupported operand types for + ("Type[C]" and "Type[C]")

[case testMetaclassOperatorsDirect]
import a
[file a.py]
from mod import C
def f() -> None:
    C + C
[file mod.py]
import submod
class C(metaclass=submod.M):
    pass
[file submod.py]
class M(type):
    def __add__(self, other: int) -> M:
        pass
[file submod.py.2]
class M(type):
    def __add__(self, other: M) -> M:
        pass
[out]
a.py:3: error: Unsupported operand types for + ("Type[C]" and "Type[C]")
==

[case testMetaclassAttributesDirect_python2]
# flags: --py2
import a
[file a.py]
from mod import C
def f():
    # type: () -> None
    C.x = int()
[file mod.py]
import submod
class C:
    __metaclass__ = submod.M
[file submod.py]
class M(type):
    x = None  # type: int
[file submod.py.2]
class M(type):
    x = None  # type: str
[file submod.py.3]
class M(type):
    y = None  # type: str
[file submod.py.4]
class M(type):
    x = None  # type: int
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")
==
a.py:4: error: "Type[C]" has no attribute "x"
==

[case testMetaclassOperators_python2]
# flags: --py2
import a
[file a.py]
from mod import C
from typing import Type
def f(arg):
    # type: (Type[C]) -> None
    arg + arg
[file mod.py]
import submod
class C:
    __metaclass__ = submod.M
[file submod.py]
class M(type):
    def __add__(self, other):
        # type: (M) -> M
        pass
[file submod.py.2]
class M(type):
    def __add__(self, other):
        # type: (int) -> M
        pass
[out]
==
a.py:5: error: Unsupported operand types for + ("Type[C]" and "Type[C]")

[case testFineMetaclassUpdate]
import a
[file a.py]
from c import M
import b
def f(arg: M) -> None:
    pass

f(b.B)
[file b.py]
import c
class B: pass

[file b.py.2]
import c
class B(metaclass=c.M): pass

[file c.py]
class M(type):
    pass
[out]
a.py:6: error: Argument 1 to "f" has incompatible type "Type[B]"; expected "M"
==

[case testFineMetaclassRecalculation]
import a
[file a.py]
from b import B
class M2(type): pass
class D(B, metaclass=M2): pass
[file b.py]
import c
class B: pass

[file b.py.2]
import c
class B(metaclass=c.M): pass

[file c.py]
class M(type):
    pass
[out]
==
a.py:3: error: Inconsistent metaclass structure for 'D'

[case testFineMetaclassDeclaredUpdate]
import a
[file a.py]
import b
class B(metaclass=b.M): pass
class D(B, metaclass=b.M2): pass
[file b.py]
class M(type): pass
class M2(M): pass
[file b.py.2]
class M(type): pass
class M2(type): pass
[out]
==
a.py:3: error: Inconsistent metaclass structure for 'D'

[case testFineMetaclassRemoveFromClass]
import a
[file a.py]
import b
def func() -> int:
    return b.B.x
[file b.py]
from c import M
class B(metaclass=M):
    pass
[file b.py.2]
from c import M
class B:
    pass
[file c.py]
class M(type):
    x: int
[out]
==
a.py:3: error: "Type[B]" has no attribute "x"

[case testFineMetaclassRemoveFromClass2]
import a
[file a.py]
import b
def func() -> None:
    b.test(b.B)
[file b.py]
import c
def test(cls: c.M) -> None:
    pass
class B(metaclass=c.M):
    pass
[file b.py.2]
import c
def test(cls: c.M) -> None:
    pass
class B:
    pass
[file c.py]
class M(type):
    x: int
[out]
==
a.py:3: error: Argument 1 to "test" has incompatible type "Type[B]"; expected "M"

[case testBadMetaclassCorrected]
import a
[file a.py]
import b
class C(metaclass=b.M):
    pass
[file b.py]
from c import M
[file c.py]
M = 1
[file c.py.2]
class M(type):
    pass
[out]
a.py:2: error: Invalid metaclass 'b.M'
==

[case testFixedAttrOnAddedMetaclass]
import a
[file a.py]
import b
def fun() -> None:
    x: int = b.C.x
[file b.py]
import c
class C:
    pass
[file b.py.2]
import c
class C(metaclass=c.M):
    pass
[file c.py]
class M(type):
    x: int
[out]
a.py:3: error: "Type[C]" has no attribute "x"
==

[case testIndirectSubclassReferenceMetaclass]
import a
[file a.py]
import b
def f() -> None:
    b.x = int()
[file b.py]
import bb
x = bb.D.x
[file bb.py]
import mod
class D(mod.C):
    pass
[file mod.py]
import submod
class C(metaclass=submod.M):
    pass
[file submod.py]
class M(type):
    x: int
[file submod.py.2]
class M(type):
    x: str
[file submod.py.3]
class M(type):
    y: str
[file submod.py.4]
class M(type):
    x: int
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")
==
b.py:2: error: "Type[D]" has no attribute "x"
==

[case testMetaclassDeletion]
import a
[file a.py]
import b
def func() -> None:
    b.B.x
[file b.py]
import c
class B(metaclass=c.M):
    pass
[file c.py]
class M(type):
    x: int
[file c.py.2]
whatever: int
[out]
==
b.py:2: error: Name 'c.M' is not defined
a.py:3: error: "Type[B]" has no attribute "x"

[case testFixMissingMetaclass]
import a
[file a.py]
import b
def func() -> None:
    b.B.x
[file b.py]
import c
class B(metaclass=c.M):
    pass
[file c.py]
whatever: int
[file c.py.2]
class M(type):
    x: int
[out]
b.py:2: error: Name 'c.M' is not defined
a.py:3: error: "Type[B]" has no attribute "x"
==

[case testGoodMetaclassSpoiled]
import a
[file a.py]
import b
class C(metaclass=b.M):
    pass
[file b.py]
class M(type):
    pass
[file b.py.2]
M = 1
[out]
==
a.py:2: error: Invalid metaclass 'b.M'

[case testRefreshGenericSubclass]
from typing import Generic, TypeVar
import m
m.x

T = TypeVar('T')

class C(Generic[T]):
    def __init__(self, x: T) -> None:
        pass

class D(C[T]):
    def __init__(self, x: T) -> None:
        m.x
        super(D, self).__init__(x)
[file m.py]
x = 0
[file m.py.2]
x = ''
[out]
==

[case testRefreshNamedTupleSubclass]
from typing import NamedTuple
import m
m.x

N = NamedTuple('N', [('x', int)])

class C(N):
    pass
[file m.py]
x = 0
[file m.py.2]
x = ''
[out]
==

[case testNewTypeRefresh]
import a

[file a.py]
from typing import Dict, NewType

class A: pass
N = NewType('N', A)

a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[file a.py.2]
from typing import Dict, NewType  # dummy change

class A: pass
N = NewType('N', A)

a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[builtins fixtures/dict.pyi]
[out]
==

[case testRefreshFunctionalEnum]
import a

[file a.py]
from typing import Dict
from enum import Enum

N = Enum('N', 'x')
a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[file a.py.2]
from typing import Dict
from enum import Enum

N = Enum('N', 'x')
a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)
[builtins fixtures/dict.pyi]
[out]
==

[case testFineGrainedCallable]
import a
[file a.py]
def f(o: object) -> None:
    if callable(o):
        o()
[file a.py.2]
def f(o: object) -> None:
    if callable(o):
        o()
[builtins fixtures/callable.pyi]
[out]
==

[case testRefreshFunctionalNamedTuple]
import a

[file a.py]
from typing import NamedTuple
from b import L

A = NamedTuple('A', [])
a: A

def g() -> None:
    x = L(A())
    x.f(a)

[file b.pyi]
from typing import TypeVar, Generic, overload

T = TypeVar('T')

class L(Generic[T]):
    def __init__(self, x: T) -> None: pass
    @overload
    def f(self) -> None: pass
    @overload
    def f(self, a: T) -> None: pass

[file a.py.2]
from typing import NamedTuple
from b import L

A = NamedTuple('A', [])
a: A

def g() -> None:
    x = L(A())
    x.f(a)
[out]
==

[case testRefreshSubclassNestedInFunction1]
from a import C
def f() -> None:
    class D(C): pass
[file a.py]
class C: pass
[file a.py.2]
[out]
==
main:1: error: Module 'a' has no attribute 'C'

[case testRefreshSubclassNestedInFunction2]
from a import C
def f() -> None:
    class D(C):
        def g(self) -> None:
            super().__init__()
    d = D()
[file a.py]
class C:
    def __init__(self) -> None: pass
[file a.py.2]
class C:
    def __init__(self, x: int) -> None: pass
[out]
==
main:5: error: Too few arguments for "__init__" of "C"
main:6: error: Too few arguments for "D"

[case testInferAttributeTypeAndMultipleStaleTargets]
import a

class A:
    def g(self) -> None:
        a.x
        self.x = 1

    def f(self) -> None:
        a.x
        b = self.x
        self.x = 1

[file a.py]
x = 0
[file a.py.2]
x = ''
[out]
==

[case testNamedTupleUpdate]
import b
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('x', str)])
x = N('hi')
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testNamedTupleUpdate2]
import b
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('y', int)])
x = N(2)
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testNamedTupleUpdate3]
import c
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('x', str)])
x = N('hi')
[file b.py]
import a
from typing import NamedTuple
M = NamedTuple('M', [('z', 'a.N')])
x = M(a.x)
[file c.py]
import a
import b
from typing import Tuple
def lol(n: Tuple[Tuple[int]]) -> None:
    pass
def f(x: b.M) -> None:
    lol(x)
f(b.x)
lol(b.x)
[out]
==
c.py:7: error: Argument 1 to "lol" has incompatible type "M"; expected "Tuple[Tuple[int]]"
c.py:9: error: Argument 1 to "lol" has incompatible type "M"; expected "Tuple[Tuple[int]]"

[case testNamedTupleUpdate4]
import b
[file a.py]
from typing import NamedTuple
class N(NamedTuple):
    x: int
x = N(1)
[file a.py.2]
from typing import NamedTuple
class N(NamedTuple):
    x: str
x = N('hi')
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testTypedDictRefresh]
[builtins fixtures/dict.pyi]
import a
[file a.py]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337)) # dummy change
[out]
==

[case testTypedDictUpdate]
import b
[file a.py]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': str})
p = Point(dict(x=42, y='lurr'))
[file b.py]
from a import Point
def foo(x: Point) -> int:
    return x['x'] + x['y']
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Unsupported operand types for + ("int" and "str")

[case testTypedDictUpdate2]
import b
[file a.py]
from mypy_extensions import TypedDict
class Point(TypedDict):
    x: int
    y: int
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
class Point(TypedDict):
    x: int
    y: str
p = Point(dict(x=42, y='lurr'))
[file b.py]
from a import Point
def foo(x: Point) -> int:
    return x['x'] + x['y']
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Unsupported operand types for + ("int" and "str")

[case testBasicAliasUpdate]
import b
[file a.py]
N = int
x = 1
[file a.py.2]
N = str
x = 'hi'
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testBasicAliasUpdateGeneric]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
D = Dict[int, T]
x = {1: 1}
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
D = Dict[str, T]
x = {'hi': 1}
[file b.py]
import a
def f(x: a.D[int]) -> None:
    pass
f(a.x)
[builtins fixtures/dict.pyi]
[out]
==

[case testAliasFineNormalMod]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
x: a.A = int()
[out]
==
b.py:2: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalFunc]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
def f(x: a.A):
    x = int()
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalClass]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
class C:
    x: a.A
c = C()
c.x = int()
[out]
==
b.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalClassBases]
import b
[file a.py]
import c
A = c.BaseI
[file a.py.2]
import c
A = c.BaseS
[file b.py]
import a
class C(a.A):
    x = int()
[file c.py]
class BaseI:
    x: int
class BaseS:
    x: str
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", base class "BaseS" defined the type as "str")

[case testAliasFineGenericMod]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file b.py]
import a
x: a.A = {str(): int()}
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineGenericFunc]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file b.py]
import a
def f(x: a.A):
    pass
f({str(): int()})
[builtins fixtures/dict.pyi]
[out]
==
b.py:4: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineForwardMod]
import b
[file b.py]
x: A = int()
A = int
[file b.py.2]
x: A = int()
A = str
[out]
==
b.py:1: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineForwardFunc]
import b
[file b.py]
def f(x: A):
    x = int()
A = int
[file b.py.2]
def f(x: A):
    x = int()
A = str
[out]
==
b.py:2: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineChainedFunc]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file aa.py]
import a
B = a.A
[file b.py]
import aa
def f(x: aa.B):
    x = int()
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineChainedClass]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file aa.py]
import a
B = a.A
[file b.py]
import aa
class C:
    x: aa.B
c = C()
c.x = int()
[out]
==
b.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNestedMod]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
B = Dict[str, a.A]
[file b.py]
import aa
x: aa.B = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNestedFunc]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
B = Dict[str, a.A]
[file b.py]
import aa
def f(x: aa.B):
    x = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNestedFuncDirect]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
E = Dict
[file b.py]
import aa
def f(x: aa.E[str, aa.a.A]):
    x = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNonGenericToGeneric]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file a.py.2]
A = str
[file b.py]
import a
def f(x: a.A[str]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: "str" expects no type arguments, but 1 given

[case testAliasFineGenericToNonGeneric]
import b
[file a.py]
A = str
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file b.py]
import a
def f(x: a.A):
    pass
reveal_type(f)
[builtins fixtures/dict.pyi]
[out]
b.py:4: error: Revealed type is 'def (x: builtins.str) -> Any'
==
b.py:4: error: Revealed type is 'def (x: builtins.dict[Any, builtins.int]) -> Any'

[case testAliasFineChangedNumberOfTypeVars]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
S = TypeVar('S')
A = Dict[T, S]
[file b.py]
import a
def f(x: a.A[str]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Bad number of arguments for type alias, expected: 2, given: 1

[case testAliasFineAdded]
import b
[file a.py]
[file a.py.2]
A = int
[file b.py]
import a
x: a.A
[out]
b.py:2: error: Name 'a.A' is not defined
==

[case testAliasFineDeleted]
import b
[file a.py]
A = int
[file a.py.2]
[file b.py]
import a
x: a.A
[out]
==
b.py:2: error: Name 'a.A' is not defined

[case testAliasFineClassToAlias]
import b
[file a.py]
class A: pass
[file a.py.2]
A = int
[file b.py]
import a
x: a.A
x = 1
[out]
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "A")
==

[case testAliasFineAliasToClass]
import b
[file a.py]
A = int
[file a.py.2]
class A: pass
[file b.py]
import a
x: a.A
x = 1
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "A")

[case testAliasFineComponentDeleted]
import b
[file a.py]
class B: pass
[file a.py.2]
x = 1
[file b.py]
import a
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, a.B]
def f(x: A[int]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:4: error: Name 'a.B' is not defined

[case testAliasFineTargetDeleted]
import c
[file a.py]
A = int
[file b.py]
import a
B = a.A
[file b.py.2]
x = 1
[file c.py]
import b
def f(x: b.B):
    pass
[out]
==
c.py:2: error: Name 'b.B' is not defined

[case testAliasFineClassInFunction]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
def f() -> None:
    class C:
        x: a.A = int()
[out]
==
b.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineInitNormalMod]
import c
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
from b import B
B(int())
[out]
==
c.py:2: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitNormalFunc]
import c
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
from b import B
def f() -> None:
    B(int())
[out]
==
c.py:3: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitGenericMod]
import c
[file a.py]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: T) -> None:
        pass
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: S) -> None:
        pass
[file b.py]
import a
B = a.A[int, str]
[file c.py]
from b import B
B(int())
[out]
==
c.py:2: error: Argument 1 has incompatible type "int"; expected "str"

[case testAliasFineInitGenericFunc]
import c
[file a.py]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: T) -> None:
        pass
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: S) -> None:
        pass
[file b.py]
import a
B = a.A[int, str]
[file c.py]
from b import B
def f() -> None:
    B(str())
[out]
c.py:3: error: Argument 1 has incompatible type "str"; expected "int"
==

[case testAliasFineInitChainedMod]
import d
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
import b
C = b.B
[file d.py]
from c import C
C(int())
[out]
==
d.py:2: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitChainedFunc]
import d
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
import b
C = b.B
[file d.py]
from c import C
def f() -> None:
    C(str())
[out]
d.py:3: error: Argument 1 to "A" has incompatible type "str"; expected "int"
==

[case testNonePartialType1]
import a
a.y

x = None

def f() -> None:
    global x
    x = 1
[file a.py]
y = 0
[file a.py.2]
y = ''
[out]
main:4: error: Need type annotation for 'x'
==
main:4: error: Need type annotation for 'x'

[case testNonePartialType2]
import a
a.y

x = None

def f():
    global x
    x = 1
[file a.py]
y = 0
[file a.py.2]
y = ''
[out]
main:4: error: Need type annotation for 'x'
==
main:4: error: Need type annotation for 'x'

[case testNonePartialType3]
import a
[file a.py]
[file a.py.2]
y = None
def f() -> None:
    global y
    y = ''
[out]
==
a.py:1: error: Need type annotation for 'y'

[case testNonePartialType4]
import a
[file a.py]
y = None
def f() -> None:
    global y
    y = ''
[file a.py.2]
from typing import Optional
y: Optional[str] = None
def f() -> None:
    global y
    y = ''
[out]
a.py:1: error: Need type annotation for 'y'
==

[case testSkippedClass1]
import a
[file a.py]
class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass2]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass3]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
[file a.py.2]
class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass4]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
else:
    class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
else:
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testNewTypeDependencies1]
from a import N

def f(x: N) -> None:
    x.y = 1
[file a.py]
from typing import NewType
from b import C

N = NewType('N', C)
[file b.py]
class C:
    y: int
[file b.py.2]
class C:
    y: str
[out]
==
main:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testNewTypeDependencies2]
from a import N
from b import C, D

def f(x: C) -> None: pass

def g(x: N) -> None:
    f(x)
[file a.py]
from typing import NewType
from b import D

N = NewType('N', D)
[file b.py]
class C: pass
class D(C): pass
[file b.py.2]
class C: pass
class D: pass
[out]
==
main:7: error: Argument 1 to "f" has incompatible type "N"; expected "C"

[case testNewTypeDependencies3]
from a import N

def f(x: N) -> None:
    x.y
[file a.py]
from typing import NewType
from b import C
N = NewType('N', C)
[file a.py.2]
from typing import NewType
from b import D
N = NewType('N', D)
[file b.py]
class C:
    y: int
class D:
    pass
[out]
==
main:4: error: "N" has no attribute "y"

[case testNamedTupleWithinFunction]
from typing import NamedTuple
import b
def f() -> None:
    b.x
    n = NamedTuple('n', [])
[file b.py]
x = 0
[file b.py.2]
x = ''
[out]
==

[case testNamedTupleFallback]
# This test will fail without semantic analyzer pass 2 patches
import a
[file a.py]
import b
[file b.py]
from typing import NamedTuple
import c
c.x
class N(NamedTuple):
    count: int
[file c.py]
x = 0
[file c.py.2]
x = ''
[builtins fixtures/tuple.pyi]
[out]
b.py:5: error: Incompatible types in assignment (expression has type "int", base class "tuple" defined the type as "Callable[[Tuple[int, ...], Any], int]")
==
b.py:5: error: Incompatible types in assignment (expression has type "int", base class "tuple" defined the type as "Callable[[Tuple[int, ...], Any], int]")

[case testReprocessEllipses1]
import a
[file a.py]
from typing import Tuple
def foo(x: Tuple[int, ...]) -> None: pass
[file a.py.2]
from typing import Tuple
def foo(x: Tuple[int, ...]) -> None: pass
[builtins fixtures/tuple.pyi]
[out]
==

[case testReprocessEllipses2]
import a
[file a.py]
from typing import Callable
def foo(x: Callable[..., int]) -> None: pass
[file a.py.2]
from typing import Callable
def foo(x: Callable[..., int]) -> None: pass
[out]
==

[case testReprocessCallableArg]
import a
[file a.py]
from typing import Callable
from mypy_extensions import Arg
def a(f: Callable[[Arg(int, 'x')], int]) -> None: pass
[file a.py.2]
from typing import Callable
from mypy_extensions import Arg
def a(f: Callable[[Arg(int, 'x')], int]) -> None: pass
[builtins fixtures/dict.pyi]
[out]
==

[case testImplicitTuple1]
import a
[file a.py]
# Bogus annotation in nested function masked because outer function
# isn't annotated
def unchecked():
    def inner():
        # type: () -> (str, int)
        return 'lol', 10
[file a.py.2]
# dummy change
def unchecked():
    def inner():
        # type: () -> (str, int)
        return 'lol', 10
[out]
==

[case testImplicitTuple2]
import a
[file a.py]
def inner():
    # type: () -> (str, int)
    return 'lol', 10
[file a.py.2]
# dummy change
def inner():
    # type: () -> (str, int)
    return 'lol', 10
[out]
a.py:1: error: Syntax error in type annotation
a.py:1: note: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)
==
a.py:2: error: Syntax error in type annotation
a.py:2: note: Suggestion: Use Tuple[T1, ..., Tn] instead of (T1, ..., Tn)

[case testImplicitTuple3]
import a
[file a.py]
(x, y) = 1, 'hi'  # type: (int, str)
[file a.py.2]
# dummy change
(x, y) = 1, 'hi'  # type: (int, str)
[out]
==

[case testCastConfusion]
import b
[file a.py]
from typing import cast
class Thing:
    def foo(self) -> None: pass

thing = cast(Thing, Thing())

[file b.py]
from typing import Optional
from a import Thing, thing
class User:
    def __init__(self, x: Optional[Thing]) -> None:
        self.x = x if x else thing
    def use(self) -> None: self.x.foo()

[file a.py.2]
from typing import cast
class Thing:
    def foo(self) -> None: pass

thing = cast(Thing, Thing())
# update

[file b.py.2]
from typing import Optional
from a import Thing, thing
class User:
    def __init__(self, x: Optional[Thing]) -> None:
        self.x = x if x else thing
    def use(self) -> None: self.x.foo()
# update
[builtins fixtures/ops.pyi]
[out]
==

[case testNoStrictOptionalModule]
import a
a.y = a.x
[file a.py]
from typing import Optional
x: int
y: int
[file a.py.2]
from typing import Optional
x: Optional[int]
y: int
[file a.py.3]
from typing import Optional
x: Optional[str]
y: int
[out]
==
==
main:2: error: Incompatible types in assignment (expression has type "Optional[str]", variable has type "int")

[case testNoStrictOptionalFunction]
import a
from typing import Optional
def f() -> None:
    x: Optional[int]
    a.g(x)
[file a.py]
from typing import Optional
def g(x: Optional[int]) -> None:
    pass
[file a.py.2]
from typing import Optional
def g(x: int) -> None:
    pass
[file a.py.3]
from typing import Optional
def g(x: str) -> None:
    pass
[out]
==
==
main:5: error: Argument 1 to "g" has incompatible type "Optional[int]"; expected "str"

[case testNoStrictOptionalMethod]
import a
from typing import Optional
class C:
    def f(self) -> None:
        x: Optional[int]
        a.B().g(x)
[file a.py]
from typing import Optional
class B:
    def g(self, x: Optional[int]) -> None:
        pass
[file a.py.2]
from typing import Optional
class B:
    def g(self, x: int) -> None:
        pass
[file a.py.3]
from typing import Optional
class B:
    def g(self, x: str) -> None:
        pass
[out]
==
==
main:6: error: Argument 1 to "g" of "B" has incompatible type "Optional[int]"; expected "str"

[case testStrictOptionalModule]
# flags: --strict-optional
import a
a.y = a.x
[file a.py]
from typing import Optional
x: int
y: int
[file a.py.2]
from typing import Optional
x: Optional[int]
y: int
[out]
==
main:3: error: Incompatible types in assignment (expression has type "Optional[int]", variable has type "int")

[case testStrictOptionalFunction]
# flags: --strict-optional
import a
from typing import Optional
def f() -> None:
    x: Optional[int]
    a.g(x)
[file a.py]
from typing import Optional
def g(x: Optional[int]) -> None:
    pass
[file a.py.2]
from typing import Optional
def g(x: int) -> None:
    pass
[out]
==
main:6: error: Argument 1 to "g" has incompatible type "Optional[int]"; expected "int"

[case testStrictOptionalMethod]
# flags: --strict-optional
import a
from typing import Optional
class C:
    def f(self) -> None:
        x: Optional[int]
        a.B().g(x)
[file a.py]
from typing import Optional
class B:
    def g(self, x: Optional[int]) -> None:
        pass
[file a.py.2]
from typing import Optional
class B:
    def g(self, x: int) -> None:
        pass
[out]
==
main:7: error: Argument 1 to "g" of "B" has incompatible type "Optional[int]"; expected "int"

[case testPerFileStrictOptionalModule]
import a
[file mypy.ini]
[[mypy]
strict_optional = False
[[mypy-a.*]
strict_optional = True
[file a.py]
from typing import Optional
import b
x: int
y: int = x
[file b.py]
from typing import Optional
x: int
y: int = x
[file b.py.2]
from typing import Optional
x: Optional[int]
y: int = x
[file a.py.3]
from typing import Optional
import b
x: Optional[int]
y: int = x
[out]
==
==
a.py:4: error: Incompatible types in assignment (expression has type "Optional[int]", variable has type "int")

[case testPerFileStrictOptionalModuleOnly]
import a
[file mypy.ini]
[[mypy]
strict_optional = False
[[mypy-a.*]
strict_optional = True
[file a.py]
from typing import Optional
import b
y: int = b.x
class Dummy:
    def f(self) -> None:
        pass
[file b.py]
from typing import Optional
import c
x: int
y: int = c.x
class Dummy:
    def f(self) -> None:
        pass
[file c.py]
from typing import Optional
x: int
[file c.py.2]
from typing import Optional
x: Optional[int]
[file b.py.3]
from typing import Optional
import c
x: Optional[int]
y: int = c.x
[file a.py.4]
from typing import Optional
import b
y: Optional[int] = b.x
class Dummy:
    def f(self) -> None:
        pass
[out]
==
==
a.py:3: error: Incompatible types in assignment (expression has type "Optional[int]", variable has type "int")
==

[case testPerFileStrictOptionalFunction]
import a
[file mypy.ini]
[[mypy]
strict_optional = False
[[mypy-b.*]
strict_optional = True
[file a.py]
from typing import Optional
import b
def f() -> None:
    x: int
    x = b.g(x)
[file b.py]
from typing import Optional
import c
def g(x: Optional[int]) -> Optional[int]:
    return c.h(x)
[file c.py]
from typing import Optional
def h(x: Optional[int]) -> int:
    pass
[file c.py.2]
from typing import Optional
def h(x: int) -> int:
    pass
[file b.py.3]
from typing import Optional
import c
def g(x: int) -> Optional[int]:
    return c.h(x)
[out]
==
b.py:4: error: Argument 1 to "h" has incompatible type "Optional[int]"; expected "int"
==

[case testPerFileStrictOptionalMethod]
import a
[file mypy.ini]
[[mypy]
strict_optional = False
[[mypy-b.*]
strict_optional = True
[file a.py]
from typing import Optional
import b
class A:
    def f(self) -> None:
        x: int
        x = b.B().g(x)
[file b.py]
from typing import Optional
import c
class B:
    def g(self, x: Optional[int]) -> Optional[int]:
        return c.C().h(x)
[file c.py]
from typing import Optional
class C:
    def h(self, x: Optional[int]) -> int:
        pass
[file c.py.2]
from typing import Optional
class C:
    def h(self, x: int) -> int:
        pass
[file b.py.3]
from typing import Optional
import c
class B:
    def g(self, x: int) -> Optional[int]:
        return c.C().h(x)
[out]
==
b.py:5: error: Argument 1 to "h" of "C" has incompatible type "Optional[int]"; expected "int"
==

[case testTypeVarValuesFunction]
import a
[file a.py]
from typing import TypeVar
from c import A, B
T = TypeVar('T', A, B)

def f(x: T) -> T:
    x.x = int()
    return x
[file c.py]
class A:
    x: int
class B:
    x: int
[file c.py.2]
class A:
    x: int
class B:
    x: str
[out]
==
a.py:6: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testTypeVarValuesClass]
import a
[file a.py]
import c
class C:
    x: c.D[c.A]
[file c.py]
from typing import TypeVar, Generic
class A: pass
class B: pass
class C: pass
T = TypeVar('T', A, B, C)
class D(Generic[T]):
    pass
[file c.py.2]
from typing import TypeVar, Generic
class A: pass
class B: pass
class C: pass
T = TypeVar('T', B, C)
class D(Generic[T]):
    pass
[out]
==
a.py:3: error: Value of type variable "T" of "D" cannot be "A"

[case testTypeVarValuesMethod1]
import a
[file a.py]
from typing import Generic
import c
class G(Generic[c.T]):
    def f(self, x: c.T) -> None:
        x.x = int()
[file c.py]
from typing import TypeVar
class A:
    x: int
class B:
    x: int
class C:
    x: str
T = TypeVar('T', A, B, C)
[file c.py.2]
from typing import TypeVar
class A:
    x: int
class B:
    x: int
class C:
    x: str
T = TypeVar('T', A, B)
[out]
a.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")
==

[case testTypeVarValuesMethod2]
import a
[file a.py]
from typing import Generic
import c
class G(Generic[c.T]):
    def f(self, x: c.T) -> None:
        x.x = int()
[file c.py]
from typing import TypeVar
class A:
    x: int
class B:
    x: int
T = TypeVar('T', A, B)
[file c.py.2]
from typing import TypeVar
class A:
    x: int
class B:
    x: str
T = TypeVar('T', A, B)
[out]
==
a.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testTypeVarBoundFunction]
import a
[file a.py]
from typing import TypeVar
from c import B
T = TypeVar('T', bound=B)

def f(x: T) -> T:
    x.x = int()
    return x
[file c.py]
class B:
    x: int
[file c.py.2]
class B:
    x: str
[out]
==
a.py:6: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testTypeVarBoundClass]
import a
[file a.py]
import c
class C:
    x: c.D[c.A]
[file c.py]
from typing import TypeVar, Generic
class A: pass
class B: pass
T = TypeVar('T', bound=A)
class D(Generic[T]):
    pass
[file c.py.2]
from typing import TypeVar, Generic
class A: pass
class B: pass
T = TypeVar('T', bound=B)
class D(Generic[T]):
    pass
[out]
==
a.py:3: error: Type argument "c.A" of "D" must be a subtype of "c.B"

[case testTypeVarValuesRuntime]
from mod import I, S, D
A = I
x = D[S, A]()
[file mod.py]
import submod
from typing import Generic
class D(Generic[submod.T, submod.U]): pass
class I: pass
class S: pass
[file submod.py]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
[file submod.py.2]
from typing import TypeVar
T = TypeVar('T', int, str)
U = TypeVar('U', int, str)
[out]
==
main:3: error: Value of type variable "submod.T" of "D" cannot be "S"
main:3: error: Value of type variable "submod.U" of "D" cannot be "I"

[case testTypeVarBoundRuntime]
from mod import I, S, D
A = I
x = D[S, A]()
[file mod.py]
import submod
from typing import Generic
class D(Generic[submod.T, submod.U]): pass
class I: pass
class S: pass
[file submod.py]
from typing import TypeVar
T = TypeVar('T', bound=int)
U = TypeVar('U', bound=int)
[file submod.py.2]
from typing import TypeVar
T = TypeVar('T')
U = TypeVar('U')
[out]
main:3: error: Value of type variable "submod.T" of "D" cannot be "S"
main:3: error: Value of type variable "submod.U" of "D" cannot be "I"
==

[case testGenericFineCallableNormal]
import a
[file a.py]
import b
x: int = b.f(int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar
class B: pass
T = TypeVar('T')
def g(x: T) -> T:
    pass
[file c.py.2]
from typing import TypeVar
class B: pass
T = TypeVar('T', str, B)
def g(x: T) -> T:
    pass
[out]
==
a.py:2: error: Value of type variable "T" of function cannot be "int"

[case testGenericFineCallableNamed]
import a
[file a.py]
import b
x: int = b.f(x=int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar
class B: pass
T = TypeVar('T')
def g(x: T) -> T:
    pass
[file c.py.2]
from typing import TypeVar
class B: pass
T = TypeVar('T')
def g(y: T) -> T:
    pass
[out]
==
a.py:2: error: Unexpected keyword argument "x"
c.py:4: note: Called function defined here

[case testGenericFineCallableInBound]
import a
[file a.py]
import b
x: int = b.f()(int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import Callable, TypeVar
class B: pass
T = TypeVar('T')
def g() -> Callable[[T], T]:
    pass
[file c.py.2]
from typing import Callable, TypeVar
class B: pass
T = TypeVar('T', str, B)
def g() -> Callable[[T], T]:
    pass
[out]
==
a.py:2: error: Value of type variable "T" of function cannot be "int"

[case testGenericFineCallableAddedBound]
import a
[file a.py]
import b
x: int = b.f(int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar
class B: pass
T = TypeVar('T')
def g(x: T) -> T:
    pass
[file c.py.2]
from typing import TypeVar
class B: pass
T = TypeVar('T', bound=B)
def g(x: T) -> T:
    pass
[out]
==
a.py:2: error: Value of type variable "T" of function cannot be "int"

[case testGenericFineCallableBoundDeleted-skip-nocache]
# See https://github.com/python/mypy/issues/4783
import a
[file a.py]
import b
x: int = b.f(int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar
import d
T = TypeVar('T', bound=d.B)
def g(x: T) -> T:
    pass
[file d.py]
class B:
    pass
[file d.py.2]
# empty
[out]
a.py:2: error: Value of type variable "T" of function cannot be "int"
==
c.py:3: error: Name 'd.B' is not defined

[case testGenericFineCallableToNonGeneric]
import a
[file a.py]
import b
x: int = b.f(x=int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar
T = TypeVar('T')
def g(x: T) -> T:
    pass
[file c.py.2]
from typing import TypeVar
class T: pass
def g(x: T) -> T:
    pass
[out]
==
a.py:2: error: Incompatible types in assignment (expression has type "T", variable has type "int")
a.py:2: error: Argument "x" has incompatible type "int"; expected "T"

[case testGenericFineCallableToGenericClass]
import a
[file a.py]
import b
x: int = b.f(x=int())
[file b.py]
from c import g
f = g
[file c.py]
from typing import TypeVar, Generic
T = TypeVar('T')
def g(x: T) -> T:
    pass
[file c.py.2]
from typing import TypeVar, Generic
T = TypeVar('T')
class g(Generic[T]):
    def __init__(self, x: T) -> None:
        pass
[out]
==
a.py:2: error: Incompatible types in assignment (expression has type "g[int]", variable has type "int")

[case testMakeClassNoLongerAbstract1]
[file z.py]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self) -> None: pass
[file b.py]
from z import I
class Foo(I):
    pass
def x() -> Foo: return None
[file z.py.2]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    pass
[file b.py.2]
from z import I
class Foo(I):
    pass
def x() -> Foo: return Foo()
[out]
==

[case testMakeClassNoLongerAbstract2]
-- this version never failed, but it is just a file-renaming
-- away from the above test that did
[file a.py]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self) -> None: pass
[file b.py]
from a import I
class Foo(I):
    pass
def x() -> Foo: return None
[file a.py.2]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    pass
[file b.py.2]
from a import I
class Foo(I):
    pass
def x() -> Foo: return Foo()
[out]
==

[case testRefreshClassBasedEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import Enum
import b
b.x
class C(Enum):
    X = 0
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testRefreshClassBasedIntEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import IntEnum
import b
b.x
class C(IntEnum):
    X = 0
x: int
x = C.X
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
n: int
n = C.X
n = c
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testClassBasedEnumPropagation1]
import a
[file a.py]
from b import C

def f(x: C) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
from enum import Enum

class C(Enum):
    X = 0
    Y = 1
[file b.py.2]
from enum import Enum

class C(Enum):
    X = 0
[out]
==
a.py:5: error: "Type[C]" has no attribute "Y"

[case testClassBasedEnumPropagation2]
import a
[file a.py]
from b import C

def f(x: int) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
class C:
    X = 0
    Y = 1
[file b.py.2]
from enum import Enum
class C(Enum):
    X = 0
    Y = 1
[out]
==
a.py:4: error: Argument 1 to "f" has incompatible type "C"; expected "int"
a.py:5: error: Argument 1 to "f" has incompatible type "C"; expected "int"

[case testRefreshFuncBasedEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import Enum
import b
b.x
C = Enum('C', [('X', 0)])
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testRefreshFuncBasedIntEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import IntEnum
import b
b.x
C = IntEnum('C', 'X')
x: int
x = C.X
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
n: int
n = C.X
n = c
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testFuncBasedEnumPropagation1]
import a
[file a.py]
from b import C

def f(x: C) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
from enum import Enum

C = Enum('C', 'X Y')
[file b.py.2]
from enum import Enum

C = Enum('C', 'X')
[out]
==
a.py:5: error: "Type[C]" has no attribute "Y"

[case testFuncBasedEnumPropagation2]
import a
[file a.py]
from b import C

def f(x: int) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
class C:
    X = 0
    Y = 1
[file b.py.2]
from enum import Enum
C = Enum('C', [('X', 0), ('Y', 1)])
[out]
==
a.py:4: error: Argument 1 to "f" has incompatible type "C"; expected "int"
a.py:5: error: Argument 1 to "f" has incompatible type "C"; expected "int"

[case testChangeTypeVarToFunction]
import a
from typing import Generic
Alias = C[C[a.T]]

class C(Generic[a.T]):
    def meth(self, x: a.T) -> None:
        pass
def outer() -> None:
    def func(x: a.T) -> Alias[a.T]:
        pass
[file a.py]
from typing import TypeVar
T = TypeVar('T')
[file a.py.2]
from typing import TypeVar
def T() -> None:
    pass
[out]
==
main:3: error: "C" expects no type arguments, but 1 given
main:3: error: Invalid type "a.T"
main:5: error: Free type variable expected in Generic[...]
main:6: error: Invalid type "a.T"
main:9: error: Invalid type "a.T"
main:9: error: Bad number of arguments for type alias, expected: 0, given: 1
main:9: error: "C" expects no type arguments, but 1 given

[case testChangeTypeVarToModule]
import a
from typing import Generic
Alias = C[C[a.T]]

class C(Generic[a.T]):
    def meth(self, x: a.T) -> None:
        pass
def outer() -> None:
    def func(x: a.T) -> Alias[a.T]:
        pass
[file a.py]
from typing import TypeVar
T = TypeVar('T')
[file T.py.2]
[file a.py.3]
from typing import TypeVar
import T
[out]
==
==
main:3: error: "C" expects no type arguments, but 1 given
main:5: error: Free type variable expected in Generic[...]
main:6: error: Invalid type "T"
main:9: error: Bad number of arguments for type alias, expected: 0, given: 1
main:9: error: "C" expects no type arguments, but 1 given
main:9: error: Invalid type "T"

[case testChangeClassToModule]
import a
x: a.C
def f() -> None:
    a.C()
class A:
    def meth(self) -> None:
        def inner() -> a.C:
            pass
[file a.py]
class C:
    pass
[file C.py.2]
[file a.py.3]
import C
[builtins fixtures/module.pyi]
[out]
==
==
main:2: error: Invalid type "C"
main:4: error: Module not callable
main:7: error: Invalid type "C"

[case testChangeTypeVarToTypeAlias]
import a
from typing import Generic
Alias = C[C[a.T]]

class C(Generic[a.T]):
    def meth(self, x: a.T) -> None:
        pass
def outer() -> None:
    def func(x: a.T) -> Alias[a.T]:
        pass
[file a.py]
from typing import TypeVar
T = TypeVar('T')
[file a.py.2]
from typing import TypeVar
T = int
[out]
==
main:3: error: "C" expects no type arguments, but 1 given
main:5: error: Free type variable expected in Generic[...]
main:9: error: Bad number of arguments for type alias, expected: 0, given: 1
main:9: error: "C" expects no type arguments, but 1 given

[case testChangeTypeAliasToModule]
import a
x: a.C
def f() -> None:
    a.C()
class A:
    def meth(self) -> None:
        def inner() -> a.C:
            pass
[file a.py]
import b
C = b.D
[file b.py]
class D:
    pass
[file D.py.2]
[file b.py.3]
import D
[builtins fixtures/module.pyi]
[out]
==
==
main:2: error: Invalid type "D"
main:4: error: Module not callable
main:7: error: Invalid type "D"

[case testChangeTypeAliasToModuleUnqualified]
from a import C
x: C
def f() -> None:
    C()
class A:
    def meth(self) -> None:
        def inner() -> C:
            pass
[file a.py]
from b import D
C = D
[file b.py]
class D:
    pass
[file D.py.2]
[file b.py.3]
import D
[builtins fixtures/module.pyi]
[out]
==
==
main:2: error: Invalid type "D"
main:4: error: Module not callable
main:7: error: Invalid type "D"

[case testChangeFunctionToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
f = 1
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeVarAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from typing import TypeVar
f = TypeVar('f')
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToModuleAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
import c as f
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeAliasAndRefreshUsingStaleDependency1]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
f = int
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeAliasAndRefreshUsingStaleDependency2]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from typing import List
f = List[int]
[file c.py]
class A: pass
[file c.py.3]
[builtins fixtures/list.pyi]
[out]
==
==

[case testChangeFunctionToClassAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
class f: pass
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testClassToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
class A:
    def f(self) -> c.A: pass
[file a.py.2]
A = 0
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testFunctionToImportedFunctionAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from d import f
[file c.py]
class A: pass
[file c.py.3]
[file d.py]
def g() -> None: pass
def f() -> None:
    g()
[out]
==
==

[case testMethodToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
class B:
    def f(self) -> c.A: pass
[file a.py.2]
class B:
    f = 0
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeGenericFunctionToVariable]
import a
x: int
y: int = a.f(x)
class Dummy:
    def g(self) -> None:
        a.f(x)
[file a.py]
from typing import TypeVar
T = TypeVar('T')
def f(x: T) -> T:
    pass
[file a.py.2]
from typing import TypeVar
T = TypeVar('T')
f = 42
[out]
==
main:3: error: "int" not callable
main:6: error: "int" not callable

[case testChangeGenericClassToVariable]
import a
x: int
a.A(x)
class Dummy:
    def g(self) -> None:
        a.A(x)
[file a.py]
from typing import TypeVar, Generic
T = TypeVar('T')
class A(Generic[T]):
    def __init__(self, x: T) -> None:
        pass
[file a.py.2]
from typing import TypeVar, Generic
T = TypeVar('T')
A = 'no way'
[out]
==
main:3: error: "str" not callable
main:6: error: "str" not callable

[case testChangeGenericMethodToVariable]
import a
x: int
y: int = a.A(x).f()
class Dummy:
    def g(self) -> None:
        a.A(x).f()
[file a.py]
from typing import TypeVar, Generic
T = TypeVar('T')
class A(Generic[T]):
    def __init__(self, x: T) -> None:
        pass
    def f(self) -> T:
        pass
[file a.py.2]
from typing import TypeVar, Generic
T = TypeVar('T')
class A(Generic[T]):
    f: T
    def __init__(self, x: T) -> None:
        pass
[out]
==
main:3: error: "int" not callable
main:6: error: "int" not callable

[case testRefreshNestedClassWithSelfReference]
import a
[file a.py]
import b

def f(self) -> None:
    b.y
    class C:
        z: C
[file b.py]
y = 0
[file b.py.2]
y = ''
[file b.py.3]
y = 0
[out]
==
==

[case testMultipleAssignment]
import a
[file a.py]
from b import f

def h(x: str) -> None: pass

class C:
    def __init__(self) -> None:
        self.a, self.b = f()

    def g(self) -> None:
        h(self.a)
[file b.py]
from typing import Tuple
def f() -> Tuple[str, int]: pass
[file b.py.2]
from typing import Tuple
def f() -> Tuple[int, object]: pass
[file b.py.3]
from typing import Tuple
def f() -> Tuple[str, int]: pass
[out]
==
a.py:10: error: Argument 1 to "h" has incompatible type "int"; expected "str"
==

[case testMultipleLvalues]
import a
[file a.py]
from b import f

def h(x: str) -> None: pass

class C:
    def __init__(self) -> None:
        self.a = self.b = f()

    def g(self) -> None:
        h(self.a)
        h(self.b)
[file b.py]
def f() -> str: pass
[file b.py.2]
def f() -> int: pass
[file b.py.3]
def f() -> str: pass
[out]
==
a.py:10: error: Argument 1 to "h" has incompatible type "int"; expected "str"
a.py:11: error: Argument 1 to "h" has incompatible type "int"; expected "str"
==

[case testNoOpUpdateFineGrainedIncremental1]
# cmd: mypy a.py
[file a.py]
1()
[file b.py.2]
# Note: this file is not part of the build
[file a.py.3]
x = 1
[out]
a.py:1: error: "int" not callable
==
a.py:1: error: "int" not callable
==

[case testNoOpUpdateFineGrainedIncremental2]
# cmd: mypy a.py
[file a.py]
1()
[file a.py.2]
1()
[file a.py.3]
x = 1
[file a.py.4]
x = 1
[out]
a.py:1: error: "int" not callable
==
a.py:1: error: "int" not callable
==
==

[case testNonExistentFileOnCommandLine1]
# cmd: mypy a.py nonexistent.py
[file a.py]
[file a.py.2]
1()
[out]
mypy: can't read file 'tmp/nonexistent.py': No such file or directory
==
mypy: can't read file 'tmp/nonexistent.py': No such file or directory

[case testNonExistentFileOnCommandLine2]
# cmd: mypy a.py
# cmd2: mypy a.py nonexistent.py
[file a.py]
[file a.py.2]
1()
[out]
==
a.py:1: error: "int" not callable

[case testNonExistentFileOnCommandLine3]
# cmd: mypy a.py
# cmd2: mypy a.py nonexistent.py
[file a.py]
[file nonexistent.py]
[delete nonexistent.py.2]
[out]
==

[case testNonExistentFileOnCommandLine4]
# cmd: mypy a.py nonexistent.py
[file a.py]
[file nonexistent.py]
[delete nonexistent.py.2]
[out]
==

[case testNonExistentFileOnCommandLine5]
# cmd: mypy a.py nonexistent_stub.pyi
# TODO: Should generate an error for missing file
[file a.py]
[file nonexistent_stub.pyi]
[delete nonexistent_stub.pyi.2]
[out]
==

[case testDunderNewUpdatedMethod]
import a
[file a.py]
import b
class A:
    def func(self) -> None:
        b.C(int())
[file b.py]
class C:
    def __new__(cls, x: str) -> C:
        pass
[file b.py.2]
class C:
    def __new__(cls, x: int) -> C:
        pass
[out]
a.py:4: error: Argument 1 to "C" has incompatible type "int"; expected "str"
==

[case testDunderNewUpdatedSubclass]
import a
[file a.py]
import b

b.D(int())
[file b.py]
from c import C
class D(C): pass
[file c.py]
class C:
    def __new__(cls, x: str) -> C:
        pass
[file c.py.2]
class C:
    def __new__(cls, x: int) -> C:
        pass
[out]
a.py:3: error: Argument 1 to "D" has incompatible type "int"; expected "str"
==

[case testDunderNewUpdatedAlias]
import a
[file a.py]
import b

b.D(int())
[file b.py]
from c import C
D = C
[file c.py]
class C:
    def __new__(cls, x: int) -> C:
        pass
[file c.py.2]
class C:
    def __new__(cls, x: str) -> C:
        pass
[out]
==
a.py:3: error: Argument 1 to "C" has incompatible type "int"; expected "str"

[case testDunderNewUpdatedCallable]
import a
[file a.py]
from typing import Callable, Any
import b

def func(arg: Callable[[int], Any]) -> None:
    pass
func(b.C)
[file b.py]
class C:
    def __new__(cls, x: int) -> C:
        pass
[file b.py.2]
class C:
    def __new__(cls, x: str) -> C:
        pass
[out]
==
a.py:6: error: Argument 1 to "func" has incompatible type "Type[C]"; expected "Callable[[int], Any]"

[case testDunderNewDefine]
import a
[file a.py]
import b
class A:
    def func(self) -> None:
        b.C()
[file b.py]
class C:
    pass
[file b.py.2]
class C:
    def __new__(cls, x: int) -> C:
        pass
[out]
==
a.py:4: error: Too few arguments for "C"

[case testDunderNewInsteadOfInit]
import a
[file a.py]
import b
class A:
    def func(self) -> None:
        b.C(int())
[file b.py]
class C:
    def __init__(cls, x: int) -> None:
        pass
[file b.py.2]
class C:
    def __new__(cls, x: int) -> C:
        pass
[file b.py.3]
class C:
    pass
[out]
==
==
a.py:4: error: Too many arguments for "C"

-- Protocol tests

[case testProtocolUpdateTypeInVariable]
import a
[file a.py]
import b
class C:
    x: int
x: b.P = C()
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
[file b.py.2]
from typing import Protocol
class P(Protocol):
    x: str
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:4: note: Following member(s) of "C" have conflicts:
a.py:4: note:     x: expected "str", got "int"

[case testProtocolUpdateTypeInFunction]
import a
[file a.py]
import b
class C:
    x: int
c: C
def f() -> None:
    def g(x: b.P) -> None:
        pass
    g(c)
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
[file b.py.2]
from typing import Protocol
class P(Protocol):
    x: str
[out]
==
a.py:8: error: Argument 1 to "g" has incompatible type "C"; expected "P"
a.py:8: note: Following member(s) of "C" have conflicts:
a.py:8: note:     x: expected "str", got "int"

[case testProtocolUpdateTypeInClass]
import a
[file a.py]
import b
class C:
    x: int
class A:
    class B:
        x: b.P
    y: B
A().y.x = C()
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
[file b.py.2]
from typing import Protocol
class P(Protocol):
    x: str
[out]
==
a.py:8: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:8: note: Following member(s) of "C" have conflicts:
a.py:8: note:     x: expected "str", got "int"

[case testProtocolAddAttrInFunction]
import a
[file a.py]
import b
class C:
    x: int
def f() -> None:
    c: C
    def g(x: b.P) -> None:
        pass
    g(c)
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
[file b.py.2]
from typing import Protocol
class P(Protocol):
    x: int
    y: str
[out]
==
a.py:8: error: Argument 1 to "g" has incompatible type "C"; expected "P"
a.py:8: note: 'C' is missing following 'P' protocol member:
a.py:8: note:     y

[case testProtocolRemoveAttrInClass]
import a
[file a.py]
import b
class C:
    x: int
class A:
    class B:
        x: b.P
    y: B
A().y.x = C()
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
    y: str
[file b.py.2]
from typing import Protocol
class P(Protocol):
    x: int
[out]
a.py:8: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:8: note: 'C' is missing following 'P' protocol member:
a.py:8: note:     y
==

[case testProtocolConcreteUpdateTypeFunction]
import a
[file a.py]
import b
from typing import Protocol
class P(Protocol):
    x: int
def f() -> None:
    def g(x: P) -> None:
        pass
    g(b.C())
[file b.py]
class C:
    x: int
[file b.py.2]
class C:
    x: str
[out]
==
a.py:8: error: Argument 1 to "g" has incompatible type "C"; expected "P"
a.py:8: note: Following member(s) of "C" have conflicts:
a.py:8: note:     x: expected "int", got "str"

[case testProtocolConcreteUpdateTypeMethodGeneric]
import a
[file a.py]
import b
from typing import Protocol, TypeVar
T = TypeVar('T')
class P(Protocol[T]):
    x: T
class C:
    def g(self, x: P[int]) -> None:
        pass
    def do(self) -> None:
        self.g(b.C())
[file b.py]
class C:
    x: int
[file b.py.2]
class C:
    x: str
[out]
==
a.py:10: error: Argument 1 to "g" of "C" has incompatible type "C"; expected "P[int]"
a.py:10: note: Following member(s) of "C" have conflicts:
a.py:10: note:     x: expected "int", got "str"

[case testProtocolConcreteRemoveAttrVariable]
import a
[file a.py]
import b, c
cc: c.C
x: b.P = cc
[file b.py]
from typing import Protocol
class P(Protocol):
    x: int
[file c.py]
class C:
    x: int
[file c.py.2]
class C:
    pass
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "C", variable has type "P")

[case testProtocolUpdateBaseGeneric]
import a
[file a.py]
import b, c
def g(x: c.P) -> None:
    pass
g(b.C())
[file b.py]
class C:
    x: int
[file c.py]
from typing import Protocol
import d
class P(d.PBase[int], Protocol):
    pass
[file c.py.2]
from typing import Protocol
import d
class P(d.PBase[str], Protocol):
    pass
[file d.py]
from typing import Protocol, TypeVar
T = TypeVar('T')
class PBase(Protocol[T]):
    x: T
[out]
==
a.py:4: error: Argument 1 to "g" has incompatible type "C"; expected "P"
a.py:4: note: Following member(s) of "C" have conflicts:
a.py:4: note:     x: expected "str", got "int"

[case testProtocolConcreteUpdateBaseGeneric]
import a
[file a.py]
import b
from typing import Protocol
class P(Protocol):
    x: int
def f(x: P) -> None:
    pass
f(b.B())
[file b.py]
import c
class B(c.C[int]):
    pass
[file b.py.2]
import c
class B(c.C[str]):
    pass
[file c.py]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]):
    x: T
[out]
==
a.py:7: error: Argument 1 to "f" has incompatible type "B"; expected "P"
a.py:7: note: Following member(s) of "B" have conflicts:
a.py:7: note:     x: expected "int", got "str"

[case testProtocolChangeGeneric]
import a
[file a.py]
import b, c
x: b.P = c.C()
[file b.py]
import b2
from typing import Protocol
class P(b2.P2[str], Protocol):
    pass
[file b2.py]
from typing import Protocol, TypeVar
T = TypeVar('T')
class P2(Protocol[T]):
    x: T
[file b2.py.2]
from typing import Protocol, TypeVar
T = TypeVar('T')
class P2(Protocol):
    x: int
[file c.py]
class C:
    x: int
[out]
a.py:2: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:2: note: Following member(s) of "C" have conflicts:
a.py:2: note:     x: expected "str", got "int"
==
b.py:3: error: "P2" expects no type arguments, but 1 given

[case testProtocolToNonProtocol]
import a
[file a.py]
import b, c
b.f(c.C())
[file b.py]
import d
def f(x: d.D) -> None:
    pass
[file c.py]
import d
class C:
    x: int
[file d.py]
from typing import Protocol
class D(Protocol):
    x: int
[file d.py.2]
class D:
    x: int
[file c.py.3]
import d
class C(d.D):
    pass
[out]
==
a.py:2: error: Argument 1 to "f" has incompatible type "C"; expected "D"
==

[case testNonProtocolToProtocol]
import a
[file a.py]
import b, c
b.f(c.C())
[file b.py]
import d
def f(x: d.D) -> None:
    pass
[file c.py]
import d
class C(d.D):
    pass
[file d.py]
class D:
    x: int
[file d.py.2]
from typing import Protocol
class D(Protocol):
    x: int
[file c.py.3]
import d
class C:
    x: int
[out]
==
a.py:2: error: Cannot instantiate abstract class 'C' with abstract attribute 'x'
==

[case testInvalidateProtocolViaSuperClass]
import a
[file a.py]
import b, c
def func(x: c.P) -> None:
    pass
func(b.B())
[file b.py]
class B:
    x: int
    y: str
[file c.py]
from typing import Protocol
import d
class P(d.PBase, Protocol):
    x: int
[file d.py]
from typing import Protocol
class PBase(Protocol):
    y: str
[file d.py.2]
from typing import Protocol
class PBase(Protocol):
    y: int
[out]
==
a.py:4: error: Argument 1 to "func" has incompatible type "B"; expected "P"
a.py:4: note: Following member(s) of "B" have conflicts:
a.py:4: note:     y: expected "int", got "str"

[case testProtocolInvalidateConcreteViaSuperClassUpdateType]
import a
[file a.py]
import b
def func(x: b.P) -> None:
    pass
func(b.B())
[file b.py]
from typing import Protocol
import c
class P(Protocol):
    x: int
class B(c.C):
    pass
[file c.py]
class C:
    x: int
[file c.py.2]
class C:
    x: str
[out]
==
a.py:4: error: Argument 1 to "func" has incompatible type "B"; expected "P"
a.py:4: note: Following member(s) of "B" have conflicts:
a.py:4: note:     x: expected "int", got "str"

[case testProtocolInvalidateConcreteViaSuperClassAddAttr]
import a
[file a.py]
import b
def func(x: b.P) -> None:
    pass
bb: b.B
func(bb)
[file b.py]
from typing import Protocol
import c
class P(Protocol):
    x: int
class B(c.C):
    pass
[file c.py]
class C:
    pass
[file c.py.2]
class C:
    x: int
[out]
a.py:5: error: Argument 1 to "func" has incompatible type "B"; expected "P"
==

[case testProtocolInvalidateConcreteViaSuperClassRemoveAttr]
import a
[file a.py]
import b
def func(x: b.P) -> None:
    pass
func(b.B())
[file b.py]
from typing import Protocol
import c
class P(Protocol):
    x: int
class B(c.C):
    pass
[file c.py]
class C:
    x: int
[file c.py.2]
class C:
    pass
[out]
==
a.py:4: error: Argument 1 to "func" has incompatible type "B"; expected "P"

[case testTwoProtocolsTwoFilesCrossedUpdateType-skip-cache]
# this test and the next one (TwoProtocolsTwoFilesCrossedDeleteAttr) has errors ordered
# opposite way with and without cache, therefore skip one of each.
import a
[file a.py]
import b1
import b2
[file b1.py]
import b2, d
from typing import Protocol
class P1(Protocol):
    x: int
def f(x: b2.P2) -> None:
    pass
f(d.D())
[file b2.py]
import b1, d
from typing import Protocol
class P2(Protocol):
    x: int
def f(x: b1.P1) -> None:
    pass
f(d.D())
[file d.py]
class D:
    x: int
[file d.py.2]
class D:
    x: str
[out]
==
b1.py:7: error: Argument 1 to "f" has incompatible type "D"; expected "P2"
b1.py:7: note: Following member(s) of "D" have conflicts:
b1.py:7: note:     x: expected "int", got "str"
b2.py:7: error: Argument 1 to "f" has incompatible type "D"; expected "P1"
b2.py:7: note: Following member(s) of "D" have conflicts:
b2.py:7: note:     x: expected "int", got "str"

[case testTwoProtocolsTwoFilesCrossedDeleteAttr-skip-nocache]
import a
[file a.py]
import b1
import b2
[file b1.py]
import b2, d
from typing import Protocol
class P1(Protocol):
    x: int
def f(x: b2.P2) -> None:
    pass
f(d.D())
[file b2.py]
import b1, d
from typing import Protocol
class P2(Protocol):
    x: int
def f(x: b1.P1) -> None:
    pass
f(d.D())
[file d.py]
class D:
    x: int
[file d.py.2]
class D:
    y: int
[out]
b2.py:7: error: Argument 1 to "f" has incompatible type "D"; expected "P2" (diff)
b1.py:7: error: Argument 1 to "f" has incompatible type "D"; expected "P1"

[case testProtocolsInvalidateByRemovingBase]
import a
[file a.py]
import b
def func(x: b.P) -> None:
    pass
func(b.B())
[file b.py]
from typing import Protocol
import c
class P(Protocol):
    x: int
class B(c.C):
    pass
[file c.py]
import d
class C(d.D):
    pass
[file c.py.2]
import d
class C:
    pass
[file d.py]
class D:
    x: int
[out]
==
a.py:4: error: Argument 1 to "func" has incompatible type "B"; expected "P"

[case testProtocolsInvalidateByRemovingMetaclass]
import a
[file a.py]
import b
def func(x: b.P) -> None:
    pass
func(b.B)
[file b.py]
from typing import Protocol
import c
class P(Protocol):
    x: int
class B(c.C):
    pass
[file c.py]
import d
class C(metaclass=d.M):
    pass
[file c.py.2]
import d
class C:
    pass
[file d.py]
class M(type):
    x: int
[out]
==
a.py:4: error: Argument 1 to "func" has incompatible type "Type[B]"; expected "P"

[case testProtocolVsProtocolSubUpdated]
import a
[file a.py]
import b, c
x: b.SuperP
y: c.SubP
x = y
[file b.py]
from typing import Protocol
class SuperP(Protocol):
    x: int
[file c.py]
from typing import Protocol
import d
class SubP(d.PBase, Protocol):
    y: str
[file d.py]
from typing import Protocol
class PBase(Protocol):
    x: int
[file d.py.2]
from typing import Protocol
class PBase(Protocol):
    x: str
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "SubP", variable has type "SuperP")
a.py:4: note: Following member(s) of "SubP" have conflicts:
a.py:4: note:     x: expected "int", got "str"

[case testProtocolVsProtocolSuperUpdated]
import a
[file a.py]
import b, c
x: b.SuperP
y: c.SubP
x = y
[file b.py]
from typing import Protocol
import d
class SuperP(d.PBase, Protocol):
    pass
[file c.py]
from typing import Protocol
class SubP(Protocol):
    x: int
[file d.py]
from typing import Protocol
class PBase(Protocol):
    x: int
[file d.py.2]
from typing import Protocol
class PBase(Protocol):
    y: int
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "SubP", variable has type "SuperP")

[case testProtocolVsProtocolSuperUpdated2]
import a
[file a.py]
import b, c
x: b.SuperP
y: c.SubP
x = y
[file b.py]
from typing import Protocol
import d
class SuperP(d.PBase, Protocol):
    x: int
[file c.py]
from typing import Protocol
class SubP(Protocol):
    x: int
    y: int
[file d.py]
from typing import Protocol
class PBase(Protocol):
    y: int
[file d.py.2]
from typing import Protocol
class PBase(Protocol):
    y: int
    z: int
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "SubP", variable has type "SuperP")
a.py:4: note: 'SubP' is missing following 'SuperP' protocol member:
a.py:4: note:     z

[case testProtocolVsProtocolSuperUpdated3]
import a
[file a.py]
import b, c
x: b.SuperP
y: c.SubP
x = y
[file b.py]
from typing import Protocol
import d
class SuperP(d.PBase, Protocol):
    x: int
[file c.py]
from typing import Protocol
class SubP(Protocol):
    x: int
    y: int
[file d.py]
from typing import Protocol
import e
class PBase(Protocol):
    y: int
[file d.py.2]
from typing import Protocol
import e
class PBase(e.NewP, Protocol):
    y: int
[file e.py]
from typing import Protocol
class NewP(Protocol):
    z: int
[out]
==
a.py:4: error: Incompatible types in assignment (expression has type "SubP", variable has type "SuperP")
a.py:4: note: 'SubP' is missing following 'SuperP' protocol member:
a.py:4: note:     z

[case testProtocolMultipleUpdates]
import a
[file a.py]
import b, c
x: b.P = c.C()
[file b.py]
from typing import Protocol
import b2
class P(b2.P2, Protocol):
    x: int
[file b2.py]
from typing import Protocol
class P2(Protocol):
    y: int
[file c.py]
import c2
class C(c2.C2):
    x: int
[file c2.py]
class C2:
    y: int
[file b2.py.2]
from typing import Protocol
class P2(Protocol):
    y: int
    z: int
[file c2.py.3]
class C2:
    y: int
    z: int
[file c2.py.4]
class C2:
    y: int
    z: str
[out]
==
a.py:2: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:2: note: 'C' is missing following 'P' protocol member:
a.py:2: note:     z
==
==
a.py:2: error: Incompatible types in assignment (expression has type "C", variable has type "P")
a.py:2: note: Following member(s) of "C" have conflicts:
a.py:2: note:     z: expected "int", got "str"

[case testWeAreCarefulWithBuiltinProtocols]
import a
x: a.A
for i in x:
    pass
[file a.py]
from typing import Iterator
class A:
    def __iter__(self) -> Iterator[int]:
        pass
[file a.py.2]
class A:
    pass
[out]
==
main:3: error: "A" has no attribute "__iter__" (not iterable)

[case testWeAreCarefullWithBuiltinProtocolsBase]
import a
x: a.A
for i in x:
    pass
[file a.py]
import b
class A(b.B):
    pass
[file a.py.2]
class A:
    pass
[file b.py]
from typing import Iterator
class B:
    def __iter__(self) -> Iterator[int]:
        pass
[out]
==
main:3: error: "A" has no attribute "__iter__" (not iterable)

[case testOverloadsSimpleFrom]
import a
[file a.py]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> str: pass
def f(x):
    pass
[file mod.py.2]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> int: pass
def f(x):
    pass
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testOverloadsSimpleToNested]
from typing import overload, Any
import mod
def outer() -> None:
    @overload
    def f(x: int) -> None: pass
    @overload
    def f(x: str) -> str: pass
    def f(x: Any) -> Any:
        y: int = mod.f()
[file mod.py]
def f() -> int:
    pass
[file mod.py.2]
def f() -> str:
    pass
[out]
==
main:9: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testOverloadsRemovedOverload]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
class C: pass
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> str: pass
@overload
def f(x: C) -> int: pass
def f(x):
    pass
[file mod.py.2]
class C: pass
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: C) -> int: pass
def f(x):
    pass
[out]
==
main:3: error: No overload variant of "f" matches argument types [builtins.str]

[case testOverloadsDeleted]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> str: pass
def f(x):
    pass
[file mod.py.2]
from typing import overload
[builtins fixtures/module.pyi]
[out]
==
main:3: error: Module has no attribute "f"

[case testOverloadsUpdatedTypeRecheckImplementation-skip]
from typing import overload
import mod
class Outer:
    @overload
    def f(self, x: mod.D) -> mod.D: pass
    @overload
    def f(self, x: mod.E) -> mod.E: pass
    def f(self, x: mod.C) -> mod.C:
        x.x = int()
        return x
[file mod.py]
import submod
class C(submod.B):
    pass
class D(C):
    pass
class E(C):
    pass
[file submod.py]
import base
class B(base.AI):
    pass
[file submod.py.2]
import base
class B(base.AS):
    pass
[file base.py]
class AI:
    x: int
class AS:
    x: str
[out]
==
main:9: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testOverloadsUpdatedTypeRechekConsistency]
from typing import overload
import mod
class Outer:
    @overload
    def f(self, x: mod.D) -> mod.D: pass
    @overload
    def f(self, x: mod.E) -> mod.E: pass
    def f(self, x: mod.C) -> mod.C:
        pass
[file mod.py]
class C:
    pass
class D(C):
    pass
class E(C):
    pass
[file mod.py.2]
class C:
    pass
class D(C):
    pass
class E:
    pass
[out]
==
main:8: error: Overloaded function implementation does not accept all possible arguments of signature 2
main:8: error: Overloaded function implementation cannot produce return type of signature 2

[case testOverloadsGenericTypevarUpdated]
import a
[file a.py]
import b
b.f(int())
[file b.py]
from typing import overload
import c
class C: pass
@overload
def f(x: C) -> None: pass
@overload
def f(x: c.T) -> c.T: pass
def f(x):
    pass
[file c.py]
from typing import TypeVar
T = TypeVar('T', int, str)
[file c.py.2]
from typing import TypeVar
T = TypeVar('T', bound=str)
[out]
==
a.py:2: error: No overload variant of "f" matches argument types [builtins.int]

[case testOverloadsGenericToNonGeneric]
import a
[file a.py]
import b
b.f(int())
[file b.py]
from typing import overload
import c
class C: pass
@overload
def f(x: C) -> None: pass
@overload
def f(x: c.T) -> c.T: pass
def f(x):
    pass
[file c.py]
from typing import TypeVar
T = TypeVar('T', bound=int)
[file c.py.2]
from typing import TypeVar
class T: pass
[out]
==
a.py:2: error: No overload variant of "f" matches argument types [builtins.int]

[case testOverloadsToNonOverloaded]
import a
[file a.py]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> str: pass
def f(x):
    pass
[file mod.py.2]
from typing import overload
def f(x: int) -> int:
    pass
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")
a.py:3: error: Argument 1 to "f" has incompatible type "str"; expected "int"

[case testOverloadsUpdateFunctionToOverloaded]
import a
[file a.py]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
from typing import overload
def f(x: str) -> str:
    pass
[file mod.py.2]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> int: pass
def f(x):
    pass
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testOverloadedUpdateToClass]
import a
[file a.py]
import mod
def f() -> None:
    x: str = mod.f(str())
[file mod.py]
from typing import overload
@overload
def f(x: int) -> None: pass
@overload
def f(x: str) -> str: pass
def f(x):
    pass
[file mod.py.2]
from typing import overload
class f:
    def __init__(self, x: str) -> None:
        pass
[out]
==
a.py:3: error: Incompatible types in assignment (expression has type "f", variable has type "str")

[case testDepsFromOverloadUpdatedAttrRecheckImpl]
import mod
x = mod.f
[file mod.py]
from typing import overload, Any
import submod
@overload
def f(x: int) -> submod.A: pass
@overload
def f(x: str) -> submod.B: pass
def f(x) -> Any:
    y: submod.C
    y.x = int()
[file submod.py]
import other
class A: pass
class B: pass
C = other.C
[file other.py]
class C:
    x: int
[file other.py.2]
class C:
    x: str
[out]
==
mod.py:9: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testOverloadedMethodSupertype]
from typing import overload, Any
import b
class Child(b.Parent):
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Any) -> Any: ...
[file b.py]
from typing import overload, Any
class C: pass
class Parent:
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Any) -> Any: ...
[file b.py.2]
from typing import overload, Any
class C: pass
class Parent:
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> C: ...
    def f(self, arg: Any) -> Any: ...
[out]
==
main:4: error: Signature of "f" incompatible with supertype "Parent"

[case testOverloadedInitSupertype]
import a
[file a.py]
from b import B
B(int())
[file b.py]
import c
class B(c.C):
    pass
[file c.py]
from typing import overload
class C:
    def __init__(self, x: int) -> None:
        pass
[file c.py.2]
from typing import overload
class C:
    @overload
    def __init__(self, x: str) -> None: pass
    @overload
    def __init__(self, x: str, y: int) -> None: pass
    def __init__(self, *args, **kwargs) -> None:
        pass
[builtins fixtures/dict.pyi]
[out]
==
a.py:2: error: No overload variant of "B" matches argument types [builtins.int]

[case testOverloadedToNormalMethodMetaclass]
import a
[file a.py]
import b
b.B.f(int())
[file b.py]
import c
class B(metaclass=c.M):
    pass
[file c.py]
from typing import overload
class M(type):
    @overload
    def f(cls, x: str) -> str: pass
    @overload
    def f(cls, x: int) -> None: pass
    def f(cls, x):
        pass
[file c.py.2]
from typing import overload
class M(type):
    def f(cls, x: str) -> str:
        pass
[out]
==
a.py:2: error: Argument 1 to "f" of "M" has incompatible type "int"; expected "str"

[case testYieldFrom]
from typing import Iterator
from a import f

def g() -> Iterator[int]:
    a = "string"
    a = yield from f()

[file a.py]
from typing import Generator

def f() -> Generator[int, None, str]:
    yield 5
    return "ham"

[file a.py.2]
from typing import Generator

class A: pass

def f() -> Generator[int, None, A]:
    yield 5
    return A()

[out]
==
main:6: error: Incompatible types in assignment (expression has type "A", variable has type "str")

[case testFString]
from a import g
f'{g(1)}'
[file a.py]
def g(x: int) -> str: pass
[file a.py.2]
def g(x: str) -> str: pass
[builtins fixtures/f_string.pyi]
[out]
==
main:2: error: Argument 1 to "g" has incompatible type "int"; expected "str"

[case testExtendedUnpacking-skip-cache]
from typing import List
from a import g
def f() -> List[int]:
    a, *b = g()
    return b

[file a.py]
from typing import Tuple
def g() -> Tuple[str, int, int]: pass

[file a.py.2]
from typing import Tuple
def g() -> Tuple[str, str]: pass

[builtins fixtures/tuple.pyi]
[out]
==
main:5: error: Incompatible return value type (got "List[str]", expected "List[int]")

[case testUnpackInExpression1-skip-cache]
from typing import Tuple, List
from a import t

def f() -> Tuple[int, int]:
    return (1, *t())

def g() -> List[int]:
    return [1, *t()]

[file a.py]
from typing import Tuple
def t() -> Tuple[int]: ...

[file a.py.2]
from typing import Tuple
def t() -> Tuple[str]: ...

[builtins fixtures/list.pyi]
[out]
==
main:5: error: Incompatible return value type (got "Tuple[int, str]", expected "Tuple[int, int]")
main:8: error: List item 1 has incompatible type "Tuple[str]"; expected "int"

[case testUnpackInExpression2-skip-cache]
from typing import Set
from a import t

def f() -> Set[int]:
    return {1, *t()}

[file a.py]
from typing import Tuple
def t() -> Tuple[int]: pass

[file a.py.2]
from typing import Tuple
def t() -> Tuple[str]: pass

[builtins fixtures/set.pyi]
[out]
==
main:5: error: Argument 2 to <set> has incompatible type "*Tuple[str]"; expected "int"

[case testUnpackInExpression3-skip-cache]
from typing import Dict
from a import d

def f() -> Dict[int, str]:
    return {1: '', **d()}

[file a.py]
from typing import Dict
def d() -> Dict[int, str]: pass

[file a.py.2]
from typing import Dict
def d() -> Dict[int, int]: pass

[builtins fixtures/dict.pyi]
[out]
==
main:5: error: Argument 1 to "update" of "dict" has incompatible type "Dict[int, int]"; expected "Mapping[int, str]"

[case testAwaitAndAsyncDef-skip-cache]
from a import g

async def f() -> int:
    return await g()

[file a.py]
async def g() -> int:
    return 0

[file a.py.2]
async def g() -> str:
    return ''

[builtins fixtures/async_await.pyi]
[typing fixtures/typing-full.pyi]
[out]
==
main:4: error: Incompatible return value type (got "str", expected "int")

[case testAwaitAnd__await__-skip-cache]
from a import C

async def f(c: C) -> int:
    return await c

[file a.py]
from typing import Any, Generator
class C:
    def __await__(self) -> Generator[Any, None, int]:
        yield
        return 0

[file a.py.2]
from typing import Any, Generator
class C:
    def __await__(self) -> Generator[Any, None, str]:
        yield
        return ''

[builtins fixtures/async_await.pyi]
[typing fixtures/typing-full.pyi]
[out]
==
main:4: error: Incompatible return value type (got "str", expected "int")

[case test__aiter__and__anext__]
from a import C

async def f() -> int:
    async for x in C():
        pass
    return x

[file a.py]
class C:
    def __aiter__(self) -> D: pass
class D:
    def __aiter__(self) -> D: pass
    async def __anext__(self) -> int: return 0

[file a.py.2]
class C:
    def __aiter__(self) -> D: pass
class D:
    def __aiter__(self) -> D: pass
    async def __anext__(self) -> str: return ''

[file a.py.3]
class C:
    def __aiter__(self) -> E: pass
class E:
    def __aiter__(self) -> E: pass
    async def __anext__(self) -> object: return 0

[builtins fixtures/async_await.pyi]
[typing fixtures/typing-full.pyi]
[out]
==
main:6: error: Incompatible return value type (got "str", expected "int")
==
main:6: error: Incompatible return value type (got "object", expected "int")

[case testAsyncWith2-skip-cache]
from a import C

async def f() -> int:
    async with C() as x:
        return x

async def g() -> None:
    async with C(): pass

[file a.py]
class C:
    async def __aenter__(self) -> int: pass
    async def __aexit__(self, x, y, z) -> None: pass

[file a.py.2]
class C:
    async def __aenter__(self) -> str: pass
    async def __aexit__(self, x, y, z) -> None: pass

[file a.py.3]
from typing import Awaitable
class C:
    async def __aenter__(self) -> int: pass
    async def __aexit__(self, x, y, z) -> None: pass

[file a.py.4]
from typing import Awaitable
class C:
    async def __aenter__(self) -> int: pass

[builtins fixtures/async_await.pyi]
[typing fixtures/typing-full.pyi]
[out]
==
main:5: error: Incompatible return value type (got "str", expected "int")
==
==
main:4: error: "C" has no attribute "__aexit__"
main:8: error: "C" has no attribute "__aexit__"

[case testLiskovFineVariable]
import b
class A(b.B):
    x: str
def f(x: b.B) -> None:
    x.x + int()
f(A())
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
main:5: error: Unsupported operand types for + ("str" and "int")
==
main:3: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineVariableInFunction]
from b import B
def outer() -> None:
    class A(B):
        x: str
    def f(x: B) -> None:
        x.x + int()
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
main:6: error: Unsupported operand types for + ("str" and "int")
==
main:4: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineDecorator]
import b
from c import deco
class A(b.B):
    @deco
    def m(self) -> str: pass
def f(x: b.B) -> None:
    x.m() + int()
f(A())
[file b.py]
from c import deco
class B:
    @deco
    def m(self) -> str: pass
[file b.py.2]
from c import deco
class B:
    @deco
    def m(self) -> int: pass
[file c.py]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)
def deco(f: F) -> F:
    pass
[out]
main:7: error: Unsupported operand types for + ("str" and "int")
==
main:5: error: Return type of "m" incompatible with supertype "B"

[case testLiskovFineVariableClean-skip-cache]
import b
class A(b.B):
    x: str
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
==
main:3: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineVariableCleanDefInMethod-skip-cache]
import b
class A(b.B):
    def meth(self) -> None:
        self.x: str
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
==
main:4: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineVariableCleanDefInMethodNested-skip-cache]
from b import B
def outer() -> None:
    class A(B):
        def meth(self) -> None:
            self.x: str
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineVariableInFunctionClean-skip-cache]
from b import B
def outer() -> None:
    class A(B):
        x: str
[file b.py]
class B:
    x: str
[file b.py.2]
class B:
    x: int
[out]
==
main:4: error: Incompatible types in assignment (expression has type "str", base class "B" defined the type as "int")

[case testLiskovFineDecoratorClean-skip-cache]
import b
from c import deco
class A(b.B):
    @deco
    def m(self) -> str: pass
[file b.py]
from c import deco
class B:
    @deco
    def m(self) -> str: pass
[file b.py.2]
from c import deco
class B:
    @deco
    def m(self) -> int: pass
[file c.py]
from typing import Callable, TypeVar
F = TypeVar('F', bound=Callable)
def deco(f: F) -> F:
    pass
[out]
==
main:5: error: Return type of "m" incompatible with supertype "B"

[case testAddAbstractMethod]
from b import D
D()
[file b.py]
from a import C
class D(C):
    def f(self) -> None: pass
[file a.py]
from abc import abstractmethod
class C:
    @abstractmethod
    def f(self) -> None: pass
[file a.py.2]
from abc import abstractmethod
class C:
    @abstractmethod
    def f(self) -> None: pass
    @abstractmethod
    def g(self) -> None: pass
[file a.py.3]
from abc import abstractmethod
class C:
    @abstractmethod
    def f(self) -> None: pass
    def g(self) -> None: pass
[out]
==
main:2: error: Cannot instantiate abstract class 'D' with abstract attribute 'g'
==

[case testMakeClassAbstract]
from a import C
c = C()
[file a.py]
from abc import abstractmethod
class C: pass
[file a.py.2]
from abc import abstractmethod
class C:
    @abstractmethod
    def f(self) -> None: pass
[out]
==
main:2: error: Cannot instantiate abstract class 'C' with abstract attribute 'f'

[case testMakeMethodNoLongerAbstract1]
[file z.py]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self) -> None: pass
    @abstractmethod
    def g(self) -> None: pass
[file b.py]
import z
def x() -> Foo: return Foo()
class Foo(z.I):
    def f(self) -> None: pass
    def g(self) -> None: pass

[file z.py.2]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    def f(self) -> None: pass
    @abstractmethod
    def g(self) -> None: pass

[file b.py.2]
import z
def x() -> Foo: return Foo()
class Foo(z.I):
    def g(self) -> None: pass
[out]
==

[case testMakeMethodNoLongerAbstract2]
-- this version never failed, but it is just a file-renaming
-- away from the above test that did
[file a.py]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    @abstractmethod
    def f(self) -> None: pass
    @abstractmethod
    def g(self) -> None: pass
[file b.py]
import a
def x() -> Foo: return Foo()
class Foo(a.I):
    def f(self) -> None: pass
    def g(self) -> None: pass

[file a.py.2]
from abc import abstractmethod, ABCMeta
class I(metaclass=ABCMeta):
    def f(self) -> None: pass
    @abstractmethod
    def g(self) -> None: pass

[file b.py.2]
import a
def x() -> Foo: return Foo()
class Foo(a.I):
    def g(self) -> None: pass
[out]
==

[case testImplicitOptionalRefresh1]
# flags: --strict-optional
from x import f
def foo(x: int = None) -> None:
    f()
[file x.py]
def f() -> int: return 0
[file x.py.2]
def f() -> str: return '0'
[out]
==
