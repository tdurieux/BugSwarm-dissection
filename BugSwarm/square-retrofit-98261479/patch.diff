diff --git a/retrofit/src/main/java/retrofit2/CallAdapter.java b/retrofit/src/main/java/retrofit2/CallAdapter.java
index e6e94a5a4..7c289f5f4 100644
--- a/retrofit/src/main/java/retrofit2/CallAdapter.java
+++ b/retrofit/src/main/java/retrofit2/CallAdapter.java
@@ -18,22 +18,45 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 
-/** Adapts a {@link Call} into the type of {@code T}. */
+/**
+ * Adapts a {@link Call} into the type of {@code T}. Instances are created by {@linkplain Factory a
+ * factory} which is {@linkplain Retrofit.Builder#addCallAdapterFactory(Factory) installed} into
+ * the {@link Retrofit} instance.
+ */
 public interface CallAdapter<T> {
   /**
    * Returns the value type that this adapter uses when converting the HTTP response body to a Java
    * object. For example, the response type for {@code Call<Repo>} is {@code Repo}. This type
    * is used to prepare the {@code call} passed to {@code #adapt}.
-   *
-   * <p>Note that this is typically not the same type as the {@code returnType} provided to
-   * this call adapter's factory.
+   * <p>
+   * Note: This is typically not the same type as the {@code returnType} provided to this call
+   * adapter's factory.
    */
   Type responseType();
 
-  /** Returns an instance of the {@code T} which adapts the execution of {@code call}. */
+  /**
+   * Returns an instance of {@code T} which delegates to {@code call}.
+   * <p>
+   * For example, given an instance for a hypothetical utility, {@code Async}, this instance would
+   * return a new {@code Async<R>} which invoked {@code call} when run.
+   * <pre>{@code
+   * &#64;Override
+   * public <R> Async<R> adapt(final Call<R> call) {
+   *   return Async.create(new Callable<Response<R>>() {
+   *     &#64;Override
+   *     public Response<R> call() throws Exception {
+   *       return call.execute();
+   *     }
+   *   });
+   * }
+   * }</pre>
+   */
   <R> T adapt(Call<R> call);
 
-  /** Creates {@link CallAdapter} instances based on a desired type. */
+  /**
+   * Creates {@link CallAdapter} instances based on the return type of {@linkplain
+   * Retrofit#create(Class) the service interface} methods.
+   */
   interface Factory {
     /**
      * Returns a call adapter for interface methods that return {@code returnType}, or null if it
diff --git a/retrofit/src/main/java/retrofit2/Converter.java b/retrofit/src/main/java/retrofit2/Converter.java
index 1f87253e4..e20673d99 100644
--- a/retrofit/src/main/java/retrofit2/Converter.java
+++ b/retrofit/src/main/java/retrofit2/Converter.java
@@ -31,8 +31,9 @@
 import retrofit2.http.QueryMap;
 
 /**
- * Convert objects to and from their representation in HTTP. Register a converter with Retrofit
- * using {@link Retrofit.Builder#addConverterFactory(Factory)}.
+ * Convert objects to and from their representation in HTTP. Instances are created by {@linkplain
+ * Factory a factory} which is {@linkplain Retrofit.Builder#addConverterFactory(Factory) installed}
+ * into the {@link Retrofit} instance.
  */
 public interface Converter<F, T> {
   T convert(F value) throws IOException;
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index 795e5404e..04245106a 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -33,58 +33,25 @@
 import retrofit2.http.GET;
 import retrofit2.http.HTTP;
 import retrofit2.http.Header;
+import retrofit2.http.Url;
 
 import static retrofit2.Utils.checkNotNull;
 
 /**
- * Adapts a Java interface to a REST API.
+ * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to
+ * define how requests are made. Create instances using {@linkplain Builder
+ * the builder} and pass your interface to {@link #create} to generate an implementation.
  * <p>
- * API endpoints are defined as methods on an interface with annotations providing metadata about
- * the form in which the HTTP call should be made.
- * <p>
- * The relative path for a given method is obtained from an annotation on the method describing
- * the request type. The built-in methods are {@link retrofit2.http.GET GET},
- * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
- * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
- * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with {@link HTTP @HTTP}.
- * <p>
- * Method parameters can be used to replace parts of the URL by annotating them with
- * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier surrounded
- * by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
- * {@link retrofit2.http.Query @Query}.
- * <p>
- * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The object
- * will be converted to request representation by one of the {@link Converter.Factory} instances.
- * A {@link RequestBody} can also be used for a raw representation.
- * <p>
- * Alternative request body formats are supported by method annotations and corresponding parameter
- * annotations:
- * <ul>
- * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
- * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
- * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with parts
- * specified by the {@link retrofit2.http.Part @Part} parameter annotation.
- * </ul>
- * <p>
- * Additional static headers can be added for an endpoint using the
- * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a header
- * annotate a parameter with {@link Header @Header}.
- * <p>
- * By default, methods return a {@link Call} which represents the HTTP request. The generic
- * parameter of the call is the response body type and will be converted by one of the
- * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
- * representation. {@link Void} can be used if you do not care about the body contents.
- * <p>
- * For example:
- * <pre>
- * public interface CategoryService {
- *   &#64;POST("/category/{cat}")
- *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
- * }
- * </pre>
- * <p>
- * Calling {@link #create(Class) create()} with {@code CategoryService.class} will validate the
- * annotations and create a new implementation of the service definition.
+ * For example,
+ * <pre>{@code
+ * Retrofit retrofit = new Retrofit.Builder()
+ *     .baseUrl("http://api.example.com")
+ *     .addConverterFactory(GsonConverterFactory.create())
+ *     .build();
+ *
+ * MyApi api = retrofit.create(MyApi.class);
+ * Response<User> user = api.getUser().execute();
+ * }</pre>
  *
  * @author Bob Lee (bob@squareup.com)
  * @author Jake Wharton (jw@squareup.com)
@@ -110,7 +77,52 @@
     this.validateEagerly = validateEagerly;
   }
 
-  /** Create an implementation of the API defined by the {@code service} interface. */
+  /**
+   * Create an implementation of the API endpoints defined by the {@code service} interface.
+   * <p>
+   * The relative path for a given method is obtained from an annotation on the method describing
+   * the request type. The built-in methods are {@link retrofit2.http.GET GET},
+   * {@link retrofit2.http.PUT PUT}, {@link retrofit2.http.POST POST}, {@link retrofit2.http.PATCH
+   * PATCH}, {@link retrofit2.http.HEAD HEAD}, {@link retrofit2.http.DELETE DELETE} and
+   * {@link retrofit2.http.OPTIONS OPTIONS}. You can use a custom HTTP method with
+   * {@link HTTP @HTTP}. For a dynamic URL, omit the path on the annotation and annotate the first
+   * parameter with {@link Url @Url}.
+   * <p>
+   * Method parameters can be used to replace parts of the URL by annotating them with
+   * {@link retrofit2.http.Path @Path}. Replacement sections are denoted by an identifier
+   * surrounded by curly braces (e.g., "{foo}"). To add items to the query string of a URL use
+   * {@link retrofit2.http.Query @Query}.
+   * <p>
+   * The body of a request is denoted by the {@link retrofit2.http.Body @Body} annotation. The
+   * object will be converted to request representation by one of the {@link Converter.Factory}
+   * instances. A {@link RequestBody} can also be used for a raw representation.
+   * <p>
+   * Alternative request body formats are supported by method annotations and corresponding
+   * parameter annotations:
+   * <ul>
+   * <li>{@link retrofit2.http.FormUrlEncoded @FormUrlEncoded} - Form-encoded data with key-value
+   * pairs specified by the {@link retrofit2.http.Field @Field} parameter annotation.
+   * <li>{@link retrofit2.http.Multipart @Multipart} - RFC 2388-compliant multi-part data with
+   * parts specified by the {@link retrofit2.http.Part @Part} parameter annotation.
+   * </ul>
+   * <p>
+   * Additional static headers can be added for an endpoint using the
+   * {@link retrofit2.http.Headers @Headers} method annotation. For per-request control over a
+   * header annotate a parameter with {@link Header @Header}.
+   * <p>
+   * By default, methods return a {@link Call} which represents the HTTP request. The generic
+   * parameter of the call is the response body type and will be converted by one of the
+   * {@link Converter.Factory} instances. {@link ResponseBody} can also be used for a raw
+   * representation. {@link Void} can be used if you do not care about the body contents.
+   * <p>
+   * For example:
+   * <pre>
+   * public interface CategoryService {
+   *   &#64;POST("category/{cat}/")
+   *   Call&lt;List&lt;Item&gt;&gt; categoryList(@Path("cat") String a, @Query("page") int b);
+   * }
+   * </pre>
+   */
   @SuppressWarnings("unchecked") // Single-interface proxy creation guarded by parameter safety.
   public <T> T create(final Class<T> service) {
     Utils.validateServiceInterface(service);
@@ -156,9 +168,7 @@ MethodHandler loadMethodHandler(Method method) {
     return handler;
   }
 
-  /**
-   * TODO
-   */
+  /** The factory used to create {@link Call} instances. */
   public Call.Factory callFactory() {
     return callFactory;
   }
@@ -336,6 +346,7 @@ public BaseUrl baseUrl() {
     return (Converter<T, String>) BuiltInConverters.ToStringConverter.INSTANCE;
   }
 
+  /** The executor used for {@link Callback} methods on a {@link Call}. */
   public Executor callbackExecutor() {
     return callbackExecutor;
   }
@@ -375,7 +386,9 @@ public Builder client(OkHttpClient client) {
     }
 
     /**
-     * TODO
+     * Specify a custom call factory for creating {@link Call} instances.
+     * <p>
+     * Note: Calling {@link #client} automatically sets this value.
      */
     public Builder callFactory(Call.Factory factory) {
       this.callFactory = checkNotNull(factory, "factory == null");
@@ -470,13 +483,14 @@ public Builder baseUrl(BaseUrl baseUrl) {
     }
 
     /** Add converter factory for serialization and deserialization of objects. */
-    public Builder addConverterFactory(Converter.Factory converterFactory) {
-      converterFactories.add(checkNotNull(converterFactory, "converterFactory == null"));
+    public Builder addConverterFactory(Converter.Factory factory) {
+      converterFactories.add(checkNotNull(factory, "factory == null"));
       return this;
     }
 
     /**
-     * TODO
+     * Add a call adapter factory for supporting service method return types other than {@link
+     * Call}.
      */
     public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
       adapterFactories.add(checkNotNull(factory, "factory == null"));
@@ -486,9 +500,12 @@ public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
     /**
      * The executor on which {@link Callback} methods are invoked when returning {@link Call} from
      * your service method.
+     * <p>
+     * Note: {@code executor} is not used for {@linkplain #addCallAdapterFactory custom method
+     * return types}.
      */
-    public Builder callbackExecutor(Executor callbackExecutor) {
-      this.callbackExecutor = checkNotNull(callbackExecutor, "callbackExecutor == null");
+    public Builder callbackExecutor(Executor executor) {
+      this.callbackExecutor = checkNotNull(executor, "executor == null");
       return this;
     }
 
@@ -501,7 +518,12 @@ public Builder validateEagerly(boolean validateEagerly) {
       return this;
     }
 
-    /** Create the {@link Retrofit} instances. */
+    /**
+     * Create the {@link Retrofit} instance using the configured values.
+     * <p>
+     * Note: If neither {@link #client} nor {@link #callFactory} is called a default {@link
+     * OkHttpClient} will be created and used.
+     */
     public Retrofit build() {
       if (baseUrl == null) {
         throw new IllegalStateException("Base URL required.");
diff --git a/retrofit/src/test/java/retrofit2/RetrofitTest.java b/retrofit/src/test/java/retrofit2/RetrofitTest.java
index 600771966..290a593c0 100644
--- a/retrofit/src/test/java/retrofit2/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit2/RetrofitTest.java
@@ -741,7 +741,7 @@
       new Retrofit.Builder().addConverterFactory(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage("converterFactory == null");
+      assertThat(e).hasMessage("factory == null");
     }
   }
 
@@ -1054,7 +1054,7 @@
       new Retrofit.Builder().callbackExecutor(null);
       fail();
     } catch (NullPointerException e) {
-      assertThat(e).hasMessage("callbackExecutor == null");
+      assertThat(e).hasMessage("executor == null");
     }
   }
 
