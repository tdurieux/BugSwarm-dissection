diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 754d604aee..9f68096de5 100755
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -24,11 +24,6 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.bouncycastle</groupId>
       <artifactId>bcprov-jdk15on</artifactId>
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 26123f2568..8452b84634 100755
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -21,7 +21,7 @@
 import okhttp3.Headers;
 import okhttp3.internal.Internal;
 import okhttp3.internal.http2.Settings;
-import okhttp3.ws.WebSocketListener;
+import okhttp3.WebSocketListener;
 import okio.Buffer;
 
 /** A scripted response to be replayed by the mock web server. */
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index a745efe734..59b50c70af 100755
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -17,6 +17,7 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
 import java.net.InetAddress;
@@ -70,7 +71,6 @@
 import okhttp3.internal.platform.Platform;
 import okhttp3.internal.ws.RealWebSocket;
 import okhttp3.internal.ws.WebSocketProtocol;
-import okhttp3.ws.WebSocketListener;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -99,7 +99,7 @@
  * A scriptable web server. Callers supply canned responses and the server replays them upon request
  * in sequence.
  */
-public final class MockWebServer implements TestRule {
+public final class MockWebServer implements TestRule, Closeable {
   static {
     Internal.initializeInstanceForTests();
   }
@@ -655,22 +655,6 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
     writeHttpResponse(socket, sink, response);
 
-    final WebSocketListener listener = response.getWebSocketListener();
-    final CountDownLatch connectionClose = new CountDownLatch(1);
-
-    ThreadPoolExecutor replyExecutor =
-        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-            Util.threadFactory(Util.format("MockWebServer %s WebSocket", request.getPath()),
-                true));
-    replyExecutor.allowCoreThreadTimeOut(true);
-    final RealWebSocket webSocket =
-        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
-            listener, request.getPath()) {
-          @Override protected void close() throws IOException {
-            connectionClose.countDown();
-          }
-        };
-
     // Adapt the request and response into our Request and Response domain model.
     String scheme = request.getTlsVersion() != null ? "https" : "http";
     String authority = request.getHeader("Host"); // Has host and port.
@@ -686,16 +670,27 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
         .protocol(Protocol.HTTP_1_1)
         .build();
 
-    listener.onOpen(webSocket, fancyResponse);
+    String name = request.getPath();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("MockWebServer %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
+
+    final CountDownLatch connectionClose = new CountDownLatch(1);
+    RealWebSocket webSocket =
+        new RealWebSocket(false /* is server */, source, sink, new SecureRandom(), replyExecutor,
+            response.getWebSocketListener(), fancyResponse, name) {
+          @Override protected void shutdown() {
+            connectionClose.countDown();
+          }
+        };
 
-    while (webSocket.readMessage()) {
-    }
+    webSocket.loopReader();
 
     // Even if messages are no longer being read we need to wait for the connection close signal.
     try {
       connectionClose.await();
-    } catch (InterruptedException e) {
-      throw new RuntimeException(e);
+    } catch (InterruptedException ignored) {
     }
 
     replyExecutor.shutdown();
@@ -807,6 +802,10 @@ public void setDispatcher(Dispatcher dispatcher) {
     return "MockWebServer[" + port + "]";
   }
 
+  @Override public void close() throws IOException {
+    shutdown();
+  }
+
   /** A buffer wrapper that drops data after {@code bodyLimit} bytes. */
   private static class TruncatingBuffer implements Sink {
     private final Buffer buffer = new Buffer();
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index dbeafc26de..b0a3ec06ee 100755
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -16,6 +16,7 @@
 package okhttp3.mockwebserver;
 
 import java.io.BufferedReader;
+import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -339,6 +340,11 @@
     server.shutdown();
   }
 
+  @Test public void closeViaClosable() throws IOException {
+    Closeable server = new MockWebServer();
+    server.close();
+  }
+
   @Test public void shutdownWithoutEnqueue() throws IOException {
     MockWebServer server = new MockWebServer();
     server.start();
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index 752786dd86..b65d463b51 100755
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -58,8 +58,6 @@
  * Helper methods that convert between Java and OkHttp representations.
  */
 public final class JavaApiConverter {
-  private static final RequestBody EMPTY_REQUEST_BODY = RequestBody.create(null, new byte[0]);
-
   /** Synthetic response header: the local time when the request was sent. */
   private static final String SENT_MILLIS = Platform.get().getPrefix() + "-Sent-Millis";
 
@@ -92,7 +90,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     String requestMethod = httpUrlConnection.getRequestMethod();
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request okRequest = new Request.Builder()
@@ -280,7 +278,7 @@ public static Request createOkRequest(
       URI uri, String requestMethod, Map<String, List<String>> requestHeaders) {
     // OkHttp's Call API requires a placeholder body; the real body will be streamed separately.
     RequestBody placeholderBody = HttpMethod.requiresRequestBody(requestMethod)
-        ? EMPTY_REQUEST_BODY
+        ? Util.EMPTY_REQUEST
         : null;
 
     Request.Builder builder = new Request.Builder()
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
index c95bd710c2..d1241d3d01 100755
--- a/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/OkApacheClient.java
@@ -10,6 +10,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
 import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 import org.apache.http.HttpEntityEnclosingRequest;
@@ -66,7 +67,7 @@ private static Request transformRequest(HttpRequest request) {
           builder.header(encoding.getName(), encoding.getValue());
         }
       } else {
-        body = RequestBody.create(null, new byte[0]);
+        body = Util.EMPTY_REQUEST;
       }
     }
     builder.method(method, body);
diff --git a/okhttp-ws-tests/fuzzingserver-config.json b/okhttp-tests/fuzzingserver-config.json
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-config.json
rename to okhttp-tests/fuzzingserver-config.json
diff --git a/okhttp-ws-tests/fuzzingserver-expected.txt b/okhttp-tests/fuzzingserver-expected.txt
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-expected.txt
rename to okhttp-tests/fuzzingserver-expected.txt
diff --git a/okhttp-ws-tests/fuzzingserver-test.sh b/okhttp-tests/fuzzingserver-test.sh
similarity index 90%
rename from okhttp-ws-tests/fuzzingserver-test.sh
rename to okhttp-tests/fuzzingserver-test.sh
index af89a42422..78ad71f59e 100755
--- a/okhttp-ws-tests/fuzzingserver-test.sh
+++ b/okhttp-tests/fuzzingserver-test.sh
@@ -21,7 +21,7 @@ set -ex
 wstest -m fuzzingserver -s fuzzingserver-config.json &
 sleep 2 # wait for wstest to start
 
-java -jar target/okhttp-ws-tests-*-jar-with-dependencies.jar
+java -jar target/okhttp-tests-*-jar-with-dependencies.jar
 
 jq '.[] as $in | $in | keys[] | . + " " + $in[.].behavior' target/fuzzingserver-report/index.json > target/fuzzingserver-actual.txt
 
diff --git a/okhttp-ws-tests/fuzzingserver-update-expected.sh b/okhttp-tests/fuzzingserver-update-expected.sh
similarity index 100%
rename from okhttp-ws-tests/fuzzingserver-update-expected.sh
rename to okhttp-tests/fuzzingserver-update-expected.sh
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 7202df8592..4b3a04ac78 100755
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -49,6 +49,28 @@
 
   <build>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>okhttp3.AutobahnTester</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <!-- Do not deploy this as an artifact to Maven central. -->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
diff --git a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
similarity index 84%
rename from okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
rename to okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
index 707f58c116..c9be7b6d1e 100755
--- a/okhttp-ws-tests/src/main/java/okhttp3/ws/AutobahnTester.java
+++ b/okhttp-tests/src/main/java/okhttp3/AutobahnTester.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
 import java.util.concurrent.CountDownLatch;
@@ -22,17 +22,12 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Version;
-import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
 
 /**
  * Exercises the web socket implementation against the <a
@@ -49,7 +44,7 @@ public static void main(String... args) throws IOException {
 
   private WebSocketCall newWebSocket(String path) {
     Request request = new Request.Builder().url(HOST + path).build();
-    return WebSocketCall.create(client, request);
+    return client.newWebSocketCall(request);
   }
 
   public void run() throws IOException {
@@ -67,7 +62,7 @@ public void run() throws IOException {
     }
   }
 
-  private void runTest(final long number, final long count) throws IOException {
+  private void runTest(final long number, final long count) {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong startNanos = new AtomicLong();
     newWebSocket("/runCase?case=" + number + "&agent=okhttp") //
@@ -102,7 +97,7 @@ private void runTest(final long number, final long count) throws IOException {
             });
           }
 
-          @Override public void onPong(Buffer payload) {
+          @Override public void onPong(ByteString payload) {
           }
 
           @Override public void onClose(int code, String reason) {
@@ -110,8 +105,8 @@ private void runTest(final long number, final long count) throws IOException {
             latch.countDown();
           }
 
-          @Override public void onFailure(IOException e, Response response) {
-            e.printStackTrace(System.out);
+          @Override public void onFailure(Throwable t, Response response) {
+            t.printStackTrace(System.out);
             latch.countDown();
           }
         });
@@ -131,7 +126,7 @@ private void runTest(final long number, final long count) throws IOException {
   private long getTestCount() throws IOException {
     final CountDownLatch latch = new CountDownLatch(1);
     final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
     newWebSocket("/getCaseCount").enqueue(new WebSocketListener() {
       @Override public void onOpen(WebSocket webSocket, Response response) {
       }
@@ -141,15 +136,15 @@ private long getTestCount() throws IOException {
         message.close();
       }
 
-      @Override public void onPong(Buffer payload) {
+      @Override public void onPong(ByteString payload) {
       }
 
       @Override public void onClose(int code, String reason) {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
-        failureRef.set(e);
+      @Override public void onFailure(Throwable t, Response response) {
+        failureRef.set(t);
         latch.countDown();
       }
     });
@@ -160,9 +155,9 @@ private long getTestCount() throws IOException {
     } catch (InterruptedException e) {
       throw new AssertionError();
     }
-    IOException failure = failureRef.get();
+    Throwable failure = failureRef.get();
     if (failure != null) {
-      throw failure;
+      throw new RuntimeException(failure);
     }
     return countRef.get();
   }
@@ -176,14 +171,14 @@ private void updateReports() {
       @Override public void onMessage(ResponseBody message) throws IOException {
       }
 
-      @Override public void onPong(Buffer payload) {
+      @Override public void onPong(ByteString payload) {
       }
 
       @Override public void onClose(int code, String reason) {
         latch.countDown();
       }
 
-      @Override public void onFailure(IOException e, Response response) {
+      @Override public void onFailure(Throwable t, Response response) {
         latch.countDown();
       }
     });
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index bbc2a59bbd..02c25f41c9 100755
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -1249,7 +1249,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .build();
 
     // Store a response in the cache.
-    long request1At = System.currentTimeMillis();
+    long request1SentAt = System.currentTimeMillis();
     executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
         .assertCode(200)
         .assertHeader("Donut", "a")
@@ -1273,8 +1273,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestHeader("Accept-Language", "en-US")
         .assertRequestHeader("Accept-Charset", "UTF-8")
         .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
-        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
+        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
 
     // Check the cached response. Its request contains only the saved Vary headers.
     cacheHit.cacheResponse()
@@ -1285,8 +1285,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
         .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
         .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
-        .assertSentRequestAtMillis(request1At, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1At, request1ReceivedAt);
+        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
+        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
 
     // Check the network response. It has the caller's request, plus some caching headers.
     cacheHit.networkResponse()
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index c6ac7d09f9..d906affb04 100755
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -75,10 +75,12 @@
         .add("foo: bar")
         .add(" foo: baz") // Name leading whitespace is trimmed.
         .add("foo : bak") // Name trailing whitespace is trimmed.
+        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
         .add("ping:  pong  ") // Value whitespace is trimmed.
         .add("kit:kat") // Space after colon is not required.
         .build();
     assertEquals(Arrays.asList("bar", "baz", "bak"), headers.values("foo"));
+    assertEquals(Arrays.asList("value"), headers.values("key"));
     assertEquals(Arrays.asList("pong"), headers.values("ping"));
     assertEquals(Arrays.asList("kat"), headers.values("kit"));
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index a5a8664a87..35d2f67906 100755
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -258,4 +258,17 @@
     } catch (IllegalArgumentException expected) {
     }
   }
+
+  @Test public void partAccessors() throws IOException {
+    MultipartBody body = new MultipartBody.Builder()
+        .addPart(Headers.of("Foo", "Bar"), RequestBody.create(null, "Baz"))
+        .build();
+    assertEquals(1, body.parts().size());
+
+    Buffer part1Buffer = new Buffer();
+    MultipartBody.Part part1 = body.part(0);
+    part1.body().writeTo(part1Buffer);
+    assertEquals(Headers.of("Foo", "Bar"), part1.headers());
+    assertEquals("Baz", part1Buffer.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index feaab57bfe..3410775b6c 100755
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -19,7 +19,6 @@
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Date;
-import okhttp3.ws.WebSocket;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 4668f6005d..bd6092b4a8 100755
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -198,11 +198,20 @@
     }
   }
 
+  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+    Request.Builder builder = new Request.Builder();
+    builder.header("key", "sample\tvalue");
+    try {
+      builder.header("sample\tkey", "value");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void headerForbidsControlCharacters() throws Exception {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
-    assertForbiddenHeader("\t");
     assertForbiddenHeader("\u001f");
     assertForbiddenHeader("\u007f");
     assertForbiddenHeader("\u0080");
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
new file mode 100755
index 0000000000..beba4bd0d8
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.ForwardingSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class ResponseBodyTest {
+  @Test public void stringEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", body.string());
+  }
+
+  @Test public void stringLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", body.string());
+  }
+
+  @Test public void stringDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomOverridesExplicitCharset() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf8() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.string());
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals("", exhaust(body.charStream()));
+  }
+
+  @Test public void readerLooksLikeBomButTooShort() throws IOException {
+    ResponseBody body = body("000048");
+    assertEquals("\0\0H", exhaust(body.charStream()));
+  }
+
+  @Test public void readerDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf8() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Be() throws IOException {
+    ResponseBody body = body("feff00680065006c006c006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf16Le() throws IOException {
+    ResponseBody body = body("fffe680065006c006c006f00");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerBomUtf32Le() throws IOException {
+    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", exhaust(body.charStream()));
+  }
+
+  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.charStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        ResponseBody body = body("fffe680065006c006c006f00");
+        return Okio.buffer(new ForwardingSource(body.source()) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    Reader reader = body.charStream();
+    assertEquals('h', reader.read());
+    reader.close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void sourceEmpty() throws IOException {
+    ResponseBody body = body("");
+    BufferedSource source = body.source();
+    assertTrue(source.exhausted());
+    assertEquals("", source.readUtf8());
+  }
+
+  @Test public void sourceSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    BufferedSource source = body.source();
+    assertEquals(0xef, source.readByte() & 0xff);
+    assertEquals(0xbb, source.readByte() & 0xff);
+    assertEquals(0xff, source.readByte() & 0xff);
+    assertEquals("hello", source.readUtf8());
+  }
+
+  @Test public void sourceClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.source().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesEmpty() throws IOException {
+    ResponseBody body = body("");
+    assertEquals(0, body.bytes().length);
+  }
+
+  @Test public void bytesSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    byte[] bytes = body.bytes();
+    assertEquals(0xef, bytes[0] & 0xff);
+    assertEquals(0xbb, bytes[1] & 0xff);
+    assertEquals(0xff, bytes[2] & 0xff);
+    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+  }
+
+  @Test public void bytesClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    assertEquals(5, body.bytes().length);
+    assertTrue(closed.get());
+  }
+
+  @Test public void bytesThrowsWhenLengthsDisagree() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 10;
+      }
+
+      @Override public BufferedSource source() {
+        return new Buffer().writeUtf8("hello");
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Content-Length (10) and stream length (5) disagree", e.getMessage());
+    }
+  }
+
+  @Test public void bytesThrowsMoreThanIntMaxValue() {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return Integer.MAX_VALUE + 1L;
+      }
+
+      @Override public BufferedSource source() {
+        throw new AssertionError();
+      }
+    };
+    try {
+      body.bytes();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Cannot buffer entire body for content length: 2147483648", e.getMessage());
+    }
+  }
+
+  @Test public void byteStreamEmpty() throws IOException {
+    ResponseBody body = body("");
+    InputStream bytes = body.byteStream();
+    assertEquals(-1, bytes.read());
+  }
+
+  @Test public void byteStreamSeesBom() throws IOException {
+    ResponseBody body = body("efbbff68656c6c6f");
+    InputStream bytes = body.byteStream();
+    assertEquals(0xef, bytes.read());
+    assertEquals(0xbb, bytes.read());
+    assertEquals(0xff, bytes.read());
+    assertEquals("hello", exhaust(new InputStreamReader(bytes, "utf-8")));
+  }
+
+  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
+    final AtomicBoolean closed = new AtomicBoolean();
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            closed.set(true);
+            super.close();
+          }
+        });
+      }
+    };
+    body.byteStream().close();
+    assertTrue(closed.get());
+  }
+
+  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
+    ResponseBody body = new ResponseBody() {
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public long contentLength() {
+        return 5;
+      }
+
+      @Override public BufferedSource source() {
+        Buffer source = new Buffer().writeUtf8("hello");
+        return Okio.buffer(new ForwardingSource(source) {
+          @Override public void close() throws IOException {
+            throw new IOException("Broken!");
+          }
+        });
+      }
+    };
+    assertEquals("hello", body.source().readUtf8());
+    body.close();
+  }
+
+  static ResponseBody body(String hex) {
+    return body(hex, null);
+  }
+
+  static ResponseBody body(String hex, String charset) {
+    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+  }
+
+  static String exhaust(Reader reader) throws IOException {
+    StringBuilder builder = new StringBuilder();
+    char[] buf = new char[10];
+    int read;
+    while ((read = reader.read(buf)) != -1) {
+      builder.append(buf, 0, read);
+    }
+    return builder.toString();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index d3745e1a0d..0ec9bc34fb 100755
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,38 +15,38 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
-import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.logging.Handler;
 import java.util.logging.LogRecord;
-import java.util.logging.SimpleFormatter;
 
 /**
  * A log handler that records which log messages were published so that a calling test can make
  * assertions about them.
  */
 public final class TestLogHandler extends Handler {
-  private final List<String> logs = new ArrayList<>();
+  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
 
-  @Override public synchronized void publish(LogRecord logRecord) {
+  @Override public void publish(LogRecord logRecord) {
     if (getFormatter() == null) {
       logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
     } else {
       logs.add(getFormatter().format(logRecord));
     }
-    notifyAll();
   }
 
   @Override public void flush() {
   }
 
-  @Override public void close() throws SecurityException {
+  @Override public void close() {
   }
 
-  public synchronized String take() throws InterruptedException {
-    while (logs.isEmpty()) {
-      wait();
+  public String take() throws InterruptedException {
+    String message = logs.poll(10, TimeUnit.SECONDS);
+    if (message == null) {
+      throw new AssertionError("Timed out waiting for log message.");
     }
-    return logs.remove(0);
+    return message;
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
new file mode 100755
index 0000000000..d7eadbedb9
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/WebSocketCallTest.java
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.logging.Logger;
+import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.ws.EmptyWebSocketListener;
+import okhttp3.internal.ws.WebSocketRecorder;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+public final class WebSocketCallTest {
+  @Rule public final MockWebServer webServer = new MockWebServer();
+
+  private final SslClient sslClient = SslClient.localhost();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
+  private final Random random = new Random(0);
+  private OkHttpClient client = new OkHttpClient.Builder()
+      .addInterceptor(new Interceptor() {
+        @Override public Response intercept(Chain chain) throws IOException {
+          Response response = chain.proceed(chain.request());
+          assertNotNull(response.body()); // Ensure application interceptors never see a null body.
+          return response;
+        }
+      })
+      .build();
+
+  @After public void tearDown() {
+    clientListener.assertExhausted();
+  }
+
+  @Test public void textMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    serverListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void binaryMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
+    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
+  }
+
+  @Test public void nullMessageThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("message == null", e.getMessage());
+    }
+  }
+
+  @Test public void missingContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(null, "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void unknownContentTypeThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals(
+          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
+          e.getMessage());
+    }
+  }
+
+  @Test public void pingPong() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+
+    client.sendPing(ByteString.encodeUtf8("Hello, WebSockets!"));
+    clientListener.assertPong(ByteString.encodeUtf8("Hello, WebSockets!"));
+  }
+
+  @Test public void nullPingPayloadThrows() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    try {
+      client.sendPing(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("payload == null", e.getMessage());
+    }
+  }
+
+  @Test public void serverMessage() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertTextMessage("Hello, WebSockets!");
+  }
+
+  @Test public void throwingOnOpenClosesAndFails() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        throw e;
+      }
+    });
+    enqueueClientWebSocket();
+
+    serverListener.assertOpen();
+    serverListener.assertClose(1001, "");
+    clientListener.assertFailure(e);
+  }
+
+  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
+  @Test public void throwingOnFailLogs() throws InterruptedException {
+    TestLogHandler logs = new TestLogHandler();
+    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
+    logger.addHandler(logs);
+
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onFailure(Throwable t, Response response) {
+        throw e;
+      }
+    });
+
+    enqueueClientWebSocket();
+
+    assertEquals("", logs.take());
+    logger.removeHandler(logs);
+  }
+
+  @Test public void throwingOnMessageClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onMessage(ResponseBody message) {
+        throw e;
+      }
+    });
+
+    server.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnOnPongClosesAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onPong(ByteString payload) {
+        throw e;
+      }
+    });
+
+    client.sendPing(ByteString.EMPTY);
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1001, "");
+  }
+
+  @Test public void throwingOnCloseClosesNormallyAndFails() throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    final RuntimeException e = new RuntimeException();
+    clientListener.setNextEventDelegate(new EmptyWebSocketListener() {
+      @Override public void onClose(int code, String reason) {
+        throw e;
+      }
+    });
+
+    server.close(1000, "bye");
+    clientListener.assertFailure(e);
+    serverListener.assertClose(1000, "bye");
+  }
+
+  @Test public void non101RetainsBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(200, "Body", ProtocolException.class,
+        "Expected HTTP 101 response but was '200 OK'");
+  }
+
+  @Test public void notFound() throws IOException {
+    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(404, null, ProtocolException.class,
+        "Expected HTTP 101 response but was '404 Not Found'");
+  }
+
+  @Test public void clientTimeoutClosesBody() throws IOException {
+    webServer.enqueue(new MockResponse().setResponseCode(408));
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    enqueueClientWebSocket();
+
+    WebSocket client = clientListener.assertOpen();
+
+    client.sendPing(ByteString.encodeUtf8("WebSockets are fun!"));
+    clientListener.assertPong(ByteString.encodeUtf8("WebSockets are fun!"));
+  }
+
+  @Test public void missingConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'null'");
+  }
+
+  @Test public void wrongConnectionHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Connection", "Downgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
+  }
+
+  @Test public void missingUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'null'");
+  }
+
+  @Test public void wrongUpgradeHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "Pepsi")
+        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
+  }
+
+  @Test public void missingMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
+  }
+
+  @Test public void wrongMagicHeader() throws IOException {
+    webServer.enqueue(new MockResponse()
+        .setResponseCode(101)
+        .setHeader("Connection", "Upgrade")
+        .setHeader("Upgrade", "websocket")
+        .setHeader("Sec-WebSocket-Accept", "magic"));
+    enqueueClientWebSocket();
+
+    clientListener.assertFailure(101, null, ProtocolException.class,
+        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
+  }
+
+  @Test public void wsScheme() throws IOException {
+    websocketScheme("ws");
+  }
+
+  @Test public void wsUppercaseScheme() throws IOException {
+    websocketScheme("WS");
+  }
+
+  @Test public void wssScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("wss");
+  }
+
+  @Test public void httpsScheme() throws IOException {
+    webServer.useHttps(sslClient.socketFactory, false);
+    client = client.newBuilder()
+        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+
+    websocketScheme("https");
+  }
+
+  private void websocketScheme(String scheme) throws IOException {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+
+    Request request = new Request.Builder()
+        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
+        .build();
+
+    enqueueClientWebSocket(request);
+    WebSocket webSocket = clientListener.assertOpen();
+    serverListener.assertOpen();
+
+    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
+    serverListener.assertTextMessage("abc");
+  }
+
+  private void enqueueClientWebSocket() {
+    enqueueClientWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
+  }
+
+  private void enqueueClientWebSocket(Request request) {
+    WebSocketCall call = new RealWebSocketCall(client, request, random);
+    call.enqueue(clientListener);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 99d54a4fdb..6a90ac0458 100755
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -925,6 +925,97 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(expected, actual);
   }
 
+  @Test public void staticTableIndexedHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
+    assertBytes(0x82);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
+    assertBytes(0x83);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/"));
+    assertBytes(0x84);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
+    assertBytes(0x85);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
+    assertBytes(0x86);
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
+    assertBytes(0x87);
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void dynamicTableIndexedHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0x40,
+        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
+        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void doNotIndexPseudoHeaders() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
+    assertBytes(0x02, 3, 'P', 'U', 'T');
+    assertEquals(0, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
+    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
+    assertEquals(0, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+
+    // If the :authority header somehow changes, it should be re-added to the dynamic table.
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
+    assertBytes(0xbe);
+    assertEquals(1, hpackWriter.headerCount);
+  }
+
+  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
+    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
+    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
+    assertEquals(1, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
+    assertEquals(2, hpackWriter.headerCount);
+
+    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
+    assertBytes(0xbe);
+    assertEquals(2, hpackWriter.headerCount);
+  }
+
   private Hpack.Reader newReader(Buffer source) {
     return new Hpack.Reader(4096, source);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
new file mode 100755
index 0000000000..f3ba32e464
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/EmptyWebSocketListener.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+public class EmptyWebSocketListener implements WebSocketListener {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+  }
+
+  @Override public void onPong(ByteString payload) {
+  }
+
+  @Override public void onClose(int code, String reason) {
+  }
+
+  @Override public void onFailure(Throwable t, Response response) {
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
similarity index 75%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index 90a803ec14..7a23b269cc 100755
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -21,8 +21,10 @@
 import java.util.Random;
 import java.util.concurrent.Executor;
 import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
 import okhttp3.RequestBody;
-import okhttp3.ws.WebSocketRecorder;
+import okhttp3.Response;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -35,8 +37,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.TEXT;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -53,34 +54,39 @@
   private boolean clientConnectionCloseThrows;
   private boolean clientConnectionClosed;
   private final MemorySocket client2Server = new MemorySocket();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder();
+  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
 
   private final Executor serverExecutor = new SynchronousExecutor();
   private RealWebSocket server;
   private boolean serverConnectionClosed;
   private final MemorySocket server2client = new MemorySocket();
-  private final WebSocketRecorder serverListener = new WebSocketRecorder();
+  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
 
   @Before public void setUp() {
     Random random = new Random(0);
     String url = "http://example.com/websocket";
+    Response response = new Response.Builder()
+        .code(101)
+        .request(new Request.Builder().url(url).build())
+        .protocol(Protocol.HTTP_1_1)
+        .build();
 
     client = new RealWebSocket(true, server2client.source(), client2Server.sink(), random,
-        clientExecutor, clientListener, url) {
-      @Override protected void close() throws IOException {
+        clientExecutor, clientListener, response, url) {
+      @Override protected void shutdown() {
         if (clientConnectionClosed) {
           throw new AssertionError("Already closed");
         }
         clientConnectionClosed = true;
 
         if (clientConnectionCloseThrows) {
-          throw new IOException("Oops!");
+          throw new RuntimeException("Oops!");
         }
       }
     };
     server = new RealWebSocket(false, client2Server.source(), server2client.sink(), random,
-        serverExecutor, serverListener, url) {
-      @Override protected void close() throws IOException {
+        serverExecutor, serverListener, response, url) {
+      @Override protected void shutdown() {
         if (serverConnectionClosed) {
           throw new AssertionError("Already closed");
         }
@@ -94,48 +100,6 @@
     serverListener.assertExhausted();
   }
 
-  @Test public void nullMessageThrows() throws IOException {
-    try {
-      client.sendMessage(null);
-      fail();
-    } catch (NullPointerException e) {
-      assertEquals("message == null", e.getMessage());
-    }
-  }
-
-  @Test public void textMessage() throws IOException {
-    client.sendMessage(RequestBody.create(TEXT, "Hello!"));
-    server.readMessage();
-    serverListener.assertTextMessage("Hello!");
-  }
-
-  @Test public void binaryMessage() throws IOException {
-    client.sendMessage(RequestBody.create(BINARY, "Hello!"));
-    server.readMessage();
-    serverListener.assertBinaryMessage(new byte[] {'H', 'e', 'l', 'l', 'o', '!'});
-  }
-
-  @Test public void missingContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(null, "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
-  @Test public void unknownContentTypeThrows() throws IOException {
-    try {
-      client.sendMessage(RequestBody.create(MediaType.parse("text/plain"), "Hey!"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals(
-          "Unknown message content type: text/plain. Must use WebSocket.TEXT or WebSocket.BINARY.",
-          e.getMessage());
-    }
-  }
-
   @Test public void streamingMessage() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
@@ -149,11 +113,11 @@
       }
     };
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
   }
 
-  @Test public void streamingMessageCanInterleavePing() throws IOException, InterruptedException {
+  @Test public void streamingMessageCanInterleavePing() throws IOException {
     RequestBody message = new RequestBody() {
       @Override public MediaType contentType() {
         return TEXT;
@@ -161,37 +125,46 @@
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
         sink.writeUtf8("Hel").flush();
-        client.sendPing(new Buffer().writeUtf8("Pong?"));
+        client.sendPing(ByteString.encodeUtf8("Pong?"));
         sink.writeUtf8("lo!").flush();
         sink.close();
       }
     };
 
     client.sendMessage(message);
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertTextMessage("Hello!");
-    client.readMessage();
-    clientListener.assertPong(new Buffer().writeUtf8("Pong?"));
+    client.processNextFrame();
+    clientListener.assertPong(ByteString.encodeUtf8("Pong?"));
   }
 
-  @Test public void pingWritesPong() throws IOException, InterruptedException {
-    client.sendPing(new Buffer().writeUtf8("Hello!"));
-    server.readMessage(); // Read the ping, write the pong.
-    client.readMessage(); // Read the pong.
-    clientListener.assertPong(new Buffer().writeUtf8("Hello!"));
+  @Test public void pingWritesPong() throws IOException {
+    client.sendPing(ByteString.encodeUtf8("Hello!"));
+    server.processNextFrame(); // Read the ping, write the pong.
+    client.processNextFrame(); // Read the pong.
+    clientListener.assertPong(ByteString.encodeUtf8("Hello!"));
   }
 
   @Test public void unsolicitedPong() throws IOException {
-    client.sendPong(new Buffer().writeUtf8("Hello!"));
-    server.readMessage();
-    serverListener.assertPong(new Buffer().writeUtf8("Hello!"));
+    client.sendPong(ByteString.encodeUtf8("Hello!"));
+    server.processNextFrame();
+    serverListener.assertPong(ByteString.encodeUtf8("Hello!"));
+  }
+
+  @Test public void nullPongPayloadThrows() throws IOException {
+    try {
+      client.sendPong(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertEquals("payload == null", e.getMessage());
+    }
   }
 
   @Test public void close() throws IOException {
     client.close(1000, "Hello!");
-    assertFalse(server.readMessage()); // This will trigger a close response.
+    assertFalse(server.processNextFrame()); // This will trigger a close response.
     serverListener.assertClose(1000, "Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Hello!");
   }
 
@@ -199,7 +172,7 @@
     client.close(1000, "Hello!");
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      client.sendPing(ByteString.encodeUtf8("Pong?"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("closed", e.getMessage());
@@ -222,7 +195,7 @@
     client2Server.close();
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IOException ignored) {
     }
@@ -235,7 +208,7 @@
       assertEquals("must call close()", e.getMessage());
     }
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("must call close()", e.getMessage());
@@ -259,7 +232,7 @@
       assertEquals("must call close()", e.getMessage());
     }
     try {
-      client.sendPing(new Buffer().writeUtf8("Ping!"));
+      client.sendPing(ByteString.encodeUtf8("Ping!"));
       fail();
     } catch (IllegalStateException e) {
       assertEquals("must call close()", e.getMessage());
@@ -268,11 +241,11 @@
 
   @Test public void serverCloseThenWritingPingThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
-      client.sendPing(new Buffer().writeUtf8("Pong?"));
+      client.sendPing(ByteString.encodeUtf8("Pong?"));
       fail();
     } catch (IOException e) {
       assertEquals("closed", e.getMessage());
@@ -281,7 +254,7 @@
 
   @Test public void serverCloseThenWritingMessageThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -294,7 +267,7 @@
 
   @Test public void serverCloseThenWritingCloseThrows() throws IOException {
     server.close(1000, "Hello!");
-    client.readMessage();
+    client.processNextFrame();
     clientListener.assertClose(1000, "Hello!");
 
     try {
@@ -316,7 +289,7 @@
         sink.writeUtf8("Hel").flush();
 
         server.close(1000, "Hello!");
-        client.readMessage();
+        client.processNextFrame();
         clientListener.assertClose(1000, "Hello!");
 
         try {
@@ -339,10 +312,10 @@
   @Test public void clientCloseClosesConnection() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed);
-    server.readMessage(); // Read client close, send server close.
+    server.processNextFrame(); // Read client close, send server close.
     serverListener.assertClose(1000, "Hello!");
 
-    client.readMessage(); // Read server close, close connection.
+    client.processNextFrame(); // Read server close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
   }
@@ -350,11 +323,11 @@
   @Test public void serverCloseClosesConnection() throws IOException {
     server.close(1000, "Hello!");
 
-    client.readMessage(); // Read server close, send client close, close connection.
+    client.processNextFrame(); // Read server close, send client close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
   }
 
@@ -364,11 +337,11 @@
     client.close(1000, "Hi!");
     assertFalse(clientConnectionClosed);
 
-    client.readMessage(); // Read close, close connection close.
+    client.processNextFrame(); // Read close, close connection close.
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Hello!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hi!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
@@ -378,38 +351,61 @@
   @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
     server.sendMessage(RequestBody.create(TEXT, "Hello!"));
     server.close(1000, "Bye!");
-    assertTrue(client.readMessage());
+    assertTrue(client.processNextFrame());
     clientListener.assertTextMessage("Hello!");
-    assertFalse(client.readMessage());
+    assertFalse(client.processNextFrame());
     clientListener.assertClose(1000, "Bye!");
   }
 
-  @Test public void protocolErrorBeforeCloseSendsClose() throws IOException {
+  @Test public void protocolErrorBeforeCloseSendsClose() {
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, send close, close connection.
+    client.processNextFrame(); // Detects error, send close, close connection.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1002, "");
   }
 
+  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
+    client.close(1000, "Hello");
+    assertFalse(clientConnectionClosed); // Not closed until close reply is received.
+
+    // Manually write an invalid masked close frame.
+    server2client.raw().write(ByteString.decodeHex("888760b420bb635c68de0cd84f"));
+
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
+    assertTrue(clientConnectionClosed);
+    clientListener.assertFailure(ProtocolException.class, "Server-sent frames must not be masked.");
+
+    server.processNextFrame();
+    serverListener.assertClose(1000, "Hello");
+
+    serverListener.assertExhausted(); // Client should not have sent second close.
+  }
+
   @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
     client.close(1000, "Hello!");
     assertFalse(clientConnectionClosed); // Not closed until close reply is received.
     server2client.raw().write(ByteString.decodeHex("0a00")); // Invalid non-final ping frame.
 
-    client.readMessage(); // Detects error, closes connection immediately since close already sent.
+    client.processNextFrame(); // Detects error, closes connection immediately since close already sent.
     assertTrue(clientConnectionClosed);
     clientListener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Hello!");
 
     serverListener.assertExhausted(); // Client should not have sent second close.
   }
 
+  @Test public void networkErrorReportedAsCloseNotFailure() {
+    server2client.close();
+    client.processNextFrame();
+    clientListener.assertClose(1006, "");
+  }
+
   @Test public void closeThrowingClosesConnection() {
     client2Server.close();
 
@@ -421,7 +417,7 @@
     assertTrue(clientConnectionClosed);
   }
 
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
+  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() {
     client2Server.close();
     clientConnectionCloseThrows = true;
 
@@ -438,11 +434,11 @@
     clientConnectionCloseThrows = true;
 
     server.close(1000, "Bye!");
-    client.readMessage();
+    client.processNextFrame();
     assertTrue(clientConnectionClosed);
     clientListener.assertClose(1000, "Bye!");
 
-    server.readMessage();
+    server.processNextFrame();
     serverListener.assertClose(1000, "Bye!");
   }
 
@@ -469,7 +465,7 @@ BufferedSource source() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
@@ -482,14 +478,14 @@ BufferedSink sink() {
           buffer.write(source, byteCount);
         }
 
-        @Override public void flush() throws IOException {
+        @Override public void flush() {
         }
 
         @Override public Timeout timeout() {
           return Timeout.NONE;
         }
 
-        @Override public void close() throws IOException {
+        @Override public void close() {
           closed = true;
         }
       });
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
similarity index 92%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 6bb7ef86d8..f1ae34e51f 100755
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -23,8 +23,6 @@
 import java.util.regex.Pattern;
 import okhttp3.ResponseBody;
 import okhttp3.internal.Util;
-import okhttp3.ws.WebSocketRecorder;
-import okhttp3.ws.WebSocketRecorder.MessageDelegate;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -38,12 +36,12 @@
 
 public final class WebSocketReaderTest {
   private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder();
+  private final WebSocketRecorder callback = new WebSocketRecorder("client");
   private final Random random = new Random(0);
 
   // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketReader serverReader = new WebSocketReader(false, data, callback);
-  private final WebSocketReader clientReader = new WebSocketReader(true, data, callback);
+  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
+  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
 
   @After public void tearDown() {
     callback.assertExhausted();
@@ -91,7 +89,7 @@
       serverReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Client-sent frames must be masked.", e.getMessage());
     }
   }
 
@@ -101,7 +99,7 @@
       clientReader.processNextFrame();
       fail();
     } catch (ProtocolException e) {
-      assertEquals("Client-sent frames must be masked. Server sent must not.", e.getMessage());
+      assertEquals("Server-sent frames must not be masked.", e.getMessage());
     }
   }
 
@@ -153,7 +151,7 @@
     data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         BufferedSource source = message.source();
         source.readFully(sink, 3); // Read "Hel"
@@ -182,10 +180,10 @@
     data.write(ByteString.decodeHex("8a00")); // Pong
     data.write(ByteString.decodeHex("80026c6f")); // lo
     clientReader.processNextFrame();
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
-    callback.assertPong(null);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
     callback.assertTextMessage("Hello");
   }
 
@@ -254,7 +252,7 @@
 
   @Test public void noCloseErrors() throws IOException {
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody body) throws IOException {
         body.source().readAll(new Buffer());
       }
@@ -272,7 +270,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 3);
         message.close();
@@ -294,7 +292,7 @@
     data.write(ByteString.decodeHex("810448657921")); // Hey!
 
     final Buffer sink = new Buffer();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.source().read(sink, 2);
         message.close();
@@ -303,8 +301,8 @@
 
     clientReader.processNextFrame();
     assertEquals("He", sink.readUtf8());
-    callback.assertPong(null);
-    callback.assertPong(null);
+    callback.assertPong(ByteString.EMPTY);
+    callback.assertPong(ByteString.EMPTY);
 
     clientReader.processNextFrame();
     callback.assertTextMessage("Hey!");
@@ -314,7 +312,7 @@
     data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
 
     final AtomicReference<Exception> exception = new AtomicReference<>();
-    callback.setNextMessageDelegate(new MessageDelegate() {
+    callback.setNextEventDelegate(new EmptyWebSocketListener() {
       @Override public void onMessage(ResponseBody message) throws IOException {
         message.close();
         try {
@@ -333,19 +331,19 @@
   @Test public void emptyPingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8900")); // Empty ping
     clientReader.processNextFrame();
-    callback.assertPing(null);
+    callback.assertPing(ByteString.EMPTY);
   }
 
   @Test public void pingCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
     clientReader.processNextFrame();
-    callback.assertPing(new Buffer().writeUtf8("Hello"));
+    callback.assertPing(ByteString.encodeUtf8("Hello"));
   }
 
   @Test public void emptyCloseCallsCallback() throws IOException {
     data.write(ByteString.decodeHex("8800")); // Empty close
     clientReader.processNextFrame();
-    callback.assertClose(1000, "");
+    callback.assertClose(1005, "");
   }
 
   @Test public void closeLengthOfOneThrows() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
new file mode 100755
index 0000000000..91510cdf56
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+import okhttp3.MediaType;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.ByteString;
+
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class WebSocketRecorder implements WebSocketListener {
+  private final String name;
+  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
+  private WebSocketListener delegate;
+
+  public WebSocketRecorder(String name) {
+    this.name = name;
+  }
+
+  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
+  public void setNextEventDelegate(WebSocketListener delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onOpen", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onOpen(webSocket, response);
+    } else {
+      events.add(new Open(webSocket, response));
+    }
+  }
+
+  @Override public void onMessage(ResponseBody message) throws IOException {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onMessage", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onMessage(message);
+    } else {
+      Message event = new Message(message.contentType());
+      message.source().readAll(event.buffer);
+      message.close();
+      events.add(event);
+    }
+  }
+
+  @Override public void onPong(ByteString payload) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onPong", null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onPong(payload);
+    } else {
+      events.add(new Pong(payload));
+    }
+  }
+
+  @Override public void onClose(int code, String reason) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onClose " + code, null);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onClose(code, reason);
+    } else {
+      events.add(new Close(code, reason));
+    }
+  }
+
+  @Override public void onFailure(Throwable t, Response response) {
+    Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
+
+    WebSocketListener delegate = this.delegate;
+    if (delegate != null) {
+      this.delegate = null;
+      delegate.onFailure(t, response);
+    } else {
+      events.add(new Failure(t, response));
+    }
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, TimeUnit.SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertTextMessage(String payload) {
+    Message message = new Message(TEXT);
+    message.buffer.writeUtf8(payload);
+    Object actual = nextEvent();
+    assertEquals(message, actual);
+  }
+
+  public void assertBinaryMessage(byte[] payload) {
+    Message message = new Message(BINARY);
+    message.buffer.write(payload);
+    Object actual = nextEvent();
+    assertEquals(message, actual);
+  }
+
+  public void assertPong(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Pong(payload), actual);
+  }
+
+  public void assertClose(int code, String reason) {
+    Object actual = nextEvent();
+    assertEquals(new Close(code, reason), actual);
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public WebSocket assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).webSocket;
+  }
+
+  public void assertFailure(Throwable t) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertSame(t, failure.t);
+  }
+
+  public void assertFailure(Class<? extends IOException> cls, String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertNull(failure.response);
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
+      throws IOException {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    Failure failure = (Failure) event;
+    assertEquals(code, failure.response.code());
+    if (body != null) {
+      assertEquals(body, failure.response.body().string());
+    }
+    assertEquals(cls, failure.t.getClass());
+    assertEquals(message, failure.t.getMessage());
+  }
+
+  static final class Open {
+    final WebSocket webSocket;
+    final Response response;
+
+    Open(WebSocket webSocket, Response response) {
+      this.webSocket = webSocket;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + "]";
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Message {
+    public final MediaType mediaType;
+    public final Buffer buffer = new Buffer();
+
+    Message(MediaType mediaType) {
+      this.mediaType = mediaType;
+    }
+
+    @Override public String toString() {
+      return "Message[" + mediaType + " " + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return mediaType.hashCode() * 37 + buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Message) {
+        Message other = (Message) obj;
+        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+
+  static final class Pong {
+    public final ByteString payload;
+
+    Pong(ByteString payload) {
+      this.payload = payload;
+    }
+
+    @Override public String toString() {
+      return "Pong[" + payload + "]";
+    }
+
+    @Override public int hashCode() {
+      return payload.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Pong) {
+        Pong other = (Pong) obj;
+        return payload == null ? other.payload == null : payload.equals(other.payload);
+      }
+      return false;
+    }
+  }
+
+  static final class Close {
+    public final int code;
+    public final String reason;
+
+    Close(int code, String reason) {
+      this.code = code;
+      this.reason = reason;
+    }
+
+    @Override public String toString() {
+      return "Close[" + code + " " + reason + "]";
+    }
+
+    @Override public int hashCode() {
+      return code * 37 + reason.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Close) {
+        Close other = (Close) obj;
+        return code == other.code && reason.equals(other.reason);
+      }
+      return false;
+    }
+  }
+
+  /** Expose this recorder as a frame callback and shim in "ping" events. */
+  WebSocketReader.FrameCallback asFrameCallback() {
+    return new WebSocketReader.FrameCallback() {
+      @Override public void onReadMessage(ResponseBody body) throws IOException {
+        onMessage(body);
+      }
+
+      @Override public void onReadPing(ByteString payload) {
+        events.add(new Ping(payload));
+      }
+
+      @Override public void onReadPong(ByteString padload) {
+        onPong(padload);
+      }
+
+      @Override public void onReadClose(int code, String reason) {
+        onClose(code, reason);
+      }
+    };
+  }
+
+  void assertPing(ByteString payload) {
+    Object actual = nextEvent();
+    assertEquals(new Ping(payload), actual);
+  }
+
+  static final class Ping {
+    public final ByteString buffer;
+
+    Ping(ByteString buffer) {
+      this.buffer = buffer;
+    }
+
+    @Override public String toString() {
+      return "Ping[" + buffer + "]";
+    }
+
+    @Override public int hashCode() {
+      return buffer.hashCode();
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (obj instanceof Ping) {
+        Ping other = (Ping) obj;
+        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
+      }
+      return false;
+    }
+  }
+}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
similarity index 95%
rename from okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
rename to okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index 384151cf4a..bb4d43ec10 100755
--- a/okhttp-ws-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -306,48 +306,48 @@
   }
 
   @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(null);
+    serverWriter.writePing(ByteString.EMPTY);
     assertData("8900");
   }
 
   @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(null);
+    clientWriter.writePing(ByteString.EMPTY);
     assertData("898060b420bb");
   }
 
   @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("890548656c6c6f");
   }
 
   @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
     assertData("898560b420bb28d14cd70f");
   }
 
   @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(null);
+    serverWriter.writePong(ByteString.EMPTY);
     assertData("8a00");
   }
 
   @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(null);
+    clientWriter.writePong(ByteString.EMPTY);
     assertData("8a8060b420bb");
   }
 
   @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(new Buffer().writeUtf8("Hello"));
+    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a0548656c6c6f");
   }
 
   @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(new Buffer().writeUtf8("Hello"));
+    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
     assertData("8a8560b420bb28d14cd70f");
   }
 
   @Test public void pingTooLongThrows() throws IOException {
     try {
-      serverWriter.writePing(new Buffer().write(binaryData(1000)));
+      serverWriter.writePing(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
@@ -356,7 +356,7 @@
 
   @Test public void pongTooLongThrows() throws IOException {
     try {
-      serverWriter.writePong(new Buffer().write(binaryData(1000)));
+      serverWriter.writePong(ByteString.of(binaryData(1000)));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("Payload size must be less than or equal to 125", e.getMessage());
diff --git a/okhttp-ws-tests/pom.xml b/okhttp-ws-tests/pom.xml
deleted file mode 100755
index d8a43e09a8..0000000000
--- a/okhttp-ws-tests/pom.xml
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws-tests</artifactId>
-  <name>OkHttp Web Socket Tests</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp-testing-support</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-          <archive>
-            <manifest>
-              <mainClass>okhttp3.ws.AutobahnTester</mainClass>
-            </manifest>
-          </archive>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <!-- Do not deploy this as an artifact to Maven central. -->
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-deploy-plugin</artifactId>
-        <configuration>
-          <skip>true</skip>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
deleted file mode 100755
index 06dd4a2e28..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketCallTest.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.OkHttpClient;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.ws.WebSocket.TEXT;
-
-public final class WebSocketCallTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final SslClient sslClient = SslClient.localhost();
-  private final WebSocketRecorder listener = new WebSocketRecorder();
-  private final Random random = new Random(0);
-  private OkHttpClient client = new OkHttpClient();
-
-  @After public void tearDown() {
-    listener.assertExhausted();
-  }
-
-  @Test public void clientPingPong() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("Hello, WebSockets!"));
-    listener.assertPong(new Buffer().writeUtf8("Hello, WebSockets!"));
-  }
-
-  @Test public void clientMessage() throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-    serverListener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void serverMessage() throws IOException {
-    WebSocketListener serverListener = new EmptyWebSocketListener() {
-      @Override public void onOpen(final WebSocket webSocket, Response response) {
-        new Thread() {
-          @Override public void run() {
-            try {
-              webSocket.sendMessage(RequestBody.create(TEXT, "Hello, WebSockets!"));
-            } catch (IOException e) {
-              throw new AssertionError(e);
-            }
-          }
-        }.start();
-      }
-    };
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    awaitWebSocket();
-    listener.assertTextMessage("Hello, WebSockets!");
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class, "Expected HTTP 101 response but was '200 OK'");
-    listener.assertResponse(200, "Body");
-  }
-
-  @Test public void notFound() throws IOException {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-    listener.assertResponse(404, "");
-  }
-
-  @Test public void clientTimeoutClosesBody() throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(408));
-    WebSocketListener serverListener = new EmptyWebSocketListener();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = awaitWebSocket();
-    webSocket.sendPing(new Buffer().writeUtf8("WebSockets are fun!"));
-    listener.assertPong(new Buffer().writeUtf8("WebSockets are fun!"));
-  }
-
-  @Test public void missingConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    awaitWebSocket();
-    listener.assertFailure(ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void wsScheme() throws IOException {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() throws IOException {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
-    client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  private void websocketScheme(String scheme) throws IOException {
-    WebSocketRecorder serverListener = new WebSocketRecorder();
-    server.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request1 = new Request.Builder()
-        .url(scheme + "://" + server.getHostName() + ":" + server.getPort() + "/")
-        .build();
-
-    WebSocket webSocket = awaitWebSocket(request1);
-    webSocket.sendMessage(RequestBody.create(TEXT, "abc"));
-    serverListener.assertTextMessage("abc");
-  }
-
-  private WebSocket awaitWebSocket() {
-    return awaitWebSocket(new Request.Builder().get().url(server.url("/")).build());
-  }
-
-  private WebSocket awaitWebSocket(Request request) {
-    WebSocketCall call = new WebSocketCall(client, request, random);
-
-    final AtomicReference<Response> responseRef = new AtomicReference<>();
-    final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();
-    final AtomicReference<IOException> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        webSocketRef.set(webSocket);
-        responseRef.set(response);
-        latch.countDown();
-      }
-
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPong(Buffer payload) {
-        listener.onPong(payload);
-      }
-
-      @Override public void onClose(int code, String reason) {
-        listener.onClose(code, reason);
-      }
-
-      @Override public void onFailure(IOException e, Response response) {
-        listener.onFailure(e, response);
-        failureRef.set(e);
-        latch.countDown();
-      }
-    });
-
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new AssertionError("Timed out.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-
-    return webSocketRef.get();
-  }
-
-  private static class EmptyWebSocketListener implements WebSocketListener {
-    @Override public void onOpen(WebSocket webSocket, Response response) {
-    }
-
-    @Override public void onMessage(ResponseBody message) throws IOException {
-    }
-
-    @Override public void onPong(Buffer payload) {
-    }
-
-    @Override public void onClose(int code, String reason) {
-    }
-
-    @Override public void onFailure(IOException e, Response response) {
-    }
-  }
-}
diff --git a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java b/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
deleted file mode 100755
index 485a4a1e88..0000000000
--- a/okhttp-ws-tests/src/test/java/okhttp3/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import okhttp3.MediaType;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.internal.ws.WebSocketReader;
-import okio.Buffer;
-
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-
-public final class WebSocketRecorder implements WebSocketReader.FrameCallback, WebSocketListener {
-  public interface MessageDelegate {
-    void onMessage(ResponseBody message) throws IOException;
-  }
-
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private MessageDelegate delegate;
-  private Response response;
-
-  /** Sets a delegate for the next call to {@link #onMessage}. Cleared after invoked. */
-  public void setNextMessageDelegate(MessageDelegate delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-  }
-
-  @Override public void onMessage(ResponseBody message) throws IOException {
-    if (delegate != null) {
-      delegate.onMessage(message);
-      delegate = null;
-    } else {
-      Message event = new Message(message.contentType());
-      message.source().readAll(event.buffer);
-      message.close();
-      events.add(event);
-    }
-  }
-
-  @Override public void onPing(Buffer buffer) {
-    events.add(new Ping(buffer));
-  }
-
-  @Override public void onPong(Buffer buffer) {
-    events.add(new Pong(buffer));
-  }
-
-  @Override public void onClose(int code, String reason) {
-    events.add(new Close(code, reason));
-  }
-
-  @Override public void onFailure(IOException e, Response response) {
-    events.add(e);
-    this.response = response;
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) throws IOException {
-    Message message = new Message(TEXT);
-    message.buffer.writeUtf8(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertBinaryMessage(byte[] payload) throws IOException {
-    Message message = new Message(BINARY);
-    message.buffer.write(payload);
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(message, actual);
-  }
-
-  public void assertPing(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Ping(payload), actual);
-  }
-
-  public void assertPong(Buffer payload) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Pong(payload), actual);
-  }
-
-  public void assertClose(int code, String reason) throws IOException {
-    Object actual = nextEvent();
-    if (actual instanceof IOException) {
-      throw (IOException) actual;
-    }
-    assertEquals(new Close(code, reason), actual);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String message) {
-    Object event = nextEvent();
-    String errorMessage =
-        "Expected [" + cls.getName() + ": " + message + "] but was [" + event + "].";
-    assertNotNull(errorMessage, event);
-    assertEquals(errorMessage, cls, event.getClass());
-    assertEquals(errorMessage, cls.cast(event).getMessage(), message);
-  }
-
-  public void assertExhausted() {
-    assertTrue("Remaining events: " + events, events.isEmpty());
-  }
-
-  public void assertResponse(int code, String body) throws IOException {
-    assertNotNull(response);
-    assertEquals(code, response.code());
-    assertEquals(body, response.body().string());
-  }
-
-  private static class Message {
-    public final MediaType mediaType;
-    public final Buffer buffer = new Buffer();
-
-    private Message(MediaType mediaType) {
-      this.mediaType = mediaType;
-    }
-
-    @Override public String toString() {
-      return "Message[" + mediaType + " " + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return mediaType.hashCode() * 37 + buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Message) {
-        Message other = (Message) obj;
-        return mediaType.equals(other.mediaType) && buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Ping {
-    public final Buffer buffer;
-
-    private Ping(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Ping) {
-        Ping other = (Ping) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Pong {
-    public final Buffer buffer;
-
-    private Pong(Buffer buffer) {
-      this.buffer = buffer;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + buffer + "]";
-    }
-
-    @Override public int hashCode() {
-      return buffer.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Pong) {
-        Pong other = (Pong) obj;
-        return buffer == null ? other.buffer == null : buffer.equals(other.buffer);
-      }
-      return false;
-    }
-  }
-
-  private static class Close {
-    public final int code;
-    public final String reason;
-
-    private Close(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Close[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object obj) {
-      if (obj instanceof Close) {
-        Close other = (Close) obj;
-        return code == other.code && reason.equals(other.reason);
-      }
-      return false;
-    }
-  }
-}
diff --git a/okhttp-ws/README.md b/okhttp-ws/README.md
deleted file mode 100755
index 054ea91fbf..0000000000
--- a/okhttp-ws/README.md
+++ /dev/null
@@ -1,22 +0,0 @@
-OkHttp Web Sockets
-==================
-
-RFC6455-compliant web socket implementation.
-
-Create a `WebSocketCall` with a `Request` and an `OkHttpClient` instance.
-```java
-WebSocketCall call = WebSocketCall.create(client, request);
-```
-
-A `WebSocketListener` will notify of the initial connection, server-sent messages, and any failures
-on the connection.
-
-Start the web socket by calling `enqueue` on `WebSocketCall` with the `WebSocketListener`.
-```java
-call.enqueue(new WebSocketListener() {
-  // ...
-});
-```
-
-*Note: This module's API should be considered experimental and may be subject to breaking changes
-in future releases.*
diff --git a/okhttp-ws/pom.xml b/okhttp-ws/pom.xml
deleted file mode 100755
index 649b117f62..0000000000
--- a/okhttp-ws/pom.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.okhttp3</groupId>
-    <artifactId>parent</artifactId>
-    <version>3.5.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>okhttp-ws</artifactId>
-  <name>OkHttp Web Sockets</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>okhttp</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <configuration>
-          <excludePackageNames>okhttp3.internal.*</excludePackageNames>
-          <links>
-            <link>http://square.github.io/okhttp/javadoc/</link>
-          </links>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
deleted file mode 100755
index b9af6bdd65..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.internal.NamedRunnable;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
-
-public abstract class RealWebSocket implements WebSocket {
-  private static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
-
-  private final WebSocketWriter writer;
-  private final WebSocketReader reader;
-  private final WebSocketListener listener;
-
-  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
-  private volatile boolean writerSentClose;
-  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
-  private boolean writerWantsClose;
-  /** True after a close frame was read by the reader. No frames will follow it. */
-  private boolean readerSentClose;
-
-  /** True after calling {@link #close()} to free connection resources. */
-  private final AtomicBoolean connectionClosed = new AtomicBoolean();
-
-  public RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
-      final Executor replyExecutor, final WebSocketListener listener, final String url) {
-    this.listener = listener;
-
-    writer = new WebSocketWriter(isClient, sink, random);
-    reader = new WebSocketReader(isClient, source, new FrameCallback() {
-      @Override public void onMessage(ResponseBody message) throws IOException {
-        listener.onMessage(message);
-      }
-
-      @Override public void onPing(final Buffer buffer) {
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Pong Reply", url) {
-          @Override protected void execute() {
-            try {
-              writer.writePong(buffer);
-            } catch (IOException ignored) {
-            }
-          }
-        });
-      }
-
-      @Override public void onPong(Buffer buffer) {
-        listener.onPong(buffer);
-      }
-
-      @Override public void onClose(final int code, final String reason) {
-        readerSentClose = true;
-        replyExecutor.execute(new NamedRunnable("OkHttp %s WebSocket Close Reply", url) {
-          @Override protected void execute() {
-            peerClose(code, reason);
-          }
-        });
-      }
-    });
-  }
-
-  /**
-   * Read a single message from the web socket and deliver it to the listener. This method should be
-   * called in a loop with the return value indicating whether looping should continue.
-   */
-  public boolean readMessage() {
-    try {
-      reader.processNextFrame();
-      return !readerSentClose;
-    } catch (IOException e) {
-      readerErrorClose(e);
-      return false;
-    }
-  }
-
-  @Override public void sendMessage(RequestBody message) throws IOException {
-    if (message == null) throw new NullPointerException("message == null");
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    MediaType contentType = message.contentType();
-    if (contentType == null) {
-      throw new IllegalArgumentException(
-          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-    String contentSubtype = contentType.subtype();
-
-    int formatOpcode;
-    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_TEXT;
-    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
-      formatOpcode = OPCODE_BINARY;
-    } else {
-      throw new IllegalArgumentException("Unknown message content type: "
-          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
-          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
-    }
-
-    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
-    try {
-      message.writeTo(sink);
-      sink.close();
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void sendPing(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePing(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  /** Send an unsolicited pong with the specified payload. */
-  public void sendPong(Buffer payload) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    if (writerWantsClose) throw new IllegalStateException("must call close()");
-
-    try {
-      writer.writePong(payload);
-    } catch (IOException e) {
-      writerWantsClose = true;
-      throw e;
-    }
-  }
-
-  @Override public void close(int code, String reason) throws IOException {
-    if (writerSentClose) throw new IllegalStateException("closed");
-    writerSentClose = true;
-
-    try {
-      writer.writeClose(code, reason);
-    } catch (IOException e) {
-      if (connectionClosed.compareAndSet(false, true)) {
-        // Try to close the connection without masking the original exception.
-        try {
-          close();
-        } catch (IOException ignored) {
-        }
-      }
-      throw e;
-    }
-  }
-
-  /** Replies and closes this web socket when a close frame is read from the peer. */
-  private void peerClose(int code, String reason) {
-    if (!writerSentClose) {
-      try {
-        writer.writeClose(code, reason);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onClose(code, reason);
-  }
-
-  /** Called on the reader thread when an error occurs. */
-  private void readerErrorClose(IOException e) {
-    // For protocol exceptions, try to inform the server of such.
-    if (!writerSentClose && e instanceof ProtocolException) {
-      try {
-        writer.writeClose(CLOSE_PROTOCOL_EXCEPTION, null);
-      } catch (IOException ignored) {
-      }
-    }
-
-    if (connectionClosed.compareAndSet(false, true)) {
-      try {
-        close();
-      } catch (IOException ignored) {
-      }
-    }
-
-    listener.onFailure(e, null);
-  }
-
-  /** Perform any tear-down work (close the connection, shutdown executors). */
-  protected abstract void close() throws IOException;
-}
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java b/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
deleted file mode 100755
index 12d5e66aab..0000000000
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketListener.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.ws;
-
-import java.io.IOException;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okio.Buffer;
-
-/** Listener for server-initiated messages on a connected {@link WebSocket}. */
-public interface WebSocketListener {
-  /**
-   * Called when the request has successfully been upgraded to a web socket. This method is called
-   * on the message reading thread to allow setting up any state before the {@linkplain #onMessage
-   * message}, {@linkplain #onPong pong}, and {@link #onClose close} callbacks start.
-   *
-   * <p><b>Do not</b> use this callback to write to the web socket. Start a new thread or use
-   * another thread in your application.
-   */
-  void onOpen(WebSocket webSocket, Response response);
-
-  /**
-   * Called when the transport or protocol layer of this web socket errors during communication.
-   *
-   * @param response Present when the failure is a direct result of the response (e.g., failed
-   * upgrade, non-101 response code, etc.). {@code null} otherwise.
-   */
-  void onFailure(IOException e, Response response);
-
-  /**
-   * Called when a server message is received. The {@code type} indicates whether the {@code
-   * payload} should be interpreted as UTF-8 text or binary data.
-   *
-   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
-   * indicates completion of parsing the message payload and will consume any remaining bytes in the
-   * message.
-   *
-   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
-   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
-   */
-  void onMessage(ResponseBody message) throws IOException;
-
-  /**
-   * Called when a server pong is received. This is usually a result of calling {@link
-   * WebSocket#sendPing(Buffer)} but might also be unsolicited.
-   */
-  void onPong(Buffer payload);
-
-  /**
-   * Called when the server sends a close message. This may have been initiated from a call to
-   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
-   *
-   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
-   * status code.
-   * @param reason Reason for close or an empty string.
-   */
-  void onClose(int code, String reason);
-}
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 3b9d447b6f..a229e2dd00 100755
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -15,12 +15,13 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 
 import static okhttp3.internal.Util.concat;
-import static okhttp3.internal.Util.immutableList;
 import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
 
@@ -30,7 +31,7 @@
  * connection.
  *
  * <p>The TLS versions configured in a connection spec are only be used if they are also enabled in
- * the SSL socket. For example, if an SSL socket does not have TLS 1.2 enabled, it will not be used
+ * the SSL socket. For example, if an SSL socket does not have TLS 1.3 enabled, it will not be used
  * even if it is present on the connection spec. The same policy also applies to cipher suites.
  *
  * <p>Use {@link Builder#allEnabledTlsVersions()} and {@link Builder#allEnabledCipherSuites} to
@@ -66,7 +67,7 @@
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -102,11 +103,11 @@ public boolean isTls() {
   public List<CipherSuite> cipherSuites() {
     if (cipherSuites == null) return null;
 
-    CipherSuite[] result = new CipherSuite[cipherSuites.length];
-    for (int i = 0; i < cipherSuites.length; i++) {
-      result[i] = CipherSuite.forJavaName(cipherSuites[i]);
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(CipherSuite.forJavaName(cipherSuite));
     }
-    return immutableList(result);
+    return Collections.unmodifiableList(result);
   }
 
   /**
@@ -116,11 +117,11 @@ public boolean isTls() {
   public List<TlsVersion> tlsVersions() {
     if (tlsVersions == null) return null;
 
-    TlsVersion[] result = new TlsVersion[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      result[i] = TlsVersion.forJavaName(tlsVersions[i]);
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(TlsVersion.forJavaName(tlsVersion));
     }
-    return immutableList(result);
+    return Collections.unmodifiableList(result);
   }
 
   public boolean supportsTlsExtensions() {
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index d52f306e90..df882c01ab 100755
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -100,7 +100,7 @@ public String value() {
     return value;
   }
 
-  /** Returns true if this cookie expires at the end of the current session. */
+  /** Returns true if this cookie does not expire at the end of the current session. */
   public boolean persistent() {
     return persistent;
   }
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index bd34d931da..e6c7c359b5 100755
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -316,7 +316,7 @@ private void checkNameAndValue(String name, String value) {
       if (value == null) throw new NullPointerException("value == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
-        if (c <= '\u001f' || c >= '\u007f') {
+        if ((c <= '\u001f' && c != '\u0009' /* htab */) || c >= '\u007f') {
           throw new IllegalArgumentException(Util.format(
               "Unexpected char %#04x at %d in %s value: %s", (int) c, i, name, value));
         }
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 29baeefdb0..39741176d3 100755
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -1726,8 +1726,10 @@ static String percentDecode(String encoded, boolean plusIsSpace) {
   }
 
   private List<String> percentDecode(List<String> list, boolean plusIsSpace) {
-    List<String> result = new ArrayList<>(list.size());
-    for (String s : list) {
+    int size = list.size();
+    List<String> result = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      String s = list.get(i);
       result.add(s != null ? percentDecode(s, plusIsSpace) : null);
     }
     return Collections.unmodifiableList(result);
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 7ac584d1d9..3aa31f310d 100755
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -257,13 +257,21 @@ public static Part createFormData(String name, String filename, RequestBody body
       return create(Headers.of("Content-Disposition", disposition.toString()), body);
     }
 
-    private final Headers headers;
-    private final RequestBody body;
+    final Headers headers;
+    final RequestBody body;
 
     private Part(Headers headers, RequestBody body) {
       this.headers = headers;
       this.body = body;
     }
+
+    public Headers headers() {
+      return headers;
+    }
+
+    public RequestBody body() {
+      return body;
+    }
   }
 
   public static final class Builder {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 7e26bcd6ed..999015996b 100755
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -115,7 +115,7 @@
  * <p>OkHttp also uses daemon threads for HTTP/2 connections. These will exit automatically if they
  * remain idle.
  */
-public class OkHttpClient implements Cloneable, Call.Factory {
+public class OkHttpClient implements Cloneable, Call.Factory, WebSocketCall.Factory {
   private static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
@@ -154,10 +154,6 @@
         return connectionPool.routeDatabase;
       }
 
-      @Override public StreamAllocation callEngineGetStreamAllocation(Call call) {
-        return ((RealCall) call).streamAllocation();
-      }
-
       @Override
       public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) {
         tlsConfiguration.apply(sslSocket, isFallback);
@@ -167,10 +163,6 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
           throws MalformedURLException, UnknownHostException {
         return HttpUrl.getChecked(url);
       }
-
-      @Override public void setCallWebSocket(Call call) {
-        ((RealCall) call).setForWebSocket();
-      }
     };
   }
 
@@ -385,7 +377,14 @@ public Dispatcher dispatcher() {
    * Prepares the {@code request} to be executed at some point in the future.
    */
   @Override public Call newCall(Request request) {
-    return new RealCall(this, request);
+    return new RealCall(this, request, false /* for web socket */);
+  }
+
+  /**
+   * Prepares the {@code request} to create a web socket at some point in the future.
+   */
+  @Override public WebSocketCall newWebSocketCall(Request request) {
+    return new RealWebSocketCall(this, request);
   }
 
   public Builder newBuilder() {
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index 7545b508b3..3c027a2caf 100755
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -31,19 +31,21 @@
 import static okhttp3.internal.platform.Platform.INFO;
 
 final class RealCall implements Call {
-  private final OkHttpClient client;
-  private final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+  final OkHttpClient client;
+  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
+
+  /** The application's original request unadulterated by redirects or auth headers. */
+  final Request originalRequest;
+  final boolean forWebSocket;
 
   // Guarded by this.
   private boolean executed;
 
-  /** The application's original request unadulterated by redirects or auth headers. */
-  Request originalRequest;
-
-  protected RealCall(OkHttpClient client, Request originalRequest) {
+  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
-    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client);
+    this.forWebSocket = forWebSocket;
+    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
   @Override public Request request() {
@@ -71,11 +73,6 @@ private void captureCallStackTrace() {
     retryAndFollowUpInterceptor.setCallStackTrace(callStackTrace);
   }
 
-  synchronized void setForWebSocket() {
-    if (executed) throw new IllegalStateException("Already Executed");
-    this.retryAndFollowUpInterceptor.setForWebSocket(true);
-  }
-
   @Override public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
@@ -99,7 +96,7 @@ synchronized void setForWebSocket() {
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public RealCall clone() {
-    return new RealCall(client, originalRequest);
+    return new RealCall(client, originalRequest, forWebSocket);
   }
 
   StreamAllocation streamAllocation() {
@@ -109,7 +106,7 @@ StreamAllocation streamAllocation() {
   final class AsyncCall extends NamedRunnable {
     private final Callback responseCallback;
 
-    private AsyncCall(Callback responseCallback) {
+    AsyncCall(Callback responseCallback) {
       super("OkHttp %s", redactedUrl());
       this.responseCallback = responseCallback;
     }
@@ -154,16 +151,17 @@ RealCall get() {
    * Returns a string that describes this call. Doesn't include a full URL as that might contain
    * sensitive information.
    */
-  private String toLoggableString() {
-    String string = retryAndFollowUpInterceptor.isCanceled() ? "canceled call" : "call";
-    return string + " to " + redactedUrl();
+  String toLoggableString() {
+    return (isCanceled() ? "canceled " : "")
+        + (forWebSocket ? "web socket" : "call")
+        + " to " + redactedUrl();
   }
 
   String redactedUrl() {
     return originalRequest.url().redact().toString();
   }
 
-  private Response getResponseWithInterceptorChain() throws IOException {
+  Response getResponseWithInterceptorChain() throws IOException {
     // Build a full stack of interceptors.
     List<Interceptor> interceptors = new ArrayList<>();
     interceptors.addAll(client.interceptors());
@@ -171,11 +169,10 @@ private Response getResponseWithInterceptorChain() throws IOException {
     interceptors.add(new BridgeInterceptor(client.cookieJar()));
     interceptors.add(new CacheInterceptor(client.internalCache()));
     interceptors.add(new ConnectInterceptor(client));
-    if (!retryAndFollowUpInterceptor.isForWebSocket()) {
+    if (!forWebSocket) {
       interceptors.addAll(client.networkInterceptors());
     }
-    interceptors.add(new CallServerInterceptor(
-        retryAndFollowUpInterceptor.isForWebSocket()));
+    interceptors.add(new CallServerInterceptor(forWebSocket));
 
     Interceptor.Chain chain = new RealInterceptorChain(
         interceptors, null, null, null, 0, originalRequest);
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
similarity index 54%
rename from okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
rename to okhttp/src/main/java/okhttp3/RealWebSocketCall.java
index bdfd3dbb51..f383c58e76 100755
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocketCall.java
+++ b/okhttp/src/main/java/okhttp3/RealWebSocketCall.java
@@ -13,23 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.security.SecureRandom;
 import java.util.Collections;
+import java.util.List;
 import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingDeque;
 import java.util.concurrent.ThreadPoolExecutor;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.ws.RealWebSocket;
@@ -38,23 +32,20 @@
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
-public final class WebSocketCall {
-  /**
-   * Prepares the {@code request} to create a web socket at some point in the future.
-   */
-  public static WebSocketCall create(OkHttpClient client, Request request) {
-    return new WebSocketCall(client, request);
-  }
+final class RealWebSocketCall implements WebSocketCall {
+  private static final List<Protocol> ONLY_HTTP1 = Collections.singletonList(Protocol.HTTP_1_1);
 
-  private final Call call;
+  /** The application's original request unadulterated by web socket headers. */
+  private final Request originalRequest;
+  private final RealCall call;
   private final Random random;
   private final String key;
 
-  WebSocketCall(OkHttpClient client, Request request) {
+  RealWebSocketCall(OkHttpClient client, Request request) {
     this(client, request, new SecureRandom());
   }
 
-  WebSocketCall(OkHttpClient client, Request request, Random random) {
+  RealWebSocketCall(OkHttpClient client, Request request, Random random) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
@@ -65,9 +56,12 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
     key = ByteString.of(nonce).base64();
 
     client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .writeTimeout(0, SECONDS) // i.e., no timeout because this is a long-lived connection.
+        .protocols(ONLY_HTTP1)
         .build();
 
+    originalRequest = request;
     request = request.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
@@ -75,46 +69,31 @@ public static WebSocketCall create(OkHttpClient client, Request request) {
         .header("Sec-WebSocket-Version", "13")
         .build();
 
-    call = client.newCall(request);
+    call = new RealCall(client, request, true /* for web socket */);
   }
 
-  /**
-   * Schedules the request to be executed at some point in the future.
-   *
-   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
-   * immediately unless there are several other requests currently being executed.
-   *
-   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
-   * failure exception. If you {@link #cancel} a request before it completes the callback will not
-   * be invoked.
-   *
-   * @throws IllegalStateException when the call has already been executed.
-   */
-  public void enqueue(final WebSocketListener listener) {
+  @Override public void enqueue(final WebSocketListener listener) {
     Callback responseCallback = new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
+      @Override public void onResponse(Call call, Response response) {
+        StreamWebSocket webSocket;
         try {
-          createWebSocket(response, listener);
+          webSocket = create(response, listener);
         } catch (IOException e) {
           listener.onFailure(e, response);
+          return;
         }
+
+        webSocket.loopReader();
       }
 
       @Override public void onFailure(Call call, IOException e) {
         listener.onFailure(e, null);
       }
     };
-    // TODO call.enqueue(responseCallback, true);
-    Internal.instance.setCallWebSocket(call);
     call.enqueue(responseCallback);
   }
 
-  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
-  public void cancel() {
-    call.cancel();
-  }
-
-  private void createWebSocket(Response response, WebSocketListener listener) throws IOException {
+  StreamWebSocket create(Response response, WebSocketListener listener) throws IOException {
     if (response.code() != 101) {
       throw new ProtocolException("Expected HTTP 101 response but was '"
           + response.code()
@@ -143,43 +122,52 @@ private void createWebSocket(Response response, WebSocketListener listener) thro
           + "'");
     }
 
-    StreamAllocation streamAllocation = Internal.instance.callEngineGetStreamAllocation(call);
-    RealWebSocket webSocket = StreamWebSocket.create(
-        streamAllocation, response, random, listener);
+    String name = response.request().url().redact().toString();
+    ThreadPoolExecutor replyExecutor =
+        new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
+            Util.threadFactory(Util.format("OkHttp %s WebSocket Replier", name), true));
+    replyExecutor.allowCoreThreadTimeOut(true);
 
-    listener.onOpen(webSocket, response);
+    StreamAllocation streamAllocation = call.streamAllocation();
+    streamAllocation.noNewStreams(); // Web socket connections can't be re-used.
+    return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, response, name);
+  }
 
-    while (webSocket.readMessage()) {
-    }
+  @Override public Request request() {
+    return originalRequest;
   }
 
-  // Keep static so that the WebSocketCall instance can be garbage collected.
-  private static class StreamWebSocket extends RealWebSocket {
-    static RealWebSocket create(StreamAllocation streamAllocation, Response response,
-        Random random, WebSocketListener listener) {
-      String url = response.request().url().redact().toString();
-      ThreadPoolExecutor replyExecutor =
-          new ThreadPoolExecutor(1, 1, 1, SECONDS, new LinkedBlockingDeque<Runnable>(),
-              Util.threadFactory(Util.format("OkHttp %s WebSocket", url), true));
-      replyExecutor.allowCoreThreadTimeOut(true);
-
-      return new StreamWebSocket(streamAllocation, random, replyExecutor, listener, url);
-    }
+  @Override public void cancel() {
+    call.cancel();
+  }
 
+  @Override public boolean isExecuted() {
+    return call.isExecuted();
+  }
+
+  @Override public boolean isCanceled() {
+    return call.isCanceled();
+  }
+
+  @Override public WebSocketCall clone() {
+    return new RealWebSocketCall(call.client, originalRequest, random);
+  }
+
+  // Keep static so that the WebSocketCall instance can be garbage collected.
+  static final class StreamWebSocket extends RealWebSocket {
     private final StreamAllocation streamAllocation;
-    private final ExecutorService replyExecutor;
+    private final ExecutorService executor;
 
-    private StreamWebSocket(StreamAllocation streamAllocation,
-        Random random, ExecutorService replyExecutor, WebSocketListener listener, String url) {
+    StreamWebSocket(StreamAllocation streamAllocation, Random random, ExecutorService executor,
+        WebSocketListener listener, Response response, String name) {
       super(true /* is client */, streamAllocation.connection().source,
-          streamAllocation.connection().sink, random, replyExecutor, listener, url);
+          streamAllocation.connection().sink, random, executor, listener, response, name);
       this.streamAllocation = streamAllocation;
-      this.replyExecutor = replyExecutor;
+      this.executor = executor;
     }
 
-    @Override protected void close() throws IOException {
-      replyExecutor.shutdown();
-      streamAllocation.noNewStreams();
+    @Override protected void shutdown() {
+      executor.shutdown();
       streamAllocation.streamFinished(true, streamAllocation.codec());
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index 89188ec587..17da07747c 100755
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -17,6 +17,7 @@
 
 import java.net.URL;
 import java.util.List;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
 /**
@@ -215,7 +216,7 @@ public Builder delete(RequestBody body) {
     }
 
     public Builder delete() {
-      return delete(RequestBody.create(null, new byte[0]));
+      return delete(Util.EMPTY_REQUEST);
     }
 
     public Builder put(RequestBody body) {
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index c0d3309b31..113d607746 100755
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -137,7 +137,11 @@ public final InputStream byteStream() {
       Util.closeQuietly(source);
     }
     if (contentLength != -1 && contentLength != bytes.length) {
-      throw new IOException("Content-Length and stream length disagree");
+      throw new IOException("Content-Length ("
+          + contentLength
+          + ") and stream length ("
+          + bytes.length
+          + ") disagree");
     }
     return bytes;
   }
@@ -145,24 +149,32 @@ public final InputStream byteStream() {
   /**
    * Returns the response as a character stream decoded with the charset of the Content-Type header.
    * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body as UTF-8.
+   * body in accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or
+   * UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
   }
 
   /**
    * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body as
-   * UTF-8. Closes {@link ResponseBody} automatically.
+   * header is either absent or lacks a charset, this will attempt to decode the response body in
+   * accordance to <a href="https://en.wikipedia.org/wiki/Byte_order_mark">its BOM</a> or UTF-8.
+   * Closes {@link ResponseBody} automatically.
    *
    * <p>This method loads entire response body into memory. If the response body is very large this
    * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
    * possibility for your response.
    */
   public final String string() throws IOException {
-    return new String(bytes(), charset().name());
+    BufferedSource source = source();
+    try {
+      Charset charset = Util.bomAwareCharset(source, charset());
+      return source.readString(charset);
+    } finally {
+      Util.closeQuietly(source);
+    }
   }
 
   private Charset charset() {
@@ -215,4 +227,37 @@ public static ResponseBody create(
       }
     };
   }
+
+  static final class BomAwareReader extends Reader {
+    private final BufferedSource source;
+    private final Charset charset;
+
+    private boolean closed;
+    private Reader delegate;
+
+    private BomAwareReader(BufferedSource source, Charset charset) {
+      this.source = source;
+      this.charset = charset;
+    }
+
+    @Override public int read(char[] cbuf, int off, int len) throws IOException {
+      if (closed) throw new IOException("Stream closed");
+
+      Reader delegate = this.delegate;
+      if (delegate == null) {
+        Charset charset = Util.bomAwareCharset(source, this.charset);
+        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
+      }
+      return delegate.read(cbuf, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      closed = true;
+      if (delegate != null) {
+        delegate.close();
+      } else {
+        source.close();
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 668cd9732b..391af88e3a 100755
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -20,6 +20,7 @@
  * javax.net.ssl.SSLSocket#setEnabledProtocols}.
  */
 public enum TlsVersion {
+  TLS_1_3("TLSv1.3"), // 2016.
   TLS_1_2("TLSv1.2"), // 2008.
   TLS_1_1("TLSv1.1"), // 2006.
   TLS_1_0("TLSv1"),   // 1999.
@@ -34,6 +35,8 @@
 
   public static TlsVersion forJavaName(String javaName) {
     switch (javaName) {
+      case "TLSv1.3":
+        return TLS_1_3;
       case "TLSv1.2":
         return TLS_1_2;
       case "TLSv1.1":
diff --git a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
similarity index 65%
rename from okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
rename to okhttp/src/main/java/okhttp3/WebSocket.java
index 7435c01d7f..8f80497b3b 100755
--- a/okhttp-ws/src/main/java/okhttp3/ws/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -13,14 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.ws;
+package okhttp3;
 
 import java.io.IOException;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okio.Buffer;
+import okio.ByteString;
 
-/** Blocking interface to connect and write to a web socket. */
+/** Blocking interface to connect and write to a web socket. This class is not thread safe. */
 public interface WebSocket {
   /** A {@link MediaType} indicating UTF-8 text frames should be used when sending the message. */
   MediaType TEXT = MediaType.parse("application/vnd.okhttp.websocket+text; charset=utf-8");
@@ -28,28 +26,29 @@
   MediaType BINARY = MediaType.parse("application/vnd.okhttp.websocket+binary");
 
   /**
-   * Send a message payload to the server.
-   *
-   * <p>The {@linkplain RequestBody#contentType() content type} of {@code message} should be either
-   * {@link #TEXT} or {@link #BINARY}.
+   * Send a message to the server.
    *
+   * @param message The message body. The {@linkplain RequestBody#contentType() content type} of
+   * must be either {@link #TEXT} or {@link #BINARY}.
    * @throws IOException if unable to write the message. Clients must call {@link #close} when this
    * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if not connected, already closed, or another writer is active.
+   * @throws IllegalStateException if this web socket was already closed.
    */
   void sendMessage(RequestBody message) throws IOException;
 
   /**
-   * Send a ping to the server with optional payload.
+   * Send a ping to the server.
    *
+   * @param payload Ping payload which must not exceed 125 bytes. Use {@link ByteString#EMPTY} for
+   * no payload.
    * @throws IOException if unable to write the ping.  Clients must call {@link #close} when this
    * happens to ensure resources are cleaned up.
-   * @throws IllegalStateException if already closed.
+   * @throws IllegalStateException if this web socket was already closed.
    */
-  void sendPing(Buffer payload) throws IOException;
+  void sendPing(ByteString payload) throws IOException;
 
   /**
-   * Send a close frame to the server.
+   * Send a close indicator to the server.
    *
    * <p>The corresponding {@link WebSocketListener} will continue to get messages until its {@link
    * WebSocketListener#onClose onClose()} method is called.
@@ -57,8 +56,11 @@
    * <p>It is an error to call this method before calling close on an active writer. Calling this
    * method more than once has no effect.
    *
+   * @param code Status code as defined by <a
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * @param reason Reason for shutting down or {@code null}.
    * @throws IOException if unable to write the close message. Resources will still be freed.
-   * @throws IllegalStateException if already closed.
+   * @throws IllegalStateException if this web socket was already closed.
    */
   void close(int code, String reason) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/WebSocketCall.java b/okhttp/src/main/java/okhttp3/WebSocketCall.java
new file mode 100755
index 0000000000..3dc18bcba4
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketCall.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+public interface WebSocketCall extends Cloneable {
+  /** Returns the original request that initiated this call. */
+  Request request();
+
+  /**
+   * Schedules the request to be executed at some point in the future.
+   *
+   * <p>The {@link OkHttpClient#dispatcher dispatcher} defines when the request will run: usually
+   * immediately unless there are several other requests currently being executed.
+   *
+   * <p>This client will later call back {@code responseCallback} with either an HTTP response or a
+   * failure exception. If you {@link #cancel} a request before it completes the callback will not
+   * be invoked.
+   *
+   * @throws IllegalStateException when the call has already been executed.
+   */
+  void enqueue(WebSocketListener listener);
+
+  /** Cancels the request, if possible. Requests that are already complete cannot be canceled. */
+  void cancel();
+
+  /**
+   * Returns true if this call has been {@linkplain #enqueue(WebSocketListener) enqueued}. It is an
+   * error to enqueue a call more than once.
+   */
+  boolean isExecuted();
+
+  boolean isCanceled();
+
+  /**
+   * Create a new, identical call to this one which can be enqueued even if this call has already
+   * been.
+   */
+  WebSocketCall clone();
+
+  interface Factory {
+    WebSocketCall newWebSocketCall(Request request);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
new file mode 100755
index 0000000000..b25548b5f9
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import okio.ByteString;
+
+/**
+ * Listener for server-initiated messages on a connected {@link WebSocket}. All callbacks will be
+ * called on a single thread.
+ *
+ * <h2>Lifecycle Rules</h2>
+ * <ul>
+ * <li>Either {@link #onOpen} or {@link #onFailure} will be called first depending on if the web
+ * socket was successfully opened or if there was an error connecting to the server or parsing its
+ * response.</li>
+ * <li>After {@link #onOpen} is called, {@link #onFailure} can be called at any time. No more
+ * callbacks will follow a call to {@link #onFailure}.</li>
+ * <li>After {@link #onOpen} is called, {@link #onMessage} and {@link #onPong} will be called for
+ * each message and pong frame, respectively. Note: {@link #onPong} may be called while {@link
+ * #onMessage} is reading the message because pong frames may interleave in the message body.</li>
+ * <li>After {@link #onOpen} is called, {@link #onClose} may be called once. No calls to {@link
+ * #onMessage} or {@link #onPong} will follow a call to {@link #onClose}.</li>
+ * <li>{@link #onFailure} will be called if any of the other callbacks throws an exception.</li>
+ * </ul>
+ */
+public interface WebSocketListener {
+  /**
+   * Called when the request has successfully been upgraded to a web socket. <b>Do not</b> use this
+   * callback to write to the web socket. Start a new thread or use another thread in your
+   * application.
+   */
+  void onOpen(WebSocket webSocket, Response response);
+
+  /**
+   * Called when a server message is received. The {@code type} indicates whether the {@code
+   * payload} should be interpreted as UTF-8 text or binary data.
+   *
+   * <p>Implementations <strong>must</strong> call {@code source.close()} before returning. This
+   * indicates completion of parsing the message payload and will consume any remaining bytes in the
+   * message.
+   *
+   * <p>The {@linkplain ResponseBody#contentType() content type} of {@code message} will be either
+   * {@link WebSocket#TEXT} or {@link WebSocket#BINARY} which indicates the format of the message.
+   */
+  void onMessage(ResponseBody message) throws IOException;
+
+  /**
+   * Called when a server pong is received. This is usually a result of calling {@link
+   * WebSocket#sendPing(ByteString)} but might also be unsolicited directly from the server.
+   */
+  void onPong(ByteString payload);
+
+  /**
+   * Called when the server sends a close message. This may have been initiated from a call to
+   * {@link WebSocket#close(int, String) close()} or as an unprompted message from the server.
+   * If you did not explicitly call {@link WebSocket#close(int, String) close()}, you do not need
+   * to do so in response to this callback. A matching close frame is automatically sent back to
+   * the server.
+   *
+   * @param code The <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC-compliant</a>
+   * status code.
+   * @param reason Reason for close or an empty string.
+   */
+  void onClose(int code, String reason);
+
+  /**
+   * Called when the transport or protocol layer of this web socket errors during communication, or
+   * when another listener callback throws an exception. If the web socket was successfully
+   * {@linkplain #onOpen opened} before this callback, it will have been closed automatically and
+   * future interactions with it will throw {@link IOException}.
+   *
+   * @param response Non-null when the failure is because of an unexpected HTTP response (e.g.,
+   * failed upgrade, non-101 response code, etc.).
+   */
+  void onFailure(Throwable t, Response response);
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 48c911a267..6a25d3cdf8 100755
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -19,7 +19,6 @@
 import java.net.UnknownHostException;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
-import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
@@ -63,8 +62,4 @@ public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
 
   public abstract HttpUrl getHttpUrlChecked(String url)
       throws MalformedURLException, UnknownHostException;
-
-  public abstract StreamAllocation callEngineGetStreamAllocation(Call call);
-
-  public abstract void setCallWebSocket(Call call);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 56dfdf555e..d31b55ae10 100755
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -36,7 +36,10 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
 import okhttp3.HttpUrl;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
 import okio.Buffer;
+import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
@@ -45,8 +48,20 @@
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final ResponseBody EMPTY_RESPONSE = ResponseBody.create(null, EMPTY_BYTE_ARRAY);
+  public static final RequestBody EMPTY_REQUEST = RequestBody.create(null, EMPTY_BYTE_ARRAY);
+
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("efbbff");
+  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("feff");
+  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("fffe");
+  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000ffff");
+  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
+
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
+  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
+  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
@@ -424,4 +439,35 @@ public static boolean verifyAsIpAddress(String host) {
   public static String format(String format, Object... args) {
     return String.format(Locale.US, format, args);
   }
+
+  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
+    if (source.rangeEquals(0, UTF_8_BOM)) {
+      source.skip(UTF_8_BOM.size());
+      return UTF_8;
+    }
+    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
+      source.skip(UTF_16_BE_BOM.size());
+      return UTF_16_BE;
+    }
+    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
+      source.skip(UTF_16_LE_BOM.size());
+      return UTF_16_LE;
+    }
+    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
+      source.skip(UTF_32_BE_BOM.size());
+      return UTF_32_BE;
+    }
+    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
+      source.skip(UTF_32_LE_BOM.size());
+      return UTF_32_LE;
+    }
+    return charset;
+  }
+
+  /** Re-throws {@code t} if it is a fatal exception which should not be handled. */
+  public static void throwIfFatal(Throwable t) {
+    if (t instanceof VirtualMachineError) throw (VirtualMachineError) t;
+    if (t instanceof ThreadDeath) throw (ThreadDeath) t;
+    if (t instanceof LinkageError) throw (LinkageError) t;
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 00d1d7586c..2b848e0971 100755
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -20,12 +20,11 @@
 import java.util.Date;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
-import okhttp3.MediaType;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
-import okhttp3.ResponseBody;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpCodec;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
@@ -45,20 +44,6 @@
 
 /** Serves requests from the cache and writes responses to the cache. */
 public final class CacheInterceptor implements Interceptor {
-  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-
-    @Override public long contentLength() {
-      return 0;
-    }
-
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
-
   final InternalCache cache;
 
   public CacheInterceptor(InternalCache cache) {
@@ -91,7 +76,7 @@ public CacheInterceptor(InternalCache cache) {
           .protocol(Protocol.HTTP_1_1)
           .code(504)
           .message("Unsatisfiable Request (only-if-cached)")
-          .body(EMPTY_BODY)
+          .body(Util.EMPTY_RESPONSE)
           .sentRequestAtMillis(-1L)
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build();
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 8b7b7f2a02..4d3ef616ab 100755
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -35,13 +35,11 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.io.FileSystem;
 import okhttp3.internal.platform.Platform;
-import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
 import okio.Source;
-import okio.Timeout;
 
 import static okhttp3.internal.platform.Platform.WARN;
 
@@ -187,7 +185,7 @@ public void run() {
           }
         } catch (IOException e) {
           mostRecentRebuildFailed = true;
-          journalWriter = Okio.buffer(NULL_SINK);
+          journalWriter = Okio.buffer(Okio.blackhole());
         }
       }
     }
@@ -822,22 +820,6 @@ public void close() {
     }
   }
 
-  private static final Sink NULL_SINK = new Sink() {
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      source.skip(byteCount);
-    }
-
-    @Override public void flush() throws IOException {
-    }
-
-    @Override public Timeout timeout() {
-      return Timeout.NONE;
-    }
-
-    @Override public void close() throws IOException {
-    }
-  };
-
   /** Edits the values for an entry. */
   public final class Editor {
     private final Entry entry;
@@ -899,7 +881,7 @@ public Sink newSink(int index) {
           throw new IllegalStateException();
         }
         if (entry.currentEditor != this) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         if (!entry.readable) {
           written[index] = true;
@@ -909,7 +891,7 @@ public Sink newSink(int index) {
         try {
           sink = fileSystem.sink(dirtyFile);
         } catch (FileNotFoundException e) {
-          return NULL_SINK;
+          return Okio.blackhole();
         }
         return new FaultHidingSink(sink) {
           @Override protected void onException(IOException e) {
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 3652cba0c6..42d91038a8 100755
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -186,7 +186,9 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
     try {
       Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
     } catch (ConnectException e) {
-      throw new ConnectException("Failed to connect to " + route.socketAddress());
+      ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress());
+      ce.initCause(e);
+      throw ce;
     }
     source = Okio.buffer(Okio.source(rawSocket));
     sink = Okio.buffer(Okio.sink(rawSocket));
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index 57d4cbdb35..6adbc28b56 100755
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -20,6 +20,7 @@
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okio.BufferedSink;
 import okio.Okio;
@@ -57,7 +58,13 @@ public CallServerInterceptor(boolean forWebSocket) {
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build();
 
-    if (!forWebSocket || response.code() != 101) {
+    int code = response.code();
+    if (forWebSocket && code == 101) {
+      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+      response = response.newBuilder()
+          .body(Util.EMPTY_RESPONSE)
+          .build();
+    } else {
       response = response.newBuilder()
           .body(httpCodec.openResponseBody(response))
           .build();
@@ -68,7 +75,6 @@ public CallServerInterceptor(boolean forWebSocket) {
       streamAllocation.noNewStreams();
     }
 
-    int code = response.code();
     if ((code == 204 || code == 205) && response.body().contentLength() > 0) {
       throw new ProtocolException(
           "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength());
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 4122740e0a..2a7cd13822 100755
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -62,13 +62,14 @@
   private static final int MAX_FOLLOW_UPS = 20;
 
   private final OkHttpClient client;
+  private final boolean forWebSocket;
   private StreamAllocation streamAllocation;
-  private boolean forWebSocket;
   private Object callStackTrace;
   private volatile boolean canceled;
 
-  public RetryAndFollowUpInterceptor(OkHttpClient client) {
+  public RetryAndFollowUpInterceptor(OkHttpClient client, boolean forWebSocket) {
     this.client = client;
+    this.forWebSocket = forWebSocket;
   }
 
   /**
@@ -90,14 +91,6 @@ public boolean isCanceled() {
     return canceled;
   }
 
-  public void setForWebSocket(boolean forWebSocket) {
-    this.forWebSocket = forWebSocket;
-  }
-
-  public boolean isForWebSocket() {
-    return forWebSocket;
-  }
-
   public void setCallStackTrace(Object callStackTrace) {
     this.callStackTrace = callStackTrace;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Header.java b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
index 638e550848..3cfd7be8d7 100755
--- a/okhttp/src/main/java/okhttp3/internal/http2/Header.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Header.java
@@ -21,6 +21,7 @@
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
   // Special header names defined in HTTP/2 spec.
+  public static final ByteString PSEUDO_PREFIX = ByteString.encodeUtf8(":");
   public static final ByteString RESPONSE_STATUS = ByteString.encodeUtf8(":status");
   public static final ByteString TARGET_METHOD = ByteString.encodeUtf8(":method");
   public static final ByteString TARGET_PATH = ByteString.encodeUtf8(":path");
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index 405c2e273d..3aeed262b4 100755
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -152,7 +152,6 @@ private void adjustDynamicTableByteCount() {
     }
 
     private void clearDynamicTable() {
-      headerList.clear();
       Arrays.fill(dynamicTable, null);
       nextHeaderIndex = dynamicTable.length - 1;
       headerCount = 0;
@@ -463,29 +462,62 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
         smallestHeaderTableSizeSetting = Integer.MAX_VALUE;
         writeInt(maxDynamicTableByteCount, PREFIX_5_BITS, 0x20);
       }
-      // TODO: implement index tracking
+
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         Header header = headerBlock.get(i);
         ByteString name = header.name.toAsciiLowercase();
         ByteString value = header.value;
+        int headerIndex = -1;
+        int headerNameIndex = -1;
+
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
-          // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
+          headerNameIndex = staticIndex + 1;
+          if (headerNameIndex > 1 && headerNameIndex < 8) {
+            // Only search a subset of the static header table. Most entries have an empty value, so
+            // it's unnecessary to waste cycles looking at them. This check is built on the
+            // observation that the header entries we care about are in adjacent pairs, and we
+            // always know the first index of the pair.
+            if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex - 1].value, value)) {
+              headerIndex = headerNameIndex;
+            } else if (Util.equal(STATIC_HEADER_TABLE[headerNameIndex].value, value)) {
+              headerIndex = headerNameIndex + 1;
+            }
+          }
+        }
+
+        if (headerIndex == -1) {
+          for (int j = nextHeaderIndex + 1, length = dynamicTable.length; j < length; j++) {
+            if (Util.equal(dynamicTable[j].name, name)) {
+              if (Util.equal(dynamicTable[j].value, value)) {
+                headerIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+                break;
+              } else if (headerNameIndex == -1) {
+                headerNameIndex = j - nextHeaderIndex + STATIC_HEADER_TABLE.length;
+              }
+            }
+          }
+        }
+
+        if (headerIndex != -1) {
+          // Indexed Header Field.
+          writeInt(headerIndex, PREFIX_7_BITS, 0x80);
+        } else if (headerNameIndex == -1) {
+          // Literal Header Field with Incremental Indexing - New Name.
+          out.writeByte(0x40);
+          writeByteString(name);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
+        } else if (name.startsWith(Header.PSEUDO_PREFIX) && !Header.TARGET_AUTHORITY.equals(name)) {
+          // Follow Chromes lead - only include the :authority pseudo header, but exclude all other
+          // pseudo headers. Literal Header Field without Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_4_BITS, 0);
           writeByteString(value);
         } else {
-          int dynamicIndex = Util.indexOf(dynamicTable, header);
-          if (dynamicIndex != -1) {
-            // Indexed Header.
-            writeInt(dynamicIndex - nextHeaderIndex + STATIC_HEADER_TABLE.length, PREFIX_7_BITS,
-                0x80);
-          } else {
-            // Literal Header Field with Incremental Indexing - New Name
-            out.writeByte(0x40);
-            writeByteString(name);
-            writeByteString(value);
-            insertIntoDynamicTable(header);
-          }
+          // Literal Header Field with Incremental Indexing - Indexed Name.
+          writeInt(headerNameIndex, PREFIX_6_BITS, 0x40);
+          writeByteString(value);
+          insertIntoDynamicTable(header);
         }
       }
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
new file mode 100755
index 0000000000..bf7d1d60f5
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.ws;
+
+import java.io.IOException;
+import java.net.ProtocolException;
+import java.util.Random;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okhttp3.internal.NamedRunnable;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
+
+import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_ABNORMAL_TERMINATION;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_PROTOCOL_EXCEPTION;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
+import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
+import static okhttp3.internal.ws.WebSocketReader.FrameCallback;
+
+/**
+ * An implementation of {@link WebSocket} which sits on top of {@link WebSocketReader} and
+ * {@link WebSocketWriter}.
+ *
+ * <h2>Threading</h2>
+ * This class deals with three threads concurrently and care must be taken to only access the
+ * appropriate resources on each:
+ * <ul>
+ * <li><b>Reader</b>: This is the only thread allowed to access {@link #reader}. Methods from
+ * {@link FrameCallback} will happen on this thread as a result. This is the only thread that
+ * should invoke methods on the {@link #readerListener}.</li>
+ * <li><b>Replier</b>: Invoked on {@link #replier} to write responses from reading
+ * frames. Contends with the "Sender" thread for access to {@link #writer}.</li>
+ * <li><b>Sender</b>: Methods from {@link WebSocket} will happen on this thread. Contends with the
+ * "Replier" thread</li>
+ * </ul>
+ * Instance variables have prefixes matching the thread names based on the thread on which they can
+ * be accessed. A prefix of "writer" indicates both "Sender" and "Replier" threads can access.
+ */
+public abstract class RealWebSocket implements WebSocket, FrameCallback {
+  private final WebSocketReader reader;
+  private final WebSocketListener readerListener;
+  /** True after a close frame was read by the reader. No frames will follow it. */
+  private boolean readerSawClose;
+
+  final WebSocketWriter writer;
+  /** True after calling {@link WebSocketWriter#writeClose(int, String)} to send a close frame. */
+  final AtomicBoolean writerClosed = new AtomicBoolean();
+
+  /** Guarded by itself. Must check {@link #isShutdown} before enqueuing work. */
+  private final Executor replier;
+
+  /** True after calling {@link #close(int, String)}. No writes are allowed afterward. */
+  private boolean senderSentClose;
+  /** True after {@link IOException}. {@link #close(int, String)} becomes only valid call. */
+  private boolean senderWantsClose;
+
+  private final Response response;
+  private final String name;
+
+  /** Guarded by {@link #replier}. True after calling {@link #shutdown()}. */
+  private boolean isShutdown;
+
+  protected RealWebSocket(boolean isClient, BufferedSource source, BufferedSink sink, Random random,
+      Executor replier, WebSocketListener readerListener, Response response, String name) {
+    this.readerListener = readerListener;
+    this.replier = replier;
+    this.response = response;
+    this.name = name;
+
+    reader = new WebSocketReader(isClient, source, this);
+    writer = new WebSocketWriter(isClient, sink, random);
+  }
+
+  ////// READER THREAD
+
+  /** Read and process all socket messages delivering callbacks to the supplied listener. */
+  public final void loopReader() {
+    try {
+      readerListener.onOpen(this, response);
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      readerListener.onFailure(t, null);
+      return;
+    }
+
+    while (processNextFrame()) {
+    }
+  }
+
+  /**
+   * Read a single control frame or all frames of a message from the web socket and deliver any
+   * notifications to the listener. Returns false when no more messages can be read.
+   */
+  final boolean processNextFrame() {
+    try {
+      // This method call results in one or more onRead* methods being called on this thread.
+      reader.processNextFrame();
+
+      return !readerSawClose;
+    } catch (Throwable t) {
+      Util.throwIfFatal(t);
+      replyToReaderError(t);
+      if (t instanceof IOException && !(t instanceof ProtocolException)) {
+        readerListener.onClose(CLOSE_ABNORMAL_TERMINATION, "");
+      } else {
+        readerListener.onFailure(t, null);
+      }
+      return false;
+    }
+  }
+
+  @Override public final void onReadMessage(ResponseBody message) throws IOException {
+    readerListener.onMessage(message);
+  }
+
+  @Override public final void onReadPing(ByteString buffer) {
+    replyToPeerPing(buffer);
+  }
+
+  @Override public final void onReadPong(ByteString buffer) {
+    readerListener.onPong(buffer);
+  }
+
+  @Override public final void onReadClose(int code, String reason) {
+    replyToPeerClose(code, reason);
+    readerSawClose = true;
+    readerListener.onClose(code, reason);
+  }
+
+  ///// REPLIER THREAD (executed on replier, contends with sender thread)
+
+  /** Replies with a pong when a ping frame is read from the peer. */
+  private void replyToPeerPing(final ByteString payload) {
+    Runnable replierPong = new NamedRunnable("OkHttp %s WebSocket Pong Reply", name) {
+      @Override protected void execute() {
+        try {
+          writer.writePong(payload);
+        } catch (IOException t) {
+          Platform.get().log(INFO, "Unable to send pong reply in response to peer ping.", t);
+        }
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierPong);
+      }
+    }
+  }
+
+  /** Replies and closes this web socket when a close frame is read from the peer. */
+  private void replyToPeerClose(final int code, final String reason) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Close Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          try {
+            writer.writeClose(code, reason);
+          } catch (IOException t) {
+            Platform.get().log(INFO, "Unable to send close reply in response to peer close.", t);
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
+    }
+  }
+
+  private void replyToReaderError(final Throwable t) {
+    Runnable replierClose = new NamedRunnable("OkHttp %s WebSocket Fatal Reply", name) {
+      @Override protected void execute() {
+        if (writerClosed.compareAndSet(false, true)) {
+          // For protocol and runtime exceptions, try to inform the server of such.
+          boolean protocolException = t instanceof ProtocolException;
+          boolean runtimeException = !(t instanceof IOException);
+          if (protocolException || runtimeException) {
+            int code = protocolException ? CLOSE_PROTOCOL_EXCEPTION : CLOSE_CLIENT_GOING_AWAY;
+            try {
+              writer.writeClose(code, null);
+            } catch (IOException inner) {
+              Platform.get()
+                  .log(INFO, "Unable to send close in response to listener error.", inner);
+            }
+          }
+        }
+
+        quietlyCloseConnection();
+      }
+    };
+    synchronized (replier) {
+      if (!isShutdown) {
+        replier.execute(replierClose);
+      }
+    }
+  }
+
+  ////// SENDER THREAD (aka user thread)
+
+  @Override public final void sendMessage(RequestBody message) throws IOException {
+    if (message == null) throw new NullPointerException("message == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    MediaType contentType = message.contentType();
+    if (contentType == null) {
+      throw new IllegalArgumentException(
+          "Message content type was null. Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+    String contentSubtype = contentType.subtype();
+
+    int formatOpcode;
+    if (WebSocket.TEXT.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_TEXT;
+    } else if (WebSocket.BINARY.subtype().equals(contentSubtype)) {
+      formatOpcode = OPCODE_BINARY;
+    } else {
+      throw new IllegalArgumentException("Unknown message content type: "
+          + contentType.type() + "/" + contentType.subtype() // Omit any implicitly added charset.
+          + ". Must use WebSocket.TEXT or WebSocket.BINARY.");
+    }
+
+    BufferedSink sink = Okio.buffer(writer.newMessageSink(formatOpcode, message.contentLength()));
+    try {
+      message.writeTo(sink);
+      sink.close();
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public final void sendPing(ByteString payload) throws IOException {
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePing(payload);
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  /** Send an unsolicited pong with the specified payload. */
+  final void sendPong(ByteString payload) throws IOException {
+    if (payload == null) throw new NullPointerException("payload == null");
+    if (senderSentClose) throw new IllegalStateException("closed");
+    if (senderWantsClose) throw new IllegalStateException("must call close()");
+
+    try {
+      writer.writePong(payload);
+    } catch (IOException e) {
+      senderWantsClose = true;
+      throw e;
+    }
+  }
+
+  @Override public final void close(int code, String reason) throws IOException {
+    if (senderSentClose) throw new IllegalStateException("closed");
+    senderSentClose = true;
+
+    // Not doing a CAS because we want writer to throw if already closed via peer close.
+    writerClosed.set(true);
+
+    try {
+      writer.writeClose(code, reason);
+    } catch (IOException e) {
+      quietlyCloseConnection();
+      throw e;
+    }
+
+    // NOTE: We do not close the connection here! That will happen when we read the close reply.
+  }
+
+  ////// ANY THREAD
+
+  void quietlyCloseConnection() {
+    synchronized (replier) {
+      if (isShutdown) return;
+      isShutdown = true;
+    }
+    try {
+      shutdown();
+    } catch (Throwable inner) {
+      Util.throwIfFatal(inner);
+      Platform.get().log(INFO, "Unable to close web socket connection.", inner);
+    }
+  }
+
+  /** Perform any tear-down work (close the connection, shutdown executors). */
+  protected abstract void shutdown();
+}
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
similarity index 88%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 0a1126a147..bff2d9c992 100755
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.IOException;
 import java.net.ProtocolException;
 
 public final class WebSocketProtocol {
@@ -84,6 +85,15 @@
    */
   static final int PAYLOAD_LONG = 127;
 
+  /** Used when an unchecked exception was thrown in a listener. */
+  static final int CLOSE_CLIENT_GOING_AWAY = 1001;
+  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
+  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
+  /** Used when an empty close frame was received (i.e., without a status code). */
+  static final int CLOSE_NO_STATUS_CODE = 1005;
+  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
+  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
+
   static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
     int keyLength = key.length;
     for (int i = 0; i < byteCount; i++, frameBytesRead++) {
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
similarity index 82%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 8be28a2c5a..bb6f5760d8 100755
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -20,9 +20,10 @@
 import java.net.ProtocolException;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
+import okhttp3.WebSocket;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 import okio.Okio;
 import okio.Source;
 import okio.Timeout;
@@ -35,6 +36,7 @@
 import static okhttp3.internal.ws.WebSocketProtocol.B0_MASK_OPCODE;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK;
 import static okhttp3.internal.ws.WebSocketProtocol.B1_MASK_LENGTH;
+import static okhttp3.internal.ws.WebSocketProtocol.CLOSE_NO_STATUS_CODE;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTINUATION;
 import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_CONTROL_CLOSE;
@@ -50,39 +52,38 @@
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
+ * <p>
+ * This class is not thread safe.
  */
-public final class WebSocketReader {
+final class WebSocketReader {
   public interface FrameCallback {
-    void onMessage(ResponseBody body) throws IOException;
-
-    void onPing(Buffer buffer);
-
-    void onPong(Buffer buffer);
-
-    void onClose(int code, String reason);
+    void onReadMessage(ResponseBody body) throws IOException;
+    void onReadPing(ByteString buffer);
+    void onReadPong(ByteString buffer);
+    void onReadClose(int code, String reason);
   }
 
-  private final boolean isClient;
-  private final BufferedSource source;
-  private final FrameCallback frameCallback;
+  final boolean isClient;
+  final BufferedSource source;
+  final FrameCallback frameCallback;
 
-  private final Source framedMessageSource = new FramedMessageSource();
+  final Source framedMessageSource = new FramedMessageSource();
 
-  private boolean closed;
-  private boolean messageClosed;
+  boolean closed;
+  boolean messageClosed;
 
   // Stateful data about the current frame.
-  private int opcode;
-  private long frameLength;
-  private long frameBytesRead;
-  private boolean isFinalFrame;
-  private boolean isControlFrame;
-  private boolean isMasked;
+  int opcode;
+  long frameLength;
+  long frameBytesRead;
+  boolean isFinalFrame;
+  boolean isControlFrame;
+  boolean isMasked;
 
-  private final byte[] maskKey = new byte[4];
-  private final byte[] maskBuffer = new byte[8192];
+  final byte[] maskKey = new byte[4];
+  final byte[] maskBuffer = new byte[8192];
 
-  public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
+  WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
     if (frameCallback == null) throw new NullPointerException("frameCallback == null");
     this.isClient = isClient;
@@ -96,11 +97,11 @@ public WebSocketReader(boolean isClient, BufferedSource source, FrameCallback fr
    * <ul>
    *     <li>If it is a control frame this will result in a single call to {@link FrameCallback}.
    *     <li>If it is a message frame this will result in a single call to {@link
-   *         FrameCallback#onMessage}. If the message spans multiple frames, each interleaved
+   *         FrameCallback#onReadMessage}. If the message spans multiple frames, each interleaved
    *         control frame will result in a corresponding call to {@link FrameCallback}.
    * </ul>
    */
-  public void processNextFrame() throws IOException {
+  void processNextFrame() throws IOException {
     readHeader();
     if (isControlFrame) {
       readControlFrame();
@@ -136,7 +137,9 @@ private void readHeader() throws IOException {
     isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
-      throw new ProtocolException("Client-sent frames must be masked. Server sent must not.");
+      throw new ProtocolException(isClient
+          ? "Server-sent frames must not be masked."
+          : "Client-sent frames must be masked.");
     }
 
     // Get frame length, optionally reading from follow-up bytes if indicated by special values.
@@ -163,10 +166,8 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = null;
+    Buffer buffer = new Buffer();
     if (frameBytesRead < frameLength) {
-      buffer = new Buffer();
-
       if (isClient) {
         source.readFully(buffer, frameLength);
       } else {
@@ -183,26 +184,23 @@ private void readControlFrame() throws IOException {
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onPing(buffer);
+        frameCallback.onReadPing(buffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onPong(buffer);
+        frameCallback.onReadPong(buffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
-        int code = 1000;
+        int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        if (buffer != null) {
-          long bufferSize = buffer.size();
-          if (bufferSize == 1) {
-            throw new ProtocolException("Malformed close payload length of 1.");
-          } else if (bufferSize != 0) {
-            code = buffer.readShort();
-            validateCloseCode(code, false);
-
-            reason = buffer.readUtf8();
-          }
+        long bufferSize = buffer.size();
+        if (bufferSize == 1) {
+          throw new ProtocolException("Malformed close payload length of 1.");
+        } else if (bufferSize != 0) {
+          code = buffer.readShort();
+          reason = buffer.readUtf8();
+          validateCloseCode(code, false);
         }
-        frameCallback.onClose(code, reason);
+        frameCallback.onReadClose(code, reason);
         closed = true;
         break;
       default:
@@ -239,14 +237,14 @@ private void readMessageFrame() throws IOException {
     };
 
     messageClosed = false;
-    frameCallback.onMessage(body);
+    frameCallback.onReadMessage(body);
     if (!messageClosed) {
       throw new IllegalStateException("Listener failed to call close on message payload.");
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  private void readUntilNonControlFrame() throws IOException {
+  void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -261,7 +259,7 @@ private void readUntilNonControlFrame() throws IOException {
    * frames that occur between fragments will be processed. If the message payload is masked this
    * will unmask as it's being processed.
    */
-  private final class FramedMessageSource implements Source {
+  final class FramedMessageSource implements Source {
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (closed) throw new IOException("closed");
       if (messageClosed) throw new IllegalStateException("closed");
diff --git a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
similarity index 72%
rename from okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
rename to okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 6ce0cfdd0a..e232857eed 100755
--- a/okhttp-ws/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -19,7 +19,7 @@
 import java.util.Random;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
+import okio.ByteString;
 import okio.Sink;
 import okio.Timeout;
 
@@ -44,24 +44,24 @@
  * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
  * the wire with frames from the "main" sending thread.
  */
-public final class WebSocketWriter {
-  private final boolean isClient;
-  private final Random random;
+final class WebSocketWriter {
+  final boolean isClient;
+  final Random random;
 
   /** Writes must be guarded by synchronizing on 'this'. */
-  private final BufferedSink sink;
+  final BufferedSink sink;
   /** Access must be guarded by synchronizing on 'this'. */
-  private boolean writerClosed;
+  boolean writerClosed;
 
-  private final Buffer buffer = new Buffer();
-  private final FrameSink frameSink = new FrameSink();
+  final Buffer buffer = new Buffer();
+  final FrameSink frameSink = new FrameSink();
 
-  private boolean activeWriter;
+  boolean activeWriter;
 
-  private final byte[] maskKey;
-  private final byte[] maskBuffer;
+  final byte[] maskKey;
+  final byte[] maskBuffer;
 
-  public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
+  WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
@@ -73,15 +73,15 @@ public WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     maskBuffer = isClient ? new byte[8192] : null;
   }
 
-  /** Send a ping with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePing(Buffer payload) throws IOException {
+  /** Send a ping with the supplied {@code payload}. */
+  void writePing(ByteString payload) throws IOException {
     synchronized (this) {
       writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
     }
   }
 
-  /** Send a pong with the supplied {@code payload}. Payload may be {@code null} */
-  public void writePong(Buffer payload) throws IOException {
+  /** Send a pong with the supplied {@code payload}. */
+  void writePong(ByteString payload) throws IOException {
     synchronized (this) {
       writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
     }
@@ -94,37 +94,38 @@ public void writePong(Buffer payload) throws IOException {
    * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
    * @param reason Reason for shutting down or {@code null}.
    */
-  public void writeClose(int code, String reason) throws IOException {
-    Buffer payload = null;
+  void writeClose(int code, String reason) throws IOException {
+    ByteString payload = ByteString.EMPTY;
     if (code != 0 || reason != null) {
       if (code != 0) {
         validateCloseCode(code, true);
       }
-      payload = new Buffer();
-      payload.writeShort(code);
+      Buffer buffer = new Buffer();
+      buffer.writeShort(code);
       if (reason != null) {
-        payload.writeUtf8(reason);
+        buffer.writeUtf8(reason);
       }
+      payload = buffer.readByteString();
     }
 
     synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
-      writerClosed = true;
+      try {
+        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
+      } finally {
+        writerClosed = true;
+      }
     }
   }
 
-  private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IOException {
+  private void writeControlFrameSynchronized(int opcode, ByteString payload) throws IOException {
     assert Thread.holdsLock(this);
 
     if (writerClosed) throw new IOException("closed");
 
-    int length = 0;
-    if (payload != null) {
-      length = (int) payload.size();
-      if (length > PAYLOAD_BYTE_MAX) {
-        throw new IllegalArgumentException(
-            "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
-      }
+    int length = payload.size();
+    if (length > PAYLOAD_BYTE_MAX) {
+      throw new IllegalArgumentException(
+          "Payload size must be less than or equal to " + PAYLOAD_BYTE_MAX);
     }
 
     int b0 = B0_FLAG_FIN | opcode;
@@ -138,25 +139,22 @@ private void writeControlFrameSynchronized(int opcode, Buffer payload) throws IO
       random.nextBytes(maskKey);
       sink.write(maskKey);
 
-      if (payload != null) {
-        writeMaskedSynchronized(payload, length);
-      }
+      byte[] bytes = payload.toByteArray();
+      toggleMask(bytes, bytes.length, maskKey, 0);
+      sink.write(bytes);
     } else {
       sink.writeByte(b1);
-
-      if (payload != null) {
-        sink.writeAll(payload);
-      }
+      sink.write(payload);
     }
 
-    sink.emit();
+    sink.flush();
   }
 
   /**
    * Stream a message payload as a series of frames. This allows control frames to be interleaved
    * between parts of the message.
    */
-  public Sink newMessageSink(int formatOpcode, long contentLength) {
+  Sink newMessageSink(int formatOpcode, long contentLength) {
     if (activeWriter) {
       throw new IllegalStateException("Another message writer is active. Did you call close()?");
     }
@@ -171,7 +169,7 @@ public Sink newMessageSink(int formatOpcode, long contentLength) {
     return frameSink;
   }
 
-  private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+  void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
       boolean isFinal) throws IOException {
     assert Thread.holdsLock(this);
 
@@ -186,7 +184,6 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     int b1 = 0;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      random.nextBytes(maskKey);
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
@@ -202,8 +199,17 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     }
 
     if (isClient) {
+      random.nextBytes(maskKey);
       sink.write(maskKey);
-      writeMaskedSynchronized(buffer, byteCount);
+
+      for (long written = 0; written < byteCount; ) {
+        int toRead = (int) Math.min(byteCount, maskBuffer.length);
+        int read = buffer.read(maskBuffer, 0, toRead);
+        if (read == -1) throw new AssertionError();
+        toggleMask(maskBuffer, read, maskKey, written);
+        sink.write(maskBuffer, 0, read);
+        written += read;
+      }
     } else {
       sink.write(buffer, byteCount);
     }
@@ -211,25 +217,11 @@ private void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boo
     sink.emit();
   }
 
-  private void writeMaskedSynchronized(BufferedSource source, long byteCount) throws IOException {
-    assert Thread.holdsLock(this);
-
-    long written = 0;
-    while (written < byteCount) {
-      int toRead = (int) Math.min(byteCount, maskBuffer.length);
-      int read = source.read(maskBuffer, 0, toRead);
-      if (read == -1) throw new AssertionError();
-      toggleMask(maskBuffer, read, maskKey, written);
-      sink.write(maskBuffer, 0, read);
-      written += read;
-    }
-  }
-
-  private final class FrameSink implements Sink {
-    private int formatOpcode;
-    private long contentLength;
-    private boolean isFirstFrame;
-    private boolean closed;
+  final class FrameSink implements Sink {
+    int formatOpcode;
+    long contentLength;
+    boolean isFirstFrame;
+    boolean closed;
 
     @Override public void write(Buffer source, long byteCount) throws IOException {
       if (closed) throw new IOException("closed");
diff --git a/pom.xml b/pom.xml
index d769d52c27..aff4da184f 100755
--- a/pom.xml
+++ b/pom.xml
@@ -28,9 +28,6 @@
     <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
 
-    <module>okhttp-ws</module>
-    <module>okhttp-ws-tests</module>
-
     <module>okhttp-logging-interceptor</module>
 
     <module>okcurl</module>
@@ -53,7 +50,7 @@
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.9.0</okio.version>
+    <okio.version>1.10.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index ba8e54ec85..2d0c791c38 100755
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -18,11 +18,6 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>okhttp-ws</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
index 77fb4db7a3..77c873020d 100755
--- a/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/WebSocketEcho.java
@@ -4,25 +4,22 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
-
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.ws.WebSocket;
-import okhttp3.ws.WebSocketCall;
-import okhttp3.ws.WebSocketListener;
-import okio.Buffer;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
 import okio.ByteString;
 
-import static okhttp3.ws.WebSocket.BINARY;
-import static okhttp3.ws.WebSocket.TEXT;
+import static okhttp3.WebSocket.BINARY;
+import static okhttp3.WebSocket.TEXT;
 
 public final class WebSocketEcho implements WebSocketListener {
   private final ExecutorService writeExecutor = Executors.newSingleThreadExecutor();
 
-  private void run() throws IOException {
+  private void run() {
     OkHttpClient client = new OkHttpClient.Builder()
         .readTimeout(0,  TimeUnit.MILLISECONDS)
         .build();
@@ -30,7 +27,7 @@ private void run() throws IOException {
     Request request = new Request.Builder()
         .url("ws://echo.websocket.org")
         .build();
-    WebSocketCall.create(client, request).enqueue(this);
+    client.newWebSocketCall(request).enqueue(this);
 
     // Trigger shutdown of the dispatcher's executor so this process can exit cleanly.
     client.dispatcher().executorService().shutdown();
@@ -60,8 +57,8 @@ private void run() throws IOException {
     message.close();
   }
 
-  @Override public void onPong(Buffer payload) {
-    System.out.println("PONG: " + payload.readUtf8());
+  @Override public void onPong(ByteString payload) {
+    System.out.println("PONG: " + payload.utf8());
   }
 
   @Override public void onClose(int code, String reason) {
@@ -69,12 +66,12 @@ private void run() throws IOException {
     writeExecutor.shutdown();
   }
 
-  @Override public void onFailure(IOException e, Response response) {
-    e.printStackTrace();
+  @Override public void onFailure(Throwable t, Response response) {
+    t.printStackTrace();
     writeExecutor.shutdown();
   }
 
-  public static void main(String... args) throws IOException {
+  public static void main(String... args) {
     new WebSocketEcho().run();
   }
 }
