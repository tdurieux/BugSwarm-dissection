diff --git a/source/Overview/FrameworkStack.rst b/source/Overview/FrameworkStack.rst
index 062dc191aa..e2ae1acb7b 100755
--- a/source/Overview/FrameworkStack.rst
+++ b/source/Overview/FrameworkStack.rst
@@ -623,38 +623,54 @@ version 5.0.1.RELEASEで利用するOSSの一覧を以下に示す。
       - Webに依存しない汎用的に使用できる機能と依存関係定義を提供する。
       - 有
     * - \ (2)
-      - terasoluna-gfw-jodatime
-      - Joda Timeに依存する機能と依存関係定義を提供する。
+      - terasoluna-gfw-string
+      - 文字列処理に関連する機能を提供する。(5.1.0から追加)
       - 有
     * - \ (3)
-      - terasoluna-gfw-web
-      - Webアプリケーションを作成する場合に使用する機能と依存関係定義を提供する。
+      - terasoluna-gfw-codepoints
+      - 対象の文字列を構成するコードポイントがコードポイント集合に含まれることをチェックする機能を提供する。(5.1.0から追加)
       - 有
     * - \ (4)
+      - terasoluna-gfw-validator
+      - 汎用的なBean Validationの制約アノテーションを追加して提供する。(5.1.0から追加)
+      - 有
+    * - \ (5)
+      - terasoluna-gfw-jodatime
+      - Joda Timeに依存する機能と依存関係定義を提供する。(5.0.0から追加)
+      - 有
+    * - \ (6)
+      - terasoluna-gfw-web
+      - Webアプリケーションを作成する場合に使用する機能と依存関係定義を提供する。Viewに依存しない機能や依存関係定義を集約している。
+      - 有
+    * - \ (7)
+      - terasoluna-gfw-web-jsp
+      - ViewにJSPを採用するWebアプリケーションを作成する場合に使用する機能と依存関係定義を提供する。
+      - 有
+    * - \ (8)
       - terasoluna-gfw-mybatis3
       - MyBatis3を使用する場合の依存関係定義を提供する。
       - 無
-    * - \ (5)
+    * - \ (9)
       - terasoluna-gfw-jpa
       - JPAを使用する場合の依存関係定義を提供する。
       - 無
-    * - \ (6)
+    * - \ (10)
       - terasoluna-gfw-security-core
       - Spring Securityを使用する場合の依存関係定義(Web以外)を提供する。
       - 無
-    * - \ (7)
+    * - \ (11)
       - terasoluna-gfw-security-web
       - Spring Securityを使用する場合の依存関係定義(Web関連)とSpring Securityの拡張部品を提供する。
       - 有
-    * - \ (8)
+    * - \ (12)
       - terasoluna-gfw-recommended-dependencies
       - Webに依存しない推奨ライブラリへの依存関係定義を提供する。
       - 無
-    * - \ (9)
+    * - \ (13)
       - terasoluna-gfw-recommended-web-dependencies
       - Webに依存する推奨ライブラリへの依存関係定義を提供する。
       - 無
-    * - \ (10)
+    * - \ (14)
       - terasoluna-gfw-parent
       - 依存ライブラリの管理とビルド用プラグインの推奨設定を提供する。
       - 無
@@ -705,6 +721,65 @@ terasoluna-gfw-commonは以下の部品を提供している。
       - シーケンサ
       - シーケンス値を取得するためのクラスを提供する。
 
+terasoluna-gfw-string
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+terasoluna-gfw-stringは以下の部品を提供している。
+
+.. tabularcolumns:: |p{0.20\linewidth}|p{0.30\linewidth}|p{0.50\linewidth}|
+.. list-table::
+    :header-rows: 1
+    :widths: 20 30 50
+
+    * - 分類
+      - 部品名
+      - 説明
+    * - :doc:`../ArchitectureInDetail/Utilities/StringProcessing`
+      - 半角全角変換
+      - 半角文字列と全角文字列のマッピングテーブルに基づき、入力文字列の半角文字を全角に変換する処理と全角文字を半角に変換する処理を行うクラスを提供する。
+
+
+terasoluna-gfw-codepoints
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+terasoluna-gfw-codepointsは以下の部品を提供している。
+
+.. tabularcolumns:: |p{0.20\linewidth}|p{0.30\linewidth}|p{0.50\linewidth}|
+.. list-table::
+    :header-rows: 1
+    :widths: 20 30 50
+
+    * - 分類
+      - 部品名
+      - 説明
+    * - :doc:`../ArchitectureInDetail/Utilities/StringProcessing`
+      - コードポイントチェック
+      - 対象の文字列を構成するコードポイントが、定義されたコードポイント集合に含まれることをチェックするクラスを提供する。
+    * - :doc:`../ArchitectureInDetail/Validation`
+      - コードポイントチェック用Bean Validation制約アノテーション
+      - コードポイントチェックをBean Validationで行うための制約アノテーションを提供する。
+
+
+terasoluna-gfw-validator
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+terasoluna-gfw-validatorは以下の部品を提供している。
+
+.. tabularcolumns:: |p{0.20\linewidth}|p{0.30\linewidth}|p{0.50\linewidth}|
+.. list-table::
+    :header-rows: 1
+    :widths: 20 30 50
+
+    * - 分類
+      - 部品名
+      - 説明
+    * - :doc:`../ArchitectureInDetail/Validation`
+      - バイト長チェック用Bean Validation制約アノテーション
+      - 入力文字列の文字コードにおけるバイト長が、指定した最大値以下であること、最小値以上であることのチェックをBean Validationで行うための制約アノテーションを提供する。
+    * -
+      - フィールド値比較相関チェック用Bean Validation制約アノテーション
+      - 2つのフィールド値の大小関係チェックをBean Validationで行うための制約アノテーションを提供する。
+
 terasoluna-gfw-jodatime
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
@@ -762,6 +837,23 @@ terasoluna-gfw-webは以下の部品を提供している。
     * -
       - MDCクリア用サーブレットフィルタ
       - ロガーのMDCに格納されている情報をクリアするためのサーブレットフィルタクラスを提供する。
+
+terasoluna-gfw-web-jsp
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+terasoluna-gfw-web-jspは以下の部品を提供している。
+
+.. tabularcolumns:: |p{0.20\linewidth}|p{0.30\linewidth}|p{0.50\linewidth}|
+.. list-table::
+    :header-rows: 1
+    :widths: 20 30 50
+
+    * - 分類
+      - 部品名
+      - 説明
+    * - :doc:`../ArchitectureInDetail/DoubleSubmitProtection`
+      - トランザクショントークン出力用のJSPタグ
+      - トランザクショントークンをhidden項目として出力するためのJSPタグライブラリを提供する。
     * - :doc:`../ArchitectureInDetail/Pagination`
       - ページネーションリンク表示用のJSPタグ
       - Spring Data Commons提供のクラスと連携してページネーションリンクを表示するためのJSPタグライブラリを提供する。
@@ -798,9 +890,6 @@ terasoluna-gfw-security-webは以下の部品を提供している。
       - 認証ユーザ名格納用サーブレットフィルタ
       - トレーサビリティを向上させるために、
         認証ユーザ名をロガーのMDCに設定するためのサーブレットフィルタクラスを提供する。
-    * - :doc:`../Security/Authentication`
-      - リダイレクト先の指定が可能な認証成功ハンドラ
-      - 認証が成功した際に、Webアプリケーション内の任意のパスにリダイレクトするためのハンドラクラスを提供する。
 
 
 .. raw:: latex
diff --git a/source/Overview/images_FrameworkStack/FrameworkStackProjectDependencies.png b/source/Overview/images_FrameworkStack/FrameworkStackProjectDependencies.png
index 06cce68e86..0acd3cf76e 100755
Binary files a/source/Overview/images_FrameworkStack/FrameworkStackProjectDependencies.png and b/source/Overview/images_FrameworkStack/FrameworkStackProjectDependencies.png differ
diff --git a/source/Overview/images_FrameworkStack/materialFrameworkStack.pptx b/source/Overview/images_FrameworkStack/materialFrameworkStack.pptx
index bec1b68858..53d95cd54c 100755
Binary files a/source/Overview/images_FrameworkStack/materialFrameworkStack.pptx and b/source/Overview/images_FrameworkStack/materialFrameworkStack.pptx differ
diff --git a/source/Security/SecureLoginDemo.rst b/source/Security/SecureLoginDemo.rst
index f2b29ee30d..b4a5bbc1b6 100755
--- a/source/Security/SecureLoginDemo.rst
+++ b/source/Security/SecureLoginDemo.rst
@@ -1,4 +1,4 @@
-【応用】セキュリティ対策の実装例
+代表的なセキュリティ要件の実装例
 ********************************************************************************
 
 .. only:: html
@@ -13,27 +13,28 @@
 この章で説明すること
 --------------------------------------------------------------------------------
 
-* TERASOLUNA Server Framework for Java (5.x)を利用した、セキュリティ対策の実装例
-* :ref:`app-description-sec` に示すサンプルアプリケーションを題材として、実装の方針とソースコードの説明を行う
+* TERASOLUNA Server Framework for Java (5.x)を利用して代表的なセキュリティ要件を満たすための実装方法の例
+* :ref:`app-description-sec` に示すサンプルアプリケーションを題材として、実装方法とソースコードの説明を行う
   
-対象読者
---------------------------------------------------------------------------------
-
-* 本ガイドラインの内容を一通り把握していること
-* 特に、Spring Securityチュートリアルを実施済みであること
-
 .. warning::
     * この章で説明している実装方法はあくまでも一例であり、実際の開発においては個別の要件を考慮して実装する必要がある
     * セキュリティ対策の網羅的な実施を保証するものではないため、必要に応じて追加の対策を検討すること
 
+対象読者
+--------------------------------------------------------------------------------
+
+* :doc:`../ImplementationAtEachLayer/index` の内容を理解していること
+* :doc:`./SpringSecurity`, :doc:`./Authentication`, :doc:`./Authorization` の内容を理解していること
+* :doc:`./Tutorial` を実施済みのこと
+
 .. _app-description-sec:
 
 アプリケーションの説明
 ================================================================================
 
-| 本章では、サンプルアプリケーションを題材として、セキュリティ対策の具体的な実装例について説明する。
+| 本章では、代表的なセキュリティ要件を満たすサンプルアプリケーションを題材として、セキュリティ対策の具体的な実装方法の例について説明する。
 | 以下に本章で実装例を解説するセキュリティ要件の一覧を示し、題材となるサンプルアプリケーションの機能、認証・認可に関する仕様を示す。
-| 以降、このサンプルアプリケーションを本アプリケーションと呼び、特に本章で解説する実装の例を指して本実装例と呼ぶ。
+| 以降、このサンプルアプリケーションを本アプリケーションと呼ぶ。
 
 .. _sec-requirements:
 
@@ -56,27 +57,28 @@
       - 初期パスワード使用時のパスワード変更の強制
       - 初期パスワードを使用して認証成功した際に、パスワードの変更を強制する
     * - | (2)
-      - :ref:`パスワード変更の強制・促進 <password-change>`
-      - 期限切れ管理ユーザパスワードの変更の強制
-      - 一定期間パスワードを変更していない管理ユーザに対して、次回認証成功時にパスワードの変更を強制する
+      - 
+      - 期限切れパスワードの変更の強制
+      - | 一定期間パスワードを変更していないユーザに対して、認証成功時にパスワードの変更を強制する
+        | 本アプリケーションでは、管理ユーザのみを対象とする
     * - | (3)
-      - :ref:`パスワード変更の強制・促進 <password-change>`
+      - 
       - パスワード変更を促すメッセージの表示
-      - 一定期間パスワードを変更していないユーザに対して、次回認証成功時にパスワードの変更を促すメッセージを表示する
+      - 一定期間パスワードを変更していないユーザに対して、認証成功時にパスワードの変更を促すメッセージを表示する
     * - | (4)
       - :ref:`パスワードの品質チェック <password-strength>`
       - パスワードの最小文字数指定
       - パスワードとして設定できる文字数の最小値を指定する
     * - | (5)
-      - :ref:`パスワードの品質チェック <password-strength>`
+      - 
       - パスワードの文字種別指定
       - パスワード中に含めなければならない文字種別（英大文字、英小文字、数字、記号）を指定する
     * - | (6)
-      - :ref:`パスワードの品質チェック <password-strength>`
+      - 
       - ユーザ名を含むパスワードの禁止
       - パスワード中にアカウントのユーザ名を含めることを禁止する
     * - | (7)
-      - :ref:`パスワードの品質チェック <password-strength>`
+      - 
       - 管理ユーザパスワードの再使用禁止
       - 管理ユーザが、以前使用したパスワードを短期間のうちに再使用することを禁止する
     * - | (8)
@@ -84,11 +86,11 @@
       - アカウントロックアウト
       - あるアカウントが短期間の間に一定回数以上認証に失敗した場合、そのアカウントを認証不能な状態（ロックアウト状態）にする
     * - | (9)
-      - :ref:`アカウントのロックアウト <account-lock>`
+      - 
       - アカウントロックアウト期間の指定
       - アカウントのロックアウト状態の継続時間を指定する
     * - | (10)
-      - :ref:`アカウントのロックアウト <account-lock>`
+      - 
       - 管理ユーザによるロックアウトの解除
       - 管理ユーザは任意のアカウントのロックアウト状態を解除できる
     * - | (11)
@@ -100,11 +102,11 @@
       - パスワード再発行用URLへのランダム文字列の付与
       - 不正なアクセスを防ぐため、パスワード再発行画面にアクセスするためのURLに十分に推測困難な文字列を付与する
     * - | (13)
-      - :ref:`パスワード再発行のための認証情報の生成 <reissue-info-create>`
+      - 
       - パスワード再発行用秘密情報の発行
-      - パスワード再発行時のユーザ確認に用いるために、事前に十分に推測困難な秘密情報（ランダム文字列）を生成してユーザに配布する
+      - パスワード再発行時のユーザ確認に用いるために、事前に十分に推測困難な秘密情報（ランダム文字列）を生成する
     * - | (14)
-      - :ref:`パスワード再発行のための認証情報の生成 <reissue-info-create>`
+      - 
       - パスワード再発行用の認証情報への有効期限の設定
       - パスワード再発行画面のURLと秘密情報に有効期限を設定する
     * - | (15)
@@ -112,18 +114,18 @@
       - パスワード再発行画面URLのメール送付
       - パスワード再発行ページにアクセスするためのURLは、アカウントの登録済みメールアドレスへ送付する
     * - | (16)
-      - :ref:`パスワード再発行のための認証情報の配布 <reissue-info-delivery>`
+      - 
       - パスワード再発行画面のURLと秘密情報の別配布
       - パスワード再発行画面のURLの漏えいに備え、秘密情報はメール以外の方法でユーザに配布する
     * - | (17)
       - :ref:`パスワード再発行の失敗上限回数の設定 <reissue-info-invalidate>`
       - パスワード再発行の失敗上限回数の設定
-      - パスワード再発行時のユーザ確認に一定回数失敗した場合、パスワード再発行画面のURLと秘密情報を使用不能にする
+      - パスワード再発行時の認証に一定回数失敗した場合、パスワード再発行画面のURLと秘密情報を使用不能にする
 
 機能
 --------------------------------------------------------------------------------
 
-本アプリケーションは、セキュリティチュートリアルで作成したアプリケーションに加え、以下の機能を持つ。
+本アプリケーションは、:doc:`./Tutorial` で作成したアプリケーションに加え、以下の機能を持つ。
 
 .. tabularcolumns:: |p{0.30\linewidth}|p{0.70\linewidth}|
 .. list-table::
@@ -134,13 +136,15 @@
       - 説明
     * - パスワード変更機能
       - ログイン済みのユーザが、自分のアカウントのパスワードを変更する機能
-    * - アカウントロックアウト機能・ロックアウト解除機能
-      - 短期間に一定回数以上認証に失敗したアカウントを認証不能な状態にする機能、および再び認証可能な状態に戻す機能
+    * - アカウントロックアウト機能
+      - 短期間に一定回数以上認証に失敗したアカウントを認証不能な状態にする機能
+    * - ロックアウト解除機能
+      - アカウントロックアウト機能により認証不能な状態になったアカウントを再び認証可能な状態に戻す機能
     * - パスワード再発行機能
       - ユーザがパスワードを忘れてしまった場合に、ユーザ確認を行った後、新しいパスワードを設定できる機能
 
 .. note::
-  このアプリケーションはセキュリティ対策に関するサンプルであるため、本来は当然必要となる
+  本アプリケーションはセキュリティ対策に関するサンプルであるため、本来は当然必要となる
   ユーザ登録の機能やパスワード以外の登録情報の更新機能を作成していない。
 
 認証・認可に関する仕様
@@ -151,12 +155,12 @@
 認証
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
-* ログイン画面とパスワード再発行に使用する画面以外の画面へのアクセスには、認証が必要
 * 認証に使用するための初期パスワードはアプリケーション側から払い出されるものとする
 
 認可
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
+* ログイン画面とパスワード再発行に使用する画面以外の画面へのアクセスには、認証が必要
 * 「一般ユーザ」と「管理ユーザ」の二種類のロールが存在する
     * 一つのアカウントが複数のロールを持つことができる
 * アカウントロックアウト解除機能は、管理ユーザの権限を持つアカウントのみが使用できる
@@ -164,7 +168,7 @@
 設計情報
 --------------------------------------------------------------------------------
 
-画面遷移とURL一覧
+画面遷移
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
 画面遷移図を以下に示す。エラー時の画面遷移は省略している。
@@ -181,28 +185,28 @@
 
     * - | 項番
       - | 画面名
-      - | 認証・認可
+      - | アクセスコントロール
     * - | (1)
       - | ログイン画面
       - | -
     * - | (2)
       - | トップ画面
-      - | 要認証
+      - | 認証済みユーザのみ
     * - | (3)
       - | アカウント情報表示画面
-      - | 要認証
+      - | 認証済みユーザのみ
     * - | (4)
       - | パスワード変更画面
-      - | 要認証
+      - | 認証済みユーザのみ
     * - | (5)
       - | パスワード変更完了画面
-      - | 要認証
+      - | 認証済みユーザのみ
     * - | (6)
       - | ロックアウト解除画面
-      - | 要認証、要管理ユーザ権限
+      - | 管理ユーザのみ
     * - | (7)
       - | ロックアウト解除完了画面
-      - | 要認証、要管理ユーザ権限
+      - | 管理ユーザのみ
     * - | (8)
       - | パスワード再発行のための認証情報生成画面
       - | -
@@ -216,6 +220,8 @@
       - | パスワード再発行完了画面
       - | -
 
+URL一覧
+""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 URL一覧を以下に示す。
 
 .. tabularcolumns:: |p{0.10\linewidth}|p{0.20\linewidth}|p{0.15\linewidth}|p{0.15\linewidth}|p{0.40\linewidth}|
@@ -230,7 +236,7 @@ URL一覧を以下に示す。
       - 説明
     * - 1
       - ログイン画面表示
-      - GET
+      - POST
       - /login
       - ログイン画面を表示する
     * - 2
@@ -301,7 +307,7 @@ URL一覧を以下に示す。
     * - 15
       - パスワード再発行画面表示
       - GET
-      - /reissue/resetpassword?form&username={username}&token={token}
+      - /reissue/resetpassword?form&token={token}
       - 二つのリクエストパラメータを使用して、ユーザ専用のパスワード再発行画面表示を表示する
     * - 16
       - パスワード再発行
@@ -310,14 +316,14 @@ URL一覧を以下に示す。
       - パスワード再発行画面に入力された情報を使用してパスワードを再発行する
     * - 17
       - パスワード再発行完了画面表示
-      - POST
+      - GET
       - /reissue/resetpassword?complete
       - パスワード再発行完了画面を表示する
 
 ER図
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
-本実装例におけるER図を以下に示す。
+本アプリケーションにおけるER図を以下に示す。
 
 .. figure:: ./images/SecureLogin_ER.png
    :alt: Entity-Relation Diagram
@@ -358,7 +364,7 @@ ER図
       - | username : ユーザ名
         | authenticationTimestamp : 認証失敗日時
     * - | (5)
-      - | パスワード変更イベント
+      - | パスワード変更履歴
       - | パスワードの有効期限の判定等に用いるために、パスワード変更時に残す情報
       - | username : ユーザ名
         | useFrom : 変更後のパスワードの使用開始日時
@@ -376,17 +382,24 @@ ER図
       - | token : パスワード再発行に失敗した際に使用したtoken
         | attemptDate : パスワード再発行を試行した日時
 
+.. tip ::
+
+   初期パスワードやパスワード有効期限切れの判定を行うために、アカウントエンティティにフィールドを追加してパスワードの最終変更日時等の情報を持たせるといった設計も可能である。
+   そのような方法で実装を行う場合、アカウントのテーブルに様々な状態を判定するためのカラムが追加され、エントリが頻繁に更新されるという状況に繋がりがちである。
+
+   本アプリケーションでは、テーブルをシンプルな状態に保ち、エントリの不要な更新を避けて単純に挿入と削除を使用することで要件を実現するために、認証成功イベントエンティティ等のイベントエンティティを用いた設計を採用している。
+
 .. _implement-description:
 
-実装方針とコード解説
+実装方法とコード解説
 ================================================================================
 
-| セキュリティ要件の分類ごとに、本実装例における実装の方針とコードの説明を行う。
+| セキュリティ要件の分類ごとに、本アプリケーションにおける実装の方法とコードの説明を行う。
 | ここでは各分類ごとに要件の実現のために必要最小限のコード片のみを掲載している。コード全体を確認したい場合は **TODO:ここにコードへのリンクを張る** を参照すること。
 
 .. note::
 
-   本実装例では、ボイラープレートコードの排除のために、Lombokを使用している。Lombokについては、:doc:`../Appendix/Lombok` を参照。
+   本アプリケーションでは、ボイラープレートコードの排除のために、Lombokを使用している。Lombokについては、:doc:`../Appendix/Lombok` を参照。
 
 .. _password-change:
 
@@ -408,36 +421,30 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-| 本実装例では、パスワードを変更した際の履歴を「パスワード変更イベント」エンティティとしてデータベースに保存し、このパスワード変更イベントエンティティを使用して、初期パスワードの判定およびパスワードの有効期限切れの判定を行う。
+| 本アプリケーションでは、パスワードを変更した際の履歴を「パスワード変更履歴」エンティティとしてデータベースに保存し、このパスワード変更履歴エンティティを使用して、初期パスワードの判定およびパスワードの有効期限切れの判定を行う。
 | また、その判定結果に基づいてパスワード変更画面へのリダイレクトや、画面へのメッセージの表示を制御する。
 | 具体的には以下の処理を実装して用いることで、要件を実現する。
 
-* パスワード変更イベントエンティティの保存
+* パスワード変更履歴エンティティの保存
 
-  パスワードを変更した際に、以下の情報を持ったパスワード変更イベントエンティティをデータベースに登録する。
+  パスワードを変更した際に、以下の情報を持ったパスワード変更履歴エンティティをデータベースに登録する。
 
   * パスワードを変更したアカウントのユーザ名
-  * 変更後のパスワード
   * 変更後のパスワードの使用開始日時
 
-  .. note ::
-
-     「パスワード変更の強制・促進」に関する要件の実現には、変更後のパスワードは使用しない。
-     しかしながら、:ref:`パスワードの品質チェック <password-strength>` の要件の実現に使用するため、パスワード変更イベントエンティティに含めて保存する。
-
 * 初期パスワード、パスワード有効期限切れの判定
 
-  | 認証後、認証されたアカウントのパスワード変更イベントエンティティをデータベースから検索し、一件も見つからなければ初期パスワードを使用していると判断する。
-  | そうでない場合には、最新のパスワード変更イベントエンティティを取得し、現在日時とパスワードの使用開始日時の差分を計算して、パスワードの有効期限が切れているかどうかの判定を行う。
+  | 認証後、認証されたアカウントのパスワード変更履歴エンティティをデータベースから検索し、一件も見つからなければ初期パスワードを使用していると判断する。
+  | そうでない場合には、最新のパスワード変更履歴エンティティを取得し、現在日時とパスワードの使用開始日時の差分を計算して、パスワードの有効期限が切れているかどうかの判定を行う。
 
 * パスワード変更画面への強制リダイレクト
 
   パスワードの変更を強制するために、以下のいずれかに該当する場合には、パスワード変更画面以外へのリクエストが要求された際に、パスワード変更画面へリダイレクトさせる。
 
-  * 認証済みのユーザが管理ユーザであり、かつパスワードの有効期限が切れている場合
   * 認証済みのユーザが初回パスワードを使用している場合
+  * 認証済みのユーザが管理ユーザであり、かつパスワードの有効期限が切れている場合
 
   \ ``org.springframework.web.servlet.handler.HandlerInterceptor`` \ を利用して、Controllerのハンドラメソッド実行前に上記の条件に該当するかどうかの判定を行う。
 
@@ -446,30 +453,26 @@ ER図
      認証後にパスワード変更画面へリダイレクトさせる方法は他にもあるが、方法によってはリダイレクト後にURLを直打ちすることでパスワード変更を避けて別画面にアクセスできてしまう可能性がある。
      \ ``HandlerInterceptor`` \を使用する方法ではハンドラメソッド実行前に処理を行うため、URLを直打ちするなどの方法で回避することはできない。
 
+  .. tip ::
+     \ ``HandlerInterceptor`` \の代わりにServlet Filterを用いることもできる。両者の説明については :doc:`../ImplementationAtEachLayer/ApplicationLayer` の「Controllerの呼び出し前後で行う共通処理の実装」を参照すること。
+     ここでは、アプリケーションが許可したリクエストのみに対して処理を行うために、\ ``HandlerInterceptor`` \を用いている。
+
 * パスワード変更を促すメッセージの表示
 
   Controllerの中で前述のパスワード有効期限切れ判定処理を呼び出す。判定結果をViewに渡し、Viewでメッセージの表示・非表示を切り替える。
 
-
-.. tip ::
-
-   初期パスワードやパスワード有効期限切れの判定を行う方法としては、アカウントのテーブルにカラムを追加してパスワードの最終変更日時等の情報を持たせるといった方法を採ることも可能である。
-   そのような方法で実装を行う場合、アカウントのテーブルに様々な状態を判定するためのカラムが追加され、エントリが頻繁に更新されるという状況に繋がりがちである。
-
-   本実装例では、テーブルをシンプルな状態に保ち、エントリの不要な更新を避けて単純に挿入と削除を使用することで要件を実現するために、イベントエンティティを用いる実装方針を採用している。
-
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
-上記の実装方針に従って実装されたコードについて順に解説する。
+上記の実装方法に従って実装されたコードについて順に解説する。
 
-* パスワード変更イベントエンティティの保存
+* パスワード変更履歴エンティティの保存
 
-  パスワード変更時にパスワード変更イベントエンティティをデータベースに登録するための一連の実装を示す。
+  パスワード変更時にパスワード変更履歴エンティティをデータベースに登録するための一連の実装を示す。
 
   * Entityの実装
 
-    パスワード変更イベントエンティティの実装は以下の通り。
+    パスワード変更履歴エンティティの実装は以下の通り。
 
     .. code-block:: java
 
@@ -504,7 +507,7 @@ ER図
 
   * Repositoryの実装
 
-    データベースに対するパスワード変更イベントエンティティの登録、検索を行うためのRepositoryを以下に示す。
+    データベースに対するパスワード変更履歴エンティティの登録、検索を行うためのRepositoryを以下に示す。
 
     .. code-block:: java
 
@@ -514,12 +517,12 @@ ER図
 
        public interface PasswordHistoryRepository {
 
-           int insert(PasswordHistory history); // (1)
+           int create(PasswordHistory history); // (1)
 
            List<PasswordHistory> findByUseFrom(@Param("username") String username,  
                    @Param("useFrom") LocalDateTime useFrom); // (2)
 
-           List<PasswordHistory> findLatestHistories(
+           List<PasswordHistory> findLatest(
                    @Param("username") String username, @Param("limit") int limit); // (3)
 
        }
@@ -534,7 +537,7 @@ ER図
        * - | (1)
          - | 引数として与えられた\ ``PasswordHistory`` \ オブジェクトをデータベースのレコードとして登録するメソッド
        * - | (2)
-         - | 引数として与えられたユーザ名をキーとして、パスワードの使用開始日時が指定された日付よりも新しい\ ``PasswordHistory`` \ オブジェクトを取得するメソッド
+         - | 引数として与えられたユーザ名をキーとして、パスワードの使用開始日時が指定された日付よりも新しい\ ``PasswordHistory`` \ オブジェクトを降順(新しい順)に取得するメソッド
        * - | (3)
          - | 引数として与えられたユーザ名をキーとして、指定された個数の\ ``PasswordHistory`` \ オブジェクトを新しい順に取得するメソッド
 
@@ -570,7 +573,7 @@ ER図
            ]]>
            </select>
 
-           <select id="findLatestHistories" resultMap="PasswordHistoryResultMap">
+           <select id="findLatest" resultMap="PasswordHistoryResultMap">
            <![CDATA[
                SELECT
                    username,
@@ -585,7 +588,7 @@ ER図
            ]]>
            </select>
 
-           <insert id="insert" parameterType="PasswordHistory">
+           <insert id="create" parameterType="PasswordHistory">
            <![CDATA[
                INSERT INTO password_history (
                    username,
@@ -603,7 +606,7 @@ ER図
 
   * Serviceの実装
 
-    パスワード変更イベントエンティティの操作は :ref:`パスワードの品質チェック <password-strength>` においても使用する。
+    パスワード変更履歴エンティティの操作は :ref:`パスワードの品質チェック <password-strength>` においても使用する。
     そのため、以下のようにSharedServiceからRepositoryのメソッドを呼び出す。
 
     .. code-block:: java
@@ -621,7 +624,7 @@ ER図
            PasswordHistoryRepository passwordHistoryRepository;
 
            public int insert(PasswordHistory history) {
-               return passwordHistoryRepository.insert(history);
+               return passwordHistoryRepository.create(history);
            }
 
            @Transactional(readOnly = true)
@@ -632,13 +635,13 @@ ER図
 
            @Override
            @Transactional(readOnly = true)
-           public List<PasswordHistory> findLatestHistories(String username, int limit) {
-               return passwordHistoryRepository.findLatestHistories(username, limit);
+           public List<PasswordHistory> findLatest(String username, int limit) {
+               return passwordHistoryRepository.findLatest(username, limit);
            }
 
        }
 
-    パスワード変更時にパスワード変更イベントエンティティをデータベースに保存する処理の実装を以下に示す。
+    パスワード変更時にパスワード変更履歴エンティティをデータベースに保存する処理の実装を以下に示す。
 
     .. code-block:: java
 
@@ -650,6 +653,9 @@ ER図
        @Transactional
        public class AccountSharedServiceImpl implements AccountSharedService {
 
+           @Inject
+           ClassicDateFactory dateFactory;
+
            @Inject
            PasswordHistorySharedService passwordHistorySharedService;
 
@@ -665,7 +671,7 @@ ER図
                String password = passwordEncoder.encode(rawPassword);
                boolean result = accountRepository.updatePassword(username, password); // (2)
 
-               LocalDateTime passwordChangeDate = LocalDateTime.now();
+               LocalDateTime passwordChangeDate = dateFactory.newTimestamp().toLocalDateTime();
 
                PasswordHistory passwordHistory = new PasswordHistory(); // (3)
                passwordHistory.setUsername(username);
@@ -691,14 +697,14 @@ ER図
        * - | (2)
          - | データベース上のパスワードを更新する処理を呼び出す。
        * - | (3)
-         - | パスワード変更イベントエンティティを作成し、ユーザ名、変更後のパスワード、変更後のパスワードの使用開始日時を設定する。
+         - | パスワード変更履歴エンティティを作成し、ユーザ名、変更後のパスワード、変更後のパスワードの使用開始日時を設定する。
        * - | (4)
-         - | 作成したパスワード変更イベントエンティティをデータベースに登録する処理を呼び出す。
+         - | 作成したパスワード変更履歴エンティティをデータベースに登録する処理を呼び出す。
 
 
 * 初期パスワード、パスワード有効期限切れの判定
 
-  データベースに登録されたパスワード変更イベントエンティティを用いて、初期パスワードを使用しているかどうかの判定と、パスワードの有効期限が切れているかどうかを判定する処理の実装を以下に示す。
+  データベースに登録されたパスワード変更履歴エンティティを用いて、初期パスワードを使用しているかどうかの判定と、パスワードの有効期限が切れているかどうかを判定する処理の実装を以下に示す。
 
   .. code-block:: java
 
@@ -710,11 +716,14 @@ ER図
      @Transactional
      public class AccountSharedServiceImpl implements AccountSharedService {
 
+         @Inject
+         ClassicDateFactory dateFactory;
+
          @Inject
          PasswordHistorySharedService passwordHistorySharedService;
 
-         @Value("${security.passwordLifeTime}") // (1)
-         int passwordLifeTime;
+         @Value("${security.passwordLifeTimeSeconds}") // (1)
+         int passwordLifeTimeSeconds;
 
          // omitted
 
@@ -723,7 +732,7 @@ ER図
         @Cacheable("isInitialPassword")
         public boolean isInitialPassword(String username) { // (2)
             List<PasswordHistory> passwordHistories = passwordHistorySharedService
-                    .findLatestHistories(username, 1); // (3)
+                    .findLatest(username, 1); // (3)
             return passwordHistories.isEmpty(); // (4)
         }
 
@@ -732,7 +741,7 @@ ER図
         @Cacheable("isCurrentPasswordExpired")
         public boolean isCurrentPasswordExpired(String username) { // (5)
             List<PasswordHistory> passwordHistories = passwordHistorySharedService
-                    .findLatestHistories(username, 1); // (6)
+                    .findLatest(username, 1); // (6)
 
             if (passwordHistories.isEmpty()) { // (7)
                 return true;
@@ -742,8 +751,8 @@ ER図
                     .get(0)
                     .getUseFrom()
                     .isBefore(
-                            LocalDateTime.now()
-                                    .minusSeconds(passwordLifeTime))) { // (8)
+                            dateFactory.newTimestamp().toLocalDateTime()
+                                    .minusSeconds(passwordLifeTimeSeconds))) { // (8)
                 return true;
             }
 
@@ -764,20 +773,34 @@ ER図
      * - | (2)
        - | 初期パスワードを使用しているかどうかを判定し、使用している場合はtrue、そうでなければfalseを返すメソッド
      * - | (3)
-       - | データベースから最新のパスワード変更イベントエンティティを一件取得する処理を呼び出す。
+       - | データベースから最新のパスワード変更履歴エンティティを一件取得する処理を呼び出す。
      * - | (4)
-       - | データベースからパスワード変更イベントエンティティが取得できなかった場合に、初期パスワードを使用していると判定し、trueを返す。そうでなければfalseを返す。
+       - | データベースからパスワード変更履歴エンティティが取得できなかった場合に、初期パスワードを使用していると判定し、trueを返す。そうでなければfalseを返す。
      * - | (5)
        - | 現在使用中のパスワードの有効期限が切れているかどうかを判定し、切れている場合はtrue、そうでなければfalseを返すメソッド
      * - | (6)
-       - | データベースから最新のパスワード変更イベントエンティティを一件取得する処理を呼び出す。
+       - | データベースから最新のパスワード変更履歴エンティティを一件取得する処理を呼び出す。
      * - | (7)
-       - | データベースからパスワード変更イベントエンティティが取得できなかった場合には、パスワードの有効期限が切れていると判定し、trueを返す。
+       - | データベースからパスワード変更履歴エンティティが取得できなかった場合には、パスワードの有効期限が切れていると判定し、trueを返す。
      * - | (8)
-       - | パスワード変更イベントエンティティから取得したパスワードの使用開始日時と現在日時の差分が、(1)で設定したパスワード有効期間よりも大きい場合、パスワードの有効期限が切れていると判定し、trueを返す。
+       - | パスワード変更履歴エンティティから取得したパスワードの使用開始日時と現在日時の差分が、(1)で設定したパスワード有効期間よりも大きい場合、パスワードの有効期限が切れていると判定し、trueを返す。
      * - | (9)
        - | (7), (8)のいずれの条件にも該当しない場合、パスワード有効期限内であると判定し、falseを返す。
 
+  .. tip::
+
+     isInitialPassword および isCurrentPasswordExpired に付与されている @Cacheable は Spring の Cache Abstraction 機能を使用するためのアノテーションである。
+     @Cacheable アノテーションを付与することで、メソッドの引数に対する結果をキャッシュすることができる。
+     ここでは、キャッシュの使用により初期パスワード判定、パスワード期限切れ判定のたびにデータベースへのアクセスが発生することを防止し、パフォーマンスの低下を防いでいる。
+     Cache Abstraction については `公式ドキュメント <http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html>`_ を参照すること。
+
+  .. tip::
+
+     キャッシュを使用する際には、パスワード変更時等の必要なタイミングでキャッシュをクリアする必要があることに注意すること。
+
+     また、必要に応じてキャッシュのTTL(生存時間)を設定すること。TTLは使用するキャッシュの実装によっては設定不能であることに注意。
+
+
 * パスワード変更画面への強制リダイレクト
 
   パスワードの変更を強制するために、パスワード変更画面へリダイレクトさせる処理の実装を以下に示す。
@@ -804,7 +827,7 @@ ER図
                  Object principal = authentication.getPrincipal();
                  if (principal instanceof UserDetails) { // (3)
                      LoggedInUser userDetails = (LoggedInUser) principal; // (4)
-                     if ((userDetails.getAccount().getRoles().contains(Role.ADMN) && accountSharedService
+                     if ((userDetails.getAccount().getRoles().contains(Role.ADMIN) && accountSharedService
                              .isCurrentPasswordExpired(userDetails.getUsername())) // (5)
                              || accountSharedService.isInitialPassword(userDetails
                                      .getUsername())) { // (6)
@@ -833,7 +856,7 @@ ER図
      * - | (3)
        - | 取得したユーザ情報が\ ``org.springframework.security.core.userdetails.UserDetails`` \のオブジェクトであるかどうかを確認する。
      * - | (4)
-       - | \ ``UserDetails`` \のオブジェクトを取得する。本実装例では、\ ``UserDetails`` \の実装として\ ``LoggedInUser`` \というクラスを作成して用いている。
+       - | \ ``UserDetails`` \のオブジェクトを取得する。本アプリケーションでは、\ ``UserDetails`` \の実装として\ ``LoggedInUser`` \というクラスを作成して用いている。
      * - | (5)
        - | \ ``UserDetails`` \オブジェクトからロールを取得してユーザが管理ユーザであるかどうかを判定する。その後、パスワード有効期限が切れているかどうかを判定する処理を呼び出す。二つの判定結果の論理積(And)をとる。
      * - | (6)
@@ -858,10 +881,11 @@ ER図
         <mvc:interceptor>
             <mvc:mapping path="/**" /> <!-- (1) -->
             <mvc:exclude-mapping path="/password/**" /> <!-- (2) -->
+            <mvc:exclude-mapping path="/reissue/**" /> <!-- (3) -->
             <mvc:exclude-mapping path="/resources/**" />
             <mvc:exclude-mapping path="/**/*.html" />
             <bean
-                class="org.terasoluna.securelogin.app.common.interceptor.PasswordExpirationCheckInterceptor" /> <!-- (3) -->
+                class="org.terasoluna.securelogin.app.common.interceptor.PasswordExpirationCheckInterceptor" /> <!-- (4) -->
         </mvc:interceptor>
 
         <!-- omitted -->
@@ -882,19 +906,10 @@ ER図
      * - | (2)
        - | パスワード変更画面からパスワード変更画面へのリダイレクトを防ぐため、 "/password" 以下のパスは適用対象外とする。
      * - | (3)
+       - | パスワード再発行時にはパスワード有効期限のチェックを行う必要はないため、 "/reissue" 以下のパスは適用対象外とする。
+     * - | (4)
        - | \ ``HandlerInterceptor`` \のクラスを指定する。
 
-  .. tip::
-
-     ここまで解説した通りの実装を行った場合、リクエスト毎にデータベースへのアクセスが発生し、初期パスワード判定とパスワード有効期限切れ判定が行われる。その結果、パフォーマンスの低下が問題となる可能性がある。
-
-     これを防ぐためには、`Springのキャッシュ機能 <http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html>`_ 等を使用して、初期パスワード判定とパスワード有効期限切れ判定の結果をキャッシュするといった対策が有効である。
-
-     キャッシュを使用する際には、パスワード変更時等のタイミングでキャッシュをクリアする必要があることに注意すること。
-
-     また、必要に応じてキャッシュのTTL(生存時間)を設定すること。TTLは使用するキャッシュの実装によっては設定不能であることに注意。
-     
-
 * パスワード変更を促すメッセージの表示
 
   トップ画面にパスワード変更を促すメッセージを表示するための、Controllerの実装を以下に示す。
@@ -997,10 +1012,12 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-| パスワード変更時等にユーザが指定したパスワードの品質を検査するためには、 :doc:`../ArchitectureInDetail/Validation` の機能を利用することができる。本実装例ではBean Validationを用いてパスワードの品質を検査する。
-| パスワードの品質として求められる要件はアプリケーションによって異なり、多岐に渡るため、パスワード入力チェック用のライブラリとして `Passay <http://www.passay.org/>`_ を利用し、必要なBean Validationのアノテーションを作成する。
+| パスワード変更時等にユーザが指定したパスワードの品質を検査するためには、 :doc:`../ArchitectureInDetail/Validation` の機能を利用することができる。本アプリケーションではBean Validationを用いてパスワードの品質を検査する。
+| パスワードの品質として求められる要件はアプリケーションによって異なり、多岐に渡る。
+| そこで、パスワード入力チェック用のライブラリとして `Passay <http://www.passay.org/>`_ を利用し、必要なBean Validationのアノテーションを作成する。
+| Passayではパスワード入力チェックで一般的に使用される機能の多くを提供しており、提供されていない機能についても標準機能を拡張することで容易に実装することができる。
 | Passayの概要については :ref:`Appendix <passay_overview>` を参照。
 | 具体的には以下の設定、処理を記述し、使用することで要件を実現する。
 
@@ -1011,7 +1028,7 @@ ER図
     * パスワード長の最小値を設定した検証規則
     * パスワードに含めなければならない文字種別を設定した検証規則
     * パスワードがユーザ名を含まないことをチェックするための検証規則
-    * パスワードが過去に使用したパスワードと一致していないことをチェックするための検証規則
+    * 同一のパスワードを過去に使用していないことをチェックするための検証規則
 
 * Passayの検証器の作成
 
@@ -1019,7 +1036,18 @@ ER図
 
 * Bean Validationのアノテーションの作成
 
-  Passayの検証器を使用してパスワードの入力チェックを行うためのアノテーションを作成する。過去に使用したパスワードを取得するためには、 :ref:`パスワード変更の強制・促進 <password-change>` で説明したパスワード変更イベントエンティティを用いる。
+  Passayの検証器を使用してパスワードの入力チェックを行うためのアノテーションを作成する。
+  一つのアノテーションですべての検証規則を検査することもできるが、多種の規則の検査を行うことで処理が複雑になり視認性が下がることを避けるため、以下の二つに分けて実装する。
+
+    * パスワード自体の性質を検証するアノテーション
+
+      「パスワードが最小文字列長よりも長いこと」、「指定した文字種別の文字を含むこと」、「ユーザ名を含まないこと」の三つの検証規則をチェックする
+    * 過去のパスワードとの比較を行うアノテーション
+
+      管理ユーザが、以前使用したパスワードを短期間のうちに再使用していないことをチェックする
+
+  いずれのアノテーションも、ユーザ名と新しいパスワードを用いる相関入力チェックルールとなる。
+  両方のルールに違反した入力を行った場合、それぞれのエラーメッセージが表示される。
 
 * パスワードの入力チェック
 
@@ -1028,11 +1056,11 @@ ER図
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
-上記の実装方針に従って実装されたコードについて順に解説する。Passayを用いたパスワード入力チェックについては :ref:`password_validation` にて説明する。
+上記の実装方法に従って実装されたコードについて順に解説する。Passayを用いたパスワード入力チェックについては :ref:`password_validation` にて説明する。
 
 * Passayの検証規則の作成
 
-  | 本実装例で使用するほとんどの検証規則は、Passayにデフォルトで用意されたクラスを利用することで定義できる。
+  | 本アプリケーションで使用するほとんどの検証規則は、Passayにデフォルトで用意されたクラスを利用することで定義できる。
   | しかしながら、Passayが提供するクラスでは、\ ``org.springframework.security.crypto.password.PasswordEncoder`` \でハッシュ化された過去のパスワードと比較する検証規則を定義することができない。
   | そのため、Passayが提供するクラスを拡張し、独自の検証規則のクラスを以下のように作成する必要がある。
 
@@ -1108,7 +1136,7 @@ ER図
      </bean>
      <bean id="characterCharacteristicsRule" class="org.passay.CharacterCharacteristicsRule"> <!-- (6) -->
          <property name="rules">
-             <list value-type="org.passay.CharacterRule">
+             <list>
                  <ref bean="upperCaseRule" />
                  <ref bean="lowerCaseRule" />
                  <ref bean="digitRule" />
@@ -1157,7 +1185,7 @@ ER図
 
      <bean id="characteristicPasswordValidator" class="org.passay.PasswordValidator"> <!-- (1) -->
          <constructor-arg name="rules">
-             <list value-type="org.passay.Rule">
+             <list>
                  <ref bean="lengthRule" />
                  <ref bean="characterCharacteristicsRule" />
                  <ref bean="usernameRule" />
@@ -1166,7 +1194,7 @@ ER図
      </bean>
      <bean id="encodedPasswordHistoryValidator" class="org.passay.PasswordValidator"> <!-- (2) -->
          <constructor-arg name="rules">
-             <list value-type="org.passay.Rule">
+             <list>
                  <ref bean="encodedPasswordHistoryRule" />
              </list>
          </constructor-arg>
@@ -1207,7 +1235,7 @@ ER図
 
            Class<?>[] groups() default {};
 
-           String idPropertyName(); // (2)
+           String usernamePropertyName(); // (2)
 
            String newPasswordPropertyName(); // (3)
 
@@ -1244,7 +1272,8 @@ ER図
        public class StrongPasswordValidator implements
                ConstraintValidator<StrongPassword, Object> {
 
-           @Resource(name = "characteristicPasswordValidator") // (1)
+           @Inject
+           @Named("characteristicPasswordValidator") // (1)
            PasswordValidator characteristicPasswordValidator;
 
            private String usernamePropertyName;
@@ -1253,7 +1282,7 @@ ER図
 
            @Override
            public void initialize(StrongPassword constraintAnnotation) {
-               usernamePropertyName = constraintAnnotation.idPropertyName();
+               usernamePropertyName = constraintAnnotation.usernamePropertyName();
                newPasswordPropertyName = constraintAnnotation.newPasswordPropertyName();
            }
 
@@ -1264,10 +1293,11 @@ ER図
                String newPassword = (String) beanWrapper
                        .getPropertyValue(newPasswordPropertyName);
 
-               context.disableDefaultConstraintViolation();
-
                RuleResult result = characteristicPasswordValidator
                        .validate(PasswordData.newInstance(newPassword, username, null)); // (2)
+
+               context.disableDefaultConstraintViolation();
+
                if (result.isValid()) { // (3)
                    return true;
                } else {
@@ -1301,22 +1331,27 @@ ER図
   * 過去のパスワードとの比較を行うアノテーション
 
     | 管理ユーザが、以前使用したパスワードを短期間のうちに再使用していないことをチェックするアノテーションの実装を以下に示す。
-    | 過去に使用したパスワードを取得するために、パスワード変更イベントエンティティを用いる。パスワード変更イベントエンティティについては :ref:`パスワード変更の強制・促進 <password-change>` を参照。
+    | 過去に使用したパスワードを取得するために、パスワード変更履歴エンティティを用いる。パスワード変更履歴エンティティについては :ref:`パスワード変更の強制・促進 <password-change>` を参照。
+
+    .. note ::
+
+       「いくつ前までのパスワードの再使用を禁止するか」のみの設定では、短時間の間にパスワード変更を繰り返すことでパスワードを再使用することが可能となってしまう。
+       これを防ぐために、本アプリケーションでは「いつ以降使用したパスワードの再使用を禁止するか」を設定して検査を行う。
 
     .. code-block:: java
 
        package org.terasoluna.securelogin.app.common.validation;
 
        @Documented
-       @Constraint(validatedBy = { NotReusedValidator.class }) // (1)
+       @Constraint(validatedBy = { NotReusedPasswordValidator.class }) // (1)
        @Target({ TYPE, ANNOTATION_TYPE })
        @Retention(RUNTIME)
-       public @interface NotReused {
-           String message() default "{org.terasoluna.securelogin.app.common.validation.NotReused.message}";
+       public @interface NotReusedPassword {
+           String message() default "{org.terasoluna.securelogin.app.common.validation.NotReusedPassword.message}";
 
            Class<?>[] groups() default {};
 
-           String idPropertyName(); // (2)
+           String usernamePropertyName(); // (2)
 
            String newPasswordPropertyName(); // (3)
 
@@ -1324,7 +1359,7 @@ ER図
            @Retention(RUNTIME)
            @Documented
            public @interface List {
-               NotReused[] value();
+               NotReusedPassword[] value();
            }
 
            Class<? extends Payload>[] payload() default {};
@@ -1350,8 +1385,11 @@ ER図
 
        // omitted
 
-       public class NotReusedValidator implements
-               ConstraintValidator<NotReused, Object> {
+       public class NotReusedPasswordValidator implements
+               ConstraintValidator<NotReusedPassword, Object> {
+
+           @Inject
+           ClassicDateFactory dateFactory;
 
            @Inject
            AccountSharedService accountSharedService;
@@ -1362,7 +1400,8 @@ ER図
            @Inject
            PasswordEncoder passwordEncoder;
 
-           @Resource(name = "encodedPasswordHistoryValidator") // (1)
+           @Inject
+           @Named("encodedPasswordHistoryValidator") // (1)
            PasswordValidator encodedPasswordHistoryValidator;
 
            @Value("${security.passwordHistoricalCheckingCount}") // (2)
@@ -1378,8 +1417,8 @@ ER図
            private String message;
 
            @Override
-           public void initialize(NotReused constraintAnnotation) {
-               usernamePropertyName = constraintAnnotation.idPropertyName();
+           public void initialize(NotReusedPassword constraintAnnotation) {
+               usernamePropertyName = constraintAnnotation.usernamePropertyName();
                newPasswordPropertyName = constraintAnnotation.newPasswordPropertyName();
                message = constraintAnnotation.message();
            }
@@ -1394,13 +1433,14 @@ ER図
                Account account = accountSharedService.findOne(username);
                String currentPassword = account.getPassword();
 
-               context.disableDefaultConstraintViolation();
                boolean result = checkNewPasswordDifferentFromCurrentPassword(
                        newPassword, currentPassword, context); // (4)
-               if (result && account.getRoles().contains(Role.ADMN)) { // (5)
+               if (result && account.getRoles().contains(Role.ADMIN)) { // (5)
                    result = checkHistoricalPassword(username, newPassword, context);
                }
 
+               context.disableDefaultConstraintViolation();
+
                return result;
            }
 
@@ -1418,12 +1458,12 @@ ER図
 
            private boolean checkHistoricalPassword(String username,
                    String newPassword, ConstraintValidatorContext context) {
-               LocalDateTime useFrom = LocalDateTime.now().minusMinutes(
-                       passwordHistoricalCheckingPeriod);
+               LocalDateTime useFrom = dateFactory.newTimestamp().toLocalDateTime()
+                       .minusMinutes(passwordHistoricalCheckingPeriod);
                List<PasswordHistory> historyByTime = passwordHistorySharedService
                        .findHistoriesByUseFrom(username, useFrom);
                List<PasswordHistory> historyByCount = passwordHistorySharedService
-                       .findLatestHistories(username, passwordHistoricalCheckingCount);
+                       .findLatest(username, passwordHistoricalCheckingCount);
                List<PasswordHistory> history = historyByCount.size() > historyByTime
                        .size() ? historyByCount : historyByTime; // (6)
 
@@ -1467,9 +1507,9 @@ ER図
        * - | (5)
          - | 管理ユーザの場合は、新しいパスワードが過去に使用したパスワードに含まれていないかをチェックする処理を呼び出す。
        * - | (6)
-         - | (2)で指定した個数分のパスワード変更イベントエンティティと、(3)で指定した期間分のパスワード変更イベントエンティティを取得し、どちらか数の多い方を以降のチェックに用いる。
+         - | (2)で指定した個数分のパスワード変更履歴エンティティと、(3)で指定した期間分のパスワード変更履歴エンティティを取得し、どちらか数の多い方を以降のチェックに用いる。
        * - | (7)
-         - | Passayの検証器で過去のパスワードとの比較を行うために、パスワード変更イベントエンティティからパスワードを取得し、\ ``org.passay.PasswordData.HistoricalReference`` \のリストを作成する。
+         - | Passayの検証器で過去のパスワードとの比較を行うために、パスワード変更履歴エンティティからパスワードを取得し、\ ``org.passay.PasswordData.HistoricalReference`` \のリストを作成する。
        * - | (8)
          - | パスワード、ユーザ名、過去のパスワードのリストを指定した\ ``org.passay.PasswordData`` \のインスタンスを作成する。
        * - | (9)
@@ -1479,10 +1519,6 @@ ER図
        * - | (11)
          - | パスワード入力チェックエラーメッセージを取得する。
 
-    .. note ::
-
-       「いくつ前までのパスワードの再使用を禁止するか」のみの設定では、短時間の間にパスワード変更を繰り返すことでパスワードを再使用することが可能となってしまう。
-       これを防ぐために、本実装例では「いつ以降使用したパスワードの再使用を禁止するか」を設定して検査を行っている。
 
 * パスワードの入力チェック
 
@@ -1498,11 +1534,13 @@ ER図
 
      @Data
      @Compare(source = "newPasssword", destination = "confirmNewPassword", operator = Compare.Operator.EQUAL) // (1)
-     @StrongPassword(idPropertyName = "username", newPasswordPropertyName = "newPassword") // (2)
-     @NotReused(idPropertyName = "username", newPasswordPropertyName = "newPassword") // (3)
-     @ConfirmOldPassword(idPropertyName = "username", oldPasswordPropertyName = "oldPassword") // (4)
-     public class PasswordChangeForm {
+     @StrongPassword(usernamePropertyName = "username", newPasswordPropertyName = "newPassword") // (2)
+     @NotReusedPassword(usernamePropertyName = "username", newPasswordPropertyName = "newPassword") // (3)
+     @ConfirmOldPassword(usernamePropertyName = "username", oldPasswordPropertyName = "oldPassword") // (4)
+     public class PasswordChangeForm implements Serializable{
 
+         private static final long serialVersionUID = 1L;
+         
          private String username;
 
          private String oldPassword;
@@ -1521,7 +1559,7 @@ ER図
      * - 項番
        - 説明
      * - | (1)
-       - | 新しいパスワードの二回の入力が一致しているかをチェックするためのアノテーション。
+       - | 新しいパスワードの二回の入力が一致しているかをチェックするためのアノテーション。詳細は :ref:`Validation_terasoluna_gfw_list` を参照すること。
      * - | (2)
        - | 上述した、パスワード自体の性質を検証するアノテーション
      * - | (3)
@@ -1549,16 +1587,20 @@ ER図
                  @Validated PasswordChangeForm form, BindingResult bindingResult, // (1)
                  Model model) {
 
+             Account account = userDetails.getAccount();
              if (bindingResult.hasErrors()) {
-                 Account account = userDetails.getAccount();
                  model.addAttribute(account);
                  return "passwordchange/changeForm";
              }
 
-             passwordService.updatePassword(form.getUsername(),
-                     form.getNewPassword());
+             if (account.getUsername().equals(form.getUsername())) { // (2)
+                 passwordService.updatePassword(form.getUsername(),
+                         form.getNewPassword());
 
-             return "redirect:/password?complete";
+                 return "redirect:/password?complete";
+             } else {
+                 return "passwordchange/changeForm";
+             }
          }
 
          // omitted
@@ -1574,6 +1616,13 @@ ER図
        - 説明
      * - | (1)
        - | パスワード変更時に呼び出されるハンドラメソッド。パラメータ中のFormに\ ``@Validated`` \ アノテーションを付与して、入力チェックを行う。
+     * - | (2)
+       - | パスワード変更対象のユーザ名がログイン中のアカウントのユーザ名と一致していることを確認する。
+
+  .. note::
+
+     本アプリケーションではBean Valiidationでユーザ名を用いたパスワード入力チェックを行うために、ユーザ名をFormから取得している。
+     Viewでは\ ``Model`` \に設定したユーザ名をhiddenで保持することを想定しているが、改ざんされる恐れがあるため、パスワード変更前にFormから取得したユーザ名の確認を行っている。
 
 .. _account-lock:
 
@@ -1595,6 +1644,10 @@ ER図
    :width: 80%
    :align: center
 
+| ログインフォームにて、あるユーザ名に対して短時間に一定回数連続して誤ったパスワードで認証を試行すると、そのユーザのアカウントはロックアウト状態となる。
+  ロックアウト状態のアカウントは、正しいユーザ名とパスワードの組を入力した場合であっても認証されない。
+| ロックアウト状態は一定期間経過するか、ロックアウト解除を行うことで解消される。
+
 * ロックアウト解除
 
 .. figure:: ./images/SecureLogin_unlock_ss.png
@@ -1602,33 +1655,37 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+管理権限を持つユーザでログインした場合にのみ、ロックアウト解除機能を使用することができる。
+ロックアウト状態を解消したいユーザ名を入力してロックアウト解除を実行すると、そのユーザのアカウントは再び認証可能な状態に戻る。
+
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 | Spring Securityでは、\ ``org.springframework.security.core.userdetails.UserDetails`` \に対してアカウントのロックアウト状態を設定することができる。
 | 「ロックアウト状態である」と設定した場合、Spring Securityがその設定を読み取って\ ``org.springframework.security.authentication.LockedException`` \をthrowする。
 | この機能を用いることにより、アカウントがロックアウト状態であるか否かを判定して\ ``UserDetails`` \に設定する処理のみを実装すれば、ロックアウト機能が実現できる。
 
-| 本実装例では、認証に失敗した履歴を「認証失敗イベント」エンティティとしてデータベースに保存し、この認証失敗イベントエンティティを使用してアカウントのロックアウト状態の判定を行う。
+| 本アプリケーションでは、認証に失敗した履歴を「認証失敗イベント」エンティティとしてデータベースに保存し、この認証失敗イベントエンティティを使用してアカウントのロックアウト状態の判定を行う。
 | 具体的には以下の三つの処理を実装して用いることにより、アカウントのロックアウトに関する各要件を実現する。
 
 * 認証失敗イベントエンティティの保存
 
-  不正な認証情報の入力によって認証に失敗した際に、Springが発生させるイベントをハンドリングし、認証に使用したユーザ名と認証を試みた日時を認証失敗イベントエンティティとしてデータベースに登録する。
+  不正な認証情報の入力によって認証に失敗した際に、Spring Securityが発生させるイベントをハンドリングし、認証に使用したユーザ名と認証を試みた日時を認証失敗イベントエンティティとしてデータベースに登録する。
 
 * ロックアウト状態の判定
 
   あるアカウントについて、現在時刻から一定以上新しい認証失敗イベントエンティティが一定個数以上存在する場合、該当アカウントはロックアウト状態であると判定する。
   認証時にこの判定処理を呼び出し、判定結果を\ ``UserDetails`` \の実装クラスに設定する。
 
-* 管理ユーザによる認証失敗イベントエンティティの削除
+* 認証失敗イベントエンティティの削除
 
-  あるアカウントについて、認証失敗イベントエンティティをすべて削除する。
-  認証失敗イベントエンティティが消去されると該当アカウントはロックアウト状態と判定されなくなるため、これはロックアウト解除処理に相当する。
-  認証失敗イベントエンティティの消去は認可機能を用いて、管理ユーザ以外実行できないようにする。
+  | あるアカウントについて、認証失敗イベントエンティティをすべて削除する。
+  | ロックアウトの対象となるのは連続して認証に失敗した場合のみであるため、認証に成功した際には認証失敗イベントエンティティを削除する。
+  | また、アカウントのロックアウト状態は認証失敗イベントエンティティを用いて判定されるため、認証失敗イベントエンティティを消去することでロックアウト解除機能が実現できる。
+    アカウントのロックアウトは認可機能を用いて、管理ユーザ以外実行できないようにする。
 
 .. warning::
 
-   認証失敗イベントエンティティはロックアウトの判定のみを目的としているため、不要になったタイミングで消去される。
+   認証失敗イベントエンティティはロックアウトの判定のみを目的としているため、不要になったタイミングで消去する。
    認証ログが必要な場合は必ず別途ログを保存しておくこと。
 
 認証失敗イベントエンティティを用いたロックアウト機能の動作例を以下の図を用いて説明する。
@@ -1639,10 +1696,19 @@ ER図
    :width: 60%
    :align: center
   
-*  | 過去10分以内に、誤ったパスワードでの認証が3回試行されており、データベースには3回分の認証失敗イベントエンティティが保存されている。
-   | そのため、アカウントはロックアウト状態であると判定される。
-*  | データベースには3回分の認証失敗イベントエンティティが保存されている。
-   | しかしながら、過去10分以内の認証失敗イベントエンティティは2回分のみであるため、ロックアウト状態ではないと判定される。
+.. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+.. list-table::
+   :header-rows: 1
+   :widths: 10 90
+  
+   * - 項番
+     - 説明
+   * - | (1)
+     - | 過去10分以内に、誤ったパスワードでの認証が3回試行されており、データベースには3回分の認証失敗イベントエンティティが保存されている。
+       | そのため、アカウントはロックアウト状態であると判定される。
+   * - | (2)
+     - | データベースには3回分の認証失敗イベントエンティティが保存されている。
+       | しかしながら、過去10分以内の認証失敗イベントエンティティは2回分のみであるため、ロックアウト状態ではないと判定される。
 
 同様に、ロックアウトを解除する場合の動作例を以下の図で説明する。
 
@@ -1651,20 +1717,23 @@ ER図
    :width: 60%
    :align: center
 
-*  | 過去10分以内に、誤ったパスワードでの認証が3回試行されている。
-   | その後、認証失敗イベントエンティティが消去されているため、データベースには認証失敗イベントエンティティが保存されておらず、ロックアウト状態ではないと判定される。
-
-.. note::
-   本実装例においては、認証失敗が連続していない場合でもロックアウトされることに留意する。
-   すなわち、途中で認証成功した場合であっても、一定期間内に一定回数以上認証に失敗された場合にはロックアウトされる。
-   また、ロックアウト継続時間の起点にも注意すること。
+.. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+.. list-table::
+   :header-rows: 1
+   :widths: 10 90
+  
+   * - 項番
+     - 説明
+   * - | (1)
+     - | 過去10分以内に、誤ったパスワードでの認証が3回試行されている。
+       | その後、認証失敗イベントエンティティが消去されているため、データベースには認証失敗イベントエンティティが保存されておらず、ロックアウト状態ではないと判定される。
    
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
 * 共通部分
 
-  本実装例において、アカウントのロックアウトに関する機能を実現するためには、データベースに対する認証失敗イベントエンティティの登録、検索、削除が共通的に必要となる。
+  本アプリケーションにおいて、アカウントのロックアウトに関する機能を実現するためには、データベースに対する認証失敗イベントエンティティの登録、検索、削除が共通的に必要となる。
   そのため、まずは認証失敗イベントエンティティに関するドメイン層・インフラストラクチャ層の実装を示す。
   
   * Entityの実装
@@ -1710,9 +1779,9 @@ ER図
       
       public interface FailedAuthenticationRepository {
       
-        int insert(FailedAuthentication accountAuthenticationLog); // (1)
+        int create(FailedAuthentication event); // (1)
       
-        List<FailedAuthentication> findLatestEvents(
+        List<FailedAuthentication> findLatest(
                         @Param("username") String username, @Param("count") long count); // (2)
       
         int deleteByUsername(@Param("username") String username); // (3)
@@ -1749,7 +1818,7 @@ ER図
                 <id property="authenticationTimestamp" column="authentication_timestamp" />
         </resultMap>
       
-        <insert id="insert" parameterType="FailedAuthentication">
+        <insert id="create" parameterType="FailedAuthentication">
           <![CDATA[
               INSERT INTO failed_authentication (
                   username,
@@ -1761,7 +1830,7 @@ ER図
           ]]>
         </insert>
       
-        <select id="findLatestEvents" resultMap="failedAuthenticationResultMap">
+        <select id="findLatest" resultMap="failedAuthenticationResultMap">
              <![CDATA[
                   SELECT
                       username,
@@ -1802,9 +1871,15 @@ ER図
 
            // omitted
 
+           @Inject
+           ClassicDateFactory dateFactory;
+           
            @Inject
            FailedAuthenticationRepository failedAuthenticationRepository;
 
+           @Inject
+           AccountSharedService accountSharedService;
+
            @Transactional(readOnly = true)
            @Override
            public List<FailedAuthentication> findLatestFailureEvents(
@@ -1812,10 +1887,18 @@ ER図
                    return failedAuthenticationRepository.findLatestEvents(username, count);
            }
 
+
            @Override
-           public int insertFailureEvent(FailedAuthentication event) {
-                   return failedAuthenticationRepository.insert(event);
-           }
+            public void authenticationFailure(String username) { // (1)
+                FailedAuthentication failureEvents = new FailedAuthentication();
+                failureEvents.setUsername(username);
+                failureEvents.setAuthenticationTimestamp(dateFactory.newTimestamp()
+                        .toLocalDateTime());
+                
+                if (accountSharedService.exists(username)){
+                    failedAuthenticationRepository.create(failureEvents);
+                }
+            }
 
            @Override
            public int deleteFailureEventByUsername(String username) {
@@ -1825,12 +1908,24 @@ ER図
            // omitted
 
        }
+
+    .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+    .. list-table::
+       :header-rows: 1
+       :widths: 10 90
+    
+       * - 項番
+         - 説明
+       * - | (1)
+         - | 認証失敗イベントエンティティを作成してデータベースに登録するメソッド。
+           | 引数として受け取ったユーザ名のアカウントが存在しない場合、データベースの外部キー制約に違反するため、データベースへの登録処理をスキップする。
            
-以下、実装方針に従って実装されたコードについて順に解説する。
+以下、実装方法に従って実装されたコードについて順に解説する。
 
 * 認証失敗イベントエンティティの保存
 
   認証失敗時に発生するイベントをハンドリングして処理を行うために、\ ``@EventListener`` \アノテーションを使用する。
+  \ ``@EventListener`` \アノテーションによるイベントのハンドリングについては :doc:`./Authentication` の「イベントリスナの作成」を参照すること。
 
   .. code-block:: java
 
@@ -1850,11 +1945,7 @@ ER図
 
              String username = (String) event.getAuthentication().getPrincipal(); // (2)
 
-             FailedAuthentication failureEvents = new FailedAuthentication(); // (3)
-             failureEvents.setUsername(username);
-             failureEvents.setAuthenticationTimestamp(LocalDateTime.now());
-
-             authenticationEventSharedService.insertFailureEvent(failureEvents); // (4)
+             authenticationEventSharedService.authenticationFailure(username); // (3)
          }
 
      }
@@ -1871,9 +1962,7 @@ ER図
      * - | (2)
        - | \ ``AuthenticationFailureBadCredentialsEvent`` \オブジェクトから、認証に使用したユーザ名を取得する。
      * - | (3)
-       - | 認証失敗イベントエンティティを作成し、ユーザ名と現在時刻を設定する。
-     * - | (4)
-       - | 認証失敗イベントエンティティをデータベースに登録する処理を呼び出す。
+       - | 認証失敗イベントエンティティを作成してデータベースに登録する処理を呼び出す。
 
 * ロックアウト状態の判定
 
@@ -1891,11 +1980,14 @@ ER図
 
          // omitted
 
+         @Inject
+         ClassicDateFactory dateFactory;
+
          @Inject
          AuthenticationEventSharedService authenticationEventSharedService;
 
-         @Value("${security.lockingDuration}") // (1)
-         int lockingDuration;
+         @Value("${security.lockingDurationSeconds}") // (1)
+         int lockingDurationSeconds;
 
          @Value("${security.lockingThreshold}") // (2)
          int lockingThreshold;
@@ -1914,7 +2006,8 @@ ER図
                      .get(lockingThreshold - 1) // (5)
                      .getAuthenticationTimestamp()
                      .isBefore(
-                             LocalDateTime.now().minusSeconds(lockingDuration))) {
+                             dateFactory.newTimestamp().toLocalDateTime()
+                             .minusSeconds(lockingDurationSeconds))) {
                  return false;
              }
 
@@ -1943,7 +2036,7 @@ ER図
        - | 取得した認証失敗イベントエンティティのうち最も古い認証失敗時刻と現在時刻の差分が、ロックアウト継続時間よりも大きい場合には、ロックアウト状態ではないと判定する。
 
   | \ ``UserDetails`` \の実装クラスである\ ``org.springframework.security.core.userdetails.User`` \では、コンストラクタにロックアウト状態を渡すことができる。
-  | 本実装例では以下のように\ ``User`` \を継承したクラスと、\ ``org.springframework.security.core.userdetails.UserDetailsService`` \を実装したクラスを用いる。
+  | 本アプリケーションでは以下のように\ ``User`` \を継承したクラスと、\ ``org.springframework.security.core.userdetails.UserDetailsService`` \を実装したクラスを用いる。
 
   .. code-block:: java
   
@@ -2054,238 +2147,316 @@ ER図
      * - | (1)
        - | \ ``UserDetailsService`` \のBeanのidを指定する。
 
-* 管理ユーザによる認証失敗イベントエンティティの削除
+* 認証失敗イベントエンティティの削除
 
-  | ロックアウト状態の判定に認証失敗イベントエンティティを使用しているため、認証失敗イベントエンティティの削除はロックアウトの解除に相当する。
-  | 認証失敗イベントエンティティの削除に関するインフラストラクチャ層・ドメイン層の実装は既に済ませているため、ここでは認可の設定と、ロックアウト解除機能としてのドメイン層・アプリケーション層の実装を行う。
+  * 認証成功時の認証失敗イベントエンティティの削除
 
-  * 認可の設定
+    連続した認証失敗のみをロックアウトの判定に使用するため、認証に成功した際にはアカウントの認証失敗イベントエンティティを削除する。
+    共通部分として作成したServiceに、認証成功時に実行するメソッドを作成する。
 
-    ロックアウトの解除を行うことができるユーザの権限を以下の通りに設定する。
+    .. code-block:: java
 
-    **spring-security.xml**
+       package org.terasoluna.securelogin.domain.service.authenticationevent;
 
-    .. code-block:: xml
+       // omitted
 
-      <!-- omitted -->
+       @Service
+       @Transactional
+       public class AuthenticationEventSharedServiceImpl implements
+                       AuthenticationEventSharedService {
 
-        <sec:http pattern="/resources/**" security="none" />
-        <sec:http>
-        
-            <!-- omitted -->
-            
-            <sec:intercept-url pattern="/unlock/**" access="hasRole('ADMN')" /> <!-- (1) -->
-            
-            <!-- omitted -->
-            
-        </sec:http>
+           // omitted
+
+           @Override
+           public void authenticationSuccess(String username) {
+
+               // omitted
+
+               deleteFailureEventByUsername(username); // (1)
+           }
+
+           // omitted
 
-      <!-- omitted -->
+       }
 
     .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
     .. list-table::
        :header-rows: 1
        :widths: 10 90
-  
+    
        * - 項番
          - 説明
        * - | (1)
-         - | /unlock 以下のURLへのアクセス権限を管理ユーザに限定する。
+         - | 引数として渡されたユーザ名のアカウントに関する認証失敗イベントエンティティを削除する。
 
-  * Serviceの実装
+
+    認証成功時に発生するイベントをハンドリングして処理を行うために、 \ ``@EventListener`` \アノテーションを使用する。
 
     .. code-block:: java
 
-       package org.terasoluna.securelogin.domain.service.unlock;
+       package org.terasoluna.securelogin.domain.service.account;
 
        // omitted
 
-       @Transactional
-       @Service
-       public class UnlockServiceImpl implements UnlockService {
-
-           @Inject
-           AccountSharedService accountSharedService;
+       @Component
+       public class AccountAuthenticationSuccessEventListener{ 
 
            @Inject
            AuthenticationEventSharedService authenticationEventSharedService;
 
-           @Override
-           public boolean unlock(String username) {
-               if (!accountSharedService.isLocked(username)) { // (1)
-                   throw new BusinessException(ResultMessages.error().add(
-                           MessageKeys.E_SL_UL_5001));
-               }
+           @EventListener // (1)
+           public void onApplicationEvent(
+                           AuthenticationSuccessEvent event) {
 
-               authenticationEventSharedService
-                      .deleteFailureEventByUsername(username); // (2)
+               LoggedInUser details = (LoggedInUser) event.getAuthentication()
+                       .getPrincipal();
+
+               authenticationEventSharedService.authenticationSuccess(details.getUsername()); // (2)
 
-               return true;
            }
 
        }
-      
+           
     .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
     .. list-table::
        :header-rows: 1
        :widths: 10 90
-  
+    
        * - 項番
          - 説明
        * - | (1)
-         - | ロック解除対象のアカウントのロックアウト状態を判定し、ロックアウト状態でなければ例外を発生させる。
+         - | \ ``@EventListener`` \アノテーションを付与することで、認証が成功した際に\ ``onApplicationEvent`` \メソッドが実行される。
        * - | (2)
-         - | 認証失敗イベントエンティティを消去することによりロックアウト状態を解除する。
+         - | \ ``AuthenticationSuccessEvent`` \からユーザ名を取得し、認証失敗イベントエンティティを削除する処理を呼び出す。
+    
+    
+  * ロックアウト状態の解除
 
-  * Formの実装
+    ロックアウト状態の判定に認証失敗イベントエンティティを使用しているため、認証失敗イベントエンティティを削除することでロックアウト状態を解除することができる。
+    ロックアウト解除機能の使用を管理権限を持つユーザに限定するための認可の設定と、ドメイン層・アプリケーション層の実装を行う。
 
-    .. code-block:: java
+    * 認可の設定
 
-      package org.terasoluna.securelogin.app.unlock;    
+      ロックアウトの解除を行うことができるユーザの権限を以下の通りに設定する。
 
-      @Data
-      public class UnlockForm {
-          @NotEmpty
-          private String username;
-      }
-      
-  * Viewの実装
+      **spring-security.xml**
 
-    **トップ画面(home.jsp)**
+      .. code-block:: xml
 
-    .. code-block:: jsp
+        <!-- omitted -->
 
-      <!-- omitted -->
+          <sec:http pattern="/resources/**" security="none" />
+          <sec:http>
+          
+              <!-- omitted -->
+              
+              <sec:intercept-url pattern="/unlock/**" access="hasRole('ADMIN')" /> <!-- (1) -->
+              
+              <!-- omitted -->
+              
+          </sec:http>
+
+        <!-- omitted -->
 
-      <body>
-          <div id="wrapper">
+      .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+      .. list-table::
+         :header-rows: 1
+         :widths: 10 90
+    
+         * - 項番
+           - 説明
+         * - | (1)
+           - | /unlock 以下のURLへのアクセス権限を管理ユーザに限定する。
 
-              <!-- omitted -->        
+    * Serviceの実装
 
-              <sec:authorize url="/unlock"> <!-- (1) -->
-                  <form:form
-                      action="${f:h(pageContext.request.contextPath)}/unlock?form">
-                      <button id="unlock">Unlock Account</button>
-                  </form:form>
-              </sec:authorize>
+      .. code-block:: java
 
-              <!-- omitted -->
+         package org.terasoluna.securelogin.domain.service.unlock;
 
-          </div>
-      </body>
+         // omitted
 
-      <!-- omitted -->
+         @Transactional
+         @Service
+         public class UnlockServiceImpl implements UnlockService {
 
-    .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
-    .. list-table::
-       :header-rows: 1
-       :widths: 10 90
-  
-       * - 項番
-         - 説明
-       * - | (1)
-         - | /unlock 以下のアクセス権限を持つユーザに対してのみ表示する。
+             @Inject
+             AccountSharedService accountSharedService;
 
-    **ロックアウト解除フォーム(unlokcForm.jsp)**
+             @Inject
+             AuthenticationEventSharedService authenticationEventSharedService;
 
-    .. code-block:: jsp
+             @Override
+             public void unlock(String username) {
+                 authenticationEventSharedService
+                        .deleteFailureEventByUsername(username); // (1)
+             }
+
+         }
+        
+      .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+      .. list-table::
+         :header-rows: 1
+         :widths: 10 90
     
-      <!-- omitted -->
-
-      <body>
-          <div id="wrapper">
-              <h1>Unlock Account</h1>
-              <t:messagesPanel />
-              <form:form action="${f:h(pageContext.request.contextPath)}/unlock"
-                  method="POST" modelAttribute="unlockForm">
-                  <table>
-                      <tr>
-                          <th><form:label path="username" cssErrorClass="error-label">Username</form:label>
-                          </th>
-                          <td><form:input path="username" cssErrorClass="error-input" /></td>
-                          <td><form:errors path="username" cssClass="error-messages" /></td>
-                      </tr>
-                  </table>
-
-                  <input id="submit" type="submit" value="Unlock" />
-              </form:form>
-              <a href="${f:h(pageContext.request.contextPath)}/">go to Top</a>
-          </div>
-      </body>
-
-      <!-- omitted -->
-
-    **ロックアウト解除完了画面(unlockComplete.jsp)**
+         * - 項番
+           - 説明
+         * - | (1)
+           - | 認証失敗イベントエンティティを消去することによりロックアウト状態を解除する。
 
-    .. code-block:: jsp
+    * Formの実装
 
-      <!-- omitted -->
+      .. code-block:: java
 
-      <body>
-          <div id="wrapper">
-                <h1>${f:h(username)}'s account was successfully unlocked.</h1>
-                <a href="${f:h(pageContext.request.contextPath)}/">go to Top</a>
-          </div>
-      </body>
+        package org.terasoluna.securelogin.app.unlock;    
+
+        @Data
+        public class UnlockForm implements Serializable {
+
+            private static final long serialVersionUID = 1L;
+
+            @NotEmpty
+            private String username;
+        }
+        
+    * Viewの実装
+
+      **トップ画面(home.jsp)**
+
+      .. code-block:: jsp
+
+        <!-- omitted -->
+
+        <body>
+            <div id="wrapper">
+
+                <!-- omitted -->        
+
+                <sec:authorize url="/unlock"> <!-- (1) -->
+                <div>
+                    <button id="unlock"
+                        onClick="location.href='${f:h(pageContext.request.contextPath)}/unlock?form'">Unlock
+                        Account</button>
+                </div>
+                </sec:authorize>
+
+                <!-- omitted -->
+
+            </div>
+        </body>
+
+        <!-- omitted -->
+
+      .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+      .. list-table::
+         :header-rows: 1
+         :widths: 10 90
+    
+         * - 項番
+           - 説明
+         * - | (1)
+           - | /unlock 以下のアクセス権限を持つユーザに対してのみ表示する。
+
+      **ロックアウト解除フォーム(unlokcForm.jsp)**
+
+      .. code-block:: jsp
       
-      <!-- omitted -->
+        <!-- omitted -->
 
-  * Controllerの実装
+        <body>
+            <div id="wrapper">
+                <h1>Unlock Account</h1>
+                <t:messagesPanel />
+                <form:form action="${f:h(pageContext.request.contextPath)}/unlock"
+                    method="POST" modelAttribute="unlockForm">
+                    <table>
+                        <tr>
+                            <th><form:label path="username" cssErrorClass="error-label">Username</form:label>
+                            </th>
+                            <td><form:input path="username" cssErrorClass="error-input" /></td>
+                            <td><form:errors path="username" cssClass="error-messages" /></td>
+                        </tr>
+                    </table>
+
+                    <input id="submit" type="submit" value="Unlock" />
+                </form:form>
+                <a href="${f:h(pageContext.request.contextPath)}/">go to Top</a>
+            </div>
+        </body>
 
-    .. code-block:: java
+        <!-- omitted -->
 
-       package org.terasoluna.securelogin.app.unlock;
+      **ロックアウト解除完了画面(unlockComplete.jsp)**
 
-       // omitted
+      .. code-block:: jsp
 
-       @Controller
-       @RequestMapping("/unlock") // (1)
-       public class UnlockController {
+        <!-- omitted -->
 
-           @Inject
-           UnlockService unlockService;
+        <body>
+            <div id="wrapper">
+                  <h1>${f:h(username)}'s account was successfully unlocked.</h1>
+                  <a href="${f:h(pageContext.request.contextPath)}/">go to Top</a>
+            </div>
+        </body>
+        
+        <!-- omitted -->
 
-           @RequestMapping(params = "form")
-           public String showForm(UnlockForm form) {
-               return "unlock/unlockForm";
-           }
+    * Controllerの実装
 
-           @RequestMapping(method = RequestMethod.POST)
-           public String unlock(@Validated UnlockForm form,
-                   BindingResult bindingResult, Model model,
-                   RedirectAttributes attributes) {
-               if (bindingResult.hasErrors()) {
-                       return showForm(form);
-               }
+      .. code-block:: java
 
-               try {
-                   unlockService.unlock(form.getUsername()); // (2)
-                   attributes.addFlashAttribute("username", form.getUsername());
-                   return "redirect:/unlock?complete";
-               } catch (BusinessException e) {
-                   model.addAttribute(e.getResultMessages());
-                   return showForm(form);
-               }
-           }
+         package org.terasoluna.securelogin.app.unlock;
 
-           @RequestMapping(method = RequestMethod.GET, params = "complete")
-           public String unlockComplete() {
-               return "unlock/unlockComplete";
-           }
+         // omitted
 
-       }
+         @Controller
+         @RequestMapping("/unlock") // (1)
+         public class UnlockController {
 
-    .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
-    .. list-table::
-       :header-rows: 1
-       :widths: 10 90
-  
-       * - 項番
-         - 説明
-       * - | (1)
-         - | /unlock 以下のURLにマッピングする。認可の設定によって、管理ユーザのみがアクセス可能となる。
-       * - | (2)
-         - | Formから取得したユーザ名を引数として、アカウントのロックアウトを解除する処理を呼び出す。
+             @Inject
+             UnlockService unlockService;
+
+             @RequestMapping(params = "form")
+             public String showForm(UnlockForm form) {
+                 return "unlock/unlockForm";
+             }
+
+             @RequestMapping(method = RequestMethod.POST)
+             public String unlock(@Validated UnlockForm form,
+                     BindingResult bindingResult, Model model,
+                     RedirectAttributes attributes) {
+                 if (bindingResult.hasErrors()) {
+                         return showForm(form);
+                 }
+
+                 try {
+                     unlockService.unlock(form.getUsername()); // (2)
+                     attributes.addFlashAttribute("username", form.getUsername());
+                     return "redirect:/unlock?complete";
+                 } catch (BusinessException e) {
+                     model.addAttribute(e.getResultMessages());
+                     return showForm(form);
+                 }
+             }
+
+             @RequestMapping(method = RequestMethod.GET, params = "complete")
+             public String unlockComplete() {
+                 return "unlock/unlockComplete";
+             }
+
+         }
+
+      .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
+      .. list-table::
+         :header-rows: 1
+         :widths: 10 90
+    
+         * - 項番
+           - 説明
+         * - | (1)
+           - | /unlock 以下のURLにマッピングする。認可の設定によって、管理ユーザのみがアクセス可能となる。
+         * - | (2)
+           - | Formから取得したユーザ名を引数として、アカウントのロックアウトを解除する処理を呼び出す。
 
 .. _last-login:
 
@@ -2303,26 +2474,26 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-| 本実装例では、認証に成功した履歴を「認証成功イベント」エンティティとしてデータベースに保存し、この認証成功イベントエンティティを用いて、トップ画面にアカウントの前回ログイン日時を表示する。
+| 本アプリケーションでは、認証に成功した履歴を「認証成功イベント」エンティティとしてデータベースに保存し、この認証成功イベントエンティティを用いて、トップ画面にアカウントの前回ログイン日時を表示する。
 | 具体的には以下の二つの処理を実装することで、要件を実現する。
 
 * 認証成功イベントエンティティの保存
 
-  認証に成功した際にSpringが発生させるイベントをハンドリングし、認証に使用したユーザ名と認証に成功した日時を認証成功イベントエンティティとしてデータベースに登録する。
+  認証に成功した際にSpring Securityが発生させるイベントをハンドリングし、認証に使用したユーザ名と認証に成功した日時を認証成功イベントエンティティとしてデータベースに登録する。
 
 * 前回ログイン日時の取得と表示
 
   認証時に、アカウントにおける最新の認証成功イベントエンティティをデータベースから取得し、イベントエンティティから認証成功日時を取得して\ ``org.springframework.security.core.userdetails.UserDetails`` \に設定する。
-  jspから\ ``UserDetails`` \が保持している認証成功日時にアクセスし、フォーマットして表示する。
+  jspに\ ``UserDetails`` \が保持している認証成功日時をフォーマットして渡し、表示する。
 
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
 * 共通部分
 
-  本実装例において、前回ログイン日時を表示するためには、データベースに対する認証成功イベントエンティティの登録、検索が必要となる。
+  本アプリケーションにおいて、前回ログイン日時を表示するためには、データベースに対する認証成功イベントエンティティの登録、検索が必要となる。
   そのため、まずは認証成功イベントエンティティに関するドメイン層・インフラストラクチャ層の実装から解説を行う。
   
   * Entityの実装
@@ -2370,7 +2541,7 @@ ER図
 
        public interface SuccessfulAuthenticationRepository {
 
-           int insert(SuccessfulAuthentication accountAuthenticationLog); // (1)
+           int create(SuccessfulAuthentication event); // (1)
 
            List<SuccessfulAuthentication> findLatestEvents(
                   @Param("username") String username, @Param("count") long count); // (2)
@@ -2405,13 +2576,13 @@ ER図
                <id property="authenticationTimestamp" column="authentication_timestamp" />
            </resultMap>
 
-           <insert id="insert" parameterType="SuccessfulAuthentication">
+           <insert id="create" parameterType="SuccessfulAuthentication">
            <![CDATA[
                INSERT INTO successful_authentication (
                    username,
                    authentication_timestamp
                ) VALUES (
-                       #{username},
+                   #{username},
                    #{authenticationTimestamp}
                )
            ]]>
@@ -2448,6 +2619,10 @@ ER図
        		AuthenticationEventSharedService {
 
            // omitted
+           
+           @Inject
+           ClassicDateFactory dateFactory;
+
            @Inject
            SuccessfulAuthenticationRepository successAuthenticationRepository;
 
@@ -2459,13 +2634,18 @@ ER図
            }
 
            @Override
-           public int insertSuccessEvent(SuccessfulAuthentication event) {
-               return successAuthenticationRepository.insert(event);
-           }
+             public void authenticationSuccess(String username) {
+                 SuccessfulAuthentication successEvent = new SuccessfulAuthentication();
+                 successEvent.setUsername(username);
+                 successEvent.setAuthenticationTimestamp(dateFactory.newTimestamp().toLocalDateTime());
+
+                 successAuthenticationRepository.create(successEvent);
+                 deleteFailureEventByUsername(username);
+             }
 
        }
   
-以下、実装方針に従って実装されたコードについて順に解説する。
+以下、実装方法に従って実装されたコードについて順に解説する。
 
 * 認証成功イベントエンティティの保存
 
@@ -2488,11 +2668,7 @@ ER図
              LoggedInUser details = (LoggedInUser) event.getAuthentication()
                              .getPrincipal(); // (2)
 
-             SuccessfulAuthentication successEvent = new SuccessfulAuthentication(); // (3)
-             successEvent.setUsername(details.getUsername());
-             successEvent.setAuthenticationTimestamp(LocalDateTime.now());
-
-             authenticationEventSharedService.insertSuccessEvent(successEvent); // (4)
+             authenticationEventSharedService.authenticationSuccess(details.getUsername()); // (3)
          }
 
      }
@@ -2509,9 +2685,7 @@ ER図
      * - | (2)
        - | \ ``AuthenticationSuccessEvent`` \オブジェクトから、\ ``UserDetails`` \の実装クラスを取得する。このクラスについては以降で説明する。
      * - | (3)
-       - | 認証成功イベントエンティティを作成し、ユーザ名と現在時刻を設定する。
-     * - | (4)
-       - | 認証成功イベントエンティティをデータベースに登録する処理を呼び出す。
+       - | 認証成功イベントエンティティを作成し、データベースに登録する処理を呼び出す。
 
 * 前回ログイン日時の取得と表示
 
@@ -2534,7 +2708,7 @@ ER図
 
           @Transactional(readOnly = true)
           @Override
-          public DateTime getLastLoginDate(String username) {
+          public LocalDateTime getLastLoginDate(String username) {
               List<SuccessfulAuthentication> events = authenticationEventSharedService
                           .findLatestSuccessEvents(username, 1); // (1)
 
@@ -2708,7 +2882,7 @@ ER図
 
           <!-- omitted -->
 
-          <c:if test="${lastLoginDate != null}"> <!-- (1) -->
+          <c:if test="${!empty lastLoginDate}"> <!-- (1) -->
               <p id="lastLogin">
                   Last login date is ${f:h(lastLoginDate)}. <!-- (2) -->
               </p>
@@ -2749,10 +2923,21 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+パスワード再発行のための認証情報生成画面で、パスワードを再発行するユーザ名を入力する。このとき、パスワード再発行時の認証に使用する秘密情報と、トークンが生成される。
+秘密情報は画面に表示され、トークンを含んだパスワード再発行画面のURLはユーザの登録済みメールアドレスに送付される。
+
+メール送付されたURLには有効期限があり、有効期限内にアクセスして秘密情報と新しいパスワードを入力することで、パスワードを変更することができる。
+有効期限が切れた後にメール送付されたURLにアクセスした場合、エラー画面に遷移する。
+
+ここでは、秘密情報とトークンの生成について説明を行う
+
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-| パスワードの再発行を行う際には、再発行を行うユーザがアカウントの所有者であることを確認する必要がある。そのため、本実装例では、パスワードの再発行を行う前にパスワード再発行用の認証情報を生成する。
-| 認証情報の生成の際には、パスワード再発行画面のURLに含めるためのランダムな文字列とユーザの確認を目的としたランダムな文字列を、それぞれ異なる方法で生成する。また、認証情報生成時点の日時を用いて有効期限を計算し、設定する。
+| パスワードの再発行を行う際には、ユーザがアカウントの所有者であることを確認するためのパスワードに代わる手段が必要である。
+| 本アプリケーションでは、ユーザを確認するための情報として、パスワード再発行画面のURLと秘密情報の二つを用いる。
+| パスワード再発行画面のURLを一意かつ推測困難にするために、ランダムな文字列を生成しURLに付加する。万が一URLが漏えいした場合に備え、ランダムな文字列である秘密情報を生成し、これを用いて認証を行う。
+| 二つのランダムな文字列は、片方からもう一方を推測することが不可能となるように、それぞれ異なる方法で生成する。
+| また、一般的にはパスワードの再発行は認証情報の生成から間をおかずに行われるため、不必要に長期間有効となることが無いようにに、有効期限を設定する。
 | 具体的には以下の三つの処理を実装することで要件を実現する。
 
 * パスワード再発行のための認証情報の生成と保存
@@ -2764,12 +2949,12 @@ ER図
   * 秘密情報：パスワード再発行時にユーザに入力させるために生成するランダムな文字列
   * 有効期限：パスワード再発行のための認証情報の有効期限
 
-  トークンと秘密情報はそれぞれ異なる方法を使用して生成する。
+  秘密情報については、パスワードと同様にハッシュ化してデータベースへ保存する。
   パスワード再発行のための認証情報をユーザに配布する方法については、:ref:`パスワード再発行のための認証情報の配布 <reissue-info-delivery>` を参照。
 
 * パスワード再発行のための認証情報の有効期限の検査
 
-  パスワード再発行画面にアクセスされた際に、リクエストパラメータに含まれるユーザ名とトークンを取得し、トークンをキーとしてデータベースに保存されているパスワード再発行のための認証情報を検索する。
+  パスワード再発行画面にアクセスされた際に、リクエストパラメータに含まれるトークンを取得し、トークンをキーとしてデータベースに保存されているパスワード再発行のための認証情報を検索する。
   認証情報に含まれる有効期限と現在時刻を比較し、有効期限が切れていればエラー画面に遷移させる。
 
 * パスワード再発行のための認証情報を用いたユーザの確認
@@ -2782,7 +2967,7 @@ ER図
 
 * 共通部分
 
-  上記の実装方針に従って実装を進める上で、パスワード再発行のための認証情報をデータベースに登録、検索する処理が共通的に必要となる。
+  上記の実装方法に従って実装を進める上で、パスワード再発行のための認証情報をデータベースに登録、検索する処理が共通的に必要となる。
   そのため、まずはパスワード再発行のための認証情報に関連するEntityとRepositoryの実装から解説する。
 
   * Entityの作成
@@ -2836,7 +3021,7 @@ ER図
 
        public interface PasswordReissueInfoRepository {
 
-           int insert(PasswordReissueInfo info); // (1)
+           void create(PasswordReissueInfo info); // (1)
 
            PasswordReissueInfo findOne(@Param("token") String token); // (2)
 
@@ -2892,7 +3077,7 @@ ER図
           ]]>
           </select>
 
-          <insert id="insert" parameterType="PasswordReissueInfo">
+          <insert id="create" parameterType="PasswordReissueInfo">
           <![CDATA[
               INSERT INTO password_reissue_info (
                   username,
@@ -2921,7 +3106,7 @@ ER図
 
       </mapper>
 
-以下、実装方針に従って実装されたコードについて順に解説する。
+以下、実装方法に従って実装されたコードについて順に解説する。
 
 * パスワード再発行のための認証情報の生成と保存
 
@@ -2950,7 +3135,7 @@ ER図
        <bean id="passwordGenerationRules"
            class="org.springframework.beans.factory.config.ListFactoryBean">
            <property name="sourceList">
-               <list value-type="org.passay.CharacterRule"> <!-- (2) -->
+               <list> <!-- (2) -->
                    <ref bean="upperCaseRule" />
                    <ref bean="lowerCaseRule" />
                    <ref bean="digitRule" />
@@ -2960,7 +3145,7 @@ ER図
 
   * Serviceの実装
 
-    パスワード再発行のための認証情報を作成し、データベースへ保存するための処理の実装を以下に示す。
+    パスワード再発行のための認証情報を作成し、データベースへ保存するための処理の実装を以下に示す。この処理中で生成した認証情報をメール送信する。メール送信については後述するため、ここでは省略する。
 
     .. code-block:: java
 
@@ -2969,9 +3154,12 @@ ER図
        // omitted
 
        @Service
-       @Transactionalp
+       @Transactional
        public class PasswordReissueServiceImpl implements PasswordReissueService {
 
+           @Inject
+           ClassicDateFactory dateFactory;
+
            @Inject
            PasswordReissueInfoRepository passwordReissueInfoRepository;
 
@@ -2984,44 +3172,42 @@ ER図
            @Inject
            PasswordGenerator passwordGenerator; // (1)
 
-           @Resource(name = "passwordGenerationRules")
+           @Resource(name="passwordGenerationRules")
            List<CharacterRule> passwordGenerationRules; //(2)
 
-           @Value("${security.tokenLifeTime}")
-           int tokenLifeTime; // (3)
+           @Value("${security.tokenLifeTimeSeconds}")
+           int tokenLifeTimeSeconds; // (3)
 
            // omitted
 
            @Override
-           public String createRawSecret() {
-               return passwordGenerator.generatePassword(10, passwordGenerationRules); // (4)
-           }
+           public String createAndSendReissueInfo(String username) {
+               
+               String rowSecret = passwordGenerator.generatePassword(10, passwordGenerationRules); // (4)
 
-           @Override
-           public boolean saveAndSendReissueInfo(String username, String rawSecret) {
-               Account account = accountSharedService.findOne(username); // (5)
+               if(!accountSharedService.exists(username)){ // (5)
+                   return rowSecret;           
+               }
+               
+               Account account= accountSharedService.findOne(username); // (6)
                
-               String token = UUID.randomUUID().toString(); // (6)
+               String token = UUID.randomUUID().toString(); // (7)
 
-               LocalDateTime expiryDate = LocalDateTime.now().plusSeconds(
-                       tokenLifeTime); // (7)
+               LocalDateTime expiryDate = dateFactory.newTimestamp().toLocalDateTime()
+                       .plusSeconds(tokenLifeTimeSeconds); // (8)
 
-               PasswordReissueInfo info = new PasswordReissueInfo(); // (8)
+               PasswordReissueInfo info = new PasswordReissueInfo(); // (9)
                info.setUsername(username);
                info.setToken(token);
-               info.setSecret(passwordEncoder.encode(rawSecret)); // (9)
+               info.setSecret(passwordEncoder.encode(rowSecret)); // (10)
                info.setExpiryDate(expiryDate);
-               
-               int count = passwordReissueInfoRepository.insert(info); // (10)
 
-               if (count > 0) {
+               passwordReissueInfoRepository.create(info); // (11)
 
-                   // omitted
+               // omitted (Send E-Mail)
+
+               return rowSecret; // (12)
 
-                   return true;
-               } else {
-                   return false;
-               }
            }
 
            // omitted
@@ -3044,17 +3230,21 @@ ER図
        * - | (4)
          - | 秘密情報として用いるために、Passayのパスワード生成機能を用いて、パスワード生成規則に従った、長さ10のランダムな文字列を生成する。
        * - | (5)
-         - | パスワード再発行用の認証情報に含まれるユーザ名のアカウント情報を取得する。該当するアカウントが存在しない場合、\ ``org.terasoluna.gfw.common.exception.ResourceNotFoundException`` \がthrowされる。
+         - | 引数として渡されてきたユーザ名のアカウントが存在するかどうか確認する。存在しなかった場合、ユーザが存在しないことを知られないためにダミーの秘密情報を返す。
        * - | (6)
-         - | トークンとして用いるために、\ ``java.util.UUID`` \クラスの\ ``randomUUID`` \メソッドを用いてランダムな文字列を生成する。
+         - | パスワード再発行用の認証情報に含まれるユーザ名のアカウント情報を取得する。
        * - | (7)
-         - | 現在時刻に(3)の値を加えることにより、パスワード再発行用の認証情報の有効期限を計算する。
+         - | トークンとして用いるために、\ ``java.util.UUID`` \クラスの\ ``randomUUID`` \メソッドを用いてランダムな文字列を生成する。
        * - | (8)
-         - | パスワード再発行用の認証情報を作成し、ユーザ名、トークン、秘密情報、有効期限を設定する。
+         - | 現在時刻に(3)の値を加えることにより、パスワード再発行用の認証情報の有効期限を計算する。
        * - | (9)
-         - | 秘密情報はハッシュ化を行ってから\ ``PasswordReissueInfo`` \に設定する。
+         - | パスワード再発行用の認証情報を作成し、ユーザ名、トークン、秘密情報、有効期限を設定する。
        * - | (10)
+         - | 秘密情報はハッシュ化を行ってから\ ``PasswordReissueInfo`` \に設定する。
+       * - | (11)
          - | パスワード再発行用の認証情報をデータベースに登録する。
+       * - | (12)
+         - | 生成した秘密情報を返す。
 
   * Formの実装
 
@@ -3065,9 +3255,12 @@ ER図
        // omitted
 
        @Data
-       public class CreateReissueInfoForm {
+       public class CreateReissueInfoForm implements Serializable {
+
+           private static final long serialVersionUID = 1L;
+       
            @NotEmpty
-           String username;
+           private String username;
        }
 
   * Viewの実装
@@ -3084,7 +3277,7 @@ ER図
                <t:messagesPanel />
                <form:form
                    action="${f:h(pageContext.request.contextPath)}/reissue/create"
-                   method="Post" modelAttribute="createReissueInfoForm">
+                   method="post" modelAttribute="createReissueInfoForm">
                    <table>
                        <tr>
                            <th><form:label path="username" cssErrorClass="error-label">Username</form:label>
@@ -3113,39 +3306,31 @@ ER図
        @RequestMapping("/reissue")
        public class PasswordReissueController {
 
-       	@Inject
-       	PasswordReissueService passwordReissueService;
-
-       	@RequestMapping(value = "create", params = "form")
-       	public String showCreateReissueInfoForm(CreateReissueInfoForm form) {
-       		return "passwordreissue/createReissueInfoForm";
-       	}
-
-       	@RequestMapping(value = "create", method = RequestMethod.POST)
-       	public String createReissueInfo(@Validated CreateReissueInfoForm form,
-       			BindingResult bindingResult, Model model,
-       			RedirectAttributes attributes) {
-       		if (bindingResult.hasErrors()) {
-       			return showCreateReissueInfoForm(form);
-       		}
-
-       		String rawSecret = passwordReissueService.createRawSecret(); // (1)
-
-       		try {
-       			passwordReissueService.saveAndSendReissueInfo(form.getUsername(),
-       					rawSecret); // (2)
-       			attributes.addFlashAttribute("secret", rawSecret);
-       			return "redirect:/reissue/create?complete";
-       		} catch (ResourceNotFoundException e) {
-       			model.addAttribute(e.getResultMessages());
-       			return showCreateReissueInfoForm(form);
-       		}
-       	}
-
-       	@RequestMapping(value = "create", params = "complete", method = RequestMethod.GET)
-       	public String createReissueInfoComplete() {
-       		return "passwordreissue/createReissueInfoComplete";
-       	}
+           @Inject
+           PasswordReissueService passwordReissueService;
+
+           @RequestMapping(value = "create", params = "form")
+           public String showCreateReissueInfoForm(CreateReissueInfoForm form) {
+               return "passwordreissue/createReissueInfoForm";
+           }
+
+           @RequestMapping(value = "create", method = RequestMethod.POST)
+           public String createReissueInfo(@Validated CreateReissueInfoForm form,
+                   BindingResult bindingResult, Model model,
+                   RedirectAttributes attributes) {
+               if (bindingResult.hasErrors()) {
+                   return showCreateReissueInfoForm(form);
+               }
+
+               String rawSecret = passwordReissueService.createAndSendReissueInfo(form.getUsername()); // (1)
+               attributes.addFlashAttribute("secret", rawSecret);
+               return "redirect:/reissue/create?complete";
+           }
+
+           @RequestMapping(value = "create", params = "complete", method = RequestMethod.GET)
+           public String createReissueInfoComplete() {
+               return "passwordreissue/createReissueInfoComplete";
+           }
 
            // omitted
 
@@ -3160,13 +3345,12 @@ ER図
        * - 項番
          - 説明
        * - | (1)
-         - | 秘密情報を生成する処理を呼び出す。
-       * - | (2)
-         - | Formから取得したユーザ名と生成した秘密情報をServiceのメソッドに渡す。パスワード再発行のための認証情報が生成され、データベースに登録される。
+         - | Formから取得したユーザ名から、パスワード再発行のための認証情報を生成し、データベースに登録する処理を呼び出す。
 
 * パスワード再発行のための認証情報の有効期限の検査
 
   パスワード再発行画面にアクセスされた際に、リクエストパラメータとしてURLに含まれるトークンからパスワード再発行のための認証情報を取得し、有効期限内であるかどうかを検査する処理の実装を以下に示す。
+  この処理中ではパスワード再発行の失敗上限を超過しているかどうかの検査も行うが、後述するため、ここでは省略する。
 
   * Serviceの実装
 
@@ -3180,6 +3364,9 @@ ER図
        @Transactional
        public class PasswordReissueServiceImpl implements PasswordReissueService {
 
+           @Inject
+           ClassicDateFactory dateFactory;
+
            @Inject
            PasswordReissueInfoRepository passwordReissueInfoRepository;
 
@@ -3187,23 +3374,21 @@ ER図
 
            @Override
            @Transactional(readOnly = true)
-           public PasswordReissueInfo findOne(String username, String token) {
+           public PasswordReissueInfo findOne(String token) {
                PasswordReissueInfo info = passwordReissueInfoRepository.findOne(token); // (1)
 
                if (info == null) {
                    throw new ResourceNotFoundException(ResultMessages.error().add(
                            MessageKeys.E_SL_PR_5002, token));
                }
-               if (!info.getUsername().equals(username)) {
-                   throw new BusinessException(ResultMessages.error().add(
-                           MessageKeys.E_SL_PR_5001));
-               }
 
-               if (info.getExpiryDate().isBefore(LocalDateTime.now())) { // (2)
+               if (dateFactory.newTimestamp().toLocalDateTime().isAfter(info.getExpiryDate())) { // (2)
                    throw new BusinessException(ResultMessages.error().add(
                            MessageKeys.E_SL_PR_2001));
                }
 
+               // omitted (attempts exceeded upper bounds)
+
                return info;
            }
 
@@ -3221,7 +3406,7 @@ ER図
        * - | (1)
          - | 引数として与えられたトークンをキーとして、パスワード再発行のための認証情報をデータベースから取得する。
        * - | (2)
-         - | データベースから取得した認証情報に含まれる有効期限が現在時刻よりも前である場合は、\ ``org.terasoluna.gfw.common.exception.BusinessException`` \をthrowする。
+         - | 有効期限が切れている場合は、\ ``org.terasoluna.gfw.common.exception.BusinessException`` \をthrowする。
 
   * Controllerの実装
 
@@ -3240,14 +3425,12 @@ ER図
 
            // omitted
 
-           @RequestMapping(value = "resetpassword", params = "form")
            public String showPasswordResetForm(PasswordResetForm form, Model model,
-                   @RequestParam("username") String username, // (1)
-                   @RequestParam("token") String token) {  // (2)
+                   @RequestParam("token") String token) { // (1)
 
-               passwordReissueService.findOne(username, token); // (3)
+               PasswordReissueInfo info = passwordReissueService.findOne(token); // (3)
 
-               form.setUsername(username);
+               form.setUsername(info.getUsername());
                form.setToken(token);
                model.addAttribute("passwordResetForm", form);
                return "passwordreissue/passwordResetForm";
@@ -3265,15 +3448,14 @@ ER図
        * - 項番
          - 説明
        * - | (1)
-         - | パスワード再発行画面のURLにリクエストパラメータとして含まれるユーザ名を取得する。
-       * - | (2)
          - | パスワード再発行画面のURLにリクエストパラメータとして含まれるトークンを取得する。
-       * - | (3)
-         - | Serviceのメソッドにユーザ名とトークンを渡して呼び出す。データベースから認証情報が取得され、有効期限が検査される。
+       * - | (2)
+         - | Serviceのメソッドにトークンを渡して呼び出す。データベースから認証情報が取得され、有効期限が検査される。
 
 * パスワード再発行のための認証情報を用いたユーザの確認
 
   パスワード再発行画面においてユーザが入力した秘密情報と、パスワード再発行画面のURLに含まれるユーザ名、トークンの組が正しいかどうかを確認する処理の実装を以下に示す。
+  この確認処理はパスワード再発行固有のロジックであり、かつ文脈に依存したチェックであることから、Bean ValidationやSpring Validatorを用いず、Serviceに実装している。
 
   * Serviceの実装
 
@@ -3315,6 +3497,9 @@ ER図
        @Transactional
        public class PasswordReissueServiceImpl implements PasswordReissueService {
 
+           @Inject
+           PasswordReissueFailureSharedService passwordReissueFailureSharedService;
+
            @Inject
            PasswordReissueInfoRepository passwordReissueInfoRepository;
 
@@ -3329,17 +3514,14 @@ ER図
            @Override
            public boolean resetPassword(String username, String token, String secret,
                    String rawPassword) {
-               PasswordReissueInfo info = this.findOne(username, token); // (1)
+               PasswordReissueInfo info = this.findOne(token); // (1)
                if (!passwordEncoder.matches(secret, info.getSecret())) { // (2)
-
-                   // omitted
-
+                   passwordReissueFailureSharedService.resetFailure(username, token);
                    throw new BusinessException(ResultMessages.error().add(
                        MessageKeys.E_SL_PR_5003));
                }
                passwordReissueInfoRepository.delete(token); // (3)
-
-               //omitted
+               failedPasswordReissueRepository.deleteByToken(token);
 
                return accountSharedService.updatePassword(username, rawPassword); // (4)
 
@@ -3357,7 +3539,7 @@ ER図
        * - 項番
          - 説明
        * - | (1)
-         - | 引数として与えられたユーザ名とトークンを用いて、データベースからパスワード再発行用の認証情報を取得する。このとき、有効期限が改めて検査される。
+         - | 引数として与えられたトークンを用いて、データベースからパスワード再発行用の認証情報を取得する。このとき、有効期限が改めて検査される。
        * - | (2)
          - | パスワード再発行用の認証情報に含まれるハッシュ化された秘密情報と、引数として与えられた秘密情報を比較する。異なる場合には\ ``BusinessException`` \をthrowする。この場合、パスワードの再発行は失敗となる。
        * - | (3)
@@ -3375,9 +3557,11 @@ ER図
 
        @Data
        @Compare(source = "newPasssword", destination = "confirmNewPassword", operator = Compare.Operator.EQUAL)
-       @StrongPassword(idPropertyName = "username", newPasswordPropertyName = "newPassword") // (1)
-       @NotReused(idPropertyName = "username", newPasswordPropertyName = "newPassword") // (2)
-       public class PasswordResetForm {
+       @StrongPassword(usernamePropertyName = "username", newPasswordPropertyName = "newPassword") // (1)
+       @NotReusedPassword(usernamePropertyName = "username", newPasswordPropertyName = "newPassword") // (2)
+       public class PasswordResetForm implements Serializable{
+
+           private static final long serialVersionUID = 1L;
 
            private String username;
 
@@ -3419,7 +3603,7 @@ ER図
                        <tr>
                            <th><form:label path="username">Username</form:label></th>
                            <td>${f:h(passwordResetForm.username)} <form:hidden
-                                   path="username" value="${f:h(passwordResetorm.username)}" />  <!-- (1) -->
+                                   path="username" value="${f:h(passwordResetForm.username)}" />  <!-- (1) -->
                            </td>
                            <td></td>
                        </tr>
@@ -3550,7 +3734,7 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 | :ref:`パスワード再発行のための認証情報の生成 <reissue-info-create>` で生成した認証情報を二つに分け、それぞれ別の方法でユーザに配布する。
 | 以下の二つの処理を実装して用いることで要件を実現する。
@@ -3567,7 +3751,7 @@ ER図
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
 
-上記の実装方針に従って実装されたコードについて順に解説する。
+上記の実装方法に従って実装されたコードについて順に解説する。
 
 * 秘密情報の画面表示
 
@@ -3596,17 +3780,9 @@ ER図
                  return showCreateReissueInfoForm(form);
              }
 
-             String rawSecret = passwordReissueService.createRawSecret(); // (1)
-
-             try {
-                 passwordReissueService.saveAndSendReissueInfo(form.getUsername(),
-                         rawSecret);
-                 attributes.addFlashAttribute("secret", rawSecret); // (2)
-                 return "redirect:/reissue/create?complete"; // (3)
-             } catch (ResourceNotFoundException e) {
-                 model.addAttribute(e.getResultMessages());
-                 return showCreateReissueInfoForm(form);
-             }
+             String rawSecret = passwordReissueService.createAndSendReissueInfo(form.getUsername()); // (1)
+             attributes.addFlashAttribute("secret", rawSecret); // (2)
+             return "redirect:/reissue/create?complete"; // (3)
          }
 
          @RequestMapping(value = "create", params = "complete", method = RequestMethod.GET)
@@ -3663,7 +3839,7 @@ ER図
 * パスワード再発行画面のURLのメール送付
 
   パスワード再発行用の認証情報からパスワード再発行画面のURLを作成し、メール送付する処理の実装を以下に示す。
-  依存ライブラリの追加方法やメールセッションの取得方法等の詳細については、:doc:`../ArchitectureInDetail/Email`を参照。
+  依存ライブラリの追加方法やメールセッションの取得方法等の詳細については、:doc:`../ArchitectureInDetail/Email` を参照。
 
   .. code-block:: java
 
@@ -3672,7 +3848,7 @@ ER図
      // omitted
 
      @Service
-     public class MailSharedServiceImpl implements MailSharedService {
+     public class PasswordReissueMailSharedServiceImpl implements PasswordReissueMailSharedService {
 
          @Inject
          JavaMailSender mailSender; // (1)
@@ -3717,7 +3893,10 @@ ER図
      public class PasswordReissueServiceImpl implements PasswordReissueService {
 
          @Inject
-         MailSharedService mailSharedService;
+         ClassicDateFactory dateFactory;
+
+         @Inject
+         PasswordReissueMailSharedService mailSharedService;
 
          @Inject
          AccountSharedService accountSharedService;
@@ -3725,8 +3904,8 @@ ER図
          @Inject
          PasswordEncoder passwordEncoder;
 
-         @Value("${security.tokenLifeTime}")
-         int tokenLifeTime;
+         @Value("${security.tokenLifeTimeSeconds}")
+         int tokenLifeTimeSeconds;
 
          @Value("${app.hostAndPort}") // (1)
          String hostAndPort;
@@ -3740,33 +3919,37 @@ ER図
          // omitted
 
          @Override
-         public boolean saveAndSendReissueInfo(String username, String rowSecret) {
-             Account account = accountSharedService.findOne(username);
-             
+         public String createAndSendReissueInfo(String username) {
+            
+             String rowSecret = passwordGenerator.generatePassword(10, passwordGenerationRules);
+
+             if(!accountSharedService.exists(username)){
+                 return rowSecret;           
+             }
+            
+             Account account= accountSharedService.findOne(username);
+            
              String token = UUID.randomUUID().toString();
 
-             LocalDateTime expiryDate = LocalDateTime.now().plusSeconds(
-                     tokenLifeTime);
+             LocalDateTime expiryDate = dateFactory.newTimestamp().toLocalDateTime()
+                     .plusSeconds(tokenLifeTimeSeconds);
 
              PasswordReissueInfo info = new PasswordReissueInfo();
              info.setUsername(username);
              info.setToken(token);
              info.setSecret(passwordEncoder.encode(rowSecret));
              info.setExpiryDate(expiryDate);
-             
-             int count = passwordReissueInfoRepository.insert(info);
 
-             if (count > 0) {
-                 String passwordResetUrl = protocol + "://" + hostAndPort
-                         + contextPath + "/reissue/resetpassword/?form&username="
-                         + info.getUsername() + "&token=" + info.getToken(); // (2)
+             passwordReissueInfoRepository.create(info);
 
-                 mailSharedService.send(account.getEmail(), passwordResetUrl); // (3)
+             String passwordResetUrl = protocol + "://" + hostAndPort
+                     + contextPath + "/reissue/resetpassword/?form&token="
+                     + info.getToken(); // (2)
+
+             mailSharedService.send(account.getEmail(), passwordResetUrl); // (3)
+
+             return rowSecret;
 
-                 return true;
-             } else {
-                 return false;
-             }
          }
 
          // omitted
@@ -3783,7 +3966,7 @@ ER図
      * - | (1)
        - | パスワード再発行画面のURLに使用するプロトコル、ホスト名、ポート番号、コンテキストパスをプロパティファイルから取得する。
      * - | (2)
-       - | (1)で取得した値と、生成したパスワード再発行用の認証情報に含まれるユーザ名、トークンを使用して、ユーザに配布するパスワード再発行画面のURLを作成する。
+       - | (1)で取得した値と、生成したパスワード再発行用の認証情報に含まれるトークンを使用して、ユーザに配布するパスワード再発行画面のURLを作成する。
      * - | (3)
        - | ユーザの登録メールアドレス宛てに、パスワード再発行画面のURLを本文に記したメールを送付する。
 
@@ -3803,25 +3986,24 @@ ER図
    :width: 80%
    :align: center
 
-実装方針
+実装方法
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
-| 本実装例では、パスワード再発行に失敗した履歴を「パスワード再発行失敗イベント」エンティティとしてデータベースに保存し、このパスワード再発行失敗イベントエンティティを用いて、パスワード再発行の失敗回数をカウントする。
-| 失敗回数があらかじめ設定した上限に達した時点で、パスワード再発行用の認証情報をデータベースから削除し、無効化する。
+| 本アプリケーションでは、パスワード再発行に失敗した履歴を「パスワード再発行失敗イベント」エンティティとしてデータベースに保存し、このパスワード再発行失敗イベントエンティティを用いて、パスワード再発行の失敗回数をカウントする。
+| 失敗回数があらかじめ設定した上限値以上であれば、パスワード再発行時に例外をスローする。
 | 具体的には、以下の二つの処理を実装して用いることにより、要件を実現する。
 
 * パスワード再発行失敗イベントエンティティの保存
 
   :ref:`パスワード再発行のための認証情報の生成 <reissue-info-create>` における、「パスワード再発行のための認証情報を用いたユーザの確認」処理の中で、ユーザの確認に失敗した場合に、使用したトークンと失敗日時の組をパスワード再発行失敗イベントエンティティとしてデータベースに登録する。
 
-* パスワード再発行用の認証情報の削除
+* パスワード再発行時の例外のスロー
 
-  上記「パスワード再発行失敗イベントエンティティの保存」処理の直後に、同じトークンを持つパスワード再発行失敗イベントエンティティをデータベースから検索して取得する。
-  取得した個数があらかじめ設定しておいた失敗回数の上限以上であれば、同じトークンを持つパスワード再発行用の認証情報をデータベースから削除する。
+  パスワード再発行のために認証情報をデータベースから取得した際に、パスワード再発行失敗イベントエンティティの数をカウントし、上限値以上であれば例外をスローする。
 
 .. warning ::
 
-   | パスワード再発行失敗イベントエンティティはパスワード再発行の失敗回数のカウントのみを目的としているため、不要になったタイミングで消去される。
-   | パスワード再発行の失敗時のログが必要な場合は必ず別途ログを保存しておくこと。
+   パスワード再発行失敗イベントエンティティはパスワード再発行の失敗回数のカウントのみを目的としているため、不要になったタイミングで消去する。
+   パスワード再発行の失敗時のログが必要な場合は必ず別途ログを保存しておくこと。
 
 コード解説
 """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
@@ -3876,7 +4058,7 @@ ER図
 
            int countByToken(@Param("token") String token); // (1)
 
-           int insert(FailedPasswordReissue event); // (2)
+           int create(FailedPasswordReissue event); // (2)
 
            int deleteByToken(@Param("token") String token); // (3)
 
@@ -3920,7 +4102,7 @@ ER図
            ]]>
        	</select>
 
-       	<insert id="insert" parameterType="FailedPasswordReissue">
+        <insert id="create" parameterType="FailedPasswordReissue">
            <![CDATA[
                INSERT INTO failed_password_reissue (
                    token,
@@ -3941,26 +4123,9 @@ ER図
            ]]>
        	</delete>
 
-       	<delete id="deleteExpired">
-           <![CDATA[
-           	DELETE FROM
-           		failed_password_reissue
-           	WHERE
-           		token = 
-           		(SELECT
-           			token
-           		 FROM
-           		 	password_reissue_info
-           		 WHERE
-           		 	token = failed_password_reissue.token 
-           		 AND
-           			expiry_date < #{date}
-           		)
-           ]]>
-       	</delete>
        </mapper>
 
-以下、実装方針に従って実装されたコードについて順に解説する。
+以下、実装方法に従って実装されたコードについて順に解説する。
 
 * パスワード再発行失敗イベントエンティティの保存
 
@@ -3987,6 +4152,9 @@ ER図
      public class PasswordReissueFailureSharedServiceImpl implements
              PasswordReissueFailureSharedService {
 
+         @Inject
+         ClassicDateFactory dateFactory;
+
          @Inject
          FailedPasswordReissueRepository failedPasswordReissueRepository;
 
@@ -3997,11 +4165,8 @@ ER図
          public void resetFailure(String username, String token) {
              FailedPasswordReissue event = new FailedPasswordReissue(); // (2)
              event.setToken(token);
-             event.setAttemptDate(LocalDateTime.now());
-             failedPasswordReissueRepository.insert(event); // (3)
-
-             // omitted
-
+             event.setAttemptDate(dateFactory.newTimestamp().toLocalDateTime());
+             failedPasswordReissueRepository.create(event); // (3)
          }
 
      }
@@ -4014,7 +4179,8 @@ ER図
      * - 項番
        - 説明
      * - | (1)
-       - | 呼び出し元のServiceとは別にトランザクション管理を行うために、伝搬方法を「REQUIRES_NEW」に指定する。
+       - | パスワード再発行に失敗した際に呼び出されるメソッドであり、呼び出し元で実行時例外がスローされる。
+         | そのため、呼び出し元のServiceとは別にトランザクション管理を行うために、伝搬方法を「REQUIRES_NEW」に指定する。
      * - | (2)
        - | パスワード再発行失敗イベントエンティティを作成し、トークンと失敗日時を設定する。
      * - | (3)
@@ -4049,7 +4215,7 @@ ER図
          @Override
          public boolean resetPassword(String username, String token, String secret,
                  String rawPassword) {
-             PasswordReissueInfo info = this.findOne(username, token); // (1)
+             PasswordReissueInfo info = this.findOne(token); // (1)
              if (!passwordEncoder.matches(secret, info.getSecret())) { // (2)
                  passwordReissueFailureSharedService.resetFailure(username, token); // (3)
                  throw new BusinessException(ResultMessages.error().add(  // (4)
@@ -4072,7 +4238,7 @@ ER図
      * - 項番
        - 説明
      * - | (1)
-       - | 引数として与えられたユーザ名とトークンを用いて、データベースからパスワード再発行用の認証情報を取得する。
+       - | 引数として与えられたトークンを用いて、データベースからパスワード再発行用の認証情報を取得する。
      * - | (2)
        - | パスワード再発行用の認証情報に含まれるハッシュ化された秘密情報と、引数として与えられた秘密情報を比較する。
      * - | (3)
@@ -4080,7 +4246,7 @@ ER図
      * - | (4)
        - | 実行時例外をthrowするが、パスワード再発行失敗時の処理は別のトランザクションで実行されるため、影響を与えることはない。
 
-* パスワード再発行用の認証情報の削除
+* パスワード再発行時の例外のスロー
 
   パスワード再発行の失敗回数の取得と、失敗回数が上限に達した際の処理の実装を以下に示す。
 
@@ -4092,8 +4258,7 @@ ER図
 
      @Service
      @Transactional
-     public class PasswordReissueFailureSharedServiceImpl implements
-             PasswordReissueFailureSharedService {
+     public class PasswordReissueServiceImpl implements PasswordReissueService {
 
          @Inject
          FailedPasswordReissueRepository failedPasswordReissueRepository;
@@ -4104,20 +4269,26 @@ ER図
          @Value("${security.tokenValidityThreshold}")
          int tokenValidityThreshold; // (1)
 
-         @Transactional(propagation = Propagation.REQUIRES_NEW)
+         // omitted
+
          @Override
-         public void resetFailure(String username, String token) {
+         @Transactional(readOnly = true)
+         public PasswordReissueInfo findOne(String token) {
 
              // omitted
-
+              
              int count = failedPasswordReissueRepository // (2)
                      .countByToken(token);
              if (count >= tokenValidityThreshold) { // (3)
-                 passwordReissueInfoRepository.delete(token); // (4)
-                 failedPasswordReissueRepository.deleteByToken(token); // (5)
+                 throw new BusinessException(ResultMessages.error().add(
+                         MessageKeys.E_SL_PR_5001));
              }
+
+             return info;
          }
 
+         // omitted
+
      }
 
   .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
@@ -4132,17 +4303,13 @@ ER図
      * - | (2)
        - | 引数として与えられたトークンをキーとして、データベースからパスワード再発行失敗イベントエンティティの数を取得。
      * - | (3)
-       - | 取得したパスワード再発行の失敗イベントエンティティの数と失敗回数の上限値を比較する。
-     * - | (4)
-       - | 引数として与えられたトークンをキーとして、パスワード再発行のための認証情報を削除する。
-     * - | (5)
-       - | パスワード再発行のための認証情報が削除されることで、削除された認証情報と同じトークンを持つパスワード再発行失敗イベントエンティティは不要となるため、削除する。
+       - | 取得したパスワード再発行の失敗イベントエンティティの数と失敗回数の上限値を比較し、上限値以上ならば例外をスローする。
 
 おわりに
 ================================================================================
 
 | 本章では、サンプルアプリケーションを題材としてセキュリティ対策の実装方法の例を説明した。
-| 実際の開発においては、本実装例における実装方針をそのまま利用できないケースも考えられるため、本章の内容を参考にしつつ要件に合わせてカスタマイズしたり別の方針を考えるようにしてほしい。
+| 実際の開発においては、本アプリケーションにおける実装方法をそのまま利用できないケースも考えられるため、本章の内容を参考にしつつ要件に合わせてカスタマイズしたり別の方法を考えるようにしてほしい。
 
 Appendix
 ================================================================================
@@ -4264,7 +4431,7 @@ How to use
    <!-- Password Validator. -->
    <bean id="characterPasswordValidator" class="org.passay.PasswordValidator"> <!-- (6) -->
        <constructor-arg name="rules">
-           <list value-type="org.passay.Rule">
+           <list>
                <ref bean="upperCaseRule" />
                <ref bean="lowerCaseRule" />
                <ref bean="digitRule" />
@@ -4369,16 +4536,11 @@ How to use
 
     <!-- Password Generator. -->
     <bean id="passwordGenerator" class="org.passay.PasswordGenerator" /> <!-- (6) -->
-    <bean id="passwordGenerationRules"
-        class="org.springframework.beans.factory.config.ListFactoryBean">
-        <property name="sourceList">
-            <list value-type="org.passay.CharacterRule"> <!-- (7) -->
-                <ref bean="upperCaseRule" />
-                <ref bean="lowerCaseRule" />
-                <ref bean="digitRule" />
-            </list>
-        </property>
-    </bean>
+    <util:list id="passwordGenerationRules"> <!-- (7) -->
+        <ref bean="upperCaseRule" />
+        <ref bean="lowerCaseRule" />
+        <ref bean="digitRule" />
+    </util:list>
 
 .. tabularcolumns:: |p{0.10\linewidth}|p{0.90\linewidth}|
 .. list-table::
@@ -4409,7 +4571,8 @@ How to use
    @Inject
    PasswordGenerator passwordGenerator;
 
-   @Resource(name = "passwordGenerationRules")
+   @Inject
+   @Named("passwordGenerationRules")
    List<CharacterRule> passwordGenerationRules;
 
    // omitted
diff --git a/source/Security/images/SecureLogin_ER.png b/source/Security/images/SecureLogin_ER.png
index bfb103d348..10a1ecda3d 100755
Binary files a/source/Security/images/SecureLogin_ER.png and b/source/Security/images/SecureLogin_ER.png differ
diff --git a/source/Security/images_SecureLoginDemo/graph.asta b/source/Security/images_SecureLoginDemo/graph.asta
index 412ad7a0d0..5ada7579cc 100755
Binary files a/source/Security/images_SecureLoginDemo/graph.asta and b/source/Security/images_SecureLoginDemo/graph.asta differ
