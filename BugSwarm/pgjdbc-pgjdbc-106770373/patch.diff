diff --git a/pgjdbc/src/main/java/org/postgresql/core/PGStream.java b/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
index 4e0326da6..33bd3cde1 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
@@ -72,6 +72,7 @@ public PGStream(SocketFactory socketFactory, HostSpec hostSpec, int timeout) thr
   /**
    * Constructor: Connect to the PostgreSQL back end and return a stream connection.
    *
+   * @param socketFactory socket factory
    * @param hostSpec the host and port to connect to
    * @throws IOException if an IOException occurs below it.
    * @deprecated use {@link #PGStream(SocketFactory, org.postgresql.util.HostSpec, int)}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
index 37fe790e2..d47a436cd 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
@@ -10,6 +10,7 @@
 package org.postgresql.core;
 
 import org.postgresql.copy.CopyOperation;
+import org.postgresql.jdbc.BatchResultHandler;
 
 import java.sql.SQLException;
 
@@ -24,7 +25,7 @@
  * {@link #createParameterizedQuery})
  * <li>execution methods for created Query objects (
  * {@link #execute(Query, ParameterList, ResultHandler, int, int, int)} for single queries and
- * {@link #execute(Query[], ParameterList[], ResultHandler, int, int, int)} for batches of queries)
+ * {@link #execute(Query[], ParameterList[], BatchResultHandler, int, int, int)} for batches of queries)
  * <li>a fastpath call interface ({@link #createFastpathParameters} and {@link #fastpathCall}).
  * </ul>
  *
@@ -142,7 +143,7 @@ void execute(Query query, ParameterList parameters, ResultHandler handler, int m
    * @param flags a combination of QUERY_* flags indicating how to handle the query.
    * @throws SQLException if query execution fails
    */
-  void execute(Query[] queries, ParameterList[] parameterLists, ResultHandler handler, int maxRows,
+  void execute(Query[] queries, ParameterList[] parameterLists, BatchResultHandler handler, int maxRows,
       int fetchSize, int flags) throws SQLException;
 
   /**
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
index 87f356914..040dedc9c 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
@@ -20,6 +20,7 @@
 import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ResultCursor;
 import org.postgresql.core.ResultHandler;
+import org.postgresql.jdbc.BatchResultHandler;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -271,9 +272,9 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
 
   // Nothing special yet, just run the queries one at a time.
   public synchronized void execute(Query[] queries, ParameterList[] parameters,
-      ResultHandler handler, int maxRows, int fetchSize, int flags) throws SQLException {
-    final ResultHandler delegateHandler = handler;
-    handler = new ResultHandler() {
+      BatchResultHandler batchHandler, int maxRows, int fetchSize, int flags) throws SQLException {
+    final ResultHandler delegateHandler = batchHandler;
+    ResultHandler handler = new ResultHandler() {
       public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
           ResultCursor cursor) {
         delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
@@ -297,6 +298,7 @@ public void handleCompletion() throws SQLException {
 
     for (int i = 0; i < queries.length; ++i) {
       execute((V2Query) queries[i], (SimpleParameterList) parameters[i], handler, maxRows, flags);
+      batchHandler.secureProgress();
     }
 
     delegateHandler.handleCompletion();
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
index 38c0dcf8e..d3795fdc0 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
@@ -25,6 +25,7 @@
 import org.postgresql.core.ResultCursor;
 import org.postgresql.core.ResultHandler;
 import org.postgresql.core.Utils;
+import org.postgresql.jdbc.BatchResultHandler;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -194,7 +195,7 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
         handler = sendQueryPreamble(handler, flags);
         ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
         sendQuery((V3Query) query, (V3ParameterList) parameters, maxRows, fetchSize, flags,
-            trackingHandler);
+            trackingHandler, null);
         sendSync();
         processResults(handler, flags);
         estimatedReceiveBufferBytes = 0;
@@ -317,10 +318,10 @@ boolean hasErrors() {
   }
 
   public synchronized void execute(Query[] queries, ParameterList[] parameterLists,
-      ResultHandler handler, int maxRows, int fetchSize, int flags) throws SQLException {
+      BatchResultHandler batchHandler, int maxRows, int fetchSize, int flags) throws SQLException {
     waitOnLock();
     if (logger.logDebug()) {
-      logger.debug("batch execute " + queries.length + " queries, handler=" + handler + ", maxRows="
+      logger.debug("batch execute " + queries.length + " queries, handler=" + batchHandler + ", maxRows="
           + maxRows + ", fetchSize=" + fetchSize + ", flags=" + flags);
     }
 
@@ -334,8 +335,9 @@ public synchronized void execute(Query[] queries, ParameterList[] parameterLists
       }
     }
 
+    ResultHandler handler = batchHandler;
     try {
-      handler = sendQueryPreamble(handler, flags);
+      handler = sendQueryPreamble(batchHandler, flags);
       ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
       estimatedReceiveBufferBytes = 0;
 
@@ -346,7 +348,7 @@ public synchronized void execute(Query[] queries, ParameterList[] parameterLists
           parameters = SimpleQuery.NO_PARAMETERS;
         }
 
-        sendQuery(query, parameters, maxRows, fetchSize, flags, trackingHandler);
+        sendQuery(query, parameters, maxRows, fetchSize, flags, trackingHandler, batchHandler);
 
         if (trackingHandler.hasErrors()) {
           break;
@@ -1146,7 +1148,9 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
    * See the comments above MAX_BUFFERED_RECV_BYTES's declaration for details.
    */
   private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
-      ErrorTrackingResultHandler trackingHandler, final int flags) throws IOException {
+      ErrorTrackingResultHandler trackingHandler,
+      BatchResultHandler batchHandler,
+      final int flags) throws IOException {
     // Assume all statements need at least this much reply buffer space,
     // plus params
     estimatedReceiveBufferBytes += NODATA_QUERY_RESPONSE_SIZE_BYTES;
@@ -1182,6 +1186,9 @@ private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
       sendSync();
       processResults(trackingHandler, flags);
       estimatedReceiveBufferBytes = 0;
+      if (batchHandler != null) {
+        batchHandler.secureProgress();
+      }
     }
 
   }
@@ -1190,7 +1197,8 @@ private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
    * Send a query to the backend.
    */
   private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, int fetchSize,
-      int flags, ErrorTrackingResultHandler trackingHandler) throws IOException, SQLException {
+      int flags, ErrorTrackingResultHandler trackingHandler,
+      BatchResultHandler batchHandler) throws IOException, SQLException {
     // Now the query itself.
     SimpleQuery[] subqueries = query.getSubqueries();
     SimpleParameterList[] subparams = parameters.getSubparams();
@@ -1201,7 +1209,7 @@ private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, i
     boolean disallowBatching = (flags & QueryExecutor.QUERY_DISALLOW_BATCHING) != 0;
 
     if (subqueries == null) {
-      flushIfDeadlockRisk(query, disallowBatching, trackingHandler, flags);
+      flushIfDeadlockRisk(query, disallowBatching, trackingHandler, batchHandler, flags);
 
       // If we saw errors, don't send anything more.
       if (!trackingHandler.hasErrors()) {
@@ -1211,7 +1219,7 @@ private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, i
     } else {
       for (int i = 0; i < subqueries.length; ++i) {
         final SimpleQuery subquery = subqueries[i];
-        flushIfDeadlockRisk(subquery, disallowBatching, trackingHandler, flags);
+        flushIfDeadlockRisk(subquery, disallowBatching, trackingHandler, batchHandler, flags);
 
         // If we saw errors, don't send anything more.
         if (trackingHandler.hasErrors()) {
diff --git a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
index c2be4bcda..ba3148787 100644
--- a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
+++ b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
@@ -954,6 +954,7 @@ public void setAllowEncodingChanges(boolean allow) {
   }
 
   /**
+   * @return socket factory class name
    * @see PGProperty#SOCKET_FACTORY
    */
   public String getSocketFactory() {
@@ -961,6 +962,7 @@ public String getSocketFactory() {
   }
 
   /**
+   * @param socketFactoryClassName socket factory class name
    * @see PGProperty#SOCKET_FACTORY
    */
   public void setSocketFactory(String socketFactoryClassName) {
@@ -968,6 +970,7 @@ public void setSocketFactory(String socketFactoryClassName) {
   }
 
   /**
+   * @return socket factory argument
    * @see PGProperty#SOCKET_FACTORY_ARG
    */
   public String getSocketFactoryArg() {
@@ -975,6 +978,7 @@ public String getSocketFactoryArg() {
   }
 
   /**
+   * @param socketFactoryArg socket factory argument
    * @see PGProperty#SOCKET_FACTORY_ARG
    */
   public void setSocketFactoryArg(String socketFactoryArg) {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
index 7aecc23ae..e7c1bbf6c 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
@@ -13,9 +13,15 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-class BatchResultHandler implements ResultHandler {
+/**
+ * Internal class, it is not a part of public API.
+ */
+public class BatchResultHandler implements ResultHandler {
   private PgStatement pgStatement;
   private BatchUpdateException batchException = null;
   private int resultIndex = 0;
@@ -24,7 +30,11 @@
   private final ParameterList[] parameterLists;
   private final int[] updateCounts;
   private final boolean expectGeneratedKeys;
-  private ResultSet generatedKeys;
+  private PgResultSet generatedKeys;
+  private int committedRows; // 0 means no rows committed. 1 means row 0 was committed, and so on
+  private List<List<byte[][]>> allGeneratedRows;
+  private List<byte[][]> latestGeneratedRows;
+  private PgResultSet latestGeneratedKeysRs;
 
   BatchResultHandler(PgStatement pgStatement, Query[] queries, ParameterList[] parameterLists,
       int[] updateCounts, boolean expectGeneratedKeys) {
@@ -33,50 +43,86 @@
     this.parameterLists = parameterLists;
     this.updateCounts = updateCounts;
     this.expectGeneratedKeys = expectGeneratedKeys;
+    this.allGeneratedRows = !expectGeneratedKeys ? null : new ArrayList<List<byte[][]>>();
   }
 
   public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
       ResultCursor cursor) {
+    // If SELECT, then handleCommandStatus call would just be missing
+    resultIndex++;
     if (!expectGeneratedKeys) {
-      handleError(new PSQLException(GT.tr("A result was returned when none was expected."),
-          PSQLState.TOO_MANY_RESULTS));
-    } else {
-      if (generatedKeys == null) {
-        try {
-          generatedKeys = pgStatement.createResultSet(fromQuery, fields, tuples, cursor);
-        } catch (SQLException e) {
-          handleError(e);
-
-        }
-      } else {
-        ((PgResultSet) generatedKeys).addRows(tuples);
+      // No rows expected -> just ignore rows
+      return;
+    }
+    if (generatedKeys == null) {
+      try {
+        // If SELECT, the resulting ResultSet is not valid
+        // Thus it is up to handleCommandStatus to decide if resultSet is good enough
+        latestGeneratedKeysRs =
+            (PgResultSet) pgStatement.createResultSet(fromQuery, fields,
+                new ArrayList<byte[][]>(), cursor);
+      } catch (SQLException e) {
+        handleError(e);
       }
     }
+    latestGeneratedRows = tuples;
   }
 
   public void handleCommandStatus(String status, int updateCount, long insertOID) {
+    if (latestGeneratedRows != null) {
+      // We have DML. Decrease resultIndex that was just increased in handleResultRows
+      resultIndex--;
+      // If exception thrown, no need to collect generated keys
+      // Note: some generated keys might be secured in generatedKeys
+      if (updateCount > 0 && batchException == null) {
+        allGeneratedRows.add(latestGeneratedRows);
+        if (generatedKeys == null) {
+          generatedKeys = latestGeneratedKeysRs;
+        }
+      }
+      latestGeneratedRows = null;
+    }
+
     if (resultIndex >= updateCounts.length) {
       handleError(new PSQLException(GT.tr("Too many update results were returned."),
           PSQLState.TOO_MANY_RESULTS));
       return;
     }
+    latestGeneratedKeysRs = null;
 
     updateCounts[resultIndex++] = updateCount;
   }
 
+  public void secureProgress() {
+    try {
+      if (batchException == null && pgStatement.getConnection().getAutoCommit()) {
+        committedRows = resultIndex;
+        updateGeneratedKeys();
+      }
+    } catch (SQLException e) {
+        /* Should not get here */
+    }
+  }
+
+  private void updateGeneratedKeys() {
+    if (allGeneratedRows == null || allGeneratedRows.isEmpty()) {
+      return;
+    }
+    for (List<byte[][]> rows : allGeneratedRows) {
+      generatedKeys.addRows(rows);
+    }
+    allGeneratedRows.clear();
+  }
+
   public void handleWarning(SQLWarning warning) {
     pgStatement.addWarning(warning);
   }
 
   public void handleError(SQLException newError) {
     if (batchException == null) {
-      int[] successCounts;
-
-      if (resultIndex >= updateCounts.length) {
-        successCounts = updateCounts;
-      } else {
-        successCounts = new int[resultIndex];
-        System.arraycopy(updateCounts, 0, successCounts, 0, resultIndex);
+      Arrays.fill(updateCounts, committedRows, updateCounts.length, Statement.EXECUTE_FAILED);
+      if (allGeneratedRows != null) {
+        allGeneratedRows.clear();
       }
 
       String queryString = "<unknown>";
@@ -87,7 +133,7 @@ public void handleError(SQLException newError) {
       batchException = new BatchUpdateException(
           GT.tr("Batch entry {0} {1} was aborted.  Call getNextException to see the cause.",
               new Object[]{resultIndex, queryString}),
-          newError.getSQLState(), successCounts);
+          newError.getSQLState(), updateCounts);
     }
 
     batchException.setNextException(newError);
@@ -97,6 +143,7 @@ public void handleCompletion() throws SQLException {
     if (batchException != null) {
       throw batchException;
     }
+    updateGeneratedKeys();
   }
 
   public ResultSet getGeneratedKeys() {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
index be666024b..72848e3f5 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
@@ -11,7 +11,6 @@
 import org.postgresql.Driver;
 import org.postgresql.core.ParameterList;
 import org.postgresql.core.Query;
-import org.postgresql.core.ResultHandler;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -435,7 +434,7 @@ private void checkIndex(int parameterIndex, boolean fetchingData) throws SQLExce
   }
 
   @Override
-  protected ResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
+  protected BatchResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
       ParameterList[] parameterLists) {
     return new CallableBatchResultHandler(this, queries, parameterLists, updateCounts);
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
index 787ea0df8..ee1a36a38 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
@@ -897,7 +897,7 @@ public void clearBatch() throws SQLException {
     }
   }
 
-  protected ResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
+  protected BatchResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
       ParameterList[] parameterLists) {
     return new BatchResultHandler(this, queries, parameterLists, updateCounts,
         wantsGeneratedKeysAlways);
@@ -967,13 +967,23 @@ protected ResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
       flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
     }
 
+    BatchResultHandler handler;
+    handler = createBatchHandler(updateCounts, queries, parameterLists);
+
     if (preDescribe || forceBinaryTransfers) {
       // Do a client-server round trip, parsing and describing the query so we
       // can determine its result types for use in binary parameters, batch sizing,
       // etc.
       int flags2 = flags | QueryExecutor.QUERY_DESCRIBE_ONLY;
       StatementResultHandler handler2 = new StatementResultHandler();
-      connection.getQueryExecutor().execute(queries[0], parameterLists[0], handler2, 0, 0, flags2);
+      try {
+        connection.getQueryExecutor().execute(queries[0], parameterLists[0], handler2, 0, 0, flags2);
+      } catch (SQLException e) {
+        // Unable to parse the first statement -> throw BatchUpdateException
+        handler.handleError(e);
+        handler.handleCompletion();
+        // Will not reach here (see above)
+      }
       ResultWrapper result2 = handler2.getResults();
       if (result2 != null) {
         result2.getResultSet().close();
@@ -982,19 +992,16 @@ protected ResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
 
     result = null;
 
-    ResultHandler handler;
-    handler = createBatchHandler(updateCounts, queries, parameterLists);
-
     try {
       startTimer();
       connection.getQueryExecutor().execute(queries, parameterLists, handler, maxrows, fetchSize,
           flags);
     } finally {
       killTimerTask();
-    }
-
-    if (wantsGeneratedKeysAlways) {
-      generatedKeys = new ResultWrapper(((BatchResultHandler) handler).getGeneratedKeys());
+      // There might be some rows generated even in case of failures
+      if (wantsGeneratedKeysAlways) {
+        generatedKeys = new ResultWrapper(handler.getGeneratedKeys());
+      }
     }
 
     return updateCounts;
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
new file mode 100644
index 000000000..838a11a4c
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
@@ -0,0 +1,34 @@
+package org.postgresql.test.jdbc2;
+
+import org.postgresql.PGProperty;
+import org.postgresql.test.TestUtil;
+
+import org.junit.After;
+import org.junit.Before;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Properties;
+
+public class BaseTest4 {
+  protected Connection con;
+
+  protected void updateProperties(Properties props) {
+  }
+
+  protected void forceBinary(Properties props) {
+    PGProperty.PREPARE_THRESHOLD.set(props, -1);
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    Properties props = new Properties();
+    updateProperties(props);
+    con = TestUtil.openDB(props);
+  }
+
+  @After
+  public void tearDown() throws SQLException {
+    TestUtil.closeDB(con);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
index e608d14d9..d308b97f1 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
@@ -16,6 +16,7 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.util.Arrays;
 
 /*
  * TODO tests that can be added to this test case - SQLExceptions chained to a BatchUpdateException
@@ -43,10 +44,14 @@ protected void setUp() throws Exception {
     TestUtil.createTable(con, "testbatch", "pk INTEGER, col1 INTEGER");
 
     stmt.executeUpdate("INSERT INTO testbatch VALUES (1, 0)");
-    stmt.close();
 
     TestUtil.createTable(con, "prep", "a integer, b integer");
 
+    TestUtil.createTable(con, "batchUpdCnt", "id varchar(512) primary key, data varchar(512)");
+    stmt.executeUpdate("INSERT INTO batchUpdCnt(id) VALUES ('key-2')");
+
+    stmt.close();
+
     // Generally recommended with batch updates. By default we run all
     // tests in this test case with autoCommit disabled.
     con.setAutoCommit(false);
@@ -121,27 +126,77 @@ public void testClearBatch() throws Exception {
     stmt.close();
   }
 
-  public void testSelectThrowsException() throws Exception {
+  public void testSelectInBatch() throws Exception {
     Statement stmt = con.createStatement();
 
     stmt.addBatch("UPDATE testbatch SET col1 = col1 + 1 WHERE pk = 1");
     stmt.addBatch("SELECT col1 FROM testbatch WHERE pk = 1");
     stmt.addBatch("UPDATE testbatch SET col1 = col1 + 2 WHERE pk = 1");
 
+    // There's no reason to fail
+    int[] updateCounts = stmt.executeBatch();
+
+    assertTrue("First update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
+            + ", actual value: " + updateCounts[0],
+        updateCounts[0] == 1 || updateCounts[0] == Statement.SUCCESS_NO_INFO);
+    assertTrue("For SELECT, number of modified rows should be either 0 or SUCCESS_NO_INFO"
+            + ", actual value: " + updateCounts[1],
+        updateCounts[1] == 0 || updateCounts[1] == Statement.SUCCESS_NO_INFO);
+    assertTrue("Second update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
+            + ", actual value: " + updateCounts[2],
+        updateCounts[2] == 1 || updateCounts[2] == Statement.SUCCESS_NO_INFO);
+
+    stmt.close();
+  }
+
+  public void testSelectInBatchThrowsAutoCommit() throws Exception {
+    con.setAutoCommit(true);
+    testSelectInBatchThrows();
+  }
+
+  public void testSelectInBatchThrows() throws Exception {
+    Statement stmt = con.createStatement();
+
+    int oldValue = getCol1Value();
+    stmt.addBatch("UPDATE testbatch SET col1 = col1 + 1 WHERE pk = 1");
+    stmt.addBatch("SELECT 0/0 FROM testbatch WHERE pk = 1");
+    stmt.addBatch("UPDATE testbatch SET col1 = col1 + 2 WHERE pk = 1");
+
+    int[] updateCounts;
     try {
-      stmt.executeBatch();
-      fail("Should raise a BatchUpdateException because of the SELECT");
-    } catch (BatchUpdateException e) {
-      int[] updateCounts = e.getUpdateCounts();
-      assertEquals(1, updateCounts.length);
-      assertEquals(1, updateCounts[0]);
-    } catch (SQLException e) {
-      fail("Should throw a BatchUpdateException instead of " + "a generic SQLException: " + e);
+      updateCounts = stmt.executeBatch();
+      fail("0/0 should throw BatchUpdateException");
+    } catch (BatchUpdateException be) {
+      updateCounts = be.getUpdateCounts();
+    }
+
+    if (!con.getAutoCommit()) {
+      con.commit();
     }
 
+    int newValue = getCol1Value();
+    assertEquals("testbatch.col1 should not be updated since error happened in batch",
+        oldValue, newValue);
+
+    assertEquals("All rows should be marked as EXECUTE_FAILED",
+        Arrays.toString(new int[]{Statement.EXECUTE_FAILED, Statement.EXECUTE_FAILED,
+            Statement.EXECUTE_FAILED}),
+        Arrays.toString(updateCounts));
+
     stmt.close();
   }
 
+  private int getCol1Value() throws SQLException {
+    Statement stmt = con.createStatement();
+    try {
+      ResultSet rs = stmt.executeQuery("select col1 from testbatch where pk=1");
+      rs.next();
+      return rs.getInt(1);
+    } finally {
+      stmt.close();
+    }
+  }
+
   public void testStringAddBatchOnPreparedStatement() throws Exception {
     PreparedStatement pstmt =
         con.prepareStatement("UPDATE testbatch SET col1 = col1 + ? WHERE PK = ?");
@@ -833,4 +888,49 @@ Key part is (see "before the fix"):
 23:15:33.934 (1)  FE=> Terminate
      */
   }
+
+  public void testSmallBatchUpdateFailureSimple() throws SQLException {
+    con.setAutoCommit(true);
+
+    // update as batch
+    PreparedStatement batchSt = con.prepareStatement("INSERT INTO batchUpdCnt(id) VALUES (?)");
+    batchSt.setString(1, "key-1");
+    batchSt.addBatch();
+
+    batchSt.setString(1, "key-2");
+    batchSt.addBatch();
+
+    int[] batchResult;
+    try {
+      batchResult = batchSt.executeBatch();
+      fail("Expecting BatchUpdateException as key-2 is duplicated in batchUpdCnt.id. "
+          + " executeBatch returned " + Arrays.toString(batchResult));
+    } catch (BatchUpdateException ex) {
+      batchResult = ex.getUpdateCounts();
+    } finally {
+      batchSt.close();
+    }
+
+    int newCount = getBatchUpdCount();
+    if (newCount == 2) {
+      // key-1 did succeed
+      assertTrue("batchResult[0] should be 1 or SUCCESS_NO_INFO since 'key-1' was inserted,"
+          + " actual result is " + Arrays.toString(batchResult),
+          batchResult[0] == 1 || batchResult[0] == Statement.SUCCESS_NO_INFO);
+    } else {
+      assertTrue("batchResult[0] should be 0 or EXECUTE_FAILED since 'key-1' was NOT inserted,"
+              + " actual result is " + Arrays.toString(batchResult),
+          batchResult[0] == 0 || batchResult[0] == Statement.EXECUTE_FAILED);
+    }
+
+    assertEquals("'key-2' insertion should have failed",
+        batchResult[1], Statement.EXECUTE_FAILED);
+  }
+
+  private int getBatchUpdCount() throws SQLException {
+    PreparedStatement ps = con.prepareStatement("select count(*) from batchUpdCnt");
+    ResultSet rs = ps.executeQuery();
+    assertTrue("count(*) must return 1 row", rs.next());
+    return rs.getInt(1);
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java
new file mode 100644
index 000000000..3c0174ef0
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java
@@ -0,0 +1,269 @@
+package org.postgresql.test.jdbc2;
+
+import org.postgresql.test.TestUtil;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.sql.BatchUpdateException;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Properties;
+import java.util.Set;
+
+@RunWith(Parameterized.class)
+public class BatchFailureTest extends BaseTest4 {
+  private final BatchType batchType;
+  private final AutoCommit autoCommit;
+  private final FailMode failMode;
+  private final FailPosition failPosition;
+  private final BinaryMode binaryMode;
+
+  enum BinaryMode {
+    REGULAR, FORCE;
+  }
+
+  enum AutoCommit {
+    YES, NO;
+  }
+
+  enum BatchType {
+    SIMPLE {
+      @Override
+      public Statement createStatement(Connection con) throws SQLException {
+        return con.createStatement();
+      }
+    },
+    PREPARED {
+      @Override
+      public Statement createStatement(Connection con) throws SQLException {
+        return con.prepareStatement("INSERT INTO batchUpdCnt(id) VALUES (?)");
+      }
+    },
+    PREPARED_WITH_GENERATED {
+      @Override
+      public Statement createStatement(Connection con) throws SQLException {
+        return con.prepareStatement("INSERT INTO batchUpdCnt(id) VALUES (?)", new String[]{"id"});
+      }
+    };
+
+    public abstract Statement createStatement(Connection con) throws SQLException;
+
+    public void addRow(Statement statement, String value) throws SQLException {
+      switch (this) {
+        case SIMPLE:
+          statement.addBatch("INSERT INTO batchUpdCnt(id) VALUES ('" + value + "')");
+          break;
+        case PREPARED:
+        case PREPARED_WITH_GENERATED:
+          PreparedStatement ps = (PreparedStatement) statement;
+          ps.setString(1, value);
+          ps.addBatch();
+          break;
+      }
+    }
+  }
+
+  enum FailMode {
+    NO_FAIL_JUST_INSERTS, NO_FAIL_SELECT,
+    FAIL_VIA_SELECT_PARSE, FAIL_VIA_SELECT_RUNTIME,
+    FAIL_VIA_DUP_KEY;
+
+    public boolean supports(BatchType batchType) {
+      return batchType != BatchType.SIMPLE ^ this.name().contains("SELECT");
+    }
+
+    public void injectFailure(Statement statement, BatchType batchType) throws SQLException {
+      switch (this) {
+        case NO_FAIL_JUST_INSERTS:
+          break;
+        case NO_FAIL_SELECT:
+          statement.addBatch("select 1 union all select 2");
+          break;
+        case FAIL_VIA_SELECT_RUNTIME:
+          statement.addBatch("select 0/count(*) where 1=2");
+          break;
+        case FAIL_VIA_SELECT_PARSE:
+          statement.addBatch("seeeeleeeect 1");
+          break;
+        case FAIL_VIA_DUP_KEY:
+          batchType.addRow(statement, "key-2");
+          break;
+        default:
+          throw new IllegalArgumentException("Unexpected value " + this);
+      }
+    }
+  }
+
+  enum FailPosition {
+    NONE, FIRST_ROW, SECOND_ROW, MIDDLE, ALMOST_LAST_ROW, LAST_ROW;
+
+    public boolean supports(FailMode mode) {
+      return this == NONE ^ mode.name().startsWith("FAIL");
+    }
+  }
+
+  public BatchFailureTest(BatchType batchType, AutoCommit autoCommit,
+      FailMode failMode, FailPosition failPosition, BinaryMode binaryMode) {
+    this.batchType = batchType;
+    this.autoCommit = autoCommit;
+    this.failMode = failMode;
+    this.failPosition = failPosition;
+    this.binaryMode = binaryMode;
+  }
+
+  @Parameterized.Parameters(name = "{index}: batchTest(mode={2}, position={3}, autoCommit={1}, batchType={0}, generateKeys={1}, binary={4})")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (BatchType batchType : BatchType.values()) {
+      for (FailMode failMode : FailMode.values()) {
+        if (!failMode.supports(batchType)) {
+          continue;
+        }
+        for (FailPosition failPosition : FailPosition.values()) {
+          if (!failPosition.supports(failMode)) {
+            continue;
+          }
+          for (AutoCommit autoCommit : AutoCommit.values()) {
+            for (BinaryMode binaryMode : BinaryMode.values()) {
+              ids.add(new Object[]{batchType, autoCommit, failMode, failPosition, binaryMode});
+            }
+          }
+        }
+      }
+    }
+    return ids;
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    if (binaryMode == BinaryMode.FORCE) {
+      forceBinary(props);
+    }
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "batchUpdCnt", "id varchar(512) primary key, data varchar(512)");
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO batchUpdCnt(id) VALUES ('key-2')");
+    stmt.close();
+    con.setAutoCommit(autoCommit == AutoCommit.YES);
+  }
+
+  @Test
+  public void run() throws SQLException {
+    Statement statement = batchType.createStatement(con);
+
+    int minBatchResults = 0;
+    int pos = 0;
+    if (failPosition == FailPosition.FIRST_ROW) {
+      failMode.injectFailure(statement, batchType);
+      pos++;
+      minBatchResults = pos;
+    }
+
+    batchType.addRow(statement, "key-1");
+    pos++;
+
+    if (failPosition == FailPosition.SECOND_ROW) {
+      failMode.injectFailure(statement, batchType);
+      pos++;
+      minBatchResults = pos;
+    }
+
+    for (int i = 0; i < 1000; i++) {
+      batchType.addRow(statement, "key_" + i);
+      pos++;
+      if (failPosition == FailPosition.ALMOST_LAST_ROW && i == 997
+          || failPosition == FailPosition.MIDDLE && i == 500) {
+        failMode.injectFailure(statement, batchType);
+        pos++;
+        minBatchResults = pos;
+      }
+    }
+
+    if (failPosition == FailPosition.LAST_ROW) {
+      failMode.injectFailure(statement, batchType);
+      pos++;
+      minBatchResults = pos;
+    }
+
+    List<String> keys = new ArrayList<String>();
+    int[] batchResult;
+    int expectedRows = 1;
+    try {
+      batchResult = statement.executeBatch();
+      Assert.assertTrue("Expecting BatchUpdateException due to " + failMode
+              + ", executeBatch returned " + Arrays.toString(batchResult),
+          failPosition == FailPosition.NONE);
+      expectedRows = pos + 1; // +1 since key-2 is already in the DB
+    } catch (BatchUpdateException ex) {
+      batchResult = ex.getUpdateCounts();
+      Assert.assertTrue("Should not fail since fail mode should be " + failMode
+              + ", executeBatch returned " + Arrays.toString(batchResult),
+          failPosition != FailPosition.NONE);
+
+      for (int i : batchResult) {
+        if (i != Statement.EXECUTE_FAILED) {
+          expectedRows++;
+        }
+      }
+
+      Assert.assertTrue("Batch should fail at row " + minBatchResults
+              + ", thus at least " + minBatchResults
+              + " items should be returned, actual result is " + batchResult.length + " items, "
+              + Arrays.toString(batchResult),
+          batchResult.length >= minBatchResults);
+    } finally {
+      if (batchType == BatchType.PREPARED_WITH_GENERATED) {
+        ResultSet rs = statement.getGeneratedKeys();
+        while (rs.next()) {
+          keys.add(rs.getString(1));
+        }
+      }
+      statement.close();
+    }
+
+    if (!con.getAutoCommit()) {
+      con.commit();
+    }
+
+    int finalCount = getBatchUpdCount();
+    Assert.assertEquals(
+        "Number of new rows in batchUpdCnt should match number of non-error betchResult items"
+            + Arrays.toString(batchResult),
+        expectedRows - 1, finalCount - 1);
+
+    if (batchType != BatchType.PREPARED_WITH_GENERATED) {
+      return;
+    }
+
+    if (finalCount > 1) {
+      Assert.assertFalse((finalCount - 1) + " rows were inserted, thus expecting generated keys",
+          keys.isEmpty());
+    }
+    Set<String> uniqueKeys = new HashSet<String>(keys);
+    Assert.assertEquals("Generated keys should be unique: " + keys, keys.size(), uniqueKeys.size());
+    Assert.assertEquals("Number of generated keys should match the number of inserted rows" + keys,
+        keys.size(), finalCount - 1);
+  }
+
+  private int getBatchUpdCount() throws SQLException {
+    PreparedStatement ps = con.prepareStatement("select count(*) from batchUpdCnt");
+    ResultSet rs = ps.executeQuery();
+    Assert.assertTrue("count(*) must return 1 row", rs.next());
+    return rs.getInt(1);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
index 626292825..19df58917 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
@@ -11,6 +11,7 @@
 import org.postgresql.test.CursorFetchBinaryTest;
 import org.postgresql.test.TestUtil;
 
+import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite;
 
 import java.sql.Connection;
@@ -73,6 +74,7 @@ public static TestSuite suite() throws Exception {
     // BatchExecute
     suite.addTestSuite(BatchExecuteTest.class);
     suite.addTestSuite(BatchExecuteBinaryTest.class);
+    suite.addTest(new JUnit4TestAdapter(BatchFailureTest.class));
 
 
     // Other misc tests, based on previous problems users have had or specific
