diff --git a/modules/wyc/src/wyc/builder/FlowTypeChecker.java b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
index 0125270db9..db27abfef1 100755
--- a/modules/wyc/src/wyc/builder/FlowTypeChecker.java
+++ b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
@@ -2911,21 +2911,6 @@ private int resolveAsType(SyntacticType type, Context context,
 			myChildren[0] = resolveAsType(lt.element, context, states, roots,
 					nominal, unconstrained);
 			myData = false;
-		} else if (type instanceof SyntacticType.Set) {
-			SyntacticType.Set st = (SyntacticType.Set) type;
-			myKind = Type.K_SET;
-			myChildren = new int[1];
-			myChildren[0] = resolveAsType(st.element, context, states, roots,
-					nominal, unconstrained);
-			myData = false;
-		} else if (type instanceof SyntacticType.Map) {
-			SyntacticType.Map st = (SyntacticType.Map) type;
-			myKind = Type.K_MAP;
-			myChildren = new int[2];
-			myChildren[0] = resolveAsType(st.key, context, states, roots,
-					nominal, unconstrained);
-			myChildren[1] = resolveAsType(st.value, context, states, roots,
-					nominal, unconstrained);
 		} else if (type instanceof SyntacticType.Record) {
 			SyntacticType.Record tt = (SyntacticType.Record) type;
 			HashMap<String, SyntacticType> ttTypes = tt.types;
diff --git a/modules/wyc/src/wyc/io/WhileyFileParser.java b/modules/wyc/src/wyc/io/WhileyFileParser.java
index 06727801fb..2393f50fcc 100755
--- a/modules/wyc/src/wyc/io/WhileyFileParser.java
+++ b/modules/wyc/src/wyc/io/WhileyFileParser.java
@@ -3459,9 +3459,6 @@ private boolean mustParseAsType(SyntacticType type) {
 		} else if (type instanceof SyntacticType.List) {
 			SyntacticType.List tt = (SyntacticType.List) type;
 			return mustParseAsType(tt.element);
-		} else if (type instanceof SyntacticType.Map) {
-			SyntacticType.Map tt = (SyntacticType.Map) type;
-			return mustParseAsType(tt.key) || mustParseAsType(tt.value);
 		} else if (type instanceof SyntacticType.Negation) {
 			SyntacticType.Negation tt = (SyntacticType.Negation) type;
 			return mustParseAsType(tt.element);
@@ -3470,9 +3467,6 @@ private boolean mustParseAsType(SyntacticType type) {
 		} else if (type instanceof SyntacticType.Reference) {
 			SyntacticType.Reference tt = (SyntacticType.Reference) type;
 			return mustParseAsType(tt.element);
-		} else if (type instanceof SyntacticType.Set) {
-			SyntacticType.Set tt = (SyntacticType.Set) type;
-			return mustParseAsType(tt.element);
 		} else if (type instanceof SyntacticType.Union) {
 			SyntacticType.Union tt = (SyntacticType.Union) type;
 			boolean result = false;
@@ -3922,7 +3916,7 @@ public TypePattern parseTypePatternTerm(HashSet<String> environment,
 			// we just ignore it for now and acknowledge that, at some point, it
 			// might be nice to do better.
 			index = start; // backtrack
-			SyntacticType type = parseSetOrMapOrRecordType();
+			SyntacticType type = parseRecordType();
 			Expr.LocalVariable name = parseTypePatternVar(terminated);
 			if (name == null && type instanceof SyntacticType.Record) {
 				return new TypePattern.Record((SyntacticType.Record) type,
@@ -4069,7 +4063,7 @@ private SyntacticType parseBaseType() {
 		case LeftBrace:
 			return parseBracketedType();
 		case LeftCurly:
-			return parseSetOrMapOrRecordType();
+			return parseRecordType();
 		case LeftSquare:
 			return parseListType();
 		case Shreak:
@@ -4173,41 +4167,11 @@ private SyntacticType parseListType() {
 	 *
 	 * @return
 	 */
-	private SyntacticType parseSetOrMapOrRecordType() {
+	private SyntacticType parseRecordType() {
 		int start = index;
 		match(LeftCurly);
 
-		// First, we need to disambiguate between a set, map or record type. The
-		// complication is the potential for mixed types. For example, when
-		// parsing "{ function f(int)->int }", the first element is not a type.
-		// Therefore, we have to first decide whether or not we have a mixed
-		// type, or a normal type.
-
-		if (!mustParseAsMixedType()) {
-			int t_start = index; // backtrack point
-
-			SyntacticType type = parseType();
-
-			if (tryAndMatch(true, RightCurly) != null) {
-				// This indicates a set type was encountered.
-				return new SyntacticType.Set(type, sourceAttr(start, index - 1));
-			} else if (tryAndMatch(true, EqualsGreater) != null) {
-				// This indicates a map type was encountered.
-				SyntacticType value = parseType();
-				match(RightCurly);
-				return new SyntacticType.Map(type, value, sourceAttr(start,
-						index - 1));
-			}
-			// At this point, we definitely have a record type (or an error).
-			// Therefore, we backtrack and parse the potentially mixed type
-			// properly.
-			index = t_start; // backtrack
-		}
-
 		HashMap<String, SyntacticType> types = new HashMap<String, SyntacticType>();
-		// Otherwise, we have a record type and we must continue to parse
-		// the remainder of the first field.
-
 		Pair<SyntacticType, Token> p = parseMixedType();
 		types.put(p.second().text, p.first());
 
diff --git a/modules/wyc/src/wyc/io/WhileyFilePrinter.java b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
index dfbb0b18a0..4d1661665f 100755
--- a/modules/wyc/src/wyc/io/WhileyFilePrinter.java
+++ b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
@@ -751,20 +751,10 @@ public void print(SyntacticType t) {
 				firstTime=false;
 				out.print(name);
 			}
-		} else if(t instanceof SyntacticType.Set) {
-			out.print("{");
-			print(((SyntacticType.Set)t).element);
-			out.print("}");
 		} else if(t instanceof SyntacticType.List) {
 			out.print("[");
 			print(((SyntacticType.List)t).element);
 			out.print("]");
-		} else if(t instanceof SyntacticType.Map) {
-			out.print("{");
-			print(((SyntacticType.Map)t).key);
-			out.print("=>");
-			print(((SyntacticType.Map)t).value);
-			out.print("}");
 		} else if(t instanceof SyntacticType.Tuple) {
 			SyntacticType.Tuple tt = (SyntacticType.Tuple) t;
 			out.print("(");
diff --git a/modules/wyc/src/wyc/lang/SyntacticType.java b/modules/wyc/src/wyc/lang/SyntacticType.java
index 11e1aabc78..50d7c000a1 100755
--- a/modules/wyc/src/wyc/lang/SyntacticType.java
+++ b/modules/wyc/src/wyc/lang/SyntacticType.java
@@ -209,42 +209,6 @@ public List(SyntacticType element, Attribute... attributes) {
 		}
 	}
 
-	/**
-	 * Represents a set type, which is of the form:
-	 *
-	 * <pre>
-	 * SetType ::= '{' Type '}'
-	 * </pre>
-	 *
-	 * @return
-	 */
-	public static final class Set extends SyntacticElement.Impl implements NonUnion {
-		public final SyntacticType element;
-		public Set(SyntacticType element, Attribute... attributes) {
-			super(attributes);
-			this.element = element;
-		}
-	}
-
-	/**
-	 * Represents a map type, which is of the form:
-	 *
-	 * <pre>
-	 * MapType ::= '{' Type "=>" Type '}'
-	 * </pre>
-	 *
-	 * @return
-	 */
-	public static final class Map extends SyntacticElement.Impl implements NonUnion {
-		public final SyntacticType key;
-		public final SyntacticType value;
-		public Map(SyntacticType key,SyntacticType value, Attribute... attributes) {
-			super(attributes);
-			this.key=key;
-			this.value=value;
-		}
-	}
-
 	/**
 	 * Parse a negation type, which is of the form:
 	 *
diff --git a/modules/wyc/src/wyc/testing/AllValidTests.java b/modules/wyc/src/wyc/testing/AllValidTests.java
index 9e016840bc..4bbbb6d02b 100755
--- a/modules/wyc/src/wyc/testing/AllValidTests.java
+++ b/modules/wyc/src/wyc/testing/AllValidTests.java
@@ -400,11 +400,6 @@ public void ConstrainedInt_Valid_13() throws IOException {
 		runTest("ConstrainedInt_Valid_13");
 	}
 
-	@Test
-	public void ConstrainedInt_Valid_14() throws IOException {
-		runTest("ConstrainedInt_Valid_14");
-	}
-
 	@Test
 	public void ConstrainedInt_Valid_15() throws IOException {
 		runTest("ConstrainedInt_Valid_15");
@@ -810,16 +805,6 @@ public void For_Valid_11() throws IOException {
 		runTest("For_Valid_11");
 	}
 
-	@Test
-	public void For_Valid_12() throws IOException {
-		runTest("For_Valid_12");
-	}
-
-	@Test
-	public void For_Valid_13() throws IOException {
-		runTest("For_Valid_13");
-	}
-
 	@Test
 	public void For_Valid_14() throws IOException {
 		runTest("For_Valid_14");
@@ -870,11 +855,6 @@ public void For_Valid_5() throws IOException {
 		runTest("For_Valid_5");
 	}
 
-	@Ignore("Issue ???") @Test
-	public void For_Valid_6() throws IOException {
-		runTest("For_Valid_6");
-	}
-
 	@Test
 	public void For_Valid_7() throws IOException {
 		runTest("For_Valid_7");
@@ -2574,11 +2554,6 @@ public void UnionType_Valid_9() throws IOException {
 		runTest("UnionType_Valid_9");
 	}
 
-	@Ignore("Issue ???") @Test
-	public void Update_Valid_1() throws IOException {
-		runTest("Update_Valid_1");
-	}
-
 	@Test
 	public void Update_Valid_2() throws IOException {
 		runTest("Update_Valid_2");
diff --git a/modules/wyil/src/wyil/builders/VcGenerator.java b/modules/wyil/src/wyil/builders/VcGenerator.java
index c2f75fc1a8..81099f766e 100755
--- a/modules/wyil/src/wyil/builders/VcGenerator.java
+++ b/modules/wyil/src/wyil/builders/VcGenerator.java
@@ -2481,13 +2481,7 @@ private Expr generateAssumptionsHelper(VcBranch b, VcBranch end) {
 			break;
 		case LT:
 			op = Expr.Binary.Op.LT;
-			break;
-		case SUBSET:
-			op = Expr.Binary.Op.SUBSET;
-			break;
-		case SUBSETEQ:
-			op = Expr.Binary.Op.SUBSETEQ;
-			break;
+			break;		
 		case IN:
 			op = Expr.Binary.Op.IN;
 			break;
diff --git a/modules/wyil/src/wyil/lang/Codes.java b/modules/wyil/src/wyil/lang/Codes.java
index caf46677da..f53a221cc5 100755
--- a/modules/wyil/src/wyil/lang/Codes.java
+++ b/modules/wyil/src/wyil/lang/Codes.java
@@ -1157,8 +1157,6 @@ public String toString() {
 	 * <code>real</code>.</li>
 	 * <li><i>element of (in).</i> The second operand must be a set whose
 	 * element type is that of the first.</li>
-	 * <li><i>subset (ss) and subset-equals (sse)</i>. Both operands must have
-	 * the given type, which additionally must be a set.</li>
 	 * </ul>
 	 * For example, the following Whiley code:
 	 *
@@ -1298,16 +1296,6 @@ public String toString() {
 			public String toString() {
 				return "in";
 			}
-		},
-		SUBSET(7) {
-			public String toString() {
-				return "sb";
-			}
-		},
-		SUBSETEQ(8) {
-			public String toString() {
-				return "sbe";
-			}
 		};
 		public int offset;
 
diff --git a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
index 19c73413e9..5581779a27 100755
--- a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
+++ b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
@@ -42,7 +42,6 @@
 import wyil.attributes.SourceLocation;
 import wyil.lang.*;
 import wyil.lang.Constant;
-import wyil.lang.Type.EffectiveCollection;
 import wyil.util.AttributedCodeBlock;
 import wyil.util.TypeExpander;
 import static wyil.util.ErrorMessages.internalFailure;
@@ -647,14 +646,10 @@ private int translate(CodeBlock.Index index, Code code, int freeSlot,
 				translate(index, (Codes.Move) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.Update) {
 				translate(index, (Codes.Update) code, freeSlot, bytecodes);
-			} else if (code instanceof Codes.NewMap) {
-				translate(index, (Codes.NewMap) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.NewList) {
 				translate(index, (Codes.NewList) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.NewRecord) {
 				translate(index, (Codes.NewRecord) code, freeSlot, bytecodes);
-			} else if (code instanceof Codes.NewSet) {
-				translate(index, (Codes.NewSet) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.NewTuple) {
 				translate(index, (Codes.NewTuple) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.UnaryOperator) {
@@ -666,8 +661,6 @@ private int translate(CodeBlock.Index index, Code code, int freeSlot,
 				translate(index, (Codes.Return) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.Nop) {
 				// do nothing
-			} else if (code instanceof Codes.SetOperator) {
-				translate(index, (Codes.SetOperator) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.Switch) {
 				translate(index, (Codes.Switch) code, freeSlot, bytecodes);
 			} else if (code instanceof Codes.NewObject) {
@@ -780,37 +773,6 @@ private void translateUpdate(Iterator<Codes.LVal> iterator,
 			bytecodes.add(new Bytecode.Invoke(WHILEYLIST, "set", ftype,
 					Bytecode.InvokeMode.STATIC));
 
-		} else if (lv instanceof Codes.MapLVal) {
-			Codes.MapLVal l = (Codes.MapLVal) lv;
-			JvmType keyType = convertUnderlyingType(l.rawType().key());
-			JvmType valueType = convertUnderlyingType(l.rawType().value());
-			if (iterator.hasNext()) {
-				// In this case, we're partially updating the element at a
-				// given position.
-				bytecodes.add(new Bytecode.Dup(WHILEYMAP));
-				bytecodes.add(new Bytecode.Load(l.keyOperand, keyType));
-				addWriteConversion(l.rawType().key(), bytecodes);
-				JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-						WHILEYMAP, JAVA_LANG_OBJECT);
-				bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "internal_get",
-						ftype, Bytecode.InvokeMode.STATIC));
-				addReadConversion(l.rawType().value(), bytecodes);
-				translateUpdate(iterator, code, bytecodes);
-				bytecodes.add(new Bytecode.Load(l.keyOperand, keyType));
-				addWriteConversion(l.rawType().key(), bytecodes);
-				bytecodes.add(new Bytecode.Swap());
-			} else {
-				bytecodes.add(new Bytecode.Load(l.keyOperand, keyType));
-				addWriteConversion(l.rawType().key(), bytecodes);
-				bytecodes.add(new Bytecode.Load(code.result(), valueType));
-				addWriteConversion(l.rawType().value(), bytecodes);
-			}
-
-			JvmType.Function ftype = new JvmType.Function(WHILEYMAP, WHILEYMAP,
-					JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
-			bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "put", ftype,
-					Bytecode.InvokeMode.STATIC));
-
 		} else if (lv instanceof Codes.RecordLVal) {
 			Codes.RecordLVal l = (Codes.RecordLVal) lv;
 			Type.EffectiveRecord type = l.rawType();
@@ -1005,23 +967,7 @@ private void translateIfGoto(CodeBlock.Index index, Type c_type,
 					"compareTo", ftype, Bytecode.InvokeMode.VIRTUAL));
 			op = Bytecode.IfMode.GE;
 			break;
-		}
-		case SUBSETEQ: {
-			JvmType.Function ftype = new JvmType.Function(T_BOOL, WHILEYSET,
-					WHILEYSET);
-			bytecodes.add(new Bytecode.Invoke(WHILEYSET, "subsetEq", ftype,
-					Bytecode.InvokeMode.STATIC));
-			op = Bytecode.IfMode.NE;
-			break;
-		}
-		case SUBSET: {
-			JvmType.Function ftype = new JvmType.Function(T_BOOL, WHILEYSET,
-					WHILEYSET);
-			bytecodes.add(new Bytecode.Invoke(WHILEYSET, "subset", ftype,
-					Bytecode.InvokeMode.STATIC));
-			op = Bytecode.IfMode.NE;
-			break;
-		}
+		}	
 		case IN: {
 			JvmType.Function ftype = new JvmType.Function(T_BOOL,
 					JAVA_LANG_OBJECT);
@@ -1194,8 +1140,8 @@ private void translateInvariantTest(String falseTarget, Type type,
 					.element())));
 			translateInvariantTest(falseTarget, rt.element(), freeSlot,
 					freeSlot + 1, constants, bytecodes);
-		} else if (type instanceof Type.EffectiveCollection) {
-			Type.EffectiveCollection ts = (Type.EffectiveCollection) type;
+		} else if (type instanceof Type.EffectiveList) {
+			Type.EffectiveList ts = (Type.EffectiveList) type;
 			Triple<String, String, String> loopLabels = translateLoopBegin(
 					bytecodes, rootSlot, freeSlot);
 			addReadConversion(ts.element(), bytecodes);
@@ -1307,10 +1253,9 @@ private int translate(CodeBlock.Index index, Codes.ForAll c, int freeSlot,
 
 		bytecodes.add(new Bytecode.Load(c.sourceOperand,
 				convertUnderlyingType((Type) c.type)));
-		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_ITERATOR,
-				JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYCOLLECTION, "iterator", ftype,
-				Bytecode.InvokeMode.STATIC));
+		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
+		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_COLLECTION, "iterator",
+				ftype, Bytecode.InvokeMode.INTERFACE));
 		ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
 		bytecodes.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
 		String loopHeader = freshLabel();
@@ -1400,9 +1345,9 @@ private void translate(CodeBlock.Index index, Codes.LengthOf c,
 		bytecodes.add(new Bytecode.Load(c.operand(0),
 				convertUnderlyingType((Type) c.type())));
 		JvmType.Clazz ctype = JAVA_LANG_OBJECT;
-		JvmType.Function ftype = new JvmType.Function(WHILEYINT, ctype);
-		bytecodes.add(new Bytecode.Invoke(WHILEYCOLLECTION, "length", ftype,
-				Bytecode.InvokeMode.STATIC));
+		JvmType.Function ftype = new JvmType.Function(WHILEYINT);
+		bytecodes.add(new Bytecode.Invoke(WHILEYLIST, "length", ftype,
+				Bytecode.InvokeMode.VIRTUAL));
 		bytecodes.add(new Bytecode.Store(c.target(), WHILEYINT));
 	}
 
@@ -1424,14 +1369,12 @@ private void translate(CodeBlock.Index index, Codes.IndexOf c,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
 
 		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYLIST));
-		bytecodes.add(new Bytecode.Load(c.operand(1), convertUnderlyingType(c
-				.type().key())));
-		addWriteConversion(c.type().key(), bytecodes);
+		bytecodes.add(new Bytecode.Load(c.operand(1), WHILEYINT));
 		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYCOLLECTION, "indexOf", ftype,
+				WHILEYLIST, WHILEYINT);
+		bytecodes.add(new Bytecode.Invoke(WHILEYLIST, "get", ftype,
 				Bytecode.InvokeMode.STATIC));
-		addReadConversion(c.type().value(), bytecodes);
+		addReadConversion(c.type().element(), bytecodes);
 
 		bytecodes.add(new Bytecode.Store(c.target(), convertUnderlyingType(c
 				.type().element())));
@@ -1554,39 +1497,6 @@ private void translate(CodeBlock.Index index, Codes.BinaryOperator c,
 		bytecodes.add(new Bytecode.Store(c.target(), type));
 	}
 
-	private void translate(CodeBlock.Index index, Codes.SetOperator c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-
-		bytecodes.add(new Bytecode.Load(c.operand(0), WHILEYSET));
-		bytecodes.add(new Bytecode.Load(c.operand(1), WHILEYSET));
-
-		JvmType.Function ftype = new JvmType.Function(WHILEYSET, WHILEYSET,
-				WHILEYSET);
-
-		// Second, select operation
-		String operation;
-		switch (c.kind) {
-		case UNION:
-			operation = "union";
-			break;
-		case INTERSECTION:
-			operation = "intersect";
-			break;
-		case DIFFERENCE:
-			operation = "difference";
-			break;
-		default:
-			internalFailure("Unknown set operation encountered: ", filename,
-					rootBlock.attribute(index, SourceLocation.class));
-			return; // dead-code
-		}
-
-		bytecodes.add(new Bytecode.Invoke(WHILEYSET, operation, ftype,
-				Bytecode.InvokeMode.STATIC));
-
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYSET));
-	}
-
 	private void translate(CodeBlock.Index index, Codes.Invert c, int freeSlot,
 			ArrayList<Bytecode> bytecodes) {
 		JvmType type = convertUnderlyingType(c.type());
@@ -1672,29 +1582,6 @@ protected void translate(CodeBlock.Index index, Codes.NewList c,
 		bytecodes.add(new Bytecode.Store(c.target(), WHILEYLIST));
 	}
 
-	protected void translate(CodeBlock.Index index, Codes.NewMap c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-
-		construct(WHILEYMAP, freeSlot, bytecodes);
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
-		JvmType keyType = convertUnderlyingType(c.type().key());
-		JvmType valueType = convertUnderlyingType(c.type().value());
-
-		for (int i = 0; i != c.operands().length; i = i + 2) {
-			bytecodes.add(new Bytecode.Dup(WHILEYMAP));
-			bytecodes.add(new Bytecode.Load(c.operands()[i], keyType));
-			addWriteConversion(c.type().key(), bytecodes);
-			bytecodes.add(new Bytecode.Load(c.operands()[i + 1], valueType));
-			addWriteConversion(c.type().value(), bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "put", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
-			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
-		}
-
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYMAP));
-	}
-
 	private void translate(CodeBlock.Index index, Codes.NewRecord code,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
 		construct(WHILEYRECORD, freeSlot, bytecodes);
@@ -1721,23 +1608,6 @@ private void translate(CodeBlock.Index index, Codes.NewRecord code,
 		bytecodes.add(new Bytecode.Store(code.target(), WHILEYRECORD));
 	}
 
-	protected void translate(CodeBlock.Index index, Codes.NewSet c,
-			int freeSlot, ArrayList<Bytecode> bytecodes) {
-		construct(WHILEYSET, freeSlot, bytecodes);
-		JvmType.Function ftype = new JvmType.Function(WHILEYSET, WHILEYSET,
-				JAVA_LANG_OBJECT);
-
-		for (int i = 0; i != c.operands().length; ++i) {
-			bytecodes.add(new Bytecode.Load(c.operands()[i],
-					convertUnderlyingType(c.type().element())));
-			addWriteConversion(c.type().element(), bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYSET, "internal_add", ftype,
-					Bytecode.InvokeMode.STATIC));
-		}
-
-		bytecodes.add(new Bytecode.Store(c.target(), WHILEYSET));
-	}
-
 	protected void translate(CodeBlock.Index index, Codes.NewTuple c,
 			int freeSlot, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.New(WHILEYTUPLE));
@@ -1910,14 +1780,10 @@ private void translate(Constant v, int freeSlot,
 			translate((Constant.Type) v, freeSlot, bytecodes);
 		} else if (v instanceof Constant.Decimal) {
 			translate((Constant.Decimal) v, freeSlot, bytecodes);
-		} else if (v instanceof Constant.Set) {
-			translate((Constant.Set) v, freeSlot, lambdas, bytecodes);
 		} else if (v instanceof Constant.List) {
 			translate((Constant.List) v, freeSlot, lambdas, bytecodes);
 		} else if (v instanceof Constant.Record) {
 			translate((Constant.Record) v, freeSlot, lambdas, bytecodes);
-		} else if (v instanceof Constant.Map) {
-			translate((Constant.Map) v, freeSlot, lambdas, bytecodes);
 		} else if (v instanceof Constant.Tuple) {
 			translate((Constant.Tuple) v, freeSlot, lambdas, bytecodes);
 		} else if (v instanceof Constant.Lambda) {
@@ -2096,25 +1962,6 @@ protected void translate(Constant.Decimal e, int freeSlot,
 		}
 	}
 
-	protected void translate(Constant.Set lv, int freeSlot,
-			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
-		bytecodes.add(new Bytecode.New(WHILEYSET));
-		bytecodes.add(new Bytecode.Dup(WHILEYSET));
-		JvmType.Function ftype = new JvmType.Function(T_VOID);
-		bytecodes.add(new Bytecode.Invoke(WHILEYSET, "<init>", ftype,
-				Bytecode.InvokeMode.SPECIAL));
-
-		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
-		for (Constant e : lv.values) {
-			bytecodes.add(new Bytecode.Dup(WHILEYSET));
-			translate(e, freeSlot, bytecodes);
-			addWriteConversion(e.type(), bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYSET, "add", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
-			bytecodes.add(new Bytecode.Pop(T_BOOL));
-		}
-	}
-
 	protected void translate(Constant.List lv, int freeSlot,
 			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
 		bytecodes.add(new Bytecode.New(WHILEYLIST));
@@ -2171,28 +2018,7 @@ protected void translate(Constant.Record expr, int freeSlot,
 			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
 		}
 	}
-
-	protected void translate(Constant.Map expr, int freeSlot,
-			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
-		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
-
-		construct(WHILEYMAP, freeSlot, bytecodes);
-
-		for (Map.Entry<Constant, Constant> e : expr.values.entrySet()) {
-			Type kt = e.getKey().type();
-			Type vt = e.getValue().type();
-			bytecodes.add(new Bytecode.Dup(WHILEYMAP));
-			translate(e.getKey(), freeSlot, bytecodes);
-			addWriteConversion(kt, bytecodes);
-			translate(e.getValue(), freeSlot, bytecodes);
-			addWriteConversion(vt, bytecodes);
-			bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "put", ftype,
-					Bytecode.InvokeMode.VIRTUAL));
-			bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
-		}
-	}
-
+	
 	protected void translate(Constant.Lambda c, int freeSlot,
 			ArrayList<ClassFile> lambdas, ArrayList<Bytecode> bytecodes) {
 
@@ -2410,21 +2236,6 @@ protected void buildCoercion(Type from, Type to, int freeSlot,
 		} else if (from instanceof Type.Reference
 				&& to instanceof Type.Reference) {
 			// TODO
-		} else if (from instanceof Type.Set && to instanceof Type.Set) {
-			buildCoercion((Type.Set) from, (Type.Set) to, freeSlot, constants,
-					bytecodes);
-		} else if (from instanceof Type.Set && to instanceof Type.Map) {
-			buildCoercion((Type.Set) from, (Type.Map) to, freeSlot, constants,
-					bytecodes);
-		} else if (from instanceof Type.List && to instanceof Type.Set) {
-			buildCoercion((Type.List) from, (Type.Set) to, freeSlot, constants,
-					bytecodes);
-		} else if (from instanceof Type.Map && to instanceof Type.Map) {
-			buildCoercion((Type.Map) from, (Type.Map) to, freeSlot, constants,
-					bytecodes);
-		} else if (from instanceof Type.List && to instanceof Type.Map) {
-			buildCoercion((Type.List) from, (Type.Map) to, freeSlot, constants,
-					bytecodes);
 		} else if (from instanceof Type.List && to instanceof Type.List) {
 			buildCoercion((Type.List) from, (Type.List) to, freeSlot,
 					constants, bytecodes);
@@ -2523,237 +2334,6 @@ protected void buildCoercion(Type.List fromType, Type.List toType,
 		bytecodes.add(new Bytecode.Load(tmp, WHILEYLIST));
 	}
 
-	protected void buildCoercion(Type.List fromType, Type.Map toType,
-			int freeSlot, HashMap<JvmConstant, Integer> constants,
-			ArrayList<Bytecode> bytecodes) {
-
-		if (fromType.element() == Type.T_VOID) {
-			// nothing to do, in this particular case
-			return;
-		}
-
-		// The following piece of code implements a java for-each loop which
-		// iterates every element of the input collection, and recursively
-		// converts it before loading it back onto a new WhileyList.
-		String loopLabel = freshLabel();
-		String exitLabel = freshLabel();
-		int iter = freeSlot++;
-		int source = freeSlot++;
-		int target = freeSlot++;
-		bytecodes.add(new Bytecode.Store(source, JAVA_UTIL_LIST));
-		bytecodes.add(new Bytecode.LoadConst(0));
-		bytecodes.add(new Bytecode.Store(iter, T_INT));
-
-		construct(WHILEYMAP, freeSlot, bytecodes);
-		bytecodes.add(new Bytecode.Store(target, WHILEYMAP));
-		bytecodes.add(new Bytecode.Label(loopLabel));
-		JvmType.Function ftype = new JvmType.Function(T_INT);
-		bytecodes.add(new Bytecode.Load(iter, JvmTypes.T_INT));
-		bytecodes.add(new Bytecode.Load(source, JAVA_UTIL_LIST));
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_LIST, "size", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.IfCmp(Bytecode.IfCmp.GE, T_INT, exitLabel));
-		bytecodes.add(new Bytecode.Load(target, WHILEYSET));
-		bytecodes.add(new Bytecode.Load(iter, T_INT));
-		bytecodes.add(new Bytecode.Conversion(T_INT, T_LONG));
-		ftype = new JvmType.Function(WHILEYINT, T_LONG);
-		bytecodes.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype,
-				Bytecode.InvokeMode.STATIC));
-		bytecodes.add(new Bytecode.Load(source, WHILEYMAP));
-		bytecodes.add(new Bytecode.Load(iter, T_INT));
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT, T_INT);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_LIST, "get", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		addReadConversion(fromType.element(), bytecodes);
-		addCoercion(fromType.element(), toType.value(), freeSlot, constants,
-				bytecodes);
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "put", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
-		bytecodes.add(new Bytecode.Iinc(iter, 1));
-		bytecodes.add(new Bytecode.Goto(loopLabel));
-		bytecodes.add(new Bytecode.Label(exitLabel));
-		bytecodes.add(new Bytecode.Load(target, WHILEYMAP));
-	}
-
-	protected void buildCoercion(Type.Map fromType, Type.Map toType,
-			int freeSlot, HashMap<JvmConstant, Integer> constants,
-			ArrayList<Bytecode> bytecodes) {
-
-		if (fromType.key() == Type.T_VOID || toType.key() == Type.T_VOID) {
-			// nothing to do, in this particular case
-			return;
-		}
-
-		// The following piece of code implements a java for-each loop which
-		// iterates every element of the input collection, and recursively
-		// converts it before loading it back onto a new WhileyList.
-		String loopLabel = freshLabel();
-		String exitLabel = freshLabel();
-
-		int iter = freeSlot++;
-		int source = freeSlot++;
-		int target = freeSlot++;
-
-		bytecodes.add(new Bytecode.Dup(WHILEYMAP));
-		bytecodes.add(new Bytecode.Store(source, WHILEYMAP));
-		construct(WHILEYMAP, freeSlot, bytecodes);
-		bytecodes.add(new Bytecode.Store(target, WHILEYMAP));
-
-		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_SET);
-		bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "keySet", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_SET, "iterator", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.Store(iter, JAVA_UTIL_ITERATOR));
-
-		bytecodes.add(new Bytecode.Label(loopLabel));
-		ftype = new JvmType.Function(T_BOOL);
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, exitLabel));
-
-		bytecodes.add(new Bytecode.Load(target, WHILEYMAP));
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT);
-		// FIXME: use the translateLoopBegin() function below.
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		addReadConversion(fromType.key(), bytecodes);
-		bytecodes.add(new Bytecode.Dup(convertUnderlyingType(fromType.key())));
-		addCoercion(fromType.key(), toType.key(), freeSlot, constants,
-				bytecodes);
-		addWriteConversion(toType.key(), bytecodes);
-		bytecodes.add(new Bytecode.Swap());
-		bytecodes.add(new Bytecode.Load(source, WHILEYMAP));
-		bytecodes.add(new Bytecode.Swap());
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "get", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		addReadConversion(fromType.value(), bytecodes);
-		addCoercion(fromType.value(), toType.value(), freeSlot, constants,
-				bytecodes);
-		addWriteConversion(toType.value(), bytecodes);
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT,
-				JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYMAP, "put", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
-		bytecodes.add(new Bytecode.Goto(loopLabel));
-		bytecodes.add(new Bytecode.Label(exitLabel));
-		bytecodes.add(new Bytecode.Load(target, WHILEYMAP));
-	}
-
-	protected void buildCoercion(Type.Set fromType, Type.Map toType,
-			int freeSlot, HashMap<JvmConstant, Integer> constants,
-			ArrayList<Bytecode> bytecodes) {
-		// this case can only happen in one situation --- when the set is empty.
-
-		if (fromType.element() != Type.T_VOID) {
-			throw new RuntimeException("invalid coercion encountered: "
-					+ fromType + " => " + toType);
-		}
-
-		bytecodes.add(new Bytecode.Pop(WHILEYSET));
-		construct(WHILEYMAP, freeSlot, bytecodes);
-	}
-
-	protected void buildCoercion(Type.List fromType, Type.Set toType,
-			int freeSlot, HashMap<JvmConstant, Integer> constants,
-			ArrayList<Bytecode> bytecodes) {
-
-		if (fromType.element() == Type.T_VOID) {
-			// nothing to do, in this particular case
-			return;
-		}
-
-		// The following piece of code implements a java for-each loop which
-		// iterates every element of the input collection, and recursively
-		// converts it before loading it back onto a new WhileyList.
-		String loopLabel = freshLabel();
-		String exitLabel = freshLabel();
-		int iter = freeSlot++;
-		int tmp = freeSlot++;
-		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_COLLECTION, "iterator",
-				ftype, Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.Store(iter, JAVA_UTIL_ITERATOR));
-		construct(WHILEYSET, freeSlot, bytecodes);
-		bytecodes.add(new Bytecode.Store(tmp, WHILEYSET));
-		bytecodes.add(new Bytecode.Label(loopLabel));
-		ftype = new JvmType.Function(T_BOOL);
-		// FIXME: use the translateLoopBegin() function below.
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, exitLabel));
-		bytecodes.add(new Bytecode.Load(tmp, WHILEYSET));
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		addReadConversion(fromType.element(), bytecodes);
-		addCoercion(fromType.element(), toType.element(), freeSlot, constants,
-				bytecodes);
-		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYSET, "add", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Pop(T_BOOL));
-		bytecodes.add(new Bytecode.Goto(loopLabel));
-		bytecodes.add(new Bytecode.Label(exitLabel));
-		bytecodes.add(new Bytecode.Load(tmp, WHILEYSET));
-	}
-
-	protected void buildCoercion(Type.Set fromType, Type.Set toType,
-			int freeSlot, HashMap<JvmConstant, Integer> constants,
-			ArrayList<Bytecode> bytecodes) {
-
-		if (fromType.element() == Type.T_VOID) {
-			// nothing to do, in this particular case
-			return;
-		}
-
-		// The following piece of code implements a java for-each loop which
-		// iterates every element of the input collection, and recursively
-		// converts it before loading it back onto a new WhileyList.
-		String loopLabel = freshLabel();
-		String exitLabel = freshLabel();
-		int iter = freeSlot++;
-		int tmp = freeSlot++;
-		JvmType.Function ftype = new JvmType.Function(JAVA_UTIL_ITERATOR);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_COLLECTION, "iterator",
-				ftype, Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.Store(iter, JAVA_UTIL_ITERATOR));
-		construct(WHILEYSET, freeSlot, bytecodes);
-		bytecodes.add(new Bytecode.Store(tmp, WHILEYSET));
-		bytecodes.add(new Bytecode.Label(loopLabel));
-		ftype = new JvmType.Function(T_BOOL);
-		// FIXME: use the translateLoopBegin() function below.
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		bytecodes.add(new Bytecode.If(Bytecode.IfMode.EQ, exitLabel));
-		bytecodes.add(new Bytecode.Load(tmp, WHILEYSET));
-		bytecodes.add(new Bytecode.Load(iter, JAVA_UTIL_ITERATOR));
-		ftype = new JvmType.Function(JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next", ftype,
-				Bytecode.InvokeMode.INTERFACE));
-		addReadConversion(fromType.element(), bytecodes);
-		addCoercion(fromType.element(), toType.element(), freeSlot, constants,
-				bytecodes);
-		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
-		bytecodes.add(new Bytecode.Invoke(WHILEYSET, "add", ftype,
-				Bytecode.InvokeMode.VIRTUAL));
-		bytecodes.add(new Bytecode.Pop(T_BOOL));
-		bytecodes.add(new Bytecode.Goto(loopLabel));
-		bytecodes.add(new Bytecode.Label(exitLabel));
-		bytecodes.add(new Bytecode.Load(tmp, WHILEYSET));
-	}
-
 	private void buildCoercion(Type.Record fromType, Type.Record toType,
 			int freeSlot, HashMap<JvmConstant, Integer> constants,
 			ArrayList<Bytecode> bytecodes) {
@@ -2883,8 +2463,7 @@ private void buildCoercion(Type from, Type.Union to, int freeSlot,
 		// it into the free slot.
 		bytecodes.add(new Bytecode.Load(sourceSlot, JAVA_LANG_ITERABLE));
 		bytecodes.add(new Bytecode.Invoke(JAVA_LANG_ITERABLE, "iterator",
-				new JvmType.Function(JAVA_UTIL_ITERATOR),
-				Bytecode.InvokeMode.INTERFACE));
+				new JvmType.Function(JAVA_UTIL_ITERATOR),Bytecode.InvokeMode.INTERFACE));
 		bytecodes.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
 
 		// Second, construct the loop header, which consists of the test to
@@ -2974,22 +2553,14 @@ private void construct(JvmType.Clazz owner, int freeSlot,
 			"wyjc.runtime", "Util");
 	private final static JvmType.Clazz WHILEYLIST = new JvmType.Clazz(
 			"wyjc.runtime", "WyList");
-	private final static JvmType.Clazz WHILEYSET = new JvmType.Clazz(
-			"wyjc.runtime", "WySet");
 	private final static JvmType.Clazz WHILEYTUPLE = new JvmType.Clazz(
 			"wyjc.runtime", "WyTuple");
-	private final static JvmType.Clazz WHILEYCOLLECTION = new JvmType.Clazz(
-			"wyjc.runtime", "WyCollection");
 	private final static JvmType.Clazz WHILEYTYPE = new JvmType.Clazz(
 			"wyjc.runtime", "WyType");
-	private final static JvmType.Clazz WHILEYMAP = new JvmType.Clazz(
-			"wyjc.runtime", "WyMap");
 	private final static JvmType.Clazz WHILEYRECORD = new JvmType.Clazz(
 			"wyjc.runtime", "WyRecord");
 	private final static JvmType.Clazz WHILEYOBJECT = new JvmType.Clazz(
 			"wyjc.runtime", "WyObject");
-	private final static JvmType.Clazz WHILEYEXCEPTION = new JvmType.Clazz(
-			"wyjc.runtime", "WyException");
 	private final static JvmType.Clazz WHILEYBOOL = new JvmType.Clazz(
 			"wyjc.runtime", "WyBool");
 	private final static JvmType.Clazz WHILEYBYTE = new JvmType.Clazz(
@@ -3060,10 +2631,6 @@ private JvmType convertUnderlyingType(Type t) {
 			return WHILEYTYPE;
 		} else if (t instanceof Type.EffectiveList) {
 			return WHILEYLIST;
-		} else if (t instanceof Type.EffectiveSet) {
-			return WHILEYSET;
-		} else if (t instanceof Type.EffectiveMap) {
-			return WHILEYMAP;
 		} else if (t instanceof Type.EffectiveRecord) {
 			return WHILEYRECORD;
 		} else if (t instanceof Type.EffectiveTuple) {
diff --git a/modules/wyjc/src/wyjc/runtime/Util.java b/modules/wyjc/src/wyjc/runtime/Util.java
index e9c04cf156..044703ad51 100755
--- a/modules/wyjc/src/wyjc/runtime/Util.java
+++ b/modules/wyjc/src/wyjc/runtime/Util.java
@@ -138,27 +138,6 @@ public static boolean instanceOf(Object obj, WyType t) {
 				}
 				break;
 			}
-			case K_SET:
-			{
-				if(obj instanceof WySet) {
-					WySet ol = (WySet) obj;
-					WyType.Set tl = (WyType.Set) t;
-					WyType el = tl.element;
-					if(el.kind == K_ANY) {
-						return true;
-					} else if(el.kind == K_VOID) {
-						return ol.isEmpty();
-					} else {
-						for(Object elem : ol) {
-							if(!instanceOf(elem,el)) {
-								return false;
-							}
-						}
-						return true;
-					}
-				}
-				break;
-			}
 			case K_TUPLE:
 			{
 				if(obj instanceof WyTuple) {
@@ -176,32 +155,7 @@ public static boolean instanceOf(Object obj, WyType t) {
 					}
 				}
 				break;
-			}
-			case K_MAP:
-			{
-				if(obj instanceof WyMap) {
-					WyMap ol = (WyMap) obj;
-					WyType.Dictionary tl = (WyType.Dictionary) t;
-					WyType key = tl.key;
-					WyType value = tl.value;
-
-					if (key.kind == K_ANY && value.kind == K_ANY) {
-						return true;
-					} else if(key.kind == K_VOID || value.kind == K_VOID) {
-						return ol.isEmpty();
-					} else {
-						for (java.util.Map.Entry<Object, Object> elem : ol
-								.entrySet()) {
-							if (!instanceOf(elem.getKey(), key)
-									|| !instanceOf(elem.getValue(), value)) {
-								return false;
-							}
-						}
-						return true;
-					}
-				}
-				break;
-			}
+			}			
 			case K_RECORD:
 			{
 				if(obj instanceof WyRecord) {
@@ -283,82 +237,6 @@ public static boolean instanceOf(WyList object, WyType type) {
 		}
 	}
 
-	/**
-	 * This method gets called when we're testing a set object against some
-	 * type. To reduce the number of cases, we can narrow down the possible
-	 * types by a process of deduction. The type cannot be <code>void</code> or
-	 * <code>any</code> (since the test would already have been eliminated).
-	 * Likewise, it cannot be e.g. a record, since again the test would already
-	 * have been eliminated. In fact, the type can only be a set or its
-	 * negation.
-	 *
-	 * @param object
-	 *            --- object being tested against.
-	 * @param type
-	 *            --- type to test against.
-	 * @return
-	 */
-	public static boolean instanceOf(WySet object, WyType type) {
-		if(type instanceof WyType.Set) {
-			WyType.Set tl = (WyType.Set) type;
-			WyType el = tl.element;
-			if(el.kind == K_ANY) {
-				return true;
-			} else if(el.kind == K_VOID) {
-				return object.isEmpty();
-			} else {
-				for(Object elem : object) {
-					if(!instanceOf(elem,el)) {
-						return false;
-					}
-				}
-				return true;
-			}
-		} else {
-			return instanceOf((Object)object,type);
-		}
-	}
-
-	/**
-	 * This method gets called when we're testing a dictionary object against some
-	 * type. To reduce the number of cases, we can narrow down the possible
-	 * types by a process of deduction. The type cannot be <code>void</code> or
-	 * <code>any</code> (since the test would already have been eliminated).
-	 * Likewise, it cannot be e.g. a record, since again the test would already
-	 * have been eliminated. In fact, the type can only be a dictionary or its
-	 * negation.
-	 *
-	 * @param object
-	 *            --- object being tested against.
-	 * @param type
-	 *            --- type to test against.
-	 * @return
-	 */
-	public static boolean instanceOf(WyMap object, WyType type) {
-		if(type instanceof WyType.Dictionary) {
-			WyType.Dictionary tl = (WyType.Dictionary) type;
-			WyType key = tl.key;
-			WyType value = tl.value;
-
-			if (key.kind == K_ANY && value.kind == K_ANY) {
-				return true;
-			} else if(key.kind == K_VOID || value.kind == K_VOID) {
-				return object.isEmpty();
-			} else {
-				for (java.util.Map.Entry<Object, Object> elem : object
-						.entrySet()) {
-					if (!instanceOf(elem.getKey(), key)
-							|| !instanceOf(elem.getValue(), value)) {
-						return false;
-					}
-				}
-				return true;
-			}
-		} else {
-			return instanceOf((Object)object,type);
-		}
-	}
-
 	/**
 	 * This method gets called when we're testing a record object against some
 	 * type. To reduce the number of cases, we can narrow down the possible
@@ -451,12 +329,8 @@ public static int compare(Object o1, Object o2) {
 			return compare((BigInteger)o1,o2);
 		} else if(o1 instanceof WyRat) {
 			return compare((WyRat)o1,o2);
-		} else if(o1 instanceof WySet) {
-			return compare((WySet)o1,o2);
 		} else if(o1 instanceof WyList) {
 			return compare((WyList)o1,o2);
-		} else if(o1 instanceof WyMap) {
-			return compare((WyMap)o1,o2);
 		} else if(o1 instanceof WyTuple) {
 			return compare((WyTuple)o1,o2);
 		} else if(o1 instanceof WyRecord) {
@@ -488,45 +362,9 @@ public static int compare(WyRat o1, Object o2) {
 		}
 	}
 
-	public static int compare(WySet o1, Object o2) {
-		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger
-				|| o2 instanceof WyRat) {
-			return 1;
-		} else if (o2 instanceof WySet) {
-			return compare(o1, (WySet) o2);
-		} else {
-			return -1;
-		}
-	}
-
-	public static int compare(WySet o1, WySet o2) {
-		int s1_size = o1.size();
-		int s2_size = o2.size();
-		if(s1_size < s2_size) {
-			return -1;
-		} else if(s1_size > s2_size) {
-			return 1;
-		} else {
-			// this is ugly
-			ArrayList a1 = new ArrayList(o1);
-			ArrayList a2 = new ArrayList(o2);
-			Collections.sort(a1,COMPARATOR);
-			Collections.sort(a2,COMPARATOR);
-			for(int i=0;i!=s1_size;++i) {
-				Object e1 = a1.get(i);
-				Object e2 = a2.get(i);
-				int c = compare(e1,e2);
-				if(c != 0) {
-					return c;
-				}
-			}
-			return 0;
-		}
-	}
-
 	public static int compare(WyList o1, Object o2) {
 		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger
-				|| o2 instanceof WyRat || o2 instanceof WySet) {
+				|| o2 instanceof WyRat) {
 			return 1;
 		} else if (o2 instanceof WyList) {
 			return compare(o1, (WyList) o2);
@@ -557,8 +395,7 @@ public static int compare(WyList o1, WyList o2) {
 
 	public static int compare(WyTuple o1, Object o2) {
 		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger
-				|| o2 instanceof WyRat || o2 instanceof WySet
-				|| o2 instanceof WyList) {
+				|| o2 instanceof WyRat || o2 instanceof WyList) {
 			return 1;
 		} else if (o2 instanceof WyTuple) {
 			return compare(o1, (WyTuple) o2);
@@ -589,8 +426,7 @@ public static int compare(WyTuple o1, WyTuple o2) {
 
 	public static int compare(WyRecord o1, Object o2) {
 		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger
-				|| o2 instanceof WyRat || o2 instanceof WySet
-				|| o2 instanceof WyTuple) {
+				|| o2 instanceof WyRat || o2 instanceof WyTuple) {
 			return 1;
 		} else if (o2 instanceof WyRecord) {
 			return compare(o1, (WyRecord) o2);
diff --git a/modules/wyjc/src/wyjc/runtime/WyCollection.java b/modules/wyjc/src/wyjc/runtime/WyCollection.java
deleted file mode 100755
index efb4a31dc7..0000000000
--- a/modules/wyjc/src/wyjc/runtime/WyCollection.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package wyjc.runtime;
-
-import java.math.BigInteger;
-import java.util.Map;
-
-public class WyCollection {
-
-	public static java.util.Iterator iterator(Object col) {
-		if(col instanceof java.util.Collection) {
-			java.util.Collection c = (java.util.Collection) col;
-			return c.iterator();
-		} else {
-			WyMap m = (WyMap) col;
-			return m.iterator();
-		} 
-	}
-
-	public static BigInteger length(Object col) {
-		if(col instanceof java.util.Collection) {
-			java.util.Collection c = (java.util.Collection) col;
-			return BigInteger.valueOf(c.size());
-		} else {
-			java.util.Map m = (java.util.Map) col;
-			return BigInteger.valueOf(m.size());
-		} 
-	}
-
-	public static Object indexOf(Object col, Object key) {
-		if(col instanceof WyList) {
-			WyList l = (WyList) col;
-			BigInteger index = (BigInteger) key;
-			return l.get(index.intValue());
-		} else  {
-			WyMap d = (WyMap) col;
-			return d.get(key);
-		} 
-	}
-}
diff --git a/modules/wyjc/src/wyjc/runtime/WyMap.java b/modules/wyjc/src/wyjc/runtime/WyMap.java
deleted file mode 100755
index d3b96558ca..0000000000
--- a/modules/wyjc/src/wyjc/runtime/WyMap.java
+++ /dev/null
@@ -1,117 +0,0 @@
-// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//    * Neither the name of the <organization> nor the
-//      names of its contributors may be used to endorse or promote products
-//      derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
-// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-package wyjc.runtime;
-
-import java.math.BigInteger;
-import java.util.*;
-
-public final class WyMap extends java.util.HashMap<Object,Object> implements Iterable {
-	
-	// ================================================================================
-	// Generic Operations
-	// ================================================================================
-
-	public WyMap() {
-
-	}
-
-	WyMap(WyMap dict) {
-		super(dict);		
-	}
-
-	public String toString() {
-		String r = "{";
-		boolean firstTime=true;
-		ArrayList ss = new ArrayList(this.keySet());
-		Collections.sort(ss,Util.COMPARATOR);
-
-		for(Object key : ss) {
-			if(!firstTime) {
-				r = r + ", ";
-			}
-			firstTime=false;
-			Object val = get(key);
-			r = r + whiley.lang.Any$native.toRealString(key) + "=>" + val;
-		}
-		return r + "}";
-	}
-
-	public java.util.Iterator iterator() {
-		return new Iterator(entrySet().iterator());
-	}
-
-	// ================================================================================
-	// Dictionary Operations
-	// ================================================================================
-
-	public static Object get(WyMap dict, Object key) {
-		Object item = dict.get(key);
-		return item;
-	}
-
-	public static WyMap put(WyMap dict, Object key, Object value) {
-		dict = new WyMap(dict); 
-		Object val = dict.put(key, value);		
-		return dict;
-	}
-
-	public static BigInteger length(WyMap dict) {
-		return BigInteger.valueOf(dict.size());
-	}
-
-	public static final class Iterator implements java.util.Iterator {
-		public java.util.Iterator<Map.Entry> iter;
-
-		public Iterator(java.util.Iterator iter) {
-			this.iter = iter;
-		}
-
-		public boolean hasNext() {
-			return iter.hasNext();
-		}
-
-		public void remove(){
-			iter.remove();
-		}
-
-		public Object next() {
-			Map.Entry e = iter.next();
-			return new WyTuple(e.getKey(),e.getValue());
-		}
-	}
-
-	/**
-	 * This method is not intended for public consumption. It is used internally
-	 * by the compiler during imperative updates only.
-	 *
-	 * @param list
-	 * @param item
-	 * @return
-	 */
-	public static Object internal_get(WyMap dict, Object key) {
-		return dict.get(key);
-	}
-}
diff --git a/modules/wyjc/src/wyjc/runtime/WySet.java b/modules/wyjc/src/wyjc/runtime/WySet.java
deleted file mode 100755
index d0b624ccab..0000000000
--- a/modules/wyjc/src/wyjc/runtime/WySet.java
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//    * Redistributions of source code must retain the above copyright
-//      notice, this list of conditions and the following disclaimer.
-//    * Redistributions in binary form must reproduce the above copyright
-//      notice, this list of conditions and the following disclaimer in the
-//      documentation and/or other materials provided with the distribution.
-//    * Neither the name of the <organization> nor the
-//      names of its contributors may be used to endorse or promote products
-//      derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
-// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-package wyjc.runtime;
-
-import java.math.BigInteger;
-import java.util.*;
-
-
-public final class WySet extends java.util.HashSet {
-	
-	// ================================================================================
-	// Generic Operations
-	// ================================================================================
-
-	public WySet() {
-
-	}
-
-	private WySet(java.util.Collection items) {
-		super(items);		
-	}
-
-	public String toString() {
-		String r = "{";
-		boolean firstTime=true;
-		ArrayList ss = new ArrayList(this);
-		Collections.sort(ss,Util.COMPARATOR);
-
-		for(Object o : ss) {
-			if(!firstTime) {
-				r = r + ", ";
-			}
-			firstTime=false;
-			r = r + whiley.lang.Any$native.toRealString(o);
-		}
-		return r + "}";
-	}
-
-	// ================================================================================
-	// Set Operations
-	// ================================================================================
-
-	public static boolean subset(WySet lhs, WySet rhs) {
-		return rhs.containsAll(lhs) && rhs.size() > lhs.size();
-	}
-
-	public static boolean subsetEq(WySet lhs, WySet rhs) {
-		return rhs.containsAll(lhs);
-	}
-
-	public static WySet union(WySet lhs, WySet rhs) {
-		lhs = new WySet(lhs);
-		lhs.addAll(rhs);		
-		return lhs;
-	}
-
-	public static WySet union(WySet lhs, Object rhs) {
-		lhs = new WySet(lhs);
-		lhs.add(rhs);
-		return lhs;
-	}
-
-	public static WySet union(Object lhs, WySet rhs) {
-		rhs = new WySet(rhs);
-		rhs.add(lhs);
-		return rhs;
-	}
-
-	public static WySet difference(WySet lhs, WySet rhs) {
-		lhs = new WySet(lhs);
-		lhs.removeAll(rhs);		
-		return lhs;
-	}
-
-	public static WySet difference(WySet lhs, Object rhs) {
-		lhs = new WySet(lhs);
-		lhs.remove(rhs);
-		return lhs;
-	}
-
-	public static WySet intersect(WySet lhs, WySet rhs) {
-		lhs = new WySet(lhs);
-		lhs.retainAll(rhs);
-		return lhs;
-	}
-
-	public static BigInteger length(WySet set) {
-		return BigInteger.valueOf(set.size());
-	}
-
-	/**
-	 * This method is not intended for public consumption. It is used internally
-	 * by the compiler during object construction only.
-	 *
-	 * @param list
-	 * @param item
-	 * @return
-	 */
-	public static WySet internal_add(WySet lhs, Object rhs) {
-		lhs.add(rhs);
-		return lhs;
-	}
-}
diff --git a/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java b/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java
index 64398131d5..55ca0c4b7f 100755
--- a/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java
+++ b/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java
@@ -388,16 +388,6 @@ public void Coercion_Valid_3() {
 		runTest("Coercion_Valid_3");
 	}
 
-	@Test
-	public void Coercion_Valid_4() {
-		runTest("Coercion_Valid_4");
-	}
-
-	@Test
-	public void Coercion_Valid_6() {
-		runTest("Coercion_Valid_6");
-	}
-
 	@Test
 	public void Coercion_Valid_7() {
 		runTest("Coercion_Valid_7");
@@ -458,16 +448,6 @@ public void Constant_Valid_3() {
 		runTest("Constant_Valid_3");
 	}
 
-	@Test
-	public void ConstrainedDictionary_Valid_1() {
-		runTest("ConstrainedDictionary_Valid_1");
-	}
-
-	@Test
-	public void ConstrainedDictionary_Valid_2() {
-		runTest("ConstrainedDictionary_Valid_2");
-	}
-	
 	@Test
 	public void ConstrainedInt_Valid_1() {
 		runTest("ConstrainedInt_Valid_1");
@@ -488,11 +468,6 @@ public void ConstrainedInt_Valid_13() {
 		runTest("ConstrainedInt_Valid_13");
 	}
 
-	@Test
-	public void ConstrainedInt_Valid_14() {
-		runTest("ConstrainedInt_Valid_14");
-	}
-
 	@Test
 	public void ConstrainedInt_Valid_15() {
 		runTest("ConstrainedInt_Valid_15");
@@ -648,11 +623,6 @@ public void ConstrainedList_Valid_23() {
 		runTest("ConstrainedList_Valid_23");
 	}
 
-	@Test
-	public void ConstrainedList_Valid_24() {
-		runTest("ConstrainedList_Valid_24");
-	}
-
 	@Test
 	public void ConstrainedList_Valid_25() {
 		runTest("ConstrainedList_Valid_25");
@@ -763,51 +733,6 @@ public void ConstrainedReference_Valid_1() {
 		runTest("ConstrainedReference_Valid_1");
 	}
 	
-	@Test
-	public void ConstrainedSet_Valid_1() {
-		runTest("ConstrainedSet_Valid_1");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_2() {
-		runTest("ConstrainedSet_Valid_2");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_3() {
-		runTest("ConstrainedSet_Valid_3");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_4() {
-		runTest("ConstrainedSet_Valid_4");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_5() {
-		runTest("ConstrainedSet_Valid_5");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_6() {
-		runTest("ConstrainedSet_Valid_6");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_7() {
-		runTest("ConstrainedSet_Valid_7");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_8() {
-		runTest("ConstrainedSet_Valid_8");
-	}
-
-	@Test
-	public void ConstrainedSet_Valid_9() {
-		runTest("ConstrainedSet_Valid_9");
-	}
-	
 	@Test
 	public void ConstrainedTuple_Valid_1() {
 		runTest("ConstrainedTuple_Valid_1");
@@ -858,86 +783,6 @@ public void Define_Valid_4() {
 		runTest("Define_Valid_4");
 	}
 
-	@Test
-	public void Dictionary_Valid_1() {
-		runTest("Dictionary_Valid_1");
-	}
-
-	@Test
-	public void Dictionary_Valid_10() {
-		runTest("Dictionary_Valid_10");
-	}
-
-	@Test
-	public void Dictionary_Valid_11() {
-		runTest("Dictionary_Valid_11");
-	}
-
-	@Test
-	public void Dictionary_Valid_12() {
-		runTest("Dictionary_Valid_12");
-	}
-
-	@Test
-	public void Dictionary_Valid_13() {
-		runTest("Dictionary_Valid_13");
-	}
-
-	@Test
-	public void Dictionary_Valid_14() {
-		runTest("Dictionary_Valid_14");
-	}
-
-	@Test
-	public void Dictionary_Valid_15() {
-		runTest("Dictionary_Valid_15");
-	}
-
-	@Test
-	public void Dictionary_Valid_16() {
-		runTest("Dictionary_Valid_16");
-	}
-
-	@Test
-	public void Dictionary_Valid_2() {
-		runTest("Dictionary_Valid_2");
-	}
-
-	@Test
-	public void Dictionary_Valid_3() {
-		runTest("Dictionary_Valid_3");
-	}
-
-	@Test
-	public void Dictionary_Valid_4() {
-		runTest("Dictionary_Valid_4");
-	}
-
-	@Test
-	public void Dictionary_Valid_5() {
-		runTest("Dictionary_Valid_5");
-	}
-
-	@Test
-	public void Dictionary_Valid_6() {
-		runTest("Dictionary_Valid_6");
-	}
-
-	@Test
-	public void Dictionary_Valid_7() {
-		runTest("Dictionary_Valid_7");
-	}
-
-	@Test
-	public void Dictionary_Valid_8() {
-		runTest("Dictionary_Valid_8");
-	}
-
-	@Test
-	public void Dictionary_Valid_9() {
-		runTest("Dictionary_Valid_9");
-	}
-
 	@Test
 	public void DoWhile_Valid_1() {
 		runTest("DoWhile_Valid_1");
@@ -1028,16 +873,6 @@ public void For_Valid_11() {
 		runTest("For_Valid_11");
 	}
 
-	@Test
-	public void For_Valid_12() {
-		runTest("For_Valid_12");
-	}
-
-	@Test
-	public void For_Valid_13() {
-		runTest("For_Valid_13");
-	}
-
 	@Test
 	public void For_Valid_14() {
 		runTest("For_Valid_14");
@@ -1077,12 +912,7 @@ public void For_Valid_19() {
 	public void For_Valid_2() {
 		runTest("For_Valid_2");
 	}
-
-	@Test
-	public void For_Valid_3() {
-		runTest("For_Valid_3");
-	}
-
+	
 	@Test
 	public void For_Valid_4() {
 		runTest("For_Valid_4");
@@ -1163,11 +993,6 @@ public void Function_Valid_1() {
 		runTest("Function_Valid_1");
 	}
 
-	@Test
-	public void Function_Valid_10() {
-		runTest("Function_Valid_10");
-	}
-
 	@Test
 	public void Function_Valid_12() {
 		runTest("Function_Valid_12");
@@ -1198,11 +1023,6 @@ public void Function_Valid_18() {
 		runTest("Function_Valid_18");
 	}
 
-	@Test
-	public void Function_Valid_19() {
-		runTest("Function_Valid_19");
-	}
-
 	@Test
 	public void Function_Valid_2() {
 		runTest("Function_Valid_2");
@@ -1426,16 +1246,6 @@ public void LengthOf_Valid_1() {
 		runTest("LengthOf_Valid_1");
 	}
 
-	@Test
-	public void LengthOf_Valid_2() {
-		runTest("LengthOf_Valid_2");
-	}
-
-	@Test
-	public void LengthOf_Valid_3() {
-		runTest("LengthOf_Valid_3");
-	}
-
 	@Test
 	public void LengthOf_Valid_4() {
 		runTest("LengthOf_Valid_4");
@@ -2176,11 +1986,6 @@ public void RecursiveType_Valid_28() {
 		runTest("RecursiveType_Valid_28");
 	}
 
-	@Test
-	public void RecursiveType_Valid_29() {
-		runTest("RecursiveType_Valid_29");
-	}
-
 	@Ignore("#406") @Test
 	public void RecursiveType_Valid_3() {
 		runTest("RecursiveType_Valid_3");
@@ -2191,11 +1996,6 @@ public void RecursiveType_Valid_30() {
 		runTest("RecursiveType_Valid_30");
 	}
 
-	@Test
-	public void RecursiveType_Valid_31() {
-		runTest("RecursiveType_Valid_31");
-	}
-
 	@Ignore("#406") @Test
 	public void RecursiveType_Valid_4() {
 		runTest("RecursiveType_Valid_4");
@@ -2266,236 +2066,6 @@ public void Resolution_Valid_1() {
 		runTest("Resolution_Valid_1");
 	}
 
-	@Test
-	public void SetAssign_Valid_1() {
-		runTest("SetAssign_Valid_1");
-	}
-
-	@Test
-	public void SetAssign_Valid_2() {
-		runTest("SetAssign_Valid_2");
-	}
-
-	@Test
-	public void SetAssign_Valid_3() {
-		runTest("SetAssign_Valid_3");
-	}
-
-	@Test
-	public void SetConversion_Valid_1() {
-		runTest("SetConversion_Valid_1");
-	}
-
-	@Test
-	public void SetDefine_Valid_1() {
-		runTest("SetDefine_Valid_1");
-	}
-
-	@Test
-	public void SetDefine_Valid_2() {
-		runTest("SetDefine_Valid_2");
-	}
-
-	@Test
-	public void SetDefine_Valid_3() {
-		runTest("SetDefine_Valid_3");
-	}
-
-	@Test
-	public void SetDifference_Valid_1() {
-		runTest("SetDifference_Valid_1");
-	}
-
-	@Test
-	public void SetElemOf_Valid_1() {
-		runTest("SetElemOf_Valid_1");
-	}
-
-	@Test
-	public void SetEmpty_Valid_1() {
-		runTest("SetEmpty_Valid_1");
-	}
-
-	@Test
-	public void SetEquals_Valid_1() {
-		runTest("SetEquals_Valid_1");
-	}
-
-	@Test
-	public void SetGenerator_Valid_1() {
-		runTest("SetGenerator_Valid_1");
-	}
-
-	@Test
-	public void SetIntersect_Valid_1() {
-		runTest("SetIntersect_Valid_1");
-	}
-
-	@Test
-	public void SetIntersect_Valid_2() {
-		runTest("SetIntersect_Valid_2");
-	}
-
-	@Test
-	public void SetIntersection_Valid_1() {
-		runTest("SetIntersection_Valid_1");
-	}
-
-	@Test
-	public void SetIntersection_Valid_2() {
-		runTest("SetIntersection_Valid_2");
-	}
-
-	@Test
-	public void SetIntersection_Valid_3() {
-		runTest("SetIntersection_Valid_3");
-	}
-
-	@Test
-	public void SetIntersection_Valid_4() {
-		runTest("SetIntersection_Valid_4");
-	}
-
-	@Test
-	public void SetIntersection_Valid_5() {
-		runTest("SetIntersection_Valid_5");
-	}
-
-	@Test
-	public void SetIntersection_Valid_6() {
-		runTest("SetIntersection_Valid_6");
-	}
-
-	@Test
-	public void SetIntersection_Valid_7() {
-		runTest("SetIntersection_Valid_7");
-	}
-
-	@Test
-	public void SetLength_Valid_1() {
-		runTest("SetLength_Valid_1");
-	}
-
-	@Test
-	public void SetNull_Valid_1() {
-		runTest("SetNull_Valid_1");
-	}
-
-	@Test
-	public void SetSubset_Valid_1() {
-		runTest("SetSubset_Valid_1");
-	}
-
-	@Test
-	public void SetSubset_Valid_10() {
-		runTest("SetSubset_Valid_10");
-	}
-
-	@Test
-	public void SetSubset_Valid_11() {
-		runTest("SetSubset_Valid_11");
-	}
-
-	@Test
-	public void SetSubset_Valid_12() {
-		runTest("SetSubset_Valid_12");
-	}
-
-	@Test
-	public void SetSubset_Valid_2() {
-		runTest("SetSubset_Valid_2");
-	}
-
-	@Test
-	public void SetSubset_Valid_3() {
-		runTest("SetSubset_Valid_3");
-	}
-
-	@Test
-	public void SetSubset_Valid_4() {
-		runTest("SetSubset_Valid_4");
-	}
-
-	@Test
-	public void SetSubset_Valid_5() {
-		runTest("SetSubset_Valid_5");
-	}
-
-	@Test
-	public void SetSubset_Valid_6() {
-		runTest("SetSubset_Valid_6");
-	}
-
-	@Test
-	public void SetSubset_Valid_7() {
-		runTest("SetSubset_Valid_7");
-	}
-
-	@Test
-	public void SetSubset_Valid_8() {
-		runTest("SetSubset_Valid_8");
-	}
-
-	@Test
-	public void SetSubset_Valid_9() {
-		runTest("SetSubset_Valid_9");
-	}
-
-	@Test
-	public void SetUnion_Valid_1() {
-		runTest("SetUnion_Valid_1");
-	}
-
-	@Test
-	public void SetUnion_Valid_10() {
-		runTest("SetUnion_Valid_10");
-	}
-
-	@Test
-	public void SetUnion_Valid_11() {
-		runTest("SetUnion_Valid_11");
-	}
-
-	@Test
-	public void SetUnion_Valid_2() {
-		runTest("SetUnion_Valid_2");
-	}
-
-	@Test
-	public void SetUnion_Valid_3() {
-		runTest("SetUnion_Valid_3");
-	}
-
-	@Test
-	public void SetUnion_Valid_4() {
-		runTest("SetUnion_Valid_4");
-	}
-
-	@Test
-	public void SetUnion_Valid_5() {
-		runTest("SetUnion_Valid_5");
-	}
-
-	@Test
-	public void SetUnion_Valid_6() {
-		runTest("SetUnion_Valid_6");
-	}
-
-	@Test
-	public void SetUnion_Valid_7() {
-		runTest("SetUnion_Valid_7");
-	}
-
-	@Test
-	public void SetUnion_Valid_8() {
-		runTest("SetUnion_Valid_8");
-	}
-
-	@Test
-	public void SetUnion_Valid_9() {
-		runTest("SetUnion_Valid_9");
-	}
-
 	@Test
 	public void SingleLineComment_Valid_1() {
 		runTest("SingleLineComment_Valid_1");
@@ -2746,11 +2316,6 @@ public void TypeEquals_Valid_12() {
 		runTest("TypeEquals_Valid_12");
 	}
 
-	@Test
-	public void TypeEquals_Valid_13() {
-		runTest("TypeEquals_Valid_13");
-	}
-
 	@Test
 	public void TypeEquals_Valid_14() {
 		runTest("TypeEquals_Valid_14");
@@ -2796,11 +2361,6 @@ public void TypeEquals_Valid_21() {
 		runTest("TypeEquals_Valid_21");
 	}
 
-	@Test
-	public void TypeEquals_Valid_22() {
-		runTest("TypeEquals_Valid_22");
-	}
-
 	@Ignore("Issue ???") @Test
 	public void TypeEquals_Valid_23() {
 		runTest("TypeEquals_Valid_23");
@@ -2816,11 +2376,6 @@ public void TypeEquals_Valid_25() {
 		runTest("TypeEquals_Valid_25");
 	}
 
-	@Test
-	public void TypeEquals_Valid_26() {
-		runTest("TypeEquals_Valid_26");
-	}
-
 	@Test
 	public void TypeEquals_Valid_27() {
 		runTest("TypeEquals_Valid_27");
diff --git a/tests/valid/ConstrainedInt_Valid_10.whiley b/tests/valid/ConstrainedInt_Valid_10.whiley
index b62591d4af..e04d39fec1 100755
--- a/tests/valid/ConstrainedInt_Valid_10.whiley
+++ b/tests/valid/ConstrainedInt_Valid_10.whiley
@@ -2,14 +2,14 @@
 
 type nat is (int x) where x > 0
 
-type num is (int x) where x in {1, 2, 3, 4}
+type num is (int x) where 1 <= x && x <= 4
 
 function f(num x) -> int:
     int y = x
     return y
 
 function g(int x, nat z) -> int
-requires ((x == 1) || (x == 2)) && (z in {1, 2, 3, x}):
+requires ((x == 1) || (x == 2)) && (z == 1 || z == 2 || z == 3 || z == x):
     return f(z)
 
 public export method test() -> void:
diff --git a/tests/valid/ConstrainedInt_Valid_13.whiley b/tests/valid/ConstrainedInt_Valid_13.whiley
index f1846ce083..2dc142aa16 100755
--- a/tests/valid/ConstrainedInt_Valid_13.whiley
+++ b/tests/valid/ConstrainedInt_Valid_13.whiley
@@ -1,6 +1,4 @@
-
-
-type codeOp is (int x) where x in {1, 2, 3, 4}
+type codeOp is (int x) where 1 <= x && x <= 4
 
 type code is {codeOp op, [int] payload}
 
diff --git a/tests/valid/ConstrainedInt_Valid_14.whiley b/tests/valid/ConstrainedInt_Valid_14.whiley
deleted file mode 100755
index 7fabbda9ce..0000000000
--- a/tests/valid/ConstrainedInt_Valid_14.whiley
+++ /dev/null
@@ -1,12 +0,0 @@
-
-
-type codeOp is (int x) where x in {1, 2, 3, 4}
-
-type code is {codeOp op, [int] payload}
-
-function f(code x) -> int:
-    int y = x.op
-    return y
-
-public export method test() -> void:
-    assume f({op: 1, payload: [1]}) == 1
diff --git a/tests/valid/ConstrainedInt_Valid_16.whiley b/tests/valid/ConstrainedInt_Valid_16.whiley
index 83eea9f036..4f6163ea74 100755
--- a/tests/valid/ConstrainedInt_Valid_16.whiley
+++ b/tests/valid/ConstrainedInt_Valid_16.whiley
@@ -1,10 +1,7 @@
+constant odd is [1,3,5]
 
-
-constant odd is {1,3,5}
-
-type odd is (int x) where x in odd
-
-type even is (int x) where x in {2, 4, 6}
+type odd is (int x) where x == 1 || x == 3 || x == 5
+type even is (int x) where x == 2 || x == 4 || x == 6
 
 type oddeven is odd|even
 
diff --git a/tests/valid/ConstrainedInt_Valid_23.whiley b/tests/valid/ConstrainedInt_Valid_23.whiley
index 87b3fb52e5..2136ff07c7 100755
--- a/tests/valid/ConstrainedInt_Valid_23.whiley
+++ b/tests/valid/ConstrainedInt_Valid_23.whiley
@@ -1,6 +1,4 @@
-
-
-type cr2num is (int x) where x in {1, 2, 3, 4}
+type cr2num is (int x) where 1 <= x && x <= 4
 
 function f(cr2num x) -> int:
     int y = x
diff --git a/tests/valid/Ensures_Valid_3.whiley b/tests/valid/Ensures_Valid_3.whiley
index fb543a855e..08a7eb8a99 100755
--- a/tests/valid/Ensures_Valid_3.whiley
+++ b/tests/valid/Ensures_Valid_3.whiley
@@ -1,24 +1,24 @@
 
 
-function pred({int} xs) -> (bool b)
+function pred([int] xs) -> (bool b)
 ensures b ==> no { z in xs | z < 0 }:
     //
-    {int} zs = {}
+    [int] zs = []
     for y in xs:
         if y < 0:
-            zs = zs + {y}
+            zs = zs ++ [y]
     return |zs| == 0
 
-function countOver({int} xs, int y) -> int
+function countOver([int] xs, int y) -> int
 requires pred(xs):
-    {int} tmp = {}
+    [int] tmp = []
     for x in xs:
         if x > y:
-            tmp = tmp + {x}
+            tmp = tmp ++ [x]
     return |tmp|
 
 public export method test() -> void:
-    int c1 = countOver({1, 2, 3, 4}, 1)
-    int c2 = countOver({1, 2, 3, 4}, 3)
+    int c1 = countOver([1, 2, 3, 4], 1)
+    int c2 = countOver([1, 2, 3, 4], 3)
     assume c1 == 3
     assume c2 == 1
diff --git a/tests/valid/For_Valid_6.whiley b/tests/valid/For_Valid_6.whiley
deleted file mode 100755
index a5ab48cab5..0000000000
--- a/tests/valid/For_Valid_6.whiley
+++ /dev/null
@@ -1,14 +0,0 @@
-
-
-function select({int} xs) -> (int r)
-// Input list cannot be empty
-requires |xs| > 0
-// Returned value must be in input
-ensures r in xs:
-    //
-    for x in xs:
-        return x
-    return 0
-
-public export method test() -> void:
-    assume select({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 1
diff --git a/tests/valid/Function_Valid_6.whiley b/tests/valid/Function_Valid_6.whiley
index 4c6b4bccb0..b5dcc31f6b 100755
--- a/tests/valid/Function_Valid_6.whiley
+++ b/tests/valid/Function_Valid_6.whiley
@@ -1,17 +1,15 @@
-
-
 type fr5nat is (int x) where x >= 0
 
-function g({fr5nat} xs) -> {fr5nat}:
-    {fr5nat} ys = {}
+function g([fr5nat] xs) -> [fr5nat]:
+    [fr5nat] ys = []
     for y in xs:
         if y > 1:
-            ys = ys + {y}
+            ys = ys ++ [y]
     return ys
 
-function f({fr5nat} x) -> {int}:
+function f([fr5nat] x) -> [int]:
     return x
 
 public export method test() -> void:
-    {int} ys = {1, 2, 3}
-    assume f(g(ys)) == {2, 3}
+    [int] ys = [1, 2, 3]
+    assume f(g(ys)) == [2, 3]
diff --git a/tests/valid/Function_Valid_7.whiley b/tests/valid/Function_Valid_7.whiley
index ff13f062bd..d78bb1dd59 100755
--- a/tests/valid/Function_Valid_7.whiley
+++ b/tests/valid/Function_Valid_7.whiley
@@ -1,17 +1,15 @@
-
-
 type fr5nat is int
 
-function g({fr5nat} xs) -> {fr5nat}:
-    {fr5nat} ys = {}
+function g([fr5nat] xs) -> [fr5nat]:
+    [fr5nat] ys = []
     for y in xs:
         if y > 1:
-            ys = ys + {y}
+            ys = ys ++ [y]
     return ys
 
-function f({fr5nat} x) -> {int}:
+function f([fr5nat] x) -> [int]:
     return x
 
 public export method test() -> void:
-    {int} ys = {1, 2, 3}
-    assume f(g(ys)) == {2, 3}
+    [int] ys = [1, 2, 3]
+    assume f(g(ys)) == [2, 3]
diff --git a/tests/valid/Function_Valid_8.whiley b/tests/valid/Function_Valid_8.whiley
index 0862757fe0..69eb4cc370 100755
--- a/tests/valid/Function_Valid_8.whiley
+++ b/tests/valid/Function_Valid_8.whiley
@@ -1,18 +1,16 @@
-
-
 type fr6nat is (int x) where x >= 0
 
-function g({fr6nat} xs) -> {fr6nat}:
-    {fr6nat} ys = {}
+function g([fr6nat] xs) -> [fr6nat]:
+    [fr6nat] ys = []
     for y in xs:
         if y > 1:
-            ys = ys + {y}
+            ys = ys ++ [y]
     return ys
 
-function f({int} x) -> {int}:
+function f([int] x) -> [int]:
     return x
 
 public export method test() -> void:
-    {int} ys = {1, 2, 3}
-    assume f(g(ys)) == {2, 3}
+    [int] ys = [1, 2, 3]
+    assume f(g(ys)) == [2, 3]
 
diff --git a/tests/valid/Function_Valid_9.whiley b/tests/valid/Function_Valid_9.whiley
index cd83b87039..4ad310159e 100755
--- a/tests/valid/Function_Valid_9.whiley
+++ b/tests/valid/Function_Valid_9.whiley
@@ -1,18 +1,16 @@
-
-
 type fr6nat is int
 
-function g({fr6nat} xs) -> {fr6nat}:
-    {fr6nat} ys = {}
+function g([fr6nat] xs) -> [fr6nat]:
+    [fr6nat] ys = []
     for y in xs:
         if y > 1:
-            ys = ys + {y}
+            ys = ys ++ [y]
     return ys
 
-function f({int} x) -> {int}:
+function f([int] x) -> [int]:
     return x
 
 public export method test() -> void:
-    {int} ys = {-12309812, 1, 2, 2987, 2349872, 234987234987, 234987234987234}
-    assume f(g(ys)) == {2, 2987, 2349872, 234987234987, 234987234987234}
+    [int] ys = [-12309812, 1, 2, 2987, 2349872, 234987234987, 234987234987234]
+    assume f(g(ys)) == [2, 2987, 2349872, 234987234987, 234987234987234]
 
diff --git a/tests/valid/ListAssign_Valid_4.whiley b/tests/valid/ListAssign_Valid_4.whiley
index 84cf7e8698..d3ead6a2d4 100755
--- a/tests/valid/ListAssign_Valid_4.whiley
+++ b/tests/valid/ListAssign_Valid_4.whiley
@@ -1,5 +1,3 @@
-
-
 constant PAWN is 0
 
 constant KNIGHT is 1
@@ -12,7 +10,7 @@ constant QUEEN is 4
 
 constant KING is 5
 
-type PieceKind is (int x) where x in {PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING}
+type PieceKind is (int x) where PAWN <= x && x <= KING
 
 type Piece is {bool colour, PieceKind kind}
 
diff --git a/tests/valid/OpenRecord_Valid_2.whiley b/tests/valid/OpenRecord_Valid_2.whiley
index 01bf219c42..90d9f742b7 100755
--- a/tests/valid/OpenRecord_Valid_2.whiley
+++ b/tests/valid/OpenRecord_Valid_2.whiley
@@ -6,7 +6,7 @@ constant Int is 4
 type string is [int]
 type char is int
 
-type Primitive is (int x) where x in {Short, Int}
+type Primitive is (int x) where x == Short || x == Int
 
 type Class is {[string] classes, string pkg}
 
diff --git a/tests/valid/RecursiveType_Valid_7.whiley b/tests/valid/RecursiveType_Valid_7.whiley
index 426d23cac9..afc9c325b0 100755
--- a/tests/valid/RecursiveType_Valid_7.whiley
+++ b/tests/valid/RecursiveType_Valid_7.whiley
@@ -19,7 +19,7 @@ constant T_INT is 10
 
 constant T_LONG is 11
 
-type primitive_t is (int x) where x in {T_BOOLEAN, T_CHAR, T_FLOAT, T_DOUBLE, T_BYTE, T_SHORT, T_INT, T_LONG}
+type primitive_t is (int x) where T_BOOLEAN <= x && x <= T_LONG
 
 type array_t is {jvm_t element}
 
diff --git a/tests/valid/Switch_Valid_4.whiley b/tests/valid/Switch_Valid_4.whiley
index 0625dbddf7..a9bc575ff9 100755
--- a/tests/valid/Switch_Valid_4.whiley
+++ b/tests/valid/Switch_Valid_4.whiley
@@ -6,7 +6,7 @@ constant Blue is 2
 
 constant Green is 3
 
-type RGB is (int x) where x in {Red, Blue, Green}
+type RGB is (int x) where x == Red || x == Blue || x == Green
 
 function f(RGB c) -> int:
     switch c:
diff --git a/tests/valid/Update_Valid_1.whiley b/tests/valid/Update_Valid_1.whiley
deleted file mode 100755
index 9892fd1dab..0000000000
--- a/tests/valid/Update_Valid_1.whiley
+++ /dev/null
@@ -1,15 +0,0 @@
-
-
-type listdict is [int] | {int=>int}
-
-function update(listdict l, int index, int value) -> listdict:
-    l[index] = value
-    return l
-
-public export method test() -> void:
-    l = [1, 2, 3]
-    assume update(l, 1, 0) == [1,0,3]
-    assume update(l, 2, 0) == [1,2,0]
-    l = {1=>1, 2=>2, 3=>3}
-    assume update(l, 1, 0) == {1=>0, 2=>2, 3=>3}
-    assume update(l, 2, 0) == {1=>10, 2=>0, 3=>3}
