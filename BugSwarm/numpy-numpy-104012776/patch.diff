diff --git a/.gitignore b/.gitignore
index 72d31d74cd6..e6a05386e6a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,7 @@
 *.iws
 *.org
 .project
+pmip
 *.rej
 .settings/
 .*.sw[nop]
diff --git a/numpy/core/src/private/npy_config.h b/numpy/core/src/private/npy_config.h
index eb9c1e19d34..3d147060965 100644
--- a/numpy/core/src/private/npy_config.h
+++ b/numpy/core/src/private/npy_config.h
@@ -70,17 +70,13 @@
 #endif /* defined(_MSC_VER) && defined(__INTEL_COMPILER) */
 
 
-/* Disable broken gnu trig functions on linux */
-#if defined(__linux__) && defined(__GNUC__)
-
+/* Disable broken gnu trig functions */
 #if defined(HAVE_FEATURES_H)
 #include <features.h>
-#define TRIG_OK __GLIBC_PREREQ(2, 16)
-#else
-#define TRIG_OK 0
-#endif
 
-#if !TRIG_OK
+#if defined(__GLIBC__)
+#if !__GLIBC_PREREQ(2, 16)
+
 #undef HAVE_CASIN
 #undef HAVE_CASINF
 #undef HAVE_CASINL
@@ -99,9 +95,10 @@
 #undef HAVE_CACOSH
 #undef HAVE_CACOSHF
 #undef HAVE_CACOSHL
-#endif
-#undef TRIG_OK
 
-#endif /* defined(__linux__) && defined(__GNUC__) */
+#endif /* __GLIBC_PREREQ(2, 16) */
+#endif /* defined(__GLIBC_PREREQ) */
+
+#endif /* defined(HAVE_FEATURES_H) */
 
 #endif
diff --git a/numpy/random/mtrand/mtrand.pyx b/numpy/random/mtrand/mtrand.pyx
index 2f315c5d37f..8a5b364df82 100644
--- a/numpy/random/mtrand/mtrand.pyx
+++ b/numpy/random/mtrand/mtrand.pyx
@@ -572,23 +572,57 @@ def _rand_bool(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
+    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
     cdef npy_bool off, rng, buf
+    cdef npy_bool *array_data
     cdef npy_bool *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
-    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
 
-    rng = <npy_bool>(high - low)
-    off = <npy_bool>(low)
-    if size is None:
-        rk_random_bool(off, rng, 1, &buf, state)
-        return buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_bool>(high - low)
+        off = <npy_bool>(<npy_bool>low)
+
+        if size is None:
+            rk_random_bool(off, rng, 1, &buf, state)
+            return <npy_bool>buf
+        else:
+            array = <ndarray>np.empty(size, np.bool_)
+            cnt = PyArray_SIZE(array)
+            out = <npy_bool *>PyArray_DATA(array)
+            with nogil:
+                rk_random_bool(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.bool_)
-        cnt = PyArray_SIZE(array)
-        out = <npy_bool *>PyArray_DATA(array)
-        with nogil:
-            rk_random_bool(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.bool_)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.bool_)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_bool *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_bool>(int(high_data) - int(low_data))
+            off = <npy_bool>(<npy_bool>low_data)
+
+            rk_random_bool(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
@@ -599,23 +633,57 @@ def _rand_int8(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
+    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
     cdef npy_uint8 off, rng, buf
+    cdef npy_uint8 *array_data
     cdef npy_uint8 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
-    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
 
-    rng = <npy_uint8>(high - low)
-    off = <npy_uint8>(<npy_int8>low)
-    if size is None:
-        rk_random_uint8(off, rng, 1, &buf, state)
-        return <npy_int8>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint8>(high - low)
+        off = <npy_uint8>(<npy_int8>low)
+
+        if size is None:
+            rk_random_uint8(off, rng, 1, &buf, state)
+            return <npy_int8>buf
+        else:
+            array = <ndarray>np.empty(size, np.int8)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint8 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint8(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.int8)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint8 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint8(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.int8)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.int8)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint8 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint8>(int(high_data) - int(low_data))
+            off = <npy_uint8>(<npy_int8>low_data)
+
+            rk_random_uint8(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
@@ -626,74 +694,149 @@ def _rand_int16(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
+    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
     cdef npy_uint16 off, rng, buf
+    cdef npy_uint16 *array_data
     cdef npy_uint16 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
-    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
 
-    rng = <npy_uint16>(high - low)
-    off = <npy_uint16>(<npy_int16>low)
-    if size is None:
-        rk_random_uint16(off, rng, 1, &buf, state)
-        return <npy_int16>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint16>(high - low)
+        off = <npy_uint16>(<npy_int16>low)
+
+        if size is None:
+            rk_random_uint16(off, rng, 1, &buf, state)
+            return <npy_int16>buf
+        else:
+            array = <ndarray>np.empty(size, np.int16)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint16 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint16(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.int16)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint16 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint16(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.int16)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.int16)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint16 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint16>(int(high_data) - int(low_data))
+            off = <npy_uint16>(<npy_int16>low_data)
+
+            rk_random_uint16(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
 def _rand_int32(low, high, size, rngstate):
     """
-    _rand_int32(self, low, high, size, rngstate)
+    _rand_int32(low, high, size, rngstate)
 
-    Return random np.int32 integers between `low` and `high`, inclusive.
+    Return an array of random np.int32 integers between ``lo`` and ``hi``
+    inclusive for each ``lo``, ``hi`` pair in ``low`` and ``high``, where
+    the `low` and `high` arguments are broadcast.
 
     Return random integers from the "discrete uniform" distribution in the
-    closed interval [`low`, `high`]. On entry the arguments are presumed
-    to have been validated for size and order for the np.int32 type.
+    closed interval [``lo``, ``high``] for each ``lo``, ``hi`` pair in
+    `low` and `high`. On entry the arguments are presumed to have been
+    validated for size and order for the np.int32 type.
 
     Parameters
     ----------
-    low : int
-        Lowest (signed) integer to be drawn from the distribution.
-    high : int
-        Highest (signed) integer to be drawn from the distribution.
+    low : array_like
+        An array of integers, each of which serves as the lowest (signed)
+        integer to be drawn from the distribution.
+    high : array_like
+        An array of integers, each of which serves as the highest (signed)
+        integer to be drawn from the distribution.
     size : int or tuple of ints
         Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
-        ``m * n * k`` samples are drawn.  Default is None, in which case a
-        single value is returned.
+        ``m * n * k`` samples are drawn, so as long as the shape is compatible
+        with the size of `low` and `high`.  Default is None, in which case an
+        array corresponding to the shape of the `low` and `high` is returned.
     rngstate : encapsulated pointer to rk_state
         The specific type depends on the python version. In Python 2 it is
         a PyCObject, in Python 3 a PyCapsule object.
 
     Returns
     -------
-    out : python scalar or ndarray of np.int32
+    out : python ndarray of np.int32
           `size`-shaped array of random integers from the appropriate
-          distribution, or a single such random int if `size` not provided.
+          distribution, or an array corresponding to the shapes of
+          `low` and `high`.
 
     """
+    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
     cdef npy_uint32 off, rng, buf
+    cdef npy_uint32 *array_data
     cdef npy_uint32 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
-    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
 
-    rng = <npy_uint32>(high - low)
-    off = <npy_uint32>(<npy_int32>low)
-    if size is None:
-        rk_random_uint32(off, rng, 1, &buf, state)
-        return <npy_int32>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint32>(high - low)
+        off = <npy_uint32>(<npy_int32>low)
+
+        if size is None:
+            rk_random_uint32(off, rng, 1, &buf, state)
+            return <npy_int32>buf
+        else:
+            array = <ndarray>np.empty(size, np.int32)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint32 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint32(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.int32)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint32 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint32(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.int32)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.int32)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint32 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint32>(int(high_data) - int(low_data))
+            off = <npy_uint32>(<npy_int32>low_data)
+
+            rk_random_uint32(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
@@ -704,25 +847,60 @@ def _rand_int64(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
+    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
     cdef npy_uint64 off, rng, buf
+    cdef npy_uint64 *array_data
     cdef npy_uint64 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
-    cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
 
-    rng = <npy_uint64>(high - low)
-    off = <npy_uint64>(<npy_int64>low)
-    if size is None:
-        rk_random_uint64(off, rng, 1, &buf, state)
-        return <npy_int64>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint64>(high - low)
+        off = <npy_uint64>(<npy_int64>low)
+
+        if size is None:
+            rk_random_uint64(off, rng, 1, &buf, state)
+            return <npy_int64>buf
+        else:
+            array = <ndarray>np.empty(size, np.int64)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint64 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint64(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.int64)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint64 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint64(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.int64)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.int64)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint64 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint64>(int(high_data) - int(low_data))
+            off = <npy_uint64>(<npy_int64>low_data)
+
+            rk_random_uint64(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
+
 def _rand_uint8(low, high, size, rngstate):
     """
     _rand_uint8(low, high, size, rngstate)
@@ -730,23 +908,56 @@ def _rand_uint8(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
-    cdef npy_uint8 off, rng, buf
-    cdef npy_uint8 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
     cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
+    cdef npy_uint8 off, rng, buf
+    cdef npy_uint8 *array_data
 
-    rng = <npy_uint8>(high - low)
-    off = <npy_uint8>(low)
-    if size is None:
-        rk_random_uint8(off, rng, 1, &buf, state)
-        return buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint8>(high - low)
+        off = <npy_uint8>(<npy_uint8>low)
+
+        if size is None:
+            rk_random_uint8(off, rng, 1, &buf, state)
+            return <npy_uint8>buf
+        else:
+            array = <ndarray>np.empty(size, np.uint8)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint8 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint8(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.uint8)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint8 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint8(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.uint8)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.uint8)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint8 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint8>(int(high_data) - int(low_data))
+            off = <npy_uint8>(<npy_uint8>low_data)
+
+            rk_random_uint8(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
@@ -757,50 +968,116 @@ def _rand_uint16(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
-    cdef npy_uint16 off, rng, buf
-    cdef npy_uint16 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
     cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
+    cdef npy_uint16 off, rng, buf
+    cdef npy_uint16 *array_data
 
-    rng = <npy_uint16>(high - low)
-    off = <npy_uint16>(low)
-    if size is None:
-        rk_random_uint16(off, rng, 1, &buf, state)
-        return buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint16>(high - low)
+        off = <npy_uint16>(<npy_uint16>low)
+
+        if size is None:
+            rk_random_uint16(off, rng, 1, &buf, state)
+            return <npy_uint16>buf
+        else:
+            array = <ndarray>np.empty(size, np.uint16)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint16 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint16(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.uint16)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint16 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint16(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.uint16)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.uint16)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint16 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint16>(int(high_data) - int(low_data))
+            off = <npy_uint16>(<npy_uint16>low_data)
+
+            rk_random_uint16(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
 def _rand_uint32(low, high, size, rngstate):
     """
-    _rand_uint32(self, low, high, size, rngstate)
+    _rand_uint32(low, high, size, rngstate)
 
     See `_rand_int32` for documentation, only the return type changes.
 
     """
-    cdef npy_uint32 off, rng, buf
-    cdef npy_uint32 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
     cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
+    cdef npy_uint32 off, rng, buf
+    cdef npy_uint32 *array_data
 
-    rng = <npy_uint32>(high - low)
-    off = <npy_uint32>(low)
-    if size is None:
-        rk_random_uint32(off, rng, 1, &buf, state)
-        return <npy_uint32>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint32>(high - low)
+        off = <npy_uint32>(<npy_uint32>low)
+
+        if size is None:
+            rk_random_uint32(off, rng, 1, &buf, state)
+            return <npy_uint32>buf
+        else:
+            array = <ndarray>np.empty(size, np.uint32)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint32 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint32(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.uint32)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint32 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint32(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.uint32)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.uint32)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint32 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint32>(int(high_data) - int(low_data))
+            off = <npy_uint32>(<npy_uint32>low_data)
+
+            rk_random_uint32(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 
@@ -811,23 +1088,56 @@ def _rand_uint64(low, high, size, rngstate):
     See `_rand_int32` for documentation, only the return type changes.
 
     """
-    cdef npy_uint64 off, rng, buf
-    cdef npy_uint64 *out
-    cdef ndarray array "arrayObject"
-    cdef npy_intp cnt
     cdef rk_state *state = <rk_state *>NpyCapsule_AsVoidPtr(rngstate)
+    cdef ndarray array "arrayObject"
+    cdef npy_uint64 off, rng, buf
+    cdef npy_uint64 *array_data
 
-    rng = <npy_uint64>(high - low)
-    off = <npy_uint64>(low)
-    if size is None:
-        rk_random_uint64(off, rng, 1, &buf, state)
-        return <npy_uint64>buf
+    cdef ndarray lo, hi
+    cdef npy_intp i, cnt
+    cdef broadcast multi
+
+    if np.array(low).shape == np.array(high).shape == ():
+        low = int(low)
+        high = int(high)
+
+        rng = <npy_uint64>(high - low)
+        off = <npy_uint64>(<npy_uint64>low)
+
+        if size is None:
+            rk_random_uint64(off, rng, 1, &buf, state)
+            return <npy_uint64>buf
+        else:
+            array = <ndarray>np.empty(size, np.uint64)
+            cnt = PyArray_SIZE(array)
+            out = <npy_uint64 *>PyArray_DATA(array)
+            with nogil:
+                rk_random_uint64(off, rng, cnt, out, state)
+            return array
     else:
-        array = <ndarray>np.empty(size, np.uint64)
-        cnt = PyArray_SIZE(array)
-        out = <npy_uint64 *>PyArray_DATA(array)
-        with nogil:
-            rk_random_uint64(off, rng, cnt, out, state)
+        i = 0
+        lo = <ndarray>low
+        hi = <ndarray>high
+
+        if size is None:
+            multi = <broadcast>np.broadcast(lo, hi, [0])
+            array = <ndarray>np.empty(multi.shape, dtype=np.uint64)
+        else:
+            array = <ndarray>np.empty(size, dtype=np.uint64)
+            multi = <broadcast>np.broadcast(lo, hi, array)
+            if multi.shape != array.shape:
+                raise ValueError("size is not compatible with inputs")
+
+        array_data = <npy_uint64 *>PyArray_DATA(array)
+
+        for low_data, high_data, array_elt in multi:
+            rng = <npy_uint64>(int(high_data) - int(low_data))
+            off = <npy_uint64>(<npy_uint64>low_data)
+
+            rk_random_uint64(off, rng, 1, &buf, state)
+            array_data[i] = buf
+            i += 1
+
         return array
 
 # Look up table for randint functions keyed by type name. The stored data
@@ -1171,13 +1481,15 @@ cdef class RandomState:
 
         Parameters
         ----------
-        low : int
+        low : int or array_like
             Lowest (signed) integer to be drawn from the distribution (unless
             ``high=None``, in which case this parameter is the *highest* such
-            integer).
-        high : int, optional
+            integer). Note that if `low` is array_like, all elements must be
+            integers.
+        high : int or array_like, optional
             If provided, one above the largest (signed) integer to be drawn
             from the distribution (see above for behavior if ``high=None``).
+            Note that if `high` is array_like, all elements must be integers.
         size : int or tuple of ints, optional
             Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
             ``m * n * k`` samples are drawn.  Default is None, in which case a
@@ -1216,6 +1528,25 @@ cdef class RandomState:
         array([[4, 0, 2, 1],
                [3, 2, 2, 0]])
 
+        Generate a 1 x 3 array with 3 different upper bounds:
+        >>> np.random.randint(1, [3, 5, 10])
+        array([2, 2, 9])
+
+        Generate a 1 x 3 array with 3 different lower bounds:
+        >>> np.random.randint([1, 5, 7], 10)
+        array([9, 8, 7])
+
+        Generate a 1 x 3 array with 3 different lower and upper bounds:
+        >>> np.random.randint([1, 5, 7], [13, 30, 45])
+        array([12,  5, 18])
+
+        Generate a 2 x 4 array of ints of the data type np.uint8:
+        >>>> np.random.randint(np.iinfo(np.uint8).min,
+                           np.iinfo(np.uint8).max + 1,
+                           size=(2, 4), dtype=np.uint8)
+        array([[ 35, 252,  90, 214],
+               [ 47,  23, 214, 185]], dtype=uint8)
+
         """
         if high is None:
             high = low
@@ -1224,17 +1555,62 @@ cdef class RandomState:
         key = np.dtype(dtype).name
         if not key in _randint_type:
             raise TypeError('Unsupported dtype "%s" for randint' % key)
-        lowbnd, highbnd, randfunc = _randint_type[key]
+        lowbnd, highbnd, func = _randint_type[key]
+
+        if np.array(low).shape == np.array(high).shape == ():
+            # Determine if `low` and `high` are both scalars
+            # Otherwise, at least one of them is array_like
+            #
+            # These conversions also ensure that we perform
+            # the subsequent comparisons with Python integers
+            # and not with Numpy integer types, which are
+            # susceptible to an unusual corner case described
+            # below under the EXCEPT-block
+            low = int(low)
+            high = int(high)
+
+            if low < lowbnd:
+                raise ValueError("low is out of bounds for %s" % (key,))
+            if high > highbnd:
+                raise ValueError("high is out of bounds for %s" % (key,))
+            if low >= high:
+                raise ValueError("low >= high")
 
-        if low < lowbnd:
-            raise ValueError("low is out of bounds for %s" % (key,))
-        if high > highbnd:
-            raise ValueError("high is out of bounds for %s" % (key,))
-        if low >= high:
-            raise ValueError("low >= high")
+            with self.lock:
+                return func(low, high - 1, size, self.state_address)
 
-        with self.lock:
-            return randfunc(low, high - 1, size, self.state_address)
+        else:
+            # Casting the arrays as objects is necessary to
+            # avoid the corner case where we are generating
+            # a random integer between np.iinfo(np.int64).max
+            # and np.iinfo(np.int64).max + 1. When stored as
+            # Numpy integers, they are casted as np.int64
+            # and np.uint64 respectively. When Numpy tries
+            # to compare them, it converts both to np.float64
+            # because there is no superset of np.int64 and
+            # np.uint64. However, np.iinfo(np.int64).max + 1
+            # is too large to represent in np.float64, causing
+            # it be round down to np.iinfo(np.int64).max, leading
+            # to a ValueError because `low` now equals `high`
+            low = np.array(low)
+            high = np.array(high)
+
+            if np.any(np.less(low, lowbnd)):
+                raise ValueError("low is out of bounds for %s" % (key,))
+            if np.any(np.greater(high, highbnd)):
+                raise ValueError("high is out of bounds for %s" % (key,))
+
+            # We have to check whether `low` >= `high` in both ways
+            # to avoid issues of overflow and rounding when comparing
+            # an np.uint64 against np.iinfo(np.int64).max
+            if np.any(np.less(high - 1 - low, 0)) and \
+                    np.any(np.greater_equal(low, high)):
+                raise ValueError("low >= high")
+
+            with self.lock:
+                return func(low, high - np.ones(
+                        high.shape, dtype=high.dtype), size,
+                            self.state_address)
 
     def bytes(self, npy_intp length):
         """
diff --git a/numpy/random/tests/test_random.py b/numpy/random/tests/test_random.py
index 96aa3790f4d..20266d4a0cc 100644
--- a/numpy/random/tests/test_random.py
+++ b/numpy/random/tests/test_random.py
@@ -148,21 +148,58 @@ def test_bounds_checking(self):
         for dt in self.itype:
             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
-            assert_raises(ValueError, self.rfunc, lbnd - 1 , ubnd, dtype=dt)
-            assert_raises(ValueError, self.rfunc, lbnd , ubnd + 1, dtype=dt)
-            assert_raises(ValueError, self.rfunc, ubnd , lbnd, dtype=dt)
-            assert_raises(ValueError, self.rfunc, 1 , 0, dtype=dt)
+            assert_raises(ValueError, self.rfunc, lbnd - 1, ubnd, dtype=dt)
+            assert_raises(ValueError, self.rfunc, lbnd, ubnd + 1, dtype=dt)
+            assert_raises(ValueError, self.rfunc, ubnd, lbnd, dtype=dt)
+            assert_raises(ValueError, self.rfunc, 1, 0, dtype=dt)
+
+            # Broadcasting should not affect the bounds checking
+            assert_raises(ValueError, self.rfunc, [lbnd, lbnd - 1, lbnd], ubnd, dtype=dt)
+            assert_raises(ValueError, self.rfunc, lbnd, [ubnd, ubnd + 1, ubnd], dtype=dt)
+            assert_raises(ValueError, self.rfunc, [lbnd, ubnd, lbnd], lbnd + 1, dtype=dt)
+            assert_raises(ValueError, self.rfunc, ubnd - 1, [ubnd, lbnd, ubnd], dtype=dt)
+            assert_raises(ValueError, self.rfunc, [0, 2, 0], 1, dtype=dt)
+            assert_raises(ValueError, self.rfunc, 1, [2, 0, 2], dtype=dt)
 
     def test_rng_zero_and_extremes(self):
         for dt in self.itype:
             lbnd = 0 if dt is np.bool else np.iinfo(dt).min
             ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
+
             tgt = ubnd - 1
             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
+            assert_equal(self.rfunc([tgt] * 3, tgt + 1, dtype=dt), tgt)
+            assert_equal(self.rfunc(tgt, [tgt + 1] * 3, dtype=dt), tgt)
+
             tgt = lbnd
             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
+            assert_equal(self.rfunc([tgt] * 3, tgt + 1, dtype=dt), tgt)
+            assert_equal(self.rfunc(tgt, [tgt + 1] * 3, dtype=dt), tgt)
+
             tgt = (lbnd + ubnd)//2
             assert_equal(self.rfunc(tgt, tgt + 1, size=1000, dtype=dt), tgt)
+            assert_equal(self.rfunc([tgt] * 3, tgt + 1, dtype=dt), tgt)
+            assert_equal(self.rfunc(tgt, [tgt + 1] * 3, dtype=dt), tgt)
+
+    def test_full_range(self):
+        # Test for ticket #1690
+        #
+        # Expanded in PR #6938 with the introduction of `dtype`
+        # as a parameter for `np.random.randint` from PR #6910
+        # and the addition of broadcasting functionality
+        for dt in self.itype:
+            lbnd = 0 if dt is np.bool else np.iinfo(dt).min
+            ubnd = 2 if dt is np.bool else np.iinfo(dt).max + 1
+
+            try:
+                self.rfunc(lbnd, ubnd, dtype=dt)
+                self.rfunc([lbnd] * 3, ubnd, dtype=dt)
+                self.rfunc(lbnd, [ubnd] * 3, dtype=dt)
+                self.rfunc([lbnd] * 3, [ubnd] * 3, dtype=dt)
+            except Exception as e:
+                raise AssertionError("No error should have been raised, "
+                                     "but one was with the following "
+                                     "message:\n\n%s" % str(e))
 
     def test_in_bounds_fuzz(self):
         # Don't use fixed seed
@@ -209,6 +246,47 @@ def test_repeatability(self):
         res = hashlib.md5(val).hexdigest()
         assert_(tgt[np.dtype(np.bool).name] == res)
 
+    def test_broadcast(self):
+        # Case I: low = scalar, high = array
+        np.random.seed(1234)
+        actual = np.random.randint(1, [3, 6, 10])
+        desired = np.array([2, 4, 7])
+        assert_equal(actual, desired)
+
+        # Case II: low = array, high = scalar
+        np.random.seed(1234)
+        actual = np.random.randint([1, 5, 7], 10)
+        desired = np.array([4, 9, 7])
+        assert_equal(actual, desired)
+
+        # Case III: low = array, high = array
+        np.random.seed(1234)
+        actual = np.random.randint([1, 5, 7], [6, 9, 10])
+        desired = np.array([4, 7, 8])
+        assert_equal(actual, desired)
+
+    def test_int64_uint64_corner_case(self):
+        dt = np.int64
+        tgt = np.iinfo(np.int64).max
+        lbnd = np.int64(np.iinfo(np.int64).max)
+        ubnd = np.uint64(np.iinfo(np.int64).max + 1)
+
+        # None of these function calls should
+        # generate a ValueError because ``lbnd``
+        # and ``ubnd`` should be handled properly
+        # to avoid Numpy's rounding of ``ubnd`` to
+        # ``lbnd`` in np.float64
+        actual = np.random.randint(lbnd, ubnd, dtype=dt)
+        assert_equal(actual, tgt)
+
+        actual = np.random.randint([lbnd] * 3, ubnd, dtype=dt)
+        assert_equal(actual, tgt)
+
+        actual = np.random.randint(lbnd, [ubnd] * 3, dtype=dt)
+        assert_equal(actual, tgt)
+
+        actual = np.random.randint([lbnd] * 3, [ubnd] * 3, dtype=dt)
+        assert_equal(actual, tgt)
 
 class TestRandomDist(TestCase):
     # Make sure the random distribution returns the correct value for a
diff --git a/numpy/random/tests/test_regression.py b/numpy/random/tests/test_regression.py
index 133a1aa5ad6..0b554606896 100644
--- a/numpy/random/tests/test_regression.py
+++ b/numpy/random/tests/test_regression.py
@@ -55,15 +55,6 @@ def test_permutation_longs(self):
         b = np.random.permutation(long(12))
         assert_array_equal(a, b)
 
-    def test_randint_range(self):
-        # Test for ticket #1690
-        lmax = np.iinfo('l').max
-        lmin = np.iinfo('l').min
-        try:
-            random.randint(lmin, lmax)
-        except:
-            raise AssertionError
-
     def test_shuffle_mixed_dimension(self):
         # Test for trac ticket #2074
         for t in [[1, 2, 3, None],
