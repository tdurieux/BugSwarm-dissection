diff --git a/yamcs-core/mdb/refmdb.xls b/yamcs-core/mdb/refmdb.xls
index bcd95012e0..a4cbc0ba60 100755
Binary files a/yamcs-core/mdb/refmdb.xls and b/yamcs-core/mdb/refmdb.xls differ
diff --git a/yamcs-core/pom.xml b/yamcs-core/pom.xml
index 2427b1188f..50e40ae853 100755
--- a/yamcs-core/pom.xml
+++ b/yamcs-core/pom.xml
@@ -87,7 +87,7 @@
     <dependency>
       <groupId>org.rocksdb</groupId>
       <artifactId>rocksdbjni</artifactId>
-      <version>4.13.4</version>
+      <version>5.0.1</version>
     </dependency>
 
     <dependency>
diff --git a/yamcs-core/src/main/java/org/yamcs/algorithms/AbstractAlgorithmExecutor.java b/yamcs-core/src/main/java/org/yamcs/algorithms/AbstractAlgorithmExecutor.java
new file mode 100755
index 0000000000..c1670eef66
--- /dev/null
+++ b/yamcs-core/src/main/java/org/yamcs/algorithms/AbstractAlgorithmExecutor.java
@@ -0,0 +1,134 @@
+package org.yamcs.algorithms;
+
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yamcs.parameter.ParameterValue;
+import org.yamcs.xtce.Algorithm;
+import org.yamcs.xtce.InputParameter;
+import org.yamcs.xtce.OnParameterUpdateTrigger;
+import org.yamcs.xtce.Parameter;
+import org.yamcs.xtce.ParameterInstanceRef;
+
+public abstract class AbstractAlgorithmExecutor implements AlgorithmExecutor {
+    final protected AlgorithmExecutionContext execCtx;
+    final protected Algorithm algorithmDef;
+    final protected CopyOnWriteArrayList<AlgorithmExecListener> execListeners = new CopyOnWriteArrayList<AlgorithmExecListener>();
+    // Keep only unique arguments (for subscription purposes)
+    protected Set<Parameter> requiredParameters = new HashSet<Parameter>();
+    protected Set<InputParameter>mandatoryToRun = new HashSet<InputParameter>();
+    private Map<InputParameter,ParameterValue> inputValues = new HashMap<InputParameter,ParameterValue>();
+    
+    
+    static final Logger log = LoggerFactory.getLogger(AbstractAlgorithmExecutor.class);
+    
+    public AbstractAlgorithmExecutor(Algorithm algorithmDef, AlgorithmExecutionContext execCtx) {
+        this.algorithmDef = algorithmDef;
+        this.execCtx = execCtx;
+        for(InputParameter inputParameter:algorithmDef.getInputSet()) {
+            requiredParameters.add(inputParameter.getParameterInstance().getParameter());
+
+            // Default-define all input values to null to prevent ugly runtime errors
+            String scriptName = inputParameter.getInputName();
+            if(scriptName==null) {
+                scriptName = inputParameter.getParameterInstance().getParameter().getName();
+            }
+           
+            if(inputParameter.isMandatory()) mandatoryToRun.add(inputParameter);
+        }
+    }
+    
+    /**
+     * update the parameters and return true if the algorithm should run
+     * @param items
+     * @return true if the algorithm should run
+     */
+    public synchronized boolean updateParameters(ArrayList<ParameterValue> items) {
+        ArrayList<ParameterValue> allItems=new ArrayList<ParameterValue>(items);
+        boolean skipRun=false;
+
+        // Set algorithm arguments based on incoming values
+        for(InputParameter inputParameter:algorithmDef.getInputSet()) {
+            ParameterInstanceRef pInstance = inputParameter.getParameterInstance();
+            for(ParameterValue pval:allItems) {
+                if(pInstance.getParameter().equals(pval.getParameter())) {
+                    if(getLookbackSize(pInstance.getParameter())==0) {
+                        updateInput(inputParameter, pval);
+                        inputValues.put(inputParameter, pval);
+                    } else {
+                        ParameterValue historicValue=execCtx.getHistoricValue(pInstance);
+                        if(historicValue!=null) {
+                            updateInput(inputParameter, historicValue);
+                            inputValues.put(inputParameter, historicValue);
+                        }
+                    }
+                }
+            }
+            if(!skipRun && inputParameter.isMandatory() && !inputValues.containsKey(inputParameter)) {
+                log.trace("Not running algorithm {} because mandatory input {} is not present", algorithmDef.getName(), inputParameter.getInputName());
+                skipRun = true;
+            }
+        }
+
+        // But run it only, if this satisfies an onParameterUpdate trigger
+        boolean triggered=false;
+        for(OnParameterUpdateTrigger trigger:algorithmDef.getTriggerSet().getOnParameterUpdateTriggers()) {
+            if(triggered) break;
+            for(ParameterValue pval:allItems) {
+                if(pval.getParameter().equals(trigger.getParameter())) {
+                    triggered=true;
+                    break;
+                }
+            }
+        }
+        boolean shouldRun =(!skipRun && triggered);
+        return shouldRun;
+    }
+   
+
+    abstract protected void updateInput(InputParameter inputParameter, ParameterValue newValue);
+    
+    protected void propagateToListeners(Object returnValue,  List<ParameterValue> outputValues){
+        for(AlgorithmExecListener listener: execListeners) {
+            listener.algorithmRun(returnValue, outputValues);
+        }
+    }
+    @Override
+    public void addExecListener(AlgorithmExecListener listener) {
+        execListeners.add(listener);
+    }
+    
+    @Override
+    public AlgorithmExecutionContext getExecutionContext() {
+        return execCtx;
+    }
+    
+    @Override
+    public int getLookbackSize(Parameter parameter) {
+        // e.g. [ -3, -2, -1, 0 ]
+        int min=0;
+        for(InputParameter p:algorithmDef.getInputSet()) {
+            ParameterInstanceRef pInstance=p.getParameterInstance();
+            if(pInstance.getParameter().equals(parameter) && pInstance.getInstance()<min) {
+                min=p.getParameterInstance().getInstance();
+            }
+        }
+        return -min;
+    }
+    @Override
+    public Set<Parameter> getRequiredParameters() {
+        return requiredParameters;
+    }
+    @Override
+    public Algorithm getAlgorithm() {
+        return algorithmDef;
+    }
+}
diff --git a/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutionContext.java b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutionContext.java
index 94db6e1ec1..3b8b447b37 100755
--- a/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutionContext.java
+++ b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutionContext.java
@@ -29,7 +29,7 @@
     final AlgorithmExecutionContext parent;
     
     //all the algorithms that run in this context
-    HashMap<Algorithm,AlgorithmEngine> engineByAlgorithm=new HashMap<Algorithm,AlgorithmEngine>();
+    HashMap<Algorithm,AlgorithmExecutor> engineByAlgorithm=new HashMap<Algorithm,AlgorithmExecutor>();
     //name used for debugging
     final String contextName;
     
@@ -85,12 +85,12 @@ public boolean containsAlgorithm(Algorithm algo) {
         return engineByAlgorithm.containsKey(algo);
     }
 
-    public AlgorithmEngine getEngine(Algorithm algo) {
+    public AlgorithmExecutor getExecutor(Algorithm algo) {
         return engineByAlgorithm.get(algo);
     }
 
 
-    public void addAlgorithm(Algorithm algorithm, AlgorithmEngine engine) {
+    public void addAlgorithm(Algorithm algorithm, AlgorithmExecutor engine) {
         engineByAlgorithm.put(algorithm, engine);
     }
     
@@ -99,7 +99,7 @@ public void addAlgorithm(Algorithm algorithm, AlgorithmEngine engine) {
         return engineByAlgorithm.keySet();
     }
 
-    public AlgorithmEngine remove(Algorithm algo) {
+    public AlgorithmExecutor remove(Algorithm algo) {
         return engineByAlgorithm.remove(algo);
     }
 }
diff --git a/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutor.java b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutor.java
new file mode 100755
index 0000000000..f99edcb201
--- /dev/null
+++ b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmExecutor.java
@@ -0,0 +1,41 @@
+package org.yamcs.algorithms;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import org.yamcs.parameter.ParameterValue;
+import org.yamcs.xtce.Algorithm;
+import org.yamcs.xtce.Parameter;
+
+/**
+ * Represents the execution context of one algorithm. An AlgorithmExecutor is reused
+ * upon each update of one or more of its InputParameters.
+ *  
+ */
+public interface AlgorithmExecutor {
+    Algorithm getAlgorithm();
+
+    Set<Parameter> getRequiredParameters();
+
+    int getLookbackSize(Parameter parameter);
+    
+    /**
+     * Update parameters and return true if the algorithm should run
+     * 
+     * @param paramList - list of input parameters
+     * @return true if the algorithm should run
+     */
+    boolean updateParameters(ArrayList<ParameterValue> paramList);
+    /**
+     * Runs the associated algorithm with the latest InputParameters
+     * @param acqTime 
+     * @param genTime 
+     * @return the outputted parameters, if any
+     */
+    List<ParameterValue> runAlgorithm(long acqTime, long genTime);
+
+    void addExecListener(AlgorithmExecListener listener);
+
+    AlgorithmExecutionContext getExecutionContext();
+}
\ No newline at end of file
diff --git a/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmManager.java b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmManager.java
index 3f1959ac30..fc93275247 100755
--- a/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmManager.java
+++ b/yamcs-core/src/main/java/org/yamcs/algorithms/AlgorithmManager.java
@@ -13,6 +13,8 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import javax.script.Bindings;
 import javax.script.ScriptContext;
@@ -32,7 +34,7 @@
 import org.yamcs.parameter.ParameterRequestManagerImpl;
 import org.yamcs.parameter.ParameterRequestManager;
 import org.yamcs.protobuf.Yamcs.NamedObjectId;
-import org.yamcs.utils.TimeEncoding;
+import org.yamcs.utils.YObjectLoader;
 import org.yamcs.xtce.Algorithm;
 import org.yamcs.xtce.DataSource;
 import org.yamcs.xtce.InputParameter;
@@ -41,6 +43,7 @@
 import org.yamcs.xtce.OutputParameter;
 import org.yamcs.xtce.Parameter;
 import org.yamcs.xtce.XtceDb;
+import org.yaml.snakeyaml.Yaml;
 
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.AbstractService;
@@ -76,7 +79,7 @@
     // Index of all available out params
     NamedDescriptionIndex<Parameter> outParamIndex=new NamedDescriptionIndex<Parameter>();
 
-    CopyOnWriteArrayList<AlgorithmEngine> executionOrder=new CopyOnWriteArrayList<AlgorithmEngine>();
+    CopyOnWriteArrayList<AlgorithmExecutor> executionOrder=new CopyOnWriteArrayList<AlgorithmExecutor>();
     HashSet<Parameter> requiredInParams=new HashSet<Parameter>(); // required by this class
     ArrayList<Parameter> requestedOutParams=new ArrayList<Parameter>(); // requested by clients
     ParameterRequestManagerImpl parameterRequestManager;
@@ -177,7 +180,7 @@ private void loadAlgorithm(Algorithm algo, AlgorithmExecutionContext ctx) {
         if(!timedTriggers.isEmpty()) {
             // acts as a fixed-size pool
             activateAlgorithm(algo, ctx, null);
-            final AlgorithmEngine engine = ctx.getEngine(algo);
+            final AlgorithmExecutor engine = ctx.getExecutor(algo);
             for(OnPeriodicRateTrigger trigger:timedTriggers) {
                 timer.scheduleAtFixedRate(new Runnable() {
                     @Override
@@ -211,7 +214,7 @@ public void startProviding(Parameter paramDef) {
             }
         }
     }
-    
+
     /**
      * Create a new algorithm execution context. 
      * 
@@ -222,7 +225,7 @@ public AlgorithmExecutionContext createContext(String name) {
         return new AlgorithmExecutionContext(name, globalCtx);
     }
 
-    
+
     /**
      * Activate an algorithm in a context if not already active.
      * 
@@ -233,30 +236,34 @@ public AlgorithmExecutionContext createContext(String name) {
      * @param listener
      */
     public void activateAlgorithm(Algorithm algorithm, AlgorithmExecutionContext execCtx, AlgorithmExecListener listener) {
-        AlgorithmEngine engine = execCtx.getEngine(algorithm);
-        if(engine!=null) {
+        AlgorithmExecutor executor = execCtx.getExecutor(algorithm);
+        if(executor!=null) {
             log.trace("Already activated algorithm {} in context {}", algorithm.getQualifiedName(), execCtx.getName());
             if(listener!=null) {
-                engine.addExecListener(listener);
+                executor.addExecListener(listener);
             }
             return;
         }
         log.trace("Activating algorithm....{}", algorithm.getQualifiedName());
+        String algLang = algorithm.getLanguage();
+        if(algLang.equalsIgnoreCase("java")) {
+            executor = loadJavaExecutor(algorithm, execCtx);
+        } else {
+            ScriptEngine scriptEngine = scriptEngineManager.getEngineByName(algorithm.getLanguage());
+            if(scriptEngine==null) throw new RuntimeException("Cannot created a script engine for language '"+algorithm.getLanguage()+"'");
 
-        ScriptEngine scriptEngine=scriptEngineManager.getEngineByName(algorithm.getLanguage());
-        if(scriptEngine==null) throw new RuntimeException("Cannot created a script engine for language '"+algorithm.getLanguage()+"'");
-
-        scriptEngine.put("Yamcs", new AlgorithmUtils(yproc, xtcedb, algorithm.getName()));
+            scriptEngine.put("Yamcs", new AlgorithmUtils(yproc, xtcedb, algorithm.getName()));
 
-        engine=new AlgorithmEngine(algorithm, scriptEngine, execCtx);
+            executor = new ScriptAlgorithmExecutor(algorithm, scriptEngine, execCtx);
+        }
         if(listener!=null) {
-            engine.addExecListener(listener);
+            executor.addExecListener(listener);
         }
-    
-        execCtx.addAlgorithm(algorithm, engine);
+
+        execCtx.addAlgorithm(algorithm, executor);
         try {
             ArrayList<Parameter> newItems=new ArrayList<Parameter>();
-            for(Parameter param:engine.getRequiredParameters()) {
+            for(Parameter param:executor.getRequiredParameters()) {
                 if(!requiredInParams.contains(param)) {
                     requiredInParams.add(param);
                     // Recursively activate other algorithms on which this algorithm depends
@@ -278,7 +285,7 @@ public void activateAlgorithm(Algorithm algorithm, AlgorithmExecutionContext exe
                 }
 
                 // Initialize a new Windowbuffer, or extend an existing one, if the algorithm requires going back in time
-                int lookbackSize=engine.getLookbackSize(param);
+                int lookbackSize=executor.getLookbackSize(param);
                 if(lookbackSize>0) {
                     execCtx.enableBuffer(param, lookbackSize);
                 }
@@ -286,24 +293,52 @@ public void activateAlgorithm(Algorithm algorithm, AlgorithmExecutionContext exe
             if(!newItems.isEmpty()) {
                 parameterRequestManager.addItemsToRequest(subscriptionId, newItems);
             }
-            executionOrder.add(engine); // Add at the back (dependent algorithms will come in front)
+            executionOrder.add(executor); // Add at the back (dependent algorithms will come in front)
         } catch (InvalidIdentification e) {
             log.error(String.format("InvalidIdentification caught when subscribing to the items "
                     + "required for the algorithm %s\n\t The invalid items are: %s"
-                    , engine.getAlgorithm().getName(), e.invalidParameters), e);
+                    , executor.getAlgorithm().getName(), e.invalidParameters), e);
         } catch (InvalidRequestIdentification e) {
             log.error("InvalidRequestIdentification caught when subscribing to the items required for the algorithm "
-                    + engine.getAlgorithm().getName(), e);
+                    + executor.getAlgorithm().getName(), e);
+        }
+    }
+
+    private AlgorithmExecutor loadJavaExecutor(Algorithm alg, AlgorithmExecutionContext execCtx) {
+        Pattern p = Pattern.compile("([\\w\\$\\.]+)(\\(.*\\))?", Pattern.DOTALL);
+        Matcher m = p.matcher(alg.getAlgorithmText());
+        if(!m.matches()) {
+            log.warn("Cannot parse algorithm text '{}'", alg.getAlgorithmText());
+            throw new RuntimeException("Cannot parse algorithm text '"+alg.getAlgorithmText()+"'");
+        }
+        String className = m.group(1);
+        
+        try {
+            String s = m.group(2); //this includes the parentheses
+            Object arg = null;
+            if(s!=null && s.length()>2) {//s.length>2 is to make sure there is something in between the parentheses
+                Yaml yaml = new Yaml();
+                arg = yaml.load(s.substring(1, s.length()-1));
+            }
+            
+            if(arg==null){
+                return YObjectLoader.loadObject(className, alg, execCtx);
+            } else {
+                return YObjectLoader.loadObject(className, alg, execCtx, arg);
+            }
+        } catch (ConfigurationException | IOException e) {
+            log.warn("Cannot load object for algorithm", e);
+            throw new RuntimeException(e);
         }
     }
-    
+
     public void deactivateAlgorithm(Algorithm algorithm, AlgorithmExecutionContext execCtx) {
-        AlgorithmEngine engine = execCtx.remove(algorithm);
+        AlgorithmExecutor engine = execCtx.remove(algorithm);
         if(engine!=null) {
             executionOrder.remove(engine);
         }
     }
-    
+
     @Override
     public void startProvidingAll() {
         for(Parameter p:outParamIndex.getObjects()) {
@@ -317,8 +352,8 @@ public void stopProviding(Parameter paramDef) {
             // Remove algorithm engine (and any that are no longer needed as a consequence)
             // We need to clean-up three more internal structures: requiredInParams, executionOrder and engineByAlgorithm
             HashSet<Parameter> stillRequired=new HashSet<Parameter>(); // parameters still required by any other algorithm
-            for(Iterator<AlgorithmEngine> it=Lists.reverse(executionOrder).iterator();it.hasNext();) {
-                AlgorithmEngine engine = it.next();
+            for(Iterator<AlgorithmExecutor> it=Lists.reverse(executionOrder).iterator();it.hasNext();) {
+                AlgorithmExecutor engine = it.next();
                 Algorithm algo = engine.getAlgorithm();
                 boolean doRemove=true;
 
@@ -398,7 +433,7 @@ public Parameter getParameter(NamedObjectId paraId) throws InvalidIdentification
     public ArrayList<ParameterValue> updateParameters(int subscriptionId, ArrayList<ParameterValue> items) {
         return updateParameters(items, globalCtx);
     }
-    
+
     /**
      * Update parameters in context and run the affected algorithms 
      * @param items
@@ -407,17 +442,17 @@ public Parameter getParameter(NamedObjectId paraId) throws InvalidIdentification
      */
     public ArrayList<ParameterValue> updateParameters(List<ParameterValue> items, AlgorithmExecutionContext ctx) {
         ArrayList<ParameterValue> newItems=new ArrayList<ParameterValue>();
-        
+
         ctx.updateHistoryWindows(items);
         long acqTime = yproc.getCurrentTime();
         long genTime = items.get(0).getGenerationTime();
 
         ArrayList<ParameterValue> allItems=new ArrayList<ParameterValue>(items);
-        for(AlgorithmEngine engine:executionOrder) {
-            if(ctx==globalCtx || engine.execCtx==ctx) {
-                boolean shouldRun = engine.updateParameters(allItems);
+        for(AlgorithmExecutor executor:executionOrder) {
+            if(ctx==globalCtx || executor.getExecutionContext()==ctx) {
+                boolean shouldRun = executor.updateParameters(allItems);
                 if(shouldRun) {
-                    List<ParameterValue> r = engine.runAlgorithm(acqTime, genTime);
+                    List<ParameterValue> r = executor.runAlgorithm(acqTime, genTime);
                     if(r!=null) {
                         allItems.addAll(r);
                         newItems.addAll(r);
diff --git a/yamcs-core/src/main/java/org/yamcs/algorithms/ScriptAlgorithmExecutor.java b/yamcs-core/src/main/java/org/yamcs/algorithms/ScriptAlgorithmExecutor.java
new file mode 100755
index 0000000000..7a215f9456
--- /dev/null
+++ b/yamcs-core/src/main/java/org/yamcs/algorithms/ScriptAlgorithmExecutor.java
@@ -0,0 +1,396 @@
+package org.yamcs.algorithms;
+
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.script.Compilable;
+import javax.script.CompiledScript;
+import javax.script.ScriptEngine;
+import javax.script.ScriptException;
+
+import org.codehaus.janino.SimpleCompiler;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yamcs.parameter.ParameterValue;
+import org.yamcs.parameter.Value;
+import org.yamcs.protobuf.Yamcs.Value.Type;
+import org.yamcs.xtce.Algorithm;
+import org.yamcs.xtce.BinaryParameterType;
+import org.yamcs.xtce.BooleanDataEncoding;
+import org.yamcs.xtce.BooleanParameterType;
+import org.yamcs.xtce.DataEncoding;
+import org.yamcs.xtce.EnumeratedParameterType;
+import org.yamcs.xtce.FloatDataEncoding;
+import org.yamcs.xtce.FloatParameterType;
+import org.yamcs.xtce.InputParameter;
+import org.yamcs.xtce.IntegerDataEncoding;
+import org.yamcs.xtce.IntegerDataEncoding.Encoding;
+import org.yamcs.xtce.IntegerParameterType;
+import org.yamcs.xtce.OutputParameter;
+import org.yamcs.xtce.Parameter;
+import org.yamcs.xtce.ParameterType;
+import org.yamcs.xtce.StringDataEncoding;
+import org.yamcs.xtce.StringParameterType;
+import org.yamcs.xtceproc.ParameterTypeProcessor;
+
+import com.google.protobuf.ByteString;
+
+/**
+ * Represents the execution context of one algorithm. An AlgorithmEngine is reused
+ * upon each update of one or more of its InputParameters.
+ * <p>
+ * This class will create and compile on-the-fly ValueBinding implementations for every
+ * unique combination of raw and eng types. The reason for this is to get the mapping
+ * correct from Java to JavaScript. Rhino (the default JavaScript engine for JDK &le; 7)
+ * will map java Float, Integer, etc towards javascript Object, instead of Number. As
+ * a result, in javascript, using the plus operator on two supposed numbers would do a
+ * string concatenation instead of an addition.
+ * <p>
+ * Rather than changing the Rhino configuration (which would require drastic tampering
+ * of the maven-compiler-plugin in order to lift Sun's Access Restrictions on these
+ * internal classes), we generate classes with primitive raw/eng values when needed.  
+ */
+public class ScriptAlgorithmExecutor extends AbstractAlgorithmExecutor {
+    static final Logger log = LoggerFactory.getLogger(ScriptAlgorithmExecutor.class);
+
+    static final String RETURN_VALUE_VAR_NAME="returnValue";
+    
+    ScriptEngine scriptEngine; // Not shared with other algorithm engines
+    CompiledScript compiledScript;
+
+    // Keeps one ValueBinding instance per InputParameter, recycled on each algorithm run
+    private Map<InputParameter,ValueBinding> bindingsByInput = new HashMap<InputParameter,ValueBinding>();
+    // Keeps one OutputValueBinding instance per OutputParameter, recycled on each algorithm run
+    private Map<OutputParameter,OutputValueBinding> bindingsByOutput = new HashMap<OutputParameter,OutputValueBinding>();
+    // Each ValueBinding class represent a unique raw/eng type combination (== key)
+    private static Map<String, Class<ValueBinding>> valueBindingClasses = Collections.synchronizedMap(new HashMap<String,Class<ValueBinding>>());
+
+
+    public ScriptAlgorithmExecutor(Algorithm algorithmDef, ScriptEngine scriptEngine, AlgorithmExecutionContext execCtx) {
+        super(algorithmDef, execCtx);
+        this.scriptEngine=scriptEngine;
+      
+
+        for(InputParameter inputParameter:algorithmDef.getInputSet()) {
+            // Default-define all input values to null to prevent ugly runtime errors
+            String scriptName = inputParameter.getInputName();
+            if(scriptName==null) {
+                scriptName = inputParameter.getParameterInstance().getParameter().getName();
+            }
+            scriptEngine.put(scriptName, null);
+        }
+
+        // Improve error msgs
+        scriptEngine.put(ScriptEngine.FILENAME, algorithmDef.getQualifiedName());
+
+        // Set empty output bindings so that algorithms can write their attributes
+        for(OutputParameter outputParameter:algorithmDef.getOutputSet()) {
+            OutputValueBinding valueBinding=new OutputValueBinding();
+            bindingsByOutput.put(outputParameter, valueBinding);
+            String scriptName=outputParameter.getOutputName();
+            if(scriptName==null) {
+                scriptName=outputParameter.getParameter().getName();
+            }
+            scriptEngine.put(scriptName, valueBinding);
+        }
+
+        if(scriptEngine instanceof Compilable) {
+            try {
+                compiledScript = ((Compilable)scriptEngine).compile(algorithmDef.getAlgorithmText());
+            } catch (ScriptException e) {
+                log.warn("Error while compiling algorithm "+algorithmDef.getName()+": "+e.getMessage(), e);
+            }
+        }
+    }
+
+   
+    @Override
+    protected void updateInput(InputParameter inputParameter, ParameterValue newValue) {
+        // First time for an inputParameter, it will register a ValueBinding object with the engine.
+        // Further calls will just update that object
+        if(!bindingsByInput.containsKey(inputParameter)) {
+            ValueBinding valueBinding = toValueBinding(newValue);
+            bindingsByInput.put(inputParameter, valueBinding);
+            for(InputParameter input:algorithmDef.getInputSet()) {
+                if(input.equals(inputParameter)) {
+                    String scriptName=inputParameter.getInputName();
+                    if(scriptName==null) {
+                        scriptName=inputParameter.getParameterInstance().getParameter().getName();
+                    }
+                    scriptEngine.put(scriptName, valueBinding);
+                }
+            }
+        }
+        bindingsByInput.get(inputParameter).updateValue(newValue);
+    }
+    
+
+    /* (non-Javadoc)
+     * @see org.yamcs.algorithms.AlgorithmEngineIf#runAlgorithm(long, long)
+     */
+    @Override
+    public synchronized List<ParameterValue> runAlgorithm(long acqTime, long genTime) {
+        log.trace("Running algorithm '{}'",algorithmDef.getName());
+        try {
+            if(compiledScript!=null) {
+                compiledScript.eval();
+            } else {
+                scriptEngine.eval(algorithmDef.getAlgorithmText());
+            }
+        } catch (ScriptException e) {
+            log.warn("Error while executing algorithm: "+e.getMessage(), e);
+            return Collections.emptyList();
+        }
+        Object returnValue = scriptEngine.get(RETURN_VALUE_VAR_NAME);
+
+        List<ParameterValue> outputValues=new ArrayList<ParameterValue>();
+        for(OutputParameter outputParameter:algorithmDef.getOutputSet()) {
+            String scriptName=outputParameter.getOutputName();
+            if(scriptName==null) {
+                scriptName=outputParameter.getParameter().getName();
+            }
+            if(scriptEngine.get(scriptName) instanceof OutputValueBinding) {
+                OutputValueBinding res = (OutputValueBinding) scriptEngine.get(scriptName);
+                if(res.updated && res.value != null) {
+                    ParameterValue pv = convertScriptOutputToParameterValue(outputParameter.getParameter(), res);
+                    pv.setAcquisitionTime(acqTime);
+                    pv.setGenerationTime(genTime);
+                    outputValues.add(pv);
+                }
+            } else {
+                log.warn("Error while executing algorithm {}. Wrong type of output parameter. Ensure you assign to '{}.value' and not directly to '{}'",
+                        algorithmDef.getQualifiedName(), scriptName, scriptName);
+            }
+
+        }
+        propagateToListeners(returnValue, outputValues);
+        return outputValues; 
+    }
+
+    private ParameterValue convertScriptOutputToParameterValue(Parameter parameter, OutputValueBinding binding) {
+        ParameterValue pval=new ParameterValue(parameter);
+        ParameterType ptype=parameter.getParameterType();
+        if(ptype instanceof EnumeratedParameterType) {
+            setRawValue(((EnumeratedParameterType) ptype).getEncoding(), pval, binding.value);
+        } else if(ptype instanceof IntegerParameterType) {
+            setRawValue(((IntegerParameterType) ptype).getEncoding(), pval, binding.value);
+        } else if(ptype instanceof FloatParameterType) {
+            setRawValue(((FloatParameterType) ptype).getEncoding(), pval, binding.value);
+        } else if(ptype instanceof BinaryParameterType) {
+            setRawValue(((BinaryParameterType) ptype).getEncoding(), pval, binding.value);
+        } else if(ptype instanceof StringParameterType) {
+            setRawValue(((StringParameterType) ptype).getEncoding(), pval, binding.value);
+        } else if(ptype instanceof BooleanParameterType) {
+            setRawValue(((BooleanParameterType) ptype).getEncoding(), pval, binding.value);
+        } else {
+            throw new IllegalArgumentException("Unsupported parameter type "+ptype);
+        }
+
+        ParameterTypeProcessor.calibrate(pval);
+        return pval;
+    }
+
+    private void setRawValue(DataEncoding de, ParameterValue pval, Object outputValue) {
+        if(de instanceof IntegerDataEncoding) {
+            setRawIntegerValue((IntegerDataEncoding) de, pval, outputValue);
+        } else if(de instanceof FloatDataEncoding) {
+            setRawFloatValue((FloatDataEncoding) de, pval, outputValue);
+        } else if(de instanceof StringDataEncoding) {
+            pval.setRawValue(outputValue.toString());
+        } else if(de instanceof BooleanDataEncoding) {
+            if(outputValue instanceof Boolean) {
+                pval.setRawValue((Boolean)outputValue);
+            } else {
+                log.error("Could not set boolean value of parameter "+pval.getParameter().getName()+". Algorithm returned wrong type: "+outputValue.getClass());
+            }
+        } else {
+            log.error("DataEncoding "+de+" not implemented as a raw return type for algorithms");
+            throw new RuntimeException("DataEncoding "+de+" not implemented as a raw return type for algorithms");
+        }
+    }
+
+    private void setRawIntegerValue(IntegerDataEncoding ide, ParameterValue pv, Object outputValue) {
+        long longValue;
+        if(outputValue instanceof Number) {
+            longValue=((Number)outputValue).longValue();
+        } else {
+            log.warn("Unexpected script return type for "+pv.getParameter().getName()+". Was expecting a number, but got: "+outputValue.getClass());
+            return; // TODO make exc, and catch to send to ev
+        }
+        if(ide.getSizeInBits() <= 32) {
+            if(ide.getEncoding() == Encoding.unsigned) {
+                pv.setRawUnsignedInteger((int)longValue);
+            } else {
+                pv.setRawSignedInteger((int)longValue);
+            }
+        } else {
+            if(ide.getEncoding() == Encoding.unsigned) {
+                pv.setRawUnsignedLong(longValue);
+            } else {
+                pv.setRawSignedLong(longValue);
+            }
+        }
+    }
+
+    private void setRawFloatValue(FloatDataEncoding fde, ParameterValue pv, Object outputValue) {
+        double doubleValue;
+        if(outputValue instanceof Number) {
+            doubleValue=((Number)outputValue).doubleValue();
+        } else {
+            log.warn("Unexpected script return type for "+pv.getParameter().getName()+". Was expecting a number, but got: "+outputValue.getClass());
+            return; // TODO make exc, and catch to send to ev
+        }
+        if(fde.getSizeInBits() <= 32) {
+            pv.setRawValue((float) doubleValue);
+        } else {
+            pv.setRawValue(doubleValue);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "def.getName() " +scriptEngine;
+    }
+
+    private static ValueBinding toValueBinding(ParameterValue pval) {
+        try {
+            Class<ValueBinding> clazz=getOrCreateValueBindingClass(pval);
+            Constructor<ValueBinding> constructor=clazz.getConstructor();
+            return constructor.newInstance();
+        } catch (Exception e) {
+            throw new IllegalStateException("Could not instantiate object of custom class", e);
+        }
+    }
+
+    private static Class<ValueBinding> getOrCreateValueBindingClass(ParameterValue pval) {
+        String key;
+        if(pval.getRawValue()==null) {
+            key=""+pval.getEngValue().getType().getNumber();
+        } else {
+            key=pval.getRawValue().getType().getNumber()+"_"+pval.getEngValue().getType().getNumber();
+        }
+
+        if(valueBindingClasses.containsKey(key)) {
+            return valueBindingClasses.get(key);
+        } else {
+            String className="ValueBinding"+key;
+            StringBuilder source=new StringBuilder();
+            source.append("package org.yamcs.algorithms;\n");
+            source.append("import "+ByteString.class.getName()+";\n");
+            source.append("import "+ParameterValue.class.getName()+";\n")
+            .append("public class " + className + " extends ValueBinding {\n");
+            StringBuilder updateValueSource=new StringBuilder("  public void updateValue(ParameterValue v) {\n")
+            .append("    super.updateValue(v);\n");
+            if(pval.getRawValue() != null) {
+                updateValueSource.append(addValueType(source, pval.getRawValue(), true));
+            }
+            updateValueSource.append(addValueType(source, pval.getEngValue(), false));
+            updateValueSource.append("  }\n");
+
+            source.append(updateValueSource.toString());
+            source.append("}");
+
+            try {
+                SimpleCompiler compiler=new SimpleCompiler();
+                if(log.isTraceEnabled()) {
+                    log.trace("Compiling this:\n"+source.toString());
+                }
+
+                compiler.cook(source.toString());
+                @SuppressWarnings("unchecked")
+                Class<ValueBinding> clazz=(Class<ValueBinding>) compiler.getClassLoader().loadClass("org.yamcs.algorithms."+className);
+                valueBindingClasses.put(key, clazz);
+                return clazz;
+            } catch(Exception e) {
+                throw new IllegalStateException("Could not compile custom class", e);
+            }
+        }
+    }
+
+    /**
+     * Appends a raw or eng field with a getter of the given value
+     * @return a matching code fragment to be included in the updateValue() method
+     */
+    private static String addValueType(StringBuilder source, Value v, boolean raw) {
+        if(v.getType() == Type.BINARY) {
+            if(raw) {
+                source.append("  public ByteString rawValue;\n");
+                return "    rawValue=v.getRawValue().getBinaryValue();\n";
+            } else {
+                source.append("  public ByteString value;\n");
+                return "    value=v.getEngValue().getBinaryValue();\n";
+            }
+        } else if(v.getType() == Type.DOUBLE) {
+            if(raw) {
+                source.append("  public double rawValue;\n");
+                return "    rawValue=v.getRawValue().getDoubleValue();\n";
+            } else {
+                source.append("  public double value;\n");
+                return "    value=v.getEngValue().getDoubleValue();\n";
+            }
+        } else if(v.getType() == Type.FLOAT) {
+            if(raw) {
+                source.append("  public float rawValue;\n");
+                return "    rawValue=v.getRawValue().getFloatValue();\n";
+            } else {
+                source.append("  public float value;\n");
+                return "    value=v.getEngValue().getFloatValue();\n";
+            }
+        } else if(v.getType() == Type.UINT32) {
+            if(raw) {
+                source.append("  public int rawValue;\n");
+                return "    rawValue=v.getRawValue().getUint32Value();\n";
+            } else {
+                source.append("  public int value;\n");
+                return "    value=v.getEngValue().getUint32Value();\n";
+            }
+        } else if(v.getType() == Type.SINT32) {
+            if(raw) {
+                source.append("  public int rawValue;\n");
+                return "    rawValue=v.getRawValue().getSint32Value();\n";
+            } else {
+                source.append("  public int value;\n");
+                return "    value=v.getEngValue().getSint32Value();\n";
+            }
+        } else if(v.getType() == Type.UINT64) {
+            if(raw) {
+                source.append("  public long rawValue;\n");
+                return "    rawValue=v.getRawValue().getUint64Value();\n";
+            } else {
+                source.append("  public long value;\n");
+                return "    value=v.getEngValue().getUint64Value();\n";
+            }
+        } else if(v.getType() == Type.SINT64) {
+            if(raw) {
+                source.append("  public long rawValue;\n");
+                return "    rawValue=v.getRawValue().getSint64Value();\n";
+            } else {
+                source.append("  public long value;\n");
+                return "    value=v.getEngValue().getSint64Value();\n";
+            }
+        } else if(v.getType() == Type.STRING) {
+            if(raw) {
+                source.append("  public String rawValue;\n");
+                return "    rawValue=v.getRawValue().getStringValue();\n";
+            } else {
+                source.append("  public String value;\n");
+                return "    value=v.getEngValue().getStringValue();\n";
+            }
+        } else if(v.getType() == Type.BOOLEAN) {
+            if(raw) {
+                source.append("  public boolean rawValue;\n");
+                return "    rawValue=v.getRawValue().getBooleanValue();\n";
+            } else {
+                source.append("  public boolean value;\n");
+                return "    value=v.getEngValue().getBooleanValue();\n";
+            }
+        } else {
+            throw new IllegalArgumentException("Unexpected value of type "+v.getType());
+        }
+    }
+  
+}
diff --git a/yamcs-core/src/main/java/org/yamcs/cli/Backup.java b/yamcs-core/src/main/java/org/yamcs/cli/Backup.java
index 3ae68ec9da..0a07161a60 100755
--- a/yamcs-core/src/main/java/org/yamcs/cli/Backup.java
+++ b/yamcs-core/src/main/java/org/yamcs/cli/Backup.java
@@ -161,7 +161,7 @@ public static void verifyBackupDirectory(String backupDir, boolean mustExist) th
             try(DirectoryStream<Path> dirStream = Files.newDirectoryStream(path)) {
                 for(Path p: dirStream) {
                     isEmpty = false;
-                    if(p.endsWith("LATEST_BACKUP")) {
+                    if(p.endsWith("meta")) {
                         isBackupDir = true;
                         break;
                     }
diff --git a/yamcs-core/src/main/java/org/yamcs/tctm/UdpParameterDataLink.java b/yamcs-core/src/main/java/org/yamcs/tctm/UdpParameterDataLink.java
new file mode 100755
index 0000000000..9835ee36c2
--- /dev/null
+++ b/yamcs-core/src/main/java/org/yamcs/tctm/UdpParameterDataLink.java
@@ -0,0 +1,147 @@
+package org.yamcs.tctm;
+
+import java.io.IOException;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yamcs.ConfigurationException;
+import org.yamcs.YConfiguration;
+import org.yamcs.protobuf.Pvalue.ParameterData;
+
+import com.google.common.util.concurrent.AbstractExecutionThreadService;
+
+
+/**
+ * Receives PP data via UDP. 
+ * 
+ * The UDP packets are protobuf encoded ParameterData.
+ * We don't use any checksum, assume it's done by UDP.
+ * 
+ * @author nm
+ *
+ */
+public class UdpParameterDataLink extends AbstractExecutionThreadService implements ParameterDataLink {
+    private volatile int validDatagramCount = 0;
+    private volatile int invalidDatagramCount = 0;
+    private volatile boolean disabled=false;
+
+    private DatagramSocket udpSocket;
+    private String group="239.192.0.1";
+    private int port=31002;
+
+    ParameterSink ppListener;
+
+    private Logger log=LoggerFactory.getLogger(this.getClass().getName());
+    int MAX_LENGTH=10*1024;
+
+    DatagramPacket datagram = new DatagramPacket(new byte[MAX_LENGTH], MAX_LENGTH);
+
+    /**
+     * Creates a new UDP data link
+     * @param instance 
+     * @param name 
+     * @param config 
+     * @param spec
+     * @throws ConfigurationException if port is not defined in the config 
+     */
+    public UdpParameterDataLink(String instance, String name, Map<String, Object> config) throws ConfigurationException  {
+        port = YConfiguration.getInt(config, "port");
+    }
+
+    @Override
+    public void startUp() throws IOException {
+        udpSocket = new DatagramSocket(port);
+    }
+
+
+    @Override
+    public void run() {
+        while(isRunning()) {
+            ParameterData pd = getNextData();
+            if(pd!=null) {
+                ppListener.updateParams(pd.getGenerationTime(),  pd.getGroup(), pd.getSeqNum(), pd.getParameterList());
+            }
+        }
+    }
+    /**
+     * 
+     * Called to retrieve the next packet.
+     * It blocks in readinng on the UDP socket  
+     * @return anything that looks as a valid packet, just the size is taken into account to decide if it's valid or not
+     */
+    public ParameterData getNextData() {
+     
+        while(isRunning() && disabled) {
+            try {
+                Thread.sleep(1000);
+            } catch (InterruptedException e) {
+                return null;
+            }
+        }
+
+        try {
+            udpSocket.receive(datagram);
+            ParameterData.Builder pdb = ParameterData.newBuilder().mergeFrom(datagram.getData(), datagram.getOffset(), datagram.getLength());
+            validDatagramCount++;
+            return pdb.build();
+        } catch (IOException e) {
+            log.warn("exception when receiving parameter data: {}'", e.getMessage());
+            invalidDatagramCount++;
+        }
+        
+        return null;
+    }
+
+    @Override
+    public String getLinkStatus() {
+        return disabled?"DISABLED":"OK";
+    }
+
+    /**
+     * returns statistics with the number of datagram received and the number of invalid datagrams
+     */
+    @Override
+    public String getDetailedStatus() {
+        if(disabled) {
+            return "DISABLED";
+        } else {
+            return String.format("OK (%s:%d)\nValid datagrams received: %d\nInvalid datagrams received: %d",
+                    group, port, validDatagramCount, invalidDatagramCount);
+        }
+    }
+
+    /**
+     * Sets the disabled to true such that getNextPacket ignores the received datagrams
+     */
+    @Override
+    public void disable() {
+        disabled=true;
+    }
+
+    /**
+     * Sets the disabled to false such that getNextPacket does not ignore the received datagrams
+     */
+    @Override
+    public void enable() {
+        disabled=false;
+    }
+
+    @Override
+    public boolean isDisabled() {
+        return disabled;
+    }
+
+
+    @Override
+    public long getDataCount() {
+        return validDatagramCount;
+    }
+
+    @Override
+    public void setParameterSink(ParameterSink ppListener) {
+        this.ppListener = ppListener;
+    }
+}
diff --git a/yamcs-core/src/main/java/org/yamcs/web/rest/Router.java b/yamcs-core/src/main/java/org/yamcs/web/rest/Router.java
index f400bccde4..33c6cbeaf7 100755
--- a/yamcs-core/src/main/java/org/yamcs/web/rest/Router.java
+++ b/yamcs-core/src/main/java/org/yamcs/web/rest/Router.java
@@ -42,7 +42,6 @@
 import org.yamcs.web.rest.archive.ArchiveIndexRestHandler;
 import org.yamcs.web.rest.archive.ArchivePacketRestHandler;
 import org.yamcs.web.rest.archive.ArchiveParameterRestHandler;
-import org.yamcs.web.rest.archive.ArchiveParameterReplayRestHandler;
 import org.yamcs.web.rest.archive.ArchiveStreamRestHandler;
 import org.yamcs.web.rest.archive.ArchiveTableRestHandler;
 import org.yamcs.web.rest.archive.ArchiveTagRestHandler;
diff --git a/yamcs-core/src/main/java/org/yamcs/web/rest/archive/ArchiveParameterRestHandler.java b/yamcs-core/src/main/java/org/yamcs/web/rest/archive/ArchiveParameterRestHandler.java
index dd27e0c597..e808e01d0c 100755
--- a/yamcs-core/src/main/java/org/yamcs/web/rest/archive/ArchiveParameterRestHandler.java
+++ b/yamcs-core/src/main/java/org/yamcs/web/rest/archive/ArchiveParameterRestHandler.java
@@ -150,6 +150,7 @@ private void sampleDataFromCache(ParameterCache pcache, Parameter p, long start,
             int n = pvlist.size();
             for(int i = n-1; i>=0; i--) {
                 org.yamcs.parameter.ParameterValue pv = pvlist.get(i);
+                
                 if(pv.getGenerationTime() < start) continue;
                 if(pv.getGenerationTime() > stop) break;
                 if(pv.getGenerationTime() > sampler.lastSampleTime()) {
@@ -369,7 +370,8 @@ public void accept(ParameterIdValueList pidvList) {
         //now add some data from cache
         if (pcache!=null) {
             if(mpvr.isAscending())  {
-                sendFromCache(p, id, pcache, true, lastParameterTime.l, mpvr.getStop(), replayListener);      
+                long start = (lastParameterTime.l==TimeEncoding.INVALID_INSTANT)?mpvr.getStart()-1:lastParameterTime.l;
+                sendFromCache(p, id, pcache, true, start, mpvr.getStop(), replayListener);      
             } else if (lastParameterTime.l==TimeEncoding.INVALID_INSTANT) {  //no data retrieved from archive, but maybe there is still something in the cache to send
                 sendFromCache(p, id, pcache, false, mpvr.getStart(), mpvr.getStop(), replayListener);
             }
diff --git a/yamcs-core/src/main/java/org/yamcs/xtce/SpreadsheetLoader.java b/yamcs-core/src/main/java/org/yamcs/xtce/SpreadsheetLoader.java
index 79198bbb48..c0b17ae055 100755
--- a/yamcs-core/src/main/java/org/yamcs/xtce/SpreadsheetLoader.java
+++ b/yamcs-core/src/main/java/org/yamcs/xtce/SpreadsheetLoader.java
@@ -1764,12 +1764,17 @@ protected void loadAlgorithmsSheet(SpaceSystem spaceSystem, String sheetName) {
             Cell[] cells = jumpToRow(sheet, start);
             String name = cells[IDX_ALGO_NAME].getContents();
             String algorithmLanguage = cells[IDX_ALGO_LANGUGAGE].getContents();
-            if(!"JavaScript".equals(algorithmLanguage) && !"python".equals(algorithmLanguage)) {
-                throw new SpreadsheetLoadException(ctx, "Invalid algorithm language '"+algorithmLanguage+"' specified. Supported are 'JavaScript' and 'python' (case sensitive)");
+            if(!"JavaScript".equals(algorithmLanguage) && !"python".equals(algorithmLanguage)&& !"java".equalsIgnoreCase(algorithmLanguage)) {
+                throw new SpreadsheetLoadException(ctx, "Invalid algorithm language '"+algorithmLanguage+"' specified. Supported are 'JavaScript', 'python' and java (case sensitive)");
             }
 
             String algorithmText = cells[IDX_ALGO_TEXT].getContents();
             XtceAliasSet xas = getAliases(firstRow, cells);
+
+            //Check that there is not specified by mistake a in/out param already on the same line with the algorithm name
+            if(hasColumn(cells, IDX_ALGO_PARA_INOUT) || hasColumn(cells, IDX_ALGO_PARA_REF)) {
+                throw new SpreadsheetLoadException(ctx, "Algorithm paramters have to start on the next line from the algorithm name and text definition");
+            }
             
             // now we search for the matching last row of that algorithm
             int end = start + 1;
@@ -1789,6 +1794,7 @@ protected void loadAlgorithmsSheet(SpaceSystem spaceSystem, String sheetName) {
             // Replace smart-quotes “ and ” with regular quotes "
             algorithm.setAlgorithmText(algorithmText.replaceAll("[\u201c\u201d]", "\""));
 
+            
             // In/out params
             String paraInout=null;
             Set<String> inputParameterRefs=new HashSet<String>();
diff --git a/yamcs-core/src/main/java/org/yamcs/yarch/YarchDatabase.java b/yamcs-core/src/main/java/org/yamcs/yarch/YarchDatabase.java
index e4b65e1d02..2e3b182a60 100755
--- a/yamcs-core/src/main/java/org/yamcs/yarch/YarchDatabase.java
+++ b/yamcs-core/src/main/java/org/yamcs/yarch/YarchDatabase.java
@@ -235,7 +235,7 @@ TableDefinition deserializeTableDefinition(File f) throws FileNotFoundException,
 
     /**
      * serializes to disk to the rootDir/name.def
-     * @param def
+     * @param algorithmDef
      */
     void serializeTableDefinition(TableDefinition td) {
         String fn=getRoot()+"/"+td.getName()+".def";
diff --git a/yamcs-core/src/main/java/org/yamcs/yarch/rocksdb/RDBFactory.java b/yamcs-core/src/main/java/org/yamcs/yarch/rocksdb/RDBFactory.java
index 06ab87b0ac..74476e490a 100755
--- a/yamcs-core/src/main/java/org/yamcs/yarch/rocksdb/RDBFactory.java
+++ b/yamcs-core/src/main/java/org/yamcs/yarch/rocksdb/RDBFactory.java
@@ -171,6 +171,10 @@ public void run() {
 
     public synchronized void dispose(YRDB rdb) {
         DbAndAccessTime daat = databases.get(rdb.getPath());
+        if(daat==null) {
+            log.error("Dispose called with an invalid rdb (already disposed??): {}", rdb.getPath());
+            return;
+        }
         daat.lastAccess = System.currentTimeMillis();
         daat.refcount--;
     }
diff --git a/yamcs-core/src/test/java/org/yamcs/ParameterArchiveIntegrationTest.java b/yamcs-core/src/test/java/org/yamcs/ParameterArchiveIntegrationTest.java
index 05c21595a5..f059efa76b 100755
--- a/yamcs-core/src/test/java/org/yamcs/ParameterArchiveIntegrationTest.java
+++ b/yamcs-core/src/test/java/org/yamcs/ParameterArchiveIntegrationTest.java
@@ -64,14 +64,14 @@ public void testRestRetrieval() throws Exception {
         Sample s0;
 
         //first two requests before the consolidation, should return data from cache
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(100, pdata.getParameterCount());
         engValue = pdata.getParameter(0).getEngValue();
         assertEquals(0.167291805148, engValue.getFloatValue(), 1e-5);
 
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2/samples?start=2015-01-02T11:40:00&stop=2015-01-02T12:00:00", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2/samples?start=2015-01-02T11:40:00&stop=2015-01-02T12:00:00", HttpMethod.GET, "").get();
         vals = (fromJson(resp, SchemaPvalue.TimeSeries.MERGE)).build();
         assertEquals(500, vals.getSampleCount());
         s0 = vals.getSample(0);
@@ -87,7 +87,7 @@ public void testRestRetrieval() throws Exception {
 
 
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2/samples?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2/samples?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
         vals = (fromJson(resp, SchemaPvalue.TimeSeries.MERGE)).build();
         assertEquals(500, vals.getSampleCount());
         s0 = vals.getSample(0);
@@ -96,18 +96,18 @@ public void testRestRetrieval() throws Exception {
         assertEquals(0.167291805148, s0.getAvg(), 1e-5);
 
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(100, pdata.getParameterCount());
         engValue = pdata.getParameter(0).getEngValue();
         assertEquals(0.167291805148, engValue.getFloatValue(), 1e-5);
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00&limit=10", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00&limit=10", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(10, pdata.getParameterCount());
 
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00&norepeat", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T10:00:00&stop=2015-01-02T11:00:00&norepeat", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
 
         assertEquals(1, pdata.getParameterCount());
@@ -122,7 +122,7 @@ public void testRestRetrieval() throws Exception {
         //add some realtime data
         generateData("2015-01-02T12:00:00", 10);
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T11:59:00&limit=20", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T11:59:00&limit=20", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(20, pdata.getParameterCount());
         long t = TimeEncoding.parse("2015-01-02T12:00:09.000");
@@ -134,7 +134,7 @@ public void testRestRetrieval() throws Exception {
 
 
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T12:00:00", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T12:00:00", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(9, pdata.getParameterCount());
         t = TimeEncoding.parse("2015-01-02T12:00:09.000");
@@ -145,14 +145,14 @@ public void testRestRetrieval() throws Exception {
         }
 
         //request excluding realtime cache
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T12:00:00&norealtime", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T12:00:00&norealtime", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(0, pdata.getParameterCount());
 
 
         //ascending request combining archive with cache
 
-        resp = restClient.doRequest("/archive/IntegrationTest/parameters2/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T11:59:50&order=asc", HttpMethod.GET, "").get();
+        resp = restClient.doRequest("/archive/IntegrationTest/parameters/REFMDB/SUBSYS1/FloatPara1_1_2?start=2015-01-02T11:59:50&order=asc", HttpMethod.GET, "").get();
         pdata = fromJson(resp, SchemaPvalue.ParameterData.MERGE).build();
         assertEquals(20, pdata.getParameterCount());
         t = TimeEncoding.parse("2015-01-02T11:59:50");
diff --git a/yamcs-core/src/test/java/org/yamcs/algorithms/AlgorithmManagerJavaTest.java b/yamcs-core/src/test/java/org/yamcs/algorithms/AlgorithmManagerJavaTest.java
new file mode 100755
index 0000000000..0673438592
--- /dev/null
+++ b/yamcs-core/src/test/java/org/yamcs/algorithms/AlgorithmManagerJavaTest.java
@@ -0,0 +1,206 @@
+package org.yamcs.algorithms;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.yamcs.ConfigurationException;
+import org.yamcs.InvalidIdentification;
+import org.yamcs.ProcessorException;
+import org.yamcs.ProcessorFactory;
+import org.yamcs.RefMdbPacketGenerator;
+import org.yamcs.YConfiguration;
+import org.yamcs.YProcessor;
+import org.yamcs.api.EventProducerFactory;
+import org.yamcs.management.ManagementService;
+import org.yamcs.parameter.ParameterConsumer;
+import org.yamcs.parameter.ParameterProvider;
+import org.yamcs.parameter.ParameterRequestManagerImpl;
+import org.yamcs.parameter.ParameterValue;
+import org.yamcs.tctm.SimpleTcTmService;
+import org.yamcs.utils.ValueUtility;
+import org.yamcs.xtce.Algorithm;
+import org.yamcs.xtce.InputParameter;
+import org.yamcs.xtce.Parameter;
+import org.yamcs.xtce.XtceDb;
+import org.yamcs.xtceproc.XtceDbFactory;
+
+/**
+ * Just a small sanity check to verify python/jython still works.
+ * Uses algorithms in the spreadsheet that are interpreted the same in javascript and python
+ */
+public class AlgorithmManagerJavaTest {
+    @BeforeClass
+    public static void setUpBeforeClass() throws Exception {
+        YConfiguration.setup(instance);
+        ManagementService.setup(false);
+        XtceDbFactory.reset();
+    }
+    static String instance = "refmdb";
+    private XtceDb db;
+    private YProcessor c;
+    private RefMdbPacketGenerator tmGenerator;
+    private ParameterRequestManagerImpl prm;
+
+    @Before
+    public void beforeEachTest() throws ConfigurationException, ProcessorException {
+        EventProducerFactory.setMockup(true);
+
+        db=XtceDbFactory.getInstance(instance);
+        assertNotNull(db.getParameter("/REFMDB/SUBSYS1/FloatPara1_1_2"));
+
+        tmGenerator=new RefMdbPacketGenerator();
+        List<ParameterProvider> paramProviderList = new ArrayList<ParameterProvider>();
+
+        Map<String, Object> jslib = new HashMap<String, Object>();
+        Map<String, Object> config = new HashMap<String, Object>();
+        jslib.put("python", Arrays.asList("mdb/algolib.py"));
+        jslib.put("JavaScript", Arrays.asList("mdb/algolib.js"));
+
+        config.put("libraries", jslib);
+        AlgorithmManager am = new AlgorithmManager(instance, config);
+        paramProviderList.add(am);
+
+
+        SimpleTcTmService tmtcs = new SimpleTcTmService(tmGenerator, paramProviderList, null);
+        c=ProcessorFactory.create(instance, "AlgorithmManagerJavaTest", "refmdb", tmtcs, "junit");
+        prm=c.getParameterRequestManager();
+    }
+
+
+    @After
+    public void afterEachTest() { // Prevents us from wrapping our code in try-finally
+        c.quit();
+    }
+
+    @Test
+    public void testJavaAlgo1() throws InvalidIdentification {
+        final ArrayList<ParameterValue> params=new ArrayList<ParameterValue>();
+        Parameter p = prm.getParameter("/REFMDB/SUBSYS1/AlgoJavaFloat1");
+        prm.addRequest(p, new ParameterConsumer() {
+            @Override
+            public void updateItems(int subscriptionId, List<ParameterValue> items) {
+        	params.addAll(items);
+            }
+        });
+
+        c.start();
+        tmGenerator.generate_PKT1_1();
+        assertEquals(1, params.size());
+        assertEquals(0.1672918, params.get(0).getEngValue().getDoubleValue(), 0.001);
+    }
+
+    @Test
+    public void testJavaAlgo2() throws InvalidIdentification {
+        final ArrayList<ParameterValue> params=new ArrayList<ParameterValue>();
+        Parameter p = prm.getParameter("/REFMDB/SUBSYS1/AlgoJavaFloat2");
+        prm.addRequest(p, new ParameterConsumer() {
+            @Override
+            public void updateItems(int subscriptionId, List<ParameterValue> items) {
+                params.addAll(items);
+            }
+        });
+
+        c.start();
+        tmGenerator.generate_PKT1_1();
+        assertEquals(1, params.size());
+        assertEquals(3.3672918, params.get(0).getEngValue().getDoubleValue(), 0.001);
+    }
+
+    @Test
+    public void testJavaAlgo3() throws InvalidIdentification {
+        final ArrayList<ParameterValue> params=new ArrayList<ParameterValue>();
+        Parameter p = prm.getParameter("/REFMDB/SUBSYS1/AlgoJavaFloat3");
+        prm.addRequest(p, new ParameterConsumer() {
+            @Override
+            public void updateItems(int subscriptionId, List<ParameterValue> items) {
+                params.addAll(items);
+            }
+        });
+
+        c.start();
+        tmGenerator.generate_PKT1_1();
+        assertEquals(1, params.size());
+        assertEquals(8.2672918, params.get(0).getEngValue().getDoubleValue(), 0.001);
+    }
+ 
+    public static class MyAlgo1 extends AbstractAlgorithmExecutor {
+        float v;
+        public MyAlgo1(Algorithm algorithmDef, AlgorithmExecutionContext execCtx) {
+            super(algorithmDef, execCtx);
+        }
+
+        @Override
+        public List<ParameterValue> runAlgorithm(long acqTime, long genTime) {
+            Parameter p = algorithmDef.getOutputSet().get(0).getParameter();
+            ParameterValue pv = new ParameterValue(p);
+           
+            pv.setEngineeringValue(ValueUtility.getDoubleValue(v));
+            return Arrays.asList(pv);
+        }
+
+        @Override
+        protected void updateInput(InputParameter inputParameter, ParameterValue newValue) {
+            v = newValue.getEngValue().getFloatValue();
+        }
+    }
+    
+    public static class MyAlgo2 extends AbstractAlgorithmExecutor {
+        double x;
+        float v;
+        public MyAlgo2(Algorithm algorithmDef, AlgorithmExecutionContext execCtx, Double x) {
+            super(algorithmDef, execCtx);
+            this.x = x;
+        }
+
+        @Override
+        public List<ParameterValue> runAlgorithm(long acqTime, long genTime) {
+            Parameter p = algorithmDef.getOutputSet().get(0).getParameter();
+            ParameterValue pv = new ParameterValue(p);
+           
+            pv.setEngineeringValue(ValueUtility.getDoubleValue(x+v));
+            return Arrays.asList(pv);
+        }
+
+        @Override
+        protected void updateInput(InputParameter inputParameter, ParameterValue newValue) {
+            v = newValue.getEngValue().getFloatValue();
+        }
+    }
+    
+    public static class MyAlgo3 extends AbstractAlgorithmExecutor {
+        int a;
+        double b;
+        String c;
+        float v;
+        public MyAlgo3(Algorithm algorithmDef, AlgorithmExecutionContext execCtx, Map<String, Object> m) {
+            super(algorithmDef, execCtx);
+            this.a = (Integer) m.get("a");
+            this.b = (Double) m.get("b");
+            this.c = (String) m.get("c");
+        }
+
+        @Override
+        public List<ParameterValue> runAlgorithm(long acqTime, long genTime) {
+            Parameter p = algorithmDef.getOutputSet().get(0).getParameter();
+            ParameterValue pv = new ParameterValue(p);
+           
+            pv.setEngineeringValue(ValueUtility.getDoubleValue(a+b+c.length()+v));
+            return Arrays.asList(pv);
+        }
+
+        @Override
+        protected void updateInput(InputParameter inputParameter, ParameterValue newValue) {
+            v = newValue.getEngValue().getFloatValue();
+        }
+    }
+}
