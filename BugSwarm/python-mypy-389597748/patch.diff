diff --git a/docs/source/basics.rst b/docs/source/basics.rst
deleted file mode 100755
index b4cf68c035..0000000000
--- a/docs/source/basics.rst
+++ /dev/null
@@ -1,189 +0,0 @@
-Basics
-======
-
-This chapter introduces some core concepts of mypy, including function
-annotations, the ``typing`` module and library stubs. Read it carefully,
-as the rest of documentation may not make much sense otherwise.
-
-Function signatures
-*******************
-
-A function without a type annotation is considered dynamically typed:
-
-.. code-block:: python
-
-   def greeting(name):
-       return 'Hello, {}'.format(name)
-
-You can declare the signature of a function using the Python 3
-annotation syntax (Python 2 is discussed later in :ref:`python2`).
-This makes the function statically typed, and that causes type
-checker report type errors within the function.
-
-Here's a version of the above function that is statically typed and
-will be type checked:
-
-.. code-block:: python
-
-   def greeting(name: str) -> str:
-       return 'Hello, {}'.format(name)
-
-If a function does not explicitly return a value we give the return
-type as ``None``. Using a ``None`` result in a statically typed
-context results in a type check error:
-
-.. code-block:: python
-
-   def p() -> None:
-       print('hello')
-
-   a = p()   # Type check error: p has None return value
-
-Arguments with default values can be annotated as follows:
-
-.. code-block:: python
-
-   def greeting(name: str, prefix: str = 'Mr.') -> str:
-      return 'Hello, {} {}'.format(name, prefix)
-
-Running mypy
-************
-
-You can type check a program by using the ``mypy`` tool, which is
-basically a linter -- it checks your program for errors without actually
-running it::
-
-   $ mypy program.py
-
-All errors reported by mypy are essentially warnings that you are free
-to ignore, if you so wish.
-
-The next chapter explains how to download and install mypy:
-:ref:`getting-started`.
-
-More command line options are documented in :ref:`command-line`.
-
-.. note::
-
-   Depending on how mypy is configured, you may have to run mypy like
-   this::
-
-     $ python3 -m mypy program.py
-
-The typing module
-*****************
-
-The ``typing`` module contains many definitions that are useful in
-statically typed code. You typically use ``from ... import`` to import
-them (we'll explain ``Iterable`` later in this document):
-
-.. code-block:: python
-
-   from typing import Iterable
-
-   def greet_all(names: Iterable[str]) -> None:
-       for name in names:
-           print('Hello, {}'.format(name))
-
-For brevity, we often omit the ``typing`` import in code examples, but
-mypy will give an error if you use definitions such as ``Iterable``
-without first importing them.
-
-Mixing dynamic and static typing
-********************************
-
-Mixing dynamic and static typing within a single file is often
-useful. For example, if you are migrating existing Python code to
-static typing, it may be easiest to do this incrementally, such as by
-migrating a few functions at a time. Also, when prototyping a new
-feature, you may decide to first implement the relevant code using
-dynamic typing and only add type signatures later, when the code is
-more stable.
-
-.. code-block:: python
-
-   def f():
-       1 + 'x'  # No static type error (dynamically typed)
-
-   def g() -> None:
-       1 + 'x'  # Type check error (statically typed)
-
-.. note::
-
-   The earlier stages of mypy, known as the semantic analysis, may
-   report errors even for dynamically typed functions. However, you
-   should not rely on this, as this may change in the future.
-
-.. _library-stubs:
-
-Library stubs and the Typeshed repo
-***********************************
-
-In order to type check code that uses library modules such as those
-included in the Python standard library, you need to have library
-*stubs*. A library stub defines a skeleton of the public interface
-of the library, including classes, variables and functions and
-their types, but dummy function bodies.
-
-For example, consider this code:
-
-.. code-block:: python
-
-  x = chr(4)
-
-Without a library stub, the type checker would have no way of
-inferring the type of ``x`` and checking that the argument to ``chr``
-has a valid type. Mypy incorporates the `typeshed
-<https://github.com/python/typeshed>`_ project, which contains library
-stubs for the Python builtins and the standard library. The stub for
-the builtins contains a definition like this for ``chr``:
-
-.. code-block:: python
-
-    def chr(code: int) -> str: ...
-
-In stub files we don't care about the function bodies, so we use
-an ellipsis instead.  That ``...`` is three literal dots!
-
-Mypy complains if it can't find a stub (or a real module) for a
-library module that you import. You can create a stub easily; here is
-an overview:
-
-* Write a stub file for the library and store it as a ``.pyi`` file in
-  the same directory as the library module.
-* Alternatively, put your stubs (``.pyi`` files) in a directory
-  reserved for stubs (e.g., ``myproject/stubs``). In this case you
-  have to set the environment variable ``MYPYPATH`` to refer to the
-  directory.  For example::
-
-    $ export MYPYPATH=~/work/myproject/stubs
-
-Use the normal Python file name conventions for modules, e.g. ``csv.pyi``
-for module ``csv``. Use a subdirectory with ``__init__.pyi`` for packages.
-
-If a directory contains both a ``.py`` and a ``.pyi`` file for the
-same module, the ``.pyi`` file takes precedence. This way you can
-easily add annotations for a module even if you don't want to modify
-the source code. This can be useful, for example, if you use 3rd party
-open source libraries in your program (and there are no stubs in
-typeshed yet).
-
-That's it! Now you can access the module in mypy programs and type check
-code that uses the library. If you write a stub for a library module,
-consider making it available for other programmers that use mypy
-by contributing it back to the typeshed repo.
-
-There is more information about creating stubs in the
-`mypy wiki <https://github.com/python/mypy/wiki/Creating-Stubs-For-Python-Modules>`_.
-The following sections explain the kinds of type annotations you can use
-in your programs and stub files.
-
-.. note::
-
-   You may be tempted to point ``MYPYPATH`` to the standard library or
-   to the ``site-packages`` directory where your 3rd party packages
-   are installed. This is almost always a bad idea -- you will likely
-   get tons of error messages about code you didn't write and that
-   mypy can't analyze all that well yet, and in the worst case
-   scenario mypy may crash due to some construct in a 3rd party
-   package that it didn't expect.
diff --git a/docs/source/cheat_sheet.rst b/docs/source/cheat_sheet.rst
index aec927b59e..efd140c93d 100755
--- a/docs/source/cheat_sheet.rst
+++ b/docs/source/cheat_sheet.rst
@@ -3,7 +3,8 @@
 Type hints cheat sheet (Python 2)
 =================================
 
-This document is a quick cheat sheet showing how the `PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_ type
+This document is a quick cheat sheet showing how the
+`PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_ type
 language represents various common types in Python 2.
 
 .. note::
@@ -21,35 +22,32 @@ Built-in types
 
    from typing import List, Set, Dict, Tuple, Text, Optional
 
-   # For simple built-in types, just use the name of the type.
-   x = 1 # type: int
-   x = 1.0 # type: float
-   x = True # type: bool
-   x = "test" # type: str
-   x = u"test" # type: unicode
+   # For simple built-in types, just use the name of the type
+   x = 1  # type: int
+   x = 1.0  # type: float
+   x = True  # type: bool
+   x = "test"  # type: str
+   x = u"test"  # type: unicode
 
    # For collections, the name of the type is capitalized, and the
-   # name of the type inside the collection is in brackets.
-   x = [1] # type: List[int]
-   x = set([6, 7]) # type: Set[int]
+   # name of the type inside the collection is in brackets
+   x = [1]  # type: List[int]
+   x = {6, 7}  # type: Set[int]
 
-   # Empty Tuple types are a bit special
-   x = ()  # type: Tuple[()]
+   # For mappings, we need the types of both keys and values
+   x = {'field': 2.0}  # type: Dict[str, float]
 
-   # For mappings, we need the types of both keys and values.
-   x = dict(field=2.0) # type: Dict[str, float]
+   # For tuples, we specify the types of all the elements
+   x = (3, "yes", 7.5)  # type: Tuple[int, str, float]
 
-   # For tuples, we specify the types of all the elements.
-   x = (3, "yes", 7.5) # type: Tuple[int, str, float]
+   # For textual data, use Text
+   # ("Text" means  "unicode" in Python 2 and "str" in Python 3)
+   x = [u"one", u"two"]  # type: List[Text]
 
-   # For textual data, use Text.
-   # This is `unicode` in Python 2 and `str` in Python 3.
-   x = ["string", u"unicode"] # type: List[Text]
-
-   # Use Optional for values that could be None.
-   input_str = f() # type: Optional[str]
-   if input_str is not None:
-      print input_str
+   # Use Optional[] for values that could be None
+   x = some_function()  # type: Optional[str]
+   if x is not None:
+      print x
 
 
 Functions
@@ -57,9 +55,9 @@ Functions
 
 .. code-block:: python
 
-   from typing import Callable, Iterable
+   from typing import Callable, Iterable, Union, Optional, List
 
-   # This is how you annotate a function definition.
+   # This is how you annotate a function definition
    def stringify(num):
        # type: (int) -> str
        """Your function docstring goes here after the type definition."""
@@ -70,29 +68,31 @@ Functions
    def greet_world(): # type: () -> None
        print "Hello, world!"
 
-   # And here's how you specify multiple arguments.
+   # And here's how you specify multiple arguments
    def plus(num1, num2):
        # type: (int, int) -> int
        return num1 + num2
 
-   # Add type annotations for kwargs as though they were positional args.
+   # Add type annotations for arguments with default values as though they
+   # had no defaults
    def f(num1, my_float=3.5):
        # type: (int, float) -> float
        return num1 + my_float
 
    # An argument can be declared positional-only by giving it a name
-   # starting with two underscores:
+   # starting with two underscores
    def quux(__x):
        # type: (int) -> None
        pass
+
    quux(3)  # Fine
    quux(__x=3)  # Error
 
-   # This is how you annotate a function value.
-   x = f # type: Callable[[int, float], float]
+   # This is how you annotate a callable (function) value
+   x = f  # type: Callable[[int, float], float]
 
    # A generator function that yields ints is secretly just a function that
-   # returns an iterable (see below) of ints, so that's how we annotate it.
+   # returns an iterable (see below) of ints, so that's how we annotate it
    def f(n):
        # type: (int) -> Iterable[int]
        i = 0
@@ -100,7 +100,7 @@ Functions
            yield i
            i += 1
 
-   # There's alternative syntax for functions with many arguments.
+   # There's an alternative syntax for functions with many arguments
    def send_email(address,     # type: Union[str, List[str]]
                   sender,      # type: str
                   cc,          # type: Optional[List[str]]
@@ -109,7 +109,7 @@ Functions
                   body=None    # type: List[str]
                   ):
        # type: (...) -> bool
-        <code>
+       <code>
 
 
 When you're puzzled or when things are complicated
@@ -117,59 +117,63 @@ When you're puzzled or when things are complicated
 
 .. code-block:: python
 
-   from typing import Union, Any, cast
+   from typing import Union, Any, List, Optional, cast
 
    # To find out what type mypy infers for an expression anywhere in
-   # your program, wrap it in reveal_type.  Mypy will print an error
+   # your program, wrap it in reveal_type().  Mypy will print an error
    # message with the type; remove it again before running the code.
-   reveal_type(1) # -> error: Revealed type is 'builtins.int'
+   reveal_type(1) # -> Revealed type is 'builtins.int'
 
-   # Use Union when something could be one of a few types.
-   x = [3, 5, "test", "fun"] # type: List[Union[int, str]]
+   # Use Union when something could be one of a few types
+   x = [3, 5, "test", "fun"]  # type: List[Union[int, str]]
 
    # Use Any if you don't know the type of something or it's too
-   # dynamic to write a type for.
-   x = mystery_function() # type: Any
+   # dynamic to write a type for
+   x = mystery_function()  # type: Any
+
+   # If you initialize a variable with an empty container or "None"
+   # you may have to help mypy a bit by providing a type annotation
+   x = []  # type: List[str]
+   x = None  # type: Optional[str]
 
-   # This is how to deal with varargs.
-   # This makes each positional arg and each keyword arg a 'str'.
+   # This makes each positional arg and each keyword arg a "str"
    def call(self, *args, **kwargs):
-            # type: (*str, **str) -> str
-            request = make_request(*args, **kwargs)
-            return self.do_api_query(request)
-   
-   # Use `ignore` to suppress type-checking on a given line, when your
-   # code confuses mypy or runs into an outright bug in mypy.
-   # Good practice is to comment every `ignore` with a bug link
+       # type: (*str, **str) -> str
+       request = make_request(*args, **kwargs)
+       return self.do_api_query(request)
+
+   # Use a "type: ignore" comment to suppress errors on a given line,
+   # when your code confuses mypy or runs into an outright bug in mypy.
+   # Good practice is to comment every "ignore" with a bug link
    # (in mypy, typeshed, or your own code) or an explanation of the issue.
    x = confusing_function() # type: ignore # https://github.com/python/mypy/issues/1167
 
-   # cast is a helper function for mypy that allows for guidance of how to convert types.
-   # it does not cast at runtime
+   # "cast" is a helper function that lets you override the inferred
+   # type of an expression. It's only for mypy -- there's no runtime check.
    a = [4]
-   b = cast(List[int], a)  # passes fine
-   c = cast(List[str], a)  # passes fine (no runtime check)
-   reveal_type(c)  # -> error: Revealed type is 'builtins.list[builtins.str]'
-   print(c)  # -> [4] the object is not cast
-
-   # if you want dynamic attributes on your class, have it override __setattr__ or __getattr__
-   # in a stub or in your source code.
-   # __setattr__ allows for dynamic assignment to names
-   # __getattr__ allows for dynamic access to names
+   b = cast(List[int], a)  # Passes fine
+   c = cast(List[str], a)  # Passes fine (no runtime check)
+   reveal_type(c)  # -> Revealed type is 'builtins.list[builtins.str]'
+   print c  # -> [4]; the object is not cast
+
+   # If you want dynamic attributes on your class, have it override "__setattr__"
+   # or "__getattr__" in a stub or in your source code.
+   #
+   # "__setattr__" allows for dynamic assignment to names
+   # "__getattr__" allows for dynamic access to names
    class A:
-       # this will allow assignment to any A.x, if x is the same type as `value`
+       # This will allow assignment to any A.x, if x is the same type as "value"
+       # (use "value: Any" to allow arbitrary types)
        def __setattr__(self, name, value):
            # type: (str, int) -> None
            ...
-   a.foo = 42  # works
-   a.bar = 'Ex-parrot'  # fails type checking
 
-   # TODO: explain "Need type annotation for variable" when
-   # initializing with None or an empty container
+   a.foo = 42  # Works
+   a.bar = 'Ex-parrot'  # Fails type checking
 
 
-Standard duck types
-*******************
+Standard "duck types"
+*********************
 
 In typical Python code, many functions that can take a list or a dict
 as an argument only need their argument to be somehow "list-like" or
@@ -181,23 +185,28 @@ that are common in idiomatic Python are standardized.
 
    from typing import Mapping, MutableMapping, Sequence, Iterable
 
-   # Use Iterable for generic iterables (anything usable in `for`),
-   # and Sequence where a sequence (supporting `len` and `__getitem__`) is required.
+   # Use Iterable for generic iterables (anything usable in "for"),
+   # and Sequence where a sequence (supporting "len" and "__getitem__") is
+   # required
    def f(iterable_of_ints):
        # type: (Iterable[int]) -> List[str]
        return [str(x) for x in iterator_of_ints]
+
    f(range(1, 3))
 
-   # Mapping describes a dict-like object (with `__getitem__`) that we won't mutate,
-   # and MutableMapping one (with `__setitem__`) that we might.
+   # Mapping describes a dict-like object (with "__getitem__") that we won't
+   # mutate, and MutableMapping one (with "__setitem__") that we might
    def f(my_dict):
        # type: (Mapping[int, str]) -> List[int]
        return list(my_dict.keys())
+
    f({3: 'yes', 4: 'no'})
+
    def f(my_mapping):
        # type: (MutableMapping[int, str]) -> Set[str]
        my_dict[5] = 'maybe'
        return set(my_dict.values())
+
    f({3: 'yes', 4: 'no'})
 
 
@@ -207,43 +216,36 @@ Classes
 .. code-block:: python
 
    class MyClass(object):
-
-       # For instance methods, omit `self`.
+       # For instance methods, omit type for "self"
        def my_method(self, num, str1):
            # type: (int, str) -> str
            return num * str1
 
-       # The __init__ method doesn't return anything, so it gets return
-       # type None just like any other method that doesn't return anything.
+       # The "__init__" method doesn't return anything, so it gets return
+       # type "None" just like any other method that doesn't return anything
        def __init__(self):
            # type: () -> None
            pass
 
-   # User-defined classes are written with just their own names.
-   x = MyClass() # type: MyClass
+   # User-defined classes are valid as types in annotations
+   x = MyClass()  # type: MyClass
 
 
-Other stuff
-***********
+Miscellaneous
+*************
 
 .. code-block:: python
 
    import sys
-   # typing.Match describes regex matches from the re module.
+   import re
    from typing import Match, AnyStr, IO
-   x = re.match(r'[0-9]+', "15") # type: Match[str]
 
-   # Use AnyStr for functions that should accept any kind of string
-   # without allowing different kinds of strings to mix.
-   def concat(a, b):
-       # type: (AnyStr, AnyStr) -> AnyStr
-       return a + b
-   concat(u"foo", u"bar")  # type: unicode
-   concat(b"foo", b"bar")  # type: bytes
+   # "typing.Match" describes regex matches from the re module
+   x = re.match(r'[0-9]+', "15")  # type: Match[str]
 
    # Use IO[] for functions that should accept or return any
-   # object that comes from an open() call. The IO[] does not
-   # distinguish between reading, writing or other modes.
+   # object that comes from an open() call (IO[] does not
+   # distinguish between reading, writing or other modes)
    def get_sys_IO(mode='w'):
        # type: (str) -> IO[str]
        if mode == 'w':
@@ -252,6 +254,3 @@ Other stuff
            return sys.stdin
        else:
            return sys.stdout
-
-   # TODO: add TypeVar and a simple generic function
-
diff --git a/docs/source/cheat_sheet_py3.rst b/docs/source/cheat_sheet_py3.rst
index cbd1ab266e..6085cd5bc5 100755
--- a/docs/source/cheat_sheet_py3.rst
+++ b/docs/source/cheat_sheet_py3.rst
@@ -3,8 +3,9 @@
 Type hints cheat sheet (Python 3)
 =================================
 
-This document is a quick cheat sheet showing how the `PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_ type
-language represents various common types in Python 3. Unless otherwise noted, the syntax is valid on all versions of Python 3.
+This document is a quick cheat sheet showing how the
+`PEP 484 <https://www.python.org/dev/peps/pep-0484/>`_ type
+annotation notation represents various common types in Python 3.
 
 .. note::
 
@@ -14,6 +15,33 @@ language represents various common types in Python 3. Unless otherwise noted, th
    annotation, and show the inferred types.
 
 
+Variables
+*********
+
+Python 3.6 introduced a syntax for annotating variables in
+`PEP 526 <https://www.python.org/dev/peps/pep-0526/>`_ and
+we use it in most examples.
+
+.. code-block:: python
+
+   # This is how you declare the type of a variable type in Python 3.6
+   x: int = 1
+
+   # In Python 3.5 and earlier you can use a type comment instead
+   # (equivalent to the previous definition)
+   x = 1  # type: int
+
+   # You don't need to initialize a variable to annotate it
+   a: int  # Ok (no value at runtime until assigned)
+
+   # The latter is useful in conditional branches
+   child: bool
+   if age < 18:
+       child = True
+   else:
+       child = False
+
+
 Built-in types
 **************
 
@@ -21,188 +49,151 @@ Built-in types
 
    from typing import List, Set, Dict, Tuple, Text, Optional, AnyStr
 
-   # For simple built-in types, just use the name of the type.
-   x = 1  # type: int
-   x = 1.0  # type: float
-   x = True  # type: bool
-   x = "test"  # type: str
-   x = u"test"  # type: str
-   x = b"test"  # type: bytes
+   # For simple built-in types, just use the name of the type
+   x: int = 1
+   x: float = 1.0
+   x: bool = True
+   x: str = "test"
+   x: str = u"test"
+   x: bytes = b"test"
 
    # For collections, the name of the type is capitalized, and the
-   # name of the type inside the collection is in brackets.
-   x = [1]  # type: List[int]
-   x = {6, 7}  # type: Set[int]
-
-   # Empty Tuple types are a bit special
-   x = ()  # type: Tuple[()]
-
-   # For mappings, we need the types of both keys and values.
-   x = {'field': 2.0}  # type: Dict[str, float]
+   # name of the type inside the collection is in brackets
+   x: List[int] = [1]
+   x: Set[int] = {6, 7}
 
-   # For tuples, we specify the types of all the elements.
-   x = (3, "yes", 7.5)  # type: Tuple[int, str, float]
+   # Same as bove, but with type comment syntax
+   x = [1]  # type: List[int]
 
-   # For textual data, use Text.
-   # This is `unicode` in Python 2 and `str` in Python 3.
-   x = ["string", u"unicode"]  # type: List[Text]
+   # For mappings, we need the types of both keys and values
+   x: Dict[str, float] = {'field': 2.0}
 
+   # For tuples, we specify the types of all the elements
+   x: Tuple[int, str, float] = (3, "yes", 7.5)
 
+   # For textual data, use Text if you care about Python 2 compatibility
+   # ("Text" means "unicode" in Python 2 and "str" in Python 3)
+   x: List[Text] = ["string", u"unicode"]
 
-   # Use Optional for values that could be None.
-   input_str = f()  # type: Optional[str]
-   if input_str is not None:
-      print(input_str)
+   # Use Optional[] for values that could be None
+   x: Optional[str] = some_function()
+   if x is not None:
+       print(x)
 
 
 Functions
 *********
 
-Python 3 introduces an annotation syntax for function declarations in `PEP 3107 <https://www.python.org/dev/peps/pep-3107/>`_.
+Python 3 supports an annotation syntax for function declarations.
 
 .. code-block:: python
 
    from typing import Callable, Iterable, Union, Optional, List
 
-   # This is how you annotate a function definition.
+   # This is how you annotate a function definition
    def stringify(num: int) -> str:
        return str(num)
-       
-   # And here's how you specify multiple arguments.
+
+   # And here's how you specify multiple arguments
    def plus(num1: int, num2: int) -> int:
        return num1 + num2
 
-   # Add type annotations for kwargs as though they were positional args.
+   # Add default value for an arugment after the type annotation
    def f(num1: int, my_float: float = 3.5) -> float:
        return num1 + my_float
 
-   # An argument can be declared positional-only by giving it a name
-   # starting with two underscores:
-   def quux(__x: int) -> None:
-       pass
-   quux(3)  # Fine
-   quux(__x=3)  # Error
-
-   # This is how you annotate a function value.
-   x = f # type: Callable[[int, float], float]
+   # This is how you annotate a callable (function) value
+   x: Callable[[int, float], float] = f
 
    # A generator function that yields ints is secretly just a function that
-   # returns an iterable (see below) of ints, so that's how we annotate it.
+   # returns an iterable (see below) of ints, so that's how we annotate it
    def f(n: int) -> Iterable[int]:
        i = 0
        while i < n:
            yield i
            i += 1
 
-   # For a function with many arguments, you can of course split it over multiple lines
+   # You can of course split a function annotation over multiple lines
    def send_email(address: Union[str, List[str]],
                   sender: str,
                   cc: Optional[List[str]],
                   bcc: Optional[List[str]],
                   subject='',
-                  body: List[str] = None
+                  body: Optional[List[str]] = None
                   ) -> bool:
-       
        ...
 
-Coroutines and asyncio
-**********************
-
-See :ref:`async-and-await` for the full detail on typing coroutines and asynchronous code.
-
-.. code-block:: python
-
-   import asyncio
-   from typing import Generator, Any
-
-   # A generator-based coroutine created with @asyncio.coroutine should have a
-   # return type of Generator[Any, None, T], where T is the type it returns.
-   @asyncio.coroutine
-   def countdown34(tag: str, count: int) -> Generator[Any, None, str]:
-       while count > 0:
-           print('T-minus {} ({})'.format(count, tag))
-           yield from asyncio.sleep(0.1)
-           count -= 1
-       return "Blastoff!"
-
-   # mypy currently does not support converting functions into generator-based
-   # coroutines in Python 3.4, so you need to add a 'yield' to make it
-   # typecheck.
-   @asyncio.coroutine
-   def async1(obj: object) -> Generator[None, None, str]:
-       if False:
-           yield
-       return "placeholder"
+   # An argument can be declared positional-only by giving it a name
+   # starting with two underscores:
+   def quux(__x: int) -> None:
+       pass
 
-   # A Python 3.5+ coroutine is typed like a normal function.
-   async def countdown35(tag: str, count: int) -> str:
-       while count > 0:
-           print('T-minus {} ({})'.format(count, tag))
-           await asyncio.sleep(0.1)
-           count -= 1
-       return "Blastoff!"
+   quux(3)  # Fine
+   quux(__x=3)  # Error
 
-   async def async2(obj: object) -> str:
-       return "placeholder"
 
 When you're puzzled or when things are complicated
 **************************************************
 
 .. code-block:: python
 
-   from typing import Union, Any, List, cast
+   from typing import Union, Any, List, Optional, cast
 
    # To find out what type mypy infers for an expression anywhere in
-   # your program, wrap it in reveal_type.  Mypy will print an error
+   # your program, wrap it in reveal_type().  Mypy will print an error
    # message with the type; remove it again before running the code.
-   reveal_type(1)  # -> error: Revealed type is 'builtins.int'
+   reveal_type(1)  # -> Revealed type is 'builtins.int'
 
-   # Use Union when something could be one of a few types.
-   x = [3, 5, "test", "fun"]  # type: List[Union[int, str]]
+   # Use Union when something could be one of a few types
+   x: List[Union[int, str]] = [3, 5, "test", "fun"]
 
    # Use Any if you don't know the type of something or it's too
-   # dynamic to write a type for.
-   x = mystery_function()  # type: Any
+   # dynamic to write a type for
+   x: Any = mystery_function()
 
-   # This is how to deal with varargs.
-   # This makes each positional arg and each keyword arg a 'str'.
+   # If you initialize a variable with an empty container or "None"
+   # you may have to help mypy a bit by providing a type annotation
+   x: List[str] = []
+   x: Optional[str] = None
+
+   # This makes each positional arg and each keyword arg a "str"
    def call(self, *args: str, **kwargs: str) -> str:
-            request = make_request(*args, **kwargs)
-            return self.do_api_query(request)
+       request = make_request(*args, **kwargs)
+       return self.do_api_query(request)
 
-   # Use `ignore` to suppress type-checking on a given line, when your
-   # code confuses mypy or runs into an outright bug in mypy.
-   # Good practice is to comment every `ignore` with a bug link
+   # Use a "type: ignore" comment to suppress errors on a given line,
+   # when your code confuses mypy or runs into an outright bug in mypy.
+   # Good practice is to comment every "ignore" with a bug link
    # (in mypy, typeshed, or your own code) or an explanation of the issue.
-   x = confusing_function()  # type: ignore # https://github.com/python/mypy/issues/1167
+   x = confusing_function()  # type: ignore  # https://github.com/python/mypy/issues/1167
 
-   # cast is a helper function for mypy that allows for guidance of how to convert types.
-   # it does not cast at runtime
+   # "cast" is a helper function that lets you override the inferred
+   # type of an expression. It's only for mypy -- there's no runtime check.
    a = [4]
-   b = cast(List[int], a)  # passes fine
-   c = cast(List[str], a)  # passes fine (no runtime check)
-   reveal_type(c)  # -> error: Revealed type is 'builtins.list[builtins.str]'
-   print(c)  # -> [4] the object is not cast
-
-   # if you want dynamic attributes on your class, have it override __setattr__ or __getattr__
-   # in a stub or in your source code.
-   # __setattr__ allows for dynamic assignment to names
-   # __getattr__ allows for dynamic access to names
+   b = cast(List[int], a)  # Passes fine
+   c = cast(List[str], a)  # Passes fine (no runtime check)
+   reveal_type(c)  # -> Revealed type is 'builtins.list[builtins.str]'
+   print(c)  # -> [4]; the object is not cast
+
+   # If you want dynamic attributes on your class, have it override "__setattr__"
+   # or "__getattr__" in a stub or in your source code.
+   #
+   # "__setattr__" allows for dynamic assignment to names
+   # "__getattr__" allows for dynamic access to names
    class A:
-       # this will allow assignment to any A.x, if x is the same type as `value`
+       # This will allow assignment to any A.x, if x is the same type as "value"
+       # (use "value: Any" to allow arbitrary types)
        def __setattr__(self, name: str, value: int) -> None: ...
-       # this will allow access to any A.x, if x is compatible with the return type
-       def __getattr__(self, name: str) -> int: ...
-   a.foo = 42  # works
-   a.bar = 'Ex-parrot'  # fails type checking
 
+       # This will allow access to any A.x, if x is compatible with the return type
+       def __getattr__(self, name: str) -> int: ...
 
-   # TODO: explain "Need type annotation for variable" when
-   # initializing with None or an empty container
+   a.foo = 42  # Works
+   a.bar = 'Ex-parrot'  # Fails type checking
 
 
-Standard duck types
-*******************
+Standard "duck types"
+*********************
 
 In typical Python code, many functions that can take a list or a dict
 as an argument only need their argument to be somehow "list-like" or
@@ -214,20 +205,25 @@ that are common in idiomatic Python are standardized.
 
    from typing import Mapping, MutableMapping, Sequence, Iterable, List, Set
 
-   # Use Iterable for generic iterables (anything usable in `for`),
-   # and Sequence where a sequence (supporting `len` and `__getitem__`) is required.
-   def f(iterable_of_ints: Iterable[int]) -> List[str]:
-       return [str(x) for x in iterable_of_ints]
+   # Use Iterable for generic iterables (anything usable in "for"),
+   # and Sequence where a sequence (supporting "len" and "__getitem__") is
+   # required
+   def f(ints: Iterable[int]) -> List[str]:
+       return [str(x) for x in ints]
+
    f(range(1, 3))
 
-   # Mapping describes a dict-like object (with `__getitem__`) that we won't mutate,
-   # and MutableMapping one (with `__setitem__`) that we might.
-   def f(my_dict: Mapping[int, str])-> List[int]:
+   # Mapping describes a dict-like object (with "__getitem__") that we won't
+   # mutate, and MutableMapping one (with "__setitem__") that we might
+   def f(my_dict: Mapping[int, str]) -> List[int]:
        return list(my_dict.keys())
+
    f({3: 'yes', 4: 'no'})
+
    def f(my_mapping: MutableMapping[int, str]) -> Set[str]:
        my_mapping[5] = 'maybe'
        return set(my_mapping.values())
+
    f({3: 'yes', 4: 'no'})
 
 
@@ -237,43 +233,69 @@ Classes
 .. code-block:: python
 
    class MyClass:
-       # The __init__ method doesn't return anything, so it gets return
-       # type None just like any other method that doesn't return anything.
+       # You can optionally declare instance variables in the class body
+       attr: int
+       # This is an instance variable with a default value
+       charge_percent: int = 100
+
+       # The "__init__" method doesn't return anything, so it gets return
+       # type "None" just like any other method that doesn't return anything
        def __init__(self) -> None:
            ...
-       # For instance methods, omit `self`.
+
+       # For instance methods, omit type for "self"
        def my_method(self, num: int, str1: str) -> str:
            return num * str1
 
+   # User-defined classes are valid as types in annotations
+   x: MyClass = MyClass()
+
+   # You can use the ClassVar annotation to declare a class variable
+   class Car:
+       seats: ClassVar[int] = 4
+       passengers: ClassVar[List[str]]
+
+   # You can also declare the type of an attribute in "__init__"
+   class Box:
+       def __init__(self) -> None:
+           self.items: List[str] = []
+
+
+Coroutines and asyncio
+**********************
+
+See :ref:`async-and-await` for the full detail on typing coroutines and asynchronous code.
+
+.. code-block:: python
 
+   import asyncio
+   from typing import Generator, Any
 
-   # User-defined classes are written with just their own names.
-   x = MyClass() # type: MyClass
+   # A coroutine is typed like a normal function
+   async def countdown35(tag: str, count: int) -> str:
+       while count > 0:
+           print('T-minus {} ({})'.format(count, tag))
+           await asyncio.sleep(0.1)
+           count -= 1
+       return "Blastoff!"
 
 
-Other stuff
-***********
+Miscellaneous
+*************
 
 .. code-block:: python
 
    import sys
    import re
-   # typing.Match describes regex matches from the re module.
    from typing import Match, AnyStr, IO
-   x = re.match(r'[0-9]+', "15")  # type: Match[str]
 
-   # You can use AnyStr to indicate that any string type will work
-   # but not to mix types
-   def full_name(first: AnyStr, last: AnyStr) -> AnyStr:
-       return first+last
-   full_name('Jon','Doe')  # same str ok
-   full_name(b'Bill', b'Bit')  # same binary ok
-   full_name(b'Terry', 'Trouble')  # different str types, fails
+   # "typing.Match" describes regex matches from the re module
+   x: Match[str] = re.match(r'[0-9]+', "15")
 
    # Use IO[] for functions that should accept or return any
-   # object that comes from an open() call. The IO[] does not
-   # distinguish between reading, writing or other modes.
-   def get_sys_IO(mode='w') -> IO[str]:
+   # object that comes from an open() call (IO[] does not
+   # distinguish between reading, writing or other modes)
+   def get_sys_IO(mode: str = 'w') -> IO[str]:
        if mode == 'w':
            return sys.stdout
        elif mode == 'r':
@@ -281,69 +303,15 @@ Other stuff
        else:
            return sys.stdout
 
-   # forward references are useful if you want to reference a class before it is designed
-   
-   def f(foo: A) -> int:  # this will fail
+   # Forward references are useful if you want to reference a class before
+   # it is defined
+   def f(foo: A) -> int:  # This will fail
        ...
-   
+
    class A:
        ...
-       
-   # however, using the string 'A', it will pass as long as there is a class of that name later on
-   def f(foo: 'A') -> int:
-       ...
-
-   # TODO: add TypeVar and a simple generic function
-
-Variable Annotation in Python 3.6 with PEP 526
-**********************************************
 
-Python 3.6 brings new syntax for annotating variables with `PEP 526 <https://www.python.org/dev/peps/pep-0526/>`_.
-Mypy brings limited support for PEP 526 annotations.
-
-
-.. code-block:: python
-
-   # annotation is similar to arguments to functions
-   name: str = "Eric Idle"
-   
-   # class instances can be annotated as follows
-   mc : MyClass = MyClass()
-   
-   # tuple packing can be done as follows
-   tu: Tuple[str, ...] = ('a', 'b', 'c')
-   
-   # annotations are not checked at runtime
-   year: int = '1972'  # error in type checking, but works at runtime
-   
-   # these are all equivalent
-   hour = 24 # type: int
-   hour: int; hour = 24
-   hour: int = 24
-   
-   # you do not (!) need to initialize a variable to annotate it
-   a: int # ok for type checking and runtime
-   
-   # which is useful in conditional branches
-   child: bool
-   if age < 18:
-       child = True
-   else:
-       child = False
-   
-   # annotations for classes are for instance variables (those created in __init__ or __new__)
-   class Battery:
-       charge_percent: int = 100  # this is an instance variable with a default value
-       capacity: int  # an instance variable without a default
-       
-   # you can use the ClassVar annotation to make the variable a class variable instead of an instance variable.
-   class Car:
-       seats: ClassVar[int] = 4
-       passengers: ClassVar[List[str]]
-       
-    # You can also declare the type of an attribute in __init__
-    class Box:
-        def __init__(self) -> None:
-            self.items: List[str] = []
-   
-Please see :ref:`python-36` for more on mypy's compatibility with Python 3.6's new features.
+   # If you use the string literal 'A', it will pass as long as there is a
+   # class of that name later on in the file
+   def f(foo: 'A') -> int:  # Ok
+       ...
diff --git a/docs/source/common_issues.rst b/docs/source/common_issues.rst
index e2fc4822ca..a93b79c135 100755
--- a/docs/source/common_issues.rst
+++ b/docs/source/common_issues.rst
@@ -561,7 +561,6 @@ the protocol definition:
        x = 42
    fun(C())  # OK
 
-
 Dealing with conflicting names
 ------------------------------
 
@@ -589,3 +588,16 @@ renaming the method, a work-around is to use an alias:
            ...
        def register(self, path: bytes_):
            ...
+
+I need a mypy bug fix that hasn't been released yet
+---------------------------------------------------
+
+You can install the latest development version of mypy from source. Clone the
+`mypy repository on GitHub <https://github.com/python/mypy>`_, and then run
+``pip install`` locally:
+
+.. code-block:: text
+
+    git clone --recurse-submodules https://github.com/python/mypy.git
+    cd mypy
+    sudo python3 -m pip install --upgrade .
diff --git a/docs/source/existing_code.rst b/docs/source/existing_code.rst
new file mode 100755
index 0000000000..c56aab0676
--- /dev/null
+++ b/docs/source/existing_code.rst
@@ -0,0 +1,179 @@
+.. _existing-code:
+
+Using mypy with an existing codebase
+====================================
+
+This section explains how to get started using mypy with an existing,
+significant codebase that has little or no type annotations. If you are
+a beginner, you can skip this section.
+
+These steps will get you started with mypy on an existing codebase:
+
+1. Start small -- get a clean mypy build for some files, with few
+   annotations
+
+2. Write a mypy runner script to ensure consistent results
+
+3. Run mypy in Continuous Integration to prevent type errors
+
+4. Gradually annotate commonly imported modules
+
+5. Write annotations as you modify existing code and write new code
+
+6. Use MonkeyType or PyAnnotate to automatically annotate legacy code
+
+We discuss all of these points in some detail below, and a few optional
+follow-up steps.
+
+Start small
+-----------
+
+If your codebase is large, pick a subset of your codebase (say, 5,000
+to 50,000 lines) and run mypy only on this subset at first,
+*without any annotations*. This shouldn't take more than a day or two
+to implement, so you start enjoying benefits soon.
+
+You'll likely need to fix some mypy errors, either by inserting
+annotations requested by mypy or by adding ``# type: ignore``
+comments to silence errors you don't want to fix now.
+
+In particular, mypy often generates errors about modules that it can't
+find or that don't have stub files:
+
+.. code-block:: text
+
+    core/config.py:7: error: Cannot find module named 'frobnicate'
+    core/model.py:9: error: Cannot find module named 'acme'
+    ...
+
+This is normal, and you can easily ignore these errors. For example,
+here we ignore an error about a third-party module ``frobnicate`` that
+doesn't have stubs using ``# type: ignore``:
+
+.. code-block:: python
+
+   import frobnicate  # type: ignore
+   ...
+   frobnicate.initialize()  # OK (but not checked)
+
+You can also use a mypy configuration file, which is convenient if
+there are a large number of errors to ignore. For example, to disable
+errors about importing ``frobnicate`` and ``acme`` everwhere in your
+codebase, use a config like this:
+
+.. code-block:: text
+
+   [mypy-frobnicate.*]
+   ignore_missing_imports = True
+
+   [mypy-acme.*]
+   ignore_missing_imports = True
+
+You can add multiple sections for different modules that should be
+ignored.
+
+If your config file is named ``mypy.ini``, this is how you run mypy:
+
+.. code-block:: text
+
+   mypy --config-file mypy.ini mycode/
+
+If you get a large number of errors, you may want to ignore all errors
+about missing imports.  This can easily cause problems later on and
+hide real errors, and it's only recommended as a last resort.
+For more details, look :ref:`here <follow-imports>`.
+
+Mypy follows imports by default. This can result in a few files passed
+on the command line causing mypy to process a large number of imported
+files, resulting in lots of errors you don't want to deal with at the
+moment. There is a config file option to disable this behavior, but
+since this can hide errors, it's not recommended for most users.
+
+Mypy runner script
+------------------
+
+Introduce a mypy runner script that runs mypy, so that every developer
+will use mypy consistently. Here are some things you may want to do in
+the script:
+
+* Ensure that the correct version of mypy is installed.
+
+* Specify mypy config file or command-line options.
+
+* Provide set of files to type check. You may want to implement
+  inclusion and exclusion filters for full control of the file
+  list.
+
+Continuous Integration
+----------------------
+
+Once you have a clean mypy run and a runner script for a part
+of your codebase, set up your Continuous Integration (CI) system to
+run mypy to ensure that developers won't introduce bad annotations.
+A simple CI script could look something like this:
+
+.. code-block:: text
+
+    python3 -m pip install mypy==0.600  # Pinned version avoids surprises
+    scripts/mypy  # Runs with the correct options
+
+Annotate widely imported modules
+--------------------------------
+
+Most projects have some widely imported modules, such as utilities or
+model classes. It's a good idea to annotate these pretty early on,
+since this allows code using these modules to be type checked more
+effectively. Since mypy supports gradual typing, it's okay to leave
+some of these modules unannotated. The more you annotate, the more
+useful mypy will be, but even a little annotation coverage is useful.
+
+Write annotations as you go
+---------------------------
+
+Now you are ready to include type annotations in your development
+workflows. Consider adding something like these in your code style
+conventions:
+
+1. Developers should add annotations for any new code.
+2. It's also encouraged to write annotations when you modify existing code.
+
+This way you'll gradually increase annotation coverage in your
+codebase without much effort.
+
+Automate annotation of legacy code
+----------------------------------
+
+There are tools for automatically adding draft annotations
+based on type profiles collected at runtime.  Tools include
+`MonkeyType <https://github.com/Instagram/MonkeyType>`_
+(Python 3) and `PyAnnotate <https://github.com/dropbox/pyannotate>`_
+(type comments only).
+
+A simple approach is to collect types from test runs. This may work
+well if your test coverage is good (and if your tests aren't very
+slow).
+
+Another approach is to enable type collection for a small, random
+fraction of production network requests.  This clearly requires more
+care, as type collection could impact the reliability or the
+performance of your service.
+
+Speed up mypy runs
+------------------
+
+You can use :ref:`mypy daemon <mypy_daemon>` to get much faster
+incremental mypy runs. The larger your project is, the more useful
+this will be.  If your project has at least 100,000 lines of code or
+so, you may also want to set up :ref:`remote caching <remote-cache>`
+for further speedups.
+
+Introduce stricter options
+--------------------------
+
+Mypy is very configurable. Once you get started with static typing,
+you may want to explore the various
+strictness options mypy provides to
+catch more bugs. For example, you can ask mypy to require annotations
+for all functions in certain modules to avoid accidentally introducing
+code that won't be type checked. Refer to :ref:`command-line` for the
+details.
diff --git a/docs/source/getting_started.rst b/docs/source/getting_started.rst
index 6294c497a1..64524d99ce 100755
--- a/docs/source/getting_started.rst
+++ b/docs/source/getting_started.rst
@@ -1,31 +1,209 @@
-.. _getting-started:
-
 Getting started
 ===============
 
-Installation
-************
+This chapter introduces some core concepts of mypy, including function
+annotations, the ``typing`` module and library stubs. Read it carefully,
+as the rest of documentation may not make much sense otherwise.
+
+Installing mypy
+***************
 
 Mypy requires Python 3.4 or later to run.  Once you've
 `installed Python 3 <https://www.python.org/downloads/>`_,
-you can install mypy with:
+you can install mypy using pip:
 
 .. code-block:: text
 
-    $ python3 -m pip install mypy
+    python3 -m pip install mypy
 
 Note that even though you need Python 3 to run ``mypy``, type checking
-Python 2 code is fully supported, as discussed in :ref:`python2`.
+Python 2 code is fully supported, as discussed later in :ref:`python2`.
+
+Running mypy
+************
 
-Installing from source
-**********************
+You can type check a program by using the ``mypy`` tool, which is
+basically a linter -- it checks your program for errors without actually
+running it::
 
-To install mypy from source, clone the
-`mypy repository on GitHub <https://github.com/python/mypy>`_ and then run
-``pip install`` locally:
+   $ mypy program.py
 
-.. code-block:: text
+All errors reported by mypy are essentially warnings that you are free
+to ignore, if you so wish.
+
+.. note::
+
+   Depending on how mypy is configured, you may have to run mypy like
+   this::
+
+     $ python3 -m mypy program.py
+
+If you haven't added any type annotations to your program yet, you
+should add some first, as mypy won't report many errors in unannotated
+functions. Don't worry if you aren't familiar with type annotations --
+we'll discuss them in detail in much of the rest of this guide.
+
+Mypy supports many command line options that you can use to tweak how
+mypy behaves.  They are documented in :ref:`command-line`.
+
+Function signatures
+*******************
+
+A function without a type annotation is considered *dynamically typed* by
+mypy:
+
+.. code-block:: python
+
+   def greeting(name):
+       return 'Hello, {}'.format(name)
+
+You can declare the signature of a function using the Python 3
+annotation syntax (Python 2 is discussed later in :ref:`python2`).
+This makes the function statically typed, which causes mypy to
+report type errors within the function.
+
+Here's a version of the above function that is statically typed and
+will be type checked:
+
+.. code-block:: python
+
+   def greeting(name: str) -> str:
+       return 'Hello, {}'.format(name)
+
+Now mypy will reject the following call, since the argument has an
+incompatible type:
+
+.. code-block:: python
+
+   def greeting(name: str) -> str:
+       return 'Hello, {}'.format(name)
+
+   greeting(b'Alice')  # Argument 1 to "greeting" has incompatible type "bytes"; expected "str"
+
+If a function does not explicitly return a value we give the return
+type as ``None``. Using a ``None`` result in a statically typed
+context results in a type check error:
+
+.. code-block:: python
+
+   def p() -> None:
+       print('hello')
+
+   a = p()  # Error: "p" does not return a value
+
+Arguments with default values can be annotated as follows:
+
+.. code-block:: python
+
+   def greeting(name: str, excited: bool = False) -> str:
+       message = 'Hello, {}'.format(name)
+       if excited:
+           message += '!!!'
+       return message
+
+Mixing dynamic and static typing within a single file is often
+useful. For example, if you are migrating existing Python code to
+static typing, it may be easiest to do this incrementally, such as by
+migrating a few functions at a time. Also, when prototyping a new
+feature, you may decide to first implement the relevant code using
+dynamic typing and only add type signatures later, when the code is
+more stable.
+
+.. code-block:: python
+
+   def f():
+       1 + 'x'  # No static type error (dynamically typed)
+
+   def g() -> None:
+       1 + 'x'  # Type check error (statically typed)
+
+.. note::
+
+   The earlier stages of mypy, known as the semantic analysis, may
+   report errors even for dynamically typed functions. However, you
+   should not rely on this, as this may change in the future.
+
+The typing module
+*****************
+
+The ``typing`` module contains many definitions that are useful in
+statically typed code. You typically use ``from ... import`` to import
+them (we'll explain ``Iterable`` later in this document):
+
+.. code-block:: python
+
+   from typing import Iterable
+
+   def greet_all(names: Iterable[str]) -> None:
+       for name in names:
+           print('Hello, {}'.format(name))
+
+For brevity, we often omit the ``typing`` import in code examples, but
+mypy will give an error if you use definitions such as ``Iterable``
+without first importing them.
+
+.. _stubs-intro:
+
+Library stubs and typeshed
+**************************
+
+Mypy uses library *stubs* to type check code interacting with library
+modules, including the Python standard library. A library stub defines
+a skeleton of the public interface of the library, including classes,
+variables and functions, and their types. Mypy ships with stubs from
+the `typeshed <https://github.com/python/typeshed>`_ project, which
+contains library stubs for the Python builtins, the standard library,
+and selected third-party packages.
+
+For example, consider this code:
+
+.. code-block:: python
+
+  x = chr(4)
+
+Without a library stub, mypy would have no way of inferring the type of ``x``
+and checking that the argument to ``chr`` has a valid type.
+
+Mypy complains if it can't find a stub (or a real module) for a
+library module that you import. Some modules ship with stubs that mypy
+can automatically find, or you can install a 3rd party module with
+additional stubs (see :ref:`installed-packages` for details).  You can
+also :ref:`create stubs <stub-files>` easily. We discuss ways of
+silencing complaints about missing stubs in :ref:`existing-code`.
+
+Next steps
+**********
+
+If you are in a hurry and don't want to read lots of documentation
+before getting started, here are some pointers to quick learning
+resources:
+
+* Read the :ref:`mypy cheatsheet <cheat-sheet-py3>` (also for
+  :ref:`Python 2 <cheat-sheet-py2>`).
+
+* Read :ref:`existing-code` if you have a significant existing
+  codebase without many type annotations.
+
+* Read the `blog post <http://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/>`_
+  about the Zulip project's experiences with adopting mypy.
+
+* If you prefer watching talks instead of reading, here are
+  some ideas:
+
+  * Carl Meyer:
+    `Type Checked Python in the Real World <https://www.youtube.com/watch?v=pMgmKJyWKn8>`_
+    (PyCon 2018)
+
+  * Greg Price:
+    `Clearer Code at Scale: Static Types at Zulip and Dropbox <https://www.youtube.com/watch?v=0c46YHS3RY8>`_
+    (PyCon 2018)
+
+* Look at :ref:`solutions to common issues <common_issues>` with mypy if
+  you encounter problems.
+
+* You can ask questions about mypy in the
+  `mypy issue tracker <https://github.com/python/mypy/issues>`_ and
+  typing `Gitter chat <https://gitter.im/python/typing>`_.
 
-    $ git clone --recurse-submodules https://github.com/python/mypy.git
-    $ cd mypy
-    $ sudo python3 -m pip install --upgrade .
+You can also continue reading this document and skip sections that
+aren't relevant for you. You don't need to read sections in order.
diff --git a/docs/source/index.rst b/docs/source/index.rst
index 309119462b..00e9746184 100755
--- a/docs/source/index.rst
+++ b/docs/source/index.rst
@@ -13,8 +13,8 @@ Mypy is a static type checker for Python 3 and Python 2.7.
    :caption: First steps
 
    introduction
-   basics
    getting_started
+   existing_code
 
 .. toctree::
    :maxdepth: 2
@@ -27,16 +27,17 @@ Mypy is a static type checker for Python 3 and Python 2.7.
    :maxdepth: 2
    :caption: Type system reference
 
-   python2
    builtin_types
    type_inference_and_annotations
    kinds_of_types
    class_basics
    protocols
    metaclasses
+   python2
    dynamic_typing
    casts
    duck_type_compatibility
+   stubs
    generics
    more_types
 
diff --git a/docs/source/introduction.rst b/docs/source/introduction.rst
index d84027ae07..9b427ffd20 100755
--- a/docs/source/introduction.rst
+++ b/docs/source/introduction.rst
@@ -13,8 +13,8 @@ Using the Python 3 function annotation syntax (using the
 a comment-based annotation syntax for Python 2 code, you will be able to
 efficiently annotate your code and use mypy to check the code for common
 errors. Mypy has a powerful and easy-to-use type system with modern features
-such as type inference, generics, function types, tuple types, and
-union types.
+such as type inference, generics, callable types, tuple types,
+union types, and structural subtyping.
 
 As a developer, you decide how to use mypy in your workflow. You can always
 escape to dynamic typing as mypy's approach to static typing doesn't restrict
diff --git a/docs/source/revision_history.rst b/docs/source/revision_history.rst
index e90be133e3..084fbac80c 100755
--- a/docs/source/revision_history.rst
+++ b/docs/source/revision_history.rst
@@ -180,7 +180,7 @@ detailed release notes):
 - November 2016
     * Publish ``mypy-lang`` version 0.4.6 on PyPI.
 
-    * Add :ref:`getting-started`.
+    * Add Getting started.
 
     * Add :ref:`generic-methods-and-generic-self` (experimental).
 
@@ -268,7 +268,7 @@ detailed release notes):
     * Document Python 2 support.
 
 - Nov 2015
-    Add :ref:`library-stubs`.
+    Add :ref:`stubs-intro`.
 
 - Jun 2015
     Remove ``Undefined`` and ``Dynamic``, as they are not in PEP 484.
diff --git a/docs/source/stubs.rst b/docs/source/stubs.rst
new file mode 100755
index 0000000000..170b829586
--- /dev/null
+++ b/docs/source/stubs.rst
@@ -0,0 +1,78 @@
+.. _stub-files:
+
+Stub files
+==========
+
+Mypy uses stub files stored in the
+`typeshed <https://github.com/python/typeshed>`_ repository to determine
+the types of standard library and third-party library functions, classes,
+and other definitions. You can also create your own stubs that will be
+used to type check your code. The basic properties of stubs were introduced
+back in :ref:`stubs-intro`.
+
+Creating a stub
+***************
+
+Here is an overview of how to create a stub file:
+
+* Write a stub file for the library (or an arbirary module) and store it as
+  a ``.pyi`` file in the same directory as the library module.
+* Alternatively, put your stubs (``.pyi`` files) in a directory
+  reserved for stubs (e.g., ``myproject/stubs``). In this case you
+  have to set the environment variable ``MYPYPATH`` to refer to the
+  directory.  For example::
+
+    $ export MYPYPATH=~/work/myproject/stubs
+
+Use the normal Python file name conventions for modules, e.g. ``csv.pyi``
+for module ``csv``. Use a subdirectory with ``__init__.pyi`` for packages.
+
+If a directory contains both a ``.py`` and a ``.pyi`` file for the
+same module, the ``.pyi`` file takes precedence. This way you can
+easily add annotations for a module even if you don't want to modify
+the source code. This can be useful, for example, if you use 3rd party
+open source libraries in your program (and there are no stubs in
+typeshed yet).
+
+That's it! Now you can access the module in mypy programs and type check
+code that uses the library. If you write a stub for a library module,
+consider making it available for other programmers that use mypy
+by contributing it back to the typeshed repo.
+
+There is more information about creating stubs in the
+`mypy wiki <https://github.com/python/mypy/wiki/Creating-Stubs-For-Python-Modules>`_.
+The following sections explain the kinds of type annotations you can use
+in your programs and stub files.
+
+.. note::
+
+   You may be tempted to point ``MYPYPATH`` to the standard library or
+   to the ``site-packages`` directory where your 3rd party packages
+   are installed. This is almost always a bad idea -- you will likely
+   get tons of error messages about code you didn't write and that
+   mypy can't analyze all that well yet, and in the worst case
+   scenario mypy may crash due to some construct in a 3rd party
+   package that it didn't expect.
+
+Stub file syntax
+****************
+
+Stub files are written in normal Python 3 syntax, but generally
+leaving out runtime logic like variable initializers, function bodies,
+and default arguments, or replacing them with ellipses.
+
+In this example, each ellipsis ``...`` is literally written in the
+stub file as three dots:
+
+.. code-block:: python
+
+    x: int
+
+    def afunc(code: str) -> int: ...
+    def afunc(a: int, b: int = ...) -> int: ...
+
+.. note::
+
+    The ellipsis ``...`` is also used with a different meaning in
+    :ref:`callable types <callable-types>` and :ref:`tuple types
+    <tuple-types>`.
diff --git a/docs/source/type_inference_and_annotations.rst b/docs/source/type_inference_and_annotations.rst
index 117e8ecf6a..080b491af8 100755
--- a/docs/source/type_inference_and_annotations.rst
+++ b/docs/source/type_inference_and_annotations.rst
@@ -216,27 +216,3 @@ to be annotated with a starred type:
     p, q, *rs = 1, 2  # type: int, int, *List[int]
 
 Here, the type of ``rs`` is set to ``List[int]``.
-
-Types in stub files
-*******************
-
-:ref:`Stub files <library-stubs>` are written in normal Python 3
-syntax, but generally leaving out runtime logic like variable
-initializers, function bodies, and default arguments, or replacing them
-with ellipses.
-
-In this example, each ellipsis ``...`` is literally written in the
-stub file as three dots:
-
-.. code-block:: python
-
-    x: int
-
-    def afunc(code: str) -> int: ...
-    def afunc(a: int, b: int = ...) -> int: ...
-
-.. note::
-
-    The ellipsis ``...`` is also used with a different meaning in
-    :ref:`callable types <callable-types>` and :ref:`tuple types
-    <tuple-types>`.
diff --git a/mypy/main.py b/mypy/main.py
index e74c791387..fe26b75fcf 100755
--- a/mypy/main.py
+++ b/mypy/main.py
@@ -322,23 +322,26 @@ def add_invertible_flag(flag: str,
                             default: bool,
                             dest: Optional[str] = None,
                             help: str,
-                            strict_flag: bool = False
+                            strict_flag: bool = False,
+                            group: Optional[argparse._ActionsContainer] = None
                             ) -> None:
         if inverse is None:
             inverse = invert_flag_name(flag)
+        if group is None:
+            group = parser
 
         if help is not argparse.SUPPRESS:
             help += " (inverse: {})".format(inverse)
 
-        arg = parser.add_argument(flag,
-                                  action='store_false' if default else 'store_true',
-                                  dest=dest,
-                                  help=help)
+        arg = group.add_argument(flag,
+                                 action='store_false' if default else 'store_true',
+                                 dest=dest,
+                                 help=help)
         dest = arg.dest
-        arg = parser.add_argument(inverse,
-                                  action='store_true' if default else 'store_false',
-                                  dest=dest,
-                                  help=argparse.SUPPRESS)
+        arg = group.add_argument(inverse,
+                                 action='store_true' if default else 'store_false',
+                                 dest=dest,
+                                 help=argparse.SUPPRESS)
         if strict_flag:
             assert dest is not None
             strict_flag_names.append(flag)
@@ -351,125 +354,249 @@ def add_invertible_flag(flag: str,
     parser.add_argument('-v', '--verbose', action='count', dest='verbosity',
                         help="more verbose messages")
     parser.add_argument('-V', '--version', action='version',
-                        version='%(prog)s ' + __version__)
-    parser.add_argument('--python-version', type=parse_version, metavar='x.y',
-                        help='use Python x.y', dest='special-opts:python_version')
-    parser.add_argument('--python-executable', action='store', metavar='EXECUTABLE',
-                        help="Python executable used for finding PEP 561 compliant installed"
-                             " packages and stubs", dest='special-opts:python_executable')
-    parser.add_argument('--no-site-packages', action='store_true',
-                        dest='special-opts:no_executable',
-                        help="Do not search for installed PEP 561 compliant packages")
-    parser.add_argument('--platform', action='store', metavar='PLATFORM',
-                        help="typecheck special-cased code for the given OS platform "
-                             "(defaults to sys.platform)")
-    parser.add_argument('-2', '--py2', dest='python_version', action='store_const',
-                        const=defaults.PYTHON2_VERSION, help="use Python 2 mode")
-    parser.add_argument('--ignore-missing-imports', action='store_true',
-                        help="silently ignore imports of missing modules")
-    parser.add_argument('--follow-imports', choices=['normal', 'silent', 'skip', 'error'],
-                        default='normal', help="how to treat imports (default normal)")
-    parser.add_argument('--disallow-any-unimported', default=False, action='store_true',
-                        help="disallow Any types resulting from unfollowed imports")
-    parser.add_argument('--disallow-any-expr', default=False, action='store_true',
-                        help='disallow all expressions that have type Any')
-    parser.add_argument('--disallow-any-decorated', default=False, action='store_true',
-                        help='disallow functions that have Any in their signature '
-                             'after decorator transformation')
-    parser.add_argument('--disallow-any-explicit', default=False, action='store_true',
-                        help='disallow explicit Any in type positions')
-    parser.add_argument('--disallow-any-generics', default=False, action='store_true',
-                        help='disallow usage of generic types that do not specify explicit '
-                             'type parameters')
+                        version='%(prog)s ' + __version__,
+                        help="show program's version number and exit")
+
+    config_group = parser.add_argument_group(
+        title='config file',
+        description="Use a config file instead of command line arguments.")
+    config_group.add_argument(
+        '--config-file',
+        help="configuration file, must have a [mypy] section "
+             "(defaults to {})".format(', '.join(defaults.CONFIG_FILES)))
+    add_invertible_flag('--warn-unused-configs', default=False, strict_flag=True,
+                        help="warn about unused '[mypy-<pattern>]' config sections",
+                        group=config_group)
+
+    imports_group = parser.add_argument_group(
+        title='import discovery',
+        description="Configure how imports are discovered and followed.")
+    imports_group.add_argument(
+        '--ignore-missing-imports', action='store_true',
+        help="silently ignore imports of missing modules")
+    imports_group.add_argument(
+        '--follow-imports', choices=['normal', 'silent', 'skip', 'error'],
+        default='normal', help="how to treat imports (default normal)")
+    imports_group.add_argument(
+        '--python-executable', action='store', metavar='EXECUTABLE',
+        help="Python executable used for finding PEP 561 compliant installed"
+             " packages and stubs",
+        dest='special-opts:python_executable')
+    imports_group.add_argument(
+        '--no-site-packages', action='store_true',
+        dest='special-opts:no_executable',
+        help="do not search for installed PEP 561 compliant packages")
+
+    platform_group = parser.add_argument_group(
+        title='platform configuration',
+        description="Typecheck code assuming certain runtime conditions.")
+    platform_group.add_argument(
+        '--python-version', type=parse_version, metavar='x.y',
+        help='typecheck code assuming it will be running on Python x.y',
+        dest='special-opts:python_version')
+    platform_group.add_argument(
+        '-2', '--py2', dest='python_version', action='store_const',
+        const=defaults.PYTHON2_VERSION,
+        help="use Python 2 mode (same as --python-version 2.7)")
+    platform_group.add_argument(
+        '--platform', action='store', metavar='PLATFORM',
+        help="typecheck special-cased code for the given OS platform "
+             "(defaults to sys.platform)")
+    platform_group.add_argument(
+        '--always-true', metavar='NAME', action='append', default=[],
+        help="additional variable to be considered True (may be repeated)")
+    platform_group.add_argument(
+        '--always-false', metavar='NAME', action='append', default=[],
+        help="additional variable to be considered False (may be repeated)")
+
+    disallow_any_group = parser.add_argument_group(
+        title='disallow any',
+        description="Disallow the use of the 'Any' type under certain conditions.")
+    disallow_any_group.add_argument(
+        '--disallow-any-unimported', default=False, action='store_true',
+        help="disallow Any types resulting from unfollowed imports")
+    disallow_any_group.add_argument(
+        '--disallow-any-expr', default=False, action='store_true',
+        help='disallow all expressions that have type Any')
+    disallow_any_group.add_argument(
+        '--disallow-any-decorated', default=False, action='store_true',
+        help='disallow functions that have Any in their signature '
+             'after decorator transformation')
+    disallow_any_group.add_argument(
+        '--disallow-any-explicit', default=False, action='store_true',
+        help='disallow explicit Any in type positions')
+    disallow_any_group.add_argument(
+        '--disallow-any-generics', default=False, action='store_true',
+        help='disallow usage of generic types that do not specify explicit '
+             'type parameters')
+
+    untyped_group = parser.add_argument_group(
+        title='untyped definitions and calls',
+        description="Configure how untyped definitions and calls are handled.")
     add_invertible_flag('--disallow-untyped-calls', default=False, strict_flag=True,
                         help="disallow calling functions without type annotations"
-                        " from functions with type annotations")
+                        " from functions with type annotations",
+                        group=untyped_group)
     add_invertible_flag('--disallow-untyped-defs', default=False, strict_flag=True,
                         help="disallow defining functions without type annotations"
-                        " or with incomplete type annotations")
+                        " or with incomplete type annotations",
+                        group=untyped_group)
     add_invertible_flag('--disallow-incomplete-defs', default=False, strict_flag=True,
-                        help="disallow defining functions with incomplete type annotations")
+                        help="disallow defining functions with incomplete type annotations",
+                        group=untyped_group)
     add_invertible_flag('--check-untyped-defs', default=False, strict_flag=True,
-                        help="type check the interior of functions without type annotations")
-    add_invertible_flag('--disallow-subclassing-any', default=False, strict_flag=True,
-                        help="disallow subclassing values of type 'Any' when defining classes")
+                        help="type check the interior of functions without type annotations",
+                        group=untyped_group)
     add_invertible_flag('--warn-incomplete-stub', default=False,
                         help="warn if missing type annotation in typeshed, only relevant with"
-                        " --check-untyped-defs enabled")
-    add_invertible_flag('--disallow-untyped-decorators', default=False, strict_flag=True,
-                        help="disallow decorating typed functions with untyped decorators")
+                             " --check-untyped-defs enabled",
+                        group=untyped_group)
+
+    none_group = parser.add_argument_group(
+        title='handle None and Optional',
+        description="Adjust how values of type 'None' are handled.")
+    add_invertible_flag('--no-implicit-optional', default=False, strict_flag=True,
+                        help="don't assume arguments with default values of None are Optional",
+                        group=none_group)
+    none_group.add_argument(
+        '--strict-optional', action='store_true',
+        help=argparse.SUPPRESS)
+    none_group.add_argument(
+        '--no-strict-optional', action='store_false', dest='strict_optional',
+        help="disable strict Optional checks (inverse: --strict-optional)")
+    none_group.add_argument(
+        '--strict-optional-whitelist', metavar='GLOB', nargs='*',
+        help="suppress strict Optional errors in all but the provided files "
+             "(experimental -- read documentation before using!).  "
+             "Implies --strict-optional.  Has the undesirable side-effect of "
+             "suppressing other errors in non-whitelisted files.")
+
+    lint_group = parser.add_argument_group(
+        title='warnings',
+        description="Detect code that is sound but redundant or problematic.")
     add_invertible_flag('--warn-redundant-casts', default=False, strict_flag=True,
-                        help="warn about casting an expression to its inferred type")
+                        help="warn about casting an expression to its inferred type",
+                        group=lint_group)
     add_invertible_flag('--no-warn-no-return', dest='warn_no_return', default=True,
-                        help="do not warn about functions that end without returning")
+                        help="do not warn about functions that end without returning",
+                        group=lint_group)
     add_invertible_flag('--warn-return-any', default=False, strict_flag=True,
                         help="warn about returning values of type Any"
-                             " from non-Any typed functions")
+                             " from non-Any typed functions",
+                        group=lint_group)
     add_invertible_flag('--warn-unused-ignores', default=False, strict_flag=True,
-                        help="warn about unneeded '# type: ignore' comments")
-    add_invertible_flag('--warn-unused-configs', default=False, strict_flag=True,
-                        help="warn about unused '[mypy-<pattern>]' config sections")
+                        help="warn about unneeded '# type: ignore' comments",
+                        group=lint_group)
+
+    strictness_group = parser.add_argument_group(
+        title='other strictness checks',
+        description="Other miscellaneous strictness checks.")
+    add_invertible_flag('--disallow-subclassing-any', default=False, strict_flag=True,
+                        help="disallow subclassing values of type 'Any' when defining classes",
+                        group=strictness_group)
+    add_invertible_flag('--disallow-untyped-decorators', default=False, strict_flag=True,
+                        help="disallow decorating typed functions with untyped decorators",
+                        group=strictness_group)
+
+    incremental_group = parser.add_argument_group(
+        title='incremental mode',
+        description="Adjust how mypy incremental typechecks and caches modules.")
+    incremental_group.add_argument(
+        '-i', '--incremental', action='store_true',
+        help=argparse.SUPPRESS)
+    incremental_group.add_argument(
+        '--no-incremental', action='store_false', dest='incremental',
+        help="disable module cache, (inverse: --incremental)")
+    incremental_group.add_argument(
+        '--cache-dir', action='store', metavar='DIR',
+        help="store module cache info in the given folder in incremental mode "
+             "(defaults to '{}')".format(defaults.CACHE_DIR))
+    incremental_group.add_argument(
+        '--cache-fine-grained', action='store_true',
+        help="include fine-grained dependency information in the cache")
+    incremental_group.add_argument(
+        '--quick-and-dirty', action='store_true',
+        help="use cache even if dependencies out of date (implies --incremental)")
+    incremental_group.add_argument(
+        '--skip-version-check', action='store_true',
+        help="allow using cache written by older mypy version")
+
+    internals_group = parser.add_argument_group(
+        title='mypy internals',
+        description="Debug and customize mypy internals.")
+    internals_group.add_argument(
+        '--pdb', action='store_true', help="invoke pdb on fatal error")
+    internals_group.add_argument(
+        '--show-traceback', '--tb', action='store_true',
+        help="show traceback on fatal error")
+    internals_group.add_argument(
+        '--custom-typing', metavar='MODULE', dest='custom_typing_module',
+        help="use a custom typing module")
+    internals_group.add_argument(
+        '--custom-typeshed-dir', metavar='DIR',
+        help="use the custom typeshed in DIR")
+    internals_group.add_argument(
+        '--shadow-file', nargs=2, metavar=('SOURCE_FILE', 'SHADOW_FILE'),
+        dest='shadow_file', action='append',
+        help="when encountering SOURCE_FILE, read and typecheck "
+             "the contents of SHADOW_FILE instead.")
+
+    error_group = parser.add_argument_group(
+        title='error reporting',
+        description="Adjust the amount of detail shown in error messages.")
     add_invertible_flag('--show-error-context', default=False,
                         dest='show_error_context',
-                        help='Precede errors with "note:" messages explaining context')
-    add_invertible_flag('--no-implicit-optional', default=False, strict_flag=True,
-                        help="don't assume arguments with default values of None are Optional")
-    parser.add_argument('-i', '--incremental', action='store_true',
-                        help=argparse.SUPPRESS)
-    parser.add_argument('--no-incremental', action='store_false', dest='incremental',
-                        help="disable module cache, (inverse: --incremental)")
-    parser.add_argument('--quick-and-dirty', action='store_true',
-                        help="use cache even if dependencies out of date "
-                        "(implies --incremental)")
-    parser.add_argument('--cache-dir', action='store', metavar='DIR',
-                        help="store module cache info in the given folder in incremental mode "
-                        "(defaults to '{}')".format(defaults.CACHE_DIR))
-    parser.add_argument('--cache-fine-grained', action='store_true',
-                        help="include fine-grained dependency information in the cache")
-    parser.add_argument('--skip-version-check', action='store_true',
-                        help="allow using cache written by older mypy version")
-    parser.add_argument('--strict-optional', action='store_true',
-                        help=argparse.SUPPRESS)
-    parser.add_argument('--no-strict-optional', action='store_false', dest='strict_optional',
-                        help="disable strict Optional checks (inverse: --strict-optional)")
-    parser.add_argument('--strict-optional-whitelist', metavar='GLOB', nargs='*',
-                        help="suppress strict Optional errors in all but the provided files "
-                        "(experimental -- read documentation before using!).  "
-                        "Implies --strict-optional.  Has the undesirable side-effect of "
-                        "suppressing other errors in non-whitelisted files.")
-    parser.add_argument('--always-true', metavar='NAME', action='append', default=[],
-                        help="Additional variable to be considered True (may be repeated)")
-    parser.add_argument('--always-false', metavar='NAME', action='append', default=[],
-                        help="Additional variable to be considered False (may be repeated)")
-    parser.add_argument('--junit-xml', help="write junit.xml to the given file")
-    parser.add_argument('--pdb', action='store_true', help="invoke pdb on fatal error")
-    parser.add_argument('--show-traceback', '--tb', action='store_true',
-                        help="show traceback on fatal error")
-    parser.add_argument('--stats', action='store_true', dest='dump_type_stats', help="dump stats")
-    parser.add_argument('--inferstats', action='store_true', dest='dump_inference_stats',
-                        help="dump type inference stats")
-    parser.add_argument('--custom-typing', metavar='MODULE', dest='custom_typing_module',
-                        help="use a custom typing module")
-    parser.add_argument('--custom-typeshed-dir', metavar='DIR',
-                        help="use the custom typeshed in DIR")
-    parser.add_argument('--scripts-are-modules', action='store_true',
-                        help="Script x becomes module x instead of __main__")
-    parser.add_argument('--config-file',
-                        help="Configuration file, must have a [mypy] section "
-                        "(defaults to {})".format(', '.join(defaults.CONFIG_FILES)))
+                        help='precede errors with "note:" messages explaining context',
+                        group=error_group)
     add_invertible_flag('--show-column-numbers', default=False,
-                        help="Show column numbers in error messages")
-    parser.add_argument('--find-occurrences', metavar='CLASS.MEMBER',
-                        dest='special-opts:find_occurrences',
-                        help="print out all usages of a class member (experimental)")
-    strict_help = "Strict mode. Enables the following flags: {}".format(
+                        help="show column numbers in error messages",
+                        group=error_group)
+
+    analysis_group = parser.add_argument_group(
+        title='extra analysis',
+        description="Extract additional information and analysis.")
+    analysis_group.add_argument(
+        '--stats', action='store_true', dest='dump_type_stats', help="dump stats")
+    analysis_group.add_argument(
+        '--inferstats', action='store_true', dest='dump_inference_stats',
+        help="dump type inference stats")
+    analysis_group.add_argument(
+        '--find-occurrences', metavar='CLASS.MEMBER',
+        dest='special-opts:find_occurrences',
+        help="print out all usages of a class member (experimental)")
+
+    strict_help = "strict mode; enables the following flags: {}".format(
         ", ".join(strict_flag_names))
-    parser.add_argument('--strict', action='store_true', dest='special-opts:strict',
-                        help=strict_help)
-    parser.add_argument('--shadow-file', nargs=2, metavar=('SOURCE_FILE', 'SHADOW_FILE'),
-                        dest='shadow_file', action='append',
-                        help="When encountering SOURCE_FILE, read and typecheck "
-                             "the contents of SHADOW_FILE instead.")
+    strictness_group.add_argument(
+        '--strict', action='store_true', dest='special-opts:strict',
+        help=strict_help)
+
+    report_group = parser.add_argument_group(
+        title='report generation',
+        description='Generate a report in the specified format.')
+    for report_type in sorted(reporter_classes):
+        report_group.add_argument('--%s-report' % report_type.replace('_', '-'),
+                                  metavar='DIR',
+                                  dest='special-opts:%s_report' % report_type)
+
+    other_group = parser.add_argument_group(
+        title='miscellaneous',
+        description="Other miscellaneous flags.")
+    other_group.add_argument(
+        '--junit-xml', help="write junit.xml to the given file")
+    other_group.add_argument(
+        '--scripts-are-modules', action='store_true',
+        help="script x becomes module x instead of __main__")
+
+    if server_options:
+        # TODO: This flag is superfluous; remove after a short transition (2018-03-16)
+        other_group.add_argument(
+            '--experimental', action='store_true', dest='fine_grained_incremental',
+            help="enable fine-grained incremental mode")
+        other_group.add_argument(
+            '--use-fine-grained-cache', action='store_true',
+            help="use the cache in fine-grained incremental mode")
+
     # hidden options
     # --debug-cache will disable any cache-related compressions/optimizations,
     # which will make the cache writing process output pretty-printed JSON (which
@@ -519,20 +646,6 @@ def add_invertible_flag(flag: str,
     parser.add_argument('--no-fast-parser', action='store_true',
                         dest='special-opts:no_fast_parser',
                         help=argparse.SUPPRESS)
-    if server_options:
-        # TODO: This flag is superfluous; remove after a short transition (2018-03-16)
-        parser.add_argument('--experimental', action='store_true', dest='fine_grained_incremental',
-                            help="enable fine-grained incremental mode")
-        parser.add_argument('--use-fine-grained-cache', action='store_true',
-                            help="use the cache in fine-grained incremental mode")
-
-    report_group = parser.add_argument_group(
-        title='report generation',
-        description='Generate a report in the specified format.')
-    for report_type in sorted(reporter_classes):
-        report_group.add_argument('--%s-report' % report_type.replace('_', '-'),
-                                  metavar='DIR',
-                                  dest='special-opts:%s_report' % report_type)
 
     code_group = parser.add_argument_group(title='How to specify the code to type check')
     code_group.add_argument('-m', '--module', action='append', metavar='MODULE',
diff --git a/mypy/server/update.py b/mypy/server/update.py
index 44c7edf01b..0dbc0b02ba 100755
--- a/mypy/server/update.py
+++ b/mypy/server/update.py
@@ -852,6 +852,10 @@ def key(node: DeferredNode) -> int:
 
     nodes = sorted(nodeset, key=key)
 
+    options = graph[module_id].options
+    manager.errors.set_file_ignored_lines(
+        file_node.path, file_node.ignored_lines, options.ignore_errors)
+
     targets = set()
     for node in nodes:
         target = target_from_node(module_id, node.node)
@@ -868,7 +872,6 @@ def key(node: DeferredNode) -> int:
 
     # Second pass of semantic analysis. We don't redo the first pass, because it only
     # does local things that won't go stale.
-    options = graph[module_id].options
     for deferred in nodes:
         with semantic_analyzer.file_context(
                 file_node=file_node,
