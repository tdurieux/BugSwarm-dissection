diff --git a/factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java b/factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
index aa6d28ba..dbaec887 100644
--- a/factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
+++ b/factory/src/main/java/com/google/auto/factory/processor/AutoFactoryProcessor.java
@@ -23,11 +23,15 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
+
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
@@ -127,8 +131,16 @@ private void doProcess(RoundEnvironment roundEnv) {
     ImmutableSetMultimap<String, ImplementationMethodDescriptor>
         implementationMethodDescriptors = implementationMethodDescriptorsBuilder.build();
 
+    ImmutableMap<String, Collection<FactoryMethodDescriptor>>
+        implementationMethodDescriptorsMap = indexedMethods.build().asMap();
+    ImmutableMap.Builder<CharSequence, TypeName> factoriesBuilder = ImmutableMap.builder();
+    for (String name : implementationMethodDescriptorsMap.keySet()) {
+        TypeName typeName = ClassName.bestGuess(name).withoutAnnotations();
+        factoriesBuilder.put(Classes.getSimpleName(name), typeName);
+    }
+    ImmutableMap<CharSequence, TypeName> factories = factoriesBuilder.build();
     for (Entry<String, Collection<FactoryMethodDescriptor>> entry
-        : indexedMethods.build().asMap().entrySet()) {
+        : implementationMethodDescriptorsMap.entrySet()) {
       ImmutableSet.Builder<TypeMirror> extending = ImmutableSet.builder();
       ImmutableSortedSet.Builder<TypeMirror> implementing =
           ImmutableSortedSet.orderedBy(
@@ -170,7 +182,8 @@ public int compare(TypeMirror first, TypeMirror second) {
                   publicType,
                   ImmutableSet.copyOf(entry.getValue()),
                   implementationMethodDescriptors.get(entry.getKey()),
-                  allowSubclasses));
+                  allowSubclasses),
+              factories);
         } catch (IOException e) {
           messager.printMessage(Kind.ERROR, "failed");
         }
diff --git a/factory/src/main/java/com/google/auto/factory/processor/Classes.java b/factory/src/main/java/com/google/auto/factory/processor/Classes.java
new file mode 100644
index 00000000..7d12a8cc
--- /dev/null
+++ b/factory/src/main/java/com/google/auto/factory/processor/Classes.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.auto.factory.processor;
+
+public class Classes {
+
+  static CharSequence getSimpleName(CharSequence fullyQualifiedName) {
+    int lastDot = lastIndexOf(fullyQualifiedName, '.');
+    return fullyQualifiedName.subSequence(lastDot + 1, fullyQualifiedName.length());
+  }
+
+  static String getPackage(CharSequence fullyQualifiedName) {
+    int lastDot = lastIndexOf(fullyQualifiedName, '.');
+    return fullyQualifiedName.subSequence(0, lastDot).toString();
+  }
+
+  private static int lastIndexOf(CharSequence charSequence, char c) {
+    for (int i = charSequence.length() - 1; i >= 0; i--) {
+      if (charSequence.charAt(i) == c) {
+        return i;
+      }
+    }
+    return -1;
+  }
+}
diff --git a/factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java b/factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
index e1c57eb5..5f0c7257 100644
--- a/factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
+++ b/factory/src/main/java/com/google/auto/factory/processor/FactoryWriter.java
@@ -16,7 +16,10 @@
 package com.google.auto.factory.processor;
 
 import static com.google.auto.common.GeneratedAnnotationSpecs.generatedAnnotationSpec;
+import static com.google.auto.factory.processor.Classes.getPackage;
+import static com.google.auto.factory.processor.Classes.getSimpleName;
 import static com.google.auto.factory.processor.Mirrors.isProvider;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
@@ -29,6 +32,7 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
@@ -47,6 +51,7 @@
 import javax.inject.Provider;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
@@ -64,7 +69,7 @@
 
   private static final Joiner ARGUMENT_JOINER = Joiner.on(", ");
 
-  void writeFactory(final FactoryDescriptor descriptor)
+  void writeFactory(final FactoryDescriptor descriptor, final ImmutableMap<CharSequence, TypeName> factories)
       throws IOException {
     String factoryName = getSimpleName(descriptor.name()).toString();
     TypeSpec.Builder factory = classBuilder(factoryName);
@@ -86,7 +91,7 @@ void writeFactory(final FactoryDescriptor descriptor)
       factory.addSuperinterface(TypeName.get(implementingType));
     }
 
-    addConstructorAndProviderFields(factory, descriptor);
+    addConstructorAndProviderFields(factory, descriptor, factories);
     addFactoryMethods(factory, descriptor);
     addImplementationMethods(factory, descriptor);
     addCheckNotNullMethod(factory, descriptor);
@@ -98,7 +103,7 @@ void writeFactory(final FactoryDescriptor descriptor)
   }
 
   private void addConstructorAndProviderFields(
-      TypeSpec.Builder factory, FactoryDescriptor descriptor) {
+      TypeSpec.Builder factory, FactoryDescriptor descriptor, ImmutableMap<CharSequence, TypeName> factories) {
     MethodSpec.Builder constructor = constructorBuilder().addAnnotation(Inject.class);
     if (descriptor.publicType()) {
       constructor.addModifiers(PUBLIC);
@@ -106,8 +111,7 @@ private void addConstructorAndProviderFields(
     Iterator<ProviderField> providerFields = descriptor.providers().values().iterator();
     for (int argumentIndex = 1; providerFields.hasNext(); argumentIndex++) {
       ProviderField provider = providerFields.next();
-      TypeName typeName = TypeName.get(provider.key().type()).box();
-      TypeName providerType = ParameterizedTypeName.get(ClassName.get(Provider.class), typeName);
+      TypeName providerType = getProviderType(factories, provider);
       factory.addField(providerType, provider.name(), PRIVATE, FINAL);
       if (provider.key().qualifier().isPresent()) {
         // only qualify the constructor parameter
@@ -120,6 +124,18 @@ private void addConstructorAndProviderFields(
     factory.addMethod(constructor.build());
   }
 
+  private static TypeName getProviderType(ImmutableMap<CharSequence, TypeName> factories, ProviderField provider) {
+    TypeMirror type = provider.key().type();
+    TypeName typeName;
+    if (type instanceof ErrorType) {
+      typeName = factories.get(type.toString());
+    } else {
+      typeName = TypeName.get(type).box();
+    }
+    checkNotNull(typeName,"Type of '%s' could not be resolved.", provider.name());
+    return ParameterizedTypeName.get(ClassName.get(Provider.class), typeName);
+  }
+
   private void addFactoryMethods(TypeSpec.Builder factory, FactoryDescriptor descriptor) {
     for (FactoryMethodDescriptor methodDescriptor : descriptor.methodDescriptors()) {
       MethodSpec.Builder method =
@@ -248,23 +264,4 @@ private static boolean shouldGenerateCheckNotNull(FactoryDescriptor descriptor)
     }
     return false;
   }
-
-  private static CharSequence getSimpleName(CharSequence fullyQualifiedName) {
-    int lastDot = lastIndexOf(fullyQualifiedName, '.');
-    return fullyQualifiedName.subSequence(lastDot + 1, fullyQualifiedName.length());
-  }
-
-  private static String getPackage(CharSequence fullyQualifiedName) {
-    int lastDot = lastIndexOf(fullyQualifiedName, '.');
-    return fullyQualifiedName.subSequence(0, lastDot).toString();
-  }
-
-  private static int lastIndexOf(CharSequence charSequence, char c) {
-    for (int i = charSequence.length() - 1; i >= 0; i--) {
-      if (charSequence.charAt(i) == c) {
-        return i;
-      }
-    }
-    return -1;
-  }
 }
diff --git a/factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java b/factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
index 293a9deb..8bc104f7 100644
--- a/factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
+++ b/factory/src/test/java/com/google/auto/factory/processor/AutoFactoryProcessorTest.java
@@ -433,6 +433,16 @@ public void simpleClassProvidedProviderDeps() {
         .generatesSources(loadExpectedFile("expected/OnlyPrimitivesFactory.java"));
   }
 
+  @Test public void dependendFactory() {
+    assertThat(
+            JavaFileObjects.forResource("good/PublicClass.java"),
+            JavaFileObjects.forResource("good/SimpleClassDependingOnFactory.java"))
+        .processedWith(new AutoFactoryProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(loadExpectedFile("expected/SimpleClassDependingOnFactoryFactory.java"));
+  }
+
   private JavaFileObject loadExpectedFile(String resourceName) {
     try {
       List<String> sourceLines = Resources.readLines(Resources.getResource(resourceName), UTF_8);
diff --git a/factory/src/test/resources/expected/SimpleClassDependingOnFactoryFactory.java b/factory/src/test/resources/expected/SimpleClassDependingOnFactoryFactory.java
new file mode 100644
index 00000000..bd24fa9c
--- /dev/null
+++ b/factory/src/test/resources/expected/SimpleClassDependingOnFactoryFactory.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package tests.sample;
+
+import javax.annotation.processing.Generated;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import tests.PublicClassFactory;
+
+@Generated(
+  value = "com.google.auto.factory.processor.AutoFactoryProcessor",
+  comments = "https://github.com/google/auto/tree/master/factory"
+)
+final class SimpleClassDependingOnFactoryFactory {
+  private final Provider<PublicClassFactory> depAProvider;
+
+  @Inject
+  SimpleClassDependingOnFactoryFactory(Provider<PublicClassFactory> depAProvider) {
+    this.depAProvider = checkNotNull(depAProvider, 1);
+  }
+
+  SimpleClassDependingOnFactory create() {
+    return new SimpleClassDependingOnFactory(checkNotNull(depAProvider.get(), 1));
+  }  
+
+  private static <T> T checkNotNull(T reference, int argumentIndex) {
+    if (reference == null) {
+      throw new NullPointerException(
+          "@AutoFactory method argument is null but is not marked @Nullable. Argument index: "
+              + argumentIndex);
+    }
+    return reference;
+  }
+}
diff --git a/factory/src/test/resources/good/SimpleClassDependingOnFactory.java b/factory/src/test/resources/good/SimpleClassDependingOnFactory.java
new file mode 100644
index 00000000..7ae94f7c
--- /dev/null
+++ b/factory/src/test/resources/good/SimpleClassDependingOnFactory.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2018 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package tests.sample;
+
+import com.google.auto.factory.AutoFactory;
+import com.google.auto.factory.Provided;
+import tests.PublicClassFactory;
+
+@AutoFactory
+final class SimpleClassDependingOnFactory {
+  private final PublicClassFactory depA;
+
+  SimpleClassDependingOnFactory(@Provided PublicClassFactory depA) {
+    this.depA = depA;
+  }
+}
