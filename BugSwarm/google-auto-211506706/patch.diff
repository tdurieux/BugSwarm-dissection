diff --git a/README.md b/README.md
index 265c9899..ec1fe66c 100644
--- a/README.md
+++ b/README.md
@@ -17,19 +17,19 @@ Save time.  Save code.  Save sanity.
 
   * [AutoFactory] - JSR-330-compatible factories
 
-    Latest version: `0.1-beta3`
+    [![Maven Central](https://img.shields.io/maven-central/v/com.google.auto.factory/auto-factory.svg)](https://mvnrepository.com/artifact/com.google.auto.factory/auto-factory)
 
   * [AutoService] - Provider-configuration files for [`ServiceLoader`]
 
-    Latest version: `1.0-rc2`
+    [![Maven Central](https://img.shields.io/maven-central/v/com.google.auto.service/auto-service.svg)](https://mvnrepository.com/artifact/com.google.auto.service/auto-service)
 
   * [AutoValue] - Immutable [value-type] code generation for Java 1.6+.
 
-    Latest version: `1.3`
+    [![Maven Central](https://img.shields.io/maven-central/v/com.google.auto.value/auto-value.svg)](https://mvnrepository.com/artifact/com.google.auto.value/auto-value)
 
   * [Common] - Helper utilities for writing annotation processors.
 
-    Latest version: `0.6`
+    [![Maven Central](https://img.shields.io/maven-central/v/com.google.auto/auto-common.svg)](https://mvnrepository.com/artifact/com.google.auto/auto-common)
 
 ## License
 
diff --git a/factory/src/it/functional/java7_compat_test.sh b/factory/src/it/functional/java7_compat_test.sh
new file mode 100755
index 00000000..c3365e18
--- /dev/null
+++ b/factory/src/it/functional/java7_compat_test.sh
@@ -0,0 +1,47 @@
+#!/bin/bash
+# Test that the code generated by AutoFactory can run on Java 7.
+# The AutoFactory processor itself runs on Java 8, but the code it
+# generates is supposed to be able to run on Java 7.
+#
+# Users can achieve that by compiling like this:
+#   javac -source 7 -target 7 -bootclasspath .../rt.jar
+# where javac is the one from Java 8 or later and .../rt.jar is
+# the one from Java 7. 
+#
+# So this test basically does the same thing, using a large functional
+# test as input. If that test compiles and runs, it is a good sign
+# that user code will too.
+
+# Exit if any command fails.
+set -e
+
+# Arguments are the fully-qualified name of the test class, followed by
+# the path to each source file.
+TEST_CLASS="$1"
+if [ -z "${TEST_CLASS}" ]; then
+  echo "Usage: $0 TEST_CLASS" >&2
+  exit 1
+fi
+shift
+
+MY_DIR=$(dirname "${TEST_BINARY}")
+SOURCE_FILES=$(for f in "$@"; do echo "${MY_DIR}/${f}"; done)
+
+JDK8=third_party/java/jdk/jdk-64
+JDK7=third_party/java/jdk/jdk7-64
+JDK8_JAVAC="${JDK8}"/bin/javac
+JDK7_JAVA="${JDK7}"/bin/java
+CLASS_PATH="${MY_DIR}"/java7_compat_test_java_deps.jar
+BOOT_PATH="${JDK7}"/jre/lib/rt.jar
+PROCESSOR_PATH=\
+third_party/java/auto/auto_factory_ide.jar:\
+third_party/java/dagger/dagger_components_ide.jar
+
+"${JDK8_JAVAC}" -d "${TEST_TMPDIR}" \
+    -encoding utf8 -source 7 -target 7 \
+    -bootclasspath "${BOOT_PATH}" \
+    -classpath "${CLASS_PATH}" \
+    -processorpath "${PROCESSOR_PATH}" \
+    ${SOURCE_FILES}
+"${JDK7_JAVA}" -classpath "${TEST_TMPDIR}:${CLASS_PATH}" \
+    org.junit.runner.JUnitCore "${TEST_CLASS}"
diff --git a/value/CHANGES.md b/value/CHANGES.md
index 8f9b400c..be365c33 100644
--- a/value/CHANGES.md
+++ b/value/CHANGES.md
@@ -1,5 +1,95 @@
 # AutoValue Changes
 
+## 1.3 → 1.4
+
+*This is the last AutoValue version that compiles and runs on Java 6.* Future
+versions will require at least Java 8 to run. We will continue to generate code
+that is compatible with Java 7, so AutoValue can be used with `javac -source 7
+-target 7 -bootclasspath <rt.jar-from-jdk7>`, but using the `javac` from jdk8 or
+later.
+
+### Functional changes
+
+* Builder setters now reject a null parameter immediately unless the
+  corresponding property is `@Nullable`. Previously this check happened at
+  `build()` time, and in some cases didn't happen at all. This is the change
+  that is most likely to affect existing code.
+
+* Added `@Memoized`. A `@Memoized` method will be overridden in the generated
+  `AutoValue_Foo` class to save the value returned the first time it was called
+  and reuse that every other time.
+
+* Generalized support for property builders. Now, in addition to being able to
+  say `immutableListBuilder()` for a property of type `ImmutableList<T>`, you
+  can say `fooBuilder()` for a property of an arbitrary type that has a builder
+  following certain conventions. In particular, you can do this if the type of
+  `foo()` is itself an `@AutoValue` class with a builder. The default value of
+  `foo()`, if `fooBuilder()` is never called, is `fooBuilder().build()`.
+
+* If a property `foo()` or `getFoo()` has a builder method `fooBuilder()` then
+  the property can not now be `@Nullable`. An `ImmutableList`, for example,
+  starts off empty, not null, so `@Nullable` was misleading.
+
+* When an `@AutoValue` class `Foo` has a builder, the generated
+  `AutoValue_Foo.Builder` has a constructor `AutoValue_Foo.Builder(Foo)`. That
+  constructor was never documented and is now private. If you want to make a
+  `Foo.Builder` from a `Foo`, `Foo` should have an abstract method `Builder
+  toBuilder()`.
+
+  This change was necessary so that generalized property-builder support could
+  know whether or not the built class needs to be convertible back into its
+  builder. That's only necessary if there is a `toBuilder()`.
+
+* The Extension API is now a committed API, meaning we no longer warn that it is
+  likely to change incompatibly. A
+  [guide](https://github.com/google/auto/blob/master/value/userguide/extensions.md)
+  gives tips on writing extensions.
+
+* Extensions can now return null rather than generated code. In that case the
+  extension does not generate a class in the AutoValue hierarchy, but it can
+  still do other things like error checking or generating side files.
+
+* Access modifiers like `protected` are copied from builder methods to their
+  implementations, instead of the implementations always being public.
+  Change by @torquestomp.
+
+* AutoAnnotation now precomputes parts of the `hashCode` that are constant
+  because they come from defaulted methods. This avoids warnings about integer
+  overflow from tools that check that.
+
+* If a property is called `oAuth()`, its setter can be called
+  `setOAuth(x)`. Previously it had to be `setoAuth(x)`, which is still allowed.
+
+## Bugs fixed
+
+* AutoAnnotation now correctly handles types like `Class<? extends
+  Annotation>[]`. Previously it would try to create a generic array, which Java
+  doesn't allow. Change by @lukesandberg.
+
+* We guard against spurious exceptions due to a JDK bug in reading resources
+  from jars. (#365)
+
+* We don't propagate an exception if a corrupt jar is found in extension
+  loading.
+
+* AutoValue is ready for Java 9, where public classes are not necessarily
+  accessible, and javax.annotation.Generated is not necessarily present.
+
+* AutoValue now works correctly even if the version of AutoValue in the
+  `-classpath` is older than the one in the `-processorpath`.
+
+* Builders now behave correctly when there is a non-optional property called
+  `missing`. Previously a variable-hiding problem meant that we didn't detect
+  when it wasn't set.
+
+* If `@AutoValue class Foo` has a builder, we always generated two constructors,
+  `Builder()` and `Builder(Foo)`, but we only used the second one if `Foo` had a
+  `toBuilder()` method. Now we only generate that constructor if it is
+  needed. That avoids warnings about unused code.
+
+* `@AutoAnnotation` now works when the annotation and the factory method are in
+  the default (unnamed) package.
+
 ## 1.2 → 1.3
 
 ### Functional changes
diff --git a/value/pom.xml b/value/pom.xml
index d528c051..027ebf43 100644
--- a/value/pom.xml
+++ b/value/pom.xml
@@ -26,7 +26,7 @@
 
   <groupId>com.google.auto.value</groupId>
   <artifactId>auto-value</artifactId>
-  <version>1.4-SNAPSHOT</version>
+  <version>1.5-SNAPSHOT</version>
   <name>AutoValue</name>
   <description>
     Immutable value-type code generation for Java 1.6+.
diff --git a/value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java b/value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
index 4709b749..76a2f4c1 100644
--- a/value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
+++ b/value/src/main/java/com/google/auto/value/processor/AutoValueProcessor.java
@@ -15,6 +15,8 @@
  */
 package com.google.auto.value.processor;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Sets.union;
@@ -77,6 +79,7 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.JavaFileObject;
@@ -1103,9 +1106,31 @@ private boolean checkReturnType(TypeElement autoValueClass, ExecutableElement ge
     }
   }
 
+  // Detects whether the visited AnnotationValue is an array that contains the string "mutable".
+  // The simpler approach using Element.getAnnotation(SuppressWarnings.class) doesn't work if
+  // the annotation has an undefined reference, like @SuppressWarnings(UNDEFINED).
+  // TODO(emcmanus): replace with a method from auto-common when that is available.
+  private static class ContainsMutableVisitor extends SimpleAnnotationValueVisitor6<Boolean, Void> {
+    @Override
+    public Boolean visitArray(List<? extends AnnotationValue> list, Void p) {
+      for (AnnotationValue value : list) {
+        if ("mutable".equals(value.getValue())) {
+          return true;
+        }
+      }
+      return false;
+    }
+  }
+
   private void warnAboutPrimitiveArrays(TypeElement autoValueClass, ExecutableElement getter) {
-    SuppressWarnings suppressWarnings = getter.getAnnotation(SuppressWarnings.class);
-    if (suppressWarnings == null || !Arrays.asList(suppressWarnings.value()).contains("mutable")) {
+    boolean suppressed = false;
+    Optional<AnnotationMirror> maybeAnnotation =
+        getAnnotationMirror(getter, SuppressWarnings.class);
+    if (maybeAnnotation.isPresent()) {
+      AnnotationValue listValue = getAnnotationValue(maybeAnnotation.get(), "value");
+      suppressed = listValue.accept(new ContainsMutableVisitor(), null);
+    }
+    if (!suppressed) {
       // If the primitive-array property method is defined directly inside the @AutoValue class,
       // then our error message should point directly to it. But if it is inherited, we don't
       // want to try to make the error message point to the inherited definition, since that would
diff --git a/value/src/test/java/com/google/auto/value/processor/CompilationTest.java b/value/src/test/java/com/google/auto/value/processor/CompilationTest.java
index 5392a659..82697720 100644
--- a/value/src/test/java/com/google/auto/value/processor/CompilationTest.java
+++ b/value/src/test/java/com/google/auto/value/processor/CompilationTest.java
@@ -38,6 +38,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -959,8 +960,9 @@ public void correctBuilder() throws Exception {
         "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(javaFileObject, nestedJavaFileObject))
+        .withCompilerOptions("-Xlint:-processing")
         .processedWith(new AutoValueProcessor())
-        .compilesWithoutError()
+        .compilesWithoutWarnings()
         .and()
         .generatesSources(expectedOutput);
   }
@@ -2331,4 +2333,63 @@ public void referencingGeneratedClass() {
         .processedWith(new AutoValueProcessor(), new FooProcessor())
         .compilesWithoutError();
   }
+
+  // Test currently ignored because sometimes we get two UNDEFINED errors and sometimes we
+  // get no warnings if there is an error, depending on the exact JDK version. We may be
+  // able to get something a bit more solid once we require JDK 8.
+  @Test
+  @Ignore
+  public void annotationReferencesUndefined() {
+    // Test that we don't throw an exception if asked to compile @SuppressWarnings(UNDEFINED)
+    // where UNDEFINED is an undefined symbol.
+    JavaFileObject bazFileObject = JavaFileObjects.forSourceLines(
+        "foo.bar.Baz",
+        "package foo.bar;",
+        "",
+        "import com.google.auto.value.AutoValue;",
+        "",
+        "@AutoValue",
+        "public abstract class Baz {",
+        "  @SuppressWarnings(UNDEFINED)",
+        "  public abstract int[] buh();",
+        "}");
+    assertAbout(javaSource())
+        .that(bazFileObject)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new AutoValueProcessor())
+        .failsToCompile()
+        .withErrorCount(1)
+        .withErrorContaining("UNDEFINED")
+        .in(bazFileObject)
+        .onLine(7)
+        .and()
+        .withWarningCount(1)
+        .withWarningContaining("mutable")
+        .in(bazFileObject)
+        .onLine(8);
+
+    // Same test, except we do successfully suppress the warning despite the UNDEFINED.
+    bazFileObject = JavaFileObjects.forSourceLines(
+        "foo.bar.Baz",
+        "package foo.bar;",
+        "",
+        "import com.google.auto.value.AutoValue;",
+        "",
+        "@AutoValue",
+        "public abstract class Baz {",
+        "  @SuppressWarnings({UNDEFINED, \"mutable\"})",
+        "  public abstract int[] buh();",
+        "}");
+    assertAbout(javaSource())
+        .that(bazFileObject)
+        .withCompilerOptions("-Xlint:-processing")
+        .processedWith(new AutoValueProcessor())
+        .failsToCompile()
+        .withErrorCount(1)
+        .withErrorContaining("UNDEFINED")
+        .in(bazFileObject)
+        .onLine(7)
+        .and()
+        .withWarningCount(0);
+  }
 }
diff --git a/value/userguide/builders-howto.md b/value/userguide/builders-howto.md
index 43d1b330..60c121fc 100644
--- a/value/userguide/builders-howto.md
+++ b/value/userguide/builders-howto.md
@@ -551,5 +551,9 @@ requirements are:
 There are no requirements on the name of the builder class. Instead of
 `Species.Builder`, it could be `Species.Factory` or `SpeciesBuilder`.
 
+If `speciesBuilder()` is never called then the final `species()` property will
+be set as if by `speciesBuilder().build()`. In the example, that would result
+in an exception because the required properties of `Species` have not been set.
+
 
 [protobuf]: https://developers.google.com/protocol-buffers/docs/reference/java-generated#builders
diff --git a/value/userguide/index.md b/value/userguide/index.md
index f6fd09a8..2b37d920 100644
--- a/value/userguide/index.md
+++ b/value/userguide/index.md
@@ -2,7 +2,7 @@
 
 
 *Generated immutable value classes for Java 1.6+* <br />
-***Kevin Bourrillion, Éamonn McManus*** <br />
+***Éamonn McManus, Kevin Bourrillion*** <br />
 **Google, Inc.**
 
 > "AutoValue is a great tool for eliminating the drudgery of writing mundane
