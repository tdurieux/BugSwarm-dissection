diff --git a/mypy/main.py b/mypy/main.py
index e772e871b3..5d14522b33 100644
--- a/mypy/main.py
+++ b/mypy/main.py
@@ -8,7 +8,7 @@
 import sys
 import time
 
-from typing import Any, cast, Dict, List, Mapping, Optional, Set, Tuple, Type as Class
+from typing import Any, cast, Dict, List, Mapping, Optional, Set, Tuple
 
 from mypy import build
 from mypy import defaults
@@ -100,6 +100,24 @@ def type_check_only(sources: List[BuildSource], bin_dir: str, options: Options,
                        plugin=plugin)
 
 
+disallow_any_options = ['unimported']
+
+
+def disallow_any_argument_type(raw_options: str) -> List[str]:
+    if not raw_options:
+        # empty string disables all options
+        return []
+    flag_options = [o.strip() for o in raw_options.split(',')]
+    for option in flag_options:
+        if option not in disallow_any_options:
+            formatted_valid_options = ', '.join(
+                "'{}'".format(o) for o in disallow_any_options)
+            message = "Invalid '--disallow-any' option '{}' (valid options are: {}).".format(
+                option, formatted_valid_options)
+            raise argparse.ArgumentError(None, message)
+    return flag_options
+
+
 FOOTER = """environment variables:
 MYPYPATH     additional module search path"""
 
@@ -175,21 +193,32 @@ def invert_flag_name(flag: str) -> str:
     return '--no-{}'.format(flag[2:])
 
 
-def load_plugin(prefix: str, name: str, location: str) -> Optional[Class[Plugin]]:
+def load_plugin(prefix: str, name: str, location: str,
+                python_version: Tuple[int, int]) -> Optional[Plugin]:
+    try:
+        mod = __import__(location)
+    except BaseException as err:
+        print("%s: Error importing plugin module %s: %s" %
+              (prefix, location, err), file=sys.stderr)
+        return None
+    try:
+        register = getattr(mod, 'register_plugin')
+    except AttributeError:
+        print("%s: Could not find %s.register_plugin" %
+              (prefix, location), file=sys.stderr)
+        return None
     try:
-        obj = locate(location)
+        plugin = register(python_version)
     except BaseException as err:
-        print("%s: Error finding plugin %s at %s: %s" %
-              (prefix, name, location, err), file=sys.stderr)
+        print("%s: Error calling %s.register_plugin: %s" %
+              (prefix, location, err), file=sys.stderr)
         return None
-    if obj is None:
-        print("%s: Could not find plugin %s at %s" %
-              (prefix, name, location), file=sys.stderr)
-    elif not callable(obj):
-        print("%s: Hook %s at %s is not callable" %
-              (prefix, name, location), file=sys.stderr)
+
+    if not isinstance(plugin, Plugin):
+        print("%s: Result of calling %s.register_plugin is not a plugin: %r" %
+              (prefix, location, plugin), file=sys.stderr)
         return None
-    return cast(Class[Plugin], obj)
+    return plugin
 
 
 def process_options(args: List[str],
@@ -228,17 +257,6 @@ def add_invertible_flag(flag: str,
             strict_flag_names.append(flag)
             strict_flag_assignments.append((dest, not default))
 
-    def disallow_any_argument_type(raw_options: str) -> List[str]:
-        flag_options = raw_options.split(',')
-        for option in flag_options:
-            if option not in disallow_any_options:
-                formatted_valid_options = ', '.join(
-                    "'{}'".format(o) for o in disallow_any_options)
-                message = "Invalid '--disallow-any' option '{}' (valid options are: {}).".format(
-                    option, formatted_valid_options)
-                raise argparse.ArgumentError(None, message)
-        return flag_options
-
     # Unless otherwise specified, arguments will be parsed directly onto an
     # Options object.  Options that require further processing should have
     # their `dest` prefixed with `special-opts:`, which will cause them to be
@@ -477,13 +495,13 @@ def disallow_any_argument_type(raw_options: str) -> List[str]:
         options.incremental = True
 
     # Load plugins
-    plugins = []  # type: List[Class[Plugin]]
+    plugins = []  # type: List[Plugin]
     for registry in options.plugins:
-        plugin = load_plugin('[mypy]', registry.name, registry.location)
+        plugin = load_plugin('[mypy]', registry.name, registry.location, options.python_version)
         if plugin is not None:
             plugins.append(plugin)
     # always add the default last
-    plugins.append(DefaultPlugin)
+    plugins.append(DefaultPlugin(options.python_version))
     plugin_manager = PluginManager(options.python_version, plugins)
 
     # Set target.
@@ -632,6 +650,7 @@ def get_init_file(dir: str) -> Optional[str]:
     'custom_typeshed_dir': str,
     'mypy_path': lambda s: [p.strip() for p in re.split('[,:]', s)],
     'junit_xml': str,
+    'disallow_any': disallow_any_argument_type,
     # These two are for backwards compatibility
     'silent_imports': bool,
     'almost_silent': bool,
@@ -727,7 +746,7 @@ def parse_section(prefix: str, template: Options,
         key = key.replace('-', '_')
         if key.startswith('plugins.'):
             dv = section.get(key)
-            key = key[6:]
+            key = key[8:]
             plugins.append((key, dv))
             continue
         elif key in config_types:
diff --git a/mypy/plugin.py b/mypy/plugin.py
index 0838039835..b4aadecd31 100644
--- a/mypy/plugin.py
+++ b/mypy/plugin.py
@@ -1,4 +1,4 @@
-from typing import Callable, Dict, List, Tuple, Type as Class, Optional, NamedTuple
+from typing import Callable, Dict, List, Tuple, Optional, NamedTuple
 
 from types import ModuleType
 from mypy.nodes import Expression, StrExpr, IntExpr, UnaryExpr, Context
@@ -178,10 +178,9 @@ def get_method_hook(self, fullname: str) -> Optional[MethodHook]:
 
 class PluginManager(Plugin):
     def __init__(self, python_version: Tuple[int, int],
-                 plugins: List[Class[Plugin]]) -> None:
+                 plugins: List[Plugin]) -> None:
         super().__init__(python_version)
-        # TODO: handle exceptions to provide more feedback
-        self.plugins = [p(python_version) for p in plugins]
+        self.plugins = plugins
         self._function_hooks = {}  # type: Dict[str, Optional[FunctionHook]]
         self._method_signature_hooks = {}  # type: Dict[str, Optional[MethodSignatureHook]]
         self._method_hooks = {}  # type: Dict[str, Optional[MethodHook]]
diff --git a/test-data/unit/cmdline.test b/test-data/unit/cmdline.test
index a9ba3c2895..118a7c0f54 100644
--- a/test-data/unit/cmdline.test
+++ b/test-data/unit/cmdline.test
@@ -583,3 +583,28 @@ python_version = 3.3
 [[mypy]
 python_version = 3.6
 [out]
+
+[case testDisallowAnyUnimported]
+# cmd: mypy main.py
+[file mypy.ini]
+[[mypy]
+disallow_any = unimported
+ignore_missing_imports = True
+[file main.py]
+from unreal import F
+
+def f(x: F) -> None: pass
+[out]
+main.py:3: error: Argument 1 to "f" becomes "Any" due to an unfollowed import
+
+[case testDisallowAnyEmpty]
+# cmd: mypy main.py
+[file mypy.ini]
+[[mypy]
+disallow_any =
+ignore_missing_imports = True
+[file main.py]
+from unreal import F
+
+def f(x: F) -> None: pass
+[out]
