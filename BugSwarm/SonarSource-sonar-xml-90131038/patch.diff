diff --git a/README.md b/README.md
index c01f1a52..9d0b9029 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,16 @@
+Sonar XML plugin
+=========================
+
+### Build status
+
 [![Build Status](https://travis-ci.org/SonarCommunity/sonar-xml.svg?branch=master)](https://travis-ci.org/SonarCommunity/sonar-xml)
+
+This is the Sonar XML plugin
+
+Project homepage:
+http://docs.sonarqube.org/display/PLUG/XML+Plugin
+
+Issue tracking:
+https://jira.sonarsource.com/browse/SONARXML/
+
+
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlPlugin.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlPlugin.java
index 196be11f..4be07b26 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlPlugin.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlPlugin.java
@@ -17,17 +17,15 @@
  */
 package org.sonar.plugins.xml;
 
-import java.util.List;
-
+import com.google.common.collect.ImmutableList;
 import org.sonar.api.SonarPlugin;
 import org.sonar.api.config.PropertyDefinition;
 import org.sonar.api.resources.Qualifiers;
 import org.sonar.plugins.xml.language.Xml;
-import org.sonar.plugins.xml.language.XmlCodeColorizerFormat;
 import org.sonar.plugins.xml.rules.XmlRulesDefinition;
 import org.sonar.plugins.xml.rules.XmlSonarWayProfile;
 
-import com.google.common.collect.ImmutableList;
+import java.util.List;
 
 /**
  * XML Plugin publishes extensions to sonar engine.
@@ -56,8 +54,7 @@ public List getExtensions() {
 
       // Sensors
       XmlSensor.class,
-      LineCountSensor.class,
-
-      XmlCodeColorizerFormat.class);
+      LineCountSensor.class
+    );
   }
 }
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlSensor.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlSensor.java
index fbf54b42..abecca18 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlSensor.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/XmlSensor.java
@@ -17,6 +17,8 @@
  */
 package org.sonar.plugins.xml;
 
+import com.google.common.annotations.VisibleForTesting;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.sonar.api.batch.Sensor;
@@ -26,16 +28,22 @@
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.batch.rule.CheckFactory;
 import org.sonar.api.batch.rule.Checks;
+import org.sonar.api.component.Perspective;
 import org.sonar.api.component.ResourcePerspectives;
 import org.sonar.api.issue.Issuable;
 import org.sonar.api.resources.Project;
+import org.sonar.api.source.Highlightable;
+import org.sonar.api.source.Highlightable.HighlightingBuilder;
 import org.sonar.plugins.xml.checks.AbstractXmlCheck;
 import org.sonar.plugins.xml.checks.CheckRepository;
 import org.sonar.plugins.xml.checks.XmlIssue;
 import org.sonar.plugins.xml.checks.XmlSourceCode;
+import org.sonar.plugins.xml.highlighting.XMLHighlighting;
 import org.sonar.plugins.xml.language.Xml;
+import org.sonar.plugins.xml.highlighting.HighlightingData;
 
-import com.google.common.annotations.VisibleForTesting;
+import javax.annotation.Nullable;
+import java.util.List;
 
 /**
  * XmlSensor provides analysis of xml files.
@@ -44,12 +52,11 @@
  */
 public class XmlSensor implements Sensor {
 
-  private static final Logger LOG = LoggerFactory.getLogger(XmlSensor.class);
-
   private final Checks<Object> checks;
   private final FileSystem fileSystem;
   private final ResourcePerspectives resourcePerspectives;
   private final FilePredicate mainFilesPredicate;
+  private static final Logger LOG = LoggerFactory.getLogger(XmlSensor.class);
 
   public XmlSensor(FileSystem fileSystem, ResourcePerspectives resourcePerspectives, CheckFactory checkFactory) {
     this.checks = checkFactory.create(CheckRepository.REPOSITORY_KEY).addAnnotatedChecks(CheckRepository.getCheckClasses());
@@ -77,13 +84,38 @@ public void analyse(Project project, SensorContext sensorContext) {
             ((AbstractXmlCheck) check).validate(sourceCode);
           }
           saveIssue(sourceCode);
+
+          saveSyntaxHighlighting(XMLHighlighting.getHighlightingData(inputFile.file(), fileSystem.encoding()), inputFile);
         }
       } catch (Exception e) {
-        LOG.error("Could not analyze the file " + inputFile.file().getAbsolutePath(), e);
+        throw new IllegalStateException("Could not analyze the file " + inputFile.file().getAbsolutePath(), e);
       }
     }
   }
 
+  private void saveSyntaxHighlighting(List<HighlightingData> highlightingDataList, InputFile inputFile) {
+    Highlightable highlightable = perspective(Highlightable.class, inputFile);
+    if (highlightable != null) {
+      HighlightingBuilder highlightingBuilder = highlightable.newHighlighting();
+
+      for (HighlightingData highlightingData : highlightingDataList) {
+        highlightingBuilder.highlight(highlightingData.startOffset(), highlightingData.endOffset(), highlightingData.highlightCode());
+      }
+
+      highlightingBuilder.done();
+    }
+
+  }
+
+  @Nullable
+  <P extends Perspective<?>> P perspective(Class<P> clazz, InputFile file) {
+    P result = resourcePerspectives.as(clazz, file);
+    if (result == null) {
+      LOG.warn("Could not get " + clazz.getCanonicalName() + " for " + file);
+    }
+    return result;
+  }
+
   @VisibleForTesting
   protected void saveIssue(XmlSourceCode sourceCode) {
     for (XmlIssue xmlIssue : sourceCode.getXmlIssues()) {
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/AbstractXmlCheck.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/AbstractXmlCheck.java
index 5f7a858b..a72831af 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/AbstractXmlCheck.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/AbstractXmlCheck.java
@@ -55,6 +55,10 @@ public final void setRuleKey(RuleKey ruleKey) {
     this.ruleKey = ruleKey;
   }
 
+  public RuleKey getRuleKey() {
+    return ruleKey;
+  }
+
   protected void setWebSourceCode(XmlSourceCode xmlSourceCode) {
     this.xmlSourceCode = xmlSourceCode;
   }
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XPathCheck.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XPathCheck.java
index 6333babb..5e96d25d 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XPathCheck.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XPathCheck.java
@@ -102,7 +102,7 @@ private void evaluateXPathForBoolean(Document document, XPathExpression xPathExp
       }
 
     } catch (XPathExpressionException exceptionBoolean) {
-      throw new IllegalStateException(String.format("Can't evaluate XPath expression \"%s\"", expression), exceptionBoolean);
+      throw createExpressionException(exceptionBoolean);
     }
   }
 
@@ -133,10 +133,15 @@ private XPathExpression getXPathExpressionForDocument(Document document) {
       xpath.setNamespaceContext(new DocumentNamespaceContext(resolver));
       return xpath.compile(expression);
     } catch (XPathExpressionException e) {
-      throw new IllegalStateException(String.format("Can't compile XPath expression \"%s\"", expression), e);
+      throw createExpressionException(e);
     }
   }
 
+  private IllegalStateException createExpressionException(XPathExpressionException e) {
+    return new IllegalStateException(
+      String.format("Can't compile XPath expression \"%s\" for rule %s", expression, getRuleKey()), e);
+  }
+
   public void setExpression(String expression) {
     this.expression = expression;
   }
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XmlSourceCode.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XmlSourceCode.java
index 36cc456b..874cb8bc 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XmlSourceCode.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/checks/XmlSourceCode.java
@@ -17,12 +17,6 @@
  */
 package org.sonar.plugins.xml.checks;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-
 import org.apache.commons.io.FileUtils;
 import org.sonar.api.batch.fs.FileSystem;
 import org.sonar.api.batch.fs.InputFile;
@@ -31,6 +25,12 @@
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Checks and analyzes report measurements, issues and other findings in WebSourceCode.
  *
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/language/XmlCodeColorizerFormat.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/HighlightingData.java
similarity index 54%
rename from sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/language/XmlCodeColorizerFormat.java
rename to sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/HighlightingData.java
index 8d8f6ef9..5a7388e0 100644
--- a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/language/XmlCodeColorizerFormat.java
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/HighlightingData.java
@@ -15,23 +15,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.sonar.plugins.xml.language;
+package org.sonar.plugins.xml.highlighting;
 
-import org.sonar.api.web.CodeColorizerFormat;
-import org.sonar.colorizer.Tokenizer;
-import org.sonar.xml.XmlColorizer;
+public class HighlightingData {
 
-import java.util.List;
+  private Integer startOffset;
+  private Integer endOffset;
+  private String highlightCode;
 
-public class XmlCodeColorizerFormat extends CodeColorizerFormat {
+  public HighlightingData(Integer startOffset, Integer endOffset, String highlightCode) {
+    this.startOffset = startOffset;
+    this.endOffset = endOffset;
+    this.highlightCode = highlightCode;
+  }
+
+  public Integer startOffset() {
+    return startOffset;
+  }
 
-  public XmlCodeColorizerFormat() {
-    super(Xml.KEY);
+  public Integer endOffset() {
+    return endOffset;
   }
 
-  @Override
-  public List<Tokenizer> getTokenizers() {
-    return XmlColorizer.createTokenizers();
+  public String highlightCode() {
+    return highlightCode;
   }
 
 }
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/SourceFileOffsets.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/SourceFileOffsets.java
new file mode 100644
index 00000000..8d620da0
--- /dev/null
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/SourceFileOffsets.java
@@ -0,0 +1,84 @@
+/*
+ * SonarQube XML Plugin
+ * Copyright (C) 2010 SonarSource
+ * sonarqube@googlegroups.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.sonar.plugins.xml.highlighting;
+
+import com.google.common.collect.Lists;
+import com.google.common.io.Files;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.List;
+
+public class SourceFileOffsets {
+  private final int length;
+  private final List<Integer> lineStartOffsets = Lists.newArrayList();
+  private final String content;
+
+  public SourceFileOffsets(String content) {
+    this.content = content;
+    this.length = content.length();
+    initOffsets(content);
+  }
+
+  public SourceFileOffsets(File file, Charset charset) {
+    this(fileContent(file, charset));
+  }
+
+  public String content() {
+    return content;
+  }
+
+  private static String fileContent(File file, Charset charset) {
+    String fileContent;
+    try {
+      fileContent = Files.toString(file, charset);
+    } catch (IOException e) {
+      throw new IllegalStateException("Could not read " + file, e);
+    }
+    return fileContent;
+  }
+
+  private void initOffsets(String toParse) {
+    lineStartOffsets.add(0);
+    int i = 0;
+    while (i < length) {
+      if (toParse.charAt(i) == '\n' || toParse.charAt(i) == '\r') {
+        int nextLineStartOffset = i + 1;
+        if (i < (length - 1) && toParse.charAt(i) == '\r' && toParse.charAt(i + 1) == '\n') {
+          nextLineStartOffset = i + 2;
+          i++;
+        }
+        lineStartOffsets.add(nextLineStartOffset);
+      }
+      i++;
+    }
+  }
+
+  /**
+   * @param line starts from 1
+   * @param column starts from 1
+   * @return startOffset (starting from 0)
+   */
+  public int startOffset(int line, int column) {
+    int lineStartOffset = lineStartOffsets.get(line - 1);
+    return lineStartOffset + (column - 1);
+  }
+
+}
+
diff --git a/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/XMLHighlighting.java b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/XMLHighlighting.java
new file mode 100644
index 00000000..daccf921
--- /dev/null
+++ b/sonar-xml-plugin/src/main/java/org/sonar/plugins/xml/highlighting/XMLHighlighting.java
@@ -0,0 +1,191 @@
+/*
+ * SonarQube XML Plugin
+ * Copyright (C) 2010 SonarSource
+ * sonarqube@googlegroups.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.sonar.plugins.xml.highlighting;
+
+import javax.xml.stream.Location;
+import javax.xml.stream.XMLInputFactory;
+import javax.xml.stream.XMLStreamConstants;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.List;
+
+public class XMLHighlighting {
+
+  private XMLHighlighting() {
+  }
+
+  public static List<HighlightingData> getHighlightingData(File file, Charset charset) throws IOException, XMLStreamException {
+    return getHighlightingData(new FileInputStream(file), new SourceFileOffsets(file, charset));
+  }
+
+  public static List<HighlightingData> getHighlightingData(String content) throws XMLStreamException {
+    InputStream inputStream = new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8));
+    return getHighlightingData(inputStream, new SourceFileOffsets(content));
+  }
+
+  public static List<HighlightingData> getHighlightingData(InputStream inputStream, SourceFileOffsets sourceFileOffsets) throws XMLStreamException {
+    XMLStreamReader streamReader = XMLInputFactory.newInstance().createXMLStreamReader(inputStream);
+
+    List<HighlightingData> highlighting = new ArrayList<>();
+
+    if (sourceFileOffsets.content().startsWith("<?xml")) {
+      highlighting.add(new HighlightingData(0, 5, "k"));
+      int closingBracketStartOffset = getClosingBracketStartOffset(0, sourceFileOffsets.content());
+      highlighting.add(new HighlightingData(closingBracketStartOffset - 1, closingBracketStartOffset + 1, "k"));
+
+      highlightAttributes(highlighting, 5, closingBracketStartOffset, sourceFileOffsets.content());
+    }
+
+    while (streamReader.hasNext()) {
+      Location prevLocation = streamReader.getLocation();
+      streamReader.next();
+      int startOffset = sourceFileOffsets.startOffset(streamReader.getLocation().getLineNumber(), streamReader.getLocation().getColumnNumber());
+
+      switch (streamReader.getEventType()) {
+        case XMLStreamConstants.START_ELEMENT:
+          int closingBracketStartOffset = getClosingBracketStartOffset(startOffset, sourceFileOffsets.content());
+          int endOffset = startOffset + getNameWithNamespaceLength(streamReader) + 1;
+          highlightAttributes(highlighting, endOffset, closingBracketStartOffset, sourceFileOffsets.content());
+
+          highlighting.add(new HighlightingData(startOffset, endOffset, "k"));
+          highlighting.add(new HighlightingData(closingBracketStartOffset, closingBracketStartOffset + 1, "k"));
+          break;
+
+        case XMLStreamConstants.END_ELEMENT:
+          closingBracketStartOffset = getClosingBracketStartOffset(startOffset, sourceFileOffsets.content());
+          if (removePrevHighlightingIfEmptyElement(highlighting, streamReader, prevLocation)) {
+            endOffset = startOffset + getNameWithNamespaceLength(streamReader) + 1;
+            highlighting.add(new HighlightingData(startOffset, endOffset, "k"));
+            highlighting.add(new HighlightingData(closingBracketStartOffset - 1, closingBracketStartOffset + 1, "k"));
+          } else {
+            highlighting.add(new HighlightingData(startOffset, closingBracketStartOffset + 1, "k"));
+          }
+          break;
+
+        case XMLStreamConstants.CDATA:
+          closingBracketStartOffset = getCDATAClosingBracketStartOffset(startOffset, sourceFileOffsets.content());
+          highlighting.add(new HighlightingData(startOffset, startOffset + 9, "k"));
+          highlighting.add(new HighlightingData(closingBracketStartOffset - 2, closingBracketStartOffset + 1, "k"));
+          break;
+
+        case XMLStreamConstants.DTD:
+          closingBracketStartOffset = getClosingBracketStartOffset(startOffset, sourceFileOffsets.content());
+          highlighting.add(new HighlightingData(startOffset, startOffset + 9, "j"));
+          highlighting.add(new HighlightingData(closingBracketStartOffset, closingBracketStartOffset + 1, "j"));
+          break;
+
+        case XMLStreamConstants.COMMENT:
+          highlighting.add(new HighlightingData(startOffset, startOffset + streamReader.getTextLength() + 7, "j"));
+          break;
+
+        default:
+          break;
+      }
+    }
+
+    return highlighting;
+  }
+
+  private static void highlightAttributes(List<HighlightingData> highlighting, int from, int to, String content) {
+    int counter = from + 1;
+
+    Integer startOffset = null;
+    Character attributeValueQuote = null;
+
+    while (counter < to) {
+      char c = content.charAt(counter);
+
+      if (startOffset == null && !Character.isWhitespace(c)) {
+        startOffset = counter;
+      }
+
+
+      if (attributeValueQuote != null && attributeValueQuote == c) {
+        highlighting.add(new HighlightingData(startOffset, counter + 1, "s"));
+        counter++;
+        startOffset = null;
+        attributeValueQuote = null;
+      }
+
+      if (c == '=' && attributeValueQuote == null) {
+        highlighting.add(new HighlightingData(startOffset, counter, "c"));
+
+        do {
+          counter++;
+          c = content.charAt(counter);
+        } while (c != '\'' && c != '"');
+
+        startOffset = counter;
+        attributeValueQuote = c;
+      }
+
+
+      counter++;
+    }
+  }
+
+  private static boolean removePrevHighlightingIfEmptyElement(List<HighlightingData> highlighting, XMLStreamReader streamReader, Location prevLocation) {
+    boolean isEmptyElement = prevLocation.getLineNumber() == streamReader.getLocation().getLineNumber()
+      && prevLocation.getColumnNumber() == streamReader.getLocation().getColumnNumber();
+
+    if (isEmptyElement) {
+      highlighting.remove(highlighting.size() - 1);
+      highlighting.remove(highlighting.size() - 1);
+    }
+
+    return isEmptyElement;
+  }
+
+  private static int getClosingBracketStartOffset(int startOffset, String content) {
+    return getCommonClosingBracketStartOffset(startOffset, content, false);
+  }
+
+  private static int getCDATAClosingBracketStartOffset(int startOffset, String content) {
+    return getCommonClosingBracketStartOffset(startOffset, content, true);
+  }
+
+  private static int getCommonClosingBracketStartOffset(int startOffset, String content, boolean isCDATA) {
+    int counter = startOffset + 1;
+    while (startOffset < content.length()) {
+      if (content.charAt(counter) == '>' && (!isCDATA || content.charAt(counter - 1) == ']')) {
+        return counter;
+      }
+      counter++;
+    }
+
+    throw new IllegalStateException("No \">\" found.");
+  }
+
+  private static int getNameWithNamespaceLength(XMLStreamReader streamReader) {
+    int prefixLength = 0;
+    if (!streamReader.getName().getPrefix().isEmpty()) {
+      prefixLength = streamReader.getName().getPrefix().length() + 1;
+    }
+
+    return prefixLength + streamReader.getLocalName().length();
+  }
+
+}
diff --git a/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/XmlSensorTest.java b/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/XmlSensorTest.java
index fcf4510c..4948484a 100644
--- a/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/XmlSensorTest.java
+++ b/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/XmlSensorTest.java
@@ -17,18 +17,6 @@
  */
 package org.sonar.plugins.xml;
 
-import static org.fest.assertions.Assertions.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.io.File;
-import java.util.Collections;
-
 import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
@@ -37,20 +25,29 @@
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.batch.fs.internal.DefaultFileSystem;
 import org.sonar.api.batch.fs.internal.DefaultInputFile;
-import org.sonar.api.batch.rule.ActiveRule;
 import org.sonar.api.batch.rule.CheckFactory;
 import org.sonar.api.batch.rule.internal.ActiveRulesBuilder;
 import org.sonar.api.batch.rule.internal.DefaultActiveRules;
-import org.sonar.api.batch.rule.internal.NewActiveRule;
 import org.sonar.api.component.ResourcePerspectives;
 import org.sonar.api.issue.Issuable;
+import org.sonar.api.issue.Issue;
 import org.sonar.api.resources.Project;
 import org.sonar.api.rule.RuleKey;
-import org.sonar.api.scan.filesystem.PathResolver;
 import org.sonar.plugins.xml.checks.CheckRepository;
-import org.sonar.plugins.xml.checks.XmlSourceCode;
 import org.sonar.plugins.xml.language.Xml;
 
+import java.io.File;
+
+import static org.fest.assertions.Assertions.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyInt;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
 public class XmlSensorTest extends AbstractXmlPluginTester {
 
   @org.junit.Rule
@@ -74,7 +71,18 @@ public void setUp() throws Exception {
       ImmutableList.of(new ActiveRulesBuilder().create(RuleKey.of(CheckRepository.REPOSITORY_KEY, "NewlineCheck")))));
 
     perspectives = mock(ResourcePerspectives.class);
-    when(perspectives.as(any(Class.class), any(InputFile.class))).thenReturn(mock(Issuable.class));
+
+    Issuable.IssueBuilder issueBuilder = mock(Issuable.IssueBuilder.class);
+    Issue issue = mock(Issue.class);
+    Issuable issuable = mock(Issuable.class);
+
+    when(perspectives.as(eq(Issuable.class), any(InputFile.class))).thenReturn(issuable);
+    when(issuable.newIssueBuilder()).thenReturn(issueBuilder);
+    when(issueBuilder.ruleKey(any(RuleKey.class))).thenReturn(issueBuilder);
+    when(issueBuilder.line(anyInt())).thenReturn(issueBuilder);
+    when(issueBuilder.message(any(String.class))).thenReturn(issueBuilder);
+    when(issueBuilder.build()).thenReturn(issue);
+    when(issuable.addIssue(issue)).thenReturn(true);
 
     sensor = new XmlSensor(fs, perspectives, checkFactory);
   }
diff --git a/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/highlighting/XmlHighlightingTest.java b/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/highlighting/XmlHighlightingTest.java
new file mode 100644
index 00000000..943d9e3c
--- /dev/null
+++ b/sonar-xml-plugin/src/test/java/org/sonar/plugins/xml/highlighting/XmlHighlightingTest.java
@@ -0,0 +1,198 @@
+/*
+ * SonarQube XML Plugin
+ * Copyright (C) 2010 SonarSource
+ * sonarqube@googlegroups.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.sonar.plugins.xml.highlighting;
+
+import org.junit.Test;
+
+import javax.xml.stream.XMLStreamException;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class XmlHighlightingTest {
+
+  @Test
+  public void testCDATAWithTagsInside() throws Exception {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag><![CDATA[<tag/><!-- Comment -->]]></tag>");
+    assertEquals(5, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 4, "k");
+    assertData(highlightingData.get(1), 4, 5, "k");
+
+    assertData(highlightingData.get(2), 5, 14, "k");
+    assertData(highlightingData.get(3), 36, 39, "k");
+
+    assertData(highlightingData.get(4), 39, 45, "k");
+  }
+
+  @Test
+  public void testHighlightAutoclosingTagWithAttribute() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<input type='checkbox' />");
+    assertEquals(4, highlightingData.size());
+    assertData(highlightingData.get(2), 0, 6, "k");
+    assertData(highlightingData.get(0), 7, 11, "c");
+    assertData(highlightingData.get(1), 12, 22, "s");
+    assertData(highlightingData.get(3), 23, 25, "k");
+  }
+
+  @Test
+  public void testHighlightTagWithDoubleQuoteAttribute() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag att=\"value ' with simple quote\"> </tag>");
+    assertEquals(5, highlightingData.size());
+    assertData(highlightingData.get(2), 0, 4, "k");
+    assertData(highlightingData.get(0), 5, 8, "c");
+    assertData(highlightingData.get(1), 9, 36, "s");
+    assertData(highlightingData.get(3), 36, 37, "k");
+  }
+
+  @Test
+  public void testHighlightMultilineTagWithAttributes() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag att1='value1' \n att2\n = 'value2' att3=\n'value3' att4='multiline \n \" attribute'> </tag>");
+    assertEquals(11, highlightingData.size());
+    assertData(highlightingData.get(0), 5, 9, "c");
+    assertData(highlightingData.get(1), 10, 18, "s");
+    assertData(highlightingData.get(2), 21, 27, "c");
+    assertData(highlightingData.get(3), 29, 37, "s");
+    assertData(highlightingData.get(4), 38, 42, "c");
+    assertData(highlightingData.get(5), 44, 52, "s");
+    assertData(highlightingData.get(6), 53, 57, "c");
+    assertData(highlightingData.get(7), 58, 83, "s");
+
+    assertData(highlightingData.get(8), 0, 4, "k");
+    assertData(highlightingData.get(9), 83, 84, "k");
+  }
+
+  @Test
+  public void testHighlightMultilineComments() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag><!-- hello \n" +
+      " world!! --></tag>");
+    assertEquals(4, highlightingData.size());
+    assertData(highlightingData.get(2), 5, 29, "j");
+  }
+
+  @Test
+  public void testHighlightMultilineComments_() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<?xml version=\"1.0\"?>\n" +
+      "  \n" +
+      "<!--\n" +
+      " A OnJava Journal Catalog --><tag/>");
+    assertEquals(7, highlightingData.size());
+    assertData(highlightingData.get(4), 25, 59, "j");
+  }
+
+  @Test
+  public void testAttributeValueWithEqual() throws Exception {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<meta content=\"charset=UTF-8\" />");
+    assertEquals(4, highlightingData.size());
+    assertData(highlightingData.get(1), 14, 29, "s");
+  }
+
+  @Test
+  public void testHighlightCommentsAndOtherTag() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<!-- comment --><tag/>");
+    assertEquals(3, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 16, "j");
+  }
+
+  @Test
+  public void testHighlightDoctype() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<!DOCTYPE foo> <tag/>");
+    assertEquals(4, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 9, "j");
+    assertData(highlightingData.get(1), 13, 14, "j");
+  }
+
+  @Test
+  public void testCDATA() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag><![CDATA[foo]]></tag>");
+    assertEquals(5, highlightingData.size());
+    assertData(highlightingData.get(2), 5, 14, "k");
+    assertData(highlightingData.get(3), 17, 20, "k");
+  }
+
+  @Test
+  public void testCDATAMultiline() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData(
+      "<tag><![CDATA[foo\n" +
+        "bar\n" +
+        "]]></tag>");
+    assertEquals(5, highlightingData.size());
+    assertData(highlightingData.get(2), 5, 14, "k");
+    assertData(highlightingData.get(3), 22, 25, "k");
+  }
+
+  @Test
+  public void testHighlightTag() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tr></tr>");
+    assertEquals(3, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 3, "k");
+    assertData(highlightingData.get(1), 3, 4, "k");
+    assertData(highlightingData.get(2), 4, 9, "k");
+  }
+
+  @Test
+  public void testEmptyElement() throws Exception {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<br/>");
+    assertEquals(2, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 3, "k");
+    assertData(highlightingData.get(1), 3, 5, "k");
+  }
+
+  @Test
+  public void testSpacesInside() throws Exception {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag > </tag >");
+    assertEquals(3, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 4, "k");
+    assertData(highlightingData.get(1), 5, 6, "k");
+    assertData(highlightingData.get(2), 7, 14, "k");
+
+    highlightingData = XMLHighlighting.getHighlightingData("<tag />");
+    assertEquals(2, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 4, "k");
+    assertData(highlightingData.get(1), 5, 7, "k");
+  }
+
+  @Test
+  public void testHighlightTagWithNamespace() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<tag xmlns:x='url'>\n<x:table>  </x:table></tag>");
+    assertEquals(8, highlightingData.size());
+    assertData(highlightingData.get(0), 5, 12, "c");
+    assertData(highlightingData.get(1), 13, 18, "s");
+    assertData(highlightingData.get(4), 20, 28, "k");
+    assertData(highlightingData.get(5), 28, 29, "k");
+  }
+
+  @Test
+  public void testXMLHeader() throws XMLStreamException {
+    List<HighlightingData> highlightingData = XMLHighlighting.getHighlightingData("<?xml version=\"1.0\" encoding=\"UTF-8\" ?> <tag/>");
+    assertEquals(8, highlightingData.size());
+    assertData(highlightingData.get(0), 0, 5, "k");
+    assertData(highlightingData.get(1), 37, 39, "k");
+
+    assertData(highlightingData.get(2), 6, 13, "c");
+    assertData(highlightingData.get(3), 14, 19, "s");
+    assertData(highlightingData.get(4), 20, 28, "c");
+    assertData(highlightingData.get(5), 29, 36, "s");
+  }
+
+  private void assertData(HighlightingData data, Integer start, Integer end, String code) {
+    assertEquals(start, data.startOffset());
+    assertEquals(end, data.endOffset());
+    assertEquals(code, data.highlightCode());
+  }
+
+}
diff --git a/xml-squid/src/test/java/org/sonar/xml/XmlCodeColorizerFormatTest.java b/xml-squid/src/test/java/org/sonar/xml/XmlCodeColorizerFormatTest.java
deleted file mode 100644
index 1d898f5a..00000000
--- a/xml-squid/src/test/java/org/sonar/xml/XmlCodeColorizerFormatTest.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * SonarQube XML Plugin
- * Copyright (C) 2010 SonarSource
- * sonarqube@googlegroups.com
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.sonar.xml;
-
-import org.junit.Test;
-import org.sonar.colorizer.CodeColorizer;
-
-import java.io.StringReader;
-
-import static org.hamcrest.Matchers.containsString;
-import static org.junit.Assert.assertThat;
-
-public class XmlCodeColorizerFormatTest {
-
-  private CodeColorizer codeColorizer = new CodeColorizer(XmlColorizer.createTokenizers());
-
-  @Test
-  public void testXMLHeader() {
-    assertThat(
-        highlight("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"),
-        containsString("<span class=\"k\">&lt;?xml</span> <span class=\"c\">version</span>=<span class=\"s\">\"1.0\"</span> <span class=\"c\">encoding</span>=<span class=\"s\">\"UTF-8\"</span><span class=\"k\">?&gt;</span>"));
-  }
-
-  @Test
-  public void testCDATA() {
-    assertThat(highlight("<![CDATA[foo]]>"), containsString("<span class=\"k\">&lt;![CDATA[</span>foo<span class=\"k\">]]&gt;</span>"));
-  }
-
-  @Test
-  public void testCDATAMultiline() {
-    String cdataMultiline = highlight("<![CDATA[foo\nbar\n]]>");
-    assertThat(cdataMultiline, containsString("<span class=\"k\">&lt;![CDATA[</span>foo"));
-    assertThat(cdataMultiline, containsString("bar"));
-    assertThat(cdataMultiline, containsString("<span class=\"k\">]]&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightTag() {
-    assertThat(highlight("</tr>"), containsString("<span class=\"k\">&lt;/tr&gt;</span>"));
-    assertThat(highlight("<h3>"), containsString("<span class=\"k\">&lt;h3</span><span class=\"k\">&gt;</span>"));
-    assertThat(highlight("<active-rule>"), containsString("<span class=\"k\">&lt;active-rule</span><span class=\"k\">&gt;</span>"));
-    assertThat(highlight("</active-rule>"), containsString("<span class=\"k\">&lt;/active-rule&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightTagWithNamespace() {
-    assertThat(highlight("<namespace:table >"), containsString("<span class=\"k\">&lt;namespace:table</span> <span class=\"k\">&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightTagWithSingleQuoteAttribute() {
-    assertThat(highlight("<tag att='value \" with double quote'>"),
-        containsString("<span class=\"k\">&lt;tag</span> <span class=\"c\">att</span>=<span class=\"s\">'value \" with double quote'</span><span class=\"k\">&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightAutoclosingTagWithAttribute() {
-    assertThat(highlight("<input type='checkbox' />"),
-        containsString("<span class=\"k\">&lt;input</span> <span class=\"c\">type</span>=<span class=\"s\">'checkbox'</span> <span class=\"k\">/&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightTagWithDoubleQuoteAttribute() {
-    assertThat(highlight("<tag att=\"value ' with simple quote\">"),
-        containsString("<span class=\"k\">&lt;tag</span> <span class=\"c\">att</span>=<span class=\"s\">\"value ' with simple quote\"</span><span class=\"k\">&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightMultilineTagWithAttributes() {
-    String multilinetag = highlight("<tag att1='value1' \n att2\n = 'value2' att3=\n'value3' att4='multiline \n \" attribute'>");
-    assertThat(multilinetag,
-        containsString("<span class=\"k\">&lt;tag</span> <span class=\"c\">att1</span>=<span class=\"s\">'value1'</span> "));
-    assertThat(multilinetag, containsString(" <span class=\"c\">att2</span>"));
-    assertThat(multilinetag, containsString(" = <span class=\"s\">'value2'</span> <span class=\"c\">att3</span>="));
-    assertThat(multilinetag, containsString("<span class=\"s\">'value3'</span> <span class=\"c\">att4</span>=<span class=\"s\">'multiline </span>"));
-    assertThat(multilinetag, containsString("<span class=\"s\">\" attribute'</span>"));
-  }
-
-  @Test
-  public void testHighlightComments() {
-    assertThat(highlight("<!-- hello world!! --> Foo"), containsString("<span class=\"j\">&lt;!-- hello world!! --&gt;</span> Foo"));
-  }
-
-  @Test
-  public void testHighlightMultilineComments() {
-    String commentMultiline = highlight("<!-- hello \n world!! --> Foo");
-    assertThat(commentMultiline, containsString("<span class=\"j\">&lt;!-- hello </span>"));
-    assertThat(commentMultiline, containsString("<span class=\"j\"> world!! --&gt;</span> Foo"));
-  }
-
-  @Test
-  public void testHighlightCommentsAndOtherTag() {
-    assertThat(
-        highlight("<!-- hello world!! --><table size='45px'>"),
-        containsString("<span class=\"j\">&lt;!-- hello world!! --&gt;</span><span class=\"k\">&lt;table</span> <span class=\"c\">size</span>=<span class=\"s\">'45px'</span><span class=\"k\">&gt;</span>"));
-  }
-
-  @Test
-  public void testHighlightDoctype() {
-    assertThat(highlight("<!DOCTYPE foo bar >"), containsString("<span class=\"j\">&lt;!DOCTYPE</span> foo bar <span class=\"j\">&gt;</span>"));
-  }
-
-  private String highlight(String webSourceCode) {
-    return codeColorizer.toHtml(new StringReader(webSourceCode));
-  }
-
-}
