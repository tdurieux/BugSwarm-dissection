diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
new file mode 100644
index 000000000..14b638e30
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import okio.BufferedSource;
+import okio.ByteString;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class ResponseBodyTest {
+  @Test public void stringDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomOverridesExplicitCharset() throws IOException {
+    ResponseBody body = body("0000FFFF00000068000000650000006c0000006c0000006f", "utf-8");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf8() throws IOException {
+    ResponseBody body = body("EFBBBF68656c6c6f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Be() throws IOException {
+    ResponseBody body = body("FEFF00680065006c006c006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf16Le() throws IOException {
+    ResponseBody body = body("FFFE680065006c006c006f00");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000FFFF00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void stringBomUtf32Le() throws IOException {
+    ResponseBody body = body("FFFF000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", body.string());
+  }
+
+  @Test public void readerDefaultsToUtf8() throws IOException {
+    ResponseBody body = body("68656c6c6f");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerExplicitCharset() throws IOException {
+    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerBomUtf8() throws IOException {
+    ResponseBody body = body("EFBBBF68656c6c6f");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerBomUtf16Be() throws IOException {
+    ResponseBody body = body("FEFF00680065006c006c006f");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerBomUtf16Le() throws IOException {
+    ResponseBody body = body("FFFE680065006c006c006f00");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerBomUtf32Be() throws IOException {
+    ResponseBody body = body("0000FFFF00000068000000650000006c0000006c0000006f");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void readerBomUtf32Le() throws IOException {
+    ResponseBody body = body("FFFF000068000000650000006c0000006c0000006f000000");
+    assertEquals("hello", new BufferedReader(body.charStream()).readLine());
+  }
+
+  @Test public void sourceSeesBom() throws IOException {
+    ResponseBody body = body("EFBBFF68656C6C6F");
+    BufferedSource source = body.source();
+    assertEquals(0xEF, source.readByte() & 0xFF);
+    assertEquals(0xBB, source.readByte() & 0xFF);
+    assertEquals(0xFF, source.readByte() & 0xFF);
+    assertEquals("hello", source.readUtf8());
+  }
+
+  @Test public void bytesSeesBom() throws IOException {
+    ResponseBody body = body("EFBBFF68656C6C6F");
+    byte[] bytes = body.bytes();
+    assertEquals(0xEF, bytes[0] & 0xFF);
+    assertEquals(0xBB, bytes[1] & 0xFF);
+    assertEquals(0xFF, bytes[2] & 0xFF);
+    assertEquals("hello", new String(bytes, 3, 5, "UTF-8"));
+  }
+
+  @Test public void byteStreamSeesBom() throws IOException {
+    ResponseBody body = body("EFBBFF68656C6C6F");
+    InputStream bytes = body.byteStream();
+    assertEquals(0xEF, bytes.read());
+    assertEquals(0xBB, bytes.read());
+    assertEquals(0xFF, bytes.read());
+    assertEquals("hello", new BufferedReader(new InputStreamReader(bytes)).readLine());
+  }
+
+  private static ResponseBody body(String hex) {
+    return body(hex, null);
+  }
+
+  private static ResponseBody body(String hex, String charset) {
+    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index c0d3309b3..a1a63c196 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -145,24 +145,30 @@ public final InputStream byteStream() {
   /**
    * Returns the response as a character stream decoded with the charset of the Content-Type header.
    * If that header is either absent or lacks a charset, this will attempt to decode the response
-   * body as UTF-8.
+   * body in accordance to its BOM or UTF-8.
    */
   public final Reader charStream() {
     Reader r = reader;
-    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+    return r != null ? r : (reader = new BomAwareReader(source(), charset()));
   }
 
   /**
    * Returns the response as a string decoded with the charset of the Content-Type header. If that
-   * header is either absent or lacks a charset, this will attempt to decode the response body as
-   * UTF-8. Closes {@link ResponseBody} automatically.
+   * header is either absent or lacks a charset, this will attempt to decode the response body in
+   * accordance to its BOM or UTF-8. Closes {@link ResponseBody} automatically.
    *
    * <p>This method loads entire response body into memory. If the response body is very large this
    * may trigger an {@link OutOfMemoryError}. Prefer to stream the response body if this is a
    * possibility for your response.
    */
   public final String string() throws IOException {
-    return new String(bytes(), charset().name());
+    BufferedSource source = source();
+    try {
+      Charset charset = Util.bomAwareCharset(source, charset());
+      return source.readString(charset);
+    } finally {
+      Util.closeQuietly(source);
+    }
   }
 
   private Charset charset() {
@@ -215,4 +221,35 @@ public static ResponseBody create(
       }
     };
   }
+
+  static final class BomAwareReader extends Reader {
+    private final BufferedSource source;
+    private final Charset charset;
+
+    private boolean closed;
+    private Reader delegate;
+
+    private BomAwareReader(BufferedSource source, Charset charset) {
+      this.source = source;
+      this.charset = charset;
+    }
+
+    @Override public int read(char[] cbuf, int off, int len) throws IOException {
+      if (closed) throw new IOException("Stream closed");
+
+      Reader delegate = this.delegate;
+      if (delegate == null) {
+        Charset charset = Util.bomAwareCharset(source, this.charset);
+        delegate = this.delegate = new InputStreamReader(source.inputStream(), charset);
+      }
+      return delegate.read(cbuf, off, len);
+    }
+
+    @Override public void close() throws IOException {
+      closed = true;
+      if (delegate != null) {
+        delegate.close();
+      }
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 56dfdf555..8429afd3e 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -37,6 +37,7 @@
 import java.util.regex.Pattern;
 import okhttp3.HttpUrl;
 import okio.Buffer;
+import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 
@@ -45,8 +46,17 @@
   public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
   public static final String[] EMPTY_STRING_ARRAY = new String[0];
 
-  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  private static final ByteString UTF_8_BOM = ByteString.decodeHex("EFBBBF");
+  private static final ByteString UTF_16_BE_BOM = ByteString.decodeHex("FEFF");
+  private static final ByteString UTF_16_LE_BOM = ByteString.decodeHex("FFFE");
+  private static final ByteString UTF_32_BE_BOM = ByteString.decodeHex("0000FFFF");
+  private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("FFFF0000");
+
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
+  private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
+  private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
+  private static final Charset UTF_32_LE = Charset.forName("UTF-32LE");
 
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
@@ -424,4 +434,28 @@ public static boolean verifyAsIpAddress(String host) {
   public static String format(String format, Object... args) {
     return String.format(Locale.US, format, args);
   }
+
+  public static Charset bomAwareCharset(BufferedSource source, Charset charset) throws IOException {
+    if (source.rangeEquals(0, UTF_8_BOM)) {
+      source.skip(UTF_8_BOM.size());
+      return UTF_8;
+    }
+    if (source.rangeEquals(0, UTF_16_BE_BOM)) {
+      source.skip(UTF_16_BE_BOM.size());
+      return UTF_16_BE;
+    }
+    if (source.rangeEquals(0, UTF_16_LE_BOM)) {
+      source.skip(UTF_16_LE_BOM.size());
+      return UTF_16_LE;
+    }
+    if (source.rangeEquals(0, UTF_32_BE_BOM)) {
+      source.skip(UTF_32_BE_BOM.size());
+      return UTF_32_BE;
+    }
+    if (source.rangeEquals(0, UTF_32_LE_BOM)) {
+      source.skip(UTF_32_LE_BOM.size());
+      return UTF_32_LE;
+    }
+    return charset;
+  }
 }
