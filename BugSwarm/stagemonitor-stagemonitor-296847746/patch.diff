diff --git a/stagemonitor-configuration/src/main/java/org/stagemonitor/configuration/ConfigurationOptionProvider.java b/stagemonitor-configuration/src/main/java/org/stagemonitor/configuration/ConfigurationOptionProvider.java
index 70bcbcce..2252d3a6 100644
--- a/stagemonitor-configuration/src/main/java/org/stagemonitor/configuration/ConfigurationOptionProvider.java
+++ b/stagemonitor-configuration/src/main/java/org/stagemonitor/configuration/ConfigurationOptionProvider.java
@@ -1,20 +1,22 @@
 package org.stagemonitor.configuration;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedList;
 import java.util.List;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 public abstract class ConfigurationOptionProvider {
 
 	private final Logger logger = LoggerFactory.getLogger(getClass());
 
 	public List<ConfigurationOption<?>> getConfigurationOptions() {
 		List<ConfigurationOption<?>> configurationOptions = new LinkedList<ConfigurationOption<?>>();
-		for (Field field : getClass().getDeclaredFields()) {
-			if (field.getType() == ConfigurationOption.class) {
+		for (Field field : getAllDeclaredFields(getClass())) {
+			if (ConfigurationOption.class.isAssignableFrom(field.getType())) {
 				field.setAccessible(true);
 				try {
 					configurationOptions.add((ConfigurationOption) field.get(this));
@@ -26,4 +28,12 @@
 		return configurationOptions;
 	}
 
+	private static List<Field> getAllDeclaredFields(Class<?> type) {
+		List<Field> fields = new ArrayList<Field>();
+		for (Class<?> c = type; c != null; c = c.getSuperclass()) {
+			fields.addAll(Arrays.asList(c.getDeclaredFields()));
+		}
+		return fields;
+	}
+
 }
diff --git a/stagemonitor-tracing-elasticsearch/src/main/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactory.java b/stagemonitor-tracing-elasticsearch/src/main/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactory.java
index 09c8f8ec..53aa9666 100644
--- a/stagemonitor-tracing-elasticsearch/src/main/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactory.java
+++ b/stagemonitor-tracing-elasticsearch/src/main/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactory.java
@@ -7,7 +7,9 @@
 import org.stagemonitor.core.StagemonitorPlugin;
 import org.stagemonitor.tracing.B3HeaderFormat;
 import org.stagemonitor.tracing.TracerFactory;
+import org.stagemonitor.tracing.wrapper.SpanWrapper;
 
+import io.opentracing.Span;
 import io.opentracing.Tracer;
 import io.opentracing.propagation.Format;
 
@@ -25,4 +27,30 @@ public Tracer getTracer(StagemonitorPlugin.InitArguments initArguments) {
 				.registerExtractor(Format.Builtin.HTTP_HEADERS, b3TextMapCodec);
 		return builder.build();
 	}
+
+	@Override
+	public boolean isRoot(Span span) {
+		// TODO replace with Span#unwrap once https://github.com/opentracing/opentracing-java/pull/211 is merged
+		if (span instanceof SpanWrapper) {
+			span = ((SpanWrapper) span).getDelegate();
+		}
+		if (span instanceof com.uber.jaeger.Span) {
+			final com.uber.jaeger.Span jaegerSpan = (com.uber.jaeger.Span) span;
+			return jaegerSpan.context().getParentId() == 0;
+		}
+		return false;
+	}
+
+	@Override
+	public boolean isSampled(Span span) {
+		// TODO replace with Span#unwrap once https://github.com/opentracing/opentracing-java/pull/211 is merged
+		if (span instanceof SpanWrapper) {
+			span = ((SpanWrapper) span).getDelegate();
+		}
+		if (span instanceof com.uber.jaeger.Span) {
+			final com.uber.jaeger.Span jaegerSpan = (com.uber.jaeger.Span) span;
+			return jaegerSpan.context().isSampled();
+		}
+		return false;
+	}
 }
diff --git a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/AbstractElasticsearchSpanReporterTest.java b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/AbstractElasticsearchSpanReporterTest.java
index 981e14d5..54c4a514 100644
--- a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/AbstractElasticsearchSpanReporterTest.java
+++ b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/AbstractElasticsearchSpanReporterTest.java
@@ -13,6 +13,7 @@
 import org.stagemonitor.tracing.SpanContextInformation;
 import org.stagemonitor.tracing.TagRecordingSpanEventListener;
 import org.stagemonitor.tracing.TracingPlugin;
+import org.stagemonitor.tracing.impl.DefaultTracerFactory;
 import org.stagemonitor.tracing.metrics.MetricsSpanEventListener;
 import org.stagemonitor.tracing.profiler.CallStackElement;
 import org.stagemonitor.tracing.profiler.formatter.ShortSignatureFormatter;
@@ -32,6 +33,7 @@
 import io.opentracing.tag.Tags;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
@@ -71,6 +73,7 @@ public void setUp() throws Exception {
 		when(tracingPlugin.isProfilerActive()).thenReturn(true);
 		when(tracingPlugin.getProfilerRateLimitPerMinute()).thenReturn(1_000_000d);
 		when(tracingPlugin.getCallTreeAsciiFormatter()).thenReturn(new ShortSignatureFormatter());
+		when(tracingPlugin.isSampled(any())).then(invocation -> new DefaultTracerFactory().isSampled(invocation.getArgument(0)));
 		when(corePlugin.getElasticsearchUrl()).thenReturn("http://localhost:9200");
 		when(corePlugin.getElasticsearchUrls()).thenReturn(Collections.singletonList("http://localhost:9200"));
 		when(corePlugin.getElasticsearchClient()).thenReturn(elasticsearchClient = mock(ElasticsearchClient.class));
diff --git a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterIntegrationTest.java b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterIntegrationTest.java
index 48896fa2..73a36e97 100644
--- a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterIntegrationTest.java
+++ b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterIntegrationTest.java
@@ -28,6 +28,7 @@
 import io.opentracing.util.ThreadLocalScopeManager;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
@@ -51,6 +52,7 @@ public void setUp() throws Exception {
 		when(tracingPlugin.getDefaultRateLimitSpansPerMinute()).thenReturn(1000000d);
 		when(tracingPlugin.getProfilerRateLimitPerMinuteOption()).thenReturn(mock(ConfigurationOption.class));
 		when(tracingPlugin.isPseudonymizeUserNames()).thenReturn(true);
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		reporter = new ElasticsearchSpanReporter();
 		reporter.init(configuration);
 		final ReportingSpanEventListener reportingSpanEventListener = new ReportingSpanEventListener(configuration);
@@ -106,7 +108,7 @@ public void testUpdateSpan() throws Exception {
 	public void testUpdateNotYetExistentSpan_eventuallyUpdates() throws Exception {
 		final Span span = tracer.buildSpan("Test#test")
 				.withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)
-				.start();
+				.startManual();
 		reporter.updateSpan(B3HeaderFormat.getB3Identifiers(tracer, span), null, Collections.singletonMap("foo", "bar"));
 
 		span.finish();
diff --git a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterTest.java b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterTest.java
index 5b00ff83..0e3116be 100644
--- a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterTest.java
+++ b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/ElasticsearchSpanReporterTest.java
@@ -64,7 +64,6 @@ public void testReportSpanDontReport() throws Exception {
 		final SpanContextInformation info = reportSpanWithCallTree(1, "Regular Foo");
 
 		Assert.assertTrue(reporter.isActive(info));
-		Assert.assertFalse(info.isSampled());
 		assertEquals(0, tags.get(Tags.SAMPLING_PRIORITY.getKey()));
 	}
 
diff --git a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactoryTest.java b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactoryTest.java
index 44b94f44..1a2ed2f2 100644
--- a/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactoryTest.java
+++ b/stagemonitor-tracing-elasticsearch/src/test/java/org/stagemonitor/tracing/elasticsearch/impl/JaegerTracerFactoryTest.java
@@ -3,7 +3,6 @@
 import org.junit.Test;
 import org.stagemonitor.core.MeasurementSession;
 import org.stagemonitor.core.StagemonitorPlugin;
-import org.stagemonitor.tracing.utils.SpanUtils;
 
 import io.opentracing.Scope;
 import io.opentracing.Tracer;
@@ -19,11 +18,12 @@ public void testIsRoot() throws Exception {
 		final StagemonitorPlugin.InitArguments initArguments = mock(StagemonitorPlugin.InitArguments.class);
 		when(initArguments.getMeasurementSession()).thenReturn(
 				new MeasurementSession("JaegerTracerFactoryTest", "test", "test"));
-		final Tracer tracer = new JaegerTracerFactory().getTracer(initArguments);
+		final JaegerTracerFactory jaegerTracerFactory = new JaegerTracerFactory();
+		final Tracer tracer = jaegerTracerFactory.getTracer(initArguments);
 		try (final Scope rootSpan = tracer.buildSpan("foo").startActive()) {
 			try (final Scope childSpan = tracer.buildSpan("bar").startActive()) {
-				assertThat(SpanUtils.isRoot(tracer, rootSpan.span())).isTrue();
-				assertThat(SpanUtils.isRoot(tracer, childSpan.span())).isFalse();
+				assertThat(jaegerTracerFactory.isRoot(rootSpan.span())).isTrue();
+				assertThat(jaegerTracerFactory.isRoot(childSpan.span())).isFalse();
 			}
 		}
 	}
diff --git a/stagemonitor-tracing-zipkin/src/main/java/org/stagemonitor/zipkin/BraveZipkinReportingTracerFactory.java b/stagemonitor-tracing-zipkin/src/main/java/org/stagemonitor/zipkin/BraveZipkinReportingTracerFactory.java
index c29f9ece..739e9b6c 100644
--- a/stagemonitor-tracing-zipkin/src/main/java/org/stagemonitor/zipkin/BraveZipkinReportingTracerFactory.java
+++ b/stagemonitor-tracing-zipkin/src/main/java/org/stagemonitor/zipkin/BraveZipkinReportingTracerFactory.java
@@ -5,13 +5,16 @@
 import org.stagemonitor.tracing.B3HeaderFormat;
 import org.stagemonitor.tracing.TracerFactory;
 import org.stagemonitor.tracing.TracingPlugin;
+import org.stagemonitor.tracing.wrapper.SpanWrapper;
 
 import java.util.concurrent.TimeUnit;
 
 import brave.Tracing;
+import brave.opentracing.BraveSpan;
 import brave.opentracing.BraveTracer;
 import brave.propagation.Propagation;
 import brave.sampler.Sampler;
+import io.opentracing.Span;
 import io.opentracing.Tracer;
 import zipkin.reporter.AsyncReporter;
 import zipkin.reporter.urlconnection.URLConnectionSender;
@@ -30,6 +33,32 @@ public Tracer getTracer(StagemonitorPlugin.InitArguments initArguments) {
 				.build();
 	}
 
+	@Override
+	public boolean isRoot(Span span) {
+		// TODO replace with Span#unwrap once https://github.com/opentracing/opentracing-java/pull/211 is merged
+		if (span instanceof SpanWrapper) {
+			span = ((SpanWrapper) span).getDelegate();
+		}
+		if (span instanceof BraveSpan) {
+			final BraveSpan braveSpan = (BraveSpan) span;
+			return braveSpan.unwrap().context().parentId() == null;
+		}
+		return false;
+	}
+
+	@Override
+	public boolean isSampled(Span span) {
+		// TODO replace with Span#unwrap once https://github.com/opentracing/opentracing-java/pull/211 is merged
+		if (span instanceof SpanWrapper) {
+			span = ((SpanWrapper) span).getDelegate();
+		}
+		if (span instanceof BraveSpan) {
+			final BraveSpan braveSpan = (BraveSpan) span;
+			return braveSpan.unwrap().context().sampled();
+		}
+		return false;
+	}
+
 	protected AlwaysSampler getSampler() {
 		return new AlwaysSampler();
 	}
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/SpanContextInformation.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/SpanContextInformation.java
index 738bd42d..f3648de9 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/SpanContextInformation.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/SpanContextInformation.java
@@ -127,10 +127,6 @@ public PostExecutionInterceptorContext getPostExecutionInterceptorContext() {
 		return postExecutionInterceptorContext;
 	}
 
-	public boolean isSampled() {
-		return spanWrapper.isSampled();
-	}
-
 	long getOverhead1() {
 		return overhead1;
 	}
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracerFactory.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracerFactory.java
index 6c452f0e..656f481a 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracerFactory.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracerFactory.java
@@ -3,6 +3,7 @@
 import org.stagemonitor.core.StagemonitorPlugin;
 import org.stagemonitor.core.StagemonitorSPI;
 
+import io.opentracing.Span;
 import io.opentracing.Tracer;
 
 /**
@@ -10,4 +11,16 @@
  */
 public abstract class TracerFactory implements StagemonitorSPI {
 	public abstract Tracer getTracer(StagemonitorPlugin.InitArguments initArguments);
+
+	/**
+	 * @deprecated remove once https://github.com/opentracing/specification/issues/91 is resolved
+	 */
+	@Deprecated
+	public abstract boolean isRoot(Span span);
+
+	/**
+	 * @deprecated remove once https://github.com/opentracing/specification/issues/92 is resolved
+	 */
+	@Deprecated
+	public abstract boolean isSampled(Span span);
 }
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracingPlugin.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracingPlugin.java
index c7de8f3c..dc7c1410 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracingPlugin.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/TracingPlugin.java
@@ -14,7 +14,7 @@
 import org.stagemonitor.core.metrics.metrics2.Metric2Registry;
 import org.stagemonitor.core.util.ExecutorUtils;
 import org.stagemonitor.tracing.anonymization.AnonymizingSpanEventListener;
-import org.stagemonitor.tracing.impl.DefaultTracerImpl;
+import org.stagemonitor.tracing.impl.DefaultTracerFactory;
 import org.stagemonitor.tracing.mdc.MDCSpanEventListener;
 import org.stagemonitor.tracing.metrics.MetricsSpanEventListener;
 import org.stagemonitor.tracing.profiler.CallTreeSpanEventListener;
@@ -361,6 +361,7 @@ public void assertValid(Map<String, Double> value) {
 	private SamplePriorityDeterminingSpanEventListener samplePriorityDeterminingSpanInterceptor;
 	private ReportingSpanEventListener reportingSpanEventListener;
 	private CorePlugin corePlugin;
+	private TracerFactory tracerFactory;
 
 	/**
 	 * @return the {@link Span} of the current request or a noop {@link Span} (never <code>null</code>)
@@ -400,7 +401,8 @@ public void initializePlugin(final StagemonitorPlugin.InitArguments initArgument
 		}
 
 		final Metric2Registry metricRegistry = initArguments.getMetricRegistry();
-		final Tracer tracer = getTracerImpl(initArguments);
+		tracerFactory = getTracerImpl();
+		final Tracer tracer = tracerFactory.getTracer(initArguments);
 		reportingSpanEventListener = new ReportingSpanEventListener(initArguments.getConfiguration());
 		for (SpanReporter spanReporter : ServiceLoader.load(SpanReporter.class, RequestMonitor.class.getClassLoader())) {
 			addReporter(spanReporter);
@@ -417,24 +419,24 @@ public void initializePlugin(final StagemonitorPlugin.InitArguments initArgument
 		return Collections.<Class<? extends StagemonitorPlugin>>singletonList(CorePlugin.class);
 	}
 
-	private Tracer getTracerImpl(InitArguments initArguments) {
+	private TracerFactory getTracerImpl() {
 		final Iterator<TracerFactory> tracerFactoryIterator = ServiceLoader.load(TracerFactory.class, RequestMonitor.class.getClassLoader()).iterator();
 		if (tracerFactoryIterator.hasNext()) {
-			final Tracer tracer = tracerFactoryIterator.next().getTracer(initArguments);
-			assertIsSingleImplementation(initArguments, tracerFactoryIterator, tracer);
-			return tracer;
+			final TracerFactory tracerFactory = tracerFactoryIterator.next();
+			assertIsSingleImplementation(tracerFactoryIterator, tracerFactory);
+			return tracerFactory;
 		} else {
 			logger.info("No OpenTracing implementation found. Falling back to DefaultTracerImpl. " +
 					"This is fine if you just want to use stagemonitor for development, for example with the in-browser-widget. " +
 					"If you want to report your traces to Elasticsearch, add a dependency to stagemonitor-tracing-elasticsearch. " +
 					"If you want to report to Zipkin, add stagemonitor-tracing-zipkin.");
-			return new DefaultTracerImpl();
+			return new DefaultTracerFactory();
 		}
 	}
 
-	private void assertIsSingleImplementation(InitArguments initArguments, Iterator<TracerFactory> tracerFactoryIterator, Tracer tracer) {
+	private void assertIsSingleImplementation(Iterator<TracerFactory> tracerFactoryIterator, TracerFactory tracer) {
 		if (tracerFactoryIterator.hasNext()) {
-			final Tracer tracer2 = tracerFactoryIterator.next().getTracer(initArguments);
+			final TracerFactory tracer2 = tracerFactoryIterator.next();
 			throw new IllegalStateException(MessageFormat.format("Multiple tracing implementations found: {0}, {1}. " +
 							"Make sure you only have one stagemonitor-tracing-* jar in your class path.",
 					tracer.getClass().getName(), tracer2.getClass().getName()));
@@ -470,6 +472,14 @@ public void registerWidgetMetricTabPlugins(WidgetMetricTabPluginsRegistry widget
 		widgetMetricTabPluginsRegistry.addWidgetMetricTabPlugin("/stagemonitor/static/tabs/metrics/request-metrics");
 	}
 
+	public boolean isRoot(Span span) {
+		return tracerFactory.isRoot(span);
+	}
+
+	public boolean isSampled(Span span) {
+		return tracerFactory.isSampled(span);
+	}
+
 	public RequestMonitor getRequestMonitor() {
 		if (requestMonitor == null) {
 			requestMonitor = new RequestMonitor(Stagemonitor.getConfiguration(), Stagemonitor.getMetric2Registry());
@@ -667,4 +677,9 @@ public boolean isTrackMetricsAsync() {
 	public AsciiCallTreeSignatureFormatter getCallTreeAsciiFormatter() {
 		return callTreeAsciiFormatter.getValue();
 	}
+
+	public void registerDefaultRateLimitSpansPercentChangeListener(ConfigurationOption.ChangeListener<Double> changeListener) {
+		defaultRateLimitSpansPercent.addChangeListener(changeListener);
+	}
+
 }
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerFactory.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerFactory.java
new file mode 100644
index 00000000..b3099350
--- /dev/null
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerFactory.java
@@ -0,0 +1,35 @@
+package org.stagemonitor.tracing.impl;
+
+import org.stagemonitor.core.StagemonitorPlugin;
+import org.stagemonitor.tracing.SpanContextInformation;
+import org.stagemonitor.tracing.TracerFactory;
+import org.stagemonitor.tracing.wrapper.SpanWrapper;
+
+import io.opentracing.Span;
+import io.opentracing.Tracer;
+import io.opentracing.tag.Tags;
+
+public class DefaultTracerFactory extends TracerFactory {
+	@Override
+	public Tracer getTracer(StagemonitorPlugin.InitArguments initArguments) {
+		return new DefaultTracerImpl();
+	}
+
+	@Override
+	public boolean isRoot(Span span) {
+		final SpanContextInformation contextInformation = SpanContextInformation.get(span);
+		if (contextInformation != null) {
+			return contextInformation.getParent() == null;
+		}
+		return true;
+	}
+
+	@Override
+	public boolean isSampled(Span span) {
+		if (span instanceof SpanWrapper) {
+			final Number samplingPrio = ((SpanWrapper) span).getNumberTag(Tags.SAMPLING_PRIORITY.getKey());
+			return !Integer.valueOf(0).equals(samplingPrio);
+		}
+		return false;
+	}
+}
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerImpl.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerImpl.java
index 2e128a30..46671c3c 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerImpl.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/impl/DefaultTracerImpl.java
@@ -7,12 +7,12 @@
 import io.opentracing.propagation.Format;
 import io.opentracing.util.ThreadLocalScopeManager;
 
-public class DefaultTracerImpl implements Tracer {
+class DefaultTracerImpl implements Tracer {
 
 	private final ScopeManager scopeManager = new ThreadLocalScopeManager();
 	private final Tracer tracer;
 
-	public DefaultTracerImpl() {
+	DefaultTracerImpl() {
 		tracer = NoopTracerFactory.create();
 	}
 
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListener.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListener.java
index 5f97416d..ed12b701 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListener.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListener.java
@@ -41,7 +41,7 @@ public void onChange(ConfigurationOption<?> configurationOption, Double oldValue
 	@Override
 	public void onStart(SpanWrapper spanWrapper) {
 		final SpanContextInformation contextInfo = SpanContextInformation.forSpan(spanWrapper);
-		if (spanWrapper.isSampled() && contextInfo.getPreExecutionInterceptorContext() != null) {
+		if (tracingPlugin.isSampled(spanWrapper) && contextInfo.getPreExecutionInterceptorContext() != null) {
 			determineIfEnableProfiler(spanWrapper, contextInfo);
 			if (!Profiler.isProfilingActive() && contextInfo.getPreExecutionInterceptorContext().isCollectCallTree()) {
 				contextInfo.setCallTree(Profiler.activateProfiling("total"));
@@ -71,7 +71,7 @@ public void onFinish(SpanWrapper spanWrapper, String operationName, long duratio
 		if (contextInfo.getCallTree() != null) {
 			try {
 				Profiler.stop();
-				if (spanWrapper.isSampled()) {
+				if (tracingPlugin.isSampled(spanWrapper)) {
 					determineIfExcludeCallTree(contextInfo);
 					if (isAddCallTreeToSpan(contextInfo, operationName)) {
 						addCallTreeToSpan(contextInfo, spanWrapper, operationName);
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/reporter/ReportingSpanEventListener.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/reporter/ReportingSpanEventListener.java
index 52e6f865..62109615 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/reporter/ReportingSpanEventListener.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/reporter/ReportingSpanEventListener.java
@@ -39,7 +39,7 @@ public ReportingSpanEventListener(ConfigurationRegistry configuration) {
 	@Override
 	public void onFinish(SpanWrapper spanWrapper, String operationName, long durationNanos) {
 		final SpanContextInformation info = SpanContextInformation.forSpan(spanWrapper);
-		if (spanWrapper.isSampled()) {
+		if (tracingPlugin.isSampled(spanWrapper)) {
 			try {
 				report(info, spanWrapper);
 			} catch (Exception e) {
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptor.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptor.java
index 558a74d3..ad91ced6 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptor.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptor.java
@@ -4,7 +4,6 @@
 import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.tracing.SpanContextInformation;
 import org.stagemonitor.tracing.TracingPlugin;
-import org.stagemonitor.tracing.utils.SpanUtils;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 
 import java.util.BitSet;
@@ -19,10 +18,11 @@
 	private BitSet defaultSampleDecisions;
 	private Map<String, BitSet> sampleDecisionsByType;
 	private AtomicInteger spanCounter = new AtomicInteger();
+	private TracingPlugin tracingPlugin;
 
 	@Override
 	public void init(ConfigurationRegistry configuration) {
-		TracingPlugin tracingPlugin = configuration.getConfig(TracingPlugin.class);
+		tracingPlugin = configuration.getConfig(TracingPlugin.class);
 
 		defaultSampleDecisions = getBitSet(tracingPlugin.getDefaultRateLimitSpansPercent());
 		setBitSetMap(tracingPlugin.getRateLimitSpansPerMinutePercentPerType());
@@ -62,7 +62,7 @@ public void interceptReport(PreExecutionInterceptorContext context) {
 	}
 
 	protected boolean isRoot(SpanWrapper span) {
-		return SpanUtils.isRoot(span);
+		return tracingPlugin.isRoot(span);
 	}
 
 	private boolean isSampled(BitSet sampleDecisions, AtomicInteger spanCounter) {
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptor.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptor.java
index 4f710ea8..c762b8b7 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptor.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptor.java
@@ -4,16 +4,16 @@
 import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.tracing.TracingPlugin;
 import org.stagemonitor.tracing.utils.RateLimiter;
-import org.stagemonitor.tracing.utils.SpanUtils;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 
 public class RateLimitingPreExecutionInterceptor extends PreExecutionSpanInterceptor {
 
 	private RateLimiter rateLimiter;
+	private TracingPlugin tracingPlugin;
 
 	@Override
 	public void init(ConfigurationRegistry configuration) {
-		TracingPlugin tracingPlugin = configuration.getConfig(TracingPlugin.class);
+		tracingPlugin = configuration.getConfig(TracingPlugin.class);
 
 		rateLimiter = getRateLimiter(tracingPlugin.getDefaultRateLimitSpansPerMinute());
 		tracingPlugin.getDefaultRateLimitSpansPerMinuteOption().addChangeListener(new ConfigurationOption.ChangeListener<Double>() {
@@ -55,7 +55,7 @@ public void interceptReport(PreExecutionInterceptorContext context) {
 	}
 
 	protected boolean isRoot(SpanWrapper span) {
-		return SpanUtils.isRoot(span);
+		return tracingPlugin.isRoot(span);
 	}
 
 	public static boolean isRateExceeded(RateLimiter rateLimiter) {
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListener.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListener.java
index 4a0eea79..0b6f237a 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListener.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListener.java
@@ -4,6 +4,7 @@
 import org.slf4j.LoggerFactory;
 import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.tracing.SpanContextInformation;
+import org.stagemonitor.tracing.TracingPlugin;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 import org.stagemonitor.tracing.wrapper.StatelessSpanEventListener;
 
@@ -21,6 +22,7 @@
 	private final Collection<PostExecutionSpanInterceptor> postInterceptors =
 			new CopyOnWriteArrayList<PostExecutionSpanInterceptor>();
 	private final ConfigurationRegistry configuration;
+	private final TracingPlugin tracingPlugin;
 
 	public SamplePriorityDeterminingSpanEventListener(ConfigurationRegistry configuration) {
 		this(configuration,
@@ -30,6 +32,7 @@ public SamplePriorityDeterminingSpanEventListener(ConfigurationRegistry configur
 
 	public SamplePriorityDeterminingSpanEventListener(ConfigurationRegistry configuration, Iterable<PreExecutionSpanInterceptor> preExecutionSpanInterceptors, Iterable<PostExecutionSpanInterceptor> postExecutionSpanInterceptors) {
 		this.configuration = configuration;
+		this.tracingPlugin = configuration.getConfig(TracingPlugin.class);
 		registerPreInterceptors(preExecutionSpanInterceptors);
 		registerPostInterceptors(postExecutionSpanInterceptors);
 	}
@@ -49,7 +52,7 @@ private void registerPostInterceptors(Iterable<PostExecutionSpanInterceptor> pos
 	@Override
 	public void onStart(SpanWrapper spanWrapper) {
 		final SpanContextInformation spanContext = SpanContextInformation.forSpan(spanWrapper);
-		if (!spanWrapper.isSampled()) {
+		if (!tracingPlugin.isSampled(spanWrapper)) {
 			return;
 		}
 
@@ -72,7 +75,7 @@ public void onStart(SpanWrapper spanWrapper) {
 	@Override
 	public void onFinish(SpanWrapper spanWrapper, String operationName, long durationNanos) {
 		final SpanContextInformation info = SpanContextInformation.forSpan(spanWrapper);
-		if (!spanWrapper.isSampled()) {
+		if (!tracingPlugin.isSampled(spanWrapper)) {
 			return;
 		}
 		PostExecutionInterceptorContext context = new PostExecutionInterceptorContext(info);
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/utils/SpanUtils.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/utils/SpanUtils.java
index 90e95a5e..524d560e 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/utils/SpanUtils.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/utils/SpanUtils.java
@@ -1,7 +1,6 @@
 package org.stagemonitor.tracing.utils;
 
 import org.stagemonitor.core.util.InetAddresses;
-import org.stagemonitor.tracing.B3HeaderFormat;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 
 import java.io.PrintWriter;
@@ -13,9 +12,7 @@
 import java.util.Map;
 
 import io.opentracing.Span;
-import io.opentracing.Tracer;
 import io.opentracing.tag.Tags;
-import io.opentracing.util.GlobalTracer;
 
 public class SpanUtils {
 
@@ -93,12 +90,4 @@ public static boolean isServerRequest(SpanWrapper spanWrapper) {
 		return Tags.SPAN_KIND_SERVER.equals(spanWrapper.getStringTag(Tags.SPAN_KIND.getKey()));
 	}
 
-	// TODO replace with Span#isRoot when https://github.com/opentracing/specification/issues/91 is resolved
-	public static boolean isRoot(Span span) {
-		return isRoot(GlobalTracer.get(), span);
-	}
-
-	public static boolean isRoot(Tracer tracer, Span span) {
-		return B3HeaderFormat.isRoot(tracer, span);
-	}
 }
diff --git a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/wrapper/SpanWrapper.java b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/wrapper/SpanWrapper.java
index c00e993b..f354e51b 100644
--- a/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/wrapper/SpanWrapper.java
+++ b/stagemonitor-tracing/src/main/java/org/stagemonitor/tracing/wrapper/SpanWrapper.java
@@ -6,7 +6,6 @@
 
 import io.opentracing.Span;
 import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
 
 /**
  * The purpose of this wrapper is to call the registered {@link SpanEventListener}s before certain methods of the
@@ -232,9 +231,4 @@ public double getDurationMs() {
 		return durationNanos / MILLISECOND_IN_NANOS;
 	}
 
-	public boolean isSampled() {
-		final Number samplingPriority = getNumberTag(Tags.SAMPLING_PRIORITY.getKey());
-		return samplingPriority == null || samplingPriority.intValue() > 0;
-	}
-
 }
diff --git a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListenerTest.java b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListenerTest.java
index c1f014ec..28322e01 100644
--- a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListenerTest.java
+++ b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/profiler/CallTreeSpanEventListenerTest.java
@@ -24,6 +24,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
@@ -32,10 +33,13 @@
 
 	private TracingPlugin tracingPlugin;
 	private SpanWrapper span;
+	private ConfigurationRegistry configurationRegistry;
 
 	@Before
 	public void setUp() throws Exception {
 		tracingPlugin = mock(TracingPlugin.class);
+		configurationRegistry = mock(ConfigurationRegistry.class);
+		when(configurationRegistry.getConfig(TracingPlugin.class)).thenReturn(tracingPlugin);
 
 		when(tracingPlugin.getProfilerRateLimitPerMinuteOption()).thenReturn(mock(ConfigurationOption.class));
 		when(tracingPlugin.isProfilerActive()).thenReturn(true);
@@ -82,6 +86,7 @@ private SpanContextInformation invokeEventListener() {
 	}
 
 	private SpanContextInformation invokeEventListener(boolean sampled) {
+		when(tracingPlugin.isSampled(any())).thenReturn(sampled);
 		SpanWrappingTracer spanWrappingTracer = initTracer();
 		final SpanWrappingTracer.SpanWrappingSpanBuilder spanBuilder = spanWrappingTracer.buildSpan("test");
 		spanBuilder.withTag(Tags.SAMPLING_PRIORITY.getKey(), sampled ? 1 : 0);
@@ -94,7 +99,6 @@ private SpanContextInformation invokeEventListener(boolean sampled) {
 	}
 
 	private SpanWrappingTracer initTracer() {
-		final ConfigurationRegistry configurationRegistry = mock(ConfigurationRegistry.class);
 		return new SpanWrappingTracer(new MockTracer(),
 				Arrays.asList(
 						new SpanContextInformation.SpanContextSpanEventListener(),
diff --git a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptorTest.java b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptorTest.java
index 4dbf43db..89399e88 100644
--- a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptorTest.java
+++ b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/ProbabilisticSamplingPreExecutionInterceptorTest.java
@@ -21,7 +21,10 @@
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
 public class ProbabilisticSamplingPreExecutionInterceptorTest {
@@ -35,7 +38,8 @@
 	@Before
 	public void setUp() throws Exception {
 		GlobalTracerTestHelper.resetGlobalTracer();
-		tracingPlugin = new TracingPlugin();
+		tracingPlugin = spy(new TracingPlugin());
+		doReturn(true).when(tracingPlugin).isRoot(any());
 		configuration = new ConfigurationRegistry(Collections.singletonList(tracingPlugin),
 				Collections.singletonList(new SimpleSource()),
 				null);
diff --git a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptorTest.java b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptorTest.java
index 91eba1e1..f15bfc46 100644
--- a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptorTest.java
+++ b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/RateLimitingPreExecutionInterceptorTest.java
@@ -17,7 +17,10 @@
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
 public class RateLimitingPreExecutionInterceptorTest {
@@ -31,7 +34,8 @@
 	@Before
 	public void setUp() throws Exception {
 		GlobalTracerTestHelper.resetGlobalTracer();
-		tracingPlugin = new TracingPlugin();
+		tracingPlugin = spy(new TracingPlugin());
+		doReturn(true).when(tracingPlugin).isRoot(any());
 		configuration = new ConfigurationRegistry(Collections.singletonList(tracingPlugin),
 				Collections.singletonList(new SimpleSource()),
 				null);
diff --git a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListenerTest.java b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListenerTest.java
index ed586a0a..a457bc42 100644
--- a/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListenerTest.java
+++ b/stagemonitor-tracing/src/test/java/org/stagemonitor/tracing/sampling/SamplePriorityDeterminingSpanEventListenerTest.java
@@ -7,11 +7,14 @@
 import io.opentracing.tag.Tags;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.when;
 
 public class SamplePriorityDeterminingSpanEventListenerTest extends AbstractRequestMonitorTest {
 
 	@Test
 	public void testSetSamplePrioInPreInterceptor() throws Exception {
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		samplePriorityDeterminingSpanInterceptor.addPreInterceptor(new PreExecutionSpanInterceptor() {
 			@Override
 			public void interceptReport(PreExecutionInterceptorContext context) {
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/MonitoredHttpRequest.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/MonitoredHttpRequest.java
index 5e5ccc6c..b775963b 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/MonitoredHttpRequest.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/MonitoredHttpRequest.java
@@ -109,7 +109,7 @@ public Scope createScope() {
 		SpanContextInformation info = SpanContextInformation.forSpan(span);
 		info.addRequestAttribute(CONNECTION_ID_ATTRIBUTE, connectionId);
 		info.addRequestAttribute(MONITORED_HTTP_REQUEST_ATTRIBUTE, this);
-		if (info.isSampled() && servletPlugin.isParseUserAgent() && StringUtils.isNotEmpty(userAgentHeader)) {
+		if (tracingPlugin.isSampled(span) && servletPlugin.isParseUserAgent() && StringUtils.isNotEmpty(userAgentHeader)) {
 			parseUserAgentAsync(span, info);
 		}
 		return scope;
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/ServletPlugin.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/ServletPlugin.java
index a48d9726..71ecdc35 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/ServletPlugin.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/ServletPlugin.java
@@ -20,7 +20,6 @@
 import org.stagemonitor.web.servlet.eum.ClientSpanMetadataTagProcessor.ClientSpanMetadataConverter;
 import org.stagemonitor.web.servlet.eum.ClientSpanMetadataTagProcessor.ClientSpanMetadataDefinition;
 import org.stagemonitor.web.servlet.eum.ClientSpanServlet;
-import org.stagemonitor.web.servlet.eum.WeaselClientSpanExtension;
 import org.stagemonitor.web.servlet.filter.HttpRequestMonitorFilter;
 import org.stagemonitor.web.servlet.filter.StagemonitorSecurityFilter;
 import org.stagemonitor.web.servlet.health.HealthCheckServlet;
@@ -212,10 +211,10 @@
 			.dynamic(true)
 			.label("Request Exception Attributes")
 			.description("Defines the list of attribute names to check on the HttpServletRequest when searching for an exception. \n\n" +
-			             "Stagemonitor searches this list in order to see if any of these attributes are set on the request with " +
+					"Stagemonitor searches this list in order to see if any of these attributes are set on the request with " +
 					"an Exception object and then records that information on the span. If your web framework " +
 					"sets a different attribute outside of the defaults, you can add that attribute to this list to properly " +
-					     "record the exception on the trace.")
+					"record the exception on the trace.")
 			.configurationCategory(WEB_PLUGIN)
 			.buildWithDefault(new LinkedHashSet<String>() {{
 				add("javax.servlet.error.exception");
@@ -277,6 +276,8 @@
 			.configurationCategory(WEB_PLUGIN)
 			.tags("advanced")
 			.buildWithDefault(5);
+	private ClientSpanJavaScriptServlet clientSpanJavaScriptServlet;
+	private List<ClientSpanExtension> clientSpanExtensions;
 
 	@Override
 	public void initializePlugin(StagemonitorPlugin.InitArguments initArguments) {
@@ -288,6 +289,7 @@ public void initializePlugin(StagemonitorPlugin.InitArguments initArguments) {
 			elasticsearchClient.sendClassPathRessourceBulkAsync("kibana/Application-Server.bulk", true);
 			grafanaClient.sendGrafanaDashboardAsync("grafana/ElasticsearchApplicationServer.json");
 		}
+		initClientSpanExtensions(initArguments.getConfiguration());
 	}
 
 	@Override
@@ -395,8 +397,8 @@ private boolean isPasswordInShowWidgetHeaderCorrect(HttpServletRequest request,
 		} else {
 			if (StringUtils.isNotEmpty(password)) {
 				logger.error("The password transmitted via the header {} is not correct. " +
-						"This might be a malicious attempt to guess the value of {}. " +
-						"The request was initiated from the ip {}.",
+								"This might be a malicious attempt to guess the value of {}. " +
+								"The request was initiated from the ip {}.",
 						STAGEMONITOR_SHOW_WIDGET, Stagemonitor.STAGEMONITOR_PASSWORD,
 						MonitoredHttpRequest.getClientIp(request));
 			}
@@ -422,35 +424,42 @@ public boolean isHonorDoNotTrackHeader() {
 
 	public Map<String, ClientSpanMetadataDefinition> getWhitelistedClientSpanTags() {
 		HashMap<String, ClientSpanMetadataDefinition> allWhitelistedClientSpanTags = new HashMap<String, ClientSpanMetadataDefinition>();
-		allWhitelistedClientSpanTags.putAll(getWhitelistedClientSpanTagsFromSPI());
+		allWhitelistedClientSpanTags.putAll(whitelistedClientSpanTagsFromSPI);
 		allWhitelistedClientSpanTags.putAll(whitelistedClientSpanTags.get());
 		return Collections.unmodifiableMap(allWhitelistedClientSpanTags);
 	}
 
-	private Map<String, ClientSpanMetadataDefinition> getWhitelistedClientSpanTagsFromSPI() {
-		if (whitelistedClientSpanTagsFromSPI == null) {
-			HashMap<String, ClientSpanMetadataDefinition> whitelistedTagsFromSPI = new HashMap<String, ClientSpanMetadataDefinition>();
-
-			for (ClientSpanExtension clientSpanExtension : getClientSpanExtenders()) {
-				final Map<String, ClientSpanMetadataDefinition> whitelistedTags = clientSpanExtension.getWhitelistedTags();
-				whitelistedTagsFromSPI.putAll(whitelistedTags);
-			}
-
-			this.whitelistedClientSpanTagsFromSPI = Collections.unmodifiableMap(whitelistedTagsFromSPI);
+	private void initClientSpanExtensions(ConfigurationRegistry config) {
+		List<ClientSpanExtension> clientSpanExtensions = new ArrayList<ClientSpanExtension>();
+		for (ClientSpanExtension clientSpanExtension : ServiceLoader.load(ClientSpanExtension.class)) {
+			clientSpanExtension.init(config);
+			clientSpanExtensions.add(clientSpanExtension);
 		}
+		this.clientSpanExtensions = clientSpanExtensions;
+		initWhiteListedClientSpanTags(clientSpanExtensions);
+	}
 
-		return whitelistedClientSpanTagsFromSPI;
+	private void initWhiteListedClientSpanTags(List<ClientSpanExtension> clientSpanExtensions) {
+		HashMap<String, ClientSpanMetadataDefinition> whitelistedTagsFromSPI = new HashMap<String, ClientSpanMetadataDefinition>();
+		for (ClientSpanExtension clientSpanExtension : clientSpanExtensions) {
+			final Map<String, ClientSpanMetadataDefinition> whitelistedTags = clientSpanExtension.getWhitelistedTags();
+			whitelistedTagsFromSPI.putAll(whitelistedTags);
+		}
+		this.whitelistedClientSpanTagsFromSPI = Collections.unmodifiableMap(whitelistedTagsFromSPI);
 	}
 
 	public List<ClientSpanExtension> getClientSpanExtenders() {
-		List<ClientSpanExtension> clientSpanExtensions = new ArrayList<ClientSpanExtension>();
-		for (ClientSpanExtension clientSpanExtension : ServiceLoader.load(ClientSpanExtension.class)) {
-			clientSpanExtensions.add(clientSpanExtension);
-		}
-		clientSpanExtensions.add(new WeaselClientSpanExtension(this));
 		return clientSpanExtensions;
 	}
 
+	private void setClientSpanJavaScriptServlet(ClientSpanJavaScriptServlet clientSpanJavaScriptServlet) {
+		this.clientSpanJavaScriptServlet = clientSpanJavaScriptServlet;
+	}
+
+	public ClientSpanJavaScriptServlet getClientSpanJavaScriptServlet() {
+		return clientSpanJavaScriptServlet;
+	}
+
 	public static class Initializer implements StagemonitorServletContainerInitializer {
 		@Override
 		public void onStartup(ServletContext ctx) {
@@ -462,7 +471,9 @@ public void onStartup(ServletContext ctx) {
 					.addMapping("/stagemonitor/metrics");
 			ctx.addServlet(ClientSpanServlet.class.getSimpleName(), new ClientSpanServlet())
 					.addMapping("/stagemonitor/public/eum");
-			ctx.addServlet(ClientSpanJavaScriptServlet.class.getSimpleName(), new ClientSpanJavaScriptServlet())
+			final ClientSpanJavaScriptServlet servlet = new ClientSpanJavaScriptServlet();
+			Stagemonitor.getPlugin(ServletPlugin.class).setClientSpanJavaScriptServlet(servlet);
+			ctx.addServlet(ClientSpanJavaScriptServlet.class.getSimpleName(), servlet)
 					.addMapping("/stagemonitor/public/eum.js");
 			ctx.addServlet(StagemonitorFileServlet.class.getSimpleName(), new StagemonitorFileServlet())
 					.addMapping("/stagemonitor/static/*", "/stagemonitor/public/static/*");
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanExtension.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanExtension.java
index b7adfef7..215bb046 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanExtension.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanExtension.java
@@ -1,5 +1,6 @@
 package org.stagemonitor.web.servlet.eum;
 
+import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.core.StagemonitorSPI;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 import org.stagemonitor.web.servlet.eum.ClientSpanMetadataTagProcessor.ClientSpanMetadataDefinition;
@@ -11,6 +12,9 @@
  */
 public abstract class ClientSpanExtension implements StagemonitorSPI {
 
+	public void init(ConfigurationRegistry config) {
+	}
+
 	/**
 	 * This method returns the script, which shall be included in the /stagemonitor/public/eum.js script bundle.
 	 *
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanJavaScriptServlet.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanJavaScriptServlet.java
index 5a6e9532..a35d5bc9 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanJavaScriptServlet.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanJavaScriptServlet.java
@@ -2,7 +2,6 @@
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.stagemonitor.configuration.ConfigurationOption;
 import org.stagemonitor.core.Stagemonitor;
 import org.stagemonitor.web.servlet.ServletPlugin;
 
@@ -15,7 +14,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
-public class ClientSpanJavaScriptServlet extends HttpServlet implements ConfigurationOption.ChangeListener<Boolean> {
+public class ClientSpanJavaScriptServlet extends HttpServlet {
 
 	private static final String MIME_APPLICATION_JAVASCRIPT = "application/javascript";
 	private static final String ETAG = "etag";
@@ -35,11 +34,10 @@ public ClientSpanJavaScriptServlet() {
 
 	public ClientSpanJavaScriptServlet(ServletPlugin servletPlugin) {
 		this.servletPlugin = servletPlugin;
-		servletPlugin.registerMinifyClientSpanScriptOptionChangedListener(this);
-		buildJavaScriptAndEtag();
+		rebuildJavaScriptAndEtag();
 	}
 
-	private void buildJavaScriptAndEtag() {
+	public void rebuildJavaScriptAndEtag() {
 		List<ClientSpanExtension> clientSpanExtensions = Stagemonitor.getPlugin(ServletPlugin.class).getClientSpanExtenders();
 		javaScript = concatenateJavaScript(clientSpanExtensions);
 		javaScriptEtag = generateEtag(javaScript);
@@ -47,7 +45,7 @@ private void buildJavaScriptAndEtag() {
 	}
 
 	private String generateEtag(String javaScript) {
-		return String.format("\"%d\"", javaScript.hashCode());
+		return String.format("\"%x\"", javaScript.hashCode());
 	}
 
 	private String concatenateJavaScript(List<ClientSpanExtension> clientSpanExtensions) {
@@ -90,9 +88,4 @@ private String getCacheControlMaxAge() {
 			return MAX_AGE + String.valueOf(TimeUnit.MINUTES.toSeconds(cachingDurationInMinutes));
 		}
 	}
-
-	@Override
-	public void onChange(ConfigurationOption<?> configurationOption, Boolean oldValue, Boolean newValue) {
-		buildJavaScriptAndEtag();
-	}
 }
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanServlet.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanServlet.java
index e38cd68d..76117d49 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanServlet.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/ClientSpanServlet.java
@@ -4,7 +4,6 @@
 import org.slf4j.LoggerFactory;
 import org.stagemonitor.core.Stagemonitor;
 import org.stagemonitor.tracing.B3HeaderFormat;
-import org.stagemonitor.tracing.SpanContextInformation;
 import org.stagemonitor.tracing.TracingPlugin;
 import org.stagemonitor.tracing.utils.SpanUtils;
 import org.stagemonitor.web.servlet.MonitoredHttpRequest;
@@ -33,7 +32,9 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static org.stagemonitor.tracing.B3IdentifierTagger.SPAN_ID;
 import static org.stagemonitor.tracing.B3IdentifierTagger.TRACE_ID;
+import static org.stagemonitor.web.servlet.eum.ClientSpanTagProcessor.TYPE_ALL;
 import static org.stagemonitor.web.servlet.eum.WeaselClientSpanExtension.METADATA_BACKEND_SPAN_ID;
+import static org.stagemonitor.web.servlet.eum.WeaselClientSpanExtension.METADATA_BACKEND_SPAN_SAMPLING_FLAG;
 import static org.stagemonitor.web.servlet.eum.WeaselSpanTags.TIMING_APP_CACHE_LOOKUP;
 import static org.stagemonitor.web.servlet.eum.WeaselSpanTags.TIMING_DNS_LOOKUP;
 import static org.stagemonitor.web.servlet.eum.WeaselSpanTags.TIMING_LOAD;
@@ -60,6 +61,8 @@
 	private static final String ACCESS_CONTROL_ALLOW_ORIGIN = "Access-Control-Allow-Origin";
 	private static final String ACCESS_CONTROL_ALLOW_METHODS = "Access-Control-Allow-Methods";
 	private static final Logger logger = LoggerFactory.getLogger(ClientSpanServlet.class);
+	private static final String SAMPLED_FLAG = "sp";
+	private static final String BACKEND_TRACE_ID = "bt";
 
 	private final TracingPlugin tracingPlugin;
 	private final List<ClientSpanTagProcessor> tagProcessors;
@@ -106,15 +109,23 @@ private void initializeDefaultTagProcessors() {
 		addTagProcessor(new ClientSpanBooleanTagProcessor(TYPE_XHR, "xhr.async", "a"));
 		addTagProcessor(durationProcessor(TYPE_XHR, "duration_ms", "d"));
 		// The OT-API does not allow to set the SpanContext for the current span, so just set the ids as tags
-		addTagProcessor(new ClientSpanStringTagProcessor(ClientSpanTagProcessor.TYPE_ALL, SPAN_ID, "s", false));
-		addTagProcessor(new ClientSpanStringTagProcessor(ClientSpanTagProcessor.TYPE_ALL, TRACE_ID, "t", false));
+		// TODO change to SELF reference when https://github.com/opentracing/opentracing-java/pull/212 is merged
+		addTagProcessor(new ClientSpanStringTagProcessor(TYPE_ALL, SPAN_ID, "s", false));
+		addTagProcessor(new ClientSpanStringTagProcessor(TYPE_ALL, TRACE_ID, "t", false));
+		addTagProcessor(new ClientSpanLongTagProcessor(TYPE_ALL, Tags.SAMPLING_PRIORITY.getKey(), SAMPLED_FLAG)
+				.lowerBound(0)
+				.upperBound(1));
+		// sets the same sampling decision as the backend trace (does not work for standalone EUM servers)
+		addTagProcessor(new ClientSpanLongTagProcessor(TYPE_PAGE_LOAD, Tags.SAMPLING_PRIORITY.getKey(), METADATA_BACKEND_SPAN_SAMPLING_FLAG)
+				.lowerBound(0)
+				.upperBound(1));
 		// bt = backend trace id
-		addTagProcessor(new ClientSpanStringTagProcessor(TYPE_PAGE_LOAD, TRACE_ID, "bt", false));
-		addTagProcessor(new ClientSpanTagProcessor(TYPE_PAGE_LOAD, Arrays.asList("bt", METADATA_BACKEND_SPAN_ID)) {
+		addTagProcessor(new ClientSpanStringTagProcessor(TYPE_PAGE_LOAD, TRACE_ID, BACKEND_TRACE_ID, false));
+		addTagProcessor(new ClientSpanTagProcessor(TYPE_PAGE_LOAD, Arrays.asList(BACKEND_TRACE_ID, METADATA_BACKEND_SPAN_ID)) {
 			@Override
 			protected void processSpanImpl(Span span, Map<String, String[]> requestParameters) {
 				final B3HeaderFormat.B3Identifiers backendSpanIds = B3HeaderFormat.B3Identifiers.builder()
-						.traceId(getParameterValueOrNull("bt", requestParameters))
+						.traceId(getParameterValueOrNull(BACKEND_TRACE_ID, requestParameters))
 						.spanId(getParameterValueOrNull(METADATA_BACKEND_SPAN_ID, requestParameters))
 						.build();
 				final String pageloadSpanId = B3HeaderFormat.getB3Identifiers(tracingPlugin.getTracer(), span).getSpanId();
@@ -203,11 +214,13 @@ void convertWeaselBeaconToSpan(HttpServletRequest httpServletRequest) {
 		}
 
 		final Span span = spanBuilder.startManual();
-		if (SpanContextInformation.forSpan(span).isSampled()) {
+		if (tracingPlugin.isSampled(span)) {
 			for (ClientSpanTagProcessor tagProcessor : tagProcessors) {
 				tagProcessor.processSpan(span, servletParameters);
 			}
+		}
 
+		if (tracingPlugin.isSampled(span)) {
 			if (servletPlugin.isParseUserAgent()) {
 				if (userAgentParser == null) {
 					userAgentParser = new UserAgentParser();
@@ -233,10 +246,10 @@ private String getOperationName(HttpServletRequest httpServletRequest) {
 
 	private String getHttpUrl(HttpServletRequest httpServletRequest) {
 		String operationName;
-		if (httpServletRequest.getParameter(PARAMETER_LOCATION) != null) {
-			operationName = httpServletRequest.getParameter(PARAMETER_LOCATION);
-		} else {
+		if (httpServletRequest.getParameter(PARAMETER_URL) != null) {
 			operationName = httpServletRequest.getParameter(PARAMETER_URL);
+		} else {
+			operationName = httpServletRequest.getParameter(PARAMETER_LOCATION);
 		}
 		return operationName;
 	}
diff --git a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/WeaselClientSpanExtension.java b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/WeaselClientSpanExtension.java
index dcda847c..94572f8e 100644
--- a/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/WeaselClientSpanExtension.java
+++ b/stagemonitor-web-servlet/src/main/java/org/stagemonitor/web/servlet/eum/WeaselClientSpanExtension.java
@@ -1,6 +1,9 @@
 package org.stagemonitor.web.servlet.eum;
 
+import org.stagemonitor.configuration.ConfigurationOption;
+import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.tracing.B3HeaderFormat;
+import org.stagemonitor.tracing.TracingPlugin;
 import org.stagemonitor.tracing.wrapper.SpanWrapper;
 import org.stagemonitor.util.IOUtils;
 import org.stagemonitor.web.servlet.ServletPlugin;
@@ -13,21 +16,46 @@
 
 public class WeaselClientSpanExtension extends ClientSpanExtension {
 
-	static final String METADATA_BACKEND_SPAN_ID = REQUEST_PARAMETER_METADATA_PREFIX + WeaselClientSpanExtension.BACKEND_SPAN_ID;
 	private static final String BACKEND_SPAN_ID = "bs";
-	private final ServletPlugin servletPlugin;
+	static final String METADATA_BACKEND_SPAN_ID = REQUEST_PARAMETER_METADATA_PREFIX + BACKEND_SPAN_ID;
+	private static final String BACKEND_SPAN_SAMPLING_FLAG = "bsp";
+	static final String METADATA_BACKEND_SPAN_SAMPLING_FLAG = REQUEST_PARAMETER_METADATA_PREFIX + BACKEND_SPAN_SAMPLING_FLAG;
+	private ServletPlugin servletPlugin;
+	private TracingPlugin tracingPlugin;
+
+	@Override
+	public void init(ConfigurationRegistry config) {
+		this.servletPlugin = config.getConfig(ServletPlugin.class);
+		tracingPlugin = config.getConfig(TracingPlugin.class);
+		servletPlugin.registerMinifyClientSpanScriptOptionChangedListener(new ConfigurationOption.ChangeListener<Boolean>() {
+			@Override
+			public void onChange(ConfigurationOption<?> configurationOption, Boolean oldValue, Boolean newValue) {
+				if (servletPlugin.getClientSpanJavaScriptServlet() != null) {
+					servletPlugin.getClientSpanJavaScriptServlet().rebuildJavaScriptAndEtag();
+				}
+			}
+		});
+		tracingPlugin.registerDefaultRateLimitSpansPercentChangeListener(new ConfigurationOption.ChangeListener<Double>() {
+			@Override
+			public void onChange(ConfigurationOption<?> configurationOption, Double oldValue, Double newValue) {
+				if (servletPlugin.getClientSpanJavaScriptServlet() != null) {
+					servletPlugin.getClientSpanJavaScriptServlet().rebuildJavaScriptAndEtag();
+				}
+			}
+		});
 
-	public WeaselClientSpanExtension(ServletPlugin servletPlugin) {
-		this.servletPlugin = servletPlugin;
 	}
 
 	@Override
 	public String getClientTraceExtensionScriptStaticPart() {
+		String eumJs;
 		if (servletPlugin.getMinifyClientSpanScript()) {
-			return IOUtils.getResourceAsString("eum.debug.js");
+			eumJs = IOUtils.getResourceAsString("eum.debug.js");
 		} else {
-			return IOUtils.getResourceAsString("eum.min.js");
+			eumJs = IOUtils.getResourceAsString("eum.min.js");
 		}
+		eumJs += "\nineum('sampleRate', " + tracingPlugin.getDefaultRateLimitSpansPercent() + ")";
+		return eumJs;
 	}
 
 	@Override
@@ -38,7 +66,8 @@ public String getClientTraceExtensionScriptStaticPart() {
 	@Override
 	public String getClientTraceExtensionScriptDynamicPart(SpanWrapper spanWrapper) {
 		final B3HeaderFormat.B3Identifiers b3Identifiers = B3HeaderFormat.getB3Identifiers(spanWrapper);
-		return "ineum('traceId', '" + b3Identifiers.getTraceId() + "');\n"
-				+ "  ineum('meta', '" + BACKEND_SPAN_ID + "', '" + b3Identifiers.getSpanId() + "');\n";
+		return "ineum('traceId', '" + b3Identifiers.getTraceId() + "');\n" +
+				"ineum('meta', '" + BACKEND_SPAN_SAMPLING_FLAG + "', '" + (tracingPlugin.isSampled(spanWrapper) ? 1 : 0) + "');\n" +
+				"ineum('meta', '" + BACKEND_SPAN_ID + "', '" + b3Identifiers.getSpanId() + "');\n";
 	}
 }
diff --git a/stagemonitor-web-servlet/src/main/resources/META-INF/services/org.stagemonitor.web.servlet.eum.ClientSpanExtension b/stagemonitor-web-servlet/src/main/resources/META-INF/services/org.stagemonitor.web.servlet.eum.ClientSpanExtension
new file mode 100644
index 00000000..6c08de06
--- /dev/null
+++ b/stagemonitor-web-servlet/src/main/resources/META-INF/services/org.stagemonitor.web.servlet.eum.ClientSpanExtension
@@ -0,0 +1 @@
+org.stagemonitor.web.servlet.eum.WeaselClientSpanExtension
diff --git a/stagemonitor-web-servlet/src/main/resources/eum.debug.js b/stagemonitor-web-servlet/src/main/resources/eum.debug.js
index c43466b2..e64d9b92 100644
--- a/stagemonitor-web-servlet/src/main/resources/eum.debug.js
+++ b/stagemonitor-web-servlet/src/main/resources/eum.debug.js
@@ -1,892 +1,1206 @@
 (function () {
-	'use strict';
+'use strict';
 
-	var win = window;
-	var encodeURIComponent = win.encodeURIComponent;
-	var OriginalXMLHttpRequest = win.XMLHttpRequest;
+var win = window;
+var encodeURIComponent = win.encodeURIComponent;
+var OriginalXMLHttpRequest = win.XMLHttpRequest;
 
 // aliasing the global function for improved minification and
 // protection against hasOwnProperty overrides.
-	var globalHasOwnProperty = Object.prototype.hasOwnProperty;
+var globalHasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwnProperty(obj, key) {
+  return globalHasOwnProperty.call(obj, key);
+}
 
-	function hasOwnProperty(obj, key) {
-		return globalHasOwnProperty.call(obj, key);
-	}
+function now() {
+  return new Date().getTime();
+}
 
-	function now() {
-		return new Date().getTime();
-	}
-
-	function noop() {
-	}
+function noop() {}
 
 // We are trying to stay close to common tracing architectures and use
 // a hex encoded 64 bit random ID.
-	var validIdCharacters = '0123456789abcdef'.split('');
-	var generateUniqueIdImpl$1 = function generateUniqueIdViaRandom() {
-		var result = '';
-		for (var i = 0; i < 16; i++) {
-			result += validIdCharacters[Math.round(Math.random() * 15)];
-		}
-		return result;
-	};
-
-	if (win.crypto && win.crypto.getRandomValues && win.Uint32Array) {
-		generateUniqueIdImpl$1 = function generateUniqueIdViaCrypto() {
-			var array = new win.Uint32Array(2);
-			win.crypto.getRandomValues(array);
-			return array[0].toString(16) + array[1].toString(16);
-		};
-	}
-
-	var generateUniqueId = generateUniqueIdImpl$1;
-
-	function addEventListener(target, eventType, callback) {
-		if (target.addEventListener) {
-			target.addEventListener(eventType, callback, false);
-		} else if (target.attachEvent) {
-			target.attachEvent('on' + eventType, callback);
-		}
-	}
-
-	var bus = {};
-
-	function on(name, fn) {
-		var listeners = bus[name] = bus[name] || [];
-		listeners.push(fn);
-	}
-
-	function emit(name, value) {
-		var listeners = bus[name];
-		if (!listeners) {
-			return;
-		}
-		for (var i = 0, length = listeners.length; i < length; i++) {
-			listeners[i](value);
-		}
-	}
-
-	var event = {
-		name: 'e:onLoad',
-		time: null,
-		initialize: function () {
-			if (document.readyState === 'complete') {
-				return onReady();
-			}
-			addEventListener(win, 'load', function () {
-				// we want to get timing data for loadEventEnd,
-				// so asynchronously process this
-				setTimeout(onReady, 0);
-			});
-		}
-	};
-
-	function onReady() {
-		event.time = now();
-		emit(event.name, event.time);
-	}
-
-	/* eslint-disable no-console */
-
-	var info = createLogger('info');
-	var warn = createLogger('warn');
-	var error = createLogger('error');
-	var debug = createLogger('debug');
-
-	function createLogger(method) {
-		if (typeof console === 'undefined') {
-			return noop;
-		} else if (!console[method]) {
-			return function () {
-				console.log.apply(console, arguments);
-			};
-		}
-
-		return function () {
-			console[method].apply(console, arguments);
-		};
-	}
-
-	var states = {};
-	var currentStateName = void 0;
-
-	function registerState(name, impl) {
-		states[name] = impl;
-	}
-
-	function transitionTo(nextStateName) {
-		{
-			info('Transitioning from %s to %s', currentStateName || '<no state>', nextStateName);
-		}
-
-		currentStateName = nextStateName;
-		states[nextStateName].onEnter();
-	}
-
-	function getActiveTraceId() {
-		return states[currentStateName].getActiveTraceId();
-	}
+var validIdCharacters = '0123456789abcdef'.split('');
+var generateUniqueIdImpl$1 = function generateUniqueIdViaRandom() {
+  var result = '';
+  for (var i = 0; i < 16; i++) {
+    result += validIdCharacters[Math.round(Math.random() * 15)];
+  }
+  return result;
+};
+
+if (win.crypto && win.crypto.getRandomValues && win.Uint32Array) {
+  generateUniqueIdImpl$1 = function generateUniqueIdViaCrypto() {
+    var array = new win.Uint32Array(2);
+    win.crypto.getRandomValues(array);
+    return array[0].toString(16) + array[1].toString(16);
+  };
+}
+
+var generateUniqueId = generateUniqueIdImpl$1;
+
+function addEventListener(target, eventType, callback) {
+  if (target.addEventListener) {
+    target.addEventListener(eventType, callback, false);
+  } else if (target.attachEvent) {
+    target.attachEvent('on' + eventType, callback);
+  }
+}
+
+var bus = {};
+
+function on(name, fn) {
+  var listeners = bus[name] = bus[name] || [];
+  listeners.push(fn);
+}
+
+
+
+function emit(name, value) {
+  var listeners = bus[name];
+  if (!listeners) {
+    return;
+  }
+  for (var i = 0, length = listeners.length; i < length; i++) {
+    listeners[i](value);
+  }
+}
+
+var event = {
+  name: 'e:onLoad',
+  time: null,
+  initialize: function () {
+    if (document.readyState === 'complete') {
+      return onReady();
+    }
+    addEventListener(win, 'load', function () {
+      // we want to get timing data for loadEventEnd,
+      // so asynchronously process this
+      setTimeout(onReady, 0);
+    });
+  }
+};
+
+function onReady() {
+  event.time = now();
+  emit(event.name, event.time);
+}
+
+/* eslint-disable no-console */
+
+
+var info = createLogger('info');
+var warn = createLogger('warn');
+var error = createLogger('error');
+var debug = createLogger('debug');
+
+function createLogger(method) {
+  if (typeof console === 'undefined') {
+    return noop;
+  } else if (!console[method]) {
+    return function () {
+      console.log.apply(console, arguments);
+    };
+  }
+
+  return function () {
+    console[method].apply(console, arguments);
+  };
+}
+
+var states = {};
+var currentStateName = void 0;
+
+function registerState(name, impl) {
+  states[name] = impl;
+}
+
+function transitionTo(nextStateName) {
+  {
+    info('Transitioning from %s to %s', currentStateName || '<no state>', nextStateName);
+  }
+
+  currentStateName = nextStateName;
+  states[nextStateName].onEnter();
+}
+
+function getActiveTraceId() {
+  return states[currentStateName].getActiveTraceId();
+}
+
+function triggerManualPageLoad() {
+  return states[currentStateName].triggerManualPageLoad();
+}
+
+function startSpaPageTransition() {
+  return states[currentStateName].startSpaPageTransition();
+}
+
+function endSpaPageTransition(opts) {
+  return states[currentStateName].endSpaPageTransition(opts);
+}
 
 // a wrapper around win.performance for cross-browser support
-	var performance = win.performance || win.webkitPerformance || win.msPerformance || win.mozPerformance;
-
-	var isTimingAvailable = performance && performance.timing;
-	var isResourceTimingAvailable = performance && performance.getEntriesByType;
-
-	var defaultVars = {
-		nameOfLongGlobal: 'EumObject',
-		pageLoadTraceId: generateUniqueId(),
-		pageLoadBackendTraceId: null,
-		referenceTimestamp: now(),
-		highResTimestampReference: performance && performance.now ? performance.now() : 0,
-		initializerExecutionTimestamp: now(),
-		reportingUrl: null,
-		apiKey: null,
-		meta: {},
-		ignoreUrls: []
-	};
-
-	var state = {
-		onEnter: function () {
-			on(event.name, onLoad);
-			event.initialize();
-		},
-		getActiveTraceId: function () {
-			return defaultVars.pageLoadTraceId;
-		}
-	};
-
-	function onLoad() {
-		transitionTo('pageLoaded');
-	}
-
-// See spec:
-// https://www.w3.org/TR/navigation-timing/
-
-	function addTimingToPageLoadBeacon(beacon) {
-		if (!isTimingAvailable) {
-			// This is our absolute fallback mode where we only have
-			// approximations for speed information.
-			beacon['ts'] = defaultVars.initializerExecutionTimestamp - defaultVars.referenceTimestamp;
-			beacon['d'] = Number(event.time) - defaultVars.initializerExecutionTimestamp;
-
-			// We add this as an extra property to the beacon so that
-			// a backend can decide whether it should include timing
-			// information in aggregated metrics. Since they are only
-			// approximations, this is not always desirable.
-			if (!isTimingAvailable) {
-				beacon['tim'] = '0';
-			}
-
-			return;
-		}
-
-		var timing = performance.timing;
-
-		var redirectTime = timing.redirectEnd - timing.redirectStart;
-		// We don't use navigationStart since that includes unload times for the previous
-		// page.
-		var start = timing.fetchStart - redirectTime;
-		beacon['ts'] = start - defaultVars.referenceTimestamp;
-
-		// This can happen when the user aborts the page load. In this case, the load event
-		// timing information is not available and will have the default value of "0".
-		if (timing.loadEventStart > 0) {
-			beacon['d'] = timing.loadEventStart - timing.fetchStart;
-		} else {
-			beacon['d'] = Number(event.time) - defaultVars.initializerExecutionTimestamp;
-
-			// We have partial timing information, but since the load was aborted, we will
-			// mark it as missing to indicate that the information should be ignored in
-			// statistics.
-			beacon['tim'] = '0';
-		}
-
-		beacon['t_unl'] = timing.unloadEventEnd - timing.unloadEventStart;
-		beacon['t_red'] = redirectTime;
-		beacon['t_apc'] = timing.domainLookupStart - timing.fetchStart;
-		beacon['t_dns'] = timing.domainLookupEnd - timing.domainLookupStart;
-		beacon['t_tcp'] = timing.connectEnd - timing.connectStart;
-		beacon['t_req'] = timing.responseStart - timing.requestStart;
-		beacon['t_rsp'] = timing.responseEnd - timing.responseStart;
-		beacon['t_pro'] = timing.loadEventStart - timing.responseEnd;
-		beacon['t_loa'] = timing.loadEventEnd - timing.loadEventStart;
-
-		addFirstPaintTime(beacon, start);
-	}
-
-	function addFirstPaintTime(beacon, start) {
-		var firstPaint = null;
-
-		// Chrome
-		if (win.chrome && win.chrome.loadTimes) {
-			// Convert to ms
-			firstPaint = win.chrome.loadTimes().firstPaintTime * 1000;
-		}
-		// IE
-		else if (typeof win.performance.timing.msFirstPaint === 'number') {
-			firstPaint = win.performance.timing.msFirstPaint;
-		}
-		// standard
-		else if (typeof win.performance.timing.firstPaint === 'number') {
-			firstPaint = win.performance.timing.firstPaint;
-		}
-
-		// First paint may not be available -OR- the browser may have never
-		// painted anything and thereby kept this value at 0.
-		if (firstPaint != null && firstPaint !== 0) {
-			beacon['t_fp'] = Math.round(firstPaint - start);
-		}
-	}
-
-	var INTERNAL_END_MARKER = '<END>';
-
-	function createTrie() {
-		return new Trie();
-	}
-
-	function Trie() {
-		this.root = {};
-	}
-
-	Trie.prototype.addItem = function addItem(key, value) {
-		this.insertItem(this.root, key.split(''), 0, value);
-		return this;
-	};
-
-	Trie.prototype.insertItem = function insertItem(node, keyCharacters, keyCharacterIndex, value) {
-		var character = keyCharacters[keyCharacterIndex];
-		// Characters exhausted, add value to node
-		if (character == null) {
-			var values = node[INTERNAL_END_MARKER] = node[INTERNAL_END_MARKER] || [];
-			values.push(value);
-			return;
-		}
-
-		var nextNode = node[character] = node[character] || {};
-		this.insertItem(nextNode, keyCharacters, keyCharacterIndex + 1, value);
-	};
-
-	Trie.prototype.toJs = function toJs(node) {
-		node = node || this.root;
-
-		var keys = getKeys(node);
-		if (keys.length === 1 && keys[0] === INTERNAL_END_MARKER) {
-			return node[INTERNAL_END_MARKER].slice();
-		}
-
-		var result = {};
-
-		for (var i = 0, length = keys.length; i < length; i++) {
-			var key = keys[i];
-			var value = node[key];
-			if (key === INTERNAL_END_MARKER) {
-				result['$'] = value.slice();
-				continue;
-			}
-
-			var combinedKeys = key;
-			var child = node[key];
-			var childKeys = getKeys(child);
-			while (childKeys.length === 1 && childKeys[0] !== INTERNAL_END_MARKER) {
-				combinedKeys += childKeys[0];
-				child = child[childKeys[0]];
-				childKeys = getKeys(child);
-			}
-
-			result[combinedKeys] = this.toJs(child);
-		}
-
-		return result;
-	};
-
-	function getKeys(obj) {
-		var result = [];
-
-		for (var key in obj) {
-			if (hasOwnProperty(obj, key)) {
-				result.push(key);
-			}
-		}
-
-		return result;
-	}
+var performance = win.performance || win.webkitPerformance || win.msPerformance || win.mozPerformance;
+
+var isTimingAvailable = performance && performance.timing;
+var isResourceTimingAvailable = performance && performance.getEntriesByType;
+
+var defaultVars = {
+  nameOfLongGlobal: 'EumObject',
+  pageLoadTraceId: generateUniqueId(),
+  pageLoadBackendTraceId: null,
+  referenceTimestamp: now(),
+  highResTimestampReference: performance && performance.now ? performance.now() : 0,
+  initializerExecutionTimestamp: now(),
+  reportingUrl: null,
+  apiKey: null,
+  meta: {},
+  ignoreUrls: [],
+  ignorePings: true,
+  xhrTransmissionTimeout: 20000,
+  manualPageLoadEvent: false,
+  manualPageLoadTriggered: false,
+  autoClearResourceTimings: true,
+  page: undefined,
+  sampleRate: 1
+};
+
+var state = {
+  onEnter: function () {
+    if (!defaultVars.manualPageLoadEvent || defaultVars.manualPageLoadTriggered) {
+      on(event.name, onLoad);
+      event.initialize();
+    }
+  },
+  getActiveTraceId: function () {
+    return defaultVars.pageLoadTraceId;
+  },
+
+
+  triggerManualPageLoad: onLoad,
+
+  startSpaPageTransition: function () {
+    {
+      warn('Cannot start an SPA page transition until the page is considered loaded.');
+    }
+  },
+
+
+  /* eslint-disable no-unused-vars */
+  endSpaPageTransition: function (opts) {
+    /* eslint-enable no-unused-vars */
+    {
+      warn('No pending SPA page transition to end. Waiting for page load instead.');
+    }
+  }
+};
+function onLoad() {
+  transitionTo('pageLoaded');
+}
+
+var INTERNAL_END_MARKER = '<END>';
+
+function createTrie() {
+  return new Trie();
+}
+
+function Trie() {
+  this.root = {};
+}
+
+Trie.prototype.addItem = function addItem(key, value) {
+  this.insertItem(this.root, key.split(''), 0, value);
+  return this;
+};
+
+Trie.prototype.insertItem = function insertItem(node, keyCharacters, keyCharacterIndex, value) {
+  var character = keyCharacters[keyCharacterIndex];
+  // Characters exhausted, add value to node
+  if (character == null) {
+    var values = node[INTERNAL_END_MARKER] = node[INTERNAL_END_MARKER] || [];
+    values.push(value);
+    return;
+  }
+
+  var nextNode = node[character] = node[character] || {};
+  this.insertItem(nextNode, keyCharacters, keyCharacterIndex + 1, value);
+};
+
+Trie.prototype.toJs = function toJs(node) {
+  node = node || this.root;
+
+  var keys = getKeys(node);
+  if (keys.length === 1 && keys[0] === INTERNAL_END_MARKER) {
+    return node[INTERNAL_END_MARKER].slice();
+  }
+
+  var result = {};
+
+  for (var i = 0, length = keys.length; i < length; i++) {
+    var key = keys[i];
+    var value = node[key];
+    if (key === INTERNAL_END_MARKER) {
+      result['$'] = value.slice();
+      continue;
+    }
+
+    var combinedKeys = key;
+    var child = node[key];
+    var childKeys = getKeys(child);
+    while (childKeys.length === 1 && childKeys[0] !== INTERNAL_END_MARKER) {
+      combinedKeys += childKeys[0];
+      child = child[childKeys[0]];
+      childKeys = getKeys(child);
+    }
+
+    result[combinedKeys] = this.toJs(child);
+  }
+
+  return result;
+};
+
+function getKeys(obj) {
+  var result = [];
+
+  for (var key in obj) {
+    if (hasOwnProperty(obj, key)) {
+      result.push(key);
+    }
+  }
+
+  return result;
+}
 
 // See https://w3c.github.io/resource-timing/
 // See https://www.w3.org/TR/hr-time/
 
-	var urlMaxLength = 255;
-
-	var initiatorTypes = {
-		'other': 0,
-		'img': 1,
-		'link': 2,
-		'script': 3,
-		'css': 4,
-		'xmlhttprequest': 5,
-		'html': 6,
-		// IMAGE element inside a SVG
-		'image': 7
-	};
-
-	var cachingTypes = {
-		unknown: 0,
-		cached: 1,
-		validated: 2,
-		fullLoad: 3
-	};
-
-	function addResourceTimings(beacon) {
-		if (isResourceTimingAvailable && win.JSON) {
-			var entries = getEntriesTransferFormat(performance.getEntriesByType('resource'));
-			beacon['res'] = win.JSON.stringify(entries);
-		} else {
-			info('Resource timing not supported.');
-		}
-	}
-
-	function getEntriesTransferFormat(performanceEntries) {
-		var trie = createTrie();
-
-		for (var i = 0, len = performanceEntries.length; i < len; i++) {
-			var entry = performanceEntries[i];
-
-			var url = entry.name;
-			if (url.length > urlMaxLength) {
-				url = url.substring(0, urlMaxLength);
-			}
-
-			// We provide more detailed XHR insights via our XHR instrumentation.
-			// The XHR instrumentation is available once the initialization was executed
-			// (which is completely synchronous).
-			if (entry['initiatorType'] !== 'xmlhttprequest' || entry['startTime']
-															   < defaultVars.highResTimestampReference) {
-				trie.addItem(url, serializeEntry(entry));
-			}
-		}
-
-		return trie.toJs();
-	}
-
-	function serializeEntry(entry) {
-		var result = [Math.round(entry['startTime'] - defaultVars.highResTimestampReference),
-					  Math.round(entry['duration']), initiatorTypes[entry['initiatorType']] || initiatorTypes['other']];
-
-		// When timing data is available, we can provide additional information about
-		// caching and resource sizes.
-		if (typeof entry['transferSize'] === 'number' && typeof entry['encodedBodySize'] === 'number' &&
-			// All this information may not be available due to cross-origin.
-			entry['encodedBodySize'] > 0) {
-			if (entry['transferSize'] === 0) {
-				result.push(cachingTypes.cached);
-			} else if (entry['transferSize'] < entry['encodedBodySize']) {
-				result.push(cachingTypes.validated);
-			} else {
-				result.push(cachingTypes.fullLoad);
-			}
-
-			result.push(entry['encodedBodySize']);
-		}
-
-		return result.join(',');
-	}
-
-	function addMetaDataToBeacon(beacon) {
-		for (var key in defaultVars.meta) {
-			if (hasOwnProperty(defaultVars.meta, key)) {
-				beacon['m_' + key] = defaultVars.meta[key];
-			}
-		}
-	}
-
-	var maxLengthForImgRequest = 2000;
-
-	function sendBeacon(data) {
-		var str = stringify(data);
-		if (str.length === 0) {
-			return;
-		}
-
-		{
-			info('Transmitting beacon', data);
-		}
-
-		if (OriginalXMLHttpRequest && str.length > maxLengthForImgRequest) {
-			var xhr = new OriginalXMLHttpRequest();
-			xhr.open('POST', String(defaultVars.reportingUrl), true);
-			xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
-			xhr.send(str);
-		} else {
-			// Older browsers do not support the XMLHttpRequest API. This sucks and may
-			// result in a variety of issues, e.g. URL length restrictions. "Luckily", older
-			// browsers also lack support for advanced features such as resource timing.
-			// This should make this transmission via a GET request possible.
-			var image = new Image();
-			image.src = String(defaultVars.reportingUrl) + '?' + str;
-		}
-	}
-
-	function stringify(data) {
-		var str = '';
-
-		for (var key in data) {
-			if (hasOwnProperty(data, key)) {
-				var value = data[key];
-				if (value != null) {
-					str += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(String(data[key]));
-				}
-			}
-		}
-
-		return str.substring(1);
-	}
-
-	var state$1 = {
-		onEnter: function () {
-			// $FlowFixMe: Find a way to define all properties beforehand so that flow doesn't complain about missing
-			// props.
-			var beacon = {};
-			beacon['ty'] = 'pl';
-			beacon['r'] = defaultVars.referenceTimestamp;
-			beacon['k'] = defaultVars.apiKey;
-			beacon['t'] = defaultVars.pageLoadTraceId;
-			beacon['bt'] = defaultVars.pageLoadBackendTraceId;
-			beacon['u'] = win.location.href;
-
-			addMetaDataToBeacon(beacon);
-			addTimingToPageLoadBeacon(beacon);
-			addResourceTimings(beacon);
-
-			sendBeacon(beacon);
-		},
-		getActiveTraceId: function () {
-			return null;
-		}
-	};
-
-	function isUrlIgnored(url) {
-		for (var i = 0, len = defaultVars.ignoreUrls.length; i < len; i++) {
-			if (defaultVars.ignoreUrls[i].test(url)) {
-				return true;
-			}
-		}
-		return false;
-	}
+var urlMaxLength = 255;
+
+var initiatorTypes = {
+  'other': 0,
+  'img': 1,
+  'link': 2,
+  'script': 3,
+  'css': 4,
+  'xmlhttprequest': 5,
+  'html': 6,
+  // IMAGE element inside a SVG
+  'image': 7
+};
+
+var cachingTypes = {
+  unknown: 0,
+  cached: 1,
+  validated: 2,
+  fullLoad: 3
+};
+
+function addResourceTimings(beacon, minStartTime) {
+  if (isResourceTimingAvailable && win.JSON) {
+    var entries = getEntriesTransferFormat(performance.getEntriesByType('resource'), minStartTime);
+    beacon['res'] = win.JSON.stringify(entries);
+
+    if (defaultVars.autoClearResourceTimings && performance.clearResourceTimings) {
+      {
+        debug('Automatically clearing resource timing buffer.');
+      }
+      performance.clearResourceTimings();
+    }
+  } else {
+    info('Resource timing not supported.');
+  }
+}
+
+function getEntriesTransferFormat(performanceEntries, minStartTime) {
+  var trie = createTrie();
+
+  for (var i = 0, len = performanceEntries.length; i < len; i++) {
+    var entry = performanceEntries[i];
+    if (minStartTime != null && entry['startTime'] - defaultVars.highResTimestampReference + defaultVars.referenceTimestamp < minStartTime) {
+      continue;
+    }
+
+    var url = entry.name;
+    var lowerCaseUrl = url.toLowerCase();
+    if (lowerCaseUrl === 'about:blank' || lowerCaseUrl.indexOf('javascript:') === 0) {
+      continue;
+    }
+
+    if (url.length > urlMaxLength) {
+      url = url.substring(0, urlMaxLength);
+    }
+
+    // We provide more detailed XHR insights via our XHR instrumentation.
+    // The XHR instrumentation is available once the initialization was executed
+    // (which is completely synchronous).
+    if (entry['initiatorType'] !== 'xmlhttprequest' || entry['startTime'] < defaultVars.highResTimestampReference) {
+      trie.addItem(url, serializeEntry(entry));
+    }
+  }
+
+  return trie.toJs();
+}
+
+function serializeEntry(entry) {
+  var result = [Math.round(entry['startTime'] - defaultVars.highResTimestampReference), Math.round(entry['duration']), initiatorTypes[entry['initiatorType']] || initiatorTypes['other']];
+
+  // When timing data is available, we can provide additional information about
+  // caching and resource sizes.
+  if (typeof entry['transferSize'] === 'number' && typeof entry['encodedBodySize'] === 'number' &&
+  // All this information may not be available due to cross-origin.
+  entry['transferSize'] > 0) {
+    if (entry['transferSize'] === 0) {
+      result.push(cachingTypes.cached);
+    } else if (entry['transferSize'] < entry['encodedBodySize']) {
+      result.push(cachingTypes.validated);
+    } else {
+      result.push(cachingTypes.fullLoad);
+    }
+
+    result.push(entry['encodedBodySize']);
+  }
+
+  return result.join(',');
+}
+
+function addMetaDataToBeacon(beacon) {
+  for (var key in defaultVars.meta) {
+    if (hasOwnProperty(defaultVars.meta, key)) {
+      beacon['m_' + key] = defaultVars.meta[key];
+    }
+  }
+}
+
+var maxLengthForImgRequest = 2000;
+
+function sendBeacon(data) {
+  var str = stringify(data);
+  if (str.length === 0) {
+    return;
+  }
+
+  {
+    info('Transmitting beacon', data);
+  }
+
+  if (OriginalXMLHttpRequest && str.length > maxLengthForImgRequest) {
+    var xhr = new OriginalXMLHttpRequest();
+    xhr.open('POST', String(defaultVars.reportingUrl), true);
+    xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
+    xhr.timeout = defaultVars.xhrTransmissionTimeout;
+    xhr.send(str);
+  } else {
+    // Older browsers do not support the XMLHttpRequest API. This sucks and may
+    // result in a variety of issues, e.g. URL length restrictions. "Luckily", older
+    // browsers also lack support for advanced features such as resource timing.
+    // This should make this transmission via a GET request possible.
+    var image = new Image();
+    image.src = String(defaultVars.reportingUrl) + '?' + str;
+  }
+}
+
+function stringify(data) {
+  var str = '';
+
+  for (var key in data) {
+    if (hasOwnProperty(data, key)) {
+      var value = data[key];
+      if (value != null) {
+        str += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(String(data[key]));
+      }
+    }
+  }
+
+  return str.substring(1);
+}
+
+// We are never recreating this beacon object since we are always reporting / rewriting all properties.
+// $FlowFixMe: Find a way to define all properties beforehand so that flow doesn't complain about missing props.
+var beacon = {};
+
+var state$1 = {
+  onEnter: function () {
+    beacon['k'] = defaultVars.apiKey;
+    beacon['r'] = defaultVars.referenceTimestamp;
+    beacon['t'] = generateUniqueId();
+    beacon['ts'] = now();
+
+    beacon['ty'] = 'spa';
+    beacon['pl'] = defaultVars.pageLoadTraceId;
+  },
+  getActiveTraceId: function () {
+    // $FlowFixMe: Flow somehow considers this property as null|number|undefined.
+    return beacon['t'];
+  },
+  triggerManualPageLoad: function () {
+    {
+      warn('Triggering a page load while SPA transitioning is unsupported.');
+    }
+  },
+  startSpaPageTransition: function () {
+    {
+      warn('Triggering an SPA page transition while already transitioning is unsupported.');
+    }
+
+    // best effort here even though it is wrong usage
+    transitionTo('spaTransition');
+  },
+  endSpaPageTransition: function (opts) {
+    beacon['p'] = defaultVars.page;
+    beacon['l'] = opts['url'];
+    beacon['e'] = opts['explanation'];
+    // $FlowFixMe: Flow somehow considers the ts property to be a string
+    beacon['d'] = now() - beacon['ts'];
+
+    switch (opts['status']) {
+      case 'completed':
+        beacon['s'] = 'c';
+        break;
+      case 'aborted':
+        beacon['s'] = 'a';
+        break;
+      case 'error':
+        beacon['s'] = 'e';
+        break;
+      default:
+        {
+          warn('Unsupported SPA transition status of type ' + opts['status']);
+        }
+        beacon['s'] = 'u';
+        break;
+    }
+
+    addMetaDataToBeacon(beacon);
+    // $FlowFixMe: Flow somehow considers the ts property to be a string
+    addResourceTimings(beacon, beacon['ts'] - 1);
+    sendBeacon(beacon);
+    transitionTo('pageLoaded');
+  }
+};
+
+// See spec:
+// https://www.w3.org/TR/navigation-timing/
+
+function getPageLoadStartTimestamp() {
+  if (!isTimingAvailable) {
+    return defaultVars.initializerExecutionTimestamp;
+  }
+  // We don't use navigationStart since that includes unload times for the previous
+  // page.
+  var timing = performance.timing;
+  return timing.fetchStart - (timing.redirectEnd - timing.redirectStart);
+}
+
+function addTimingToPageLoadBeacon(beacon) {
+  if (!isTimingAvailable) {
+    // This is our absolute fallback mode where we only have
+    // approximations for speed information.
+    beacon['ts'] = getPageLoadStartTimestamp() - defaultVars.referenceTimestamp;
+    beacon['d'] = Number(event.time) - defaultVars.initializerExecutionTimestamp;
+
+    // We add this as an extra property to the beacon so that
+    // a backend can decide whether it should include timing
+    // information in aggregated metrics. Since they are only
+    // approximations, this is not always desirable.
+    if (!isTimingAvailable) {
+      beacon['tim'] = '0';
+    }
+
+    return;
+  }
+
+  var timing = performance.timing;
+
+  var redirectTime = timing.redirectEnd - timing.redirectStart;
+  // We don't use navigationStart since that includes unload times for the previous page.
+  var start = getPageLoadStartTimestamp();
+  beacon['ts'] = start - defaultVars.referenceTimestamp;
+
+  // This can happen when the user aborts the page load. In this case, the load event
+  // timing information is not available and will have the default value of "0".
+  if (timing.loadEventStart > 0) {
+    beacon['d'] = timing.loadEventStart - timing.fetchStart;
+  } else {
+    beacon['d'] = Number(event.time) - defaultVars.initializerExecutionTimestamp;
+
+    // We have partial timing information, but since the load was aborted, we will
+    // mark it as missing to indicate that the information should be ignored in
+    // statistics.
+    beacon['tim'] = '0';
+  }
+
+  beacon['t_unl'] = timing.unloadEventEnd - timing.unloadEventStart;
+  beacon['t_red'] = redirectTime;
+  beacon['t_apc'] = timing.domainLookupStart - timing.fetchStart;
+  beacon['t_dns'] = timing.domainLookupEnd - timing.domainLookupStart;
+  if (timing.secureConnectionStart != null && timing.secureConnectionStart > 0) {
+    beacon['t_tcp'] = timing.secureConnectionStart - timing.connectStart;
+    beacon['t_ssl'] = timing.connectEnd - timing.secureConnectionStart;
+  } else {
+    beacon['t_tcp'] = timing.connectEnd - timing.connectStart;
+    beacon['t_ssl'] = 0;
+  }
+  beacon['t_req'] = timing.responseStart - timing.requestStart;
+  beacon['t_rsp'] = timing.responseEnd - timing.responseStart;
+  beacon['t_dom'] = timing.domContentLoadedEventStart - timing.domLoading;
+  beacon['t_chi'] = timing.loadEventEnd - timing.domContentLoadedEventStart;
+  beacon['t_bac'] = timing.responseStart - start;
+  beacon['t_fro'] = timing.loadEventEnd - timing.responseStart;
+
+  addFirstPaintTimings(beacon, start);
+}
+
+function addFirstPaintTimings(beacon, start) {
+  if (!isResourceTimingAvailable) {
+    addFirstPaintFallbacks(beacon, start);
+    return;
+  }
+
+  var paintTimings = performance.getEntriesByType('paint');
+  var firstPaintFound = false;
+  for (var i = 0; i < paintTimings.length; i++) {
+    var paintTiming = paintTimings[i];
+    switch (paintTiming.name) {
+      case 'first-paint':
+        beacon['t_fp'] = paintTiming.startTime | 0;
+        firstPaintFound = true;
+        break;
+
+      case 'first-contentful-paint':
+        beacon['t_fcp'] = paintTiming.startTime | 0;
+        break;
+    }
+  }
+
+  if (!firstPaintFound) {
+    addFirstPaintFallbacks(beacon, start);
+  }
+}
+
+function addFirstPaintFallbacks(beacon, start) {
+  var firstPaint = null;
+
+  // Chrome
+  if (win.chrome && win.chrome.loadTimes) {
+    // Convert to ms
+    firstPaint = win.chrome.loadTimes().firstPaintTime * 1000;
+  }
+  // IE
+  else if (typeof win.performance.timing.msFirstPaint === 'number') {
+      firstPaint = win.performance.timing.msFirstPaint;
+    }
+    // standard
+    else if (typeof win.performance.timing.firstPaint === 'number') {
+        firstPaint = win.performance.timing.firstPaint;
+      }
+
+  // First paint may not be available -OR- the browser may have never
+  // painted anything and thereby kept this value at 0.
+  if (firstPaint != null && firstPaint !== 0) {
+    beacon['t_fp'] = Math.round(firstPaint - start);
+  }
+}
+
+var pageLoadBeaconTransmitted = false;
+
+var state$2 = {
+  onEnter: function () {
+    if (!pageLoadBeaconTransmitted) {
+      pageLoadBeaconTransmitted = true;
+      sendPageLoadBeacon();
+    }
+  },
+  getActiveTraceId: function () {
+    return null;
+  },
+  triggerManualPageLoad: function () {
+    {
+      warn('Page load triggered, but page is already considered as loaded. Did you mark it as loaded more than once?');
+    }
+  },
+  startSpaPageTransition: function () {
+    transitionTo('spaTransition');
+  },
+
+
+  /* eslint-disable no-unused-vars */
+  endSpaPageTransition: function (opts) {
+    /* eslint-enable no-unused-vars */
+    {
+      warn('No pending SPA page transition to end.');
+    }
+  }
+};
+function sendPageLoadBeacon() {
+  // $FlowFixMe: Find a way to define all properties beforehand so that flow doesn't complain about missing props.
+  var beacon = {};
+  beacon['ty'] = 'pl';
+  beacon['r'] = defaultVars.referenceTimestamp;
+  beacon['k'] = defaultVars.apiKey;
+  beacon['t'] = defaultVars.pageLoadTraceId;
+  beacon['p'] = defaultVars.page;
+  beacon['bt'] = defaultVars.pageLoadBackendTraceId;
+  beacon['u'] = win.location.href;
+
+  addMetaDataToBeacon(beacon);
+  addTimingToPageLoadBeacon(beacon);
+  addResourceTimings(beacon);
+
+  sendBeacon(beacon);
+}
+
+var ignorePingsRegex = /.*\/ping(\/?$|\?.*)/i;
+
+function isUrlIgnored(url) {
+  if (defaultVars.ignorePings && ignorePingsRegex.test(url)) {
+    return true;
+  }
+
+  for (var i = 0, len = defaultVars.ignoreUrls.length; i < len; i++) {
+    if (defaultVars.ignoreUrls[i].test(url)) {
+      return true;
+    }
+  }
+
+  return false;
+}
 
 // In addition to the common HTTP status codes, a bunch of
 // additional outcomes are possible. Mainly errors, the following
 // status codes denote internal codes which are used for beacons
 // to describe the XHR result.
-	var additionalStatuses = {
-		// https://xhr.spec.whatwg.org/#the-timeout-attribute
-		timeout: -100,
-
-		// Used when the request is aborted:
-		// https://xhr.spec.whatwg.org/#the-abort()-method
-		abort: -101,
-
-		// Errors may occur when opening an XHR object for a variety of
-		// reasons.
-		// https://xhr.spec.whatwg.org/#the-open()-method
-		openError: -102,
-
-		// Non-HTTP errors, e.g. failed to establish connection.
-		// https://xhr.spec.whatwg.org/#events
-		error: -103
-	};
-
-	function instrumentXMLHttpRequest() {
-		if (!OriginalXMLHttpRequest || !new OriginalXMLHttpRequest().addEventListener) {
-			{
-				info('Browser does not support the features required for XHR instrumentation.');
-			}
-			return;
-		}
-
-		function InstrumentedXMLHttpRequest() {
-			var xhr = new OriginalXMLHttpRequest();
-
-			var originalOpen = xhr.open;
-			var originalSend = xhr.send;
-
-			// $FlowFixMe: Some properties deliberately left our for js file size reasons.
-			var beacon = {
-				// general beacon data
-				'r': defaultVars.referenceTimestamp,
-
-				// $FlowFixMe: Some properties deliberately left our for js file size reasons.
-				'k': defaultVars.apiKey,
-				// 't': '',
-				'ts': 0,
-				'd': 0,
-
-				// xhr beacon specific data
-				'ty': 'xhr',
-				// 's': '',
-				'pl': defaultVars.pageLoadTraceId,
-				'l': win.location.href,
-				'm': '',
-				'u': '',
-				'a': 1,
-				'st': 0,
-				'e': undefined
-			};
-
-			addMetaDataToBeacon(beacon);
-
-			// Whether or not we should ignore this beacon, e.g. because the URL is
-			// ignored.
-			var ignored = false;
-
-			function onFinish(status) {
-				if (ignored) {
-					return;
-				}
-
-				if (beacon['st'] !== 0) {
-					// Multiple finish events. Should only happen when we setup the event handlers
-					// in a wrong way or when the XHR object is reused. We don't support this use
-					// case.
-					return;
-				}
-
-				beacon['st'] = status;
-				// $FlowFixMe: Not sure why flow thinks that the ts value is a string :(
-				beacon['d'] = now() - (beacon['ts'] + defaultVars.referenceTimestamp);
-				sendBeacon(beacon);
-			}
-
-			xhr.addEventListener('timeout', function onTimeout() {
-				if (ignored) {
-					return;
-				}
-
-				onFinish(additionalStatuses.timeout);
-			});
-
-			xhr.addEventListener('error', function onError(e) {
-				if (ignored) {
-					return;
-				}
-
-				var message = e && (e.error && e.error.message || e.message);
-				if (typeof message === 'string') {
-					beacon['e'] = message.substring(0, 300);
-				}
-				onFinish(additionalStatuses.error);
-			});
-
-			xhr.addEventListener('abort', function onAbort() {
-				if (ignored) {
-					return;
-				}
-
-				onFinish(additionalStatuses.abort);
-			});
-
-			xhr.addEventListener('readystatechange', function onReadystatechange() {
-				if (ignored) {
-					return;
-				}
-
-				if (xhr.readyState === 4) {
-					var status = void 0;
-
-					try {
-						status = xhr.status;
-					} catch (e) {
-						// IE 9 will throw errors when trying to access the status property
-						// on aborted requests and timeouts. We can swallow the error
-						// since we have separate event listeners for these types of
-						// situations.
-						onFinish(additionalStatuses.error);
-						return;
-					}
-
-					if (status !== 0) {
-						onFinish(status);
-					}
-				}
-			});
-
-			xhr.open = function open(method, url, async) {
-				ignored = isUrlIgnored(url);
-				if (ignored) {
-					{
-						debug(
-							'Not generating XHR beacon because it should be ignored according to user configuration. URL: '
-							+ url);
-					}
-					return originalOpen.apply(xhr, arguments);
-				}
-
-				if (async === undefined) {
-					async = true;
-				}
-
-				var traceId = getActiveTraceId();
-				var spanId = generateUniqueId();
-				if (!traceId) {
-					traceId = spanId;
-				}
-
-				beacon['t'] = traceId;
-				beacon['s'] = spanId;
-				beacon['m'] = method;
-				beacon['u'] = url;
-				beacon['a'] = async ? 1 : 0;
-
-				try {
-					var result = originalOpen.apply(xhr, arguments);
-
-					if (isSameOrigin(url)) {
-						xhr.setRequestHeader('X-INSTANA-T', traceId);
-						xhr.setRequestHeader('X-INSTANA-S', spanId);
-						xhr.setRequestHeader('X-INSTANA-L', '1');
-					}
-
-					return result;
-				} catch (e) {
-					beacon['ts'] = now() - defaultVars.referenceTimestamp;
-					beacon['st'] = additionalStatuses.openError;
-					beacon['e'] = e.message;
-					sendBeacon(beacon);
-					throw e;
-				}
-			};
-
-			xhr.send = function send() {
-				if (ignored) {
-					return originalSend.apply(xhr, arguments);
-				}
-
-				beacon['ts'] = now() - defaultVars.referenceTimestamp;
-				return originalSend.apply(xhr, arguments);
-			};
-
-			return xhr;
-		}
-
-		InstrumentedXMLHttpRequest.prototype = OriginalXMLHttpRequest.prototype;
-		InstrumentedXMLHttpRequest.DONE = OriginalXMLHttpRequest.DONE;
-		InstrumentedXMLHttpRequest.HEADERS_RECEIVED = OriginalXMLHttpRequest.HEADERS_RECEIVED;
-		InstrumentedXMLHttpRequest.LOADING = OriginalXMLHttpRequest.LOADING;
-		InstrumentedXMLHttpRequest.OPENED = OriginalXMLHttpRequest.OPENED;
-		InstrumentedXMLHttpRequest.UNSENT = OriginalXMLHttpRequest.UNSENT;
-		win.XMLHttpRequest = InstrumentedXMLHttpRequest;
-	}
-
-	function isSameOrigin(url) {
-		try {
-			var a = document.createElement('a');
-			a.href = url;
-
-			var loc = win.location;
-			// Most browsers support this fallback logic out of the box. Not so the Internet explorer.
-			// To make it work in Internet explorer, we need to add the fallback manually.
-			// IE 9 uses a colon as the protocol when no protocol is defined
-			return (a.protocol && a.protocol !== ':' ? a.protocol : loc.protocol) === loc.protocol && (a.hostname
-																									   || loc.hostname)
-																									  === loc.hostname
-				   && (a.port || loc.port) === loc.port;
-		} catch (e) {
-			return false;
-		}
-	}
-
-	var maxErrorsToReport = 100;
-	var maxStackSize = 30;
-
-	var reportedErrors = 0;
-	var maxSeenErrorsTracked = 20;
-	var numberOfDifferentErrorsSeen = 0;
-	var seenErrors = {};
-
-	var scheduledTransmissionTimeoutHandle = void 0;
-
-	function hookIntoGlobalErrorEvent() {
-		var globalOnError = win.onerror;
-		win.onerror = function (message, fileName, lineNumber, columnNumber, error) {
-			var stack = error && error.stack;
-			if (!stack) {
-				stack = 'at ' + fileName + ' ' + lineNumber + ':' + columnNumber;
-			}
-			onUnhandledError(message, stack);
-			if (typeof globalOnError === 'function') {
-				return globalOnError.apply(this, arguments);
-			}
-		};
-	}
-
-	function onUnhandledError(message, stack) {
-		if (!message || reportedErrors > maxErrorsToReport) {
-			return;
-		}
-
-		if (numberOfDifferentErrorsSeen >= maxSeenErrorsTracked) {
-			seenErrors = {};
-			numberOfDifferentErrorsSeen = 0;
-		}
-
-		message = String(message).substring(0, 300);
-		stack = String(stack || '').split('\n').slice(0, maxStackSize).join('\n');
-		var location = win.location.href;
-		var parentId = getActiveTraceId();
-		var key = message + stack + location + parentId;
-
-		var trackedError = seenErrors[key];
-		if (trackedError) {
-			trackedError.seenCount++;
-		} else {
-			trackedError = seenErrors[key] = {
-				message: message,
-				stack: stack,
-				location: location,
-				parentId: parentId,
-				seenCount: 1,
-				transmittedCount: 0
-			};
-			numberOfDifferentErrorsSeen++;
-		}
-
-		scheduleTransmission();
-	}
-
-	function scheduleTransmission() {
-		if (scheduledTransmissionTimeoutHandle) {
-			return;
-		}
-
-		scheduledTransmissionTimeoutHandle = setTimeout(send$1, 1000);
-	}
-
-	function send$1() {
-		clearTimeout(scheduledTransmissionTimeoutHandle);
-		scheduledTransmissionTimeoutHandle = null;
-
-		for (var _key in seenErrors) {
-			if (seenErrors.hasOwnProperty(_key)) {
-				var seenError = seenErrors[_key];
-				if (seenError.seenCount > seenError.transmittedCount) {
-					sendBeaconForError(seenError);
-					reportedErrors++;
-				}
-			}
-		}
-
-		seenErrors = {};
-		numberOfDifferentErrorsSeen = 0;
-	}
-
-	function sendBeaconForError(error) {
-		var spanId = generateUniqueId();
-		var traceId = error.parentId || spanId;
-		// $FlowFixMe
-		var beacon = {
-			// $FlowFixMe
-			'k': defaultVars.apiKey,
-			's': spanId,
-			't': traceId,
-			'ts': now(),
-
-			// xhr beacon specific data
-			'ty': 'err',
-			'pl': defaultVars.pageLoadTraceId,
-			'l': error.location,
-			'e': error.message,
-			'st': error.stack,
-			'c': error.seenCount - error.transmittedCount
-		};
-		addMetaDataToBeacon(beacon);
-
-		sendBeacon(beacon);
-	}
-
-	var state$2 = {
-		onEnter: function () {
-			if (!fulfillsPrerequisites()) {
-				{
-					return warn('Browser does not have all the required features for web EUM.');
-				}
-			}
-
-			var globalObjectName = win[defaultVars.nameOfLongGlobal];
-			var globalObject = win[globalObjectName];
-			if (globalObject) {
-				processQueue(globalObject.q);
-			}
-
-			if (typeof globalObject['l'] !== 'number') {
-				{
-					warn('Reference timestamp not set via EUM initializer. Was the initializer modified?');
-				}
-				return;
-			}
-
-			defaultVars.initializerExecutionTimestamp = globalObject['l'];
-
-			if (defaultVars.reportingUrl) {
-				instrumentXMLHttpRequest();
-				hookIntoGlobalErrorEvent();
-				transitionTo('waitForPageLoad');
-			} else {
-				error('No reporting URL configured. Aborting EUM initialization.');
-			}
-		},
-		getActiveTraceId: function () {
-			return null;
-		}
-	};
-
-	function processQueue(queue) {
-		for (var i = 0, len = queue.length; i < len; i++) {
-			var item = queue[i];
-
-			switch (item[0]) {
-				case 'apiKey':
-					defaultVars.apiKey = item[1];
-					break;
-				case 'reportingUrl':
-					defaultVars.reportingUrl = item[1];
-					break;
-				case 'meta':
-					defaultVars.meta[item[1]] = item[2];
-					break;
-				case 'traceId':
-					defaultVars.pageLoadBackendTraceId = item[1];
-					break;
-				case 'ignoreUrls': {
-					validateIgnoreUrls(item[1]);
-				}
-					defaultVars.ignoreUrls = item[1];
-					break;
-				default:
-
-			}
-		}
-	}
-
-	function fulfillsPrerequisites() {
-		return win.XMLHttpRequest && win.JSON;
-	}
-
-	function validateIgnoreUrls(ignoreUrls) {
-		if (!(ignoreUrls instanceof Array)) {
-			return warn('ignoreUrls is not an array. This will result in errors.');
-		}
-
-		for (var i = 0, len = ignoreUrls.length; i < len; i++) {
-			if (!(ignoreUrls[i] instanceof RegExp)) {
-				return warn('ignoreUrls[' + i + '] is not a RegExp. This will result in errors.');
-			}
-		}
-	}
-
-	registerState('init', state$2);
-	registerState('waitForPageLoad', state);
-	registerState('pageLoaded', state$1);
-
-	transitionTo('init', state$2);
+var additionalStatuses = {
+  // https://xhr.spec.whatwg.org/#the-timeout-attribute
+  timeout: -100,
+
+  // Used when the request is aborted:
+  // https://xhr.spec.whatwg.org/#the-abort()-method
+  abort: -101,
+
+  // Errors may occur when opening an XHR object for a variety of
+  // reasons.
+  // https://xhr.spec.whatwg.org/#the-open()-method
+  openError: -102,
+
+  // Non-HTTP errors, e.g. failed to establish connection.
+  // https://xhr.spec.whatwg.org/#events
+  error: -103
+};
+
+// Asynchronously created a tag.
+// document.createElement('a')
+var urlAnalysisElement = null;
+try {
+  urlAnalysisElement = document.createElement('a');
+} catch (e) {
+  {
+    debug('Failed to create URL analysis element. Will not be able to determine same-origin / ', e);
+  }
+}
+
+function instrumentXMLHttpRequest() {
+  if (!OriginalXMLHttpRequest || !new OriginalXMLHttpRequest().addEventListener) {
+    {
+      info('Browser does not support the features required for XHR instrumentation.');
+    }
+    return;
+  }
+
+  function InstrumentedXMLHttpRequest() {
+    var xhr = new OriginalXMLHttpRequest();
+
+    var originalOpen = xhr.open;
+    var originalSend = xhr.send;
+
+    // $FlowFixMe: Some properties deliberately left our for js file size reasons.
+    var beacon = {
+      // general beacon data
+      'r': defaultVars.referenceTimestamp,
+
+      // $FlowFixMe: Some properties deliberately left our for js file size reasons.
+      'k': defaultVars.apiKey,
+      // 't': '',
+      'ts': 0,
+      'd': 0,
+
+      // xhr beacon specific data
+      'ty': 'xhr',
+      // 's': '',
+      'pl': defaultVars.pageLoadTraceId,
+      'l': win.location.href,
+      'm': '',
+      'u': '',
+      'a': 1,
+      'st': 0,
+      'e': undefined
+    };
+
+    addMetaDataToBeacon(beacon);
+
+    // Whether or not we should ignore this beacon, e.g. because the URL is
+    // ignored.
+    var ignored = false;
+
+    function onFinish(status) {
+      if (ignored) return;
+
+      if (beacon['st'] !== 0) {
+        // Multiple finish events. Should only happen when we setup the event handlers
+        // in a wrong way or when the XHR object is reused. We don't support this use
+        // case.
+        return;
+      }
+
+      beacon['st'] = status;
+      // $FlowFixMe: Not sure why flow thinks that the ts value is a string :(
+      beacon['d'] = now() - (beacon['ts'] + defaultVars.referenceTimestamp);
+      sendBeacon(beacon);
+    }
+
+    xhr.addEventListener('timeout', function onTimeout() {
+      if (ignored) return;
+
+      onFinish(additionalStatuses.timeout);
+    });
+
+    xhr.addEventListener('error', function onError(e) {
+      if (ignored) return;
+
+      var message = e && (e.error && e.error.message || e.message);
+      if (typeof message === 'string') {
+        beacon['e'] = message.substring(0, 300);
+      }
+      onFinish(additionalStatuses.error);
+    });
+
+    xhr.addEventListener('abort', function onAbort() {
+      if (ignored) return;
+
+      onFinish(additionalStatuses.abort);
+    });
+
+    xhr.addEventListener('readystatechange', function onReadystatechange() {
+      if (ignored) return;
+
+      if (xhr.readyState === 4) {
+        var status = void 0;
+
+        try {
+          status = xhr.status;
+        } catch (e) {
+          // IE 9 will throw errors when trying to access the status property
+          // on aborted requests and timeouts. We can swallow the error
+          // since we have separate event listeners for these types of
+          // situations.
+          onFinish(additionalStatuses.error);
+          return;
+        }
+
+        if (status !== 0) {
+          onFinish(status);
+        }
+      }
+    });
+
+    xhr.open = function open(method, url, async) {
+      ignored = isUrlIgnored(url);
+      if (ignored) {
+        {
+          debug('Not generating XHR beacon because it should be ignored according to user configuration. URL: ' + url);
+        }
+        return originalOpen.apply(xhr, arguments);
+      }
+
+      if (async === undefined) {
+        async = true;
+      }
+
+      var traceId = getActiveTraceId();
+      var spanId = generateUniqueId();
+      if (!traceId) {
+        traceId = spanId;
+      }
+
+      var sampled = Math.random() <= defaultVars.sampleRate ? 1 : 0;
+      beacon['t'] = traceId;
+      beacon['s'] = spanId;
+      beacon['m'] = method;
+      beacon['u'] = normalizeUrl(url);
+      beacon['a'] = async ? 1 : 0;
+      beacon['sp'] = sampled;
+
+      try {
+        var result = originalOpen.apply(xhr, arguments);
+
+        if (isSameOrigin(url)) {
+          xhr.setRequestHeader('X-INSTANA-T', traceId);
+          xhr.setRequestHeader('X-INSTANA-S', spanId);
+          xhr.setRequestHeader('X-INSTANA-L', sampled);
+        }
+
+        return result;
+      } catch (e) {
+        beacon['ts'] = now() - defaultVars.referenceTimestamp;
+        beacon['st'] = additionalStatuses.openError;
+        beacon['e'] = e.message;
+        sendBeacon(beacon);
+        throw e;
+      }
+    };
+
+    xhr.send = function send() {
+      if (ignored) {
+        return originalSend.apply(xhr, arguments);
+      }
+
+      beacon['ts'] = now() - defaultVars.referenceTimestamp;
+      beacon['p'] = defaultVars.page;
+      return originalSend.apply(xhr, arguments);
+    };
+
+    return xhr;
+  }
+
+  InstrumentedXMLHttpRequest.prototype = OriginalXMLHttpRequest.prototype;
+  InstrumentedXMLHttpRequest.DONE = OriginalXMLHttpRequest.DONE;
+  InstrumentedXMLHttpRequest.HEADERS_RECEIVED = OriginalXMLHttpRequest.HEADERS_RECEIVED;
+  InstrumentedXMLHttpRequest.LOADING = OriginalXMLHttpRequest.LOADING;
+  InstrumentedXMLHttpRequest.OPENED = OriginalXMLHttpRequest.OPENED;
+  InstrumentedXMLHttpRequest.UNSENT = OriginalXMLHttpRequest.UNSENT;
+  win.XMLHttpRequest = InstrumentedXMLHttpRequest;
+}
+
+function isSameOrigin(url) {
+  if (!urlAnalysisElement) {
+    return false;
+  }
+
+  try {
+    urlAnalysisElement.href = url;
+
+    var loc = win.location;
+    // Most browsers support this fallback logic out of the box. Not so the Internet explorer.
+    // To make it work in Internet explorer, we need to add the fallback manually.
+    // IE 9 uses a colon as the protocol when no protocol is defined
+    return (urlAnalysisElement.protocol && urlAnalysisElement.protocol !== ':' ? urlAnalysisElement.protocol : loc.protocol) === loc.protocol && (urlAnalysisElement.hostname || loc.hostname) === loc.hostname && (urlAnalysisElement.port || loc.port) === loc.port;
+  } catch (e) {
+    return false;
+  }
+}
+
+function normalizeUrl(url) {
+  if (!urlAnalysisElement) {
+    return url;
+  }
+
+  try {
+    // "a"-elements normalize the URL when setting a relative URL or URLs
+    // that are missing a scheme
+    urlAnalysisElement.href = url;
+    return urlAnalysisElement.href;
+  } catch (e) {
+    {
+      debug('Failed to normalize URL' + url);
+    }
+    return url;
+  }
+}
+
+var maxErrorsToReport = 100;
+var maxStackSize = 30;
+
+var reportedErrors = 0;
+var erroneousPageViewReported = false;
+var maxSeenErrorsTracked = 20;
+var numberOfDifferentErrorsSeen = 0;
+var seenErrors = {};
+
+var scheduledTransmissionTimeoutHandle = void 0;
+
+function hookIntoGlobalErrorEvent() {
+  var globalOnError = win.onerror;
+  win.onerror = function (message, fileName, lineNumber, columnNumber, error) {
+    var stack = error && error.stack;
+    if (!stack) {
+      stack = 'at ' + fileName + ' ' + lineNumber + ':' + columnNumber;
+    }
+    onUnhandledError(message, stack);
+    if (typeof globalOnError === 'function') {
+      return globalOnError.apply(this, arguments);
+    }
+  };
+}
+
+function onUnhandledError(message, stack) {
+  if (!erroneousPageViewReported) {
+    erroneousPageViewReported = true;
+    sendErroneousPageViewBeacon();
+  }
+
+  if (!message || reportedErrors > maxErrorsToReport) {
+    return;
+  }
+
+  if (numberOfDifferentErrorsSeen >= maxSeenErrorsTracked) {
+    seenErrors = {};
+    numberOfDifferentErrorsSeen = 0;
+  }
+
+  message = String(message).substring(0, 300);
+  stack = String(stack || '').split('\n').slice(0, maxStackSize).join('\n');
+  var location = win.location.href;
+  var parentId = getActiveTraceId();
+  var key = message + stack + location + parentId;
+
+  var trackedError = seenErrors[key];
+  if (trackedError) {
+    trackedError.seenCount++;
+  } else {
+    trackedError = seenErrors[key] = {
+      message: message,
+      stack: stack,
+      location: location,
+      parentId: parentId,
+      seenCount: 1,
+      transmittedCount: 0
+    };
+    numberOfDifferentErrorsSeen++;
+  }
+
+  scheduleTransmission();
+}
+
+function scheduleTransmission() {
+  if (scheduledTransmissionTimeoutHandle) {
+    return;
+  }
+
+  scheduledTransmissionTimeoutHandle = setTimeout(send$1, 1000);
+}
+
+function send$1() {
+  clearTimeout(scheduledTransmissionTimeoutHandle);
+  scheduledTransmissionTimeoutHandle = null;
+
+  for (var _key in seenErrors) {
+    if (seenErrors.hasOwnProperty(_key)) {
+      var seenError = seenErrors[_key];
+      if (seenError.seenCount > seenError.transmittedCount) {
+        sendBeaconForError(seenError);
+        reportedErrors++;
+      }
+    }
+  }
+
+  seenErrors = {};
+  numberOfDifferentErrorsSeen = 0;
+}
+
+function sendBeaconForError(error) {
+  var spanId = generateUniqueId();
+  var traceId = error.parentId || spanId;
+  // $FlowFixMe
+  var beacon = {
+    // $FlowFixMe
+    'k': defaultVars.apiKey,
+    's': spanId,
+    't': traceId,
+    'ts': now(),
+    'p': defaultVars.page,
+
+    // xhr beacon specific data
+    'ty': 'err',
+    'pl': defaultVars.pageLoadTraceId,
+    'l': error.location,
+    'e': error.message,
+    'st': error.stack,
+    'c': error.seenCount - error.transmittedCount
+  };
+  addMetaDataToBeacon(beacon);
+
+  sendBeacon(beacon);
+}
+
+function sendErroneousPageViewBeacon() {
+  // $FlowFixMe
+  var beacon = {
+    // $FlowFixMe
+    'k': defaultVars.apiKey,
+    't': generateUniqueId(),
+    'ts': getPageLoadStartTimestamp(),
+    'p': defaultVars.page,
+
+    // epv beacon specific data
+    'ty': 'epv',
+    'pl': defaultVars.pageLoadTraceId
+  };
+  addMetaDataToBeacon(beacon);
+  sendBeacon(beacon);
+}
+
+function processCommand(command) {
+  switch (command[0]) {
+    case 'apiKey':
+      defaultVars.apiKey = command[1];
+      break;
+    case 'key':
+      defaultVars.apiKey = command[1];
+      break;
+    case 'reportingUrl':
+      defaultVars.reportingUrl = command[1];
+      break;
+    case 'meta':
+      defaultVars.meta[command[1]] = command[2];
+      break;
+    case 'traceId':
+      defaultVars.pageLoadBackendTraceId = command[1];
+      break;
+    case 'ignoreUrls':
+      {
+        validateIgnoreUrls(command[1]);
+      }
+      defaultVars.ignoreUrls = command[1];
+      break;
+    case 'manualPageLoadEvent':
+      defaultVars.manualPageLoadEvent = true;
+      break;
+    case 'triggerPageLoad':
+      defaultVars.manualPageLoadTriggered = true;
+      triggerManualPageLoad();
+      break;
+    case 'xhrTransmissionTimeout':
+      defaultVars.xhrTransmissionTimeout = command[1];
+      break;
+    case 'startSpaPageTransition':
+      startSpaPageTransition();
+      break;
+    case 'endSpaPageTransition':
+      endSpaPageTransition(command[1]);
+      break;
+    case 'autoClearResourceTimings':
+      defaultVars.autoClearResourceTimings = command[1];
+      break;
+    case 'page':
+      defaultVars.page = command[1];
+      break;
+    case 'ignorePings':
+      defaultVars.ignorePings = command[1];
+      break;
+    case 'sampleRate':
+      defaultVars.sampleRate = command[1];
+      break;
+    default:
+      {
+        warn('Unsupported command: ' + command[0]);
+      }
+      break;
+  }
+}
+
+function validateIgnoreUrls(ignoreUrls) {
+  if (!(ignoreUrls instanceof Array)) {
+    return warn('ignoreUrls is not an array. This will result in errors.');
+  }
+
+  for (var i = 0, len = ignoreUrls.length; i < len; i++) {
+    if (!(ignoreUrls[i] instanceof RegExp)) {
+      return warn('ignoreUrls[' + i + '] is not a RegExp. This will result in errors.');
+    }
+  }
+}
+
+var state$3 = {
+  onEnter: function () {
+    if (!fulfillsPrerequisites()) {
+      {
+        return warn('Browser does not have all the required features for web EUM.');
+      }
+    }
+
+    var globalObjectName = win[defaultVars.nameOfLongGlobal];
+    var globalObject = win[globalObjectName];
+
+    if (!globalObject) {
+      {
+        warn('global ' + defaultVars.nameOfLongGlobal + ' not found. Did you use the initializer?');
+      }
+      return;
+    }
+
+    if (!globalObject.q) {
+      {
+        warn('Command queue not defined. Did you add the tracking script multiple times to your website?');
+      }
+      return;
+    }
+
+    if (typeof globalObject['l'] !== 'number') {
+      {
+        warn('Reference timestamp not set via EUM initializer. Was the initializer modified?');
+      }
+      return;
+    }
+
+    processCommands(globalObject.q);
+
+    defaultVars.initializerExecutionTimestamp = globalObject['l'];
+
+    addCommandAfterInitializationSupport();
+
+    if (defaultVars.reportingUrl) {
+      instrumentXMLHttpRequest();
+      hookIntoGlobalErrorEvent();
+      transitionTo('waitForPageLoad');
+    } else {
+      error('No reporting URL configured. Aborting EUM initialization.');
+    }
+  },
+  getActiveTraceId: function () {
+    return null;
+  },
+  triggerManualPageLoad: function () {
+    {
+      warn('Triggering a page load while EUM is initializing is unsupported.');
+    }
+  },
+  startSpaPageTransition: function () {
+    {
+      warn('Triggering an SPA page transition is unsupported while EUM is initializing.');
+    }
+  },
+
+
+  /* eslint-disable no-unused-vars */
+  endSpaPageTransition: function (opts) {
+    /* eslint-enable no-unused-vars */
+    {
+      warn('SPA page transitions are unsupported while EUM is initializing.');
+    }
+  }
+};
+function processCommands(commands) {
+  for (var i = 0, len = commands.length; i < len; i++) {
+    processCommand(commands[i]);
+  }
+}
+
+function addCommandAfterInitializationSupport() {
+  var globalObjectName = win[defaultVars.nameOfLongGlobal];
+  win[globalObjectName] = function () {
+    processCommand(arguments);
+  };
+}
+
+function fulfillsPrerequisites() {
+  return win.XMLHttpRequest && win.JSON;
+}
+
+registerState('init', state$3);
+registerState('waitForPageLoad', state);
+registerState('pageLoaded', state$2);
+registerState('spaTransition', state$1);
+
+transitionTo('init');
 
 }());
-//# sourceMappingURL=eum.debug.js.map
diff --git a/stagemonitor-web-servlet/src/main/resources/eum.min.js b/stagemonitor-web-servlet/src/main/resources/eum.min.js
index 42c13e0d..f100e160 100644
--- a/stagemonitor-web-servlet/src/main/resources/eum.min.js
+++ b/stagemonitor-web-servlet/src/main/resources/eum.min.js
@@ -1,14 +1,17 @@
-(function(){(function(){function K(){for(var a='',b=0;16>b;b++)a+=R[Math.round(15*Math.random())];return a}function p(){return(new Date).getTime()}function S(a,b){a.addEventListener?a.addEventListener('load',b,!1):a.attachEvent&&a.attachEvent('onload',b)}function L(){m.time=p();var a=m.time,b=B[m.name];if(b)for(var c=0,d=b.length;c<d;c++)b[c](a)}function M(a,b){v[a]=b}function C(a){D=a;v[a].w()}function T(){C('pageLoaded')}function x(){this.root={}}function E(a){var b=[],c;for(c in a)F.call(a,c)&&b.push(c);return b}
-function U(a){var b=[Math.round(a.startTime-d.B),Math.round(a.duration),N[a.initiatorType]||N.other];'number'===typeof a.transferSize&&'number'===typeof a.encodedBodySize&&0<a.encodedBodySize&&(0===a.transferSize?b.push(G.I):a.transferSize<a.encodedBodySize?b.push(G.R):b.push(G.K),b.push(a.encodedBodySize));return b.join(',')}function H(a){for(var b in d.i)F.call(d.i,b)&&(a['m_'+b]=d.i[b])}function y(a){var b='',c;for(c in a)F.call(a,c)&&null!=a[c]&&(b+='&'+O(c)+'='+O(String(a[c])));a=b.substring(1);
-0!==a.length&&(e&&2E3<a.length?(b=new e,b.open('POST',String(d.o),!0),b.setRequestHeader('Content-type','application/x-www-form-urlencoded'),b.send(a)):(new Image).src=String(d.o)+'?'+a)}function V(){function a(){function a(a){h||0!==f.st||(f.st=a,f.d=p()-(f.ts+d.b),y(f))}var c=new e,q=c.open,k=c.send,f={r:d.b,k:d.f,ts:0,d:0,ty:'xhr',pl:d.j,l:g.location.href,m:'',u:'',a:1,st:0,e:void 0};H(f);var h=!1;c.addEventListener('timeout',function(){h||a(w.timeout)});c.addEventListener('error',function(b){h||
-(b=b&&(b.error&&b.error.message||b.message),'string'===typeof b&&(f.e=b.substring(0,300)),a(w.error))});c.addEventListener('abort',function(){h||a(w.abort)});c.addEventListener('readystatechange',function(){if(!h&&4===c.readyState){var b=void 0;try{b=c.status}catch(Z){a(w.error);return}0!==b&&a(b)}});c.open=function(a,b,k){a:{for(var e=b,r=0,l=d.v.length;r<l;r++)if(d.v[r].test(e)){h=!0;break a}h=!1}if(h)return q.apply(c,arguments);void 0===k&&(k=!0);e=v[D].g();r=I();e||(e=r);f.t=e;f.s=r;f.m=a;f.u=
-b;f.a=k?1:0;try{var m=q.apply(c,arguments),n;try{var t=document.createElement('a');t.href=b;var u=g.location;n=(t.protocol&&':'!==t.protocol?t.protocol:u.protocol)===u.protocol&&(t.hostname||u.hostname)===u.hostname&&(t.port||u.port)===u.port}catch(J){n=!1}n&&(c.setRequestHeader('X-INSTANA-T',e),c.setRequestHeader('X-INSTANA-S',r),c.setRequestHeader('X-INSTANA-L','1'));return m}catch(J){throw f.ts=p()-d.b,f.st=w.O,f.e=J.message,y(f),J;}};c.send=function(){if(h)return k.apply(c,arguments);f.ts=p()-
-d.b;return k.apply(c,arguments)};return c}e&&(new e).addEventListener&&(a.prototype=e.prototype,a.DONE=e.DONE,a.HEADERS_RECEIVED=e.HEADERS_RECEIVED,a.LOADING=e.LOADING,a.OPENED=e.OPENED,a.UNSENT=e.UNSENT,g.XMLHttpRequest=a)}function W(){var a=g.onerror;g.onerror=function(b,c,d,k,f){var h=f&&f.stack;h||(h='at '+c+' '+d+':'+k);var q=b;if(q&&!(100<P)){20<=z&&(n={},z=0);var q=String(q).substring(0,300),h=String(h||'').split('\n').slice(0,30).join('\n'),e=g.location.href,l=v[D].g(),m=q+h+e+l,p=n[m];p?
-p.A++:(n[m]={message:q,stack:h,location:e,P:l,A:1,G:0},z++);A||(A=setTimeout(X,1E3))}if('function'===typeof a)return a.apply(this,arguments)}}function X(){clearTimeout(A);A=null;for(var a in n)if(n.hasOwnProperty(a)){var b=n[a];if(b.A>b.G){var c=I(),b={k:d.f,s:c,t:b.P||c,ts:p(),ty:'err',pl:d.j,l:b.location,e:b.message,st:b.stack,c:b.A-b.G};H(b);y(b);P++}}n={};z=0}var g=window,O=g.encodeURIComponent,e=g.XMLHttpRequest,F=Object.prototype.hasOwnProperty,R='0123456789abcdef'.split('');g.crypto&&g.crypto.getRandomValues&&
-g.Uint32Array&&(K=function(){var a=new g.Uint32Array(2);g.crypto.getRandomValues(a);return a[0].toString(16)+a[1].toString(16)});var I=K,B={},m={name:'e:onLoad',time:null,L:function(){if('complete'===document.readyState)return L();S(g,function(){setTimeout(L,0)})}},v={},D=void 0,l=g.performance||g.V||g.T||g.S,Q=l&&l.timing,Y=l&&l.getEntriesByType,d={N:'EumObject',j:I(),D:null,b:p(),B:l&&l.now?l.now():0,h:p(),o:null,f:null,i:{},v:[]};x.prototype.H=function(a,b){this.C(this.root,a.split(''),0,b)};x.prototype.C=
-function(a,b,c,d){var g=b[c];null==g?(a['<END>']=a['<END>']||[]).push(d):(a=a[g]=a[g]||{},this.C(a,b,c+1,d))};x.prototype.F=function(a){a=a||this.root;var b=E(a);if(1===b.length&&'<END>'===b[0])return a['<END>'].slice();for(var c={},d=0,g=b.length;d<g;d++){var f=b[d],h=a[f];if('<END>'===f)c.$=h.slice();else{for(var h=f,f=a[f],e=E(f);1===e.length&&'<END>'!==e[0];)h+=e[0],f=f[e[0]],e=E(f);c[h]=this.F(f)}}return c};var N={other:0,img:1,link:2,script:3,css:4,xmlhttprequest:5,html:6,image:7},G={U:0,I:1,
-R:2,K:3},w={timeout:-100,abort:-101,O:-102,error:-103},P=0,z=0,n={},A=void 0;v.init={w:function(){var a=g[g[d.N]];if(a)for(var b=a.q,c=0,e=b.length;c<e;c++){var k=b[c];switch(k[0]){case 'apiKey':d.f=k[1];break;case 'reportingUrl':d.o=k[1];break;case 'meta':d.i[k[1]]=k[2];break;case 'traceId':d.D=k[1];break;case 'ignoreUrls':d.v=k[1]}}'number'===typeof a.l&&(d.h=a.l,d.o&&(V(),W(),C('waitForPageLoad')))},g:function(){return null}};M('waitForPageLoad',{w:function(){var a=m.name;(B[a]=B[a]||[]).push(T);
-m.L()},g:function(){return d.j}});M('pageLoaded',{w:function(){var a={ty:'pl'};a.r=d.b;a.k=d.f;a.t=d.j;a.bt=d.D;a.u=g.location.href;H(a);if(Q){var b=l.timing,c=b.redirectEnd-b.redirectStart,e=b.fetchStart-c;a.ts=e-d.b;0<b.loadEventStart?a.d=b.loadEventStart-b.fetchStart:(a.d=Number(m.time)-d.h,a.tim='0');a.t_unl=b.unloadEventEnd-b.unloadEventStart;a.t_red=c;a.t_apc=b.domainLookupStart-b.fetchStart;a.t_dns=b.domainLookupEnd-b.domainLookupStart;a.t_tcp=b.connectEnd-b.connectStart;a.t_req=b.responseStart-
-b.requestStart;a.t_rsp=b.responseEnd-b.responseStart;a.t_pro=b.loadEventStart-b.responseEnd;a.t_loa=b.loadEventEnd-b.loadEventStart;b=null;g.chrome&&g.chrome.loadTimes?b=1E3*g.chrome.loadTimes().firstPaintTime:'number'===typeof g.performance.timing.M?b=g.performance.timing.M:'number'===typeof g.performance.timing.J&&(b=g.performance.timing.J);null!=b&&0!==b&&(a.t_fp=Math.round(b-e))}else a.ts=d.h-d.b,a.d=Number(m.time)-d.h,Q||(a.tim='0');if(Y&&g.JSON){for(var e=l.getEntriesByType('resource'),b=new x,
-c=0,k=e.length;c<k;c++){var f=e[c],h=f.name;255<h.length&&(h=h.substring(0,255));('xmlhttprequest'!==f.initiatorType||f.startTime<d.B)&&b.H(h,U(f))}e=b.F();a.res=g.JSON.stringify(e)}y(a)},g:function(){return null}});C('init')})();})();
-//# sourceMappingURL=eum.min.js.map
+(function(){(function(){function O(){for(var a='',b=0;16>b;b++)a+=aa[Math.round(15*Math.random())];return a}function u(){return(new Date).getTime()}function ba(a,b){a.addEventListener?a.addEventListener('load',b,!1):a.attachEvent&&a.attachEvent('onload',b)}function P(){v.time=u();var a=v.time,b=H[v.name];if(b)for(var d=0,c=b.length;d<c;d++)b[d](a)}function I(a,b){w[a]=b}function n(a){y=a;w[a].v()}function Q(){n('pageLoaded')}function D(){this.root={}}function J(a){var b=[],d;for(d in a)K.call(a,d)&&b.push(d);
+return b}function R(a,b){if(S&&e.JSON){var d;d=m.getEntriesByType('resource');for(var p=new D,g=0,f=d.length;g<f;g++){var h=d[g];if(!(null!=b&&h.startTime-c.C+c.b<b)){var k=h.name,x=k.toLowerCase();'about:blank'!==x&&0!==x.indexOf('javascript:')&&(255<k.length&&(k=k.substring(0,255)),('xmlhttprequest'!==h.initiatorType||h.startTime<c.C)&&p.R(k,ca(h)))}}d=p.N();a.res=e.JSON.stringify(d);c.G&&m.clearResourceTimings&&m.clearResourceTimings()}}function ca(a){var b=[Math.round(a.startTime-c.C),Math.round(a.duration),
+T[a.initiatorType]||T.other];'number'===typeof a.transferSize&&'number'===typeof a.encodedBodySize&&0<a.transferSize&&(0===a.transferSize?b.push(L.S):a.transferSize<a.encodedBodySize?b.push(L.Z):b.push(L.U),b.push(a.encodedBodySize));return b.join(',')}function A(a){for(var b in c.o)K.call(c.o,b)&&(a['m_'+b]=c.o[b])}function z(a){var b='',d;for(d in a)K.call(a,d)&&null!=a[d]&&(b+='&'+U(d)+'='+U(String(a[d])));a=b.substring(1);0!==a.length&&(l&&2E3<a.length?(b=new l,b.open('POST',String(c.w),!0),b.setRequestHeader('Content-type',
+'application/x-www-form-urlencoded;charset=UTF-8'),b.timeout=c.P,b.send(a)):(new Image).src=String(c.w)+'?'+a)}function M(){if(!N)return c.j;var a=m.timing;return a.fetchStart-(a.redirectEnd-a.redirectStart)}function V(a,b){var d=null;e.chrome&&e.chrome.loadTimes?d=1E3*e.chrome.loadTimes().firstPaintTime:'number'===typeof e.performance.timing.W?d=e.performance.timing.W:'number'===typeof e.performance.timing.T&&(d=e.performance.timing.T);null!=d&&0!==d&&(a.t_fp=Math.round(d-b))}function da(){function a(){function a(a){h||
+0!==f.st||(f.st=a,f.d=u()-(f.ts+c.b),z(f))}var d=new l,g=d.open,q=d.send,f={r:c.b,k:c.f,ts:0,d:0,ty:'xhr',pl:c.g,l:e.location.href,m:'',u:'',a:1,st:0,e:void 0};A(f);var h=!1;d.addEventListener('timeout',function(){h||a(B.timeout)});d.addEventListener('error',function(b){h||(b=b&&(b.error&&b.error.message||b.message),'string'===typeof b&&(f.e=b.substring(0,300)),a(B.error))});d.addEventListener('abort',function(){h||a(B.abort)});d.addEventListener('readystatechange',function(){if(!h&&4===d.readyState){var b=
+void 0;try{b=d.status}catch(x){a(B.error);return}0!==b&&a(b)}});d.open=function(a,b,p){a:{var k=b;if(c.H&&ea.test(k))h=!0;else{for(var q=0,m=c.D.length;q<m;q++)if(c.D[q].test(k)){h=!0;break a}h=!1}}if(h)return g.apply(d,arguments);void 0===p&&(p=!0);k=w[y].h();q=C();k||(k=q);m=Math.random()<=c.sampleRate?1:0;f.t=k;f.s=q;f.m=a;var l;var x=b;if(t)try{t.href=x,l=t.href}catch(E){l=x}else l=x;f.u=l;f.a=p?1:0;f.sp=m;try{var v=g.apply(d,arguments),r;if(t)try{t.href=b;var n=e.location;r=(t.protocol&&':'!==
+t.protocol?t.protocol:n.protocol)===n.protocol&&(t.hostname||n.hostname)===n.hostname&&(t.port||n.port)===n.port}catch(E){r=!1}else r=!1;r&&(d.setRequestHeader('X-INSTANA-T',k),d.setRequestHeader('X-INSTANA-S',q),d.setRequestHeader('X-INSTANA-L',m));return v}catch(E){throw f.ts=u()-c.b,f.st=B.X,f.e=E.message,z(f),E;}};d.send=function(){if(h)return q.apply(d,arguments);f.ts=u()-c.b;f.p=c.page;return q.apply(d,arguments)};return d}l&&(new l).addEventListener&&(a.prototype=l.prototype,a.DONE=l.DONE,
+a.HEADERS_RECEIVED=l.HEADERS_RECEIVED,a.LOADING=l.LOADING,a.OPENED=l.OPENED,a.UNSENT=l.UNSENT,e.XMLHttpRequest=a)}function fa(){var a=e.onerror;e.onerror=function(b,d,g,q,f){var h=f&&f.stack;h||(h='at '+d+' '+g+':'+q);var k=b;if(!W){W=!0;var p={k:c.f,t:C(),ts:M(),p:c.page,ty:'epv',pl:c.g};A(p);z(p)}if(k&&!(100<X)){20<=F&&(r={},F=0);var k=String(k).substring(0,300),h=String(h||'').split('\n').slice(0,30).join('\n'),p=e.location.href,m=w[y].h(),l=k+h+p+m,n=r[l];n?n.F++:(r[l]={message:k,stack:h,location:p,
+Y:m,F:1,O:0},F++);G||(G=setTimeout(ga,1E3))}if('function'===typeof a)return a.apply(this,arguments)}}function ga(){clearTimeout(G);G=null;for(var a in r)if(r.hasOwnProperty(a)){var b=r[a];if(b.F>b.O){var d=C(),b={k:c.f,s:d,t:b.Y||d,ts:u(),p:c.page,ty:'err',pl:c.g,l:b.location,e:b.message,st:b.stack,c:b.F-b.O};A(b);z(b);X++}}r={};F=0}function Y(a){switch(a[0]){case 'apiKey':c.f=a[1];break;case 'key':c.f=a[1];break;case 'reportingUrl':c.w=a[1];break;case 'meta':c.o[a[1]]=a[2];break;case 'traceId':c.M=
+a[1];break;case 'ignoreUrls':c.D=a[1];break;case 'manualPageLoadEvent':c.J=!0;break;case 'triggerPageLoad':c.K=!0;w[y].B();break;case 'xhrTransmissionTimeout':c.P=a[1];break;case 'startSpaPageTransition':w[y].A();break;case 'endSpaPageTransition':w[y].i(a[1]);break;case 'autoClearResourceTimings':c.G=a[1];break;case 'page':c.page=a[1];break;case 'ignorePings':c.H=a[1];break;case 'sampleRate':c.sampleRate=a[1]}}function ha(){e[e[c.L]]=function(){Y(arguments)}}var e=window,U=e.encodeURIComponent,l=
+e.XMLHttpRequest,K=Object.prototype.hasOwnProperty,aa='0123456789abcdef'.split('');e.crypto&&e.crypto.getRandomValues&&e.Uint32Array&&(O=function(){var a=new e.Uint32Array(2);e.crypto.getRandomValues(a);return a[0].toString(16)+a[1].toString(16)});var C=O,H={},v={name:'e:onLoad',time:null,V:function(){if('complete'===document.readyState)return P();ba(e,function(){setTimeout(P,0)})}},w={},y=void 0,m=e.performance||e.da||e.ba||e.aa,N=m&&m.timing,S=m&&m.getEntriesByType,c={L:'EumObject',g:C(),M:null,
+b:u(),C:m&&m.now?m.now():0,j:u(),w:null,f:null,o:{},D:[],H:!0,P:2E4,J:!1,K:!1,G:!0,page:void 0,sampleRate:1},ia={v:function(){if(!c.J||c.K){var a=v.name;(H[a]=H[a]||[]).push(Q);v.V()}},h:function(){return c.g},B:Q,A:function(){},i:function(){}};D.prototype.R=function(a,b){this.I(this.root,a.split(''),0,b)};D.prototype.I=function(a,b,d,c){var e=b[d];null==e?(a['<END>']=a['<END>']||[]).push(c):(a=a[e]=a[e]||{},this.I(a,b,d+1,c))};D.prototype.N=function(a){a=a||this.root;var b=J(a);if(1===b.length&&
+'<END>'===b[0])return a['<END>'].slice();for(var c={},e=0,g=b.length;e<g;e++){var f=b[e],h=a[f];if('<END>'===f)c.$=h.slice();else{for(var h=f,f=a[f],k=J(f);1===k.length&&'<END>'!==k[0];)h+=k[0],f=f[k[0]],k=J(f);c[h]=this.N(f)}}return c};var T={other:0,img:1,link:2,script:3,css:4,xmlhttprequest:5,html:6,image:7},L={ca:0,S:1,Z:2,U:3},g={},Z=!1,ea=/.*\/ping(\/?$|\?.*)/i,B={timeout:-100,abort:-101,X:-102,error:-103},t=null;try{t=document.createElement('a')}catch(a){}var X=0,W=!1,F=0,r={},G=void 0;I('init',
+{v:function(){var a=e[e[c.L]];if(a&&a.q&&'number'===typeof a.l){for(var b=a.q,d=0,g=b.length;d<g;d++)Y(b[d]);c.j=a.l;ha();c.w&&(da(),fa(),n('waitForPageLoad'))}},h:function(){return null},B:function(){},A:function(){},i:function(){}});w.waitForPageLoad=ia;I('pageLoaded',{v:function(){if(!Z){Z=!0;var a={ty:'pl'};a.r=c.b;a.k=c.f;a.t=c.g;a.p=c.page;a.bt=c.M;a.u=e.location.href;A(a);if(N){var b=m.timing,d=b.redirectEnd-b.redirectStart,g=M();a.ts=g-c.b;0<b.loadEventStart?a.d=b.loadEventStart-b.fetchStart:
+(a.d=Number(v.time)-c.j,a.tim='0');a.t_unl=b.unloadEventEnd-b.unloadEventStart;a.t_red=d;a.t_apc=b.domainLookupStart-b.fetchStart;a.t_dns=b.domainLookupEnd-b.domainLookupStart;null!=b.secureConnectionStart&&0<b.secureConnectionStart?(a.t_tcp=b.secureConnectionStart-b.connectStart,a.t_ssl=b.connectEnd-b.secureConnectionStart):(a.t_tcp=b.connectEnd-b.connectStart,a.t_ssl=0);a.t_req=b.responseStart-b.requestStart;a.t_rsp=b.responseEnd-b.responseStart;a.t_dom=b.domContentLoadedEventStart-b.domLoading;
+a.t_chi=b.loadEventEnd-b.domContentLoadedEventStart;a.t_bac=b.responseStart-g;a.t_fro=b.loadEventEnd-b.responseStart;if(S){for(var b=m.getEntriesByType('paint'),d=!1,l=0;l<b.length;l++){var f=b[l];switch(f.name){case 'first-paint':a.t_fp=f.startTime|0;d=!0;break;case 'first-contentful-paint':a.t_fcp=f.startTime|0}}d||V(a,g)}else V(a,g)}else a.ts=M()-c.b,a.d=Number(v.time)-c.j,N||(a.tim='0');R(a);z(a)}},h:function(){return null},B:function(){},A:function(){n('spaTransition')},i:function(){}});I('spaTransition',
+{v:function(){g.k=c.f;g.r=c.b;g.t=C();g.ts=u();g.ty='spa';g.pl=c.g},h:function(){return g.t},B:function(){},A:function(){n('spaTransition')},i:function(a){g.p=c.page;g.l=a.url;g.e=a.explanation;g.d=u()-g.ts;switch(a.status){case 'completed':g.s='c';break;case 'aborted':g.s='a';break;case 'error':g.s='e';break;default:g.s='u'}A(g);R(g,g.ts-1);z(g);n('pageLoaded')}});n('init')})();})();
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestDoNotTrackTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestDoNotTrackTest.java
index de2410e0..73d48b6d 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestDoNotTrackTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestDoNotTrackTest.java
@@ -23,6 +23,7 @@
 
 import io.opentracing.Scope;
 import io.opentracing.mock.MockTracer;
+import io.opentracing.tag.Tags;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -78,7 +79,7 @@ public void testHonorDoNotTrack() throws Exception {
 		Scope activeScope = new MonitoredHttpRequest(request, mock(StatusExposingByteCountingServletResponse.class),
 				mock(FilterChain.class), configuration, mock(ExecutorService.class)).createScope();
 		SpanWrapper span = SpanContextInformation.getCurrent().getSpanWrapper();
-		assertThat(span.isSampled()).isFalse();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isEqualTo(0);
 		activeScope.close();
 	}
 
@@ -90,7 +91,7 @@ public void testDoNotTrackDisabled() throws Exception {
 		Scope activeScope = new MonitoredHttpRequest(request, mock(StatusExposingByteCountingServletResponse.class),
 				mock(FilterChain.class), configuration, mock(ExecutorService.class)).createScope();
 		SpanWrapper span = SpanContextInformation.getCurrent().getSpanWrapper();
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 		activeScope.close();
 	}
 
@@ -101,7 +102,7 @@ public void testNoDoNotTrackHeader() throws Exception {
 		Scope activeScope = new MonitoredHttpRequest(request, mock(StatusExposingByteCountingServletResponse.class),
 				mock(FilterChain.class), configuration, mock(ExecutorService.class)).createScope();
 		SpanWrapper span = SpanContextInformation.getCurrent().getSpanWrapper();
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 		activeScope.close();
 	}
 
@@ -113,7 +114,7 @@ public void testDontHonorDoNotTrack() throws Exception {
 		Scope activeScope = new MonitoredHttpRequest(request, mock(StatusExposingByteCountingServletResponse.class),
 				mock(FilterChain.class), configuration, mock(ExecutorService.class)).createScope();
 		SpanWrapper span = SpanContextInformation.getCurrent().getSpanWrapper();
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 		activeScope.close();
 	}
 
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestTest.java
index 4a34e2bf..c83cb978 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/MonitoredHttpRequestTest.java
@@ -29,6 +29,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
@@ -55,6 +56,7 @@ public void setUp() throws Exception {
 		when(tracingPlugin.getTracer()).thenReturn(new SpanWrappingTracer(tracer, spanEventListenerFactories));
 		final RequestMonitor requestMonitor = mock(RequestMonitor.class);
 		when(tracingPlugin.getRequestMonitor()).thenReturn(requestMonitor);
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		assertThat(tracer.scopeManager().active()).isNull();
 	}
 
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanLongTagProcessorTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanLongTagProcessorTest.java
index 222a1c1e..7f88f2ab 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanLongTagProcessorTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanLongTagProcessorTest.java
@@ -11,6 +11,7 @@
 
 import io.opentracing.mock.MockSpan;
 import io.opentracing.mock.MockTracer;
+import io.opentracing.tag.Tags;
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -37,7 +38,7 @@ public void testProcessSpan_withValidLongValueReturnsThatValue() throws Exceptio
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags().get(TAG)).isEqualTo(123L);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	private void addServletParameter(String parameterValue) {
@@ -57,7 +58,7 @@ public void testProcessSpan_withInvalidValueReturnsNull() throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags()).doesNotContainKey(TAG);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	@Test
@@ -74,7 +75,7 @@ public void testProcessSpan_withUpperIgnoresIfGreater()  throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags()).doesNotContainKeys(TAG);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	@Test
@@ -92,7 +93,7 @@ public void testProcessSpan_withUpperBoundDiscardsIfGreater()  throws Exception
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags()).doesNotContainKeys(TAG);
-		assertThat(span.isSampled()).isFalse();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isEqualTo(0);
 	}
 
 	@Test
@@ -110,7 +111,7 @@ public void testProcessSpan_withUpperBoundAllowingIfEquals()  throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags().get(TAG)).isEqualTo(6L);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	@Test
@@ -127,7 +128,7 @@ public void testProcessSpan_withLowerBoundIgnoresIfLower()  throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags()).doesNotContainKeys(TAG);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	@Test
@@ -145,7 +146,7 @@ public void testProcessSpan_withLowerBoundDiscardsIfLower()  throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags()).doesNotContainKeys(TAG);
-		assertThat(span.isSampled()).isFalse();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isEqualTo(0);
 	}
 
 	@Test
@@ -163,7 +164,7 @@ public void testProcessSpan_withLowerBoundAllowingIfEquals()  throws Exception {
 		assertThat(mockTracer.finishedSpans()).hasSize(1);
 		MockSpan mockSpan = mockTracer.finishedSpans().get(0);
 		assertThat(mockSpan.tags().get(TAG)).isEqualTo(5L);
-		assertThat(span.isSampled()).isTrue();
+		assertThat(span.getNumberTag(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	private SpanWrapper runProcessor(ClientSpanLongTagProcessor clientSpanLongTagProcessor) {
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanServletTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanServletTest.java
index cf80d118..12ed0356 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanServletTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/eum/ClientSpanServletTest.java
@@ -9,9 +9,7 @@
 import org.stagemonitor.tracing.TracingPlugin;
 import org.stagemonitor.tracing.reporter.ReportingSpanEventListener;
 import org.stagemonitor.tracing.tracing.B3Propagator;
-import org.stagemonitor.tracing.wrapper.SpanWrapper;
 import org.stagemonitor.tracing.wrapper.SpanWrappingTracer;
-import org.stagemonitor.tracing.wrapper.StatelessSpanEventListener;
 import org.stagemonitor.web.servlet.ServletPlugin;
 import org.stagemonitor.web.servlet.eum.ClientSpanMetadataTagProcessor.ClientSpanMetadataDefinition;
 
@@ -54,24 +52,18 @@
 	private MockTracer mockTracer;
 	private ClientSpanServlet servlet;
 	private ServletPlugin servletPlugin;
-	private Integer samplingPriority;
 	private ReportingSpanEventListener reportingSpanEventListener;
+	private TracingPlugin tracingPlugin;
 
 	@Before
 	public void setUp() {
-		samplingPriority = 1;
 		mockTracer = new MockTracer(new ThreadLocalScopeManager(), new B3Propagator());
-		TracingPlugin tracingPlugin = mock(TracingPlugin.class);
+		tracingPlugin = mock(TracingPlugin.class);
 		SpanWrappingTracer spanWrappingTracer = new SpanWrappingTracer(mockTracer, asList(
 				new SpanContextInformation.SpanContextSpanEventListener(),
-				new SpanContextInformation.SpanFinalizer(),
-				new StatelessSpanEventListener() {
-					@Override
-					public void onStart(SpanWrapper spanWrapper) {
-						Tags.SAMPLING_PRIORITY.set(spanWrapper, samplingPriority);
-					}
-				}));
+				new SpanContextInformation.SpanFinalizer()));
 		when(tracingPlugin.getTracer()).thenReturn(spanWrappingTracer);
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		reportingSpanEventListener = mock(ReportingSpanEventListener.class);
 		when(tracingPlugin.getReportingSpanEventListener()).thenReturn(reportingSpanEventListener);
 		servletPlugin = mock(ServletPlugin.class);
@@ -221,7 +213,8 @@ public void testConvertWeaselBeaconToSpan_withNegativeRedirectTimeIsDiscarded()
 	@Test
 	public void testConvertWeaselBeaconToSpan_skipsTagProcessorsIfSpanIsNotSampled() throws ServletException, IOException {
 		// Given
-		samplingPriority = 0;
+		when(tracingPlugin.isSampled(any())).thenReturn(false);
+
 		MockHttpServletRequest mockHttpServletRequest = new MockHttpServletRequest();
 		mockHttpServletRequest.setParameter("ty", "pl");
 		mockHttpServletRequest.setParameter("r", "1496751574200");
@@ -250,7 +243,6 @@ public void testConvertWeaselBeaconToSpan_skipsTagProcessorsIfSpanIsNotSampled()
 			MockSpan span = finishedSpans.get(0);
 			softly.assertThat(span.tags())
 					.containsEntry("type", "pageload")
-					.containsEntry(Tags.SAMPLING_PRIORITY.getKey(), 0)
 					.doesNotContainKeys(TIMING_UNLOAD, TIMING_REDIRECT, TIMING_APP_CACHE_LOOKUP, TIMING_DNS_LOOKUP,
 							TIMING_TCP, TIMING_REQUEST, TIMING_RESPONSE, TIMING_PROCESSING, TIMING_LOAD,
 							TIMING_TIME_TO_FIRST_PAINT, TIMING_RESOURCE);
@@ -404,7 +396,7 @@ public void testConvertWeaselBeaconToSpan_withXHRBeacon() throws ServletExceptio
 		mockHttpServletRequest.setParameter("pl", "d58cddae830273d1");
 		mockHttpServletRequest.setParameter("l", "http://localhost:9966/petclinic/");
 		mockHttpServletRequest.setParameter("m", "GET");
-		mockHttpServletRequest.setParameter("u", "owners.html?lastName=");
+		mockHttpServletRequest.setParameter("u", "http://localhost:9966/petclinic/owners.html?lastName=");
 		mockHttpServletRequest.setParameter("a", "1");
 		mockHttpServletRequest.setParameter("st", "200");
 		mockHttpServletRequest.setParameter("e", "undefined");
@@ -420,7 +412,7 @@ public void testConvertWeaselBeaconToSpan_withXHRBeacon() throws ServletExceptio
 			final List<MockSpan> finishedSpans = mockTracer.finishedSpans();
 			softly.assertThat(finishedSpans).hasSize(1);
 			MockSpan span = finishedSpans.get(0);
-			softly.assertThat(span.operationName()).isEqualTo("/petclinic/");
+			softly.assertThat(span.operationName()).isEqualTo("/petclinic/owners.html");
 			softly.assertThat(span.finishMicros() - span.startMicros()).isEqualTo(TimeUnit.MILLISECONDS.toMicros(2084L));
 
 			softly.assertThat(span.tags())
@@ -428,7 +420,7 @@ public void testConvertWeaselBeaconToSpan_withXHRBeacon() throws ServletExceptio
 					.containsEntry("type", "ajax")
 					.containsEntry("http.status_code", 200L)
 					.containsEntry("method", "GET")
-					.containsEntry("xhr.requested_url", "owners.html?lastName=")
+					.containsEntry("xhr.requested_url", "http://localhost:9966/petclinic/owners.html?lastName=")
 					.containsEntry("xhr.requested_from", "http://localhost:9966/petclinic/")
 					.containsEntry("xhr.async", true)
 					.containsEntry("duration_ms", 2084L)
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/filter/HttpRequestMonitorFilterTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/filter/HttpRequestMonitorFilterTest.java
index 3904ad01..a98dc0c6 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/filter/HttpRequestMonitorFilterTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/filter/HttpRequestMonitorFilterTest.java
@@ -1,5 +1,7 @@
 package org.stagemonitor.web.servlet.filter;
 
+import com.codahale.metrics.health.HealthCheckRegistry;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -10,6 +12,8 @@
 import org.springframework.mock.web.MockHttpServletResponse;
 import org.stagemonitor.configuration.ConfigurationRegistry;
 import org.stagemonitor.core.CorePlugin;
+import org.stagemonitor.core.MeasurementSession;
+import org.stagemonitor.core.StagemonitorPlugin;
 import org.stagemonitor.core.metrics.metrics2.Metric2Registry;
 import org.stagemonitor.tracing.RequestMonitor;
 import org.stagemonitor.tracing.SpanContextInformation;
@@ -43,6 +47,7 @@
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.when;
 
 public class HttpRequestMonitorFilterTest {
 
@@ -76,6 +81,7 @@ public SpanContextInformation answer(InvocationOnMock invocation) throws Throwab
 		doReturn(true).when(servletPlugin).isClientSpanCollectionInjectionEnabled();
 		doReturn(true).when(corePlugin).isStagemonitorActive();
 		doReturn(1000000d).when(tracingPlugin).getProfilerRateLimitPerMinute();
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		final RequestMonitor requestMonitor = new RequestMonitor(configuration, mock(Metric2Registry.class));
 		doReturn(requestMonitor).when(tracingPlugin).getRequestMonitor();
 		final SpanWrappingTracer spanWrappingTracer = new SpanWrappingTracer(new MockTracer(new ThreadLocalScopeManager(), new B3Propagator()),
@@ -87,6 +93,8 @@ public SpanContextInformation answer(InvocationOnMock invocation) throws Throwab
 		doReturn(spanWrappingTracer).when(tracingPlugin).getTracer();
 		doReturn("testApplication").when(corePlugin).getApplicationName();
 		doReturn("testInstance").when(corePlugin).getInstanceName();
+		servletPlugin.initializePlugin(new StagemonitorPlugin.InitArguments(mock(Metric2Registry.class), configuration,
+				mock(MeasurementSession.class), mock(HealthCheckRegistry.class)));
 
 		initFilter();
 		assertThat(tracingPlugin.getTracer().scopeManager().active()).isNull();
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/jaxrs/JaxRsRequestNameDeterminerTransformerTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/jaxrs/JaxRsRequestNameDeterminerTransformerTest.java
index 7df16ca9..f858db74 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/jaxrs/JaxRsRequestNameDeterminerTransformerTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/jaxrs/JaxRsRequestNameDeterminerTransformerTest.java
@@ -36,6 +36,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 import static org.stagemonitor.tracing.BusinessTransactionNamingStrategy.METHOD_NAME_SPLIT_CAMEL_CASE;
@@ -79,6 +80,7 @@ public void before() throws Exception {
 		when(tracingPlugin.getRateLimitSpansPerMinutePercentPerType()).thenReturn(Collections.emptyMap());
 		when(tracingPlugin.getProfilerRateLimitPerMinuteOption()).thenReturn(mock(ConfigurationOption.class));
 		when(tracingPlugin.getBusinessTransactionNamingStrategy()).thenReturn(METHOD_NAME_SPLIT_CAMEL_CASE);
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 
 		when(servletPlugin.getGroupUrls()).thenReturn(Collections.singletonMap(Pattern.compile("(.*).js$"), "*.js"));
 		requestMonitor = new RequestMonitor(configuration, registry);
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/spring/SpringRequestMonitorTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/spring/SpringRequestMonitorTest.java
index e728115e..e2e15d24 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/spring/SpringRequestMonitorTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/spring/SpringRequestMonitorTest.java
@@ -51,10 +51,8 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doReturn;
@@ -110,6 +108,7 @@ public void before() throws Exception {
 		when(tracingPlugin.getDefaultRateLimitSpansPercent()).thenReturn(1.0);
 		when(tracingPlugin.getRateLimitSpansPerMinutePercentPerType()).thenReturn(Collections.emptyMap());
 		when(tracingPlugin.getProfilerRateLimitPerMinuteOption()).thenReturn(mock(ConfigurationOption.class));
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 
 		when(servletPlugin.getGroupUrls()).thenReturn(Collections.singletonMap(Pattern.compile("(.*).js$"), "*.js"));
 		requestMonitor = new RequestMonitor(configuration, registry);
@@ -183,7 +182,7 @@ public void testRequestMonitorNonMvcRequestDoMonitor() throws Exception {
 		assertThat(registry.getTimers()).doesNotContainKey(getResponseTimeMetricName(spanContext.getOperationName(), "http"));
 		assertThat(registry.getTimers()).containsKey(getResponseTimeMetricName("All", "http"));
 		verify(monitoredRequest, times(1)).getRequestName();
-		assertTrue(spanContext.isSampled());
+		assertThat(tags.get(Tags.SAMPLING_PRIORITY.getKey())).isNotEqualTo(0);
 	}
 
 	@Test
@@ -196,7 +195,7 @@ public void testRequestMonitorNonMvcRequestDontMonitor() throws Exception {
 
 		assertNull(spanContext.getOperationName());
 		assertNull(registry.getTimers().get(name("response_time").operationName("GET *.js").operationType("http").build()));
-		assertFalse(spanContext.isSampled());
+		assertThat(tags.get(Tags.SAMPLING_PRIORITY.getKey())).isEqualTo(0);
 	}
 
 	private MonitoredHttpRequest createMonitoredHttpRequest(HttpServletRequest request) throws Exception {
diff --git a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/widget/SpanServletTest.java b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/widget/SpanServletTest.java
index a09eeb16..f0b3342a 100644
--- a/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/widget/SpanServletTest.java
+++ b/stagemonitor-web-servlet/src/test/java/org/stagemonitor/web/servlet/widget/SpanServletTest.java
@@ -63,6 +63,7 @@ public void setUp() throws Exception {
 		TracingPlugin tracingPlugin = mock(TracingPlugin.class);
 		when(tracingPlugin.getRequestMonitor()).thenReturn(mock(RequestMonitor.class));
 		when(tracingPlugin.getProfilerRateLimitPerMinuteOption()).thenReturn(mock(ConfigurationOption.class));
+		when(tracingPlugin.isSampled(any())).thenReturn(true);
 		when(configuration.getConfig(TracingPlugin.class)).thenReturn(tracingPlugin);
 
 		servletPlugin = mock(ServletPlugin.class);
