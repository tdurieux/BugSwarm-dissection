-- Test cases for fine-grained incremental checking
--
-- Test cases may define multiple versions of a file
-- (e.g. m.py, m.py.2). There is always an initial batch
-- pass that processes all files present initially, followed
-- by one or more fine-grained incremental passes that use
-- alternative versions of files, if available. If a file
-- just has a single .py version, it is used for all passes.

-- TODO: what if version for some passes but not all

-- Output is laid out like this:
--
--   [out]
--   <optional output from batch pass>
--   ==
--   <optional output from first incremental pass>
--
--
-- Modules that are expected to be detected as changed by dmypy_server
-- can be checked with [stale ...]
-- Generally this should mean added, deleted, or changed files, though there
-- are important edge cases related to the cache: deleted files won't be detected
-- as changed in the initial run with the cache while modules that depended on them
-- should be.
--
-- Modules that are require a full-module reprocessing by update can be checked with
-- [rechecked ...]. This should include any files detected as having changed as well
-- as any files that contain targets that need to be reprocessed but which haven't
-- been loaded yet. If there is no [rechecked...] directive, it inherits the value of
-- [stale ...].
--
-- Specifications for later runs can be given with [stale2 ...], [stale3 ...], etc.

[case testReprocessFunction]
import m
def g() -> int:
    return m.f()
[file m.py]
def f() -> int:
    pass
[file m.py.2]
def f() -> str:
    pass
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testReprocessTopLevel]
import m
m.f(1)
def g() -> None: pass
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def f(x: str) -> None: pass
[out]
==
main:2: error: Argument 1 to "f" has incompatible type "int"; expected "str"

[case testReprocessMethod]
import m
class B:
    def f(self, a: m.A) -> None:
        a.g() # E
[file m.py]
class A:
    def g(self) -> None: pass
[file m.py.2]
class A:
    def g(self, a: A) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "A"

[case testFunctionMissingModuleAttribute]
import m
def h() -> None:
    m.f(1)
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def g(x: str) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "f"

[case testTopLevelMissingModuleAttribute]
import m
m.f(1)
def g() -> None: pass
[file m.py]
def f(x: int) -> None: pass
[file m.py.2]
def g(x: int) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:2: error: Module has no attribute "f"

[case testClassChangedIntoFunction]
import m
def f(a: m.A) -> None:
    pass
[file m.py]
class A: pass
[file m.py.2]
def A() -> None: pass
[out]
==
main:2: error: Invalid type "m.A"

[case testClassChangedIntoFunction2]
import m
class B:
    def f(self, a: m.A) -> None: pass
[file m.py]
class A: pass
[file m.py.2]
def A() -> None: pass
[file n.py.3]
[out]
==
main:3: error: Invalid type "m.A"
==
main:3: error: Invalid type "m.A"

[case testAttributeTypeChanged]
import m
def f(a: m.A) -> int:
    return a.x
[file m.py]
class A:
    def f(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def f(self) -> None:
        self.x = 'x'
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testAttributeRemoved]
import m
def f(a: m.A) -> int:
    return a.x
[file m.py]
class A:
    def f(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "x"

[case testVariableTypeBecomesInvalid]
import m
def f() -> None:
    a = None # type: m.A
[file m.py]
class A: pass
[file m.py.2]
[out]
==
main:3: error: Name 'm.A' is not defined

[case testTwoIncrementalSteps]
import m
import n
[file m.py]
def f() -> None: pass
[file n.py]
import m
def g() -> None:
    m.f() # E
[file m.py.2]
import n
def f(x: int) -> None:
    n.g() # E
[file n.py.3]
import m
def g(a: str) -> None:
    m.f('') # E
[out]
==
n.py:3: error: Too few arguments for "f"
==
n.py:3: error: Argument 1 to "f" has incompatible type "str"; expected "int"
m.py:3: error: Too few arguments for "g"

[case testTwoRounds]
import m
def h(a: m.A) -> int:
    return a.x
[file m.py]
import n
class A:
    def g(self, b: n.B) -> None:
        self.x = b.f()
[file n.py]
class B:
    def f(self) -> int: pass
[file n.py.2]
class B:
    def f(self) -> str: pass
[out]
==
main:3: error: Incompatible return value type (got "str", expected "int")

[case testFixTypeError]
import m
def f(a: m.A) -> None:
    a.f(a)
[file m.py]
class A:
    def f(self, a: 'A') -> None: pass
[file m.py.2]
class A:
    def f(self) -> None: pass
[file m.py.3]
class A:
    def f(self, a: 'A') -> None: pass
[out]
==
main:3: error: Too many arguments for "f" of "A"
==

[case testFixTypeError2]
import m
def f(a: m.A) -> None:
    a.f()
[file m.py]
class A:
    def f(self) -> None: pass
[file m.py.2]
class A:
    def g(self) -> None: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
==

[case testFixSemanticAnalysisError]
import m
def f() -> None:
    m.A()
[file m.py]
class A: pass
[file m.py.2]
class B: pass
[file m.py.3]
class A: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "A"
==

[case testContinueToReportTypeCheckError]
import m
def f(a: m.A) -> None:
    a.f()
def g(a: m.A) -> None:
    a.g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
main:5: error: "A" has no attribute "g"
==
main:5: error: "A" has no attribute "g"

[case testContinueToReportSemanticAnalysisError]
import m
def f() -> None:
    m.A()
def g() -> None:
    m.B()
[file m.py]
class A: pass
class B: pass
[file m.py.2]
[file m.py.3]
class A: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:3: error: Module has no attribute "A"
main:5: error: Module has no attribute "B"
==
main:5: error: Module has no attribute "B"

[case testContinueToReportErrorAtTopLevel-skip-cache]
-- Different cache/no-cache tests because:
-- Error message ordering differs
import n
import m
m.A().f()
[file n.py]
import m
m.A().g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:3: error: "A" has no attribute "f"
n.py:2: error: "A" has no attribute "g"
==
n.py:2: error: "A" has no attribute "g"

[case testContinueToReportErrorAtTopLevel-skip-nocache]
-- Different cache/no-cache tests because:
-- Error message ordering differs
import n
import m
m.A().f()
[file n.py]
import m
m.A().g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
n.py:2: error: "A" has no attribute "g"
main:3: error: "A" has no attribute "f"
==
n.py:2: error: "A" has no attribute "g"

[case testContinueToReportErrorInMethod]
import m
class C:
    def f(self, a: m.A) -> None:
        a.f()
    def g(self, a: m.A) -> None:
        a.g()
[file m.py]
class A:
    def f(self) -> None: pass
    def g(self) -> None: pass
[file m.py.2]
class A: pass
[file m.py.3]
class A:
    def f(self) -> None: pass
[out]
==
main:4: error: "A" has no attribute "f"
main:6: error: "A" has no attribute "g"
==
main:6: error: "A" has no attribute "g"

[case testInitialBatchGeneratedError]
import m
def g() -> None:
    m.f()
def h() -> None:
    m.g()
[file m.py]
def f(x: object) -> None: pass
[file m.py.2]
def f() -> None: pass
[file m.py.3]
def f() -> None: pass
def g() -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Too few arguments for "f"
main:5: error: Module has no attribute "g"
==
main:5: error: Module has no attribute "g"
==

[case testKeepReportingErrorIfNoChanges]
import m
def h() -> None:
    m.g()
[file m.py]
[file m.py.2]
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Module has no attribute "g"
==
main:3: error: Module has no attribute "g"

[case testFixErrorAndReintroduce]
import m
def h() -> None:
    m.g()
[file m.py]
[file m.py.2]
def g() -> None: pass
[file m.py.3]
[builtins fixtures/fine_grained.pyi]
[out]
main:3: error: Module has no attribute "g"
==
==
main:3: error: Module has no attribute "g"

[case testAddBaseClassMethodCausingInvalidOverride]
import m
class B(m.A):
    def f(self) -> str: pass
[file m.py]
class A: pass
[file m.py.2]
class A:
    def f(self) -> int: pass
[file n.py.3]
[out]
==
main:3: error: Return type of "f" incompatible with supertype "A"
==
main:3: error: Return type of "f" incompatible with supertype "A"

[case testModifyBaseClassMethodCausingInvalidOverride]
import m
class B(m.A):
    def f(self) -> str: pass
[file m.py]
class A:
    def f(self) -> str: pass
[file m.py.2]
class A:
    def f(self) -> int: pass
[out]
==
main:3: error: Return type of "f" incompatible with supertype "A"

[case testAddBaseClassAttributeCausingErrorInSubclass]
import m
class B(m.A):
    def a(self) -> None:
        x = 1
        x = self.x

    def f(self) -> None:
        self.x = 1

    def z(self) -> None:
        x = 1
        x = self.x
[file m.py]
class A: pass
[file m.py.2]
class A:
    def g(self) -> None:
        self.x = 'a'
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:8: error: Incompatible types in assignment (expression has type "int", variable has type "str")
main:12: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testChangeBaseClassAttributeType]
import m
class B(m.A):
    def f(sel) -> None:
        sel.x = 1
[file m.py]
class A:
    def g(self) -> None:
        self.x = 1
[file m.py.2]
class A:
    def g(self) -> None:
        self.x = 'a'
[out]
==
main:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testRemoveAttributeInBaseClass]
import m
class B(m.A):
    def f(self) -> None:
        a = 1
        a = self.x
[file m.py]
class A:
    def g(self) -> None:
        self.x = 1
[file m.py.2]
class A: pass
[out]
==
main:5: error: "B" has no attribute "x"

[case testTestSignatureOfInheritedMethod]
import m
class B(m.A):
    def f(self) -> None:
        self.g()
[file m.py]
class A:
    def g(self) -> None: pass
[file m.py.2]
class A:
    def g(self, a: 'A') -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "A"

[case testRemoveBaseClass]
import m
class A(m.B):
    def f(self) -> None:
        self.g()
        self.x
        self.y = 1
[file m.py]
class C:
    def g(self) -> None:
        self.x = 1
class B(C): pass
[file m.py.2]
class C: pass
class B: pass
[out]
==
main:4: error: "A" has no attribute "g"
main:5: error: "A" has no attribute "x"

[case testRemoveBaseClass2]
import m
class A(m.B):
    def f(self) -> None:
        self.g()
        self.x
        self.y = 1
[file m.py]
class C:
    def g(self) -> None:
        self.x = 1
class B(C): pass
[file m.py.2]
class C:
    def g(self) -> None:
        self.x = 1
class B: pass
[out]
==
main:4: error: "A" has no attribute "g"
main:5: error: "A" has no attribute "x"

[case testChangeInPackage]
import m.n
def f() -> None:
    m.n.g()
[file m/__init__.py]
[file m/n.py]
def g() -> None: pass
[file m/n.py.2]
def g(x: int) -> None: pass
[out]
==
main:3: error: Too few arguments for "g"

[case testTriggerTargetInPackage]
import m.n
[file m/__init__.py]
[file m/n.py]
import a
def f() -> None:
    a.g()
[file a.py]
def g() -> None: pass
[file a.py.2]
def g(x: int) -> None: pass
[out]
==
m/n.py:3: error: Too few arguments for "g"

[case testChangeInPackage__init__]
import m
import m.n
def f() -> None:
    m.g()
[file m/__init__.py]
def g() -> None: pass
[file m/__init__.py.2]
def g(x: int) -> None: pass
[file m/n.py]
[out]
==
main:4: error: Too few arguments for "g"

[case testTriggerTargetInPackage__init__]
import m
import m.n
[file m/__init__.py]
import a
def f() -> None:
    a.g()
[file a.py]
def g() -> None: pass
[file a.py.2]
def g(x: int) -> None: pass
[file m/n.py]
[out]
==
m/__init__.py:3: error: Too few arguments for "g"

[case testModuleAttributeTypeChanges]
import m
def f() -> None:
    x = 1
    x = m.x
[file m.py]
x = 1
[file m.py.2]
x = ''
[out]
==
main:4: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoStepsDueToModuleAttribute]
import m
x = m.f()

def g() -> None:
    y = 1
    y = x # E
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[out]
==
main:6: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoStepsDueToMultipleNamespaces]
import m

x = m.f()

def g() -> None:
    xx = 1
    xx = x

class A:
    def a(self) -> None:
        self.y = m.f()
    def b(self) -> None:
        yy = 1
        yy = self.y

class B:
    def c(self) -> None:
        self.z = m.f()
    def b(self) -> None:
        zz = 1
        zz = self.z
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[out]
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:14: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main:21: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testConstructorSignatureChanged]
import m

def f() -> None:
    m.A()
[file m.py]
class A:
    def __init__(self) -> None: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "A"

[case testConstructorSignatureChanged2]
from typing import Callable
import m

def use(x: Callable[[], m.A]) -> None:
    x()
def f() -> None:
    use(m.A)
[file m.py]
class A:
    def __init__(self) -> None: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
-- This is a bad error message
main:7: error: Argument 1 to "use" has incompatible type "Type[A]"; expected "Callable[[], A]"

[case testConstructorSignatureChanged3]
from a import C
class D(C):
    def g(self) -> None:
        super().__init__()
D()
[file a.py]
class C:
    def __init__(self) -> None: pass
[file a.py.2]
class C:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "__init__" of "C"
main:5: error: Too few arguments for "D"

[case testConstructorAdded]
import m

def f() -> None:
    m.A()
[file m.py]
class A: pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "A"

[case testConstructorDeleted]
import m

def f() -> None:
    m.A(1)
[file m.py]
class A:
    def __init__(self, x: int) -> None: pass
[file m.py.2]
class A: pass
[out]
==
main:4: error: Too many arguments for "A"

[case testBaseClassConstructorChanged]
import m

def f() -> None:
    m.B()
[file m.py]
class A:
    def __init__(self) -> None: pass
class B(A): pass
[file m.py.2]
class A:
    def __init__(self, x: int) -> None: pass
class B(A): pass
[out]
==
main:4: error: Too few arguments for "B"

[case testSuperField]
from a import C
class D(C):
    def g(self) -> int:
        return super().x
[file a.py]
class C:
    def __init__(self) -> None: self.x = 12
[file a.py.2]
class C:
    def __init__(self) -> None: self.x = 'ar'
[out]
==
main:4: error: Incompatible return value type (got "str", expected "int")

[case testImportFrom]
from m import f

def g() -> None:
    f()
[file m.py]
def f() -> None: pass
[file m.py.2]
def f(x: int) -> None: pass
[builtins fixtures/fine_grained.pyi]
[out]
==
main:4: error: Too few arguments for "f"

[case testImportFrom2]
from m import f
f()
[file m.py]
def f() -> None: pass
[file m.py.2]
def f(x: int) -> None: pass
[out]
==
main:2: error: Too few arguments for "f"

[case testImportFromTargetsClass]
from m import C

def f(c: C) -> None:
    c.g()
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
class C:
    def g(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "C"

[case testImportFromTargetsVariable]
from m import x

def f() -> None:
    y = 1
    y = x
[file m.py]
x = 1
[file m.py.2]
x = ''
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testImportFromSubmoduleOfPackage]
from m import n

def f() -> None:
    n.g()
[file m/__init__.py]
[file m/n.py]
def g() -> None: pass
[file m/n.py.2]
def g(x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g"

[case testImportedFunctionGetsImported]
from m import f

def g() -> None:
    f()
[file m.py]
from n import f
[file n.py]
def f() -> None: pass
[file n.py.2]
def f(x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "f"

[case testNestedClassMethodSignatureChanges]
from m import A

def f(x: A.B) -> None:
    x.g()
[file m.py]
class A:
    class B:
        def g(self) -> None: pass
[file m.py.2]
class A:
    class B:
        def g(self, x: int) -> None: pass
[out]
==
main:4: error: Too few arguments for "g" of "B"

[case testNestedClassAttributeTypeChanges]
from m import A

def f(x: A.B) -> None:
    z = 1
    z = x.y
[file m.py]
class A:
    class B:
        def g(self) -> None:
            self.y = 1
[file m.py.2]
class A:
    class B:
        def g(self) -> None:
            self.y = ''
[out]
==
main:5: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testReprocessMethodInNestedClass]
from m import f

class A:
    class B:
        def g(self) -> None:
            x = 1
            x = f()
[file m.py]
def f() -> int: pass
[file m.py.2]
def f() -> str: pass
[file n.py.3]
[out]
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")
==
main:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testReprocessMethodInNestedClassSemanal]
import a
[file a.py]
class A:
    class B:
        def g() -> None: pass
    def foo(self) -> int: return 12
[file b.py.2]
[file b.py.3]
2
[out]
a.py:3: error: Method must have at least one argument
==
a.py:3: error: Method must have at least one argument
==
a.py:3: error: Method must have at least one argument

[case testBaseClassDeleted]
import m

class A(m.C):
    def f(self) -> None:
        self.g()  # No error here because m.C becomes an Any base class
    def g(self) -> None:
        self.x
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
[out]
main:7: error: "A" has no attribute "x"
==
main:3: error: Name 'm.C' is not defined

[case testBaseClassOfNestedClassDeleted]
import m

class A:
    class B(m.C):
        def f(self) -> None:
            self.g()  # No error here because m.C becomes an Any base class
        def g(self) -> None:
            self.x
[file m.py]
class C:
    def g(self) -> None: pass
[file m.py.2]
[out]
main:8: error: "B" has no attribute "x"
==
main:4: error: Name 'm.C' is not defined

[case testImportQualifiedModuleName]
import a
[file a.py]
import b.c
b.c.f()
[file a.py.2]
import b.c
b.c.f() # dummy change
[file b/__init__.py]
[file b/c.py]
def f() -> None: pass
[out]
==

[case testTypeAliasRefresh]
from typing import Callable
from a import f
C = Callable[[int], str]
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testTypeVarRefresh]
from typing import TypeVar
from a import f
T = TypeVar('T')
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testNamedTupleRefresh]
from typing import NamedTuple
from a import f
N = NamedTuple('N', [('x', int)])
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testModuleLevelAttributeRefresh]
from typing import Callable
from a import f
x = 1
y = ''  # type: str
[file a.py]
def f() -> None: pass
[file a.py.2]
[out]
==
main:2: error: Module 'a' has no attribute 'f'

[case testClassBodyRefresh]
from a import f
class A:
    x = 1
    y = '' # type: str

    def f(self) -> None:
        self.x = 1
[file a.py]
f = 1
[file a.py.2]
[out]
==
main:1: error: Module 'a' has no attribute 'f'

[case testDecoratedMethodRefresh]
from typing import Iterator, Callable, List
from a import f
import a

def dec(f: Callable[['A'], Iterator[int]]) -> Callable[[int], int]: pass

class A:
    @dec
    def f(self) -> Iterator[int]:
        self.x = a.g()  # type: int
        return None
[builtins fixtures/list.pyi]
[file a.py]
f = 1
def g() -> int: pass
[file a.py.2]
def f() -> None: pass
def g() -> int: pass
[file a.py.3]
def f() -> None: pass
def g() -> str: pass
[out]
==
==
main:10: error: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testTwoPassTypeChecking]
import a
[file a.py]
[file a.py.2]
class A:
    def __init__(self, b: B) -> None:
        self.a = b.a

class B:
    def __init__(self) -> None:
        self.a = int()
[file a.py.3]
class A:
    def __init__(self, b: B) -> None:
        self.a = b.a
        reveal_type(self.a) # E

class B:
    def __init__(self) -> None:
        self.a = int()
[out]
==
==
a.py:4: error: Revealed type is 'builtins.int'

[case testStripRevealType]
import a
reveal_type(a.f())
[file a.py]
def f() -> int: pass
[file a.py.2]
def f() -> str: pass
[out]
main:2: error: Revealed type is 'builtins.int'
==
main:2: error: Revealed type is 'builtins.str'

[case testDecoratorTypeAfterReprocessing]
import a
reveal_type(a.f())
[file a.py]
from contextlib import contextmanager
from typing import Iterator
import b
@contextmanager
def f() -> Iterator[None]:
    yield
[file b.py]
[delete b.py.2]
[file b.py.3]
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[triggered]
2: <b>, __main__
3: <b>, __main__, a
[out]
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'
==
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'
a.py:3: error: Cannot find module named 'b'
a.py:3: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
main:2: error: Revealed type is 'contextlib.GeneratorContextManager[builtins.None]'

[case testDecoratorSpecialCase1]
import a
[file a.py]
import contextlib
from typing import List, Iterator

@contextlib.contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield

def g() -> None:
    import b
    b.h(1)
[file b.py]
def h() -> None: pass
[delete b.py.2]
[file b.py.3]
def h() -> None: pass
[file a.py.4]
import contextlib
from typing import List, Iterator

@contextlib.contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield

def g() -> None:
    import b
    b.h(1)
    pass
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[triggered]
2: <b.h>, <b>, <b[wildcard]>, a.g
3: <b.h>, <b>, <b[wildcard]>, a
4: a.g
[out]
a.py:11: error: Too many arguments for "h"
==
a.py:10: error: Cannot find module named 'b'
a.py:10: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
a.py:11: error: Too many arguments for "h"
==
a.py:11: error: Too many arguments for "h"

[case testDecoratorSpecialCase2]
import a
[file a.py]
from contextlib import contextmanager
from typing import Iterator, List
import b

@contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield
[file b.py]
[delete b.py.2]
[file b.py.3]
[file a.py.4]
from contextlib import contextmanager
from typing import Iterator, List
import b

@contextmanager
def f(x: List[int]) -> Iterator[None]:
    x.append(1)
    yield
[typing fixtures/typing-full.pyi]
[builtins fixtures/list.pyi]
[out]
==
a.py:3: error: Cannot find module named 'b'
a.py:3: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
==
==

[case testPreviousErrorInDecoratedFunction]
import a
[file a.py]
from typing import Callable
import b

def dec(x: Callable[[], None]) -> Callable[[], None]:
    return x

@dec
def f() -> None:
    1 + ''
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import Callable
import b

def dec(f: Callable[[], None]) -> Callable[[], None]:
    return f

@dec
def f() -> None:
    1 + 2
[out]
a.py:9: error: Unsupported operand types for + ("int" and "str")
==
a.py:9: error: Unsupported operand types for + ("int" and "str")
==
a.py:9: error: Unsupported operand types for + ("int" and "str")
==

[case testPreviousErrorInDecoratedMethodOverride]
import a
[file a.py]
from typing import Callable
from b import B

def dec(x: Callable[['A'], int]) -> Callable[['A'], int]:
    return x

class A(B):
    @dec
    def foo(self) -> int: return 12

[file b.py]
class B:
    def foo(self) -> str: return 'hi'
[file c.py.2]
[file c.py.3]
1
[file b.py.4]
class B:
    def foo(self) -> int: return 12
[out]
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==
a.py:9: error: Return type of "foo" incompatible with supertype "B"
==

[case testPreviousErrorInMethodSemanal1]
import a
[file a.py]
class A:
    def foo() -> int: pass
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
class A:
    def foo(self) -> int: pass
[out]
a.py:2: error: Method must have at least one argument
==
a.py:2: error: Method must have at least one argument
==
a.py:2: error: Method must have at least one argument
==

[case testPreviousErrorInMethodSemanal2]
import a
[file a.py]
class A:
    def foo(self) -> None:
        nothing
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
class A:
    def foo(self) -> int: pass
[out]
a.py:3: error: Name 'nothing' is not defined
==
a.py:3: error: Name 'nothing' is not defined
==
a.py:3: error: Name 'nothing' is not defined
==

[case testPreviousErrorInMethodSemanalPass3]
import a
[file a.py]
from typing import List
class A:
    def __init__(self) -> None:
        self.x = []  # type: List[int, str]
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
from typing import List
class A:
    def __init__(self) -> None:
        self.x = []  # type: List[int]
[builtins fixtures/list.pyi]
[out]
a.py:4: error: "list" expects 1 type argument, but 2 given
==
a.py:4: error: "list" expects 1 type argument, but 2 given
==
a.py:4: error: "list" expects 1 type argument, but 2 given
==

[case testPreviousErrorInOverloadedFunctionSemanalPass3]
import a
[file a.py]
from typing import overload, List
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> List[int, str]: ...
def f(x: object) -> object:
    pass
[file c.py.2]
[file c.py.3]
1
[file a.py.4]
from typing import overload, List
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> List[int]: ...
def f(x: object) -> object:
    pass
[builtins fixtures/list.pyi]
[out]
a.py:5: error: "list" expects 1 type argument, but 2 given
==
a.py:5: error: "list" expects 1 type argument, but 2 given
==
a.py:5: error: "list" expects 1 type argument, but 2 given
==

[case testPreviousErrorInOverloadedFunction]
import a
[file a.py]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> int: ...
def f(x: object) -> None:
	pass
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
	pass
[out]
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==
a.py:6: error: Overloaded function implementation cannot produce return type of signature 2
==

[case testPreviousErrorInOverloadedFunctionSemanal]
import a
[file a.py]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
[file b.py]
[file b.py.2]
1
[file b.py.3]
2
[file a.py.4]
from typing import overload
@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
	pass
[out]
a.py:2: error: An overloaded function outside a stub file must have an implementation
==
a.py:2: error: An overloaded function outside a stub file must have an implementation
==
a.py:2: error: An overloaded function outside a stub file must have an implementation
==

[case testPreviousErrorInDecoratedMethodSemanalPass3]
import a
[file a.py]
from typing import Callable, TypeVar, Any, List

T = TypeVar('T', bound=Callable)
def dec(x: T) -> T:
    return x

@dec
def foo(self) -> List[str, int]: return []

[file c.py.2]
[file c.py.3]
[file a.py.4]
from typing import Callable, TypeVar, Any, List

T = TypeVar('T', bound=Callable[..., Any])
def dec(x: T) -> T:
    return x

@dec
def foo(self) -> List[str]: return []
[builtins fixtures/list.pyi]
[out]
a.py:8: error: "list" expects 1 type argument, but 2 given
==
a.py:8: error: "list" expects 1 type argument, but 2 given
==
a.py:8: error: "list" expects 1 type argument, but 2 given
==

[case testOverloadRefresh]
from typing import overload
import m

@overload
def f(x: m.A) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x: object) -> None:
    from n import g
[file m.py]
class A: pass
[file n.py]
def g() -> None: pass
[delete m.py.2]
[delete n.py.2]
[out]
==
main:2: error: Cannot find module named 'm'
main:2: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
main:9: error: Cannot find module named 'n'

[case testOverloadSpecialCase]
from typing import overload
import m
import sys

class C:
    if sys.platform == 'nonexistent':
        def f(self, x): pass
    else:
        @overload
        def f(self, x: m.A) -> None: pass
        @overload
        def f(self, x: int) -> None: pass
        def f(self, x: object) -> None:
            from n import g
[file m.py]
class A: pass
[file n.py]
def g() -> None: pass
[delete m.py.2]
[delete n.py.2]
[builtins fixtures/ops.pyi]
[out]
==
main:2: error: Cannot find module named 'm'
main:2: note: (Perhaps setting MYPYPATH or using the "--ignore-missing-imports" flag would help)
main:14: error: Cannot find module named 'n'

[case testRefreshGenericClass]
from typing import TypeVar, Generic
from a import A

X = TypeVar('X')

class C(Generic[X]):
    def f(self, x: A) -> X: ...
[file a.py]
class A: pass
[file a.py.2]
[file a.py.3]
class A: pass
[out]
==
main:2: error: Module 'a' has no attribute 'A'
==

[case testRefreshGenericAndFailInPass3]
# Failure in semantic analysis pass 3
from a import C
a: C[int]
[file a.py]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]): pass
[file a.py.2]
from typing import TypeVar, Generic
T = TypeVar('T')
S = TypeVar('S')
class C(Generic[T, S]): pass
[file a.py.3]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]): pass
[out]
==
main:3: error: "C" expects 2 type arguments, but 1 given
==

[case testPrintStatement_python2]
# flags: --py2
import a
[file a.py]
def f(x): # type: (int) -> int
    return 1
print f(1)
[file a.py.2]
def f(x): # type: (int) -> int
    return 1
print f('')
[out]
==
a.py:3: error: Argument 1 to "f" has incompatible type "str"; expected "int"

[case testUnannotatedClass]
import a
[file a.py]
class A:
    def f(self, x):
        self.y = x
        self.g()

    def g(self): pass
[file a.py.2]
class A:
    def f(self, x, y):
        self.y = x
        self.z = y
        self.g()

    def g(self): pass
[triggered]
2: <a.A.f>, <a.A.z>
[out]
==

[case testSuperBasics]
import a
[file a.py]
class A:
    def f(self) -> None: pass
class B(A):
    def f(self) -> None:
        super(B, self).f()
[file a.py.2]
class A:
    def f(self) -> None: pass
class B(A):
    def f(self) -> None:
        super(B, self).f()
[out]
==

[case testErrorInTypeCheckSecondPassThroughPropagation]
import a

def f() -> None:
    x = a.C()
[file a.py]
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
class C(Generic[T]): pass
[out]
main:4: error: "object" has no attribute "C"
==
main:4: error: Need type annotation for 'x'

[case testPartialTypeInNestedClass]
import a
class C:
    def f(self) -> None:
        a.g()
        class D:
            def __init__(self) -> None:
                self.x = {}
                self.x['a'] = 'b'
[file a.py]
def g() -> None: pass
[file a.py.2]
def g() -> int: pass
[builtins fixtures/dict.pyi]
[out]
main:7: error: Need type annotation for 'x'
==
main:7: error: Need type annotation for 'x'

[case testRefreshPartialTypeInClass]
import a
class D:
    def __init__(self) -> None:
        a.g()
        self.x = {}
        self.x['a'] = 'b'
[file a.py]
def g() -> None: pass
[file a.py.2]
def g() -> int: pass
[builtins fixtures/dict.pyi]
[out]
main:5: error: Need type annotation for 'x'
==
main:5: error: Need type annotation for 'x'

[case testRefreshTryExcept]
import a
def f() -> None:
    a.g()
    try:
        pass
    except BaseException as e:
        e
[file a.py]
def g() -> int: pass
[file a.py.2]
def g() -> str: pass
[builtins fixtures/exception.pyi]
[out]
==

[case testMroSpecialCase]
import b
import a

[file a.py]
class C: pass
class D(C):
    1()
class E(D): pass

[file b.py]
import a

[file a.py.2]
class C: pass
class D(C):
    1()
class E(D): pass
# Something needs to change

[file b.py.2]
import a
# Something needs to change

[triggered]
2: a, a
[out]
a.py:3: error: "int" not callable
==
a.py:3: error: "int" not callable

[case testMetaclassDefinition_python2]
# flags: --py2
import abc
import m
m.f()

class A:
    __metaclass__ = abc.ABCMeta
[file m.py]
def f(): pass
[file m.py.2]
def f(x=1): pass
[out]
==

[case testRefreshGenericSubclass]
from typing import Generic, TypeVar
import m
m.x

T = TypeVar('T')

class C(Generic[T]):
    def __init__(self, x: T) -> None:
        pass

class D(C[T]):
    def __init__(self, x: T) -> None:
        m.x
        super(D, self).__init__(x)
[file m.py]
x = 0
[file m.py.2]
x = ''
[out]
==

[case testRefreshNamedTupleSubclass]
from typing import NamedTuple
import m
m.x

N = NamedTuple('N', [('x', int)])

class C(N):
    pass
[file m.py]
x = 0
[file m.py.2]
x = ''
[out]
==

[case testNewTypeRefresh]
import a

[file a.py]
from typing import Dict, NewType

class A: pass
N = NewType('N', A)

a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[file a.py.2]
from typing import Dict, NewType  # dummy change

class A: pass
N = NewType('N', A)

a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[builtins fixtures/dict.pyi]
[out]
==

[case testRefreshFunctionalEnum]
import a

[file a.py]
from typing import Dict
from enum import Enum

N = Enum('N', 'x')
a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)

[file a.py.2]
from typing import Dict
from enum import Enum

N = Enum('N', 'x')
a: Dict[N, int]

def f(self, x: N) -> None:
    a.get(x)
[builtins fixtures/dict.pyi]
[out]
==

[case testFineGrainedCallable]
import a
[file a.py]
def f(o: object) -> None:
    if callable(o):
        o()
[file a.py.2]
def f(o: object) -> None:
    if callable(o):
        o()
[builtins fixtures/callable.pyi]
[out]
==

[case testRefreshFunctionalNamedTuple]
import a

[file a.py]
from typing import NamedTuple
from b import L

A = NamedTuple('A', [])
a: A

def g() -> None:
    x = L(A())
    x.f(a)

[file b.pyi]
from typing import TypeVar, Generic, overload

T = TypeVar('T')

class L(Generic[T]):
    def __init__(self, x: T) -> None: pass
    @overload
    def f(self) -> None: pass
    @overload
    def f(self, a: T) -> None: pass

[file a.py.2]
from typing import NamedTuple
from b import L

A = NamedTuple('A', [])
a: A

def g() -> None:
    x = L(A())
    x.f(a)
[out]
==

[case testRefreshSubclassNestedInFunction1]
from a import C
def f() -> None:
    class D(C): pass
[file a.py]
class C: pass
[file a.py.2]
[out]
==
main:1: error: Module 'a' has no attribute 'C'

[case testRefreshSubclassNestedInFunction2]
from a import C
def f() -> None:
    class D(C):
        def g(self) -> None:
            super().__init__()
    d = D()
[file a.py]
class C:
    def __init__(self) -> None: pass
[file a.py.2]
class C:
    def __init__(self, x: int) -> None: pass
[out]
==
main:5: error: Too few arguments for "__init__" of "C"
main:6: error: Too few arguments for "D"

[case testInferAttributeTypeAndMultipleStaleTargets]
import a

class A:
    def g(self) -> None:
        a.x
        self.x = 1

    def f(self) -> None:
        a.x
        b = self.x
        self.x = 1

[file a.py]
x = 0
[file a.py.2]
x = ''
[out]
==

[case testNamedTupleUpdate]
import b
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('x', str)])
x = N('hi')
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testNamedTupleUpdate2]
import b
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('y', int)])
x = N(2)
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testNamedTupleUpdate3]
import c
[file a.py]
from typing import NamedTuple
N = NamedTuple('N', [('x', int)])
x = N(1)
[file a.py.2]
from typing import NamedTuple
N = NamedTuple('N', [('x', str)])
x = N('hi')
[file b.py]
import a
from typing import NamedTuple
M = NamedTuple('M', [('z', 'a.N')])
x = M(a.x)
[file c.py]
import a
import b
from typing import Tuple
def lol(n: Tuple[Tuple[int]]) -> None:
    pass
def f(x: b.M) -> None:
    lol(x)
f(b.x)
lol(b.x)
[out]
==
c.py:7: error: Argument 1 to "lol" has incompatible type "M"; expected "Tuple[Tuple[int]]"
c.py:9: error: Argument 1 to "lol" has incompatible type "M"; expected "Tuple[Tuple[int]]"

[case testNamedTupleUpdate4]
import b
[file a.py]
from typing import NamedTuple
class N(NamedTuple):
    x: int
x = N(1)
[file a.py.2]
from typing import NamedTuple
class N(NamedTuple):
    x: str
x = N('hi')
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testTypedDictRefresh]
[builtins fixtures/dict.pyi]
import a
[file a.py]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337)) # dummy change
[out]
==

[case testTypedDictUpdate]
import b
[file a.py]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
Point = TypedDict('Point', {'x': int, 'y': str})
p = Point(dict(x=42, y='lurr'))
[file b.py]
from a import Point
def foo(x: Point) -> int:
    return x['x'] + x['y']
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Unsupported operand types for + ("int" and "str")

[case testTypedDictUpdate2]
import b
[file a.py]
from mypy_extensions import TypedDict
class Point(TypedDict):
    x: int
    y: int
p = Point(dict(x=42, y=1337))
[file a.py.2]
from mypy_extensions import TypedDict
class Point(TypedDict):
    x: int
    y: str
p = Point(dict(x=42, y='lurr'))
[file b.py]
from a import Point
def foo(x: Point) -> int:
    return x['x'] + x['y']
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Unsupported operand types for + ("int" and "str")

[case testBasicAliasUpdate]
import b
[file a.py]
N = int
x = 1
[file a.py.2]
N = str
x = 'hi'
[file b.py]
import a
def f(x: a.N) -> None:
    pass
f(a.x)
[out]
==

[case testBasicAliasUpdateGeneric]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
D = Dict[int, T]
x = {1: 1}
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
D = Dict[str, T]
x = {'hi': 1}
[file b.py]
import a
def f(x: a.D[int]) -> None:
    pass
f(a.x)
[builtins fixtures/dict.pyi]
[out]
==

[case testAliasFineNormalMod]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
x: a.A = int()
[out]
==
b.py:2: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalFunc]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
def f(x: a.A):
    x = int()
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalClass]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
class C:
    x: a.A
c = C()
c.x = int()
[out]
==
b.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNormalClassBases]
import b
[file a.py]
import c
A = c.BaseI
[file a.py.2]
import c
A = c.BaseS
[file b.py]
import a
class C(a.A):
    x = int()
[file c.py]
class BaseI:
    x: int
class BaseS:
    x: str
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", base class "BaseS" defined the type as "str")

[case testAliasFineGenericMod]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file b.py]
import a
x: a.A = {str(): int()}
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineGenericFunc]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file b.py]
import a
def f(x: a.A):
    pass
f({str(): int()})
[builtins fixtures/dict.pyi]
[out]
==
b.py:4: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineForwardMod]
import b
[file b.py]
x: A = int()
A = int
[file b.py.2]
x: A = int()
A = str
[out]
==
b.py:1: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineForwardFunc]
import b
[file b.py]
def f(x: A):
    x = int()
A = int
[file b.py.2]
def f(x: A):
    x = int()
A = str
[out]
==
b.py:2: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineChainedFunc]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file aa.py]
import a
B = a.A
[file b.py]
import aa
def f(x: aa.B):
    x = int()
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineChainedClass]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file aa.py]
import a
B = a.A
[file b.py]
import aa
class C:
    x: aa.B
c = C()
c.x = int()
[out]
==
b.py:5: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineNestedMod]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
B = Dict[str, a.A]
[file b.py]
import aa
x: aa.B = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNestedFunc]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
B = Dict[str, a.A]
[file b.py]
import aa
def f(x: aa.B):
    x = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNestedFuncDirect]
import b
[file a.py]
from typing import Dict
A = Dict[str, int]
[file a.py.2]
from typing import Dict
A = Dict[str, str]
[file aa.py]
from typing import Dict
import a
E = Dict
[file b.py]
import aa
def f(x: aa.E[str, aa.a.A]):
    x = {'first': {str(): int()}}
[builtins fixtures/dict.pyi]
[out]
==
b.py:3: error: Dict entry 0 has incompatible type "str": "int"; expected "str": "str"

[case testAliasFineNonGenericToGeneric]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file a.py.2]
A = str
[file b.py]
import a
def f(x: a.A[str]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: "str" expects no type arguments, but 1 given

[case testAliasFineGenericToNonGeneric]
import b
[file a.py]
A = str
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file b.py]
import a
def f(x: a.A):
    pass
reveal_type(f)
[builtins fixtures/dict.pyi]
[out]
b.py:4: error: Revealed type is 'def (x: builtins.str) -> Any'
==
b.py:4: error: Revealed type is 'def (x: builtins.dict[Any, builtins.int]) -> Any'

[case testAliasFineChangedNumberOfTypeVars]
import b
[file a.py]
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, int]
[file a.py.2]
from typing import Dict, TypeVar
T = TypeVar('T')
S = TypeVar('S')
A = Dict[T, S]
[file b.py]
import a
def f(x: a.A[str]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:2: error: Bad number of arguments for type alias, expected: 2, given: 1

[case testAliasFineAdded]
import b
[file a.py]
[file a.py.2]
A = int
[file b.py]
import a
x: a.A
[out]
b.py:2: error: Name 'a.A' is not defined
==

[case testAliasFineDeleted]
import b
[file a.py]
A = int
[file a.py.2]
[file b.py]
import a
x: a.A
[out]
==
b.py:2: error: Name 'a.A' is not defined

[case testAliasFineClassToAlias]
import b
[file a.py]
class A: pass
[file a.py.2]
A = int
[file b.py]
import a
x: a.A
x = 1
[out]
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "A")
==

[case testAliasFineAliasToClass]
import b
[file a.py]
A = int
[file a.py.2]
class A: pass
[file b.py]
import a
x: a.A
x = 1
[out]
==
b.py:3: error: Incompatible types in assignment (expression has type "int", variable has type "A")

[case testAliasFineComponentDeleted]
import b
[file a.py]
class B: pass
[file a.py.2]
x = 1
[file b.py]
import a
from typing import Dict, TypeVar
T = TypeVar('T')
A = Dict[T, a.B]
def f(x: A[int]):
    pass
[builtins fixtures/dict.pyi]
[out]
==
b.py:4: error: Name 'a.B' is not defined

[case testAliasFineTargetDeleted]
import c
[file a.py]
A = int
[file b.py]
import a
B = a.A
[file b.py.2]
x = 1
[file c.py]
import b
def f(x: b.B):
    pass
[out]
==
c.py:2: error: Name 'b.B' is not defined

[case testAliasFineClassInFunction]
import b
[file a.py]
A = int
[file a.py.2]
A = str
[file b.py]
import a
def f() -> None:
    class C:
        x: a.A = int()
[out]
==
b.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testAliasFineInitNormalMod]
import c
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
from b import B
B(int())
[out]
==
c.py:2: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitNormalFunc]
import c
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
from b import B
def f() -> None:
    B(int())
[out]
==
c.py:3: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitGenericMod]
import c
[file a.py]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: T) -> None:
        pass
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: S) -> None:
        pass
[file b.py]
import a
B = a.A[int, str]
[file c.py]
from b import B
B(int())
[out]
==
c.py:2: error: Argument 1 has incompatible type "int"; expected "str"

[case testAliasFineInitGenericFunc]
import c
[file a.py]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: T) -> None:
        pass
[file a.py.2]
from typing import Generic, TypeVar
T = TypeVar('T')
S = TypeVar('S')
class A(Generic[T, S]):
    def __init__(self, x: S) -> None:
        pass
[file b.py]
import a
B = a.A[int, str]
[file c.py]
from b import B
def f() -> None:
    B(str())
[out]
c.py:3: error: Argument 1 has incompatible type "str"; expected "int"
==

[case testAliasFineInitChainedMod]
import d
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
import b
C = b.B
[file d.py]
from c import C
C(int())
[out]
==
d.py:2: error: Argument 1 to "A" has incompatible type "int"; expected "str"

[case testAliasFineInitChainedFunc]
import d
[file a.py]
class A:
    def __init__(self, x: int) -> None:
        pass
[file a.py.2]
class A:
    def __init__(self, x: str) -> None:
        pass
[file b.py]
import a
B = a.A
[file c.py]
import b
C = b.B
[file d.py]
from c import C
def f() -> None:
    C(str())
[out]
d.py:3: error: Argument 1 to "A" has incompatible type "str"; expected "int"
==

[case testNonePartialType1]
import a
a.y

x = None

def f() -> None:
    global x
    x = 1
[file a.py]
y = 0
[file a.py.2]
y = ''
[out]
main:4: error: Need type annotation for 'x'
==
main:4: error: Need type annotation for 'x'

[case testNonePartialType2]
import a
a.y

x = None

def f():
    global x
    x = 1
[file a.py]
y = 0
[file a.py.2]
y = ''
[out]
main:4: error: Need type annotation for 'x'
==
main:4: error: Need type annotation for 'x'

[case testNonePartialType3]
import a
[file a.py]
[file a.py.2]
y = None
def f() -> None:
    global y
    y = ''
[out]
==
a.py:1: error: Need type annotation for 'y'

[case testNonePartialType4]
import a
[file a.py]
y = None
def f() -> None:
    global y
    y = ''
[file a.py.2]
from typing import Optional
y: Optional[str] = None
def f() -> None:
    global y
    y = ''
[out]
a.py:1: error: Need type annotation for 'y'
==

[case testSkippedClass1]
import a
[file a.py]
class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass2]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass3]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
[file a.py.2]
class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testSkippedClass4]
import a
[file a.py]
import sys
if sys.platform == 'xyz':
    class A: pass
else:
    class A: pass
[file a.py.2]
import sys
if sys.platform == 'xyz':
    class A: pass
else:
    class A: pass
[builtins fixtures/ops.pyi]
[out]
==

[case testNewTypeDependencies1]
from a import N

def f(x: N) -> None:
    x.y = 1
[file a.py]
from typing import NewType
from b import C

N = NewType('N', C)
[file b.py]
class C:
    y: int
[file b.py.2]
class C:
    y: str
[out]
==
main:4: error: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testNewTypeDependencies2]
from a import N
from b import C, D

def f(x: C) -> None: pass

def g(x: N) -> None:
    f(x)
[file a.py]
from typing import NewType
from b import D

N = NewType('N', D)
[file b.py]
class C: pass
class D(C): pass
[file b.py.2]
class C: pass
class D: pass
[out]
==
main:7: error: Argument 1 to "f" has incompatible type "N"; expected "C"

[case testNewTypeDependencies3]
from a import N

def f(x: N) -> None:
    x.y
[file a.py]
from typing import NewType
from b import C
N = NewType('N', C)
[file a.py.2]
from typing import NewType
from b import D
N = NewType('N', D)
[file b.py]
class C:
    y: int
class D:
    pass
[out]
==
main:4: error: "N" has no attribute "y"

[case testNamedTupleWithinFunction]
from typing import NamedTuple
import b
def f() -> None:
    b.x
    n = NamedTuple('n', [])
[file b.py]
x = 0
[file b.py.2]
x = ''
[out]
==

[case testNamedTupleFallback]
# This test will fail without semantic analyzer pass 2 patches
import a
[file a.py]
import b
[file b.py]
from typing import NamedTuple
import c
c.x
class N(NamedTuple):
    count: int
[file c.py]
x = 0
[file c.py.2]
x = ''
[builtins fixtures/tuple.pyi]
[out]
b.py:5: error: Incompatible types in assignment (expression has type "int", base class "tuple" defined the type as "Callable[[Tuple[int, ...], Any], int]")
==
b.py:5: error: Incompatible types in assignment (expression has type "int", base class "tuple" defined the type as "Callable[[Tuple[int, ...], Any], int]")

[case testReprocessEllipses1]
import a
[file a.py]
from typing import Tuple
def foo(x: Tuple[int, ...]) -> None: pass
[file a.py.2]
from typing import Tuple
def foo(x: Tuple[int, ...]) -> None: pass
[builtins fixtures/tuple.pyi]
[out]
==

[case testReprocessEllipses2]
import a
[file a.py]
from typing import Callable
def foo(x: Callable[..., int]) -> None: pass
[file a.py.2]
from typing import Callable
def foo(x: Callable[..., int]) -> None: pass
[out]
==

[case testReprocessCallableArg]
import a
[file a.py]
from typing import Callable
from mypy_extensions import Arg
def a(f: Callable[[Arg(int, 'x')], int]) -> None: pass
[file a.py.2]
from typing import Callable
from mypy_extensions import Arg
def a(f: Callable[[Arg(int, 'x')], int]) -> None: pass
[builtins fixtures/dict.pyi]
[out]
==

[case testImplicitTuple1]
import a
[file a.py]
# Bogus annotation in nested function masked because outer function
# isn't annotated
def unchecked():
    def inner():
        # type: () -> (str, int)
        return 'lol', 10
[file a.py.2]
# dummy change
def unchecked():
    def inner():
        # type: () -> (str, int)
        return 'lol', 10
[out]
==

[case testImplicitTuple2]
import a
[file a.py]
def inner():
    # type: () -> (str, int)
    return 'lol', 10
[file a.py.2]
# dummy change
def inner():
    # type: () -> (str, int)
    return 'lol', 10
[out]
a.py:1: error: Invalid tuple literal type
==
a.py:2: error: Invalid tuple literal type

[case testImplicitTuple3]
import a
[file a.py]
(x, y) = 1, 'hi'  # type: (int, str)
[file a.py.2]
# dummy change
(x, y) = 1, 'hi'  # type: (int, str)
[out]
==

[case testCastConfusion]
import b
[file a.py]
from typing import cast
class Thing:
    def foo(self) -> None: pass

thing = cast(Thing, Thing())

[file b.py]
from typing import Optional
from a import Thing, thing
class User:
    def __init__(self, x: Optional[Thing]) -> None:
        self.x = x if x else thing
    def use(self) -> None: self.x.foo()

[file a.py.2]
from typing import cast
class Thing:
    def foo(self) -> None: pass

thing = cast(Thing, Thing())
# update

[file b.py.2]
from typing import Optional
from a import Thing, thing
class User:
    def __init__(self, x: Optional[Thing]) -> None:
        self.x = x if x else thing
    def use(self) -> None: self.x.foo()
# update
[builtins fixtures/ops.pyi]
[out]
==

[case testRefreshClassBasedEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import Enum
import b
b.x
class C(Enum):
    X = 0
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testRefreshClassBasedIntEnum]
import aa
[file aa.py]
import a
[file a.py]
from enum import IntEnum
import b
b.x
class C(IntEnum):
    X = 0
x: int
x = C.X
[file b.py]
x = 0
[file b.py.2]
x = ''
[file aa.py.3]
from a import C
c: C
c = C.X
c = 1
n: int
n = C.X
n = c
[out]
==
==
aa.py:4: error: Incompatible types in assignment (expression has type "int", variable has type "C")

[case testClassBasedEnumPropagation1]
import a
[file a.py]
from b import C

def f(x: C) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
from enum import Enum

class C(Enum):
    X = 0
    Y = 1
[file b.py.2]
from enum import Enum

class C(Enum):
    X = 0
[out]
==
a.py:5: error: "Type[C]" has no attribute "Y"

[case testClassBasedEnumPropagation2]
import a
[file a.py]
from b import C

def f(x: int) -> None: pass
f(C.X)
f(C.Y)
[file b.py]
class C:
    X = 0
    Y = 1
[file b.py.2]
from enum import Enum
class C(Enum):
    X = 0
    Y = 1
[out]
==
a.py:4: error: Argument 1 to "f" has incompatible type "C"; expected "int"
a.py:5: error: Argument 1 to "f" has incompatible type "C"; expected "int"

[case testChangeFunctionToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
f = 1
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeVarAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from typing import TypeVar
f = TypeVar('f')
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToModuleAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
import c as f
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeAliasAndRefreshUsingStaleDependency1]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
f = int
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testChangeFunctionToTypeAliasAndRefreshUsingStaleDependency2]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from typing import List
f = List[int]
[file c.py]
class A: pass
[file c.py.3]
[builtins fixtures/list.pyi]
[out]
==
==

[case testChangeFunctionToClassAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
class f: pass
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testClassToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
class A:
    def f(self) -> c.A: pass
[file a.py.2]
A = 0
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testFunctionToImportedFunctionAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
def f() -> c.A: pass
[file a.py.2]
from d import f
[file c.py]
class A: pass
[file c.py.3]
[file d.py]
def g() -> None: pass
def f() -> None:
    g()
[out]
==
==

[case testMethodToVariableAndRefreshUsingStaleDependency]
import a
import c
[file a.py]
import c
class B:
    def f(self) -> c.A: pass
[file a.py.2]
class B:
    f = 0
[file c.py]
class A: pass
[file c.py.3]
[out]
==
==

[case testRefreshNestedClassWithSelfReference]
import a
[file a.py]
import b

def f(self) -> None:
    b.y
    class C:
        z: C
[file b.py]
y = 0
[file b.py.2]
y = ''
[file b.py.3]
y = 0
[out]
==
==

[case testMultipleAssignment]
import a
[file a.py]
from b import f

def h(x: str) -> None: pass

class C:
    def __init__(self) -> None:
        self.a, self.b = f()

    def g(self) -> None:
        h(self.a)
[file b.py]
from typing import Tuple
def f() -> Tuple[str, int]: pass
[file b.py.2]
from typing import Tuple
def f() -> Tuple[int, object]: pass
[file b.py.3]
from typing import Tuple
def f() -> Tuple[str, int]: pass
[out]
==
a.py:10: error: Argument 1 to "h" has incompatible type "int"; expected "str"
==

[case testMultipleLvalues]
import a
[file a.py]
from b import f

def h(x: str) -> None: pass

class C:
    def __init__(self) -> None:
        self.a = self.b = f()

    def g(self) -> None:
        h(self.a)
        h(self.b)
[file b.py]
def f() -> str: pass
[file b.py.2]
def f() -> int: pass
[file b.py.3]
def f() -> str: pass
[out]
==
a.py:10: error: Argument 1 to "h" has incompatible type "int"; expected "str"
a.py:11: error: Argument 1 to "h" has incompatible type "int"; expected "str"

[case testNoOpUpdateFineGrainedIncremental1]
# cmd: mypy a.py
[file a.py]
1()
[file b.py.2]
# Note: this file is not part of the build
[file a.py.3]
x = 1
[out]
a.py:1: error: "int" not callable
==
a.py:1: error: "int" not callable
==

[case testNoOpUpdateFineGrainedIncremental2]
# cmd: mypy a.py
[file a.py]
1()
[file a.py.2]
1()
[file a.py.3]
x = 1
[file a.py.4]
x = 1
[out]
a.py:1: error: "int" not callable
==
a.py:1: error: "int" not callable
==
==

[case testNonExistentFileOnCommandLine1]
# cmd: mypy a.py nonexistent.py
[file a.py]
[file a.py.2]
1()
[out]
mypy: can't read file 'tmp/nonexistent.py': No such file or directory
==
mypy: can't read file 'tmp/nonexistent.py': No such file or directory

[case testNonExistentFileOnCommandLine2]
# cmd: mypy a.py
# cmd2: mypy a.py nonexistent.py
[file a.py]
[file a.py.2]
1()
[out]
==
a.py:1: error: "int" not callable

[case testNonExistentFileOnCommandLine3]
# cmd: mypy a.py
# cmd2: mypy a.py nonexistent.py
[file a.py]
[file nonexistent.py]
[delete nonexistent.py.2]
[out]
==

[case testNonExistentFileOnCommandLine4]
# cmd: mypy a.py nonexistent.py
[file a.py]
[file nonexistent.py]
[delete nonexistent.py.2]
[out]
==

[case testNonExistentFileOnCommandLine5]
# cmd: mypy a.py nonexistent_stub.pyi
# TODO: Should generate an error for missing file
[file a.py]
[file nonexistent_stub.pyi]
[delete nonexistent_stub.pyi.2]
[out]
==
