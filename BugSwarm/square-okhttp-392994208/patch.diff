diff --git a/README.md b/README.md
index 4576c79e7..40f31ce8c 100644
--- a/README.md
+++ b/README.md
@@ -45,19 +45,14 @@ or Gradle:
 testImplementation 'com.squareup.okhttp3:mockwebserver:3.10.0'
 ```
 
-ProGuard
---------
+R8 / ProGuard
+-------------
 
-If you are using ProGuard you might need to add the following options:
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro).
+
+You might also need rules for Okio which is a dependency of this library.
 
-```
--dontwarn okhttp3.**
--dontwarn okio.**
--dontwarn javax.annotation.**
--dontwarn org.conscrypt.**
-# A resource is loaded with a relative path so the package of this class must be preserved.
--keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
-```
 
 License
 -------
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 435d4e098..4c06f268d 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -214,11 +214,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (protocols.contains(Protocol.H2C) && protocols.size() > 1) {
-      // when using h2c prior knowledge, no other protocol should be supported.
-      throw new IllegalArgumentException("protocols containing h2c cannot use other protocols: "
-              + protocols);
-    } else if (!protocols.contains(Protocol.H2C) && !protocols.contains(Protocol.HTTP_1_1)) {
+    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+      // when using h2_prior_knowledge, no other protocol should be supported.
+      throw new IllegalArgumentException(
+          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        && !protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -444,9 +445,9 @@ public void processConnection() throws Exception {
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
-        } else if (protocols.contains(Protocol.H2C)) {
+        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
           socket = raw;
-          protocol = Protocol.H2C;
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         } else {
           socket = raw;
         }
@@ -455,7 +456,7 @@ public void processConnection() throws Exception {
           return; // Ignore the socket until the server is shut down!
         }
 
-        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2C) {
+        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
@@ -703,7 +704,7 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
-    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
@@ -905,7 +906,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2C) {
+        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           httpHeaders.add(name.utf8(), value);
         } else {
           throw new IllegalStateException();
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index e9d46b2a8..4a5e490bd 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -317,7 +317,7 @@
         break;
       }
     }
-    assertEquals(512f, i, 10f); // Halfway +/- 1%
+    assertEquals(512f, i, 20f); // Halfway +/- 2%
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -458,29 +458,31 @@
     assertEquals("request", request.getBody().readUtf8());
   }
 
-  @Test public void testH2CServerFallback() {
+  @Test public void testH2PriorKnowledgeServerFallback() {
     try {
-      server.setProtocols(Arrays.asList(Protocol.H2C, Protocol.HTTP_1_1));
-      fail("When H2C is specified, no other protocol can be specified");
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, http/1.1]", expected.getMessage());
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
     }
   }
 
-  @Test public void testH2CServerDuplicates() {
+  @Test public void testH2PriorKnowledgeServerDuplicates() {
     try {
       // Treating this use case as user error
-      server.setProtocols(Arrays.asList(Protocol.H2C, Protocol.H2C));
-      fail("When H2C is specified, no other protocol can be specified");
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, h2c]", expected.getMessage());
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
     }
   }
 
-  @Test public void testMockWebServerH2CProtocol() {
-    server.setProtocols(Arrays.asList(Protocol.H2C));
+  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
+    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
 
     assertEquals(1, server.protocols().size());
-    assertEquals(Protocol.H2C, server.protocols().get(0));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, server.protocols().get(0));
   }
 }
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index 17bd2d14b..7119bceb0 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -1196,7 +1196,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
new file mode 100644
index 000000000..2b1bc4283
--- /dev/null
+++ b/okhttp-sse/README.md
@@ -0,0 +1,5 @@
+OkHttp Server-Sent Events
+=========================
+
+Experimental support for server-sent events.
+API is not considered stable and may change at any time.
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
new file mode 100644
index 000000000..fac7188b2
--- /dev/null
+++ b/okhttp-sse/pom.xml
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.11.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-sse</artifactId>
+  <name>OkHttp Server-Sent Events</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
new file mode 100644
index 000000000..1192b7ec5
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -0,0 +1,186 @@
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+public final class ServerSentEventReader {
+  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
+  private static final ByteString DATA = ByteString.encodeUtf8("data");
+  private static final ByteString ID = ByteString.encodeUtf8("id");
+  private static final ByteString EVENT = ByteString.encodeUtf8("event");
+  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
+
+  public interface Callback {
+    void onEvent(@Nullable String id, @Nullable String type, String data);
+    void onRetryChange(long timeMs);
+  }
+
+  private final BufferedSource source;
+  private final Callback callback;
+
+  private String lastId = null;
+
+  public ServerSentEventReader(BufferedSource source, Callback callback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (callback == null) throw new NullPointerException("callback == null");
+    this.source = source;
+    this.callback = callback;
+  }
+
+  /**
+   * Process the next event. This will result in a single call to {@link Callback#onEvent}
+   * <em>unless</em> the data section was empty. Any number of calls to
+   * {@link Callback#onRetryChange} may occur while processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  boolean processNextEvent() throws IOException {
+    String id = lastId;
+    String type = null;
+    Buffer data = new Buffer();
+
+    while (true) {
+      long lineEnd = source.indexOfElement(CRLF);
+      if (lineEnd == -1L) {
+        return false;
+      }
+
+      switch (source.buffer().getByte(0)) {
+        case '\r':
+        case '\n':
+          completeEvent(id, type, data);
+          return true;
+
+        case 'd':
+          if (isKey(DATA)) {
+            parseData(data, lineEnd);
+            continue;
+          }
+          break;
+
+        case 'e':
+          if (isKey(EVENT)) {
+            type = parseEvent(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'i':
+          if (isKey(ID)) {
+            id = parseId(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'r':
+          if (isKey(RETRY)) {
+            parseRetry(lineEnd);
+            continue;
+          }
+          break;
+      }
+
+      source.skip(lineEnd);
+      skipCrAndOrLf();
+    }
+  }
+
+  private void completeEvent(String id, String type, Buffer data) throws IOException {
+    skipCrAndOrLf();
+
+    if (data.size() != 0L) {
+      lastId = id;
+      data.skip(1L); // Leading newline.
+      callback.onEvent(id, type, data.readUtf8());
+    }
+  }
+
+  private void parseData(Buffer data, long end) throws IOException {
+    data.writeByte('\n');
+    end -= skipNameAndDivider(4L);
+    source.readFully(data, end);
+    skipCrAndOrLf();
+  }
+
+  private String parseEvent(long end) throws IOException {
+    String type = null;
+    end -= skipNameAndDivider(5L);
+    if (end != 0L) {
+      type = source.readUtf8(end);
+    }
+    skipCrAndOrLf();
+    return type;
+  }
+
+  private String parseId(long end) throws IOException {
+    String id;
+    end -= skipNameAndDivider(2L);
+    if (end != 0L) {
+      id = source.readUtf8(end);
+    } else {
+      id = null;
+    }
+    skipCrAndOrLf();
+    return id;
+  }
+
+  private void parseRetry(long end) throws IOException {
+    end -= skipNameAndDivider(5L);
+    String retryString = source.readUtf8(end);
+    long retryMs = -1L;
+    try {
+      retryMs = Long.parseLong(retryString);
+    } catch (NumberFormatException ignored) {
+    }
+    if (retryMs != -1L) {
+      callback.onRetryChange(retryMs);
+    }
+    skipCrAndOrLf();
+  }
+
+  /**
+   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
+   * a newline.
+   */
+  private boolean isKey(ByteString key) throws IOException {
+    if (source.rangeEquals(0, key)) {
+      byte nextByte = source.buffer().getByte(key.size());
+      return nextByte == ':'
+          || nextByte == '\r'
+          || nextByte == '\n';
+    }
+    return false;
+  }
+
+  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
+  private void skipCrAndOrLf() throws IOException {
+    if ((source.readByte() & 0xff) == '\r'
+        && source.request(1)
+        && source.buffer().getByte(0) == '\n') {
+      source.skip(1);
+    }
+  }
+
+  /**
+   * Consumes the field name of the specified length and the optional colon and its optional
+   * trailing space. Returns the number of bytes skipped.
+   */
+  private long skipNameAndDivider(long length) throws IOException {
+    source.skip(length);
+
+    if (source.buffer().getByte(0) == ':') {
+      source.skip(1L);
+      length++;
+
+      if (source.buffer().getByte(0) == ' ') {
+        source.skip(1);
+        length++;
+      }
+    }
+
+    return length;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
new file mode 100644
index 000000000..149be0014
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import javax.annotation.Nullable;
+
+final class Event {
+  final @Nullable String id;
+  final @Nullable String type;
+  final String data;
+
+  Event(@Nullable String id, @Nullable String type, String data) {
+    if (data == null) throw new NullPointerException("data == null");
+    this.id = id;
+    this.type = type;
+    this.data = data;
+  }
+
+  @Override public String toString() {
+    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof Event)) return false;
+    Event other = (Event) o;
+    return (id != null ? id.equals(other.id) : other.id == null)
+        && (type != null ? type.equals(other.type) : other.type == null)
+        && data.equals(other.data);
+  }
+
+  @Override public int hashCode() {
+    int result = (id != null ? id.hashCode() : 0);
+    result = 31 * result + (type != null ? type.hashCode() : 0);
+    result = 31 * result + data.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
new file mode 100644
index 000000000..697a2d201
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class ServerSentEventIteratorTest {
+  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
+  private final Deque<Object> callbacks = new ArrayDeque<>();
+
+  @After public void after() {
+    assertTrue("Unconsumed events: " + callbacks, callbacks.isEmpty());
+  }
+  
+  @Test public void multiline() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\n"
+        + "data: +2\n"
+        + "data: 10\n"
+        + "\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCr() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r"
+        + "data: +2\r"
+        + "data: 10\r"
+        + "\r");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCrLf() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r\n"
+        + "data: +2\r\n"
+        + "data: 10\r\n"
+        + "\r\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void eventType() throws IOException {
+    consumeEvents(""
+        + "event: add\n"
+        + "data: 73857293\n"
+        + "\n"
+        + "event: remove\n"
+        + "data: 2153\n"
+        + "\n"
+        + "event: add\n"
+        + "data: 113411\n"
+        + "\n");
+    assertEquals(new Event(null, "add", "73857293"), callbacks.remove());
+    assertEquals(new Event(null, "remove", "2153"), callbacks.remove());
+    assertEquals(new Event(null, "add", "113411"), callbacks.remove());
+  }
+
+  @Test public void commentsIgnored() throws IOException {
+    consumeEvents(""
+        + ": test stream\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void idCleared() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "id\n"
+        + "\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event(null, null, "second event"), callbacks.remove());
+    assertEquals(new Event(null, null, "third event"), callbacks.remove());
+  }
+
+  @Test public void nakedFieldNames() throws IOException {
+    consumeEvents(""
+        + "data\n"
+        + "\n"
+        + "data\n"
+        + "data\n"
+        + "\n"
+        + "data:\n");
+    assertEquals(new Event(null, null, ""), callbacks.remove());
+    assertEquals(new Event(null, null, "\n"), callbacks.remove());
+  }
+
+  @Test public void colonSpaceOptional() throws IOException {
+    consumeEvents(""
+        + "data:test\n"
+        + "\n"
+        + "data: test\n"
+        + "\n");
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+  }
+
+  @Test public void leadingWhitespace() throws IOException {
+    consumeEvents(""
+        + "data:  test\n"
+        + "\n");
+    assertEquals(new Event(null, null, " test"), callbacks.remove());
+  }
+
+  @Test public void idReusedAcrossEvents() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n"
+        + "id: 2\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+    assertEquals(new Event("2", null, "third event"), callbacks.remove());
+  }
+
+  @Test public void idIgnoredFromEmptyEvent() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "id: 2\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+  }
+
+  @Test public void retry() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void retryInvalidFormatIgnored() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "retry: hey"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+  }
+  
+  private void consumeEvents(String source) throws IOException {
+    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
+      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+        callbacks.add(new Event(id, type, data));
+      }
+      @Override public void onRetryChange(long timeMs) {
+        callbacks.add(timeMs);
+      }
+    };
+    Buffer buffer = new Buffer().writeUtf8(source);
+    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
+    while (reader.processNextEvent());
+    assertEquals("Unconsumed buffer: " + buffer.readUtf8(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 153771712..9e096772a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -1378,7 +1378,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 16b0b8076..76fdd40cd 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -1187,6 +1187,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    server.useHttps(sslClient.socketFactory, false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
+    }
+  }
+
   @Test public void setFollowSslRedirectsFalse() throws Exception {
     enableTls();
     server.enqueue(new MockResponse()
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
index c31746a57..0c42c1955 100644
--- a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -152,7 +152,7 @@
   }
 
   @Test public void failedCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse().setBodyDelay(2, TimeUnit.SECONDS));
+    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
 
     client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
 
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index bae6dce2d..ec6289f8a 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -443,6 +443,11 @@
     assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
   }
 
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertEquals(null, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:00001]"));
+  }
+
   @Test public void hostIpv6WithIpv4Suffix() throws Exception {
     assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
     assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index f38c9daaa..ebffe84f6 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -170,34 +170,33 @@
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionFallback() {
-    // fallbacks are not allowed when using h2c prior knowledge
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
     try {
       new OkHttpClient.Builder()
-              .protocols(Arrays.asList(Protocol.H2C, Protocol.HTTP_1_1));
-      fail("When H2C is specified, no other protocol can be specified");
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, http/1.1]", expected.getMessage());
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionDuplicates() {
-    // Treating this use case as user error
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
     try {
       new OkHttpClient.Builder()
-              .protocols(Arrays.asList(Protocol.H2C, Protocol.H2C));
-      fail("When H2C is specified, no other protocol can be specified");
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals("protocols containing h2c cannot use other protocols: [h2c, h2c]", expected.getMessage());
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
     }
   }
 
-  @Test public void testH2COkHttpClientConstructionSuccess() {
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
     OkHttpClient okHttpClient = new OkHttpClient.Builder()
-            .protocols(Arrays.asList(Protocol.H2C))
-            .build();
-
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
     assertEquals(1, okHttpClient.protocols().size());
-    assertEquals(Protocol.H2C, okHttpClient.protocols().get(0));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
index f16a2a5c8..88e88c0d0 100644
--- a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
@@ -15,9 +15,8 @@
  */
 package okhttp3;
 
-import org.junit.Test;
-
 import java.io.IOException;
+import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
@@ -28,7 +27,7 @@ public void testGetKnown() throws IOException {
     assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
     assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
     assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
-    assertEquals(Protocol.H2C, Protocol.get("h2c"));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.get("h2_prior_knowledge"));
     assertEquals(Protocol.QUIC, Protocol.get("quic"));
   }
 
@@ -43,7 +42,7 @@ public void testToString() throws IOException {
     assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
     assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
     assertEquals("h2", Protocol.HTTP_2.toString());
-    assertEquals("h2c", Protocol.H2C.toString());
+    assertEquals("h2_prior_knowledge", Protocol.H2_PRIOR_KNOWLEDGE.toString());
     assertEquals("quic", Protocol.QUIC.toString());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 2ab31a35d..a132f68a5 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -192,6 +192,39 @@
     assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
   }
 
+  /**
+   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
+   * just prior to us canceling a stream.
+   */
+  @Test public void discardedDataFramesAreCounted() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.sendFrame().headers(3, headerEntries("a", "apple"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(true, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
+    Source source = stream1.getSource();
+    Buffer buffer = new Buffer();
+    while (buffer.size() != 1024) source.read(buffer, 1024);
+    stream1.close(ErrorCode.CANCEL);
+
+    InFrame frame1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, frame1.type);
+    InFrame frame2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame2.type);
+    InFrame frame3 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame3.type);
+
+    assertEquals(2048, connection.unacknowledgedBytesRead);
+  }
+
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 37c28fdb3..a0409a1bf 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,7 +20,6 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
@@ -65,7 +64,6 @@
 import okhttp3.mockwebserver.internal.tls.SslClient;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -98,7 +96,7 @@
 
   @Parameters(name = "{0}")
   public static Collection<Protocol> data() {
-    return Arrays.asList(Protocol.H2C, Protocol.HTTP_2);
+    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
   }
 
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
@@ -112,14 +110,14 @@
   private Protocol protocol;
 
   public HttpOverHttp2Test(Protocol protocol) {
-    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2cClient();
+    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
     this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
     this.protocol = protocol;
   }
 
-  private static OkHttpClient buildH2cClient() {
+  private static OkHttpClient buildH2PriorKnowledgeClient() {
     return defaultClient().newBuilder()
-        .protocols(Arrays.asList(Protocol.H2C))
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
         .build();
   }
 
@@ -133,8 +131,8 @@ private static OkHttpClient buildHttp2Client() {
   }
 
   @Before public void setUp() throws Exception {
-    if (protocol == Protocol.H2C) {
-      server.setProtocols(Arrays.asList(Protocol.H2C));
+    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
     } else {
       server.useHttps(sslClient.socketFactory, false);
     }
@@ -167,6 +165,7 @@ private static OkHttpClient buildHttp2Client() {
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
     assertEquals("", response.message());
+    assertEquals(protocol, response.protocol());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
@@ -335,6 +334,39 @@ private static OkHttpClient buildHttp2Client() {
     assertEquals("abc", response2.body().string());
   }
 
+  @Test public void connectionWindowUpdateOnClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    // Wait until the server has completely filled the stream and connection flow-control windows.
+    int expectedFrameCount = Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE / 16384;
+    int dataFrameCount = 0;
+    while (dataFrameCount < expectedFrameCount) {
+      String log = http2Handler.take();
+      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
+        dataFrameCount++;
+      }
+    }
+
+    // Cancel the call and close the response body. This should discard the buffered data and update
+    // the connnection flow-control window.
+    call1.cancel();
+    response1.close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
   /** https://github.com/square/okhttp/issues/373 */
   @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
@@ -1324,7 +1356,7 @@ private int countFrames(List<String> logs, String message) {
     assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
   }
 
-  public Buffer gzip(String bytes) throws IOException {
+  private Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
     sink.writeUtf8(bytes);
@@ -1336,7 +1368,7 @@ public Buffer gzip(String bytes) throws IOException {
     String path;
     CountDownLatch countDownLatch;
 
-    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+    AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -1354,28 +1386,4 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
-
-  static final class RecordingHandler extends BaseTestHandler {
-    int headerFrameCount;
-    final List<Integer> dataFrames = new ArrayList<>();
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-    }
-
-    @Override public void ackSettings() {
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      dataFrames.add(length);
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      headerFrameCount++;
-    }
-  }
 }
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index 104d719dd..9b079a900 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -1079,7 +1079,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad2..cb9ac837f 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -32,7 +32,7 @@
    * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
    * close the underlying {@link ResponseBody}.
    *
-   * <pre>@{code
+   * <pre>{@code
    *
    *   // ensure the response (and underlying response body) is closed
    *   try (Response response = client.newCall(request).execute()) {
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 9b0bdcc1f..b349e1a0b 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -834,7 +834,9 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+     *         (cleartext only)</a>
      * </ul>
      *
      * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
@@ -842,27 +844,30 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <p>If multiple protocols are specified, <a
      * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
+     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
      *
      * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
      * Response#protocol()}.
      *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It should not contain null or {@link Protocol#HTTP_1_0}. If you use
-     * {@link Protocol#H2C}, then it should be the only specified protocol in the list.
+     * @param protocols the protocols to use, in order of preference. If the list contains {@link
+     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+     *     not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
       // Create a private copy of the list.
       protocols = new ArrayList<>(protocols);
 
-      if (protocols.contains(Protocol.H2C) && protocols.size() > 1) {
-        // when using h2c prior knowledge, no other protocol should be supported.
-        throw new IllegalArgumentException("protocols containing h2c cannot use other protocols: "
-                + protocols);
-      } else if (!protocols.contains(Protocol.H2C) && !protocols.contains(Protocol.HTTP_1_1)) {
-        // Validate that the list has everything we require and nothing we forbid.
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      // Validate that the list has everything we require and nothing we forbid.
+      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+          && !protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException(
+            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+        throw new IllegalArgumentException(
+            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
       }
       if (protocols.contains(Protocol.HTTP_1_0)) {
         throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index 108155f3b..a96070ed5 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -62,13 +62,13 @@
   HTTP_2("h2"),
 
   /**
-   * Cleartext implementation of HTTP2. This enumeration exists for the "prior knowledge" upgrade
-   * semantic supported by the protocol.
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
    *
    * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
    * Knowledge</a>
    */
-  H2C("h2c"),
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
 
   /**
    * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
@@ -95,7 +95,7 @@ public static Protocol get(String protocol) throws IOException {
     // Unroll the loop over values() to save an allocation.
     if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
     if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
-    if (protocol.equals(H2C.protocol)) return H2C;
+    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
     if (protocol.equals(QUIC.protocol)) return QUIC;
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 2531896b0..bc63eba3e 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -146,6 +146,11 @@ public void connect(int connectTimeout, int readTimeout, int writeTimeout,
         throw new RouteException(new UnknownServiceException(
             "CLEARTEXT communication to " + host + " not permitted by network security policy"));
       }
+    } else {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        throw new RouteException(new UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+      }
     }
 
     while (true) {
@@ -261,9 +266,9 @@ private void connectSocket(int connectTimeout, int readTimeout, Call call,
   private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
       int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
-      if (route.address().protocols().contains(Protocol.H2C)) {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
         socket = rawSocket;
-        protocol = Protocol.H2C;
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         startHttp2(pingIntervalMillis);
         return;
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 1ba93a965..48986270a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -85,7 +85,6 @@
       ENCODING,
       UPGRADE);
 
-  private final OkHttpClient client;
   private final Interceptor.Chain chain;
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
@@ -94,12 +93,12 @@
 
   public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
       Http2Connection connection) {
-    this.client = client;
     this.chain = chain;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
-
-    protocol = client.protocols().contains(Protocol.H2C) ? Protocol.H2C : Protocol.HTTP_2;
+    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        ? Protocol.H2_PRIOR_KNOWLEDGE
+        : Protocol.HTTP_2;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 49c71e8fe..370e64ef4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -200,6 +200,14 @@ public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
+  synchronized void updateConnectionFlowControl(long read) {
+    unacknowledgedBytesRead += read;
+    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead);
+      unacknowledgedBytesRead = 0;
+    }
+  }
+
   /**
    * Returns a new server-initiated stream.
    *
@@ -622,6 +630,7 @@ public Http2Connection build() {
       Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        updateConnectionFlowControl(length);
         source.skip(length);
         return;
       }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 23ddec3aa..d460d63e4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -358,15 +358,7 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
 
       if (read != -1) {
         // Update connection.unacknowledgedBytesRead outside the stream lock.
-        synchronized (connection) { // Multiple application threads may hit this section.
-          connection.unacknowledgedBytesRead += read;
-          if (connection.unacknowledgedBytesRead
-              >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-            connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-            connection.unacknowledgedBytesRead = 0;
-          }
-        }
-
+        updateConnectionFlowControl(read);
         return read;
       }
 
@@ -381,6 +373,11 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
       return -1; // This source is exhausted.
     }
 
+    private void updateConnectionFlowControl(long read) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      connection.updateConnectionFlowControl(read);
+    }
+
     /** Returns once the source is either readable or finished. */
     private void waitUntilReadable() throws IOException {
       readTimeout.enter();
@@ -438,11 +435,16 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
+      long bytesDiscarded;
       synchronized (Http2Stream.this) {
         closed = true;
+        bytesDiscarded = readBuffer.size();
         readBuffer.clear();
         Http2Stream.this.notifyAll();
       }
+      if (bytesDiscarded > 0) {
+        updateConnectionFlowControl(bytesDiscarded);
+      }
       cancelStreamIfNecessary();
     }
   }
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
new file mode 100644
index 000000000..0c6f70757
--- /dev/null
+++ b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
@@ -0,0 +1,11 @@
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/pom.xml b/pom.xml
index 41b3a2029..2c64e0f9e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -25,6 +25,7 @@
     <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
+    <module>okhttp-sse</module>
     <module>okhttp-testing-support</module>
     <module>okhttp-urlconnection</module>
 
@@ -47,7 +48,7 @@
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
     <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.2</apache.http.version>
+    <apache.http.version>4.2.6</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
@@ -137,7 +138,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.6.1</version>
+          <version>3.7.0</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
@@ -148,12 +149,12 @@
             <dependency>
               <groupId>org.codehaus.plexus</groupId>
               <artifactId>plexus-compiler-javac-errorprone</artifactId>
-              <version>2.8.1</version>
+              <version>2.8.4</version>
             </dependency>
             <dependency>
               <groupId>com.google.errorprone</groupId>
               <artifactId>error_prone_core</artifactId>
-              <version>2.0.16</version>
+              <version>2.3.1</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -161,7 +162,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.17</version>
+          <version>2.21.0</version>
           <configuration>
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
@@ -183,7 +184,7 @@
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.17</version>
+              <version>2.21.0</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -622,5 +623,23 @@
         <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_171</id>
+      <activation>
+        <jdk>1.8.0_171</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_172</id>
+      <activation>
+        <jdk>1.8.0_172</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
diff --git a/website/index.html b/website/index.html
index 184ee69ce..67638d570 100644
--- a/website/index.html
+++ b/website/index.html
@@ -119,7 +119,7 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
