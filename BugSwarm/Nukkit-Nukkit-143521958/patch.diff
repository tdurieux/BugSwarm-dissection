diff --git a/pom.xml b/pom.xml
index 8b87032bc7..9578a074db 100755
--- a/pom.xml
+++ b/pom.xml
@@ -63,6 +63,12 @@
             <artifactId>snakeyaml</artifactId>
             <version>1.17</version>
         </dependency>
+
+        <dependency>
+            <groupId>org.avaje</groupId>
+            <artifactId>ebean</artifactId>
+            <version>2.8.1</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/src/main/java/io/nukkit/Nukkit.java b/src/main/java/io/nukkit/Nukkit.java
index 5b0d39035d..4ba0d99b6e 100755
--- a/src/main/java/io/nukkit/Nukkit.java
+++ b/src/main/java/io/nukkit/Nukkit.java
@@ -1,11 +1,15 @@
 package io.nukkit;
 
+import io.nukkit.command.CommandException;
+import io.nukkit.command.CommandSender;
+import io.nukkit.entity.Player;
+import io.nukkit.plugin.PluginManager;
 import io.nukkit.scheduler.Scheduler;
+import io.nukkit.util.ChatColor;
 import io.nukkit.util.Versioning;
 import joptsimple.OptionException;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
-import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.core.LoggerContext;
@@ -16,6 +20,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.List;
 
 /**
@@ -28,10 +33,11 @@
     public static boolean useConsole = true;
 
     public final static String VERSION = Versioning.getNukkitVersion();
-    public final static int API_VERSION = 2;
+    public final static String VERSION_UNKNOWN = "2.0dev";
     public final static String CODENAME = "Brynhildr";
     public final static String MINECRAFT_VERSION = "v0.15.0 alpha";
     public final static String MINECRAFT_VERSION_NETWORK = "0.15.0";
+    public final static int API_VERSION = 2;
 
     private static Server server;
 
@@ -45,8 +51,7 @@ public static void setServer(Server server) {
         }
 
         Nukkit.server = server;
-        server.getLogger().info("This server is running " + getName() + " version " + getVersion() + " (Implementing API version " + getNukkitVersion() + ")");
-
+        server.getLogger().info("This server is running " + getName() + " version " + getNukkitVersion() + " (Implementing API \"" + ChatColor.AQUA + CODENAME + ChatColor.WHITE + "\" version " + API_VERSION + ")");
     }
 
     /**
@@ -70,15 +75,38 @@ public static String getNukkitVersion() {
         return server.getNukkitVersion();
     }
 
+    /**
+     * @see Server#getOnlinePlayers()
+     */
+    public static Collection<? extends Player> getOnlinePlayers() {
+        return server.getOnlinePlayers();
+    }
+
+    /**
+     * @see Server#getPluginManager()
+     */
+    public static PluginManager getPluginManager() {
+        return server.getPluginManager();
+    }
+
+    /**
+     * @see Server#getScheduler()
+     */
     public static Scheduler getScheduler() {
-        return null;
-        //TODO: IMPLEMENT THIS
+        return server.getScheduler();
     }
 
     public static Logger getLogger() {
         return server.getLogger();
     }
 
+    /**
+     * @see Server#dispatchCommand(CommandSender sender, String commandLine)
+     */
+    public static boolean dispatchCommand(CommandSender sender, String commandLine) throws CommandException {
+        return server.dispatchCommand(sender, commandLine);
+    }
+
     public static void main(String[] args) {
 
         OptionParser parser = new OptionParser() {
@@ -87,13 +115,15 @@ public static void main(String[] args) {
 
                 //TODO: SERVER CONFIGURATION ARGUMENTS
 
+                acceptsAll(asList("n", "nukkit-settings"), "File for nukkit settings").withRequiredArg().ofType(File.class).defaultsTo(new File("nukkit.yml"), new File[0]).describedAs("Yml file");
+
                 acceptsAll(asList("nojline"), "Disables jline and emulates the vanilla console");
 
                 acceptsAll(asList("noconsole"), "Disables the console");
 
                 acceptsAll(asList("v", "version"), "Show the version of Nukkit");
 
-                acceptsAll(asList("d", "debug"), "Show the debug logs");
+                acceptsAll(asList("debug"), "Show the debug logs");
             }
         };
 
@@ -102,14 +132,14 @@ public static void main(String[] args) {
         try {
             optionSet = parser.parse(args);
         } catch (OptionException e) {
-            LogManager.getLogger(Nukkit.class.getName()).log(Level.FATAL, e.getLocalizedMessage());
+            LogManager.getLogger(Nukkit.class.getName()).fatal(e.getLocalizedMessage());
         }
 
         if (optionSet == null || optionSet.has("?")) {
             try {
                 parser.printHelpOn(System.out);
             } catch (IOException e) {
-                LogManager.getLogger(Nukkit.class.getName()).log(Level.FATAL, (String) null, e);
+                LogManager.getLogger(Nukkit.class.getName()).fatal((String) null, e);
             }
         } else if (optionSet.has("v")) {
             System.out.println(Server.class.getPackage().getImplementationVersion());
@@ -148,7 +178,7 @@ public static void main(String[] args) {
                     LoggerContext context = (LoggerContext) LogManager.getContext(false);
                     Configuration config = context.getConfiguration();
                     LoggerConfig loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);
-                    loggerConfig.setLevel(Level.DEBUG);
+                    loggerConfig.setLevel(org.apache.logging.log4j.Level.DEBUG);
                     context.updateLoggers();
                 }
 
diff --git a/src/main/java/io/nukkit/Server.java b/src/main/java/io/nukkit/Server.java
index 8f1958f871..5dfc76f9db 100755
--- a/src/main/java/io/nukkit/Server.java
+++ b/src/main/java/io/nukkit/Server.java
@@ -1,28 +1,58 @@
 package io.nukkit;
 
+import com.avaje.ebean.config.DataSourceConfig;
+import com.avaje.ebean.config.ServerConfig;
+import com.avaje.ebean.config.dbplatform.SQLitePlatform;
+import com.avaje.ebeaninternal.server.lib.sql.TransactionIsolation;
+import io.nukkit.command.CommandSender;
+import io.nukkit.command.PluginCommand;
+import io.nukkit.configuration.file.YamlConfiguration;
+import io.nukkit.entity.Player;
 import io.nukkit.plugin.PluginManager;
+import io.nukkit.plugin.ServicesManager;
+import io.nukkit.plugin.TestPluginLogger;
+import io.nukkit.plugin.messaging.Messenger;
+import io.nukkit.scheduler.Scheduler;
 import io.nukkit.util.*;
 import jline.UnsupportedTerminal;
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
 
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.Map;
 
 /**
  * author: MagicDroidX
  * Nukkit Project
  */
 public class Server implements Runnable {
+    /**
+     * Used for all administrative messages, such as an operator using a
+     * command.
+     * <p>
+     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
+     */
+    public static final String BROADCAST_CHANNEL_ADMINISTRATIVE = "bukkit.broadcast.admin";
+
+    /**
+     * Used for all announcement messages, such as informing users that a
+     * player has joined.
+     * <p>
+     * For use in {@link #broadcast(java.lang.String, java.lang.String)}.
+     */
+    public static final String BROADCAST_CHANNEL_USERS = "bukkit.broadcast.user";
 
-    private final String serverVersion;
     private final String nukkitVersion = Versioning.getNukkitVersion();
-    private final Logger logger = Logger.getLogger("Minecraft");
+    private final Logger logger = LogManager.getLogger("Minecraft");
+    private YamlConfiguration configuration;
 
     public OptionSet options;
 
@@ -35,7 +65,11 @@
 
     List<String> commandQueue = new ArrayList<>();
 
+    private Thread serverThread;
+
     public Server(OptionSet options) {
+        Nukkit.setServer(this);
+
         this.options = options;
 
         if (System.console() == null && System.getProperty(jline.TerminalFactory.JLINE_TERMINAL) == null) {
@@ -51,8 +85,6 @@ public Server(OptionSet options) {
             }
         }
 
-        this.serverVersion = Server.class.getPackage().getImplementationVersion();
-
         try {
             this.reader = new ConsoleReader(System.in, System.out);
             this.reader.setExpandEvents(false);
@@ -65,7 +97,7 @@ public Server(OptionSet options) {
                 this.reader = new ConsoleReader(System.in, System.out);
                 this.reader.setExpandEvents(false);
             } catch (IOException ex) {
-                this.getLogger().log(Level.WARNING, null, ex);
+                this.getLogger().log(Level.WARN, (String) null, ex);
             }
         }
 
@@ -75,19 +107,25 @@ public Server(OptionSet options) {
 
         (new ConsoleWriter(System.out, this.reader)).start();
 
-        org.apache.logging.log4j.Logger rootLogger = LogManager.getRootLogger();
+        Logger rootLogger = LogManager.getRootLogger();
         System.setOut(new PrintStream(new LoggerOutputStream(rootLogger, org.apache.logging.log4j.Level.INFO), true));
         System.setErr(new PrintStream(new LoggerOutputStream(rootLogger, org.apache.logging.log4j.Level.WARN), true));
-        (new Thread(this, "Server Thread")).start();
+
+        TestPluginLogger logger = new TestPluginLogger("Brynhildr");
+        logger.info("Plugin logger test" + ChatColor.YELLOW + " Color test");
+
+        this.serverThread = new Thread(this, "Server Thread");
+        this.serverThread.start();
     }
 
     @Override
     public void run() {
         while (this.isRunning) {
             while (!commandQueue.isEmpty()) {
+                //TODO: REAL HANDLING
                 String command = commandQueue.get(0);
                 commandQueue.remove(0);
-                dispatchCommand(command);
+                dispatchCommand(null, command);
             }
 
             try {
@@ -115,13 +153,18 @@ public String getName() {
     }
 
     public String getVersion() {
-        return this.serverVersion + " (MCPE: " + Nukkit.MINECRAFT_VERSION + ")";
+        return Nukkit.MINECRAFT_VERSION;
     }
 
     public String getNukkitVersion() {
         return nukkitVersion;
     }
 
+    public List<Player> getOnlinePlayers() {
+        return new ArrayList<>();
+        //TODO
+    }
+
     public int getPort() {
         return port;
     }
@@ -130,11 +173,77 @@ public void setPort(int port) {
         this.port = port;
     }
 
+    public String getUpdateFolder() {
+        return "update";
+        //TODO
+    }
+
     public PluginManager getPluginManager() {
         return null;
-        //TODO:
+        //TODO
     }
 
+    public Scheduler getScheduler() {
+        return null;
+        //TODO
+    }
+
+    public ServicesManager getServicesManager() {
+        return null;
+        //TODO
+    }
+
+    public Messenger getMessenger() {
+        return null;
+        //TODO
+    }
+
+    public boolean isServerThread() {
+        return Thread.currentThread().equals(this.serverThread);
+    }
+
+    public Map<String, String[]> getCommandAliases() {
+        return new HashMap<>();
+        //TODO
+    }
+
+    public Player getPlayer(String name) {
+        //TODO
+        return null;
+    }
+
+    public Warning.WarningState getWarningState() {
+        return Warning.WarningState.DEFAULT;
+        //TODO
+    }
+
+    public int broadcast(String message, String permission) {
+        return 0;
+        //TODO
+    }
+
+    public PluginCommand getPluginCommand(String name) {
+        return null;
+        //TODO
+    }
+
+    public void configureDbConfig(ServerConfig config) {
+        Validate.notNull(config, "Config cannot be null");
+        DataSourceConfig ds = new DataSourceConfig();
+        ds.setDriver(this.configuration.getString("database.driver"));
+        ds.setUrl(this.configuration.getString("database.url"));
+        ds.setUsername(this.configuration.getString("database.username"));
+        ds.setPassword(this.configuration.getString("database.password"));
+        ds.setIsolationLevel(TransactionIsolation.getLevel(this.configuration.getString("database.isolation")));
+        if (ds.getDriver().contains("sqlite")) {
+            config.setDatabasePlatform(new SQLitePlatform());
+            config.getDatabasePlatform().getDbDdlSyntax().setIdentity("");
+        }
+
+        config.setDataSourceConfig(ds);
+    }
+
+
     public Logger getLogger() {
         return this.logger;
     }
@@ -143,7 +252,9 @@ public void issueCommand(String command) {
         this.commandQueue.add(command);
     }
 
-    public void dispatchCommand(String command) {
-        this.getLogger().info(command);
+    public boolean dispatchCommand(CommandSender sender, String commandLine) {
+        this.getLogger().info(commandLine);
+        return true;
+        //TODO
     }
 }
diff --git a/src/main/java/io/nukkit/command/BlockCommandSender.java b/src/main/java/io/nukkit/command/BlockCommandSender.java
index 9e82b2f6a6..58c220f266 100755
--- a/src/main/java/io/nukkit/command/BlockCommandSender.java
+++ b/src/main/java/io/nukkit/command/BlockCommandSender.java
@@ -1,13 +1,6 @@
 package io.nukkit.command;
 
-import org.bukkit.block.Block;
 
 public interface BlockCommandSender extends CommandSender {
-
-    /**
-     * Returns the block this command sender belongs to
-     *
-     * @return Block for the command sender
-     */
-    Block getBlock();
+    //TODO
 }
diff --git a/src/main/java/io/nukkit/command/Command.java b/src/main/java/io/nukkit/command/Command.java
index 7a1bdaa110..9d426d5187 100755
--- a/src/main/java/io/nukkit/command/Command.java
+++ b/src/main/java/io/nukkit/command/Command.java
@@ -1,15 +1,14 @@
 package io.nukkit.command;
 
 import com.google.common.collect.ImmutableList;
-import org.apache.commons.lang.Validate;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Server;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.minecart.CommandMinecart;
-import org.bukkit.permissions.Permissible;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.util.StringUtil;
+import io.nukkit.Nukkit;
+import io.nukkit.Server;
+import io.nukkit.entity.Player;
+import io.nukkit.permissions.Permissible;
+import io.nukkit.plugin.PluginDescriptionFile;
+import io.nukkit.util.ChatColor;
+import io.nukkit.util.StringUtil;
+import org.apache.commons.lang3.Validate;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -351,24 +350,24 @@ public static void broadcastCommandMessage(CommandSender source, String message)
 
     public static void broadcastCommandMessage(CommandSender source, String message, boolean sendToSource) {
         String result = source.getName() + ": " + message;
-
-        if (source instanceof BlockCommandSender) {
+        //TODO: IMPLEMENT THIS WHEN THERE IS COMMAND BLOCK IN MINECRAFT:PE
+        /*if (source instanceof BlockCommandSender) {
             BlockCommandSender blockCommandSender = (BlockCommandSender) source;
 
             if (blockCommandSender.getBlock().getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
-                Bukkit.getConsoleSender().sendMessage(result);
+                Nukkit.getConsoleSender().sendMessage(result);
                 return;
             }
-        } else if (source instanceof CommandMinecart) {
+        }else if (source instanceof CommandMinecart) {
             CommandMinecart commandMinecart = (CommandMinecart) source;
 
             if (commandMinecart.getWorld().getGameRuleValue("commandBlockOutput").equalsIgnoreCase("false")) {
-                Bukkit.getConsoleSender().sendMessage(result);
+                Nukkit.getConsoleSender().sendMessage(result);
                 return;
             }
-        }
+        }*/
 
-        Set<Permissible> users = Bukkit.getPluginManager().getPermissionSubscriptions(Server.BROADCAST_CHANNEL_ADMINISTRATIVE);
+        Set<Permissible> users = Nukkit.getPluginManager().getPermissionSubscriptions(Server.BROADCAST_CHANNEL_ADMINISTRATIVE);
         String colored = ChatColor.GRAY + "" + ChatColor.ITALIC + "[" + result + ChatColor.GRAY + ChatColor.ITALIC + "]";
 
         if (sendToSource && !(source instanceof ConsoleCommandSender)) {
diff --git a/src/main/java/io/nukkit/command/CommandSender.java b/src/main/java/io/nukkit/command/CommandSender.java
index fcf18181a7..261b498db0 100755
--- a/src/main/java/io/nukkit/command/CommandSender.java
+++ b/src/main/java/io/nukkit/command/CommandSender.java
@@ -1,7 +1,7 @@
 package io.nukkit.command;
 
-import org.bukkit.Server;
-import org.bukkit.permissions.Permissible;
+import io.nukkit.Server;
+import io.nukkit.permissions.Permissible;
 
 public interface CommandSender extends Permissible {
 
diff --git a/src/main/java/io/nukkit/command/ConsoleCommandSender.java b/src/main/java/io/nukkit/command/ConsoleCommandSender.java
index c88537c105..e67048e049 100755
--- a/src/main/java/io/nukkit/command/ConsoleCommandSender.java
+++ b/src/main/java/io/nukkit/command/ConsoleCommandSender.java
@@ -1,6 +1,6 @@
 package io.nukkit.command;
 
-import org.bukkit.conversations.Conversable;
+import io.nukkit.conversations.Conversable;
 
 public interface ConsoleCommandSender extends CommandSender, Conversable {
 }
diff --git a/src/main/java/io/nukkit/command/FormattedCommandAlias.java b/src/main/java/io/nukkit/command/FormattedCommandAlias.java
index 09d4e101f6..d31071c6b6 100755
--- a/src/main/java/io/nukkit/command/FormattedCommandAlias.java
+++ b/src/main/java/io/nukkit/command/FormattedCommandAlias.java
@@ -1,6 +1,7 @@
 package io.nukkit.command;
 
-import org.bukkit.Bukkit;
+import io.nukkit.Nukkit;
+import io.nukkit.util.ChatColor;
 
 import java.util.ArrayList;
 
@@ -23,14 +24,14 @@ public boolean execute(CommandSender sender, String commandLabel, String[] args)
                 if (throwable instanceof IllegalArgumentException) {
                     sender.sendMessage(throwable.getMessage());
                 } else {
-                    sender.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
+                    sender.sendMessage(ChatColor.RED + "An internal error occurred while attempting to perform this command");
                 }
                 return false;
             }
         }
 
         for (String command : commands) {
-            result |= Bukkit.dispatchCommand(sender, command);
+            result |= Nukkit.dispatchCommand(sender, command);
         }
 
         return result;
diff --git a/src/main/java/io/nukkit/command/PluginCommand.java b/src/main/java/io/nukkit/command/PluginCommand.java
index c7475c1f82..a974ebafcf 100755
--- a/src/main/java/io/nukkit/command/PluginCommand.java
+++ b/src/main/java/io/nukkit/command/PluginCommand.java
@@ -1,7 +1,7 @@
 package io.nukkit.command;
 
-import org.apache.commons.lang.Validate;
-import org.bukkit.plugin.Plugin;
+import io.nukkit.plugin.Plugin;
+import org.apache.commons.lang3.Validate;
 
 import java.util.List;
 
diff --git a/src/main/java/io/nukkit/command/PluginCommandYamlParser.java b/src/main/java/io/nukkit/command/PluginCommandYamlParser.java
index 5a318209eb..b9b7ed85ec 100755
--- a/src/main/java/io/nukkit/command/PluginCommandYamlParser.java
+++ b/src/main/java/io/nukkit/command/PluginCommandYamlParser.java
@@ -1,7 +1,8 @@
 package io.nukkit.command;
 
-import org.bukkit.Bukkit;
-import org.bukkit.plugin.Plugin;
+import io.nukkit.Nukkit;
+import io.nukkit.plugin.Plugin;
+import org.apache.logging.log4j.Level;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -21,7 +22,7 @@
 
         for (Entry<String, Map<String, Object>> entry : map.entrySet()) {
             if (entry.getKey().contains(":")) {
-                Bukkit.getServer().getLogger().severe("Could not load command " + entry.getKey() + " for plugin " + plugin.getName() + ": Illegal Characters");
+                Nukkit.getServer().getLogger().log(Level.ERROR, "Could not load command " + entry.getKey() + " for plugin " + plugin.getName() + ": Illegal Characters");
                 continue;
             }
             Command newCmd = new PluginCommand(entry.getKey(), plugin);
@@ -45,14 +46,14 @@
                 if (aliases instanceof List) {
                     for (Object o : (List<?>) aliases) {
                         if (o.toString().contains(":")) {
-                            Bukkit.getServer().getLogger().severe("Could not load alias " + o.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
+                            Nukkit.getServer().getLogger().log(Level.ERROR, "Could not load alias " + o.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
                             continue;
                         }
                         aliasList.add(o.toString());
                     }
                 } else {
                     if (aliases.toString().contains(":")) {
-                        Bukkit.getServer().getLogger().severe("Could not load alias " + aliases.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
+                        Nukkit.getServer().getLogger().log(Level.ERROR, "Could not load alias " + aliases.toString() + " for plugin " + plugin.getName() + ": Illegal Characters");
                     } else {
                         aliasList.add(aliases.toString());
                     }
diff --git a/src/main/java/io/nukkit/command/PluginIdentifiableCommand.java b/src/main/java/io/nukkit/command/PluginIdentifiableCommand.java
index d4b5f5da23..270e6c8f6e 100755
--- a/src/main/java/io/nukkit/command/PluginIdentifiableCommand.java
+++ b/src/main/java/io/nukkit/command/PluginIdentifiableCommand.java
@@ -1,6 +1,6 @@
 package io.nukkit.command;
 
-import org.bukkit.plugin.Plugin;
+import io.nukkit.plugin.Plugin;
 
 /**
  * This interface is used by the help system to group commands into
diff --git a/src/main/java/io/nukkit/command/SimpleCommandMap.java b/src/main/java/io/nukkit/command/SimpleCommandMap.java
index 560392898b..8ad791c0d9 100755
--- a/src/main/java/io/nukkit/command/SimpleCommandMap.java
+++ b/src/main/java/io/nukkit/command/SimpleCommandMap.java
@@ -1,15 +1,15 @@
 package io.nukkit.command;
 
-import org.apache.commons.lang.Validate;
-import org.bukkit.Server;
-import org.bukkit.command.defaults.*;
-import org.bukkit.entity.Player;
-import org.bukkit.util.StringUtil;
+import io.nukkit.Server;
+import io.nukkit.command.defaults.VanillaCommand;
+import io.nukkit.entity.Player;
+import io.nukkit.util.StringUtil;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 
 import java.util.*;
 import java.util.regex.Pattern;
 
-import static org.bukkit.util.Java15Compat.Arrays_copyOfRange;
 
 public class SimpleCommandMap implements CommandMap {
     private static final Pattern PATTERN_ON_SPACE = Pattern.compile(" ", Pattern.LITERAL);
@@ -22,18 +22,20 @@ public SimpleCommandMap(final Server server) {
     }
 
     private void setDefaultCommands() {
-        register("bukkit", new SaveCommand());
+        //TODO
+        /*register("bukkit", new SaveCommand());
         register("bukkit", new SaveOnCommand());
         register("bukkit", new SaveOffCommand());
         register("bukkit", new StopCommand());
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
         register("bukkit", new PluginsCommand("plugins"));
-        register("bukkit", new TimingsCommand("timings"));
+        register("bukkit", new TimingsCommand("timings"));*/
     }
 
     public void setFallbackCommands() {
-        register("bukkit", new ListCommand());
+        //TODO
+        /*register("bukkit", new ListCommand());
         register("bukkit", new OpCommand());
         register("bukkit", new DeopCommand());
         register("bukkit", new BanIpCommand());
@@ -69,7 +71,7 @@ public void setFallbackCommands() {
         register("bukkit", new SpreadPlayersCommand());
         register("bukkit", new SetWorldSpawnCommand());
         register("bukkit", new SetIdleTimeoutCommand());
-        register("bukkit", new AchievementCommand());
+        register("bukkit", new AchievementCommand());*/
     }
 
     /**
@@ -171,7 +173,7 @@ public boolean dispatch(CommandSender sender, String commandLine) throws Command
 
         try {
             // Note: we don't return the result of target.execute as thats success / failure, we return handled (true) or not handled (false)
-            target.execute(sender, sentCommandLabel, Arrays_copyOfRange(args, 1, args.length));
+            target.execute(sender, sentCommandLabel, Arrays.copyOfRange(args, 1, args.length));
         } catch (CommandException ex) {
             throw ex;
         } catch (Throwable ex) {
@@ -256,7 +258,7 @@ public void registerServerAliases() {
 
         for (String alias : values.keySet()) {
             if (alias.contains(":") || alias.contains(" ")) {
-                server.getLogger().warning("Could not register alias " + alias + " because it contains illegal characters");
+                server.getLogger().log(Level.WARN, "Could not register alias " + alias + " because it contains illegal characters");
                 continue;
             }
 
@@ -279,7 +281,7 @@ public void registerServerAliases() {
             }
 
             if (bad.length() > 0) {
-                server.getLogger().warning("Could not register alias " + alias + " because it contains commands that do not exist: " + bad);
+                server.getLogger().log(Level.WARN, "Could not register alias " + alias + " because it contains commands that do not exist: " + bad);
                 continue;
             }
 
diff --git a/src/main/java/io/nukkit/command/defaults/VanillaCommand.java b/src/main/java/io/nukkit/command/defaults/VanillaCommand.java
new file mode 100755
index 0000000000..05dcd1519f
--- /dev/null
+++ b/src/main/java/io/nukkit/command/defaults/VanillaCommand.java
@@ -0,0 +1,110 @@
+package io.nukkit.command.defaults;
+
+import io.nukkit.command.Command;
+import io.nukkit.command.CommandSender;
+
+import java.util.List;
+
+public abstract class VanillaCommand extends Command {
+    static final int MAX_COORD = 30000000;
+    static final int MIN_COORD_MINUS_ONE = -30000001;
+    static final int MIN_COORD = -30000000;
+
+    protected VanillaCommand(String name) {
+        super(name);
+    }
+
+    protected VanillaCommand(String name, String description, String usageMessage, List<String> aliases) {
+        super(name, description, usageMessage, aliases);
+    }
+
+    public boolean matches(String input) {
+        return input.equalsIgnoreCase(this.getName());
+    }
+
+    protected int getInteger(CommandSender sender, String value, int min) {
+        return getInteger(sender, value, min, Integer.MAX_VALUE);
+    }
+
+    int getInteger(CommandSender sender, String value, int min, int max) {
+        return getInteger(sender, value, min, max, false);
+    }
+
+    int getInteger(CommandSender sender, String value, int min, int max, boolean Throws) {
+        int i = min;
+
+        try {
+            i = Integer.valueOf(value);
+        } catch (NumberFormatException ex) {
+            if (Throws) {
+                throw new NumberFormatException(String.format("%s is not a valid number", value));
+            }
+        }
+
+        if (i < min) {
+            i = min;
+        } else if (i > max) {
+            i = max;
+        }
+
+        return i;
+    }
+
+    Integer getInteger(String value) {
+        try {
+            return Integer.valueOf(value);
+        } catch (NumberFormatException ex) {
+            return null;
+        }
+    }
+
+    public static double getRelativeDouble(double original, CommandSender sender, String input) {
+        if (input.startsWith("~")) {
+            double value = getDouble(sender, input.substring(1));
+            if (value == MIN_COORD_MINUS_ONE) {
+                return MIN_COORD_MINUS_ONE;
+            }
+            return original + value;
+        } else {
+            return getDouble(sender, input);
+        }
+    }
+
+    public static double getDouble(CommandSender sender, String input) {
+        try {
+            return Double.parseDouble(input);
+        } catch (NumberFormatException ex) {
+            return MIN_COORD_MINUS_ONE;
+        }
+    }
+
+    public static double getDouble(CommandSender sender, String input, double min, double max) {
+        double result = getDouble(sender, input);
+
+        // TODO: This should throw an exception instead.
+        if (result < min) {
+            result = min;
+        } else if (result > max) {
+            result = max;
+        }
+
+        return result;
+    }
+
+    String createString(String[] args, int start) {
+        return createString(args, start, " ");
+    }
+
+    String createString(String[] args, int start, String glue) {
+        StringBuilder string = new StringBuilder();
+
+        for (int x = start; x < args.length; x++) {
+            string.append(args[x]);
+            if (x != args.length - 1) {
+                string.append(glue);
+            }
+        }
+
+        return string.toString();
+    }
+}
diff --git a/src/main/java/io/nukkit/configuration/file/FileConfiguration.java b/src/main/java/io/nukkit/configuration/file/FileConfiguration.java
index 1ef9bb2280..a45eb36038 100755
--- a/src/main/java/io/nukkit/configuration/file/FileConfiguration.java
+++ b/src/main/java/io/nukkit/configuration/file/FileConfiguration.java
@@ -6,8 +6,10 @@
 import io.nukkit.configuration.InvalidConfigurationException;
 import io.nukkit.configuration.MemoryConfiguration;
 import org.apache.commons.lang3.Validate;
+import org.yaml.snakeyaml.external.biz.base64Coder.Base64Coder;
 
 import java.io.*;
+import java.nio.charset.Charset;
 
 /**
  * This is a base class for all File based implementations of {@link
@@ -15,6 +17,42 @@
  */
 public abstract class FileConfiguration extends MemoryConfiguration {
 
+    /**
+     * This value specified that the system default encoding should be
+     * completely ignored, as it cannot handle the ASCII character set, or it
+     * is a strict-subset of UTF8 already (plain ASCII).
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean UTF8_OVERRIDE;
+    /**
+     * This value specifies if the system default encoding is unicode, but
+     * cannot parse standard ASCII.
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean UTF_BIG;
+    /**
+     * This value specifies if the system supports unicode.
+     *
+     * @deprecated temporary compatibility measure
+     */
+    @Deprecated
+    public static final boolean SYSTEM_UTF;
+
+    static {
+        final byte[] testBytes = Base64Coder.decode("ICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX4NCg==");
+        final String testString = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\r\n";
+        final Charset defaultCharset = Charset.defaultCharset();
+        final String resultString = new String(testBytes, defaultCharset);
+        final boolean trueUTF = defaultCharset.name().contains("UTF");
+        UTF8_OVERRIDE = !testString.equals(resultString) || defaultCharset.equals(Charset.forName("US-ASCII"));
+        SYSTEM_UTF = trueUTF || UTF8_OVERRIDE;
+        UTF_BIG = trueUTF && UTF8_OVERRIDE;
+    }
+
     /**
      * Creates an empty {@link FileConfiguration} with no default values.
      */
diff --git a/src/main/java/io/nukkit/configuration/file/YamlConfiguration.java b/src/main/java/io/nukkit/configuration/file/YamlConfiguration.java
index 884a7bf379..7ef455aa45 100755
--- a/src/main/java/io/nukkit/configuration/file/YamlConfiguration.java
+++ b/src/main/java/io/nukkit/configuration/file/YamlConfiguration.java
@@ -47,7 +47,7 @@ public static YamlConfiguration loadConfiguration(File file) {
             config.load(file);
         } catch (FileNotFoundException ignored) {
         } catch (IOException | InvalidConfigurationException ex) {
-            Nukkit.getLogger().log(Level.FATAL, "Cannot load " + file, ex);
+            Nukkit.getLogger().log(Level.ERROR, "Cannot load " + file, ex);
         }
 
         return config;
@@ -76,7 +76,7 @@ public static YamlConfiguration loadConfiguration(InputStream stream) {
         try {
             config.load(stream);
         } catch (IOException | InvalidConfigurationException ex) {
-            Nukkit.getLogger().log(Level.FATAL, "Cannot load configuration from stream", ex);
+            Nukkit.getLogger().log(Level.ERROR, "Cannot load configuration from stream", ex);
         }
 
         return config;
@@ -101,7 +101,7 @@ public static YamlConfiguration loadConfiguration(Reader reader) {
         try {
             config.load(reader);
         } catch (IOException | InvalidConfigurationException ex) {
-            Nukkit.getLogger().log(Level.FATAL, "Cannot load configuration from stream", ex);
+            Nukkit.getLogger().log(Level.ERROR, "Cannot load configuration from stream", ex);
         }
 
         return config;
diff --git a/src/main/java/io/nukkit/conversations/BooleanPrompt.java b/src/main/java/io/nukkit/conversations/BooleanPrompt.java
new file mode 100755
index 0000000000..c813b6f35d
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/BooleanPrompt.java
@@ -0,0 +1,36 @@
+package io.nukkit.conversations;
+
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.BooleanUtils;
+
+/**
+ * BooleanPrompt is the base class for any prompt that requires a boolean
+ * response from the user.
+ */
+public abstract class BooleanPrompt extends ValidatingPrompt {
+
+    public BooleanPrompt() {
+        super();
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        String[] accepted = {"true", "false", "on", "off", "yes", "no"};
+        return ArrayUtils.contains(accepted, input.toLowerCase());
+    }
+
+    @Override
+    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        return acceptValidatedInput(context, BooleanUtils.toBoolean(input));
+    }
+
+    /**
+     * Override this method to perform some action with the user's boolean
+     * response.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The user's boolean response.
+     * @return The next {@link Prompt} in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, boolean input);
+}
diff --git a/src/main/java/io/nukkit/conversations/Conversable.java b/src/main/java/io/nukkit/conversations/Conversable.java
new file mode 100755
index 0000000000..8fcf83f08b
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/Conversable.java
@@ -0,0 +1,55 @@
+package io.nukkit.conversations;
+
+/**
+ * The Conversable interface is used to indicate objects that can have
+ * conversations.
+ */
+public interface Conversable {
+
+    /**
+     * Tests to see of a Conversable object is actively engaged in a
+     * conversation.
+     *
+     * @return True if a conversation is in progress
+     */
+    public boolean isConversing();
+
+    /**
+     * Accepts input into the active conversation. If no conversation is in
+     * progress, this method does nothing.
+     *
+     * @param input The input message into the conversation
+     */
+    public void acceptConversationInput(String input);
+
+    /**
+     * Enters into a dialog with a Conversation object.
+     *
+     * @param conversation The conversation to begin
+     * @return True if the conversation should proceed, false if it has been
+     * enqueued
+     */
+    public boolean beginConversation(Conversation conversation);
+
+    /**
+     * Abandons an active conversation.
+     *
+     * @param conversation The conversation to abandon
+     */
+    public void abandonConversation(Conversation conversation);
+
+    /**
+     * Abandons an active conversation.
+     *
+     * @param conversation The conversation to abandon
+     * @param details      Details about why the conversation was abandoned
+     */
+    public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details);
+
+    /**
+     * Sends this sender a message raw
+     *
+     * @param message Message to be displayed
+     */
+    public void sendRawMessage(String message);
+}
diff --git a/src/main/java/io/nukkit/conversations/Conversation.java b/src/main/java/io/nukkit/conversations/Conversation.java
new file mode 100755
index 0000000000..71b236235b
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/Conversation.java
@@ -0,0 +1,297 @@
+package io.nukkit.conversations;
+
+import io.nukkit.plugin.Plugin;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * The Conversation class is responsible for tracking the current state of a
+ * conversation, displaying prompts to the user, and dispatching the user's
+ * response to the appropriate place. Conversation objects are not typically
+ * instantiated directly. Instead a {@link ConversationFactory} is used to
+ * construct identical conversations on demand.
+ * <p>
+ * Conversation flow consists of a directed graph of {@link Prompt} objects.
+ * Each time a prompt gets input from the user, it must return the next prompt
+ * in the graph. Since each Prompt chooses the next Prompt, complex
+ * conversation trees can be implemented where the nature of the player's
+ * response directs the flow of the conversation.
+ * <p>
+ * Each conversation has a {@link ConversationPrefix} that prepends all output
+ * from the conversation to the player. The ConversationPrefix can be used to
+ * display the plugin name or conversation status as the conversation evolves.
+ * <p>
+ * Each conversation has a timeout measured in the number of inactive seconds
+ * to wait before abandoning the conversation. If the inactivity timeout is
+ * reached, the conversation is abandoned and the user's incoming and outgoing
+ * chat is returned to normal.
+ * <p>
+ * You should not construct a conversation manually. Instead, use the {@link
+ * ConversationFactory} for access to all available options.
+ */
+public class Conversation {
+
+    private Prompt firstPrompt;
+    private boolean abandoned;
+    protected Prompt currentPrompt;
+    protected ConversationContext context;
+    protected boolean modal;
+    protected boolean localEchoEnabled;
+    protected ConversationPrefix prefix;
+    protected List<ConversationCanceller> cancellers;
+    protected List<ConversationAbandonedListener> abandonedListeners;
+
+    /**
+     * Initializes a new Conversation.
+     *
+     * @param plugin      The plugin that owns this conversation.
+     * @param forWhom     The entity for whom this conversation is mediating.
+     * @param firstPrompt The first prompt in the conversation graph.
+     */
+    public Conversation(Plugin plugin, Conversable forWhom, Prompt firstPrompt) {
+        this(plugin, forWhom, firstPrompt, new HashMap<>());
+    }
+
+    /**
+     * Initializes a new Conversation.
+     *
+     * @param plugin             The plugin that owns this conversation.
+     * @param forWhom            The entity for whom this conversation is mediating.
+     * @param firstPrompt        The first prompt in the conversation graph.
+     * @param initialSessionData Any initial values to put in the conversation
+     *                           context sessionData map.
+     */
+    public Conversation(Plugin plugin, Conversable forWhom, Prompt firstPrompt, Map<Object, Object> initialSessionData) {
+        this.firstPrompt = firstPrompt;
+        this.context = new ConversationContext(plugin, forWhom, initialSessionData);
+        this.modal = true;
+        this.localEchoEnabled = true;
+        this.prefix = new NullConversationPrefix();
+        this.cancellers = new ArrayList<>();
+        this.abandonedListeners = new ArrayList<>();
+    }
+
+    /**
+     * Gets the entity for whom this conversation is mediating.
+     *
+     * @return The entity.
+     */
+    public Conversable getForWhom() {
+        return context.getForWhom();
+    }
+
+    /**
+     * Gets the modality of this conversation. If a conversation is modal, all
+     * messages directed to the player are suppressed for the duration of the
+     * conversation.
+     *
+     * @return The conversation modality.
+     */
+    public boolean isModal() {
+        return modal;
+    }
+
+    /**
+     * Sets the modality of this conversation.  If a conversation is modal,
+     * all messages directed to the player are suppressed for the duration of
+     * the conversation.
+     *
+     * @param modal The new conversation modality.
+     */
+    void setModal(boolean modal) {
+        this.modal = modal;
+    }
+
+    /**
+     * Gets the status of local echo for this conversation. If local echo is
+     * enabled, any text submitted to a conversation gets echoed back into the
+     * submitter's chat window.
+     *
+     * @return The status of local echo.
+     */
+    public boolean isLocalEchoEnabled() {
+        return localEchoEnabled;
+    }
+
+    /**
+     * Sets the status of local echo for this conversation. If local echo is
+     * enabled, any text submitted to a conversation gets echoed back into the
+     * submitter's chat window.
+     *
+     * @param localEchoEnabled The status of local echo.
+     */
+    public void setLocalEchoEnabled(boolean localEchoEnabled) {
+        this.localEchoEnabled = localEchoEnabled;
+    }
+
+    /**
+     * Gets the {@link ConversationPrefix} that prepends all output from this
+     * conversation.
+     *
+     * @return The ConversationPrefix in use.
+     */
+    public ConversationPrefix getPrefix() {
+        return prefix;
+    }
+
+    /**
+     * Sets the {@link ConversationPrefix} that prepends all output from this
+     * conversation.
+     *
+     * @param prefix The ConversationPrefix to use.
+     */
+    void setPrefix(ConversationPrefix prefix) {
+        this.prefix = prefix;
+    }
+
+    /**
+     * Adds a {@link ConversationCanceller} to the cancellers collection.
+     *
+     * @param canceller The {@link ConversationCanceller} to add.
+     */
+    void addConversationCanceller(ConversationCanceller canceller) {
+        canceller.setConversation(this);
+        this.cancellers.add(canceller);
+    }
+
+    /**
+     * Gets the list of {@link ConversationCanceller}s
+     *
+     * @return The list.
+     */
+    public List<ConversationCanceller> getCancellers() {
+        return cancellers;
+    }
+
+    /**
+     * Returns the Conversation's {@link ConversationContext}.
+     *
+     * @return The ConversationContext.
+     */
+    public ConversationContext getContext() {
+        return context;
+    }
+
+    /**
+     * Displays the first prompt of this conversation and begins redirecting
+     * the user's chat responses.
+     */
+    public void begin() {
+        if (currentPrompt == null) {
+            abandoned = false;
+            currentPrompt = firstPrompt;
+            context.getForWhom().beginConversation(this);
+        }
+    }
+
+    /**
+     * Returns Returns the current state of the conversation.
+     *
+     * @return The current state of the conversation.
+     */
+    public ConversationState getState() {
+        if (currentPrompt != null) {
+            return ConversationState.STARTED;
+        } else if (abandoned) {
+            return ConversationState.ABANDONED;
+        } else {
+            return ConversationState.UNSTARTED;
+        }
+    }
+
+    /**
+     * Passes player input into the current prompt. The next prompt (as
+     * determined by the current prompt) is then displayed to the user.
+     *
+     * @param input The user's chat text.
+     */
+    public void acceptInput(String input) {
+        if (currentPrompt != null) {
+
+            // Echo the user's input
+            if (localEchoEnabled) {
+                context.getForWhom().sendRawMessage(prefix.getPrefix(context) + input);
+            }
+
+            // Test for conversation abandonment based on input
+            for (ConversationCanceller canceller : cancellers) {
+                if (canceller.cancelBasedOnInput(context, input)) {
+                    abandon(new ConversationAbandonedEvent(this, canceller));
+                    return;
+                }
+            }
+
+            // Not abandoned, output the next prompt
+            currentPrompt = currentPrompt.acceptInput(context, input);
+            outputNextPrompt();
+        }
+    }
+
+    /**
+     * Adds a {@link ConversationAbandonedListener}.
+     *
+     * @param listener The listener to add.
+     */
+    public synchronized void addConversationAbandonedListener(ConversationAbandonedListener listener) {
+        abandonedListeners.add(listener);
+    }
+
+    /**
+     * Removes a {@link ConversationAbandonedListener}.
+     *
+     * @param listener The listener to remove.
+     */
+    public synchronized void removeConversationAbandonedListener(ConversationAbandonedListener listener) {
+        abandonedListeners.remove(listener);
+    }
+
+    /**
+     * Abandons and resets the current conversation. Restores the user's
+     * normal chat behavior.
+     */
+    public void abandon() {
+        abandon(new ConversationAbandonedEvent(this, new ManuallyAbandonedConversationCanceller()));
+    }
+
+    /**
+     * Abandons and resets the current conversation. Restores the user's
+     * normal chat behavior.
+     *
+     * @param details Details about why the conversation was abandoned
+     */
+    public synchronized void abandon(ConversationAbandonedEvent details) {
+        if (!abandoned) {
+            abandoned = true;
+            currentPrompt = null;
+            context.getForWhom().abandonConversation(this);
+            for (ConversationAbandonedListener listener : abandonedListeners) {
+                listener.conversationAbandoned(details);
+            }
+        }
+    }
+
+    /**
+     * Displays the next user prompt and abandons the conversation if the next
+     * prompt is null.
+     */
+    public void outputNextPrompt() {
+        if (currentPrompt == null) {
+            abandon(new ConversationAbandonedEvent(this));
+        } else {
+            context.getForWhom().sendRawMessage(prefix.getPrefix(context) + currentPrompt.getPromptText(context));
+            if (!currentPrompt.blocksForInput(context)) {
+                currentPrompt = currentPrompt.acceptInput(context, null);
+                outputNextPrompt();
+            }
+        }
+    }
+
+    public enum ConversationState {
+        UNSTARTED,
+        STARTED,
+        ABANDONED
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationAbandonedEvent.java b/src/main/java/io/nukkit/conversations/ConversationAbandonedEvent.java
new file mode 100755
index 0000000000..069185139e
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationAbandonedEvent.java
@@ -0,0 +1,53 @@
+package io.nukkit.conversations;
+
+import java.util.EventObject;
+
+/**
+ * ConversationAbandonedEvent contains information about an abandoned
+ * conversation.
+ */
+public class ConversationAbandonedEvent extends EventObject {
+
+    private ConversationContext context;
+    private ConversationCanceller canceller;
+
+    public ConversationAbandonedEvent(Conversation conversation) {
+        this(conversation, null);
+    }
+
+    public ConversationAbandonedEvent(Conversation conversation, ConversationCanceller canceller) {
+        super(conversation);
+        this.context = conversation.getContext();
+        this.canceller = canceller;
+    }
+
+    /**
+     * Gets the object that caused the conversation to be abandoned.
+     *
+     * @return The object that abandoned the conversation.
+     */
+    public ConversationCanceller getCanceller() {
+        return canceller;
+    }
+
+    /**
+     * Gets the abandoned conversation's conversation context.
+     *
+     * @return The abandoned conversation's conversation context.
+     */
+    public ConversationContext getContext() {
+        return context;
+    }
+
+    /**
+     * Indicates how the conversation was abandoned - naturally as part of the
+     * prompt chain or prematurely via a {@link ConversationCanceller}.
+     *
+     * @return True if the conversation is abandoned gracefully by a {@link
+     * Prompt} returning null or the next prompt. False of the
+     * conversations is abandoned prematurely by a ConversationCanceller.
+     */
+    public boolean gracefulExit() {
+        return canceller == null;
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationAbandonedListener.java b/src/main/java/io/nukkit/conversations/ConversationAbandonedListener.java
new file mode 100755
index 0000000000..261819ce0a
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationAbandonedListener.java
@@ -0,0 +1,15 @@
+package io.nukkit.conversations;
+
+import java.util.EventListener;
+
+/**
+ */
+public interface ConversationAbandonedListener extends EventListener {
+    /**
+     * Called whenever a {@link Conversation} is abandoned.
+     *
+     * @param abandonedEvent Contains details about the abandoned
+     *                       conversation.
+     */
+    public void conversationAbandoned(ConversationAbandonedEvent abandonedEvent);
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationCanceller.java b/src/main/java/io/nukkit/conversations/ConversationCanceller.java
new file mode 100755
index 0000000000..d2516b9023
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationCanceller.java
@@ -0,0 +1,34 @@
+package io.nukkit.conversations;
+
+/**
+ * A ConversationCanceller is a class that cancels an active {@link
+ * Conversation}. A Conversation can have more than one ConversationCanceller.
+ */
+public interface ConversationCanceller extends Cloneable {
+
+    /**
+     * Sets the conversation this ConversationCanceller can optionally cancel.
+     *
+     * @param conversation A conversation.
+     */
+    public void setConversation(Conversation conversation);
+
+    /**
+     * Cancels a conversation based on user input.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The input text from the user.
+     * @return True to cancel the conversation, False otherwise.
+     */
+    public boolean cancelBasedOnInput(ConversationContext context, String input);
+
+    /**
+     * Allows the {@link ConversationFactory} to duplicate this
+     * ConversationCanceller when creating a new {@link Conversation}.
+     * <p>
+     * Implementing this method should reset any internal object state.
+     *
+     * @return A clone.
+     */
+    public ConversationCanceller clone();
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationContext.java b/src/main/java/io/nukkit/conversations/ConversationContext.java
new file mode 100755
index 0000000000..f68ce1f79d
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationContext.java
@@ -0,0 +1,71 @@
+package io.nukkit.conversations;
+
+import io.nukkit.plugin.Plugin;
+
+import java.util.Map;
+
+/**
+ * A ConversationContext provides continuity between nodes in the prompt graph
+ * by giving the developer access to the subject of the conversation and a
+ * generic map for storing values that are shared between all {@link Prompt}
+ * invocations.
+ */
+public class ConversationContext {
+    private Conversable forWhom;
+    private Map<Object, Object> sessionData;
+    private Plugin plugin;
+
+    /**
+     * @param plugin             The owning plugin.
+     * @param forWhom            The subject of the conversation.
+     * @param initialSessionData Any initial values to put in the sessionData
+     *                           map.
+     */
+    public ConversationContext(Plugin plugin, Conversable forWhom, Map<Object, Object> initialSessionData) {
+        this.plugin = plugin;
+        this.forWhom = forWhom;
+        this.sessionData = initialSessionData;
+    }
+
+    /**
+     * Gets the plugin that owns this conversation.
+     *
+     * @return The owning plugin.
+     */
+    public Plugin getPlugin() {
+        return plugin;
+    }
+
+    /**
+     * Gets the subject of the conversation.
+     *
+     * @return The subject of the conversation.
+     */
+    public Conversable getForWhom() {
+        return forWhom;
+    }
+
+    /**
+     * Gets session data shared between all {@link Prompt} invocations. Use
+     * this as a way to pass data through each Prompt as the conversation
+     * develops.
+     *
+     * @param key The session data key.
+     * @return The requested session data.
+     */
+    public Object getSessionData(Object key) {
+        return sessionData.get(key);
+    }
+
+    /**
+     * Sets session data shared between all {@link Prompt} invocations. Use
+     * this as a way to pass data through each prompt as the conversation
+     * develops.
+     *
+     * @param key   The session data key.
+     * @param value The session data value.
+     */
+    public void setSessionData(Object key, Object value) {
+        sessionData.put(key, value);
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationFactory.java b/src/main/java/io/nukkit/conversations/ConversationFactory.java
new file mode 100755
index 0000000000..722ee7f1e7
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationFactory.java
@@ -0,0 +1,226 @@
+package io.nukkit.conversations;
+
+import io.nukkit.entity.Player;
+import io.nukkit.plugin.Plugin;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A ConversationFactory is responsible for creating a {@link Conversation}
+ * from a predefined template. A ConversationFactory is typically created when
+ * a plugin is instantiated and builds a Conversation each time a user
+ * initiates a conversation with the plugin. Each Conversation maintains its
+ * own state and calls back as needed into the plugin.
+ * <p>
+ * The ConversationFactory implements a fluid API, allowing parameters to be
+ * set as an extension to the constructor.
+ */
+public class ConversationFactory {
+
+    protected Plugin plugin;
+    protected boolean isModal;
+    protected boolean localEchoEnabled;
+    protected ConversationPrefix prefix;
+    protected Prompt firstPrompt;
+    protected Map<Object, Object> initialSessionData;
+    protected String playerOnlyMessage;
+    protected List<ConversationCanceller> cancellers;
+    protected List<ConversationAbandonedListener> abandonedListeners;
+
+    /**
+     * Constructs a ConversationFactory.
+     *
+     * @param plugin The plugin that owns the factory.
+     */
+    public ConversationFactory(Plugin plugin) {
+        this.plugin = plugin;
+        isModal = true;
+        localEchoEnabled = true;
+        prefix = new NullConversationPrefix();
+        firstPrompt = Prompt.END_OF_CONVERSATION;
+        initialSessionData = new HashMap<>();
+        playerOnlyMessage = null;
+        cancellers = new ArrayList<>();
+        abandonedListeners = new ArrayList<>();
+    }
+
+    /**
+     * Sets the modality of all {@link Conversation}s created by this factory.
+     * If a conversation is modal, all messages directed to the player are
+     * suppressed for the duration of the conversation.
+     * <p>
+     * The default is True.
+     *
+     * @param modal The modality of all conversations to be created.
+     * @return This object.
+     */
+    public ConversationFactory withModality(boolean modal) {
+        isModal = modal;
+        return this;
+    }
+
+    /**
+     * Sets the local echo status for all {@link Conversation}s created by
+     * this factory. If local echo is enabled, any text submitted to a
+     * conversation gets echoed back into the submitter's chat window.
+     *
+     * @param localEchoEnabled The status of local echo.
+     * @return This object.
+     */
+    public ConversationFactory withLocalEcho(boolean localEchoEnabled) {
+        this.localEchoEnabled = localEchoEnabled;
+        return this;
+    }
+
+    /**
+     * Sets the {@link ConversationPrefix} that prepends all output from all
+     * generated conversations.
+     * <p>
+     * The default is a {@link NullConversationPrefix};
+     *
+     * @param prefix The ConversationPrefix to use.
+     * @return This object.
+     */
+    public ConversationFactory withPrefix(ConversationPrefix prefix) {
+        this.prefix = prefix;
+        return this;
+    }
+
+    /**
+     * Sets the number of inactive seconds to wait before automatically
+     * abandoning all generated conversations.
+     * <p>
+     * The default is 600 seconds (5 minutes).
+     *
+     * @param timeoutSeconds The number of seconds to wait.
+     * @return This object.
+     */
+    public ConversationFactory withTimeout(int timeoutSeconds) {
+        return withConversationCanceller(new InactivityConversationCanceller(plugin, timeoutSeconds));
+    }
+
+    /**
+     * Sets the first prompt to use in all generated conversations.
+     * <p>
+     * The default is Prompt.END_OF_CONVERSATION.
+     *
+     * @param firstPrompt The first prompt.
+     * @return This object.
+     */
+    public ConversationFactory withFirstPrompt(Prompt firstPrompt) {
+        this.firstPrompt = firstPrompt;
+        return this;
+    }
+
+    /**
+     * Sets any initial data with which to populate the conversation context
+     * sessionData map.
+     *
+     * @param initialSessionData The conversation context's initial
+     *                           sessionData.
+     * @return This object.
+     */
+    public ConversationFactory withInitialSessionData(Map<Object, Object> initialSessionData) {
+        this.initialSessionData = initialSessionData;
+        return this;
+    }
+
+    /**
+     * Sets the player input that, when received, will immediately terminate
+     * the conversation.
+     *
+     * @param escapeSequence Input to terminate the conversation.
+     * @return This object.
+     */
+    public ConversationFactory withEscapeSequence(String escapeSequence) {
+        return withConversationCanceller(new ExactMatchConversationCanceller(escapeSequence));
+    }
+
+
+    /**
+     * Adds a {@link ConversationCanceller} to constructed conversations.
+     *
+     * @param canceller The {@link ConversationCanceller} to add.
+     * @return This object.
+     */
+    public ConversationFactory withConversationCanceller(ConversationCanceller canceller) {
+        cancellers.add(canceller);
+        return this;
+    }
+
+    /**
+     * Prevents this factory from creating a conversation for non-player
+     * {@link Conversable} objects.
+     *
+     * @param playerOnlyMessage The message to return to a non-play in lieu of
+     *                          starting a conversation.
+     * @return This object.
+     */
+    public ConversationFactory thatExcludesNonPlayersWithMessage(String playerOnlyMessage) {
+        this.playerOnlyMessage = playerOnlyMessage;
+        return this;
+    }
+
+    /**
+     * Adds a {@link ConversationAbandonedListener} to all conversations
+     * constructed by this factory.
+     *
+     * @param listener The listener to add.
+     * @return This object.
+     */
+    public ConversationFactory addConversationAbandonedListener(ConversationAbandonedListener listener) {
+        abandonedListeners.add(listener);
+        return this;
+    }
+
+    /**
+     * Constructs a {@link Conversation} in accordance with the defaults set
+     * for this factory.
+     *
+     * @param forWhom The entity for whom the new conversation is mediating.
+     * @return A new conversation.
+     */
+    public Conversation buildConversation(Conversable forWhom) {
+        //Abort conversation construction if we aren't supposed to talk to non-players
+        if (playerOnlyMessage != null && !(forWhom instanceof Player)) {
+            return new Conversation(plugin, forWhom, new NotPlayerMessagePrompt());
+        }
+
+        //Clone any initial session data
+        Map<Object, Object> copiedInitialSessionData = new HashMap<>();
+        copiedInitialSessionData.putAll(initialSessionData);
+
+        //Build and return a conversation
+        Conversation conversation = new Conversation(plugin, forWhom, firstPrompt, copiedInitialSessionData);
+        conversation.setModal(isModal);
+        conversation.setLocalEchoEnabled(localEchoEnabled);
+        conversation.setPrefix(prefix);
+
+        //Clone the conversation cancellers
+        for (ConversationCanceller canceller : cancellers) {
+            conversation.addConversationCanceller(canceller.clone());
+        }
+
+        //Add the ConversationAbandonedListeners
+        for (ConversationAbandonedListener listener : abandonedListeners) {
+            conversation.addConversationAbandonedListener(listener);
+        }
+
+        return conversation;
+    }
+
+    private class NotPlayerMessagePrompt extends MessagePrompt {
+
+        public String getPromptText(ConversationContext context) {
+            return playerOnlyMessage;
+        }
+
+        @Override
+        protected Prompt getNextPrompt(ConversationContext context) {
+            return Prompt.END_OF_CONVERSATION;
+        }
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ConversationPrefix.java b/src/main/java/io/nukkit/conversations/ConversationPrefix.java
new file mode 100755
index 0000000000..c793659510
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ConversationPrefix.java
@@ -0,0 +1,17 @@
+package io.nukkit.conversations;
+
+/**
+ * A ConversationPrefix implementation prepends all output from the
+ * conversation to the player. The ConversationPrefix can be used to display
+ * the plugin name or conversation status as the conversation evolves.
+ */
+public interface ConversationPrefix {
+
+    /**
+     * Gets the prefix to use before each message to the player.
+     *
+     * @param context Context information about the conversation.
+     * @return The prefix text.
+     */
+    String getPrefix(ConversationContext context);
+}
diff --git a/src/main/java/io/nukkit/conversations/ExactMatchConversationCanceller.java b/src/main/java/io/nukkit/conversations/ExactMatchConversationCanceller.java
new file mode 100755
index 0000000000..5f4e5b0bc8
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ExactMatchConversationCanceller.java
@@ -0,0 +1,30 @@
+package io.nukkit.conversations;
+
+/**
+ * An ExactMatchConversationCanceller cancels a conversation if the user
+ * enters an exact input string
+ */
+public class ExactMatchConversationCanceller implements ConversationCanceller {
+    private String escapeSequence;
+
+    /**
+     * Builds an ExactMatchConversationCanceller.
+     *
+     * @param escapeSequence The string that, if entered by the user, will
+     *                       cancel the conversation.
+     */
+    public ExactMatchConversationCanceller(String escapeSequence) {
+        this.escapeSequence = escapeSequence;
+    }
+
+    public void setConversation(Conversation conversation) {
+    }
+
+    public boolean cancelBasedOnInput(ConversationContext context, String input) {
+        return input.equals(escapeSequence);
+    }
+
+    public ConversationCanceller clone() {
+        return new ExactMatchConversationCanceller(escapeSequence);
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/FixedSetPrompt.java b/src/main/java/io/nukkit/conversations/FixedSetPrompt.java
new file mode 100755
index 0000000000..4f6220cd6d
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/FixedSetPrompt.java
@@ -0,0 +1,47 @@
+package io.nukkit.conversations;
+
+import org.apache.commons.lang3.StringUtils;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * FixedSetPrompt is the base class for any prompt that requires a fixed set
+ * response from the user.
+ */
+public abstract class FixedSetPrompt extends ValidatingPrompt {
+
+    protected List<String> fixedSet;
+
+    /**
+     * Creates a FixedSetPrompt from a set of strings.
+     * <p>
+     * foo = new FixedSetPrompt("bar", "cheese", "panda");
+     *
+     * @param fixedSet A fixed set of strings, one of which the user must
+     *                 type.
+     */
+    public FixedSetPrompt(String... fixedSet) {
+        super();
+        this.fixedSet = Arrays.asList(fixedSet);
+    }
+
+    private FixedSetPrompt() {
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return fixedSet.contains(input);
+    }
+
+    /**
+     * Utility function to create a formatted string containing all the
+     * options declared in the constructor.
+     *
+     * @return the options formatted like "[bar, cheese, panda]" if bar,
+     * cheese, and panda were the options used
+     */
+    protected String formatFixedSet() {
+        return "[" + StringUtils.join(fixedSet, ", ") + "]";
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/InactivityConversationCanceller.java b/src/main/java/io/nukkit/conversations/InactivityConversationCanceller.java
new file mode 100755
index 0000000000..5e90a5925c
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/InactivityConversationCanceller.java
@@ -0,0 +1,78 @@
+package io.nukkit.conversations;
+
+import io.nukkit.plugin.Plugin;
+
+/**
+ * An InactivityConversationCanceller will cancel a {@link Conversation} after
+ * a period of inactivity by the user.
+ */
+public class InactivityConversationCanceller implements ConversationCanceller {
+    protected Plugin plugin;
+    protected int timeoutSeconds;
+    protected Conversation conversation;
+    private int taskId = -1;
+
+    /**
+     * Creates an InactivityConversationCanceller.
+     *
+     * @param plugin         The owning plugin.
+     * @param timeoutSeconds The number of seconds of inactivity to wait.
+     */
+    public InactivityConversationCanceller(Plugin plugin, int timeoutSeconds) {
+        this.plugin = plugin;
+        this.timeoutSeconds = timeoutSeconds;
+    }
+
+    public void setConversation(Conversation conversation) {
+        this.conversation = conversation;
+        startTimer();
+    }
+
+    public boolean cancelBasedOnInput(ConversationContext context, String input) {
+        // Reset the inactivity timer
+        stopTimer();
+        startTimer();
+        return false;
+    }
+
+    public ConversationCanceller clone() {
+        return new InactivityConversationCanceller(plugin, timeoutSeconds);
+    }
+
+    /**
+     * Starts an inactivity timer.
+     */
+    private void startTimer() {
+        taskId = plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin, new Runnable() {
+            public void run() {
+                if (conversation.getState() == Conversation.ConversationState.UNSTARTED) {
+                    startTimer();
+                } else if (conversation.getState() == Conversation.ConversationState.STARTED) {
+                    cancelling(conversation);
+                    conversation.abandon(new ConversationAbandonedEvent(conversation, InactivityConversationCanceller.this));
+                }
+            }
+        }, timeoutSeconds * 20);
+    }
+
+    /**
+     * Stops the active inactivity timer.
+     */
+    private void stopTimer() {
+        if (taskId != -1) {
+            plugin.getServer().getScheduler().cancelTask(taskId);
+            taskId = -1;
+        }
+    }
+
+    /**
+     * Subclasses of InactivityConversationCanceller can override this method
+     * to take additional actions when the inactivity timer abandons the
+     * conversation.
+     *
+     * @param conversation The conversation being abandoned.
+     */
+    protected void cancelling(Conversation conversation) {
+
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ManuallyAbandonedConversationCanceller.java b/src/main/java/io/nukkit/conversations/ManuallyAbandonedConversationCanceller.java
new file mode 100755
index 0000000000..5aedf1cf71
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ManuallyAbandonedConversationCanceller.java
@@ -0,0 +1,20 @@
+package io.nukkit.conversations;
+
+/**
+ * The ManuallyAbandonedConversationCanceller is only used as part of a {@link
+ * ConversationAbandonedEvent} to indicate that the conversation was manually
+ * abandoned by programmatically calling the abandon() method on it.
+ */
+public class ManuallyAbandonedConversationCanceller implements ConversationCanceller {
+    public void setConversation(Conversation conversation) {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean cancelBasedOnInput(ConversationContext context, String input) {
+        throw new UnsupportedOperationException();
+    }
+
+    public ConversationCanceller clone() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/MessagePrompt.java b/src/main/java/io/nukkit/conversations/MessagePrompt.java
new file mode 100755
index 0000000000..7e7c61cd22
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/MessagePrompt.java
@@ -0,0 +1,42 @@
+package io.nukkit.conversations;
+
+/**
+ * MessagePrompt is the base class for any prompt that only displays a message
+ * to the user and requires no input.
+ */
+public abstract class MessagePrompt implements Prompt {
+
+    public MessagePrompt() {
+        super();
+    }
+
+    /**
+     * Message prompts never wait for user input before continuing.
+     *
+     * @param context Context information about the conversation.
+     * @return Always false.
+     */
+    public boolean blocksForInput(ConversationContext context) {
+        return false;
+    }
+
+    /**
+     * Accepts and ignores any user input, returning the next prompt in the
+     * prompt graph instead.
+     *
+     * @param context Context information about the conversation.
+     * @param input   Ignored.
+     * @return The next prompt in the prompt graph.
+     */
+    public Prompt acceptInput(ConversationContext context, String input) {
+        return getNextPrompt(context);
+    }
+
+    /**
+     * Override this method to return the next prompt in the prompt graph.
+     *
+     * @param context Context information about the conversation.
+     * @return The next prompt in the prompt graph.
+     */
+    protected abstract Prompt getNextPrompt(ConversationContext context);
+}
diff --git a/src/main/java/io/nukkit/conversations/NullConversationPrefix.java b/src/main/java/io/nukkit/conversations/NullConversationPrefix.java
new file mode 100755
index 0000000000..bb797a53d6
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/NullConversationPrefix.java
@@ -0,0 +1,18 @@
+package io.nukkit.conversations;
+
+/**
+ * NullConversationPrefix is a {@link ConversationPrefix} implementation that
+ * displays nothing in front of conversation output.
+ */
+public class NullConversationPrefix implements ConversationPrefix {
+
+    /**
+     * Prepends each conversation message with an empty string.
+     *
+     * @param context Context information about the conversation.
+     * @return An empty string.
+     */
+    public String getPrefix(ConversationContext context) {
+        return "";
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/NumericPrompt.java b/src/main/java/io/nukkit/conversations/NumericPrompt.java
new file mode 100755
index 0000000000..68ee5b15c8
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/NumericPrompt.java
@@ -0,0 +1,82 @@
+package io.nukkit.conversations;
+
+import org.apache.commons.lang3.math.NumberUtils;
+
+/**
+ * NumericPrompt is the base class for any prompt that requires a {@link
+ * Number} response from the user.
+ */
+public abstract class NumericPrompt extends ValidatingPrompt {
+    public NumericPrompt() {
+        super();
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return NumberUtils.isNumber(input) && isNumberValid(context, NumberUtils.createNumber(input));
+    }
+
+    /**
+     * Override this method to do further validation on the numeric player
+     * input after the input has been determined to actually be a number.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The number the player provided.
+     * @return The validity of the player's input.
+     */
+    protected boolean isNumberValid(ConversationContext context, Number input) {
+        return true;
+    }
+
+    @Override
+    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        try {
+            return acceptValidatedInput(context, NumberUtils.createNumber(input));
+        } catch (NumberFormatException e) {
+            return acceptValidatedInput(context, NumberUtils.INTEGER_ZERO);
+        }
+    }
+
+    /**
+     * Override this method to perform some action with the user's integer
+     * response.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The user's response as a {@link Number}.
+     * @return The next {@link Prompt} in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, Number input);
+
+    @Override
+    protected String getFailedValidationText(ConversationContext context, String invalidInput) {
+        if (NumberUtils.isNumber(invalidInput)) {
+            return getFailedValidationText(context, NumberUtils.createNumber(invalidInput));
+        } else {
+            return getInputNotNumericText(context, invalidInput);
+        }
+    }
+
+    /**
+     * Optionally override this method to display an additional message if the
+     * user enters an invalid number.
+     *
+     * @param context      Context information about the conversation.
+     * @param invalidInput The invalid input provided by the user.
+     * @return A message explaining how to correct the input.
+     */
+    protected String getInputNotNumericText(ConversationContext context, String invalidInput) {
+        return null;
+    }
+
+    /**
+     * Optionally override this method to display an additional message if the
+     * user enters an invalid numeric input.
+     *
+     * @param context      Context information about the conversation.
+     * @param invalidInput The invalid input provided by the user.
+     * @return A message explaining how to correct the input.
+     */
+    protected String getFailedValidationText(ConversationContext context, Number invalidInput) {
+        return null;
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/PlayerNamePrompt.java b/src/main/java/io/nukkit/conversations/PlayerNamePrompt.java
new file mode 100755
index 0000000000..634cffce8e
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/PlayerNamePrompt.java
@@ -0,0 +1,38 @@
+package io.nukkit.conversations;
+
+import io.nukkit.entity.Player;
+import io.nukkit.plugin.Plugin;
+
+/**
+ * PlayerNamePrompt is the base class for any prompt that requires the player
+ * to enter another player's name.
+ */
+public abstract class PlayerNamePrompt extends ValidatingPrompt {
+    private Plugin plugin;
+
+    public PlayerNamePrompt(Plugin plugin) {
+        super();
+        this.plugin = plugin;
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return plugin.getServer().getPlayer(input) != null;
+
+    }
+
+    @Override
+    protected Prompt acceptValidatedInput(ConversationContext context, String input) {
+        return acceptValidatedInput(context, plugin.getServer().getPlayer(input));
+    }
+
+    /**
+     * Override this method to perform some action with the user's player name
+     * response.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The user's player name response.
+     * @return The next {@link Prompt} in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, Player input);
+}
diff --git a/src/main/java/io/nukkit/conversations/PluginNameConversationPrefix.java b/src/main/java/io/nukkit/conversations/PluginNameConversationPrefix.java
new file mode 100755
index 0000000000..3bab6d22f5
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/PluginNameConversationPrefix.java
@@ -0,0 +1,39 @@
+package io.nukkit.conversations;
+
+import io.nukkit.plugin.Plugin;
+import io.nukkit.util.ChatColor;
+
+/**
+ * PluginNameConversationPrefix is a {@link ConversationPrefix} implementation
+ * that displays the plugin name in front of conversation output.
+ */
+public class PluginNameConversationPrefix implements ConversationPrefix {
+
+    protected String separator;
+    protected ChatColor prefixColor;
+    protected Plugin plugin;
+
+    private String cachedPrefix;
+
+    public PluginNameConversationPrefix(Plugin plugin) {
+        this(plugin, " > ", ChatColor.LIGHT_PURPLE);
+    }
+
+    public PluginNameConversationPrefix(Plugin plugin, String separator, ChatColor prefixColor) {
+        this.separator = separator;
+        this.prefixColor = prefixColor;
+        this.plugin = plugin;
+
+        cachedPrefix = prefixColor + plugin.getDescription().getName() + separator + ChatColor.WHITE;
+    }
+
+    /**
+     * Prepends each conversation message with the plugin name.
+     *
+     * @param context Context information about the conversation.
+     * @return An empty string.
+     */
+    public String getPrefix(ConversationContext context) {
+        return cachedPrefix;
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/Prompt.java b/src/main/java/io/nukkit/conversations/Prompt.java
new file mode 100755
index 0000000000..af28295ac8
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/Prompt.java
@@ -0,0 +1,45 @@
+package io.nukkit.conversations;
+
+/**
+ * A Prompt is the main constituent of a {@link Conversation}. Each prompt
+ * displays text to the user and optionally waits for a user's response.
+ * Prompts are chained together into a directed graph that represents the
+ * conversation flow. To halt a conversation, END_OF_CONVERSATION is returned
+ * in liu of another Prompt object.
+ */
+public interface Prompt extends Cloneable {
+
+    /**
+     * A convenience constant for indicating the end of a conversation.
+     */
+    static final Prompt END_OF_CONVERSATION = null;
+
+    /**
+     * Gets the text to display to the user when this prompt is first
+     * presented.
+     *
+     * @param context Context information about the conversation.
+     * @return The text to display.
+     */
+    String getPromptText(ConversationContext context);
+
+    /**
+     * Checks to see if this prompt implementation should wait for user input
+     * or immediately display the next prompt.
+     *
+     * @param context Context information about the conversation.
+     * @return If true, the {@link Conversation} will wait for input before
+     * continuing.
+     */
+    boolean blocksForInput(ConversationContext context);
+
+    /**
+     * Accepts and processes input from the user. Using the input, the next
+     * Prompt in the prompt graph is returned.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The input text from the user.
+     * @return The next Prompt in the prompt graph.
+     */
+    Prompt acceptInput(ConversationContext context, String input);
+}
diff --git a/src/main/java/io/nukkit/conversations/RegexPrompt.java b/src/main/java/io/nukkit/conversations/RegexPrompt.java
new file mode 100755
index 0000000000..72cf48b819
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/RegexPrompt.java
@@ -0,0 +1,29 @@
+package io.nukkit.conversations;
+
+import java.util.regex.Pattern;
+
+/**
+ * RegexPrompt is the base class for any prompt that requires an input
+ * validated by a regular expression.
+ */
+public abstract class RegexPrompt extends ValidatingPrompt {
+
+    private Pattern pattern;
+
+    public RegexPrompt(String regex) {
+        this(Pattern.compile(regex));
+    }
+
+    public RegexPrompt(Pattern pattern) {
+        super();
+        this.pattern = pattern;
+    }
+
+    private RegexPrompt() {
+    }
+
+    @Override
+    protected boolean isInputValid(ConversationContext context, String input) {
+        return pattern.matcher(input).matches();
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/StringPrompt.java b/src/main/java/io/nukkit/conversations/StringPrompt.java
new file mode 100755
index 0000000000..dfef06790a
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/StringPrompt.java
@@ -0,0 +1,18 @@
+package io.nukkit.conversations;
+
+/**
+ * StringPrompt is the base class for any prompt that accepts an arbitrary
+ * string from the user.
+ */
+public abstract class StringPrompt implements Prompt {
+
+    /**
+     * Ensures that the prompt waits for the user to provide input.
+     *
+     * @param context Context information about the conversation.
+     * @return True.
+     */
+    public boolean blocksForInput(ConversationContext context) {
+        return true;
+    }
+}
diff --git a/src/main/java/io/nukkit/conversations/ValidatingPrompt.java b/src/main/java/io/nukkit/conversations/ValidatingPrompt.java
new file mode 100755
index 0000000000..164212ff05
--- /dev/null
+++ b/src/main/java/io/nukkit/conversations/ValidatingPrompt.java
@@ -0,0 +1,78 @@
+package io.nukkit.conversations;
+
+import io.nukkit.util.ChatColor;
+
+/**
+ * ValidatingPrompt is the base class for any prompt that requires validation.
+ * ValidatingPrompt will keep replaying the prompt text until the user enters
+ * a valid response.
+ */
+public abstract class ValidatingPrompt implements Prompt {
+    public ValidatingPrompt() {
+        super();
+    }
+
+    /**
+     * Accepts and processes input from the user and validates it. If
+     * validation fails, this prompt is returned for re-execution, otherwise
+     * the next Prompt in the prompt graph is returned.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The input text from the user.
+     * @return This prompt or the next Prompt in the prompt graph.
+     */
+    public Prompt acceptInput(ConversationContext context, String input) {
+        if (isInputValid(context, input)) {
+            return acceptValidatedInput(context, input);
+        } else {
+            String failPrompt = getFailedValidationText(context, input);
+            if (failPrompt != null) {
+                context.getForWhom().sendRawMessage(ChatColor.RED + failPrompt);
+            }
+            // Redisplay this prompt to the user to re-collect input
+            return this;
+        }
+    }
+
+    /**
+     * Ensures that the prompt waits for the user to provide input.
+     *
+     * @param context Context information about the conversation.
+     * @return True.
+     */
+    public boolean blocksForInput(ConversationContext context) {
+        return true;
+    }
+
+    /**
+     * Override this method to check the validity of the player's input.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The player's raw console input.
+     * @return True or false depending on the validity of the input.
+     */
+    protected abstract boolean isInputValid(ConversationContext context, String input);
+
+    /**
+     * Override this method to accept and processes the validated input from
+     * the user. Using the input, the next Prompt in the prompt graph should
+     * be returned.
+     *
+     * @param context Context information about the conversation.
+     * @param input   The validated input text from the user.
+     * @return The next Prompt in the prompt graph.
+     */
+    protected abstract Prompt acceptValidatedInput(ConversationContext context, String input);
+
+    /**
+     * Optionally override this method to display an additional message if the
+     * user enters an invalid input.
+     *
+     * @param context      Context information about the conversation.
+     * @param invalidInput The invalid input provided by the user.
+     * @return A message explaining how to correct the input.
+     */
+    protected String getFailedValidationText(ConversationContext context, String invalidInput) {
+        return null;
+    }
+}
diff --git a/src/main/java/io/nukkit/entity/Player.java b/src/main/java/io/nukkit/entity/Player.java
new file mode 100755
index 0000000000..23d99bc243
--- /dev/null
+++ b/src/main/java/io/nukkit/entity/Player.java
@@ -0,0 +1,19 @@
+package io.nukkit.entity;
+
+/**
+ * Nukkit Project
+ * Author: MagicDroidX
+ */
+public class Player {
+    //TODO
+
+    public boolean canSee(Player player) {
+        return true;
+        //TODO
+    }
+
+    public String getName() {
+        return "Player";
+        //TODO
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/PluginDisableEvent.java b/src/main/java/io/nukkit/event/server/PluginDisableEvent.java
new file mode 100755
index 0000000000..2ed68fbe21
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/PluginDisableEvent.java
@@ -0,0 +1,24 @@
+package io.nukkit.event.server;
+
+import io.nukkit.event.HandlerList;
+import io.nukkit.plugin.Plugin;
+
+/**
+ * Called when a plugin is disabled.
+ */
+public class PluginDisableEvent extends PluginEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public PluginDisableEvent(final Plugin plugin) {
+        super(plugin);
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/PluginEnableEvent.java b/src/main/java/io/nukkit/event/server/PluginEnableEvent.java
new file mode 100755
index 0000000000..b7ed9f1608
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/PluginEnableEvent.java
@@ -0,0 +1,24 @@
+package io.nukkit.event.server;
+
+import io.nukkit.event.HandlerList;
+import io.nukkit.plugin.Plugin;
+
+/**
+ * Called when a plugin is enabled.
+ */
+public class PluginEnableEvent extends PluginEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public PluginEnableEvent(final Plugin plugin) {
+        super(plugin);
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/PluginEvent.java b/src/main/java/io/nukkit/event/server/PluginEvent.java
new file mode 100755
index 0000000000..242c47a512
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/PluginEvent.java
@@ -0,0 +1,23 @@
+package io.nukkit.event.server;
+
+import io.nukkit.plugin.Plugin;
+
+/**
+ * Used for plugin enable and disable events
+ */
+public abstract class PluginEvent extends ServerEvent {
+    private final Plugin plugin;
+
+    public PluginEvent(final Plugin plugin) {
+        this.plugin = plugin;
+    }
+
+    /**
+     * Gets the plugin involved in this event
+     *
+     * @return Plugin for this event
+     */
+    public Plugin getPlugin() {
+        return plugin;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/RemoteServerCommandEvent.java b/src/main/java/io/nukkit/event/server/RemoteServerCommandEvent.java
new file mode 100755
index 0000000000..1249f15fda
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/RemoteServerCommandEvent.java
@@ -0,0 +1,25 @@
+package io.nukkit.event.server;
+
+import io.nukkit.command.CommandSender;
+import io.nukkit.event.HandlerList;
+
+/**
+ * This event is called when a command is recieved over RCON. See the javadocs
+ * of {@link ServerCommandEvent} for more information.
+ */
+public class RemoteServerCommandEvent extends ServerCommandEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public RemoteServerCommandEvent(final CommandSender sender, final String command) {
+        super(sender, command);
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/ServerCommandEvent.java b/src/main/java/io/nukkit/event/server/ServerCommandEvent.java
new file mode 100755
index 0000000000..419f7f821e
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/ServerCommandEvent.java
@@ -0,0 +1,86 @@
+package io.nukkit.event.server;
+
+import io.nukkit.command.CommandSender;
+import io.nukkit.event.HandlerList;
+
+/**
+ * This event is called when a command is run from the server console. It is
+ * called early in the command handling process, and modifications in this
+ * event (via {@link #setCommand(String)}) will be shown in the behavior.
+ * <p>
+ * Many plugins will have <b>no use for this event</b>, and you should
+ * attempt to avoid using it if it is not necessary.
+ * <p>
+ * Some examples of valid uses for this event are:
+ * <ul>
+ * <li>Logging executed commands to a separate file
+ * <li>Variable substitution. For example, replacing <code>${ip:Steve}</code>
+ * with the connection IP of the player named Steve, or simulating the
+ * <code>@a</code> and <code>@p</code> decorators used by Command Blocks
+ * for plugins that do not handle it.
+ * <li>Conditionally blocking commands belonging to other plugins.
+ * <li>Per-sender command aliases. For example, after the console runs the
+ * command <code>/calias cr gamemode creative</code>, the next time they
+ * run <code>/cr</code>, it gets replaced into
+ * <code>/gamemode creative</code>. (Global command aliases should be
+ * done by registering the alias.)
+ * </ul>
+ * <p>
+ * Examples of incorrect uses are:
+ * <ul>
+ * <li>Using this event to run command logic
+ * </ul>
+ * <p>
+ * If the event is cancelled, processing of the command will halt.
+ * <p>
+ * The state of whether or not there is a slash (<code>/</code>) at the
+ * beginning of the message should be preserved. If a slash is added or
+ * removed, unexpected behavior may result.
+ */
+public class ServerCommandEvent extends ServerEvent {
+    private static final HandlerList handlers = new HandlerList();
+    private String command;
+    private final CommandSender sender;
+
+    public ServerCommandEvent(final CommandSender sender, final String command) {
+        this.command = command;
+        this.sender = sender;
+    }
+
+    /**
+     * Gets the command that the user is attempting to execute from the
+     * console
+     *
+     * @return Command the user is attempting to execute
+     */
+    public String getCommand() {
+        return command;
+    }
+
+    /**
+     * Sets the command that the server will execute
+     *
+     * @param message New message that the server will execute
+     */
+    public void setCommand(String message) {
+        this.command = message;
+    }
+
+    /**
+     * Get the command sender.
+     *
+     * @return The sender
+     */
+    public CommandSender getSender() {
+        return sender;
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/ServerEvent.java b/src/main/java/io/nukkit/event/server/ServerEvent.java
new file mode 100755
index 0000000000..4eb8e15ea8
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/ServerEvent.java
@@ -0,0 +1,9 @@
+package io.nukkit.event.server;
+
+import io.nukkit.event.Event;
+
+/**
+ * Miscellaneous server events
+ */
+public abstract class ServerEvent extends Event {
+}
diff --git a/src/main/java/io/nukkit/event/server/ServiceEvent.java b/src/main/java/io/nukkit/event/server/ServiceEvent.java
new file mode 100755
index 0000000000..2fe1367c59
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/ServiceEvent.java
@@ -0,0 +1,19 @@
+package io.nukkit.event.server;
+
+import io.nukkit.plugin.RegisteredServiceProvider;
+
+/**
+ * An event relating to a registered service. This is called in a {@link
+ * org.bukkit.plugin.ServicesManager}
+ */
+public abstract class ServiceEvent extends ServerEvent {
+    private final RegisteredServiceProvider<?> provider;
+
+    public ServiceEvent(final RegisteredServiceProvider<?> provider) {
+        this.provider = provider;
+    }
+
+    public RegisteredServiceProvider<?> getProvider() {
+        return provider;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/nukkit/event/server/ServiceRegisterEvent.java b/src/main/java/io/nukkit/event/server/ServiceRegisterEvent.java
new file mode 100755
index 0000000000..9019e977c8
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/ServiceRegisterEvent.java
@@ -0,0 +1,27 @@
+package io.nukkit.event.server;
+
+import io.nukkit.event.HandlerList;
+import io.nukkit.plugin.RegisteredServiceProvider;
+
+/**
+ * This event is called when a service is registered.
+ * <p>
+ * Warning: The order in which register and unregister events are called
+ * should not be relied upon.
+ */
+public class ServiceRegisterEvent extends ServiceEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public ServiceRegisterEvent(RegisteredServiceProvider<?> registeredProvider) {
+        super(registeredProvider);
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/ServiceUnregisterEvent.java b/src/main/java/io/nukkit/event/server/ServiceUnregisterEvent.java
new file mode 100755
index 0000000000..b2728fd801
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/ServiceUnregisterEvent.java
@@ -0,0 +1,27 @@
+package io.nukkit.event.server;
+
+import io.nukkit.event.HandlerList;
+import io.nukkit.plugin.RegisteredServiceProvider;
+
+/**
+ * This event is called when a service is unregistered.
+ * <p>
+ * Warning: The order in which register and unregister events are called
+ * should not be relied upon.
+ */
+public class ServiceUnregisterEvent extends ServiceEvent {
+    private static final HandlerList handlers = new HandlerList();
+
+    public ServiceUnregisterEvent(RegisteredServiceProvider<?> serviceProvider) {
+        super(serviceProvider);
+    }
+
+    @Override
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/event/server/TabCompleteEvent.java b/src/main/java/io/nukkit/event/server/TabCompleteEvent.java
new file mode 100755
index 0000000000..f6a224de23
--- /dev/null
+++ b/src/main/java/io/nukkit/event/server/TabCompleteEvent.java
@@ -0,0 +1,59 @@
+package io.nukkit.event.server;
+
+import io.nukkit.command.CommandSender;
+import io.nukkit.event.Cancellable;
+import io.nukkit.event.Event;
+import io.nukkit.event.HandlerList;
+import org.apache.commons.lang3.Validate;
+
+import java.util.List;
+
+public class TabCompleteEvent extends Event implements Cancellable {
+    private static final HandlerList handlers = new HandlerList();
+    private final CommandSender sender;
+    private final String buffer;
+    private List completions;
+    private boolean cancelled;
+
+    public TabCompleteEvent(CommandSender sender, String buffer, List completions) {
+        Validate.notNull(sender, "sender");
+        Validate.notNull(buffer, "buffer");
+        Validate.notNull(completions, "completions");
+        this.sender = sender;
+        this.buffer = buffer;
+        this.completions = completions;
+    }
+
+    public CommandSender getSender() {
+        return this.sender;
+    }
+
+    public String getBuffer() {
+        return this.buffer;
+    }
+
+    public List getCompletions() {
+        return this.completions;
+    }
+
+    public void setCompletions(List completions) {
+        Validate.notNull(completions);
+        this.completions = completions;
+    }
+
+    public boolean isCancelled() {
+        return this.cancelled;
+    }
+
+    public void setCancelled(boolean cancelled) {
+        this.cancelled = cancelled;
+    }
+
+    public HandlerList getHandlers() {
+        return handlers;
+    }
+
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+}
diff --git a/src/main/java/io/nukkit/generator/ChunkGenerator.java b/src/main/java/io/nukkit/generator/ChunkGenerator.java
new file mode 100755
index 0000000000..97d4ef32be
--- /dev/null
+++ b/src/main/java/io/nukkit/generator/ChunkGenerator.java
@@ -0,0 +1,6 @@
+package io.nukkit.generator;
+
+
+public abstract class ChunkGenerator {
+    //todo
+}
diff --git a/src/main/java/io/nukkit/permissions/PermissibleBase.java b/src/main/java/io/nukkit/permissions/PermissibleBase.java
index 2561831eaf..365ae4781b 100755
--- a/src/main/java/io/nukkit/permissions/PermissibleBase.java
+++ b/src/main/java/io/nukkit/permissions/PermissibleBase.java
@@ -2,9 +2,9 @@
 
 import io.nukkit.Nukkit;
 import io.nukkit.plugin.Plugin;
+import org.apache.logging.log4j.Level;
 
 import java.util.*;
-import java.util.logging.Level;
 
 /**
  * Base Permissible for use in any Permissible object via proxy or extension
@@ -216,7 +216,7 @@ public PermissionAttachment addAttachment(Plugin plugin, int ticks) {
         PermissionAttachment result = addAttachment(plugin);
 
         if (Nukkit.getServer().getScheduler().scheduleSyncDelayedTask(plugin, new RemoveAttachmentRunnable(result), ticks) == -1) {
-            Nukkit.getServer().getLogger().log(Level.WARNING, "Could not add PermissionAttachment to " + parent + " for plugin " + plugin.getDescription().getFullName() + ": Scheduler returned -1");
+            Nukkit.getServer().getLogger().log(Level.WARN, "Could not add PermissionAttachment to " + parent + " for plugin " + plugin.getDescription().getFullName() + ": Scheduler returned -1");
             result.remove();
             return null;
         } else {
diff --git a/src/main/java/io/nukkit/permissions/Permission.java b/src/main/java/io/nukkit/permissions/Permission.java
index 3b0e526ad1..50acf62d90 100755
--- a/src/main/java/io/nukkit/permissions/Permission.java
+++ b/src/main/java/io/nukkit/permissions/Permission.java
@@ -3,9 +3,9 @@
 import io.nukkit.Nukkit;
 import io.nukkit.plugin.PluginManager;
 import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 
 import java.util.*;
-import java.util.logging.Level;
 
 /**
  * Represents a unique permission that may be attached to a {@link
@@ -145,7 +145,7 @@ public void setDescription(String value) {
      * @return Set containing permissibles with this permission
      */
     public Set<Permissible> getPermissibles() {
-        return Bukkit.getServer().getPluginManager().getPermissionSubscriptions(name);
+        return Nukkit.getServer().getPluginManager().getPermissionSubscriptions(name);
     }
 
     /**
@@ -175,7 +175,7 @@ public void recalculatePermissibles() {
      * @return Parent permission it created or loaded
      */
     public Permission addParent(String name, boolean value) {
-        PluginManager pm = Bukkit.getServer().getPluginManager();
+        PluginManager pm = Nukkit.getServer().getPluginManager();
         String lname = name.toLowerCase();
 
         Permission perm = pm.getPermission(lname);
@@ -227,7 +227,7 @@ public void addParent(Permission perm, boolean value) {
             try {
                 result.add(Permission.loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), def, result));
             } catch (Throwable ex) {
-                Bukkit.getServer().getLogger().log(Level.SEVERE, String.format(error, entry.getKey()), ex);
+                Nukkit.getServer().getLogger().log(Level.ERROR, String.format(error, entry.getKey()), ex);
             }
         }
 
diff --git a/src/main/java/io/nukkit/plugin/Plugin.java b/src/main/java/io/nukkit/plugin/Plugin.java
index 1aab3b17cd..3b74f5be4a 100755
--- a/src/main/java/io/nukkit/plugin/Plugin.java
+++ b/src/main/java/io/nukkit/plugin/Plugin.java
@@ -5,10 +5,10 @@
 import io.nukkit.command.TabExecutor;
 import io.nukkit.configuration.file.FileConfiguration;
 import io.nukkit.generator.ChunkGenerator;
+import org.apache.logging.log4j.Logger;
 
 import java.io.File;
 import java.io.InputStream;
-import java.util.logging.Logger;
 
 /**
  * Represents a Plugin
diff --git a/src/main/java/io/nukkit/plugin/PluginLogger.java b/src/main/java/io/nukkit/plugin/PluginLogger.java
index 5e6057e1bb..40ea39e1eb 100755
--- a/src/main/java/io/nukkit/plugin/PluginLogger.java
+++ b/src/main/java/io/nukkit/plugin/PluginLogger.java
@@ -1,8 +1,11 @@
 package io.nukkit.plugin;
 
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.core.Logger;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.message.Message;
+
 
 /**
  * The PluginLogger class is a modified {@link Logger} that prepends all
@@ -13,6 +16,7 @@
  */
 public class PluginLogger extends Logger {
     private String pluginName;
+    private org.apache.logging.log4j.Logger parent;
 
     /**
      * Creates a new PluginLogger that extracts the name from a plugin.
@@ -20,17 +24,15 @@
      * @param context A reference to the plugin
      */
     public PluginLogger(Plugin context) {
-        super(context.getClass().getCanonicalName(), null);
+        super(new LoggerContext(context.getClass().getCanonicalName()), context.getClass().getCanonicalName(), context.getServer().getLogger().getMessageFactory());
         String prefix = context.getDescription().getPrefix();
         pluginName = prefix != null ? "[" + prefix + "] " : "[" + context.getDescription().getName() + "] ";
-        setParent(context.getServer().getLogger());
+        parent = context.getServer().getLogger();
         setLevel(Level.ALL);
     }
 
     @Override
-    public void log(LogRecord logRecord) {
-        logRecord.setMessage(pluginName + logRecord.getMessage());
-        super.log(logRecord);
+    public void logMessage(String fqcn, org.apache.logging.log4j.Level level, Marker marker, Message message, Throwable t) {
+        parent.log(level, marker, pluginName + message.getFormattedMessage(), t);
     }
-
 }
diff --git a/src/main/java/io/nukkit/plugin/SimplePluginManager.java b/src/main/java/io/nukkit/plugin/SimplePluginManager.java
index 690e68dde6..82a3a1ac46 100755
--- a/src/main/java/io/nukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/io/nukkit/plugin/SimplePluginManager.java
@@ -13,13 +13,13 @@
 import io.nukkit.permissions.Permission;
 import io.nukkit.permissions.PermissionDefault;
 import io.nukkit.util.FileUtil;
-import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 
 import java.io.File;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.util.*;
-import java.util.logging.Level;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -122,23 +122,23 @@ public void registerInterface(Class<? extends PluginLoader> loader) throws Illeg
                 description = loader.getPluginDescription(file);
                 String name = description.getName();
                 if (name.equalsIgnoreCase("nukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
-                    server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': Restricted Name");
+                    server.getLogger().log(Level.ERROR, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': Restricted Name");
                     continue;
                 } else if (description.rawName.indexOf(' ') != -1) {
-                    server.getLogger().warning(String.format(
+                    server.getLogger().log(Level.WARN, String.format(
                             "Plugin `%s' uses the space-character (0x20) in its name `%s' - this is discouraged",
                             description.getFullName(),
                             description.rawName
                     ));
                 }
             } catch (InvalidDescriptionException ex) {
-                server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                server.getLogger().log(Level.ERROR, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
                 continue;
             }
 
             File replacedFile = plugins.put(description.getName(), file);
             if (replacedFile != null) {
-                server.getLogger().severe(String.format(
+                server.getLogger().log(Level.ERROR, String.format(
                         "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
                         description.getName(),
                         file.getPath(),
@@ -203,7 +203,7 @@ public void registerInterface(Class<? extends PluginLoader> loader) throws Illeg
                             dependencies.remove(plugin);
 
                             server.getLogger().log(
-                                    Level.SEVERE,
+                                    Level.ERROR,
                                     "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'",
                                     new UnknownDependencyException(dependency));
                             break;
@@ -241,7 +241,7 @@ public void registerInterface(Class<? extends PluginLoader> loader) throws Illeg
                         loadedPlugins.add(plugin);
                         continue;
                     } catch (InvalidPluginException ex) {
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                        server.getLogger().log(Level.ERROR, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
                     }
                 }
             }
@@ -265,7 +265,7 @@ public void registerInterface(Class<? extends PluginLoader> loader) throws Illeg
                             loadedPlugins.add(plugin);
                             break;
                         } catch (InvalidPluginException ex) {
-                            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
+                            server.getLogger().log(Level.ERROR, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "'", ex);
                         }
                     }
                 }
@@ -278,7 +278,7 @@ public void registerInterface(Class<? extends PluginLoader> loader) throws Illeg
                     while (failedPluginIterator.hasNext()) {
                         File file = failedPluginIterator.next();
                         failedPluginIterator.remove();
-                        server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': circular dependency detected");
+                        server.getLogger().log(Level.ERROR, "Could not load '" + file.getPath() + "' in folder '" + directory.getPath() + "': circular dependency detected");
                     }
                 }
             }
@@ -392,7 +392,7 @@ public void enablePlugin(final Plugin plugin) {
             try {
                 plugin.getPluginLoader().enablePlugin(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             HandlerList.bakeAll();
@@ -411,32 +411,32 @@ public void disablePlugin(final Plugin plugin) {
             try {
                 plugin.getPluginLoader().disablePlugin(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             try {
                 server.getScheduler().cancelTasks(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while cancelling tasks for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while cancelling tasks for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             try {
                 server.getServicesManager().unregisterAll(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering services for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while unregistering services for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             try {
                 HandlerList.unregisterAll(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering events for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while unregistering events for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             try {
                 server.getMessenger().unregisterIncomingPluginChannel(plugin);
                 server.getMessenger().unregisterOutgoingPluginChannel(plugin);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred (in the plugin loader) while unregistering plugin channels for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred (in the plugin loader) while unregistering plugin channels for " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
         }
     }
@@ -466,8 +466,8 @@ public void callEvent(Event event) {
             if (Thread.holdsLock(this)) {
                 throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from inside synchronized code.");
             }
-            if (server.isPrimaryThread()) {
-                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from primary server thread.");
+            if (server.isServerThread()) {
+                throw new IllegalStateException(event.getEventName() + " cannot be triggered asynchronously from server thread.");
             }
             fireEvent(event);
         } else {
@@ -494,7 +494,7 @@ private void fireEvent(Event event) {
                 if (plugin.isNaggable()) {
                     plugin.setNaggable(false);
 
-                    server.getLogger().log(Level.SEVERE, String.format(
+                    server.getLogger().log(Level.ERROR, String.format(
                             "Nag author(s): '%s' of '%s' about the following: %s",
                             plugin.getDescription().getAuthors(),
                             plugin.getDescription().getFullName(),
@@ -502,7 +502,7 @@ private void fireEvent(Event event) {
                     ));
                 }
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName(), ex);
+                server.getLogger().log(Level.ERROR, "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName(), ex);
             }
         }
     }
diff --git a/src/main/java/io/nukkit/plugin/SimpleServicesManager.java b/src/main/java/io/nukkit/plugin/SimpleServicesManager.java
index 11a2116b61..7ff219e091 100755
--- a/src/main/java/io/nukkit/plugin/SimpleServicesManager.java
+++ b/src/main/java/io/nukkit/plugin/SimpleServicesManager.java
@@ -2,7 +2,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import io.nukkit.Bukkit;
+import io.nukkit.Nukkit;
 import io.nukkit.event.server.ServiceRegisterEvent;
 import io.nukkit.event.server.ServiceUnregisterEvent;
 
@@ -47,7 +47,7 @@
             }
 
         }
-        Bukkit.getServer().getPluginManager().callEvent(new ServiceRegisterEvent(registeredProvider));
+        Nukkit.getServer().getPluginManager().callEvent(new ServiceRegisterEvent(registeredProvider));
     }
 
     /**
@@ -56,7 +56,7 @@
      * @param plugin The plugin
      */
     public void unregisterAll(Plugin plugin) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
+        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<>();
         synchronized (providers) {
             Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
 
@@ -88,7 +88,7 @@ public void unregisterAll(Plugin plugin) {
             }
         }
         for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
+            Nukkit.getServer().getPluginManager().callEvent(event);
         }
     }
 
@@ -99,7 +99,7 @@ public void unregisterAll(Plugin plugin) {
      * @param provider The service provider implementation
      */
     public void unregister(Class<?> service, Object provider) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
+        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<>();
         synchronized (providers) {
             Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
 
@@ -137,7 +137,7 @@ public void unregister(Class<?> service, Object provider) {
             }
         }
         for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
+            Nukkit.getServer().getPluginManager().callEvent(event);
         }
     }
 
@@ -147,7 +147,7 @@ public void unregister(Class<?> service, Object provider) {
      * @param provider The service provider implementation
      */
     public void unregister(Object provider) {
-        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<ServiceUnregisterEvent>();
+        ArrayList<ServiceUnregisterEvent> unregisteredEvents = new ArrayList<>();
         synchronized (providers) {
             Iterator<Map.Entry<Class<?>, List<RegisteredServiceProvider<?>>>> it = providers.entrySet().iterator();
 
@@ -179,7 +179,7 @@ public void unregister(Object provider) {
             }
         }
         for (ServiceUnregisterEvent event : unregisteredEvents) {
-            Bukkit.getServer().getPluginManager().callEvent(event);
+            Nukkit.getServer().getPluginManager().callEvent(event);
         }
     }
 
diff --git a/src/main/java/io/nukkit/plugin/TestPluginLogger.java b/src/main/java/io/nukkit/plugin/TestPluginLogger.java
new file mode 100755
index 0000000000..55fb3c680d
--- /dev/null
+++ b/src/main/java/io/nukkit/plugin/TestPluginLogger.java
@@ -0,0 +1,38 @@
+package io.nukkit.plugin;
+
+import io.nukkit.Nukkit;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.core.Logger;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.message.Message;
+
+
+/**
+ * The PluginLogger class is a modified {@link Logger} that prepends all
+ * logging calls with the name of the plugin doing the logging. The API for
+ * PluginLogger is exactly the same as {@link Logger}.
+ *
+ * @see Logger
+ */
+public class TestPluginLogger extends Logger {
+    private String pluginName;
+    private org.apache.logging.log4j.Logger parent;
+
+    /**
+     * Creates a new PluginLogger that extracts the name from a plugin.
+     *
+     * @param context A reference to the plugin
+     */
+    public TestPluginLogger(String name) {
+        super(new LoggerContext(name), name, null);
+        pluginName = "[" + name + "] ";
+        parent = Nukkit.getServer().getLogger();
+        setLevel(Level.ALL);
+    }
+
+    @Override
+    public void logMessage(String fqcn, Level level, Marker marker, Message message, Throwable t) {
+        parent.log(level, marker, pluginName + message.getFormattedMessage(), t);
+    }
+}
diff --git a/src/main/java/io/nukkit/plugin/java/JavaPlugin.java b/src/main/java/io/nukkit/plugin/java/JavaPlugin.java
index 62bae13174..6d8a7d55d7 100755
--- a/src/main/java/io/nukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/io/nukkit/plugin/java/JavaPlugin.java
@@ -1,13 +1,25 @@
 package io.nukkit.plugin.java;
 
+import com.avaje.ebean.EbeanServer;
+import com.avaje.ebean.EbeanServerFactory;
+import com.avaje.ebean.config.DataSourceConfig;
+import com.avaje.ebean.config.ServerConfig;
+import com.avaje.ebeaninternal.api.SpiEbeanServer;
+import com.avaje.ebeaninternal.server.ddl.DdlGenerator;
 import com.google.common.base.Charsets;
 import com.google.common.io.ByteStreams;
 import io.nukkit.Server;
+import io.nukkit.command.Command;
+import io.nukkit.command.CommandSender;
+import io.nukkit.command.PluginCommand;
+import io.nukkit.configuration.InvalidConfigurationException;
 import io.nukkit.configuration.file.FileConfiguration;
-import io.nukkit.plugin.PluginBase;
-import io.nukkit.plugin.PluginDescriptionFile;
-import io.nukkit.plugin.PluginLoader;
-import io.nukkit.plugin.PluginLogger;
+import io.nukkit.configuration.file.YamlConfiguration;
+import io.nukkit.generator.ChunkGenerator;
+import io.nukkit.plugin.*;
+import io.nukkit.util.Warning;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 
 import java.io.*;
 import java.net.URL;
@@ -15,8 +27,6 @@
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * Represents a Java plugin
@@ -173,19 +183,19 @@ public void reloadConfig() {
             try {
                 contents = ByteStreams.toByteArray(defConfigStream);
             } catch (final IOException e) {
-                getLogger().log(Level.SEVERE, "Unexpected failure reading config.yml", e);
+                getLogger().log(Level.ERROR, "Unexpected failure reading config.yml", e);
                 return;
             }
 
             final String text = new String(contents, Charset.defaultCharset());
             if (!text.equals(new String(contents, Charsets.UTF_8))) {
-                getLogger().warning("Default system encoding may have misread config.yml from plugin jar");
+                getLogger().log(Level.WARN, "Default system encoding may have misread config.yml from plugin jar");
             }
 
             try {
                 defConfig.loadFromString(text);
             } catch (final InvalidConfigurationException e) {
-                getLogger().log(Level.SEVERE, "Cannot load configuration from jar", e);
+                getLogger().log(Level.ERROR, "Cannot load configuration from jar", e);
             }
         }
 
@@ -201,7 +211,7 @@ public void saveConfig() {
         try {
             getConfig().save(configFile);
         } catch (IOException ex) {
-            logger.log(Level.SEVERE, "Could not save config to " + configFile, ex);
+            logger.log(Level.ERROR, "Could not save config to " + configFile, ex);
         }
     }
 
@@ -243,10 +253,10 @@ public void saveResource(String resourcePath, boolean replace) {
                 out.close();
                 in.close();
             } else {
-                logger.log(Level.WARNING, "Could not save " + outFile.getName() + " to " + outFile + " because " + outFile.getName() + " already exists.");
+                logger.log(Level.WARN, "Could not save " + outFile.getName() + " to " + outFile + " because " + outFile.getName() + " already exists.");
             }
         } catch (IOException ex) {
-            logger.log(Level.SEVERE, "Could not save " + outFile.getName() + " to " + outFile, ex);
+            logger.log(Level.ERROR, "Could not save " + outFile.getName() + " to " + outFile, ex);
         }
     }
 
@@ -303,10 +313,10 @@ protected final void setEnabled(final boolean enabled) {
      */
     @Deprecated
     protected final void initialize(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
-        if (server.getWarningState() == WarningState.OFF) {
+        if (server.getWarningState() == Warning.WarningState.OFF) {
             return;
         }
-        getLogger().log(Level.WARNING, getClass().getName() + " is already initialized", server.getWarningState() == WarningState.DEFAULT ? null : new AuthorNagException("Explicit initialization"));
+        getLogger().log(Level.WARN, getClass().getName() + " is already initialized", server.getWarningState() == Warning.WarningState.DEFAULT ? null : new AuthorNagException("Explicit initialization"));
     }
 
     final void init(PluginLoader loader, Server server, PluginDescriptionFile description, File dataFolder, File file, ClassLoader classLoader) {
@@ -454,7 +464,7 @@ protected void removeDDL() {
     }
 
     @Override
-    public final Logger getLogger() {
+    public final PluginLogger getLogger() {
         return logger;
     }
 
diff --git a/src/main/java/io/nukkit/plugin/java/JavaPluginLoader.java b/src/main/java/io/nukkit/plugin/java/JavaPluginLoader.java
index 97af984199..9b2dc7017e 100755
--- a/src/main/java/io/nukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/io/nukkit/plugin/java/JavaPluginLoader.java
@@ -13,6 +13,7 @@
 import io.nukkit.util.Warning;
 import io.nukkit.util.Warning.WarningState;
 import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.Level;
 import org.yaml.snakeyaml.error.YAMLException;
 
 import java.io.File;
@@ -24,7 +25,6 @@
 import java.util.*;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
-import java.util.logging.Level;
 import java.util.regex.Pattern;
 
 /**
@@ -68,7 +68,7 @@ public Plugin loadPlugin(final File file) throws InvalidPluginException {
         if (dataFolder.equals(oldDataFolder)) {
             // They are equal -- nothing needs to be done!
         } else if (dataFolder.isDirectory() && oldDataFolder.isDirectory()) {
-            server.getLogger().warning(String.format(
+            server.getLogger().log(Level.WARN, String.format(
                     "While loading %s (%s) found old-data folder: `%s' next to the new one `%s'",
                     description.getFullName(),
                     file,
@@ -221,7 +221,7 @@ private void removeClass(String name) {
             Collections.addAll(methods, publicMethods);
             Collections.addAll(methods, listener.getClass().getDeclaredMethods());
         } catch (NoClassDefFoundError e) {
-            plugin.getLogger().severe("Plugin " + plugin.getDescription().getFullName() + " has failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
+            plugin.getLogger().log(Level.ERROR, "Plugin " + plugin.getDescription().getFullName() + " has failed to register events for " + listener.getClass() + " because " + e.getMessage() + " does not exist.");
             return ret;
         }
 
@@ -230,7 +230,7 @@ private void removeClass(String name) {
             if (eh == null) continue;
             final Class<?> checkClass;
             if (method.getParameterTypes().length != 1 || !Event.class.isAssignableFrom(checkClass = method.getParameterTypes()[0])) {
-                plugin.getLogger().severe(plugin.getDescription().getFullName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
+                plugin.getLogger().log(Level.ERROR, plugin.getDescription().getFullName() + " attempted to register an invalid EventHandler method signature \"" + method.toGenericString() + "\" in " + listener.getClass());
                 continue;
             }
             final Class<? extends Event> eventClass = checkClass.asSubclass(Event.class);
@@ -250,7 +250,7 @@ private void removeClass(String name) {
                         break;
                     }
                     plugin.getLogger().log(
-                            Level.WARNING,
+                            Level.WARN,
                             String.format(
                                     "\"%s\" has registered a listener for %s on method \"%s\", but the event is Deprecated." +
                                             " \"%s\"; please notify the authors %s.",
@@ -304,7 +304,7 @@ public void enablePlugin(final Plugin plugin) {
             try {
                 jPlugin.setEnabled(true);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred while enabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             // Perhaps abort here, rather than continue going, but as it stands,
@@ -328,7 +328,7 @@ public void disablePlugin(Plugin plugin) {
             try {
                 jPlugin.setEnabled(false);
             } catch (Throwable ex) {
-                server.getLogger().log(Level.SEVERE, "Error occurred while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
+                server.getLogger().log(Level.ERROR, "Error occurred while disabling " + plugin.getDescription().getFullName() + " (Is it up to date?)", ex);
             }
 
             loaders.remove(jPlugin.getDescription().getName());
diff --git a/src/main/java/io/nukkit/util/ConsoleHandler.java b/src/main/java/io/nukkit/util/ConsoleHandler.java
index c6cd93c979..aec00d966f 100755
--- a/src/main/java/io/nukkit/util/ConsoleHandler.java
+++ b/src/main/java/io/nukkit/util/ConsoleHandler.java
@@ -3,9 +3,11 @@
 import io.nukkit.Nukkit;
 import io.nukkit.Server;
 import jline.console.ConsoleReader;
+import org.apache.logging.log4j.Level;
 
 import java.io.IOException;
 
+
 /**
  * author: MagicDroidX
  * Nukkit Project
@@ -40,7 +42,7 @@ public void run() {
                     }
                 }
             } catch (IOException e) {
-                Server.LOGGER.error("Exception handling console input", e);
+                Nukkit.getLogger().log(Level.ERROR, "Exception handling console input", e);
             }
         }
     }
diff --git a/src/main/java/io/nukkit/util/FileUtil.java b/src/main/java/io/nukkit/util/FileUtil.java
new file mode 100755
index 0000000000..4f16e5a1d9
--- /dev/null
+++ b/src/main/java/io/nukkit/util/FileUtil.java
@@ -0,0 +1,57 @@
+package io.nukkit.util;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.channels.FileChannel;
+
+/**
+ * Class containing file utilities
+ */
+public class FileUtil {
+
+    /**
+     * This method copies one file to another location
+     *
+     * @param inFile  the source filename
+     * @param outFile the target filename
+     * @return true on success
+     */
+    public static boolean copy(File inFile, File outFile) {
+        if (!inFile.exists()) {
+            return false;
+        }
+
+        FileChannel in = null;
+        FileChannel out = null;
+
+        try {
+            in = new FileInputStream(inFile).getChannel();
+            out = new FileOutputStream(outFile).getChannel();
+
+            long pos = 0;
+            long size = in.size();
+
+            while (pos < size) {
+                pos += in.transferTo(pos, 10 * 1024 * 1024, out);
+            }
+        } catch (IOException ioe) {
+            return false;
+        } finally {
+            try {
+                if (in != null) {
+                    in.close();
+                }
+                if (out != null) {
+                    out.close();
+                }
+            } catch (IOException ioe) {
+                return false;
+            }
+        }
+
+        return true;
+
+    }
+}
diff --git a/src/main/java/io/nukkit/util/StringUtil.java b/src/main/java/io/nukkit/util/StringUtil.java
new file mode 100755
index 0000000000..00316e193f
--- /dev/null
+++ b/src/main/java/io/nukkit/util/StringUtil.java
@@ -0,0 +1,58 @@
+package io.nukkit.util;
+
+import org.apache.commons.lang3.Validate;
+
+import java.util.Collection;
+
+public class StringUtil {
+
+    /**
+     * Copies all elements from the iterable collection of originals to the
+     * collection provided.
+     *
+     * @param token      String to search for
+     * @param originals  An iterable collection of strings to filter.
+     * @param collection The collection to add matches to
+     * @return the collection provided that would have the elements copied
+     * into
+     * @throws UnsupportedOperationException if the collection is immutable
+     *                                       and originals contains a string which starts with the specified
+     *                                       search string.
+     * @throws IllegalArgumentException      if any parameter is is null
+     * @throws IllegalArgumentException      if originals contains a null element.
+     *                                       <b>Note: the collection may be modified before this is thrown</b>
+     */
+    public static <T extends Collection<? super String>> T copyPartialMatches(final String token, final Iterable<String> originals, final T collection) throws UnsupportedOperationException, IllegalArgumentException {
+        Validate.notNull(token, "Search token cannot be null");
+        Validate.notNull(collection, "Collection cannot be null");
+        Validate.notNull(originals, "Originals cannot be null");
+
+        for (String string : originals) {
+            if (startsWithIgnoreCase(string, token)) {
+                collection.add(string);
+            }
+        }
+
+        return collection;
+    }
+
+    /**
+     * This method uses a region to check case-insensitive equality. This
+     * means the internal array does not need to be copied like a
+     * toLowerCase() call would.
+     *
+     * @param string String to check
+     * @param prefix Prefix of string to compare
+     * @return true if provided string starts with, ignoring case, the prefix
+     * provided
+     * @throws NullPointerException     if prefix is null
+     * @throws IllegalArgumentException if string is null
+     */
+    public static boolean startsWithIgnoreCase(final String string, final String prefix) throws IllegalArgumentException, NullPointerException {
+        Validate.notNull(string, "Cannot check a null string for a match");
+        if (string.length() < prefix.length()) {
+            return false;
+        }
+        return string.regionMatches(true, 0, prefix, 0, prefix.length());
+    }
+}
diff --git a/src/main/java/io/nukkit/util/Versioning.java b/src/main/java/io/nukkit/util/Versioning.java
index 69f0b7bf69..d0f2356db2 100755
--- a/src/main/java/io/nukkit/util/Versioning.java
+++ b/src/main/java/io/nukkit/util/Versioning.java
@@ -10,7 +10,7 @@
 
 public final class Versioning {
     public static String getNukkitVersion() {
-        String result = "Unknown-Version";
+        String result = Nukkit.VERSION_UNKNOWN;
         InputStream stream = Nukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/io.nukkit/nukkit/pom.properties");
         Properties properties = new Properties();
         if (stream != null) {
