diff --git a/README.md b/README.md
index 46381b5059..e9714ada6b 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@ Mypy: Optional Static Typing for Python
 =======================================
 
 [![Build Status](https://travis-ci.org/python/mypy.svg)](https://travis-ci.org/python/mypy)
-[![Chat at https://gitter.im/python/mypy](https://badges.gitter.im/python/mypy.svg)](https://gitter.im/python/mypy?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
+[![Chat at https://gitter.im/python/typing](https://badges.gitter.im/python/typing.svg)](https://gitter.im/python/typing?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 
 Got a question? Join us on Gitter!
diff --git a/docs/source/command_line.rst b/docs/source/command_line.rst
index ad7555bb27..e4807b3b2d 100644
--- a/docs/source/command_line.rst
+++ b/docs/source/command_line.rst
@@ -278,7 +278,7 @@ Here are some more useful flags:
 
 - ``--disallow-any`` disallows various types of ``Any`` in a module.
   The option takes a comma-separated list of the following values:
-  ``unimported``, ``unannotated``.
+  ``unimported``, ``unannotated``, ``decorated``.
 
   ``unimported`` disallows usage of types that come from unfollowed imports
   (such types become aliases for ``Any``). Unfollowed imports occur either
@@ -290,6 +290,9 @@ Here are some more useful flags:
   of the parameters or the return type). ``unannotated`` option is
   interchangeable with ``--disallow-untyped-defs``.
 
+  ``decorated`` disallows functions that have ``Any`` in their signature
+  after decorator transformation.
+
 - ``--disallow-untyped-defs`` reports an error whenever it encounters
   a function definition without type annotations.
 
diff --git a/mypy/checker.py b/mypy/checker.py
index 892981be20..b19a15b1af 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -28,7 +28,7 @@
     AwaitExpr, PromoteExpr, Node, EnumCallExpr,
     ARG_POS, MDEF,
     CONTRAVARIANT, COVARIANT)
-from mypy import nodes, checkexpr
+from mypy import nodes
 from mypy.typeanal import has_any_from_unimported_type
 from mypy.types import (
     Type, AnyType, CallableType, FunctionLike, Overloaded, TupleType, TypedDictType,
@@ -2297,11 +2297,8 @@ def visit_with_stmt(self, s: WithStmt) -> None:
     def check_untyped_after_decorator(self, typ: Type, func: FuncDef) -> None:
         if 'decorated' not in self.options.disallow_any or self.is_stub:
             return
-        if not isinstance(typ, CallableType):
-            self.msg.untyped_decorated_function(typ, func)
-            return
 
-        if checkexpr.has_any_type(typ):
+        if mypy.checkexpr.has_any_type(typ):
             self.msg.untyped_decorated_function(typ, func)
 
     def check_async_with_item(self, expr: Expression, target: Expression,
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 9093aec831..3914e247c0 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -1936,12 +1936,15 @@ def visit_lambda_expr(self, e: LambdaExpr) -> Type:
         """Type check lambda expression."""
         inferred_type, type_override = self.infer_lambda_type_using_context(e)
         if not inferred_type:
+            self.chk.return_types.append(AnyType())
             # No useful type context.
             ret_type = self.accept(e.expr(), allow_none_return=True)
             fallback = self.named_type('builtins.function')
+            self.chk.return_types.pop()
             return callable_type(e, fallback, ret_type)
         else:
             # Type context available.
+            self.chk.return_types.append(inferred_type.ret_type)
             self.chk.check_func_item(e, type_override=type_override)
             if e.expr() not in self.chk.type_map:
                 self.accept(e.expr(), allow_none_return=True)
@@ -1950,7 +1953,9 @@ def visit_lambda_expr(self, e: LambdaExpr) -> Type:
                 # For "lambda ...: None", just use type from the context.
                 # Important when the context is Callable[..., None] which
                 # really means Void. See #1425.
+                self.chk.return_types.pop()
                 return inferred_type
+            self.chk.return_types.pop()
             return replace_callable_return_type(inferred_type, ret_type)
 
     def infer_lambda_type_using_context(self, e: LambdaExpr) -> Tuple[Optional[CallableType],
diff --git a/mypy/semanal.py b/mypy/semanal.py
index 523edc8563..c5b460ebb3 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -3448,7 +3448,7 @@ def check_no_global(self, n: str, ctx: Context,
             elif prev_is_overloaded:
                 self.fail("Definition of '{}' missing 'overload'".format(n), ctx)
             else:
-                self.name_already_defined(n, ctx)
+                self.name_already_defined(n, ctx, self.globals[n])
 
     def name_not_defined(self, name: str, ctx: Context) -> None:
         message = "Name '{}' is not defined".format(name)
@@ -3463,8 +3463,16 @@ def name_not_defined(self, name: str, ctx: Context) -> None:
                 # Yes. Generate a helpful note.
                 self.add_fixture_note(fullname, ctx)
 
-    def name_already_defined(self, name: str, ctx: Context) -> None:
-        self.fail("Name '{}' already defined".format(name), ctx)
+    def name_already_defined(self, name: str, ctx: Context,
+                             original_ctx: Optional[SymbolTableNode] = None) -> None:
+        if original_ctx:
+            if original_ctx.node and original_ctx.node.get_line() != -1:
+                extra_msg = ' on line {}'.format(original_ctx.node.get_line())
+            else:
+                extra_msg = ' (possibly by an import)'
+        else:
+            extra_msg = ''
+        self.fail("Name '{}' already defined{}".format(name, extra_msg), ctx)
 
     def fail(self, msg: str, ctx: Context, serious: bool = False, *,
              blocker: bool = False) -> None:
diff --git a/setup.cfg b/setup.cfg
index 27244e8803..0dc9667a58 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -56,5 +56,5 @@ show_missing = true
 # Then run "python3 setup.py bdist_wheel" to build a wheel file
 # (and then upload that to PyPI).
 requires-dist =
-    typed-ast >= 1.0.3, < 1.1.0
+    typed-ast >= 1.0.4, < 1.1.0
     typing >= 3.5.3; python_version < "3.5"
diff --git a/setup.py b/setup.py
index efc23f4a6f..77c3a3b870 100644
--- a/setup.py
+++ b/setup.py
@@ -100,7 +100,7 @@ def run(self):
 # "pip3 install git+git://github.com/python/mypy.git"
 # (as suggested by README.md).
 install_requires = []
-install_requires.append('typed-ast >= 1.0.3, < 1.1.0')
+install_requires.append('typed-ast >= 1.0.4, < 1.1.0')
 if sys.version_info < (3, 5):
     install_requires.append('typing >= 3.5.3')
 
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index 666477941e..6890bd792f 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -714,7 +714,7 @@ A()
 class A: pass
 class A: pass
 [out]
-main:4: error: Name 'A' already defined
+main:4: error: Name 'A' already defined on line 3
 
 [case testDocstringInClass]
 import typing
diff --git a/test-data/unit/check-expressions.test b/test-data/unit/check-expressions.test
index ab2bd1e925..8cbd1782ea 100644
--- a/test-data/unit/check-expressions.test
+++ b/test-data/unit/check-expressions.test
@@ -1208,6 +1208,20 @@ def void() -> None:
     pass
 x = lambda: void() # type: typing.Callable[[], None]
 
+[case testNoCrashOnLambdaGenerator]
+from typing import Iterator, Callable
+
+# These should not crash
+lambda: (yield)
+
+gen: Callable[[], Iterator[str]]
+gen = (lambda: (yield 1))  # E: Incompatible types in yield (actual type "int", expected type "str")
+
+def fun(cb: Callable[[], Iterator[str]]) -> None:
+    pass
+fun(lambda: (yield from [1]))  # E: Incompatible types in "yield from" (actual type "int", expected type "str")
+[builtins fixtures/list.pyi]
+[out]
 
 -- List comprehensions
 -- -------------------
diff --git a/test-data/unit/check-flags.test b/test-data/unit/check-flags.test
index 33d68c13ff..c1d3a9a4ae 100644
--- a/test-data/unit/check-flags.test
+++ b/test-data/unit/check-flags.test
@@ -516,7 +516,7 @@ x, y = 1, 2  # type: Unchecked, Unchecked
 main:4: error: Type of variable becomes "Any" due to an unfollowed import
 main:6: error: A type on this line becomes "Any" due to an unfollowed import
 
-[case testDisallowAnyDecoratorUnannotatedDecorator]
+[case testDisallowAnyDecoratedUnannotatedDecorator]
 # flags: --disallow-any=decorated
 from typing import Any
 
@@ -530,7 +530,7 @@ def f(x: Any) -> Any:  # E: Function is untyped after decorator transformation
 def h(x):  # E: Function is untyped after decorator transformation
     pass
 [builtins fixtures/list.pyi]
-[case testDisallowAnyDecoratorErrorIsReportedOnlyOnce]
+[case testDisallowAnyDecoratedErrorIsReportedOnlyOnce]
 # flags: --disallow-any=decorated
 
 def d(f):
@@ -543,7 +543,7 @@ def d2(f):
 @d2
 @d
 def f(x: int) -> None: pass  # E: Function is untyped after decorator transformation
-[case testDisallowAnyDecoratorReturnAny]
+[case testDisallowAnyDecoratedReturnAny]
 # flags: --disallow-any=decorated
 from typing import Any
 
@@ -553,7 +553,7 @@ def d(f) -> Any:
 @d
 def f() -> None: pass  # E: Function is untyped after decorator transformation
 [builtins fixtures/list.pyi]
-[case testDisallowAnyDecoratorReturnCallable]
+[case testDisallowAnyDecoratedReturnCallable]
 # flags: --disallow-any=decorated
 from typing import Any, Callable
 
@@ -564,7 +564,7 @@ def d(f) -> Callable[..., None]:
 def g(i: int, s: str) -> None: pass  # E: Type of decorated function contains type "Any" (Callable[..., None])
 
 [builtins fixtures/list.pyi]
-[case testDisallowAnyDecoratorNonexistentDecorator]
+[case testDisallowAnyDecoratedNonexistentDecorator]
 # flags: --disallow-any=decorated --ignore-missing-imports
 from nonexistent import d
 
@@ -572,7 +572,7 @@ from nonexistent import d
 def f() -> None: pass  # E: Function is untyped after decorator transformation
 [builtins fixtures/list.pyi]
 
-[case testDisallowAnyPartlyTypedCallable]
+[case testDisallowAnyDecoratedPartlyTypedCallable]
 # flags: --disallow-any=decorated --ignore-missing-imports
 from typing import Callable, Any, List
 
@@ -587,7 +587,7 @@ def g(i: int) -> None: # E: Type of decorated function contains type "Any" (Call
     pass
 [builtins fixtures/list.pyi]
 
-[case testDisallowAnyDecoratorReturnsCallableNoParams]
+[case testDisallowAnyDecoratedReturnsCallableNoParams]
 # flags: --disallow-any=decorated
 from typing import Callable
 
@@ -598,3 +598,12 @@ def d(p) -> Callable[[], int]:
 def f(i):
     return i
 [builtins fixtures/list.pyi]
+
+[case testDisallowAnyDecoratedDecoratorReturnsNonCallable]
+# flags: --disallow-any=decorated
+def d(p) -> int:
+    return p(0)
+
+@d
+def f(i):
+    return i
diff --git a/test-data/unit/check-functions.test b/test-data/unit/check-functions.test
index fc049053f8..41f8f7a49a 100644
--- a/test-data/unit/check-functions.test
+++ b/test-data/unit/check-functions.test
@@ -1213,7 +1213,7 @@ from typing import Any
 x = None # type: Any
 if x:
     def f(): pass
-def f(): pass # E: Name 'f' already defined
+def f(): pass # E: Name 'f' already defined on line 4
 
 [case testIncompatibleConditionalFunctionDefinition]
 from typing import Any
@@ -1837,7 +1837,7 @@ f = g # E: Incompatible types in assignment (expression has type Callable[[Any,
 
 [case testRedefineFunction2]
 def f() -> None: pass
-def f() -> None: pass # E: Name 'f' already defined
+def f() -> None: pass # E: Name 'f' already defined on line 1
 
 
 -- Special cases
diff --git a/test-data/unit/check-overloading.test b/test-data/unit/check-overloading.test
index 69289fae18..f3e5b993a3 100644
--- a/test-data/unit/check-overloading.test
+++ b/test-data/unit/check-overloading.test
@@ -1106,7 +1106,7 @@ def f(a: int) -> None: pass
 def f(a: str) -> None: pass
 [out]
 tmp/foo.pyi:2: error: Single overload definition, multiple required
-tmp/foo.pyi:5: error: Name 'f' already defined
+tmp/foo.pyi:5: error: Name 'f' already defined on line 2
 
 [case testOverloadTuple]
 from foo import *
diff --git a/test-data/unit/check-semanal-error.test b/test-data/unit/check-semanal-error.test
index 0a078290a1..1869bbe8e3 100644
--- a/test-data/unit/check-semanal-error.test
+++ b/test-data/unit/check-semanal-error.test
@@ -79,3 +79,19 @@ yield # E: 'yield' outside function
 [case testYieldFromOutsideFunction]
 x = 1
 yield from x # E: 'yield from' outside function
+
+[case testImportFuncDup]
+import m
+def m() -> None: ...  # ok
+
+[file m.py]
+[out]
+
+[case testIgnoredImportDup]
+import m # type: ignore
+from m import f # type: ignore
+def m() -> None: ...  # ok
+def f() -> None: ...  # ok
+
+[out]
+
diff --git a/test-data/unit/semanal-errors.test b/test-data/unit/semanal-errors.test
index 57dbb6ca39..2192bce322 100644
--- a/test-data/unit/semanal-errors.test
+++ b/test-data/unit/semanal-errors.test
@@ -165,7 +165,7 @@ import typing
 class A: pass
 class A: pass
 [out]
-main:3: error: Name 'A' already defined
+main:3: error: Name 'A' already defined on line 2
 
 [case testMultipleMixedDefinitions]
 import typing
@@ -173,8 +173,8 @@ x = 1
 def x(): pass
 class x: pass
 [out]
-main:3: error: Name 'x' already defined
-main:4: error: Name 'x' already defined
+main:3: error: Name 'x' already defined on line 2
+main:4: error: Name 'x' already defined on line 2
 
 [case testNameNotImported]
 import typing
@@ -1037,13 +1037,13 @@ t = 1 # E: Invalid assignment target
 [case testRedefineTypevar2]
 from typing import TypeVar
 t = TypeVar('t')
-def t(): pass # E: Name 't' already defined
+def t(): pass # E: Name 't' already defined on line 2
 [out]
 
 [case testRedefineTypevar3]
 from typing import TypeVar
 t = TypeVar('t')
-class t: pass # E: Name 't' already defined
+class t: pass # E: Name 't' already defined on line 2
 [out]
 
 [case testRedefineTypevar4]
@@ -1330,3 +1330,74 @@ a = ('spam', 'spam', 'eggs', 'spam')  # type: Tuple[str]
 [out]
 main:3: error: Name 'a' already defined
 main:4: error: Name 'a' already defined
+
+[case testDuplicateDefFromImport]
+from m import A
+class A:  # E: Name 'A' already defined (possibly by an import)
+    pass
+[file m.py]
+class A:
+    pass
+[out]
+
+[case testDuplicateDefDec]
+from typing import Any
+def dec(x: Any) -> Any:
+    return x
+@dec
+def f() -> None:
+    pass
+@dec  # E: Name 'f' already defined
+def f() -> None:
+    pass
+[out]
+
+[case testDuplicateDefOverload]
+from typing import overload, Any
+if 1:
+    @overload
+    def f(x: int) -> None:
+        pass
+    @overload
+    def f(x: str) -> None:
+        pass
+    def f(x: Any) -> None:
+        pass
+else:
+    def f(x: str) -> None:  # E: Name 'f' already defined on line 3
+        pass
+[out]
+
+[case testDuplicateDefNT]
+from typing import NamedTuple
+N = NamedTuple('N', [('a', int),
+                     ('b', str)])
+
+class N:  # E: Name 'N' already defined on line 2
+    pass
+[out]
+
+[case testDuplicateDefTypedDict]
+from mypy_extensions import TypedDict
+Point = TypedDict('Point', {'x': int, 'y': int})
+
+class Point:  # E: Name 'Point' already defined on line 2
+    pass
+[builtins fixtures/dict.pyi]
+
+[out]
+
+[case testTypeVarClassDup]
+from typing import TypeVar
+T = TypeVar('T')
+class T: ...  # E: Name 'T' already defined on line 2
+
+[out]
+
+[case testAliasDup]
+from typing import List
+A = List[int]
+class A: ... # E: Name 'A' already defined on line 2
+
+[builtins fixtures/list.pyi]
+[out]
diff --git a/test-requirements.txt b/test-requirements.txt
index 0619cdc316..62e2f4c2c2 100644
--- a/test-requirements.txt
+++ b/test-requirements.txt
@@ -2,7 +2,7 @@ flake8
 flake8-bugbear; python_version >= '3.5'
 flake8-pyi; python_version >= '3.6'
 lxml; sys_platform != 'win32' or python_version == '3.5' or python_version == '3.6'
-typed-ast>=1.0.3,<1.1.0; sys_platform != 'win32' or python_version >= '3.5'
+typed-ast>=1.0.4,<1.1.0; sys_platform != 'win32' or python_version >= '3.5'
 pytest>=2.8
 pytest-xdist>=1.13
 pytest-cov>=2.4.0
