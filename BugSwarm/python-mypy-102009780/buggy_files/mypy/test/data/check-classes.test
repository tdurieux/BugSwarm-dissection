-- Methods
-- -------


[case testMethodCall]

a = None # type: A
b = None # type: B

a.foo(B())        # Fail
a.bar(B(), A())   # Fail

a.foo(A())
b.bar(B(), A())

class A:
    def foo(self, x: 'A') -> None: pass
class B:
    def bar(self, x: 'B', y: A) -> None: pass
[out]
main:5: error: Argument 1 to "foo" of "A" has incompatible type "B"; expected "A"
main:6: error: "A" has no attribute "bar"

[case testMethodCallWithSubtype]

a = None # type: A
a.foo(A())
a.foo(B())
a.bar(A()) # Fail
a.bar(B())

class A:
    def foo(self, x: 'A') -> None: pass
    def bar(self, x: 'B') -> None: pass
class B(A): pass
[out]
main:5: error: Argument 1 to "bar" of "A" has incompatible type "A"; expected "B"

[case testInheritingMethod]

a = None # type: B
a.foo(A()) # Fail
a.foo(B())

class A:
    def foo(self, x: 'B') -> None: pass
class B(A): pass
[out]
main:3: error: Argument 1 to "foo" of "A" has incompatible type "A"; expected "B"

[case testMethodCallWithInvalidNumberOfArguments]

a = None # type: A
a.foo()               # Fail
a.foo(object(), A())  # Fail

class A:
    def foo(self, x: 'A') -> None: pass
[out]
main:3: error: Too few arguments for "foo" of "A"
main:4: error: Too many arguments for "foo" of "A"
main:4: error: Argument 1 to "foo" of "A" has incompatible type "object"; expected "A"

[case testMethodBody]
import typing
class A:
    def f(self) -> None:
        a = object() # type: A    # Fail
[out]
main: note: In member "f" of class "A":
main:4: error: Incompatible types in assignment (expression has type "object", variable has type "A")

[case testMethodArguments]
import typing
class A:
    def f(self, a: 'A', b: 'B') -> None:
        a = B() # Fail
        b = A() # Fail
        a = A()
        b = B()
        a = a
        a = b # Fail
class B: pass
[out]
main: note: In member "f" of class "A":
main:4: error: Incompatible types in assignment (expression has type "B", variable has type "A")
main:5: error: Incompatible types in assignment (expression has type "A", variable has type "B")
main:9: error: Incompatible types in assignment (expression has type "B", variable has type "A")

[case testReturnFromMethod]
import typing
class A:
    def f(self) -> 'A':
        return B() # Fail
        return A()
class B: pass
[out]
main: note: In member "f" of class "A":
main:4: error: Incompatible return value type: expected __main__.A, got __main__.B

[case testSelfArgument]
import typing
class A:
    def f(self) -> None:
        o = self # type: B    # Fail
        self.g()      # Fail
        a = self # type: A
        self.f()
class B: pass
[out]
main: note: In member "f" of class "A":
main:4: error: Incompatible types in assignment (expression has type "A", variable has type "B")
main:5: error: "A" has no attribute "g"

[case testAssignToMethodViaInstance]
import typing
class A:
    def f(self): pass
A().f = None # E: Cannot assign to a method


-- Attributes
-- ----------


[case testReferToInvalidAttribute]

class A:
    def __init__(self):
        self.x = object()
a = None # type: A
a.y
a.y = object()
a.x
a.x = object()
[out]
main:6: error: "A" has no attribute "y"
main:7: error: "A" has no attribute "y"

[case testArgumentTypeInference]

class A:
    def __init__(self, aa: 'A', bb: 'B') -> None:
        self.a = aa
        self.b = bb
class B: pass
a = None # type: A
b = None # type: B
a.a = b # Fail
a.b = a # Fail
b.a     # Fail
a.a = a
a.b = b
[out]
main:9: error: Incompatible types in assignment (expression has type "B", variable has type "A")
main:10: error: Incompatible types in assignment (expression has type "A", variable has type "B")
main:11: error: "B" has no attribute "a"

[case testExplicitAttributeInBody]

a = None # type: A
a.x = object() # Fail
a.x = A()
class A:
  x = None # type: A
[out]
main:3: error: Incompatible types in assignment (expression has type "object", variable has type "A")

[case testAttributeDefinedInNonInitMethod]
import typing
class A:
    def f(self) -> None:
        self.x = 1
        self.y = ''
        self.x = 1
a = A()
a.x = 1
a.y = ''
a.x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
a.z = 0  # E: "A" has no attribute "z"

[case testInheritanceAndAttributeAssignment]
import typing
class A:
    def f(self) -> None:
        self.x = 0
class B(A):
    def f(self) -> None:
        self.x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
[out]
main: note: In member "f" of class "B":

[case testAssignmentToAttributeInMultipleMethods]
import typing
class A:
    def f(self) -> None:
        self.x = 0
    def g(self) -> None:
        self.x = '' # Fail
    def __init__(self) -> None:
        self.x = '' # Fail
[out]
main: note: In member "g" of class "A":
main:6: error: Incompatible types in assignment (expression has type "str", variable has type "int")
main: note: In member "__init__" of class "A":
main:8: error: Incompatible types in assignment (expression has type "str", variable has type "int")


-- Method overriding
-- -----------------


[case testMethodOverridingWithIdenticalSignature]
import typing
class A:
    def f(self, x: 'A') -> None: pass
    def g(self, x: 'B' , y: object) -> 'A': pass
    def h(self) -> None: pass
class B(A):
    def f(self, x: A) -> None: pass
    def g(self, x: 'B' , y: object) -> A: pass
    def h(self) -> None: pass
[out]

[case testMethodOverridingWithCovariantType]
import typing
class A:
  def f(self, x: 'A', y: 'B') -> 'A': pass
  def g(self, x: 'A', y: 'B') -> 'A': pass
class B(A):
  def f(self, x: A, y: 'B') -> 'B': pass
  def g(self, x: A, y: A) -> 'A': pass
[out]

[case testMethodOverridingWithIncompatibleTypes]
import typing
class A:
  def f(self, x: 'A', y: 'B') -> 'A': pass
  def g(self, x: 'A', y: 'B') -> 'A': pass
  def h(self, x: 'A', y: 'B') -> 'A': pass
class B(A):
  def f(self, x: 'B', y: 'B') -> A: pass  # Fail
  def g(self, x: A, y: A) -> A: pass
  def h(self, x: A, y: 'B') -> object: pass  # Fail
[out]
main: note: In class "B":
main:7: error: Argument 1 of "f" incompatible with supertype "A"
main:9: error: Return type of "h" incompatible with supertype "A"

[case testMethodOverridingWithIncompatibleArgumentCount]
import typing
class A:
    def f(self, x: 'A') -> None: pass
    def g(self, x: 'A', y: 'B') -> 'A': pass
class B(A):
    def f(self, x: A, y: A) -> None: pass # Fail
    def g(self, x: A) -> A: pass # Fail
[out]
main: note: In class "B":
main:6: error: Signature of "f" incompatible with supertype "A"
main:7: error: Signature of "g" incompatible with supertype "A"

[case testMethodOverridingAcrossDeepInheritanceHierarchy1]
import typing
class A:
    def f(self, x: 'B') -> None: pass
class B(A): pass
class C(B): # with gap in implementations
    def f(self, x: 'C') -> None:  # Fail
        pass
[out]
main: note: In class "C":
main:6: error: Argument 1 of "f" incompatible with supertype "A"

[case testMethodOverridingAcrossDeepInheritanceHierarchy2]
import typing
class A:
    def f(self) -> 'B': pass
class B(A):
    def f(self) -> 'C': pass
class C(B): # with multiple implementations
    def f(self) -> B:  # Fail
        pass
[out]
main: note: In class "C":
main:7: error: Return type of "f" incompatible with supertype "B"

[case testMethodOverridingWithVoidReturnValue]
import typing
class A:
    def f(self) -> None: pass
    def g(self) -> 'A': pass
class B(A):
    def f(self) -> A: pass  # Fail
    def g(self) -> None: pass  # Fail
[out]
main: note: In class "B":
main:6: error: Return type of "f" incompatible with supertype "A"
main:7: error: Return type of "g" incompatible with supertype "A"

[case testOverride__new__WithDifferentSignature]
class A:
    def __new__(cls, x: int) -> str:
        return ''

class B(A):
    def __new__(cls) -> int:
        return 1


-- Constructors
-- ------------


[case testTrivialConstructor]
import typing
a = A() # type: A
b = A() # type: B # Fail
class A:
    def __init__(self) -> None: pass
class B: pass
[out]
main:3: error: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testConstructor]
import typing
a = A(B()) # type: A
aa = A(object()) # type: A  # Fail
b = A(B()) # type: B       # Fail
class A:
    def __init__(self, x: 'B') -> None: pass
class B: pass
[out]
main:3: error: Argument 1 to "A" has incompatible type "object"; expected "B"
main:4: error: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testConstructorWithTwoArguments]
import typing
a = A(C(), B()) # type: A  # Fail

class A:
    def __init__(self, x: 'B', y: 'C') -> None: pass
class B: pass
class C(B): pass
[out]
main:2: error: Argument 2 to "A" has incompatible type "B"; expected "C"

[case testInheritedConstructor]
import typing
b = B(C()) # type: B
a = B(D()) # type: A # Fail
class A:
    def __init__(self, x: 'C') -> None: pass
class B(A): pass
class C: pass
class D: pass
[out]
main:3: error: Argument 1 to "B" has incompatible type "D"; expected "C"

[case testOverridingWithIncompatibleConstructor]
import typing
A()    # Fail
B(C()) # Fail
A(C())
B()
class A:
    def __init__(self, x: 'C') -> None: pass
class B(A):
    def __init__(self) -> None: pass
class C: pass
[out]
main:2: error: Too few arguments for "A"
main:3: error: Too many arguments for "B"

[case testConstructorWithReturnValueType]
import typing
class A:
    def __init__(self) -> 'A': pass
[out]
main: note: In member "__init__" of class "A":
main:3: error: The return type of "__init__" must be None

[case testConstructorWithImplicitReturnValueType]
import typing
class A:
    def __init__(self, x: int): pass
[out]
main: note: In member "__init__" of class "A":
main:3: error: The return type of "__init__" must be None

[case testGlobalFunctionInitWithReturnType]
import typing
a = __init__() # type: A
b = __init__() # type: B # Fail
def __init__() -> 'A': pass
class A: pass
class B: pass
[out]
main:3: error: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testAccessingInit]
from typing import Any
class A:
    def __init__(self, a: 'A') -> None: pass
a = None # type: A
a.__init__(a)  # E: Cannot access "__init__" directly
(Any(a)).__init__(a)

[case testDeepInheritanceHierarchy]
import typing
d = C() # type: D  # Fail
d = B()      # Fail
d = A()      # Fail
d = D2()     # Fail
a = D() # type: A
a = D2()
b = D() # type: B
b = D2()

class A: pass
class B(A): pass
class C(B): pass
class D(C): pass
class D2(C): pass
[out]
main:2: error: Incompatible types in assignment (expression has type "C", variable has type "D")
main:3: error: Incompatible types in assignment (expression has type "B", variable has type "D")
main:4: error: Incompatible types in assignment (expression has type "A", variable has type "D")
main:5: error: Incompatible types in assignment (expression has type "D2", variable has type "D")


-- Attribute access in class body
-- ------------------------------


[case testDataAttributeRefInClassBody]
import typing
class B: pass
class A:
    x = B()
    y = x
    b = x # type: B
    b = x
    c = x # type: A # E: Incompatible types in assignment (expression has type "B", variable has type "A")
    c = b   # E: Incompatible types in assignment (expression has type "B", variable has type "A")
[out]
main: note: In class "A":

[case testMethodRefInClassBody]
from typing import Callable
class B: pass
class A:
    def f(self) -> None: pass
    g = f
    h = f # type: Callable[[A], None]
    h = f
    g = h
    ff = f # type: Callable[[B], None]  # E: Incompatible types in assignment (expression has type Callable[[A], None], variable has type Callable[[B], None])
    g = ff                # E: Incompatible types in assignment (expression has type Callable[[B], None], variable has type Callable[[A], None])
[out]
main: note: In class "A":


-- Arbitrary statements in class body
-- ----------------------------------


[case testStatementsInClassBody]
import typing
class B: pass
class A:
    for x in [A()]:
        y = x
        y = B() # E: Incompatible types in assignment (expression has type "B", variable has type "A")
    x = A()
    y = A()
    x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "A")
[builtins fixtures/for.py]
[out]
main: note: In class "A":


-- Class attributes
-- ----------------


[case testAccessMethodViaClass]
import typing
class A:
    def f(self) -> None: pass
A.f(A())
A.f(object())     # E: Argument 1 to "f" of "A" has incompatible type "object"; expected "A"
A.f()             # E: Too few arguments for "f" of "A"
A.f(None, None)   # E: Too many arguments for "f" of "A"

[case testAccessAttributeViaClass]
import typing
class B: pass
class A:
    x = None # type: A
a = A.x # type: A
b = A.x # type: B # E: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testAccessingUndefinedAttributeViaClass]
import typing
class A: pass
A.x # E: "A" has no attribute "x"

[case testAccessingUndefinedAttributeViaClassWithOverloadedInit]
from typing import overload
class A:
    @overload
    def __init__(self): pass
    @overload
    def __init__(self, x): pass
A.x # E: "A" has no attribute "x"

[case testAccessMethodOfClassWithOverloadedInit]
from typing import overload, Any
class A:
    @overload
    def __init__(self) -> None: pass
    @overload
    def __init__(self, x: Any) -> None: pass
    def f(self) -> None: pass
A.f(A())
A.f()    # E: Too few arguments for "f" of "A"

[case testAssignmentToClassDataAttribute]
import typing
class B: pass
class A:
    x = None # type: B
A.x = B()
A.x = object()  # E: Incompatible types in assignment (expression has type "object", variable has type "B")

[case testAssignmentToInferredClassDataAttribute]
import typing
class B: pass
class A:
     x = B()
A.x = B()
A.x = A()   # E: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testInitMethodUnbound]

class B: pass
class A:
    def __init__(self, b: B) -> None: pass
a = None # type: A
b = None # type: B
A.__init__(a, b)
A.__init__(b, b) # E: Argument 1 to "__init__" of "A" has incompatible type "B"; expected "A"
A.__init__(a, a) # E: Argument 2 to "__init__" of "A" has incompatible type "A"; expected "B"

[case testAssignToMethodViaClass]
import typing
class A:
    def f(self): pass
A.f = None # E: Cannot assign to a method

[case testAssignToNestedClassViaClass]
import typing
class A:
    class B: pass
A.B = None # E: Cannot assign to a type

[case testAccessingClassAttributeWithTypeInferenceIssue]
x = C.x # E: Cannot determine type of 'x'
class C:
    x = 1
[builtins fixtures/list.py]

[case testAccessingClassAttributeWithTypeInferenceIssue2]
class C:
    x = []
x = C.x
[builtins fixtures/list.py]
[out]
main: note: In class "C":
main:2: error: Need type annotation for variable


-- Nested classes
-- --------------


[case testClassWithinFunction]

def f() -> None:
    class A:
        def g(self) -> None: pass
    a = None # type: A
    a.g()
    a.g(a) # E: Too many arguments for "g" of "A"
[out]
main: note: In function "f":

[case testConstructNestedClass]
import typing
class A:
    class B: pass
    b = B()
    b = A() # E: Incompatible types in assignment (expression has type "A", variable has type "B")
    b = B(b) # E: Too many arguments for "B"
[out]
main: note: In class "A":

[case testConstructNestedClassWithCustomInit]
import typing
class A:
    def f(self) -> None:
        class B:
            def __init__(self, a: 'A') -> None: pass
        b = B(A())
        b = A() # E: Incompatible types in assignment (expression has type "A", variable has type "B")
        b = B() # E: Too few arguments for "B"
[out]
main: note: In member "f" of class "A":

[case testDeclareVariableWithNestedClassType]

def f() -> None:
    class A: pass
    a = None # type: A
    a = A()
    a = object() # E: Incompatible types in assignment (expression has type "object", variable has type "A")
[out]
main: note: In function "f":

[case testExternalReferenceToClassWithinClass]

class A:
    class B: pass
b = None # type: A.B
b = A.B()
b = A() # E: Incompatible types in assignment (expression has type "A", variable has type "B")
b = A.B(b) # E: Too many arguments for "B"


-- Declaring attribute type in method
-- ----------------------------------


[case testDeclareAttributeTypeInInit]

class A:
    def __init__(self):
        self.x = None # type: int
a = None # type: A
a.x = 1
a.x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testAccessAttributeDeclaredInInitBeforeDeclaration]

a = None # type: A
a.x = 1
a.x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
class A:
    def __init__(self):
        self.x = None # type: int


-- Special cases
-- -------------


[case testMultipleClassDefinition]
import typing
A()
class A: pass
class A: pass
[out]
main:4: error: Name 'A' already defined

[case testDocstringInClass]
import typing
class A:
    """Foo"""
class B:
    'x'
    y = B()
[builtins fixtures/primitives.py]

[case testErrorMessageInFunctionNestedWithinMethod]
import typing
class A:
    def f(self) -> None:
        def g() -> None:
            a = None
        b = None
[out]
main: note: In function "g":
main:5: error: Need type annotation for variable
main: note: In member "f" of class "A":
main:6: error: Need type annotation for variable


-- Static methods
-- --------------


[case testSimpleStaticMethod]
import typing
class A:
  @staticmethod
  def f(x: int) -> None: pass
A.f(1)
A().f(1)
A.f('') # E: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"
A().f('') # E: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"
[builtins fixtures/staticmethod.py]

[case testBuiltinStaticMethod]
import typing
int.from_bytes(b'', '')
int.from_bytes('', '') # E: Argument 1 to "from_bytes" of "int" has incompatible type "str"; expected "bytes"
[builtins fixtures/staticmethod.py]

[case testAssignStaticMethodOnInstance]
import typing
class A:
  @staticmethod
  def f(x: int) -> None: pass
A().f = A.f # E: Cannot assign to a method
[builtins fixtures/staticmethod.py]


-- Class methods
-- -------------


[case testSimpleClassMethod]
import typing
class A:
  @classmethod
  def f(cls, x: int) -> None: pass
A.f(1)
A().f(1)
A.f('') # E: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"
A().f('') # E: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"
[builtins fixtures/classmethod.py]

[case testBuiltinClassMethod]
import typing
int.from_bytes(b'', '')
int.from_bytes('', '') # E: Argument 1 to "from_bytes" of "int" has incompatible type "str"; expected "bytes"
[builtins fixtures/classmethod.py]

[case testAssignClassMethodOnClass]
import typing
class A:
  @classmethod
  def f(cls, x: int) -> None: pass
A.f = A.f # E: Cannot assign to a method
[builtins fixtures/classmethod.py]

[case testAssignClassMethodOnInstance]
import typing
class A:
  @classmethod
  def f(cls, x: int) -> None: pass
A().f = A.f # E: Cannot assign to a method
[builtins fixtures/classmethod.py]


-- Properties
-- ----------


[case testAccessingReadOnlyProperty]
import typing
class A:
    @property
    def f(self) -> str: pass
a = A() # type. A
s = ''  # type: str
s = a.f
a = a.f  # E: Incompatible types in assignment (expression has type "str", variable has type "A")
[builtins fixtures/property.py]

[case testAssigningToReadOnlyProperty]
import typing
class A:
    @property
    def f(self) -> str: pass
A().f = '' # E: Property "f" defined in "A" is read-only
[builtins fixtures/property.py]

[case testPropertyGetterBody]
import typing
class A:
    @property
    def f(self) -> str:
        self.x = 1
        self.x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
[builtins fixtures/property.py]
[out]
main: note: In member "f" of class "A":

[case testDynamicallyTypedProperty]
import typing
class A:
    @property
    def f(self): pass
a = A() # type. A
a.f.xx
a.f = '' # E: Property "f" defined in "A" is read-only
[builtins fixtures/property.py]

[case testPropertyWithSetter]
import typing
class A:
    @property
    def f(self) -> int:
        return 1
    @f.setter
    def f(self, x: int) -> None:
        pass
a = A()
a.f = a.f
a.f.x # E: "int" has no attribute "x"
a.f = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
[builtins fixtures/property.py]

[case testPropertyWithDeleterButNoSetter]
import typing
class A:
    @property
    def f(self) -> int:
        return 1
    @f.deleter
    def f(self, x) -> None:
        pass
a = A()
a.f = a.f # E: Property "f" defined in "A" is read-only
a.f.x # E: "int" has no attribute "x"
[builtins fixtures/property.py]


-- Multiple inheritance, non-object built-in class as base
-- -------------------------------------------------------


[case testInvalidMultipleInheritanceFromBuiltins-skip]
import typing
class A(int, str): pass # E: Instance layout conflict in multiple inheritance
[out]
main: note: In class "A":

[case testInvalidMultipleInheritanceFromBuiltins-skip]
import typing
class S(str): pass
class A(S, str): pass
class B(S, int): pass # E: Instance layout conflict in multiple inheritance
[out]
main: note: In class "B":


-- _promote decorators
-- -------------------


[case testSimpleDucktypeDecorator]
from typing import _promote
class A: pass
@_promote(A)
class B: pass
a = None  # type: A
b = None  # type: B
b = a # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a = b

[case testDucktypeTransitivityDecorator]
from typing import _promote
class A: pass
@_promote(A)
class B: pass
@_promote(B)
class C: pass
a = None  # type: A
c = None  # type: C
c = a # E: Incompatible types in assignment (expression has type "A", variable has type "C")
a = c


-- Hard coded type promotions
-- --------------------------

[case testHardCodedTypePromotions]
import typing
def f(x: float) -> None: pass
def g(x: complex) -> None: pass
f(1)
g(1)
g(1.1)
[builtins fixtures/complex.py]


-- Operator methods
-- ----------------


[case testOperatorMethodOverrideIntroducingOverloading]
from typing import overload
class A:
    def __add__(self, x: int) -> int: pass
class B(A):
    @overload  # E: Signature of "__add__" incompatible with supertype "A"
    def __add__(self, x: int) -> int: pass
    @overload
    def __add__(self, x: str) -> str: pass
[out]
main: note: In class "B":

[case testOperatorMethodOverrideWideningArgumentType]
import typing
class A:
    def __add__(self, x: int) -> int: pass
class B(A):
    def __add__(self, x: object) -> int: pass
[out]

[case testOperatorMethodOverrideNarrowingReturnType]
import typing
class A:
    def __add__(self, x: int) -> 'A': pass
class B(A):
    def __add__(self, x: int) -> 'B': pass

[case testOperatorMethodOverrideWithDynamicallyTyped]
import typing
class A:
    def __add__(self, x: int) -> 'A': pass
class B(A):
    def __add__(self, x): pass

[case testOperatorMethodOverrideWithIdenticalOverloadedType]
from typing import overload
class A:
    @overload
    def __add__(self, x: int) -> 'A': pass
    @overload
    def __add__(self, x: str) -> 'A': pass
class B(A):
    @overload
    def __add__(self, x: int) -> 'A': pass
    @overload
    def __add__(self, x: str) -> 'A': pass

[case testOverloadedOperatorMethodOverrideWithDynamicallyTypedMethod]
from typing import overload, Any
class A:
    @overload
    def __add__(self, x: int) -> 'A': pass
    @overload
    def __add__(self, x: str) -> 'A': pass
class B(A):
    def __add__(self, x): pass
class C(A):
    def __add__(self, x: Any) -> A: pass

[case testOverloadedOperatorMethodOverrideWithNewItem]
from typing import overload, Any
class A:
    @overload
    def __add__(self, x: int) -> 'A': pass
    @overload
    def __add__(self, x: str) -> 'A': pass
class B(A):
    @overload
    def __add__(self, x: int) -> A: pass
    @overload
    def __add__(self, x: str) -> A: pass
    @overload
    def __add__(self, x: type) -> A: pass
[out]
main: note: In class "B":
main:8: error: Signature of "__add__" incompatible with supertype "A"

[case testOverloadedOperatorMethodOverrideWithSwitchedItemOrder]
from typing import overload, Any
class A:
    @overload
    def __add__(self, x: 'B') -> 'B': pass
    @overload
    def __add__(self, x: 'A') -> 'A': pass
class B(A):
    @overload
    def __add__(self, x: 'A') -> 'A': pass
    @overload
    def __add__(self, x: 'B') -> 'B': pass
[out]
main: note: In class "B":
main:8: error: Signature of "__add__" incompatible with supertype "A"

[case testReverseOperatorMethoddArgumentType]
from typing import Any
class A: pass
class B:
    def __radd__(self, x: A) -> int: pass # Error
class C:
    def __radd__(self, x: A) -> Any: pass
class D:
    def __radd__(self, x: A) -> object: pass
[out]

[case testReverseOperatorMethoddArgumentType2]
from typing import Any, Tuple, Callable
class A:
    def __radd__(self, x: Tuple[int, str]) -> int: pass
class B:
    def __radd__(self, x: Callable[[], int]) -> int: pass
class C:
    def __radd__(self, x: Any) -> int: pass
[out]

[case testReverseOperatorMethodForwardIsAny]
from typing import Any
def deco(f: Any) -> Any: return f
class C:
    @deco
    def __add__(self, other: C) -> C: return C()
    def __radd__(self, other: C) -> C: return C()
[out]

[case testReverseOperatorMethodForwardIsAny2]
from typing import Any
def deco(f: Any) -> Any: return f
class C:
    __add__ = None  # type: Any
    def __radd__(self, other: C) -> C: return C()
[out]

[case testReverseOperatorMethodForwardIsAny3]
from typing import Any
def deco(f: Any) -> Any: return f
class C:
    __add__ = 42
    def __radd__(self, other: C) -> C: return C()
[out]
main: note: In member "__radd__" of class "C":
main:5: error: Forward operator "__add__" is not callable

[case testOverloadedReverseOperatorMethodArgumentType]
from typing import overload, Any
class A:
    @overload
    def __radd__(self, x: 'A') -> str: pass # Error
    @overload
    def __radd__(self, x: 'A') -> Any: pass
[out]

[case testReverseOperatorMethodArgumentTypeAndOverloadedMethod]
from typing import overload
class A:
    @overload
    def __add__(self, x: int) -> int: pass
    @overload
    def __add__(self, x: str) -> int: pass
    def __radd__(self, x: 'A') -> str: pass

[case testAbstractReverseOperatorMethod]
import typing
from abc import abstractmethod
class A:
    @abstractmethod
    def __lt__(self, x: 'A') -> int: pass
class B:
    @abstractmethod
    def __lt__(self, x: 'B') -> int: pass
    @abstractmethod
    def __gt__(self, x: 'B') -> int: pass
[out]

[case testOperatorMethodsAndOverloadingSpecialCase]
from typing import overload
class A:
    @overload
    def __add__(self, x: 'A') -> int: pass
    @overload
    def __add__(self, x: str) -> int: pass
class B:
    def __radd__(self, x: 'A') -> str: pass
[out]

[case testUnsafeOverlappingWithOperatorMethodsAndOverloading2]
from typing import overload
class A:
    def __add__(self, x: 'A') -> int: pass
class B:
    @overload
    def __radd__(self, x: 'X') -> str: pass # Error
    @overload
    def __radd__(self, x: A) -> str: pass   # Error
class X:
    def __add__(self, x): pass
[out]
main: note: In member "__radd__" of class "B":
main:6: error: Signatures of "__radd__" of "B" and "__add__" of "X" are unsafely overlapping

[case testOverlappingNormalAndInplaceOperatorMethod]
import typing
class A:
    # Incompatible (potential trouble with __radd__)
    def __add__(self, x: 'A') -> int: pass
    def __iadd__(self, x: 'B') -> int: pass
class B:
    # Safe
    def __add__(self, x: 'C') -> int: pass
    def __iadd__(self, x: A) -> int: pass
class C(A): pass
[out]
main: note: In class "A":
main:5: error: Signatures of "__iadd__" and "__add__" are incompatible

[case testOverloadedNormalAndInplaceOperatorMethod]
from typing import overload
class A:
    @overload
    def __add__(self, x: int) -> int: pass
    @overload
    def __add__(self, x: str) -> int: pass
    @overload # Error
    def __iadd__(self, x: int) -> int: pass
    @overload
    def __iadd__(self, x: object) -> int: pass
class B:
    @overload
    def __add__(self, x: int) -> int: pass
    @overload
    def __add__(self, x: str) -> str: pass
    @overload
    def __iadd__(self, x: int) -> int: pass
    @overload
    def __iadd__(self, x: str) -> str: pass
[out]
main: note: In class "A":
main:7: error: Signatures of "__iadd__" and "__add__" are incompatible

[case testIntroducingInplaceOperatorInSubclass]
import typing
class A:
    def __add__(self, x: 'A') -> 'B': pass
class B(A):
    # __iadd__ effectively partially overrides __add__
    def __iadd__(self, x: 'A') -> 'A': pass # Error
class C(A):
    def __iadd__(self, x: int) -> 'B': pass # Error
class D(A):
    def __iadd__(self, x: 'A') -> 'B': pass
[out]
main: note: In class "B":
main:6: error: Return type of "__iadd__" incompatible with "__add__" of supertype "A"
main: note: In class "C":
main:8: error: Argument 1 of "__iadd__" incompatible with "__add__" of supertype "A"
main:8: error: Signatures of "__iadd__" and "__add__" are incompatible


[case testGetAttr]

a, b = None, None # type: A, B
class A:
    def __getattr__(self, x: str) -> A:
        return A()
class B: pass

a = a.foo
b = a.bar
[out]
main:9: error: Incompatible types in assignment (expression has type "A", variable has type "B")


[case testGetAttrSignature]
class A:
    def __getattr__(self, x: str) -> A: pass
class B:
    def __getattr__(self, x: A) -> B: pass
class C:
    def __getattr__(self, x: str, y: str) -> C: pass
class D:
    def __getattr__(self, x: str) -> None: pass
[out]
main: note: In member "__getattr__" of class "B":
main:4: error: Invalid signature "def (self: __main__.B, x: __main__.A) -> __main__.B"
main: note: In member "__getattr__" of class "C":
main:6: error: Invalid signature "def (self: __main__.C, x: builtins.str, y: builtins.str) -> __main__.C"


-- CallableType objects
-- ----------------


[case testCallableObject]
import typing
a = A()
b = B()

a()  # E: Too few arguments for "__call__" of "A"
a(a, a)  # E: Too many arguments for "__call__" of "A"
a = a(a)
a = a(b)  # E: Argument 1 to "__call__" of "A" has incompatible type "B"; expected "A"
b = a(a)  # E: Incompatible types in assignment (expression has type "A", variable has type "B")

class A:
    def __call__(self, x: A) -> A:
        pass
class B: pass


-- __new__
-- --------


[case testConstructInstanceWith__new__]
class C:
    def __new__(cls, foo: int = None) -> 'C':
        obj = object.__new__(cls)
        return obj

x = C(foo=12)
x.a # E: "C" has no attribute "a"
C(foo='') # E: Argument 1 to "C" has incompatible type "str"; expected "int"
[builtins fixtures/__new__.py]

[case testConstructInstanceWithDynamicallyTyped__new__]
class C:
    def __new__(cls, foo):
        obj = object.__new__(cls)
        return obj

x = C(foo=12)
x = C(foo='x')
x.a # E: "C" has no attribute "a"
C(bar='') # E: Unexpected keyword argument "bar" for "C"
[builtins fixtures/__new__.py]

[case testClassWith__new__AndCompatibilityWithType]
class C:
    def __new__(cls, foo: int = None) -> 'C':
        obj = object.__new__(cls)
        return obj
def f(x: type) -> None: pass
def g(x: int) -> None: pass
f(C)
g(C) # E: Argument 1 to "g" has incompatible type "C"; expected "int"
[builtins fixtures/__new__.py]

[case testClassWith__new__AndCompatibilityWithType2]
class C:
    def __new__(cls, foo):
        obj = object.__new__(cls)
        return obj
def f(x: type) -> None: pass
def g(x: int) -> None: pass
f(C)
g(C) # E: Argument 1 to "g" has incompatible type "C"; expected "int"
[builtins fixtures/__new__.py]

[case testGenericClassWith__new__]
from typing import TypeVar, Generic
T = TypeVar('T')
class C(Generic[T]):
    def __new__(cls, foo: T) -> 'C[T]':
        obj = object.__new__(cls)
        return obj
    def set(self, x: T) -> None: pass
c = C('')
c.set('')
c.set(1) # E: Argument 1 to "set" of "C" has incompatible type "int"; expected "str"
[builtins fixtures/__new__.py]

[case testOverloaded__new__]
from typing import overload
class C:
    @overload
    def __new__(cls, foo: int) -> 'C':
        obj = object.__new__(cls)
        return obj
    @overload
    def __new__(cls, x: str, y: str) -> 'C':
        obj = object.__new__(cls)
        return obj
c = C(1)
c.a # E: "C" has no attribute "a"
C('', '')
C('') # E: No overload variant of "C" matches argument types [builtins.str]
[builtins fixtures/__new__.py]


-- Special cases
-- -------------


[case testSubclassInt]
import typing
class A(int): pass
n = 0
n = A()
a = A()
a = 0 # E: Incompatible types in assignment (expression has type "int", variable has type "A")

[case testForwardReferenceToNestedClass]
def f(o: 'B.C') -> None:
    o.f('') # E: Argument 1 to "f" of "C" has incompatible type "str"; expected "int"

class B:
    class C:
        def f(self, x: int) -> None: pass
[out]
main: note: In function "f":

[case testForwardReferenceToNestedClassDeep]
def f(o: 'B.C.D') -> None:
    o.f('') # E: Argument 1 to "f" of "D" has incompatible type "str"; expected "int"

class B:
    class C:
        class D:
            def f(self, x: int) -> None: pass
[out]
main: note: In function "f":

[case testForwardReferenceToNestedClassWithinClass]
class B:
    def f(self, o: 'C.D') -> None:
        o.f('') # E: Argument 1 to "f" of "D" has incompatible type "str"; expected "int"

    class C:
        class D:
            def f(self, x: int) -> None: pass
[out]
main: note: In member "f" of class "B":

[case testClassVsInstanceDisambiguation]
class A: pass
def f(x: A) -> None: pass
f(A) # E: Argument 1 to "f" has incompatible type "A" (type object); expected "A"
[out]

-- TODO
--   attribute inherited from superclass; assign in __init__
--   refer to attribute before type has been inferred (the initialization in
--   __init__ has not been analyzed)
