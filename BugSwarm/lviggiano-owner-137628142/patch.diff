diff --git a/owner-assembly/pom.xml b/owner-assembly/pom.xml
index de3893569a..cd2d338e91 100755
--- a/owner-assembly/pom.xml
+++ b/owner-assembly/pom.xml
@@ -28,7 +28,7 @@
             <dependencies>
                 <dependency>
                     <groupId>org.aeonbits.owner</groupId>
-                    <artifactId>owner-java8</artifactId>
+                    <artifactId>owner-java8-extras</artifactId>
                     <version>1.0.10-SNAPSHOT</version>
                 </dependency>
             </dependencies>
diff --git a/owner-assembly/src/main/assemblies/bin.xml b/owner-assembly/src/main/assemblies/bin.xml
index a1f2461b7b..87d5369484 100755
--- a/owner-assembly/src/main/assemblies/bin.xml
+++ b/owner-assembly/src/main/assemblies/bin.xml
@@ -51,6 +51,13 @@
                 <include>*.jar</include>
             </includes>
         </fileSet>
+        <fileSet>
+            <directory>${project.parent.basedir}/owner-java8-extras/target</directory>
+            <outputDirectory>/</outputDirectory>
+            <includes>
+                <include>*.jar</include>
+            </includes>
+        </fileSet>
         <fileSet>
             <directory>${project.parent.basedir}/owner-examples</directory>
             <outputDirectory>/examples</outputDirectory>
diff --git a/owner-extras/pom.xml b/owner-extras/pom.xml
index ed5fb21106..e190883b85 100755
--- a/owner-extras/pom.xml
+++ b/owner-extras/pom.xml
@@ -15,9 +15,9 @@
         <version>1.0.10-SNAPSHOT</version>
     </parent>
 
-    <name>OWNER :: Third Party Extras</name>
+    <name>OWNER :: Extras</name>
     <artifactId>owner-extras</artifactId>
-    <description>Third Party Extras for OWNER library</description>
+    <description>Extras for OWNER library</description>
     <packaging>jar</packaging>
 
     <dependencies>
diff --git a/owner-java8-extras/pom.xml b/owner-java8-extras/pom.xml
new file mode 100755
index 0000000000..42bd1b7254
--- /dev/null
+++ b/owner-java8-extras/pom.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright (c) 2012-2015, Luigi R. Viggiano
+  ~ All rights reserved.
+  ~
+  ~ This software is distributable under the BSD license.
+  ~ See the terms of the BSD license in the documentation provided with this software.
+  -->
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <artifactId>owner-parent</artifactId>
+        <groupId>org.aeonbits.owner</groupId>
+        <version>1.0.10-SNAPSHOT</version>
+    </parent>
+
+    <groupId>org.aeonbits.owner</groupId>
+    <artifactId>owner-java8-extras</artifactId>
+    <name>OWNER :: Java 8 Extras</name>
+    <version>1.0.10-SNAPSHOT</version>
+    <packaging>jar</packaging>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                </configuration>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-source-plugin</artifactId>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-javadoc-plugin</artifactId>
+            </plugin>
+            <plugin>
+                <groupId>org.eluder.coveralls</groupId>
+                <artifactId>coveralls-maven-plugin</artifactId>
+            </plugin>
+            <plugin>
+                <groupId>org.codehaus.mojo</groupId>
+                <artifactId>cobertura-maven-plugin</artifactId>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.aeonbits.owner</groupId>
+            <artifactId>owner-java8</artifactId>
+            <version>1.0.10-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+        </dependency>
+    </dependencies>
+
+</project>
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ByteSizeConverter.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ByteSizeConverter.java
new file mode 100755
index 0000000000..54cbaf566d
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ByteSizeConverter.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.converters;
+
+import org.aeonbits.owner.util.bytesize.ByteSize;
+import org.aeonbits.owner.util.bytesize.ByteSizeUnit;
+import org.aeonbits.owner.Converter;
+
+import java.lang.reflect.Method;
+import java.math.BigDecimal;
+
+/**
+ * @author Stefan Freyr Stefansson
+ */
+public class ByteSizeConverter implements Converter<ByteSize> {
+
+    public ByteSize convert(Method method, String input) {
+        return parse(input);
+    }
+
+    private static ByteSize parse(String input){
+        String[] parts = ConverterUtil.splitNumericAndChar(input);
+        String value = parts[0];
+        String unit = parts[1];
+
+        BigDecimal bdValue = new BigDecimal(value);
+        ByteSizeUnit bsuUnit = ByteSizeUnit.parse(unit);
+
+        if (bsuUnit == null){
+            throw new IllegalArgumentException("Invalid unit string: '" + unit + "'");
+        }
+
+        return new ByteSize(bdValue, bsuUnit);
+    }
+}
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ConverterUtil.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ConverterUtil.java
new file mode 100755
index 0000000000..f310c745af
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/ConverterUtil.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.converters;
+
+/**
+ * A utility class for converters.
+ *
+ * @author Stefan Freyr Stefansson
+ */
+class ConverterUtil {
+    /**
+     * Splits a string into a numeric part and a character part. The input string should conform to the format
+     * <code>[numeric_part][char_part]</code> with an optional whitespace between the two parts.
+     *
+     * The <code>char_part</code> should only contain letters as defined by {@link Character#isLetter(char)} while
+     * the <code>numeric_part</code> will be parsed regardless of content.
+     *
+     * Any whitespace will be trimmed from the beginning and end of both parts, however, the <code>numeric_part</code>
+     * can contain whitespaces within it.
+     *
+     * @param input the string to split.
+     *
+     * @return an array of two strings.
+     */
+    static String[] splitNumericAndChar(String input){
+        // ATTN: String.trim() may not trim all UTF-8 whitespace characters properly.
+        // The original implementation used its own unicodeTrim() method that I decided not to include until the need
+        // arises. For more information, see:
+        // https://github.com/typesafehub/config/blob/v1.3.0/config/src/main/java/com/typesafe/config/impl/ConfigImplUtil.java#L118-L164
+
+        int i = input.length() - 1;
+        while (i >= 0) {
+            char c = input.charAt(i);
+            if (!Character.isLetter(c))
+                break;
+            i -= 1;
+        }
+        return new String[]{input.substring(0,i+1).trim(), input.substring(i + 1).trim()};
+    }
+
+}
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/DurationConverter.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/DurationConverter.java
new file mode 100755
index 0000000000..eaad2420e5
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/converters/DurationConverter.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.converters;
+
+import org.aeonbits.owner.Converter;
+
+import java.lang.reflect.Method;
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+
+/**
+ * A duration converter for the OWNER configuration system.
+ *
+ * This converter will convert various duration formatted strings over to {@link java.time.Duration} objects.
+ *
+ * The class supports two formats for the duration string:
+ * <ul>
+ *     <li>
+ *         The ISO-8601 based format that the {@link java.time.Duration#parse(CharSequence)} method supports
+ *         (<a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-"
+ *         target="_blank">see the official Java 8 documentation</a>, although note that currently there is an
+ *         <a href="https://bugs.openjdk.java.net/browse/JDK-8146173" target="_blank">error in the documentation</a>).
+ *         The implementation will check whether the input string starts with <code>P</code> with an optional plus/minus
+ *         prefix and if so, will use this method for parsing.
+ *     </li>
+ *     <li>
+ *         A "<code>value time_unit</code>" string where the <code>value</code> is an integer and <code>time_unit</code>
+ *         is one of:
+ *         <ul>
+ *             <li>ns / nanos / nanoseconds</li>
+ *             <li>us / µs / micros / microseconds</li>
+ *             <li>ms / millis / milliseconds</li>
+ *             <li>s / seconds</li>
+ *             <li>m / minutes</li>
+ *             <li>h / hours</li>
+ *             <li>d / days</li>
+ *         </ul>
+ *         <p>
+ *         Note that the <code>time_unit</code> string is case sensitive.
+ *         <p>
+ *         If no <code>time_unit</code> is specified, <code>milliseconds</code> is assumed.
+ *     </li>
+ * </ul>
+ */
+public class DurationConverter implements Converter<Duration> {
+
+    @Override
+    public Duration convert(Method method, String input) {
+        // If it looks like a string that Duration.parse can handle, let's try that.
+        if (input.startsWith("P") || input.startsWith("-P") || input.startsWith("+P")) {
+            return Duration.parse(input);
+        }
+        // ...otherwise we'll perform our own parsing
+        return parseDuration(input);
+    }
+
+    /**
+     * Parses a duration string. If no units are specified in the string, it is
+     * assumed to be in milliseconds.
+     *
+     * This implementation was blatantly stolen/adapted from the typesafe-config project:
+     * https://github.com/typesafehub/config/blob/v1.3.0/config/src/main/java/com/typesafe/config/impl/SimpleConfig.java#L551-L624
+     *
+     * @param input the string to parse
+     * @return duration
+     * @throws IllegalArgumentException if input is invalid
+     */
+    private static Duration parseDuration(String input) {
+        String[] parts = ConverterUtil.splitNumericAndChar(input);
+        String numberString = parts[0];
+        String originalUnitString = parts[1];
+        String unitString = originalUnitString;
+
+        if (numberString.length() == 0) {
+            throw new IllegalArgumentException(String.format("No number in duration value '%s'", input));
+        }
+
+        if (unitString.length() > 2 && !unitString.endsWith("s")) {
+            unitString = unitString + "s";
+        }
+
+        ChronoUnit units;
+        // note that this is deliberately case-sensitive
+        switch (unitString) {
+            case "ns":
+            case "nanos":
+            case "nanoseconds":
+                units = ChronoUnit.NANOS;
+                break;
+            case "us":
+            case "µs":
+            case "micros":
+            case "microseconds":
+                units = ChronoUnit.MICROS;
+                break;
+            case "":
+            case "ms":
+            case "millis":
+            case "milliseconds":
+                units = ChronoUnit.MILLIS;
+                break;
+            case "s":
+            case "seconds":
+                units = ChronoUnit.SECONDS;
+                break;
+            case "m":
+            case "minutes":
+                units = ChronoUnit.MINUTES;
+                break;
+            case "h":
+            case "hours":
+                units = ChronoUnit.HOURS;
+                break;
+            case "d":
+            case "days":
+                units = ChronoUnit.DAYS;
+                break;
+            default:
+                throw new IllegalArgumentException(
+                        String.format("Could not parse time unit '%s' (try ns, us, ms, s, m, h, d)", originalUnitString));
+        }
+
+        return Duration.of(Long.parseLong(numberString), units);
+    }
+
+    private static String getUnits(String s) {
+        int i = s.length() - 1;
+        while (i >= 0) {
+            char c = s.charAt(i);
+            if (!Character.isLetter(c))
+                break;
+            i -= 1;
+        }
+        return s.substring(i + 1);
+    }
+}
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSize.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSize.java
new file mode 100755
index 0000000000..9c16f1f769
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSize.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.util.bytesize;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.math.RoundingMode;
+
+/**
+ * A unit of byte size, such as "512 kilobytes".
+ *
+ * This class models a two part byte count size, one part being a value and the other part being a
+ * {@link ByteSizeUnit}.
+ *
+ * This class supports converting to another {@link ByteSizeUnit}.
+ *
+ * @author Stefan Freyr Stefansson
+ */
+public class ByteSize {
+    private final BigDecimal value;
+    private final ByteSizeUnit unit;
+
+    /**
+     * Creates a byte size value from two parts, a value and a {@link ByteSizeUnit}.
+     *
+     * @param value the value part of this byte size.
+     * @param unit the unit part of this byte size.
+     */
+    public ByteSize(BigDecimal value, ByteSizeUnit unit){
+        this.value = value;
+        this.unit = unit;
+    }
+
+    /**
+     * Creates a byte size value from a <code>long</code> value representing the number of bytes.
+     *
+     * The unit part of this byte size will be {@link ByteSizeUnit#BYTES}.
+     *
+     * @param bytes the number of bytes this {@link ByteSize} instance should represent
+     */
+    public ByteSize(long bytes){
+        this(bytes, ByteSizeUnit.BYTES);
+    }
+
+    /**
+     * Creates a byte size value from a <code>String</code> value and a {@link ByteSizeUnit}.
+     *
+     * @param value the value part of this byte size
+     * @param unit the unit part of this byte size
+     */
+    public ByteSize(String value, ByteSizeUnit unit){
+        this(new BigDecimal(value), unit);
+    }
+
+    /**
+     * Creates a byte size value from a <code>long</code> value and a {@link ByteSizeUnit}.
+     *
+     * @param value the value part of this byte size
+     * @param unit the unit part of this byte size
+     */
+    public ByteSize(long value, ByteSizeUnit unit){
+        this(BigDecimal.valueOf(value), unit);
+    }
+
+    /**
+     * Creates a byte size value from a <code>double</code> value and a {@link ByteSizeUnit}.
+     *
+     * @param value the value part of this byte size
+     * @param unit the unit part of this byte size
+     */
+    public ByteSize(double value, ByteSizeUnit unit){
+        this(BigDecimal.valueOf(value), unit);
+    }
+
+    /**
+     * Returns the number of bytes that this byte size represents after multiplying the unit factor with the value.
+     *
+     * Since the value part can be a represented by a decimal, there is some possibility of a rounding error. Therefore,
+     * the result of multiplying the value and the unit factor are always rounded towards positive infinity to the
+     * nearest integer value (see {@link RoundingMode#CEILING}) to make sure that this method never gives values that
+     * are too small.
+     *
+     * @return number of bytes this byte size represents after factoring in the unit.
+     */
+    public BigInteger getBytes(){
+        return value.multiply(unit.getFactor()).setScale(0, RoundingMode.CEILING).toBigIntegerExact();
+    }
+
+    /**
+     * Returns the number of bytes that this byte size represents as a <code>long</code> after multiplying the unit
+     * factor with the value, throwing an exception if the result overflows a <code>long</code>.
+     *
+     * @throws ArithmeticException if the result overflows a <code>long</code>
+     *
+     * @return the number of bytes that this byte size represents after factoring in the unit.
+     */
+    public long getBytesAsLong(){
+        return getBytes().longValueExact();
+    }
+
+    /**
+     * Returns the number of bytes that this byte size represents as an <code>int</code> after multiplying the unit
+     * factor with the value, throwing an exception if the result overflows an <code>int</code>.
+     *
+     * @throws ArithmeticException if the result overflows an <code>int</code>
+     *
+     * @return the number of bytes that this byte size represents after factoring in the unit.
+     */
+    public int getBytesAsInt() {
+        return getBytes().intValueExact();
+    }
+
+    /**
+     * Creates a new {@link ByteSize} representing the same byte size but in a different unit.
+     *
+     * Scale of the value (number of decimal points) is handled automatically but if a non-terminating decimal expansion
+     * occurs, an {@link ArithmeticException} is thrown.
+     *
+     * @param unit the unit for the new {@link ByteSize}.
+     *
+     * @throws ArithmeticException if a non-terminating decimal expansion occurs during calculation.
+     *
+     * @return a new {@link ByteSize} instance representing the same byte size as this but using the specified unit.
+     */
+    public ByteSize convertTo(ByteSizeUnit unit){
+        BigDecimal bytes = this.value.multiply(this.unit.getFactor()).setScale(0, RoundingMode.CEILING);
+        return new ByteSize(bytes.divide(unit.getFactor()), unit);
+    }
+
+    @Override
+    public String toString() {
+        return value.toString() + " " + unit.toStringShortForm();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ByteSize byteSize = (ByteSize) o;
+
+        return getBytes().equals(byteSize.getBytes());
+    }
+
+    @Override
+    public int hashCode() {
+        int result = value.hashCode();
+        result = 31 * result + unit.hashCode();
+        return result;
+    }
+}
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeStandard.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeStandard.java
new file mode 100755
index 0000000000..0320dd0c7b
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeStandard.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.util.bytesize;
+
+/**
+ * Represents the possible standards that a {@link ByteSizeUnit} can have. Different standards represent different
+ * "power of" values for which byte sizes are defined in.
+ *
+ * @see <a href="https://en.wikipedia.org/wiki/Binary_prefix">https://en.wikipedia.org/wiki/Binary_prefix</a>
+ *
+ * @author Stefan Freyr Stefansson
+ */
+public enum ByteSizeStandard {
+
+    /**
+     * The International System of Units (SI) standard. Base of 1000.
+     */
+    SI(1000),
+
+    /**
+     * The International Electrotechnical Commission (IEC) standard. Base of 1024.
+     */
+    IEC(1024);
+
+    final int powerOf;
+
+    ByteSizeStandard(int powerOf){
+        this.powerOf = powerOf;
+    }
+}
diff --git a/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeUnit.java b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeUnit.java
new file mode 100755
index 0000000000..d6cd1e1f10
--- /dev/null
+++ b/owner-java8-extras/src/main/java/org/aeonbits/owner/util/bytesize/ByteSizeUnit.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.util.bytesize;
+
+import java.math.BigDecimal;
+import java.util.HashMap;
+import java.util.Map;
+
+import static org.aeonbits.owner.util.bytesize.ByteSizeStandard.*;
+
+/**
+ * Specifies the available byte size units that a {@link ByteSize} can have.
+ *
+ * A byte size unit has a {@link ByteSizeStandard} that dictates the base value to be raised to a given power as well
+ * as the power value that dictates the magnitude of the unit. For example, a unit having the SI standard with a power
+ * value of 4 is known as a terabyte while a unit having the IEC standard with a power value of 4 is known as a
+ * tebibyte. The former has a factor of 1000^4 while the latter has a factor of 1024^4.
+ *
+ * @author Stefan Freyr Stefansson
+ */
+public enum ByteSizeUnit {
+    /**
+     * The base unit. Has a factor of 1.
+     */
+    BYTES("", "B", SI, 0),
+
+    /**
+     * The SI kilobyte. Has a factor of 1000^1.
+     */
+    KILOBYTES  ("kilo",  "KB",  SI, 1),
+    /**
+     * The IEC kibibyte. Has a factor of 1024^1.
+     */
+    KIBIBYTES  ("kibi",  "KiB", IEC, 1),
+    /**
+     * The SI megabyte. Has a factor of 1000^2.
+     */
+    MEGABYTES  ("mega",  "MB",  SI, 2),
+    /**
+     * The IEC mebibyte. Has a factor of 1024^2.
+     */
+    MEBIBYTES  ("mebi",  "MiB", IEC, 2),
+    /**
+     * The SI gigabyte. Has a factor of 1000^3.
+     */
+    GIGABYTES  ("giga",  "GB",  SI, 3),
+    /**
+     * The IEC gibibyte. Has a factor of 1024^3.
+     */
+    GIBIBYTES  ("gibi",  "GiB", IEC, 3),
+    /**
+     * The SI terabyte. Has a factor of 1000^4.
+     */
+    TERABYTES  ("tera",  "TB",  SI, 4),
+    /**
+     * The IEC tebibyte. Has a factor of 1024^4.
+     */
+    TEBIBYTES  ("tebi",  "TiB", IEC, 4),
+    /**
+     * The SI petabyte. Has a factor of 1000^5.
+     */
+    PETABYTES  ("peta",  "PB",  SI, 5),
+    /**
+     * The IEC pebibyte. Has a factor of 1024^5.
+     */
+    PEBIBYTES  ("pebi",  "PiB", IEC, 5),
+    /**
+     * The SI exabyte. Has a factor of 1000^6.
+     */
+    EXABYTES   ("exa",   "EB",  SI, 6),
+    /**
+     * The IEC exibyte. Has a factor of 1024^6.
+     */
+    EXBIBYTES  ("exbi",  "EiB", IEC, 6),
+    /**
+     * The SI zettabyte. Has a factor of 1000^7.
+     */
+    ZETTABYTES ("zetta", "ZB",  SI, 7),
+    /**
+     * The IEC zebibyte. Has a factor of 1024^7.
+     */
+    ZEBIBYTES  ("zebi",  "ZiB", IEC, 7),
+    /**
+     * The SI yottabyte. Has a factor of 1000^8.
+     */
+    YOTTABYTES ("yotta", "YB",  SI, 8),
+    /**
+     * The IEC yobibyte. Has a factor of 1024^8.
+     */
+    YOBIBYTES  ("yobi",  "YiB", IEC, 8);
+
+    final String prefix;
+    final String shortLabel;
+    final ByteSizeStandard standard;
+    final int power;
+
+    ByteSizeUnit(String prefix, String shortLabel, ByteSizeStandard standard, int power) {
+        this.prefix = prefix;
+        this.shortLabel = shortLabel;
+        this.standard = standard;
+        this.power = power;
+    }
+
+    private static Map<String, ByteSizeUnit> makeUnitsMap() {
+        Map<String, ByteSizeUnit> map = new HashMap<String, ByteSizeUnit>();
+        for (ByteSizeUnit unit : ByteSizeUnit.values()) {
+            map.put(unit.prefix + "byte", unit);
+            map.put(unit.prefix + "bytes", unit);
+            if (unit.prefix.length() == 0) {
+                map.put("b", unit);
+                map.put("", unit); // no unit specified means bytes
+            } else {
+                String first = unit.prefix.substring(0, 1);
+                if (unit.standard == IEC) {
+                    map.put(first, unit);        // 512m
+                    map.put(first + "i", unit);  // 512mi
+                    map.put(first + "ib", unit); // 512mib
+                } else if (unit.standard == SI) {
+                    map.put(first + "b", unit);  // 512kb
+                } else {
+                    throw new RuntimeException("broken MemoryUnit enum");
+                }
+            }
+        }
+        return map;
+    }
+
+    private static Map<String, ByteSizeUnit> unitsMap = makeUnitsMap();
+
+    /**
+     * Parses a string representation of a byte size unit and returns the corresponding {@link ByteSizeUnit}.
+     *
+     * There is support for various formats. Below is a list describing them where [prefix] represents the long form
+     * prefix of the unit (such as "kilo", "mega", "tera", etc) and [first] represents the first letter in the prefix
+     * (such as "k", "m", "t", etc):
+     * <ul>
+     *     <li>"" (empty string) - refers to the {@link ByteSizeUnit#BYTES}</li>
+     *     <li>"b" - refers to the {@link ByteSizeUnit#BYTES}.</li>
+     *     <li>"[prefix]byte" - the prefix determines what {@link ByteSizeStandard} is being used.</li>
+     *     <li>"[prefix]bytes" - the prefix determines what {@link ByteSizeStandard} is being used.</li>
+     *     <li>"[first]" - refers to the {@link ByteSizeStandard#IEC} standard for the corresponding prefix, eg. "k" is equal to "kibibyte"</li>
+     *     <li>"[first]i" - refers to the {@link ByteSizeStandard#IEC} standard for the corresponding prefix, eg. "ki" is equal to "kibibyte"</li>
+     *     <li>"[first]ib" - refers to the {@link ByteSizeStandard#IEC} standard for the corresponding prefix, eg. "kib" is equal to "kibibyte"</li>
+     *     <li>"[first]b" - refers to the {@link ByteSizeStandard#SI} standard for the corresponding prefix, eg. "kb" is equal to "kilobyte"</li>
+     * </ul>
+     *
+     * The parsing is case insensitive, meaning that the following strings are equivalent: "KiB", "kIb", "KIB", etc.
+     *
+     * This method will return <code>null</code> if the specified string is not a valid {@link ByteSizeUnit} string as
+     * described above.
+     *
+     * @param unit the string representation of the desired {@link ByteSizeUnit}.
+     *
+     * @return  the {@link ByteSizeUnit} represented by the specified string or <code>null</code> if the string could
+     *          not be translated into a known unit.
+     */
+    public static ByteSizeUnit parse(String unit) {
+        return unitsMap.get(unit.toLowerCase());
+    }
+
+    /**
+     * Returns whether this {@link ByteSizeUnit} is an SI unit.
+     *
+     * @return true iff this unit is an SI unit.
+     */
+    public boolean isSI(){
+        return this.standard == ByteSizeStandard.SI;
+    }
+
+    /**
+     * Returns whether this {@link ByteSizeUnit} is an IEC unit.
+     *
+     * @return true iff this unit is an IEC unit.
+     */
+    public boolean isIEC(){
+        return this.standard == ByteSizeStandard.IEC;
+    }
+
+    /**
+     * Gets the multiplication factor for this {@link ByteSizeUnit}.
+     *
+     * Returns the result of raising the poweOf value of this units standard to the power specified in this unit.
+     *
+     * @return the factor by which to multiply for this unit.
+     */
+    public BigDecimal getFactor(){
+        return BigDecimal.valueOf(standard.powerOf).pow(power);
+    }
+
+    /**
+     * Returns the long string representation of this unit, such as "kilobytes", "megabytes" or "bytes".
+     *
+     * Note that this method always returns the plural form.
+     *
+     * @return the plural long string representation of this unit.
+     */
+    public String toStringLongForm(){
+        return prefix + "bytes";
+    }
+
+    /**
+     * Returns the short string representation of this unit, such as "KiB", "B" or "MB".
+     *
+     * @return the short string representation of this unit.
+     */
+    public String toStringShortForm(){
+        return shortLabel;
+    }
+}
diff --git a/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/ByteSizeConverterTest.java b/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/ByteSizeConverterTest.java
new file mode 100755
index 0000000000..7d7240b89e
--- /dev/null
+++ b/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/ByteSizeConverterTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.converters;
+
+import org.aeonbits.owner.Config;
+import org.aeonbits.owner.ConfigFactory;
+import org.aeonbits.owner.util.bytesize.ByteSize;
+import org.aeonbits.owner.util.bytesize.ByteSizeUnit;
+import org.junit.Test;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import static org.junit.Assert.*;
+
+/**
+ * @author Stefan Freyr Stefansson
+ */
+public class ByteSizeConverterTest {
+    public interface ByteSizeConfig extends Config {
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10 byte")
+        ByteSize singular10byteWithSpace();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10byte")
+        ByteSize singular10byteWithoutSpace();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10 bytes")
+        ByteSize plural10byte();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10m")
+        ByteSize short10mebibytes();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10mi")
+        ByteSize medium10mebibytes();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10mib")
+        ByteSize long10mebibytes();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10 megabytes")
+        ByteSize full10megabytes();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("10 sillybyte")
+        ByteSize invalidSillybyte();
+
+        @ConverterClass(ByteSizeConverter.class)
+        @DefaultValue("megabyte")
+        ByteSize invalidNoNumber();
+    }
+
+    @Test
+    public void testValidByteSizeConverter(){
+        ByteSizeConfig cfg = ConfigFactory.create(ByteSizeConfig.class);
+        ByteSize bs;
+
+        bs = cfg.plural10byte();
+        assertEquals(bs, new ByteSize(10, ByteSizeUnit.BYTES));
+
+        bs = cfg.singular10byteWithoutSpace();
+        assertEquals(bs, new ByteSize(10, ByteSizeUnit.BYTES));
+
+        bs = cfg.singular10byteWithSpace();
+        assertEquals(bs, new ByteSize(10, ByteSizeUnit.BYTES));
+
+        ByteSize compare = new ByteSize(10, ByteSizeUnit.MEBIBYTES);
+        assertEquals(compare, cfg.short10mebibytes());
+        assertEquals(compare, cfg.medium10mebibytes());
+        assertEquals(compare, cfg.long10mebibytes());
+        assertNotEquals(compare, cfg.full10megabytes());
+        assertEquals(new ByteSize(10, ByteSizeUnit.MEGABYTES), cfg.full10megabytes());
+    }
+
+    @Test
+    public void testInvalid() throws NoSuchMethodException, IllegalAccessException {
+        ByteSizeConfig cfg = ConfigFactory.create(ByteSizeConfig.class);
+        ByteSize bs;
+        for (String method : new String[]{"invalidSillybyte", "invalidNoNumber"}) {
+            Method m = ByteSizeConfig.class.getDeclaredMethod(method);
+            try {
+                bs = (ByteSize) m.invoke(cfg);
+                fail(String.format("Invalid byte size [%s] should have thrown an exception. Instead we parsed: %s", method, bs));
+            } catch (InvocationTargetException e) {
+                if (!(e.getCause() instanceof IllegalArgumentException)){
+                    fail("Got an unexpected exception type when calling method: " + method);
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/DurationConverterTest.java b/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/DurationConverterTest.java
new file mode 100755
index 0000000000..51046a2682
--- /dev/null
+++ b/owner-java8-extras/src/test/java/org/aeonbits/owner/converters/DurationConverterTest.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.converters;
+
+import org.aeonbits.owner.Config;
+import org.aeonbits.owner.ConfigFactory;
+import org.aeonbits.owner.converters.DurationConverter;
+import org.junit.Test;
+
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import java.util.Arrays;
+import java.util.Collection;
+
+import static org.junit.Assert.assertEquals;
+
+public class DurationConverterTest {
+
+    public interface DurationTypesConfig extends Config {
+        // empty suffix
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10")
+        Duration emptySuffix();
+
+        // no space before suffix
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10ms")
+        Duration noSpaceBeforeSuffix();
+
+        // nanoseconds
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 ns")
+        Duration nsSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 nano")
+        Duration nanoSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 nanos")
+        Duration nanosSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 nanosecond")
+        Duration nanosecondSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 nanoseconds")
+        Duration nanosecondsSuffix();
+
+        // microseconds
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 us")
+        Duration usSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 µs")
+        Duration µsSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 micro")
+        Duration microSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 micros")
+        Duration microsSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 microsecond")
+        Duration microsecondSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 microseconds")
+        Duration microsecondsSuffix();
+
+        // milliseconds
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 ms")
+        Duration msSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 milli")
+        Duration milliSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 millis")
+        Duration millisSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 millisecond")
+        Duration millisecondSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 milliseconds")
+        Duration millisecondsSuffix();
+
+        // seconds
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 s")
+        Duration sSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 second")
+        Duration secondSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 seconds")
+        Duration secondsSuffix();
+
+        // minutes
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 m")
+        Duration mSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 minute")
+        Duration minuteSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 minutes")
+        Duration minutesSuffix();
+
+        // hours
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 h")
+        Duration hSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 hour")
+        Duration hourSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 hours")
+        Duration hoursSuffix();
+
+        // days
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 d")
+        Duration dSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 day")
+        Duration daySuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("10 days")
+        Duration daysSuffix();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("PT15M")
+        Duration iso8601NoPrefix15Minutes();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("-PT15M")
+        Duration iso8601MinusPrefix15Minutes();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("+PT15M")
+        Duration iso8601PlusPrefix15Minutes();
+
+        @ConverterClass(DurationConverter.class)
+        @DefaultValue("-PT-6H+3M")
+        Duration iso8601Complex();
+    }
+
+    private static boolean allEqual(Duration compareTo, Collection<Duration> durations){
+        for (Duration duration : durations) {
+            if( !compareTo.equals(duration) ){
+                return false;
+            }
+        }
+        return true;
+    }
+
+    @Test
+    public void testEmptySuffix() {
+        DurationTypesConfig cfg = ConfigFactory.create(DurationTypesConfig.class);
+        assertEquals(Duration.of(10, ChronoUnit.MILLIS), cfg.emptySuffix());
+    }
+
+    @Test
+    public void testNoSpaceBeforeSuffix() {
+        DurationTypesConfig cfg = ConfigFactory.create(DurationTypesConfig.class);
+        assertEquals(Duration.of(10, ChronoUnit.MILLIS), cfg.noSpaceBeforeSuffix());
+    }
+
+    @Test
+    public void testSuffixEquality() {
+        DurationTypesConfig cfg = ConfigFactory.create(DurationTypesConfig.class);
+
+        allEqual(Duration.of(10, ChronoUnit.NANOS),
+                Arrays.asList(cfg.nsSuffix(),cfg.nanoSuffix(),cfg.nanosSuffix(),cfg.nanosecondSuffix(),cfg.nanosecondsSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.MICROS),
+                Arrays.asList(cfg.usSuffix(),cfg.µsSuffix(),cfg.microSuffix(),cfg.microsSuffix(),cfg.microsecondSuffix(),cfg.microsecondsSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.MILLIS),
+                Arrays.asList(cfg.msSuffix(),cfg.milliSuffix(),cfg.millisSuffix(),cfg.millisecondSuffix(),cfg.millisecondsSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.SECONDS),
+                Arrays.asList(cfg.sSuffix(),cfg.secondSuffix(),cfg.secondsSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.MINUTES),
+                Arrays.asList(cfg.mSuffix(),cfg.minuteSuffix(),cfg.minutesSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.HOURS),
+                Arrays.asList(cfg.hSuffix(),cfg.hourSuffix(),cfg.hoursSuffix()));
+
+        allEqual(Duration.of(10, ChronoUnit.DAYS),
+                Arrays.asList(cfg.dSuffix(),cfg.daySuffix(),cfg.daysSuffix()));
+    }
+
+    @Test
+    public void testIso8601() {
+        DurationTypesConfig cfg = ConfigFactory.create(DurationTypesConfig.class);
+        assertEquals(Duration.of(15, ChronoUnit.MINUTES), cfg.iso8601NoPrefix15Minutes());
+        assertEquals(cfg.iso8601NoPrefix15Minutes(), cfg.iso8601PlusPrefix15Minutes());
+        assertEquals(Duration.of(-15, ChronoUnit.MINUTES), cfg.iso8601MinusPrefix15Minutes());
+        assertEquals(Duration.of(6, ChronoUnit.HOURS).minus(3, ChronoUnit.MINUTES), cfg.iso8601Complex());
+    }
+
+}
diff --git a/owner-java8-extras/src/test/java/org/aeonbits/owner/util/bytesize/ByteSizeTest.java b/owner-java8-extras/src/test/java/org/aeonbits/owner/util/bytesize/ByteSizeTest.java
new file mode 100755
index 0000000000..36c2d0e7cc
--- /dev/null
+++ b/owner-java8-extras/src/test/java/org/aeonbits/owner/util/bytesize/ByteSizeTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2012-2016, Luigi R. Viggiano
+ * All rights reserved.
+ *
+ * This software is distributable under the BSD license.
+ * See the terms of the BSD license in the documentation provided with this software.
+ */
+
+package org.aeonbits.owner.util.bytesize;
+
+import org.junit.Test;
+import java.math.BigInteger;
+import static org.junit.Assert.*;
+
+public class ByteSizeTest {
+    @Test
+    public void testBasics(){
+        assertEquals(1, new ByteSize(1, ByteSizeUnit.BYTES).getBytesAsLong());
+
+        BigInteger siBytes = BigInteger.valueOf(1000);
+        BigInteger iecBytes = BigInteger.valueOf(1024);
+
+        for (ByteSizeUnit bsu : ByteSizeUnit.values()) {
+            if (bsu == ByteSizeUnit.BYTES) {
+                assertEquals(1, new ByteSize(1, bsu).getBytesAsLong());
+            } else if (bsu.isIEC()) {
+                assertEquals(iecBytes, new ByteSize(1, bsu).getBytes());
+                iecBytes = iecBytes.multiply(BigInteger.valueOf(1024));
+            } else if (bsu.isSI()) {
+                assertEquals(siBytes, new ByteSize(1, bsu).getBytes());
+                siBytes = siBytes.multiply(BigInteger.valueOf(1000));
+            }
+        }
+    }
+
+    @Test
+    public void testConversion(){
+        assertEquals(new ByteSize(0.5, ByteSizeUnit.GIGABYTES), new ByteSize(500, ByteSizeUnit.MEGABYTES).convertTo(ByteSizeUnit.GIGABYTES));
+        assertEquals(new ByteSize(9.765625, ByteSizeUnit.KIBIBYTES), new ByteSize(10, ByteSizeUnit.KILOBYTES).convertTo(ByteSizeUnit.KIBIBYTES));
+        assertEquals(new ByteSize(10, ByteSizeUnit.MEGABYTES), new ByteSize(10, ByteSizeUnit.MEGABYTES).convertTo(ByteSizeUnit.MEGABYTES));
+        ByteSize bs = new ByteSize(1, ByteSizeUnit.BYTES).convertTo(ByteSizeUnit.ZETTABYTES);
+        assertEquals(1, bs.getBytesAsLong());
+        assertEquals(new ByteSize(1, ByteSizeUnit.BYTES), bs.convertTo(ByteSizeUnit.BYTES));
+    }
+
+    @Test
+    public void testEquality(){
+        assertEquals(new ByteSize(500, ByteSizeUnit.MEGABYTES), new ByteSize(0.5, ByteSizeUnit.GIGABYTES));
+        assertEquals(new ByteSize(500, ByteSizeUnit.MEBIBYTES), new ByteSize("0.48828125", ByteSizeUnit.GIBIBYTES));
+    }
+}
diff --git a/pom.xml b/pom.xml
index 52001dba9f..6d2ae407c2 100755
--- a/pom.xml
+++ b/pom.xml
@@ -138,6 +138,7 @@
             </activation>
             <modules>
                 <module>owner-java8</module>
+                <module>owner-java8-extras</module>
             </modules>
         </profile>
         <profile>
