diff --git a/its/ruling/src/test/resources/jdk6/squid-S4435.json b/its/ruling/src/test/resources/jdk6/squid-S4435.json
new file mode 100755
index 0000000000..0a8dee2556
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4435.json
@@ -0,0 +1,8 @@
+{
+'jdk6:java/util/XMLUtils.java':[
+142,
+],
+'jdk6:java/util/prefs/XmlSupport.java':[
+246,
+],
+}
diff --git a/its/ruling/src/test/resources/sonar-server/squid-S4435.json b/its/ruling/src/test/resources/sonar-server/squid-S4435.json
new file mode 100755
index 0000000000..c32fafae23
--- /dev/null
+++ b/its/ruling/src/test/resources/sonar-server/squid-S4435.json
@@ -0,0 +1,5 @@
+{
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/debt/DebtModelXMLExporter.java':[
+132,
+],
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
index 82f067c74e..adc0baa92e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
@@ -45,9 +45,11 @@
 import org.sonar.java.checks.security.AESAlgorithmCheck;
 import org.sonar.java.checks.security.CipherBlockChainingCheck;
 import org.sonar.java.checks.security.CookieShouldNotContainSensitiveDataCheck;
+import org.sonar.java.checks.security.CryptographicKeySizeCheck;
 import org.sonar.java.checks.security.HostnameVerifierImplementationCheck;
 import org.sonar.java.checks.security.IntegerToHexStringCheck;
 import org.sonar.java.checks.security.LDAPDeserializationCheck;
+import org.sonar.java.checks.security.SecureXmlTransformerCheck;
 import org.sonar.java.checks.security.TrustManagerCertificateCheck;
 import org.sonar.java.checks.security.LDAPAuthenticatedConnectionCheck;
 import org.sonar.java.checks.security.XmlExternalEntityProcessingCheck;
@@ -342,6 +344,7 @@ private CheckList() {
       .add(XmlExternalEntityProcessingCheck.class)
       .add(LDAPAuthenticatedConnectionCheck.class)
       .add(LDAPDeserializationCheck.class)
+      .add(SecureXmlTransformerCheck.class)
       .add(NonShortCircuitLogicCheck.class)
       .add(ArrayHashCodeAndToStringCheck.class)
       .add(DefaultEncodingUsageCheck.class)
@@ -557,6 +560,7 @@ private CheckList() {
       .add(SpecializedFunctionalInterfacesCheck.class)
       .add(IndentationAfterConditionalCheck.class)
       .add(CipherBlockChainingCheck.class)
+      .add(CryptographicKeySizeCheck.class)
       .build();
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java b/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
index 67c71e1bf8..eb9dd15ed6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/HardcodedIpCheck.java
@@ -35,7 +35,7 @@
 @Rule(key = "S1313")
 public class HardcodedIpCheck extends BaseTreeVisitor implements JavaFileScanner {
 
-  private static final Matcher IP = Pattern.compile("([^\\d.]*\\/)?(?<ip>(?:\\d{1,3}\\.){3}\\d{1,3}(?!\\d|\\.))(\\/.*)?").matcher("");
+  private static final Matcher IP = Pattern.compile("([^\\d.]*\\/)?((?<ip>(?:\\d{1,3}\\.){3}\\d{1,3})(:\\d{1,5})?(?!\\d|\\.))(\\/.*)?").matcher("");
 
   private JavaFileScannerContext context;
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
index 808587e936..6c1d14e6bf 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/InterruptedExceptionCheck.java
@@ -20,7 +20,12 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.Deque;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -34,16 +39,17 @@
 import org.sonar.plugins.java.api.tree.ThrowStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TryStatementTree;
-
-import javax.annotation.Nullable;
-
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.List;
+import org.sonar.plugins.java.api.tree.TypeTree;
+import org.sonar.plugins.java.api.tree.UnionTypeTree;
+import org.sonar.plugins.java.api.tree.VariableTree;
 
 @Rule(key = "S2142")
 public class InterruptedExceptionCheck extends IssuableSubscriptionVisitor {
 
+  private static final Predicate<Type> INTERRUPTING_TYPE_PREDICATE = catchType ->
+      catchType.is("java.lang.InterruptedException") ||
+      catchType.is("java.lang.ThreadDeath");
+
   private Deque<Boolean> withinInterruptingFinally = new LinkedList<>();
 
   @Override
@@ -64,17 +70,31 @@ public void visitNode(Tree tree) {
     TryStatementTree tryStatementTree = (TryStatementTree) tree;
     withinInterruptingFinally.addFirst(isFinallyInterrupting(tryStatementTree.finallyBlock()));
     for (CatchTree catchTree : tryStatementTree.catches()) {
-      Type catchType = catchTree.parameter().symbol().type();
-      if(catchType.is("java.lang.InterruptedException") || catchType.is("java.lang.ThreadDeath")) {
+      Optional<Type> interruptType = findInterruptingType(catchTree.parameter());
+      if(interruptType.isPresent()) {
         BlockVisitor blockVisitor = new BlockVisitor(catchTree.parameter().symbol());
         catchTree.block().accept(blockVisitor);
         if(!blockVisitor.threadInterrupted && !isWithinInterruptingFinally()) {
-          reportIssue(catchTree.parameter(), "Either re-interrupt this method or rethrow the \""+catchType.name()+"\".");
+          reportIssue(catchTree.parameter(), "Either re-interrupt this method" +
+            " or rethrow the \""+interruptType.get().name()+"\".");
         }
       }
     }
   }
 
+  private static Optional<Type> findInterruptingType(VariableTree parameter) {
+    if (parameter.type().is(Tree.Kind.UNION_TYPE)) {
+      return ((UnionTypeTree) parameter.type()).typeAlternatives().stream()
+        .map(TypeTree::symbolType)
+        .filter(INTERRUPTING_TYPE_PREDICATE)
+        .findFirst();
+    }
+    return Optional.of(parameter)
+      .map(VariableTree::symbol)
+      .map(Symbol::type)
+      .filter(INTERRUPTING_TYPE_PREDICATE);
+  }
+
   private boolean isWithinInterruptingFinally() {
     for (Boolean aBoolean : withinInterruptingFinally) {
       if(aBoolean) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
index 682979d698..258f391052 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
@@ -22,11 +22,13 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import org.sonar.check.Rule;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
 import org.sonar.java.model.LiteralUtils;
+import org.sonar.java.resolve.ArrayJavaType;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -170,9 +172,30 @@ private boolean checkEmptyParams(MethodInvocationTree mit, Collection<?> params)
   private void checkToStringInvocation(List<ExpressionTree> args) {
     args.stream()
       .filter(arg -> arg.is(Tree.Kind.METHOD_INVOCATION) && TO_STRING.matches((MethodInvocationTree) arg))
-      .forEach(arg -> reportIssue(arg, "No need to call toString \"method()\" as formatting and string conversion is done by the Formatter."));
+      .forEach(arg -> reportIssue(arg, getToStringMessage(arg)));
   }
 
+  private static String getToStringMessage(ExpressionTree arg) {
+    if (isInStringArrayInitializer(arg)) {
+      return "No need to call \"toString()\" method since an array of Objects can be used here.";
+    }
+    return "No need to call \"toString()\" method as formatting and string conversion is done by the Formatter.";
+  }
+
+  private static boolean isInStringArrayInitializer(ExpressionTree arg) {
+    return Optional.of(arg)
+      .map(Tree::parent)
+      .filter(tree -> tree.is(Tree.Kind.LIST))
+      .map(Tree::parent)
+      .filter(tree -> tree.is(Tree.Kind.NEW_ARRAY))
+      .map(NewArrayTree.class::cast)
+      .map(ExpressionTree::symbolType)
+      .filter(Type::isArray)
+      .map(ArrayJavaType.class::cast)
+      .map(ArrayJavaType::elementType)
+      .filter(type -> type.is("java.lang.String"))
+      .isPresent();
+  }
 
   private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> args, Set<Integer> indexes) {
     List<ExpressionTree> unusedArgs = new ArrayList<>(args);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java
new file mode 100755
index 0000000000..267ee60c16
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/CryptographicKeySizeCheck.java
@@ -0,0 +1,99 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.CheckForNull;
+import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.ConstantUtils;
+import org.sonar.java.checks.methods.AbstractMethodDetection;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S4426")
+public class CryptographicKeySizeCheck extends AbstractMethodDetection {
+
+  private static final String KEY_PAIR_GENERATOR = "java.security.KeyPairGenerator";
+  private static final String KEY_GENERATOR = "javax.crypto.KeyGenerator";
+  private static final String GET_INSTANCE_METHOD = "getInstance";
+  private static final String STRING = "java.lang.String";
+
+  @Override
+  protected List<MethodMatcher> getMethodInvocationMatchers() {
+    return ImmutableList.of(
+      MethodMatcher.create().typeDefinition(KEY_GENERATOR).name(GET_INSTANCE_METHOD).addParameter(STRING),
+      MethodMatcher.create().typeDefinition(KEY_PAIR_GENERATOR).name(GET_INSTANCE_METHOD).addParameter(STRING));
+  }
+
+  @Override
+  protected void onMethodInvocationFound(MethodInvocationTree mit) {
+    MethodTree methodTree = findEnclosingMethod(mit);
+    String getInstanceArg = ConstantUtils.resolveAsStringConstant(mit.arguments().get(0));
+    if (methodTree != null && getInstanceArg != null) {
+      MethodVisitor methodVisitor = new MethodVisitor(getInstanceArg);
+      methodTree.accept(methodVisitor);
+    }
+  }
+
+  @CheckForNull
+  public static MethodTree findEnclosingMethod(Tree tree) {
+    while (!tree.is(Tree.Kind.CLASS, Tree.Kind.METHOD)) {
+      tree = tree.parent();
+    }
+    if (tree.is(Tree.Kind.CLASS)) {
+      return null;
+    }
+    return (MethodTree) tree;
+  }
+
+  private class MethodVisitor extends BaseTreeVisitor {
+
+    private final String algorithm;
+
+    public MethodVisitor(String getInstanceArg) {
+      this.algorithm = getInstanceArg;
+    }
+
+    private final Map<String, Integer> algorithmKeySizeMap = ImmutableMap.of("Blowfish", 128, "RSA", 2048);
+
+    private final MethodMatcher keyGenInit = MethodMatcher.create().typeDefinition(KEY_GENERATOR).name("init").addParameter("int");
+    private final MethodMatcher keyPairGenInitialize = MethodMatcher.create().typeDefinition(KEY_PAIR_GENERATOR).name("initialize").addParameter("int");
+
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree mit) {
+      if (keyGenInit.matches(mit) || keyPairGenInitialize.matches(mit)) {
+        Integer minKeySize = algorithmKeySizeMap.get(this.algorithm);
+        if (minKeySize != null) {
+          Integer keySize = LiteralUtils.intLiteralValue(mit.arguments().get(0));
+          if (keySize != null && keySize < minKeySize) {
+            reportIssue(mit, "Use a key length of at least " + minKeySize + " bits.");
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/SecureXmlTransformerCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/SecureXmlTransformerCheck.java
new file mode 100755
index 0000000000..22733714ec
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/SecureXmlTransformerCheck.java
@@ -0,0 +1,128 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.CheckForNull;
+import javax.xml.XMLConstants;
+import javax.xml.transform.TransformerFactory;
+import org.sonar.check.Rule;
+import org.sonar.java.checks.methods.AbstractMethodDetection;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.plugins.java.api.tree.Arguments;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.Tree.Kind;
+
+import static org.sonar.java.checks.helpers.ConstantUtils.resolveAsStringConstant;
+import static org.sonar.java.matcher.TypeCriteria.subtypeOf;
+
+@Rule(key = "S4435")
+public class SecureXmlTransformerCheck extends AbstractMethodDetection {
+
+  private static final String TRANSFORMER_FACTORY_CLASS_NAME = TransformerFactory.class.getName();
+
+  @Override
+  protected List<MethodMatcher> getMethodInvocationMatchers() {
+    return Collections.singletonList(
+      MethodMatcher.create()
+        .typeDefinition(TRANSFORMER_FACTORY_CLASS_NAME)
+        .name("newInstance")
+        .withAnyParameters());
+  }
+
+  @Override
+  protected void onMethodInvocationFound(MethodInvocationTree methodInvocation) {
+    Tree enclosingMethod = enclosingMethod(methodInvocation);
+    if (enclosingMethod == null) {
+      return;
+    }
+    MethodBodyVisitor visitor = new MethodBodyVisitor();
+    enclosingMethod.accept(visitor);
+    if (!visitor.foundCallsToSecuringMethods()) {
+      reportIssue(methodInvocation.methodSelect(), "Secure this \"Transformer\" by either disabling external DTDs or enabling secure processing.");
+    }
+  }
+
+  @CheckForNull
+  private static Tree enclosingMethod(Tree tree) {
+    Tree parent = tree.parent();
+    while (!parent.is(Kind.CLASS, Kind.METHOD)) {
+      parent = parent.parent();
+    }
+    if (parent.is(Kind.CLASS)) {
+      return null;
+    }
+    return parent;
+  }
+
+  private static class MethodBodyVisitor extends BaseTreeVisitor {
+
+    private static final MethodMatcher SET_FEATURE =
+      MethodMatcher.create()
+        .typeDefinition(subtypeOf(TRANSFORMER_FACTORY_CLASS_NAME))
+        .name("setFeature")
+        .parameters("java.lang.String", "boolean");
+
+    private static final MethodMatcher SET_ATTRIBUTE =
+      MethodMatcher.create()
+        .typeDefinition(subtypeOf(TRANSFORMER_FACTORY_CLASS_NAME))
+        .name("setAttribute")
+        .parameters("java.lang.String", "java.lang.Object");
+
+    private boolean hasSecureProcessingFeature = false;
+    private boolean hasSecuredExternalDtd = false;
+    private boolean hasSecuredExternalStylesheet = false;
+
+    private boolean foundCallsToSecuringMethods() {
+      return hasSecureProcessingFeature || (hasSecuredExternalDtd && hasSecuredExternalStylesheet);
+    }
+
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
+      Arguments arguments = methodInvocation.arguments();
+
+      if (SET_FEATURE.matches(methodInvocation)
+        && XMLConstants.FEATURE_SECURE_PROCESSING.equals(resolveAsStringConstant(arguments.get(0)))
+        && LiteralUtils.isTrue(arguments.get(1))) {
+
+        hasSecureProcessingFeature = true;
+      }
+
+      if (SET_ATTRIBUTE.matches(methodInvocation)) {
+        String attributeName = resolveAsStringConstant(arguments.get(0));
+        String attributeValue = resolveAsStringConstant(arguments.get(1));
+        if ("".equals(attributeValue)) {
+          if (XMLConstants.ACCESS_EXTERNAL_DTD.equals(attributeName)) {
+            hasSecuredExternalDtd = true;
+          } else if (XMLConstants.ACCESS_EXTERNAL_STYLESHEET.equals(attributeName)) {
+            hasSecuredExternalStylesheet = true;
+          }
+        }
+      }
+
+      super.visitMethodInvocation(methodInvocation);
+    }
+
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/XmlExternalEntityProcessingCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/XmlExternalEntityProcessingCheck.java
index 00f03a5cf4..1519f15250 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/security/XmlExternalEntityProcessingCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/XmlExternalEntityProcessingCheck.java
@@ -19,13 +19,13 @@
  */
 package org.sonar.java.checks.security;
 
+import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.function.Supplier;
+import java.util.function.Predicate;
 import javax.annotation.CheckForNull;
 import javax.xml.XMLConstants;
+import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.stream.XMLInputFactory;
 import org.sonar.check.Rule;
@@ -38,30 +38,41 @@
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
 
 import static org.sonar.java.checks.helpers.ConstantUtils.resolveAsBooleanConstant;
 import static org.sonar.java.checks.helpers.ConstantUtils.resolveAsStringConstant;
 import static org.sonar.java.matcher.TypeCriteria.subtypeOf;
 
-@Rule(key = "S2756")
+@Rule(key = "S2755")
 public class XmlExternalEntityProcessingCheck extends IssuableSubscriptionVisitor {
 
-  private static final String STAX_FACTORY_CLASS_NAME = XMLInputFactory.class.getName();
+  private static final String XML_INPUT_FACTORY_CLASS_NAME = XMLInputFactory.class.getName();
   private static final String SAX_PARSER_FACTORY_CLASS_NAME = SAXParserFactory.class.getName();
-
-  private final Map<MethodMatcher, Supplier<XxeValidator>> xxeValidatorsByMethodMatcher = xxeValidatorsByMethodMatcher();
-
-  private static Map<MethodMatcher, Supplier<XxeValidator>> xxeValidatorsByMethodMatcher() {
-    Map<MethodMatcher, Supplier<XxeValidator>> map = new HashMap<>();
-    map.put(
-      MethodMatcher.create().typeDefinition(STAX_FACTORY_CLASS_NAME).name("newInstance").withAnyParameters(),
-      StaxXxeValidator::new);
-    map.put(
-      MethodMatcher.create().typeDefinition(SAX_PARSER_FACTORY_CLASS_NAME).name("newInstance").withAnyParameters(),
-      SaxParserXxeValidator::new);
-    return map;
+  private static final String XML_READER_FACTORY_CLASS_NAME = XMLReaderFactory.class.getName();
+  private static final String XML_READER_CLASS_NAME = XMLReader.class.getName();
+  private static final String DOCUMENT_BUILDER_FACTORY_CLASS_NAME = DocumentBuilderFactory.class.getName();
+
+  private static final MethodMatcher CREATE_XML_READER_MATCHER = MethodMatcher.create()
+    .typeDefinition(XML_READER_FACTORY_CLASS_NAME)
+    .name("createXMLReader")
+    .withAnyParameters();
+
+  private static MethodMatcher newInstanceMethod(String className) {
+    return MethodMatcher.create()
+      .typeDefinition(className)
+      .name("newInstance")
+      .withAnyParameters();
   }
 
+  private final List<XxeCheck> xxeChecks = Arrays.asList(
+    new XxeCheck(newInstanceMethod(XML_INPUT_FACTORY_CLASS_NAME), new XMLInputFactorySecuringPredicate()),
+    new XxeCheck(newInstanceMethod(SAX_PARSER_FACTORY_CLASS_NAME), new SecureProcessingFeaturePredicate(SAX_PARSER_FACTORY_CLASS_NAME)),
+    new XxeCheck(newInstanceMethod(DOCUMENT_BUILDER_FACTORY_CLASS_NAME), new SecureProcessingFeaturePredicate(DOCUMENT_BUILDER_FACTORY_CLASS_NAME)),
+    new XxeCheck(CREATE_XML_READER_MATCHER, new SecureProcessingFeaturePredicate(XML_READER_CLASS_NAME))
+  );
+
   @Override
   public List<Tree.Kind> nodesToVisit() {
     return Collections.singletonList(Kind.METHOD_INVOCATION);
@@ -69,98 +80,110 @@
 
   @Override
   public void visitNode(Tree tree) {
-    MethodInvocationTree methodInvocation = (MethodInvocationTree) tree;
-    xxeValidatorsByMethodMatcher.forEach((matcher, validatorSupplier) -> {
-      if (matcher.matches(methodInvocation)) {
+    xxeChecks.forEach(check -> check.checkMethodInvocation((MethodInvocationTree) tree));
+  }
+
+  private class XxeCheck {
+
+    private final MethodMatcher triggeringInvocationMatcher;
+    private final Predicate<MethodInvocationTree> securingInvocationPredicate;
+
+    private XxeCheck(MethodMatcher triggeringInvocationMatcher, Predicate<MethodInvocationTree> securingInvocationPredicate) {
+      this.triggeringInvocationMatcher = triggeringInvocationMatcher;
+      this.securingInvocationPredicate = securingInvocationPredicate;
+    }
+
+    private void checkMethodInvocation(MethodInvocationTree methodInvocation) {
+      if (triggeringInvocationMatcher.matches(methodInvocation)) {
         MethodTree enclosingMethod = enclosingMethod(methodInvocation);
         if (enclosingMethod != null) {
-          XxeValidator xxeValidator = validatorSupplier.get();
-          enclosingMethod.accept(xxeValidator);
-          if (!xxeValidator.isExternalEntityProcessingDisabled()) {
+          MethodVisitor methodVisitor = new MethodVisitor(securingInvocationPredicate);
+          enclosingMethod.accept(methodVisitor);
+          if (!methodVisitor.isExternalEntityProcessingDisabled) {
             reportIssue(methodInvocation.methodSelect(), "Disable external entity (XXE) processing.");
           }
         }
       }
-    });
-  }
-
-  @CheckForNull
-  private static MethodTree enclosingMethod(Tree tree) {
-    Tree parent = tree.parent();
-    while (!parent.is(Kind.CLASS, Kind.METHOD)) {
-      parent = parent.parent();
     }
-    if (parent.is(Kind.CLASS)) {
-      return null;
+
+    @CheckForNull
+    private MethodTree enclosingMethod(Tree tree) {
+      Tree parent = tree.parent();
+      while (!parent.is(Kind.CLASS, Kind.METHOD)) {
+        parent = parent.parent();
+      }
+      if (parent.is(Kind.CLASS)) {
+        return null;
+      }
+      return (MethodTree) parent;
     }
-    return (MethodTree) parent;
   }
 
-  private abstract static class XxeValidator extends BaseTreeVisitor {
+  private static class MethodVisitor extends BaseTreeVisitor {
+
+    private final Predicate<MethodInvocationTree> securingInvocationPredicate;
+    private boolean isExternalEntityProcessingDisabled = false;
 
-    abstract boolean isExternalEntityProcessingDisabled();
+    private MethodVisitor(Predicate<MethodInvocationTree> securingInvocationPredicate) {
+      this.securingInvocationPredicate = securingInvocationPredicate;
+    }
 
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
+      if (securingInvocationPredicate.test(methodInvocation)) {
+        isExternalEntityProcessingDisabled = true;
+      }
+      super.visitMethodInvocation(methodInvocation);
+    }
   }
 
-  private static class StaxXxeValidator extends XxeValidator {
+  private static class XMLInputFactorySecuringPredicate implements Predicate<MethodInvocationTree> {
 
     private static final MethodMatcher SET_PROPERTY =
       MethodMatcher.create()
-        .typeDefinition(subtypeOf(STAX_FACTORY_CLASS_NAME))
+        .typeDefinition(subtypeOf(XML_INPUT_FACTORY_CLASS_NAME))
         .name("setProperty")
         .parameters("java.lang.String", "java.lang.Object");
 
-    private boolean isExternalEntityProcessingDisabled = false;
-
     @Override
-    boolean isExternalEntityProcessingDisabled() {
-      return isExternalEntityProcessingDisabled;
-    }
-
-    @Override
-    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
+    public boolean test(MethodInvocationTree methodInvocation) {
       Arguments arguments = methodInvocation.arguments();
       if (SET_PROPERTY.matches(methodInvocation)) {
         String propertyName = resolveAsStringConstant(arguments.get(0));
         if (XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES.equals(propertyName) || XMLInputFactory.SUPPORT_DTD.equals(propertyName)) {
           ExpressionTree propertyValue = arguments.get(1);
-          if (Boolean.FALSE.equals(resolveAsBooleanConstant(propertyValue))) {
-            isExternalEntityProcessingDisabled = true;
-          }
+          return Boolean.FALSE.equals(resolveAsBooleanConstant(propertyValue));
         }
       }
-      super.visitMethodInvocation(methodInvocation);
+      return false;
     }
   }
 
-  private static class SaxParserXxeValidator extends XxeValidator {
+  private static class SecureProcessingFeaturePredicate implements Predicate<MethodInvocationTree> {
 
-    private static final MethodMatcher SET_FEATURE =
-      MethodMatcher.create()
-        .typeDefinition(subtypeOf(SAX_PARSER_FACTORY_CLASS_NAME))
-        .name("setFeature")
-        .parameters("java.lang.String", "boolean");
-
-    private boolean isExternalEntityProcessingDisabled = false;
+    private final MethodMatcher methodMatcher;
 
-    @Override
-    boolean isExternalEntityProcessingDisabled() {
-      return isExternalEntityProcessingDisabled;
+    private SecureProcessingFeaturePredicate(String className) {
+      this.methodMatcher = setFeatureMethodMatcher(className);
     }
 
     @Override
-    public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
-      Arguments arguments = methodInvocation.arguments();
-      if (SET_FEATURE.matches(methodInvocation)) {
+    public boolean test(MethodInvocationTree methodInvocation) {
+      if (methodMatcher.matches(methodInvocation)) {
+        Arguments arguments = methodInvocation.arguments();
         String featureName = resolveAsStringConstant(arguments.get(0));
-        if (XMLConstants.FEATURE_SECURE_PROCESSING.equals(featureName)) {
-          ExpressionTree propertyValue = arguments.get(1);
-          if (Boolean.TRUE.equals(resolveAsBooleanConstant(propertyValue))) {
-            isExternalEntityProcessingDisabled = true;
-          }
-        }
+        return Boolean.TRUE.equals(resolveAsBooleanConstant(arguments.get(1)))
+          && (XMLConstants.FEATURE_SECURE_PROCESSING.equals(featureName)
+          || "http://apache.org/xml/features/disallow-doctype-decl".equals(featureName));
       }
-      super.visitMethodInvocation(methodInvocation);
+      return false;
+    }
+
+    private static MethodMatcher setFeatureMethodMatcher(String className) {
+      return MethodMatcher.create()
+        .typeDefinition(subtypeOf(className))
+        .name("setFeature")
+        .parameters("java.lang.String", "boolean");
     }
   }
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.html
similarity index 70%
rename from java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.html
rename to java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.html
index 03e6526d27..0a3768a9c7 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.html
@@ -40,4 +40,15 @@ <h2>Compliant Solution</h2>
     // Load XML stream
     XMLStreamReader xmlStreamReader = factory.createXMLStreamReader(fis);
 </pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/611.html">MITRE, CWE-611</a> - Information Exposure Through XML External Entity Reference </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/827.html">MITRE, CWE-827</a> - Improper Control of Document Type Definition </li>
+  <li> OWASP Top 10 2017 Category A1 - Injection </li>
+  <li> OWASP Top 10 2017 Category A4 - XML External Entities (XXE) </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_XMLSTREAMREADER">XXE_XMLSTREAMREADER</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_SAXPARSER">XXE_SAXPARSER</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_XMLREADER">XXE_XMLREADER</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_DOCUMENT">XXE_DOCUMENT</a> </li>
+</ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.json
new file mode 100755
index 0000000000..e8fe24af92
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2755_java.json
@@ -0,0 +1,22 @@
+{
+  "title": "Untrusted XML should be parsed with a local, static DTD",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "15min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a1",
+    "owasp-a4"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
+  "defaultSeverity": "Blocker",
+  "ruleSpecification": "RSPEC-2755",
+  "sqKey": "S2755",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.json
deleted file mode 100755
index 87f84cb1ce..0000000000
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2756_java.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "title": "Java",
-  "type": "CODE_SMELL",
-  "status": "ready",
-  "tags": [
-    
-  ],
-  "ruleSpecification": "RSPEC-2756",
-  "sqKey": "S2756",
-  "scope": "Main"
-}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html
new file mode 100755
index 0000000000..16e2d02b27
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.html
@@ -0,0 +1,28 @@
+<p>When generating cryptograpic keys (or key pairs), it is important to use a key length that provides enough entropy against brute-force attacks. For
+the <code>Blowfish</code> algorithm the key should be at least 128 bits long, while for the <code>RSA</code> algorithm it should be at least 2048 bits
+long.</p>
+<p>This rule raises an issue when a Blowfish key generator, or RSA key-pair generator is initialized with too small a length parameter.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+keyGen.init(64); // Noncompliant
+
+KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
+keyPairGen.initialize(512); // Noncompliant
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+keyGen.init(128);
+
+KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
+keyPairGen.initialize(2048);
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE, CWE-326</a> - Inadequate Encryption Strength </li>
+  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#BLOWFISH_KEY_SIZE">BLOWFISH_KEY_SIZE</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#RSA_KEY_SIZE">RSA_KEY_SIZE</a> </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json
new file mode 100755
index 0000000000..23b227ba7b
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4426_java.json
@@ -0,0 +1,21 @@
+{
+  "title": "Cryptographic keys should not be too short",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "2min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a3"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
+  "defaultSeverity": "Blocker",
+  "ruleSpecification": "RSPEC-4426",
+  "sqKey": "S4426",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.html
new file mode 100755
index 0000000000..0bd41131e1
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.html
@@ -0,0 +1,41 @@
+<p>An XML External Entity or XSLT External Entity (XXE) vulnerability can occur when a <code>javax.xml.transform.Transformer</code> is created without
+enabling "Secure Processing" or when one is created without disabling external DTDs. If that external entity is hijacked by an attacker it may lead to
+the disclosure of confidential data, denial of service, server side request forgery, port scanning from the perspective of the machine where the
+parser is located, and other system impacts.</p>
+<p>This rule raises an issue when a <code>Transformer</code> is created without either of these settings.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+Transformer transformer = TransformerFactory.newInstance().newTransformer();
+transformer.transform(input, result);
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+TransformerFactory factory = TransformerFactory.newInstance();
+factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+
+Transformer transformer = factory.newTransformer();
+transformer.setOutputProperty(OutputKeys.INDENT, "yes");
+
+transformer.transform(input, result);
+</pre>
+<p>or</p>
+<pre>
+TransformerFactory factory = TransformerFactory.newInstance();
+factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
+factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
+
+Transformer transformer = factory.newTransformer();
+transformer.setOutputProperty(OutputKeys.INDENT, "yes");
+
+transformer.transform(input, result);
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/611.html">MITRE, CWE-611</a> Improper Restriction of XML External Entity Reference ('XXE') </li>
+  <li> OWASP Top 10 2017 Category A4 - XML External Entities </li>
+  <li> [OWASP XXE cheat sheet| https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#TransformerFactory] </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_DTD_TRANSFORM_FACTORY">XXE_DTD_TRANSFORM_FACTORY</a> </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#XXE_XSLT_TRANSFORM_FACTORY">XXE_XSLT_TRANSFORM_FACTORY</a>
+  </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.json
new file mode 100755
index 0000000000..441fbc40ce
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4435_java.json
@@ -0,0 +1,21 @@
+{
+  "title": "XML transformers should be secured",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a4"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-4435",
+  "sqKey": "S4435",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
index cd7051f047..77bbdfea8d 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
@@ -304,11 +304,13 @@
     "S4349",
     "S4351",
     "S4423",
-    "S4425",
     "S4424",
+    "S4425",
+    "S4426",
     "S4432",
     "S4433",
     "S4434",
+    "S4435",
     "S4449",
     "S4454",
     "S4524"
diff --git a/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java b/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
index dc9a120311..ee97eacd47 100755
--- a/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
+++ b/java-checks/src/test/files/checks/AnnotationDefaultArgumentCheck.java
@@ -21,7 +21,7 @@
   @MyAnnotation(myName="foo", myInteger=2)
   @MyAnnotation2("defaultValue") // Noncompliant
   @MyAnnotation2("someValue")
-  @MyAnnotation3(myHexaInteger = 0x000) // false negative : unsupported reading of hexadecimal literal value.
+  @MyAnnotation3(myHexaInteger = 0x000) // Noncompliant {{Remove this default value assigned to parameter "myHexaInteger".}}
   @MyUnknownAnnotation("value")
   void goodMethod() {
 
diff --git a/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java b/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
index 392cf5a0c2..c72906cfd8 100755
--- a/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
+++ b/java-checks/src/test/files/checks/DefaultInitializedFieldCheck.java
@@ -14,7 +14,7 @@
   long l2 = 0xFFFF_FFFF_FFFF_FFFFL;
   long l3;
   long l4 = 0x0000_0000_0000_0000L; // Noncompliant {{Remove this initialization to "0x0000_0000_0000_0000L", the compiler will do that for you.}}
-  long l5 = 0b00000000_00000000_00000000_00000000; // Know limitation, this 0 initialisation not supported
+  long l5 = 0b00000000_00000000_00000000_00000000; // Noncompliant {{Remove this initialization to "0b00000000_00000000_00000000_00000000", the compiler will do that for you.}}
   float f = 0; // Noncompliant {{Remove this initialization to "0", the compiler will do that for you.}}
   float f1 = 0.f; // Noncompliant {{Remove this initialization to "0.f", the compiler will do that for you.}}
   float f2 = 1.f;
diff --git a/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java b/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
index 3b3b33d63f..efae2ac8b2 100755
--- a/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
+++ b/java-checks/src/test/files/checks/ForLoopFalseConditionCheck.java
@@ -24,5 +24,6 @@ void myMethod(int x, int y, int z) {
     for (int i = 1;      ; ) {}
     for (int i = 0; i < 0x10; ) {}
     for (int i = 0; i < 0b10; ) {}
+    for (int i = 1; i <= 0Xffff; i++) {}
   }
 }
diff --git a/java-checks/src/test/files/checks/HardcodedIpCheck.java b/java-checks/src/test/files/checks/HardcodedIpCheck.java
index d8cf740b77..c6322be244 100755
--- a/java-checks/src/test/files/checks/HardcodedIpCheck.java
+++ b/java-checks/src/test/files/checks/HardcodedIpCheck.java
@@ -1,6 +1,8 @@
 class A {
   String ip = "0.0.0.0"; // Noncompliant [[sc=15;ec=24]] {{Make this IP "0.0.0.0" address configurable.}}
+  String ipAndPort = "0.0.0.0:0"; // Noncompliant [[sc=22;ec=33]] {{Make this IP "0.0.0.0" address configurable.}}
   String url = "http://192.168.0.1/admin.html"; // Noncompliant {{Make this IP "192.168.0.1" address configurable.}}
+  String urlWithPort = "http://192.168.0.1:8000/admin.html"; // Noncompliant {{Make this IP "192.168.0.1" address configurable.}}
   String url2 = "http://www.example.org";
   int a = 42;
   String notAnIp1 = "0.0.0.1234";
diff --git a/java-checks/src/test/files/checks/InterruptedExceptionCheck.java b/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
index fe6db31270..487ce22ef8 100755
--- a/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
+++ b/java-checks/src/test/files/checks/InterruptedExceptionCheck.java
@@ -32,6 +32,16 @@ public void runUnknownSymbol () {
     }
   }
 
+  public void catchUnionType () {
+    try {
+      while (true) {
+        // do stuff
+      }
+    } catch (InterruptedException | java.io.IOException e) { // Noncompliant [[sc=14;ec=58]] {{Either re-interrupt this method or rethrow the "InterruptedException".}}
+      unknownField.log(Level.WARN, "Interrupted!", e);
+    }
+  }
+
   public void run () throws InterruptedException{
     try {
       while (true) {
diff --git a/java-checks/src/test/files/checks/PrintfMisuseCheck.java b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
index 274c7f02e8..301ceabe96 100755
--- a/java-checks/src/test/files/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
@@ -2,10 +2,10 @@
 import java.io.PrintWriter;
 import java.text.FieldPosition;
 import java.text.MessageFormat;
+import java.util.Calendar;
 import java.util.Formatter;
 import java.util.GregorianCalendar;
 import java.util.Locale;
-import java.util.Calendar;
 
 class A {
   void foo(Calendar c){
@@ -98,7 +98,7 @@ void foo(Calendar c){
     MessageFormat.format("Result '{0}'", 14); // Noncompliant {{String contains no format specifiers.}}
     MessageFormat.format("Result ' {0}", 14);
     MessageFormat.format("Result {{{0}}.", 14);
-    MessageFormat.format("Result {0}!", myObject.toString()); // Noncompliant {{No need to call toString "method()" as formatting and string conversion is done by the Formatter.}}
+    MessageFormat.format("Result {0}!", myObject.toString()); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
     MessageFormat.format("Result {0}!", myObject.hashCode()); // Compliant
     MessageFormat.format("Result yeah!", 14); // Noncompliant {{String contains no format specifiers.}}
     MessageFormat.format("Result {1}!", 14);
@@ -119,7 +119,7 @@ void foo(Calendar c){
     logger.log(java.util.logging.Level.SEVERE, "Result '{0}'", 14); // Noncompliant {{String contains no format specifiers.}}
     logger.log(java.util.logging.Level.SEVERE, "Result ' {0}", 14);
     logger.log(java.util.logging.Level.SEVERE, "Result {{{0}}.", 14);
-    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.toString()); // Noncompliant {{No need to call toString "method()" as formatting and string conversion is done by the Formatter.}}
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.toString()); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
     logger.log(java.util.logging.Level.SEVERE, "Result {0}!", myObject.hashCode()); // Compliant
     logger.log(java.util.logging.Level.SEVERE, "Result yeah!", 14); // Noncompliant {{String contains no format specifiers.}}
     logger.log(java.util.logging.Level.SEVERE, "Result yeah!", new Exception()); // compliant, throwable parameter
@@ -131,6 +131,8 @@ void foo(Calendar c){
     logger.log(java.util.logging.Level.SEVERE, "{0,number,#.#}{1}", new Object[42]); // Compliant - Not considered
     logger.log(java.util.logging.Level.SEVERE, "value=\"'{'{0}'}'{1}\"", new Object[] {"value 1", "value 2"});
     logger.log(java.util.logging.Level.SEVERE, "value=\"{0}'{'{1}'}'\"", new Object[] {"value 1", "value 2"});
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", new Object[] {myObject.toString()}); // Noncompliant {{No need to call "toString()" method as formatting and string conversion is done by the Formatter.}}
+    logger.log(java.util.logging.Level.SEVERE, "Result {0}!", new String[] {myObject.toString()}); // Noncompliant {{No need to call "toString()" method since an array of Objects can be used here.}}
 
     org.slf4j.Logger slf4jLog;
     org.slf4j.Marker marker;
diff --git a/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java
new file mode 100755
index 0000000000..15c53c3123
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java
@@ -0,0 +1,110 @@
+import B.Blowfish;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.KeyGenerator;
+
+class Blowfish {
+
+  KeyGenerator keyG;
+  private static final Integer CONSTANT_INT = 64;
+
+  public Blowfish() throws NoSuchAlgorithmException {
+    keyG = KeyGenerator.getInstance("Blowfish");
+  }
+
+  public void key_variable() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant [[sc=5;ec=20]] {{Use a key length of at least 128 bits.}}
+  }
+
+  public void key_variable_compliant() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(128); // Compliant
+  }
+
+  public void identifier_parameter() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    int x = 64;
+    keyGen.init(x); // FN requires following variable's values with SE-based engine
+  }
+
+  public void identifier_parameter2() throws NoSuchAlgorithmException {
+    String algorithm = "Blowfish";
+    KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);
+    keyGen.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void key_assignment() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen;
+    keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant {{Use a key length of at least 128 bits.}}
+  }
+
+  public void key_assignment_compliant() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen;
+    keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(128); // Compliant
+  }
+
+  public void false_negative() {
+    keyG.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void different_algorithm() throws NoSuchAlgorithmException {
+    keyG = KeyGenerator.getInstance("AES");
+    keyG.init(64); // Compliant
+  }
+
+  private KeyGenerator createGen() throws NoSuchAlgorithmException {
+    return KeyGenerator.getInstance("Blowfish");
+  }
+
+  public void false_negative2() throws NoSuchAlgorithmException {
+    keyG = createGen();
+    keyG.init(64); // FN requires following variable's values with SE-based engine
+  }
+
+  public void lambda_expr() {
+    Runnable task2 = () -> {
+      KeyGenerator keyGen;
+      try {
+        keyGen = KeyGenerator.getInstance("Blowfish");
+        keyGen.init(64); // Noncompliant
+      } catch (NoSuchAlgorithmException e) {
+        e.printStackTrace();
+      }
+    };
+  }
+
+  public void anonymous_class() {
+    new Runnable() {
+      @Override
+      public void run() {
+        KeyGenerator keyGen;
+        try {
+          keyGen = KeyGenerator.getInstance("Blowfish");
+          keyGen.init(64); // Noncompliant
+        } catch (NoSuchAlgorithmException e) {
+          e.printStackTrace();
+        }
+      }
+    };
+  }
+
+  public void false_positive() throws NoSuchAlgorithmException {
+    KeyGenerator keyGen = KeyGenerator.getInstance("AES");
+    KeyGenerator keyGen2 = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(64); // Noncompliant FP
+  }
+
+  public void constant_key_value() {
+    KeyGenerator keyGen = KeyGenerator.getInstance("Blowfish");
+    keyGen.init(CONSTANT_INT); // FN requires following variable's values with SE-based engine
+  }
+
+  public void big_key_value() {
+    KeyGenerator keyG;
+    keyG = KeyGenerator.getInstance("Blowfish");
+    keyG.init(256); // Compliant
+  }
+}
diff --git a/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java
new file mode 100755
index 0000000000..b9cbc53836
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java
@@ -0,0 +1,22 @@
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import javax.crypto.KeyGenerator;
+
+class RSA {
+
+  public void key_variable() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(1024); // Noncompliant [[sc=5;ec=28]]  {{Use a key length of at least 2048 bits.}}
+  }
+
+  public void key_variable_compliant() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(2048); // Compliant
+  }
+
+  public void report_twice() throws NoSuchAlgorithmException {
+    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
+    keyGen.initialize(1024); // Noncompliant
+    keyGen.initialize(1023); // Noncompliant
+  }
+}
diff --git a/java-checks/src/test/files/checks/security/SecureXmlTransformerCheck.java b/java-checks/src/test/files/checks/security/SecureXmlTransformerCheck.java
new file mode 100755
index 0000000000..27f46ff091
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/SecureXmlTransformerCheck.java
@@ -0,0 +1,116 @@
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.XMLConstants;
+
+class A {
+
+  static final boolean BOOLEAN_TRUE = true;
+
+  TransformerFactory classField = TransformerFactory.newInstance();
+
+  TransformerFactory no_call_to_securing_method() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    return factory;
+  }
+
+  // setFeature
+
+  TransformerFactory secure_processing_true() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+    return factory;
+  }
+
+  TransformerFactory secure_processing_false() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);
+    return factory;
+  }
+
+  TransformerFactory secure_processing_true_with_literal() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    factory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);
+    return factory;
+  }
+
+  TransformerFactory setfeature_with_other_than_secure_processing() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setFeature(XMLConstants.ACCESS_EXTERNAL_DTD, true);
+    return factory;
+  }
+
+  // setAttribute
+
+  TransformerFactory setattribute_dtd_and_stylesheet() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_dtd_and_other() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
+    factory.setAttribute(XMLConstants.DEFAULT_NS_PREFIX, "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_dtd_and_stylesheet_with_literals() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    factory.setAttribute("http://javax.xml.XMLConstants/property/accessExternalDTD", "");
+    factory.setAttribute("http://javax.xml.XMLConstants/property/accessExternalStylesheet", "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_dtd_only() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_stylesheet_only() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_dtd_and_stylesheet_with_non_empty_value() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "xxx");
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
+    return factory;
+  }
+
+  TransformerFactory setattribute_dtd_and_stylesheet_with_unknown_value(String value) {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, value);
+    factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, value);
+    return factory;
+  }
+}
+
+class Limitations {
+
+  TransformerFactory multiple_instances() {
+    TransformerFactory factory = TransformerFactory.newInstance();
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+    factory = TransformerFactory.newInstance(); // FN
+    return factory;
+  }
+
+  TransformerFactory constant_boolean_value() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant (FP)
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, BOOLEAN_TRUE);
+    return factory;
+  }
+
+  TransformerFactory cross_procedural() {
+    TransformerFactory factory = TransformerFactory.newInstance(); // Noncompliant (FP, would require symbolic execution)
+    enableSecureProcessing(factory);
+    return factory;
+  }
+
+  void enableSecureProcessing(TransformerFactory factory) {
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+  }
+}
diff --git a/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java b/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
index 43c7e1db4d..58a50dcf15 100755
--- a/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
+++ b/java-checks/src/test/files/checks/security/XmlExternalEntityProcessingCheck.java
@@ -1,8 +1,11 @@
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.parsers.SAXParserFactory;
+import org.xml.sax.XMLReader;
+import org.xml.sax.helpers.XMLReaderFactory;
+import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.XMLConstants;
 
-class Stax {
+class StaxTest {
 
   XMLInputFactory no_property() {
     XMLInputFactory factory = XMLInputFactory.newInstance(); // Noncompliant
@@ -53,31 +56,37 @@ XMLInputFactory dtd_with_unknown_value(Object value) {
 
 }
 
-class SAXParser {
+class SAXParserTest {
 
   SAXParserFactory no_property() {
     SAXParserFactory factory = SAXParserFactory.newInstance(); // Noncompliant
     return factory;
   }
 
-  SAXParserFactory secure_processing_true() {
+  SAXParserFactory secure_processing_set_to_true() {
     SAXParserFactory factory = SAXParserFactory.newInstance();
     factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
     return factory;
   }
 
-  SAXParserFactory secure_processing_false() {
+  SAXParserFactory secure_processing_set_to_false() {
     SAXParserFactory factory = SAXParserFactory.newInstance(); // Noncompliant
     factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);
     return factory;
   }
 
-  SAXParserFactory other_feature_set_to_true() {
+  SAXParserFactory secure_processing_with_literal_string_set_to_true() {
     SAXParserFactory factory = SAXParserFactory.newInstance();
     factory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);
     return factory;
   }
 
+  SAXParserFactory apache_feature_set_to_true() {
+    SAXParserFactory factory = SAXParserFactory.newInstance();
+    factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
+    return factory;
+  }
+
   SAXParserFactory other_feature_set_to_true() {
     SAXParserFactory factory = SAXParserFactory.newInstance(); // Noncompliant
     factory.setFeature("xxx", true);
@@ -85,3 +94,45 @@ SAXParserFactory other_feature_set_to_true() {
   }
 
 }
+
+class XMLReaderTest {
+
+  XMLReader no_property(XMLReaderFactory factory) {
+    XMLReader xmlReader = factory.createXMLReader(); // Noncompliant
+    return xmlReader;
+  }
+
+  XMLReader no_property(XMLReaderFactory factory) {
+    XMLReader xmlReader = factory.createXMLReader();
+    xmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+    return xmlReader;
+  }
+
+  XMLReader no_property(XMLReaderFactory factory) {
+    XMLReader xmlReader = factory.createXMLReader(); // Noncompliant
+    xmlReader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);
+    return xmlReader;
+  }
+
+}
+
+class DocumentBuilderFactoryTest {
+
+  DocumentBuilderFactory no_property() {
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Noncompliant
+    return factory;
+  }
+
+  DocumentBuilderFactory no_property() {
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
+    return factory;
+  }
+
+  DocumentBuilderFactory no_property() {
+    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // Noncompliant
+    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);
+    return factory;
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java
new file mode 100755
index 0000000000..1cc7d8ff3b
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/security/CryptographicKeySizeCheckTest.java
@@ -0,0 +1,42 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class CryptographicKeySizeCheckTest {
+
+  @Test
+  public void test_RSA() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java", new CryptographicKeySizeCheck());
+  }
+
+  @Test
+  public void test_Blowfish() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java", new CryptographicKeySizeCheck());
+  }
+
+  @Test
+  public void test_no_semantic() {
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/CryptographicKeySizeCheck/RSA.java", new CryptographicKeySizeCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/CryptographicKeySizeCheck/Blowfish.java", new CryptographicKeySizeCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/security/SecureXmlTransformerCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/security/SecureXmlTransformerCheckTest.java
new file mode 100755
index 0000000000..89357eb502
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/security/SecureXmlTransformerCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class SecureXmlTransformerCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/SecureXmlTransformerCheck.java", new SecureXmlTransformerCheck());
+  }
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
index 4b0fd08167..9024084720 100755
--- a/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
@@ -43,6 +43,7 @@
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.AnnotationTree;
+import org.sonar.plugins.java.api.tree.Arguments;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
@@ -52,6 +53,7 @@
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.ReturnStatementTree;
 import org.sonar.plugins.java.api.tree.SyntaxToken;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -68,6 +70,7 @@
 import static org.sonar.plugins.java.api.tree.Tree.Kind.CONSTRUCTOR;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.MEMBER_SELECT;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD_INVOCATION;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.NEW_CLASS;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS;
 import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS_ASSIGNMENT;
 import static org.sonar.ucfg.UCFGBuilder.call;
@@ -224,6 +227,9 @@ private void buildCall(Tree element, UCFGBuilder.BlockBuilder blockBuilder, Iden
     if (element.is(METHOD_INVOCATION)) {
       MethodInvocationTree methodInvocationTree = (MethodInvocationTree) element;
       buildMethodInvocation(blockBuilder, idGenerator, methodInvocationTree);
+    } else if (element.is(NEW_CLASS)) {
+      NewClassTree newClassTree = (NewClassTree) element;
+      buildConstructorInvocation(blockBuilder, idGenerator, newClassTree);
     } else if (element.is(PLUS, PLUS_ASSIGNMENT, ASSIGNMENT) && isString(((ExpressionTree) element).symbolType())) {
       if (element.is(PLUS)) {
         BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) element;
@@ -248,35 +254,48 @@ private void buildCall(Tree element, UCFGBuilder.BlockBuilder blockBuilder, Iden
     }
   }
 
-  private void buildMethodInvocation(UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator, MethodInvocationTree mit) {
-    if (mit.symbol().isUnknown()) {
+  private void buildConstructorInvocation(BlockBuilder blockBuilder, IdentifierGenerator idGenerator, NewClassTree tree) {
+    Symbol constructorSymbol = tree.constructorSymbol();
+    if (constructorSymbol.isUnknown()) {
       return;
     }
 
-    List<String> arguments = null;
+    if(isString(constructorSymbol.owner().type()) || tree.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
+      List<Expression> arguments = argumentIds(idGenerator, tree.arguments());
+      buildAssignCall(blockBuilder, idGenerator, arguments, tree, (Symbol.MethodSymbol) constructorSymbol);
+    }
+  }
+
+  private void buildMethodInvocation(UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator, MethodInvocationTree tree) {
+    if (tree.symbol().isUnknown()) {
+      return;
+    }
+
+    List<Expression> arguments = null;
 
-    if (isString(mit.symbol().owner().type())) {
+    if (isString(tree.symbol().owner().type())) {
       // myStr.myMethod(args) -> myMethod(myStr, args)
       arguments = new ArrayList<>();
-      if (mit.methodSelect().is(MEMBER_SELECT)) {
-        arguments.add(idGenerator.lookupIdFor(((MemberSelectExpressionTree) mit.methodSelect()).expression()));
+      if (tree.methodSelect().is(MEMBER_SELECT)) {
+        arguments.add(idGenerator.lookupExpressionFor(((MemberSelectExpressionTree) tree.methodSelect()).expression()));
       }
-      arguments.addAll(argumentIds(idGenerator, mit));
-    } else if (isString(mit.symbolType()) || mit.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
-      arguments = argumentIds(idGenerator, mit);
+      arguments.addAll(argumentIds(idGenerator, tree.arguments()));
+    } else if (isString(tree.symbolType()) || tree.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
+      arguments = argumentIds(idGenerator, tree.arguments());
     }
 
     if (arguments != null) {
-      String destination = idGenerator.newIdFor(mit);
-      blockBuilder.assignTo(variableWithId(destination),
-        UCFGBuilder.call(signatureFor((Symbol.MethodSymbol) mit.symbol()))
-          .withArgs(arguments.stream().map(UCFGBuilder::variableWithId).toArray(Expression.Variable[]::new)),
-        location(mit));
+      buildAssignCall(blockBuilder, idGenerator, arguments, tree, (Symbol.MethodSymbol) tree.symbol());
     }
   }
 
-  private static List<String> argumentIds(IdentifierGenerator idGenerator, MethodInvocationTree mit) {
-    return mit.arguments().stream().map(idGenerator::lookupIdFor).collect(Collectors.toList());
+  private void buildAssignCall(BlockBuilder blockBuilder, IdentifierGenerator idGenerator,  List<Expression> arguments, Tree tree, Symbol.MethodSymbol symbol) {
+    String destination = idGenerator.newIdFor(tree);
+    blockBuilder.assignTo(variableWithId(destination), UCFGBuilder.call(signatureFor(symbol)).withArgs(arguments.toArray(new Expression[0])), location(tree));
+  }
+
+  private static List<Expression> argumentIds(IdentifierGenerator idGenerator, Arguments arguments) {
+    return arguments.stream().map(idGenerator::lookupExpressionFor).collect(Collectors.toList());
   }
 
   private static String signatureFor(Symbol.MethodSymbol methodSymbol) {
diff --git a/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java b/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
index 30e7b8540d..ede19d6830 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/LiteralUtils.java
@@ -50,10 +50,10 @@ public static Integer intLiteralValue(ExpressionTree expression) {
   @CheckForNull
   private static Integer intLiteralValue(LiteralTree literal) {
     String literalValue = literal.value().replaceAll("_", "");
-    if (literalValue.startsWith("0x") || literalValue.startsWith("0b")) {
-      return null;
+    if (literalValue.startsWith("0b") || literalValue.startsWith("0B")) {
+      return Integer.valueOf(literalValue.substring(2), 2);
     }
-    return Integer.valueOf(literalValue);
+    return Integer.decode(literalValue);
   }
 
   @CheckForNull
@@ -70,6 +70,9 @@ public static Long longLiteralValue(ExpressionTree tree) {
       // long as hexadecimal can be written using underscore to separate groups
       value = value.replaceAll("\\_", "");
       try {
+        if (value.startsWith("0b") || value.startsWith("0B")) {
+          return sign * Long.valueOf(value.substring(2), 2);
+        }
         return sign * Long.decode(value);
       } catch (NumberFormatException e) {
         // Long.decode() may fail in case of very large long number written in hexadecimal. In such situation, we ignore the number.
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
index 11eaca23b4..d9eec87c59 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
@@ -109,6 +109,15 @@ private void complete(JavaSymbol.TypeJavaSymbol symbol) {
 
     if ((symbol.flags() & Flags.INTERFACE) == 0) {
       symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type.supertype, symbol));
+    } else {
+      // JLS9 - 15.12.1 : Used in form 'TypeName.super.foo()', where 'TypeName' is an interface. To support invocation
+      // of default methods from super-interfaces, 'TypeName' may also refer to a direct super-interface of the current
+      // class or interface. The method being invoked ('foo()') has to be searched in that super-interface.
+      symbol.members.enter(new JavaSymbol.VariableJavaSymbol(Flags.FINAL, "super", type, symbol));
+      // Note: The above "super" symbol will always be qualified when referenced. e.g. A.super.hashCode()
+      // because it's a compilation error to use unqualified "super" in default method. e.g. super.hashCode()
+      // Note: interface/class can extend/implement multiple interfaces containing default methods with the same
+      // signature. Mentioning the super-interfaces explicitly removes any ambiguity.
     }
 
     // Register default constructor
diff --git a/java-frontend/src/test/files/sym/references/SuperMethodCall.java b/java-frontend/src/test/files/sym/references/SuperMethodCall.java
new file mode 100755
index 0000000000..d63f9289f4
--- /dev/null
+++ b/java-frontend/src/test/files/sym/references/SuperMethodCall.java
@@ -0,0 +1,30 @@
+public interface A {
+  default String f() {
+    return "A";
+  }
+}
+
+public interface B {
+  default String f() {
+    return "B";
+  }
+}
+
+public class C {
+  public String f() {
+    return "C";
+  }
+}
+
+public class D extends C implements A, B {
+  public void call() {
+    f();
+  }
+  @Override
+  public String f() {
+    return super.f() +
+           A.super.f() +
+           B.super.f();
+  }
+
+}
diff --git a/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
index aa1f7c4a03..460c881739 100755
--- a/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
@@ -23,6 +23,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import org.junit.BeforeClass;
@@ -405,6 +406,34 @@ protected void serializeUCFG(MethodTree tree, CFG cfg) {
     UCFGJavaVisitor.scanFile(context);
   }
 
+  @Test
+  public void null_literal_should_produce_a_constant_expression() {
+    UCFG ucfg = createUCFG("class A {String foo(String s) {return foo(null);}}");
+    BasicBlock basicBlock = ucfg.entryBlocks().iterator().next();
+    Expression argExpression = basicBlock.calls().get(0).getArgExpressions().get(0);
+    assertThat(argExpression.isConstant()).isTrue();
+  }
+
+  @Test
+  public void string_literal_should_produce_a_constant_expression() {
+    UCFG ucfg = createUCFG("class A {String foo(String s) {return foo(\"plop\");}}");
+    BasicBlock basicBlock = ucfg.entryBlocks().iterator().next();
+    Expression argExpression = basicBlock.calls().get(0).getArgExpressions().get(0);
+    assertThat(argExpression.isConstant()).isTrue();
+  }
+
+  @Test
+  public void constructors_should_have_a_ucfg() {
+    UCFG ucfg = createUCFG("class A { Object foo(String s) {new A(s); new Object(); new Unknown(\"\"); return new String();} A(String s) {} }");
+    assertThat(ucfg.methodId()).isEqualTo("A#foo(Ljava/lang/String;)Ljava/lang/Object;");
+    List<Instruction.AssignCall> calls = ucfg.entryBlocks().iterator().next().calls();
+    assertThat(calls).hasSize(2);
+    Instruction.AssignCall assignCall0 = calls.get(0);
+    assertThat(assignCall0.getMethodId()).isEqualTo("A#<init>(Ljava/lang/String;)V");
+    Instruction.AssignCall assignCall1 = calls.get(1);
+    assertThat(assignCall1.getMethodId()).isEqualTo("java.lang.String#<init>()V");
+  }
+
   private CompilationUnitTree getCompilationUnitTreeWithSemantics(String source) {
     CompilationUnitTree cut = (CompilationUnitTree) JavaParser.createParser().parse(source);
     SemanticModel.createFor(cut, squidClassLoader);
diff --git a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
index 213f58b6d0..8408e3aa5b 100755
--- a/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/LiteralUtilsTest.java
@@ -70,6 +70,8 @@ public static void setUp() {
   int x6 = 0xff;
   int x7 = 0b0100;
   int x8 = 56_78;
+  int x9 = 0XFF;
+  int x10 = 0B1100110;
 
   long y1 = 42;
   long y2 = 42L;
@@ -87,6 +89,8 @@ public static void setUp() {
   long y14 = 0x7FFF_FFFF_FFFF_FFFFL;
   long y15 = 0b11010010_01101001_10010100_10010010;
   long y16 = 100_10;
+  long y17 = 0XFFL;
+  long y18 = 0B1100110L;
 
   String s1 = "";
   String s2 = " ";
@@ -104,8 +108,9 @@ public void private_constructor() throws Exception {
 
   @Test
   public void test_int_and_long_value() throws Exception {
-    Integer[] expectedIntegerValues = {42, -7, 3, null, null, null, null, 5678};
-    Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 255L, null, null, null, Long.MAX_VALUE, Long.MAX_VALUE, null, 10010L};
+    Integer[] expectedIntegerValues = {42, -7, 3, null, null, 0xff, 0b0100, 5678, 0xFF, 0b1100110};
+    Long[] expectedLongValues = {42L, 42L, -7L, -7L, +3L, +3L, null, null, 0xFFL, null, null, null,
+      Long.MAX_VALUE, Long.MAX_VALUE, 0b11010010_01101001_10010100_10010010L, 10010L, 0xFFL, 0b1100110L};
     int i = 0;
     int j = 0;
 
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
index 56943d84d3..6adc95ff8d 100755
--- a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
@@ -383,7 +383,7 @@ public void InterfaceDeclaration() {
       result.symbol("FirstInterface").type,
       result.symbol("SecondInterface").type);
     assertThat(interfaceSymbol.members.lookup("this")).hasSize(1);
-    assertThat(interfaceSymbol.members.lookup("super")).isEmpty();
+    assertThat(interfaceSymbol.members.lookup("super")).hasSize(1);
 
     JavaSymbol.VariableJavaSymbol variableSymbol = (JavaSymbol.VariableJavaSymbol) result.symbol("FIRST_CONSTANT");
     assertThat(variableSymbol.owner()).isSameAs(interfaceSymbol);
@@ -1110,6 +1110,42 @@ public void MethodCall() {
 
   }
 
+  @Test
+  public void SuperMethodCall() {
+    Result result = Result.createFor("references/SuperMethodCall");
+
+    JavaSymbol fOfD = result.reference(21, 5);
+    assertThat(fOfD.name()).isEqualTo("f");
+    assertThat(fOfD.owner().name()).isEqualTo("D");
+
+    JavaSymbol superOfD = result.reference(25, 12);
+    assertThat(superOfD.name()).isEqualTo("super");
+    assertThat(superOfD.isVariableSymbol()).isTrue();
+    assertThat(superOfD.type().fullyQualifiedName()).isEqualTo("C");
+    assertThat(superOfD.owner().name()).isEqualTo("D");
+
+    JavaSymbol fOfC = result.reference(25, 18);
+    assertThat(fOfC.name()).isEqualTo("f");
+    assertThat(fOfC.owner().name()).isEqualTo("C");
+
+    JavaSymbol refA = result.reference(26, 12);
+    assertThat(refA.name()).isEqualTo("A");
+    assertThat(refA.isTypeSymbol()).isTrue();
+
+    JavaSymbol superOfA = result.reference(26, 14);
+    assertThat(superOfA.name()).isEqualTo("super");
+    assertThat(superOfA.isVariableSymbol()).isTrue();
+    assertThat(superOfA.type().fullyQualifiedName()).isEqualTo("A");
+
+    JavaSymbol fOfA = result.reference(26, 20);
+    assertThat(fOfA.name()).isEqualTo("f");
+    assertThat(fOfA.owner().name()).isEqualTo("A");
+
+    JavaSymbol fOfB = result.reference(27, 20);
+    assertThat(fOfB.name()).isEqualTo("f");
+    assertThat(fOfB.owner().name()).isEqualTo("B");
+  }
+
   @Test
   public void FieldTypes() {
     Result result = Result.createFor("FieldTypes");
