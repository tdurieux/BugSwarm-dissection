diff --git a/verktyg/http/basic.py b/verktyg/http/basic.py
index 9a287f2..ad9b8db 100644
--- a/verktyg/http/basic.py
+++ b/verktyg/http/basic.py
@@ -174,8 +174,10 @@ def __getitem__(self, key, _get_mode=False):
         raise exceptions.BadRequestKeyError(key)
 
     def __eq__(self, other):
-        return other.__class__ is self.__class__ and \
+        return (
+            other.__class__ is self.__class__ and
             set(other._list) == set(self._list)
+        )
 
     def __ne__(self, other):
         return not self.__eq__(other)
@@ -710,8 +712,10 @@ def parse_date(value):
                     year += 2000
                 elif year >= 69 and year <= 99:
                     year += 1900
-                return datetime(*((year,) + t[1:7])) - \
+                return (
+                    datetime(*((year,) + t[1:7])) -
                     timedelta(seconds=t[-1] or 0)
+                )
             except (ValueError, OverflowError):
                 return None
 
@@ -854,8 +858,7 @@ def __init__(self, stream=None, filename=None, name=None,
 
     def _parse_content_type(self):
         if not hasattr(self, '_parsed_content_type'):
-            self._parsed_content_type = \
-                parse_options_header(self.content_type)
+            self._parsed_content_type = parse_options_header(self.content_type)
 
     @property
     def content_type(self):
diff --git a/verktyg/http/cache_control.py b/verktyg/http/cache_control.py
index 318012b..e35cdc9 100644
--- a/verktyg/http/cache_control.py
+++ b/verktyg/http/cache_control.py
@@ -159,8 +159,8 @@ class ContentRange(object):
     """
 
     def __init__(self, units, start, stop, length=None, on_update=None):
-        assert is_byte_range_valid(start, stop, length), \
-            'Bad range provided'
+        if not is_byte_range_valid(start, stop, length):
+            raise ValueError('Bad range provided')
         self.on_update = on_update
         self.set(start, stop, length, units)
 
@@ -186,8 +186,8 @@ def fset(self, value):
 
     def set(self, start, stop, length=None, units='bytes'):
         """Simple method to update the ranges."""
-        assert is_byte_range_valid(start, stop, length), \
-            'Bad range provided'
+        if not is_byte_range_valid(start, stop, length):
+            raise ValueError('Bad range provided')
         self._units = units
         self._start = start
         self._stop = stop
diff --git a/verktyg/requests.py b/verktyg/requests.py
index ecfe6ec..ade1d55 100644
--- a/verktyg/requests.py
+++ b/verktyg/requests.py
@@ -709,8 +709,9 @@ def content_length(self):
 
     def _parse_content_type(self):
         if not hasattr(self, '_parsed_content_type'):
-            self._parsed_content_type = \
-                parse_options_header(self.environ.get('CONTENT_TYPE', ''))
+            self._parsed_content_type = parse_options_header(
+                self.environ.get('CONTENT_TYPE', '')
+            )
 
     @property
     def mimetype(self):
diff --git a/verktyg/responses.py b/verktyg/responses.py
index 0625c8d..007968b 100644
--- a/verktyg/responses.py
+++ b/verktyg/responses.py
@@ -516,8 +516,10 @@ def get_wsgi_headers(self, environ):
                 headers['Location'] = location
 
         # make sure the content location is a URL
-        if content_location is not None and \
-           isinstance(content_location, str):
+        if (
+            content_location is not None and
+            isinstance(content_location, str)
+        ):
             headers['Content-Location'] = iri_to_uri(content_location)
 
         # remove entity headers and set content length to zero if needed.
@@ -534,8 +536,10 @@ def get_wsgi_headers(self, environ):
         # flattening the iterator or encoding of unicode strings in
         # the response.  We however should not do that if we have a 304
         # response.
-        if self.automatically_set_content_length and \
-           self.is_sequence and content_length is None and status != 304:
+        if (
+            self.automatically_set_content_length and
+            self.is_sequence and content_length is None and status != 304
+        ):
             try:
                 content_length = sum(len(to_bytes(x, 'ascii'))
                                      for x in self.response)
@@ -561,8 +565,10 @@ def get_app_iter(self, environ):
         :return: a response iterable.
         """
         status = self.status_code
-        if environ['REQUEST_METHOD'] == 'HEAD' or \
-           100 <= status < 200 or status in (204, 304):
+        if (
+            environ['REQUEST_METHOD'] == 'HEAD' or
+            100 <= status < 200 or status in (204, 304)
+        ):
             iterable = ()
         elif self.direct_passthrough:
             if __debug__:
@@ -666,8 +672,10 @@ def make_conditional(self, request_or_environ):
             # wsgiref.
             if 'date' not in self.headers:
                 self.headers['Date'] = http_date()
-            if self.automatically_set_content_length and \
-                    'content-length' not in self.headers:
+            if (
+                self.automatically_set_content_length and
+                'content-length' not in self.headers
+            ):
                 length = self.calculate_content_length()
                 if length is not None:
                     self.headers['Content-Length'] = length
@@ -808,8 +816,9 @@ def _set_mimetype(self, value):
 
     def _get_mimetype_params(self):
         def on_update(d):
-            self.headers['Content-Type'] = \
-                dump_options_header(self.mimetype, d)
+            self.headers['Content-Type'] = dump_options_header(
+                self.mimetype, d
+            )
         d = parse_options_header(self.headers.get('content-type', ''))[1]
         return CallbackDict(d, on_update)
 
@@ -933,8 +942,11 @@ def fset(self, value):
         associated with the resource. An Allow header field MUST be
         present in a 405 (Method Not Allowed) response.''')
 
-    del _set_property, _get_mimetype, _set_mimetype, _get_retry_after, \
-        _set_retry_after
+    del (
+        _set_property,
+        _get_mimetype, _set_mimetype,
+        _get_retry_after, _set_retry_after
+    )
 
 
 class WWWAuthenticateMixin(object):
diff --git a/verktyg/routing.py b/verktyg/routing.py
index 64e25a7..056b744 100644
--- a/verktyg/routing.py
+++ b/verktyg/routing.py
@@ -650,8 +650,10 @@ def match(self, path):
                 # slash and strict slashes enabled. raise an exception that
                 # tells the router to redirect to the same url but with a
                 # trailing slash
-                if self.strict_slashes and not self.is_leaf and \
-                   not groups.pop('__suffix__'):
+                if (
+                    self.strict_slashes and not self.is_leaf and
+                    not groups.pop('__suffix__')
+                ):
                     raise RequestSlash()
                 # if we are not in strict slashes mode we have to remove
                 # a __suffix__
@@ -712,9 +714,11 @@ def provides_defaults_for(self, route):
 
         :internal:
         """
-        return not self.build_only and self.defaults and \
-            self.endpoint == route.endpoint and self != route and \
+        return (
+            not self.build_only and self.defaults and
+            self.endpoint == route.endpoint and self != route and
             self.arguments == route.arguments
+        )
 
     def suitable_for(self, values):
         """Check if the dict of values has enough data for url generation.
@@ -759,8 +763,10 @@ def build_compare_key(self):
 
         :internal:
         """
-        return self.alias and 1 or 0, -len(self.arguments), \
+        return (
+            self.alias and 1 or 0, -len(self.arguments),
             -len(self.defaults or ())
+        )
 
     def __eq__(self, other):
         return (
@@ -887,8 +893,10 @@ def to_python(self, value):
         if (self.fixed_digits and len(value) != self.fixed_digits):
             raise ValidationError()
         value = self.num_convert(value)
-        if (self.min is not None and value < self.min) or \
-           (self.max is not None and value > self.max):
+        if (
+            (self.min is not None and value < self.min) or
+            (self.max is not None and value > self.max)
+        ):
             raise ValidationError()
         return value
 
@@ -943,8 +951,10 @@ class UUIDConverter(BaseConverter):
 
     :param router: the :class:`URLMap`.
     """
-    regex = r'[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-' \
-            r'[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}'
+    regex = (
+        r'[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-'
+        r'[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}'
+    )
 
     def to_python(self, value):
         return uuid.UUID(value)
@@ -1140,8 +1150,10 @@ def bind_to_environ(self, environ, server_name=None, subdomain=None):
                 server_name = environ['HTTP_HOST']
             else:
                 server_name = environ['SERVER_NAME']
-                if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
-                   in (('https', '443'), ('http', '80')):
+                if (
+                    (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not
+                    in (('https', '443'), ('http', '80'))
+                ):
                     server_name += ':' + environ['SERVER_PORT']
         elif subdomain is None and not self.host_matching:
             server_name = server_name.lower()
@@ -1149,8 +1161,10 @@ def bind_to_environ(self, environ, server_name=None, subdomain=None):
                 wsgi_server_name = environ.get('HTTP_HOST')
             else:
                 wsgi_server_name = environ.get('SERVER_NAME')
-                if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
-                   in (('https', '443'), ('http', '80')):
+                if (
+                    (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not
+                    in (('https', '443'), ('http', '80'))
+                ):
                     wsgi_server_name += ':' + environ['SERVER_PORT']
             wsgi_server_name = wsgi_server_name.lower()
             cur_server_name = wsgi_server_name.split('.')
@@ -1372,8 +1386,10 @@ def get_default_redirect(self, route, values, query_args):
             # with the highest priority up for building.
             if r is route:
                 break
-            if r.provides_defaults_for(route) and \
-               r.suitable_for(values):
+            if (
+                r.provides_defaults_for(route) and
+                r.suitable_for(values)
+            ):
                 values.update(r.defaults)
                 domain_part, path = r.build(values)
                 return self.make_redirect_url(
@@ -1405,8 +1421,9 @@ def make_alias_redirect_url(self, path, endpoint, values, query_args):
                          force_external=True)
         if query_args:
             url += '?' + self.encode_query_args(query_args)
-        assert url != path, 'detected invalid alias setting.  No canonical ' \
-            'URL found'
+        assert url != path, (
+            'detected invalid alias setting.  No canonical URL found'
+        )
         return url
 
     def build(self, endpoint, values=None, force_external=False,
@@ -1479,8 +1496,10 @@ def build(self, endpoint, values=None, force_external=False,
         # shortcut this.
         if not force_external:
             host_matching = self.router.host_matching
-            if (host_matching and host == self.server_name) or \
-               (not host_matching and domain_part == self.subdomain):
+            if (
+                (host_matching and host == self.server_name) or
+                (not host_matching and domain_part == self.subdomain)
+            ):
                 return str(urljoin(self.script_name, './' + path.lstrip('/')))
 
         return urlunparse(ParseResult(
diff --git a/verktyg/test.py b/verktyg/test.py
index b4c6dc4..ff0a49b 100644
--- a/verktyg/test.py
+++ b/verktyg/test.py
@@ -80,10 +80,10 @@ def write(string):
                 filename = getattr(value, 'filename',
                                    getattr(value, 'name', None))
                 content_type = getattr(value, 'content_type', None)
+                if content_type is None and filename:
+                    content_type = mimetypes.guess_type(filename)[0]
                 if content_type is None:
-                    content_type = filename and \
-                        mimetypes.guess_type(filename)[0] or \
-                        'application/octet-stream'
+                    content_type = 'application/octet-stream'
                 if filename is not None:
                     write('; filename="%s"\r\n' % filename)
                 else:
@@ -223,8 +223,9 @@ def add_file(self, name, file, filename=None, content_type=None):
                     filename = file
                 file = open(file, 'rb')
             if filename and content_type is None:
-                content_type = mimetypes.guess_type(filename)[0] or \
-                    'application/octet-stream'
+                content_type = mimetypes.guess_type(filename)[0]
+            if content_type is None:
+                content_type = 'application/octet-stream'
             value = FileStorage(file, filename, name, content_type)
 
         self.add(name, value)
@@ -353,8 +354,10 @@ def __init__(self, path='/', base_url=None, query_string=None,
                     self.content_length = len(data)
             else:
                 for key, value in _iter_data(data):
-                    if isinstance(value, (tuple, dict)) or \
-                       hasattr(value, 'read'):
+                    if (
+                        isinstance(value, (tuple, dict)) or
+                        hasattr(value, 'read')
+                    ):
                         self._add_file_from_data(key, value)
                     else:
                         self.form.setlistdefault(key).append(value)
@@ -548,8 +551,9 @@ def get_environ(self):
             content_length = end_pos - start_pos
         elif content_type == 'multipart/form-data':
             values = CombinedMultiDict([self.form, self.files])
-            input_stream, content_length, boundary = \
+            input_stream, content_length, boundary = (
                 stream_encode_multipart(values, charset=self.charset)
+            )
             content_type += '; boundary="%s"' % boundary
         elif content_type == 'application/x-www-form-urlencoded':
             values = url_encode(self.form, charset=self.charset)
@@ -768,8 +772,10 @@ def open(self, *args, **kwargs):
         redirect_chain = []
         while 1:
             status_code = int(response[1].split(None, 1)[0])
-            if status_code not in (301, 302, 303, 305, 307) \
-               or not follow_redirects:
+            if (
+                status_code not in (301, 302, 303, 305, 307) or
+                not follow_redirects
+            ):
                 break
             new_location = response[2]['location']
 
diff --git a/verktyg/testsuite/test_wsgi.py b/verktyg/testsuite/test_wsgi.py
index 0d22fe9..c0372a5 100644
--- a/verktyg/testsuite/test_wsgi.py
+++ b/verktyg/testsuite/test_wsgi.py
@@ -344,8 +344,10 @@ def test_multi_part_line_breaks(self):
             ]
         )
 
-        data = 'abc\r\nThis line is broken by the buffer length.' \
+        data = (
+            'abc\r\nThis line is broken by the buffer length.'
             '\r\nFoo bar baz'
+        )
         test_stream = StringIO(data)
         lines = list(wsgi.make_line_iter(test_stream, limit=len(data),
                                          buffer_size=24))
@@ -369,8 +371,10 @@ def test_multi_part_line_breaks_bytes(self):
             ]
         )
 
-        data = b'abc\r\nThis line is broken by the buffer length.' \
+        data = (
+            b'abc\r\nThis line is broken by the buffer length.'
             b'\r\nFoo bar baz'
+        )
         test_stream = BytesIO(data)
         lines = list(wsgi.make_line_iter(test_stream, limit=len(data),
                                          buffer_size=24))
diff --git a/verktyg/utils.py b/verktyg/utils.py
index 9735186..2ca1ae0 100644
--- a/verktyg/utils.py
+++ b/verktyg/utils.py
@@ -115,10 +115,11 @@ def get_content_type(mimetype, charset):
     :return:
         The content type.
     """
-    if mimetype.startswith('text/') or \
-       mimetype == 'application/xml' or \
-       (mimetype.startswith('application/') and
-            mimetype.endswith('+xml')):
+    if (
+        mimetype.startswith('text/') or
+        mimetype == 'application/xml' or
+        (mimetype.startswith('application/') and mimetype.endswith('+xml'))
+    ):
         mimetype += '; charset=' + charset
     return mimetype
 
@@ -159,8 +160,10 @@ def secure_filename(filename):
     # on nt a couple of special files are present in each folder.  We
     # have to ensure that the target file is not such a filename.  In
     # this case we prepend an underline
-    if os.name == 'nt' and filename and \
-       filename.split('.')[0].upper() in _windows_device_files:
+    if (
+        os.name == 'nt' and filename and
+        filename.split('.')[0].upper() in _windows_device_files
+    ):
         filename = '_' + filename
 
     return filename
diff --git a/verktyg/wsgi.py b/verktyg/wsgi.py
index 4ae12b2..11452bd 100644
--- a/verktyg/wsgi.py
+++ b/verktyg/wsgi.py
@@ -152,8 +152,10 @@ def get_host(environ, trusted_hosts=None):
         rv = environ['HTTP_HOST']
     else:
         rv = environ['SERVER_NAME']
-        if (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not \
-           in (('https', '443'), ('http', '80')):
+        if (
+            (environ['wsgi.url_scheme'], environ['SERVER_PORT']) not
+            in (('https', '443'), ('http', '80'))
+        ):
             rv += ':' + environ['SERVER_PORT']
     if trusted_hosts is not None:
         if not host_is_trusted(rv, trusted_hosts):
@@ -366,8 +368,10 @@ def _normalize_netloc(scheme, netloc):
         parts = netloc.split(u'@', 1)[-1].split(u':', 1)
         if len(parts) == 2:
             netloc, port = parts
-            if (scheme == u'http' and port == u'80') or \
-               (scheme == u'https' and port == u'443'):
+            if (
+                (scheme == u'http' and port == u'80') or
+                (scheme == u'https' and port == u'443')
+            ):
                 port = None
         else:
             netloc = parts[0]
@@ -383,8 +387,9 @@ def _normalize_netloc(scheme, netloc):
                                              root_only=True)
     base_iri = uri_to_iri(environ_or_baseurl, charset, errors)
     base_scheme, base_netloc, base_path = url_parse(base_iri)[:3]
-    cur_scheme, cur_netloc, cur_path, = \
-        url_parse(url_join(base_iri, path))[:3]
+    cur_scheme, cur_netloc, cur_path, = url_parse(
+        url_join(base_iri, path)
+    )[:3]
 
     # normalize the network location
     base_netloc = _normalize_netloc(base_scheme, base_netloc)
@@ -439,8 +444,10 @@ def __len__(self):
 
     def __iter__(self):
         for key, value in self.environ.items():
-            if key.startswith('HTTP_') and key not in \
-               ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH'):
+            if (
+                key.startswith('HTTP_') and
+                key not in ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH')
+            ):
                 yield (key[5:].replace('_', '-').title(),
                        unicodify_header_value(value))
             elif key in ('CONTENT_TYPE', 'CONTENT_LENGTH'):
@@ -542,8 +549,9 @@ def get_file_loader(self, filename):
         return lambda x: (os.path.basename(filename), self._opener(filename))
 
     def get_package_loader(self, package, package_path):
-        from pkg_resources import DefaultProvider, ResourceManager, \
-            get_provider
+        from pkg_resources import (
+            DefaultProvider, ResourceManager, get_provider
+        )
         loadtime = datetime.utcnow()
         provider = get_provider(package)
         manager = ResourceManager()
