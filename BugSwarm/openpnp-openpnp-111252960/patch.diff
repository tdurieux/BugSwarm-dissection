diff --git a/OpenPnP_Eclipse_Formatter.xml b/OpenPnP_Eclipse_Formatter.xml
new file mode 100755
index 0000000000..f7d9180a1e
--- /dev/null
+++ b/OpenPnP_Eclipse_Formatter.xml
@@ -0,0 +1,295 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<profiles version="12">
+<profile kind="CodeFormatterProfile" name="OpenPnP" version="12">
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_ellipsis" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_imports" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.disabling_tag" value="@formatter:off"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_enum_constants" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_imports" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_after_package" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_root_tags" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.enabling_tag" value="@formatter:on"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.enumIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_block" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.line_length" value="100"/>
+<setting id="org.eclipse.jdt.core.formatter.use_on_off_tags" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_method_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_binary_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_lambda_body" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.compact_else_if" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.compiler.problem.assertIdentifier" value="error"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_binary_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve" value="3"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_ellipsis" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_line_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.align_type_members_on_columns" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_assignment" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_conditional_expression" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_block_in_case" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while" value="insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode" value="enabled"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_method_declaration" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.join_wrapped_lines" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_resources_in_try" value="80"/>
+<setting id="org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column" value="false"/>
+<setting id="org.eclipse.jdt.core.compiler.source" value="1.8"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_source_code" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_field" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_method" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.codegen.targetPlatform" value="1.8"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_switch" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_html" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_compact_if" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_empty_lines" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_unary_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_label" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_member_type" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.format_block_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_statements_compare_to_body" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.alignment_for_multiple_fields" value="16"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_array_initializer" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_before_binary_operator" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.compiler.compliance" value="1.8"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_enum_constant" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.brace_position_for_type_declaration" value="end_of_line"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_before_package" value="0"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.join_lines_in_comments" value="true"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="false"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="insert"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
+<setting id="org.eclipse.jdt.core.formatter.lineSplit" value="100"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation" value="do not insert"/>
+<setting id="org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch" value="insert"/>
+</profile>
+</profiles>
diff --git a/pom.xml b/pom.xml
index 51181c00a6..2507b606b6 100755
--- a/pom.xml
+++ b/pom.xml
@@ -16,6 +16,11 @@
 		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 	</properties>
 	<dependencies>
+                <dependency>
+                                <groupId>com.github.sarxos</groupId>
+                                <artifactId>webcam-capture</artifactId>
+                                <version>0.3.10</version>
+                </dependency>
                 <dependency>
                         <groupId>org.ostermiller</groupId>
                         <artifactId>utils</artifactId>
@@ -118,6 +123,11 @@
 		  <version>0.1.9</version>
 		  <scope>test</scope>
 		</dependency>
+		<dependency>
+			<groupId>org.tros</groupId>
+			<artifactId>l2fprod-properties-editor</artifactId>
+			<version>1.0.3</version>
+		</dependency>
 	</dependencies>
 	<build>
 		<plugins>
diff --git a/src/main/java/org/firepick/driver/FireStepDriver.java b/src/main/java/org/firepick/driver/FireStepDriver.java
index 971f45615a..114c34eaba 100755
--- a/src/main/java/org/firepick/driver/FireStepDriver.java
+++ b/src/main/java/org/firepick/driver/FireStepDriver.java
@@ -1,28 +1,30 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
-
-// This file is intended to support the FireStep motion controller, created by Karl Lew (karl@firepick.org).
-// More information about the FireStep controller can be found at https://github.com/firepick1/firestep
-// Note that this implementation currently only supports FirePick Delta, which has rotational delta kinematics.
-// It should be trivial to add conditional hooks to enable or disable or switch kinematics for other configurations.
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
+
+// This file is intended to support the FireStep motion controller, created by Karl Lew
+// (karl@firepick.org).
+// More information about the FireStep controller can be found at
+// https://github.com/firepick1/firestep
+// Note that this implementation currently only supports FirePick Delta, which has rotational delta
+// kinematics.
+// It should be trivial to add conditional hooks to enable or disable or switch kinematics for other
+// configurations.
 // - Neil Jansen (njansen1@gmail.com) 7/1/2014
 
 package org.firepick.driver;
@@ -54,462 +56,486 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-import com.google.gson.JsonSyntaxException;
-
 
 public class FireStepDriver extends AbstractSerialPortDriver implements Runnable {
-	private static final Logger logger = LoggerFactory.getLogger(FireStepDriver.class);
-	private static final double minimumRequiredVersion = 1.0;
-	
-	// NOTE: This is ignored out because FireStep doesn't use feed rates per se.. it just does everything rather quickly and smoothly.
-	@Attribute
-	private double feedRateMmPerMinute;
-	
-	//@Attribute
-	private double nozzleStepsPerDegree =  8.888888888;
-	private boolean nozzleEnabled = false;
-	private boolean powerSupplyOn = false;
-	private RotatableDeltaKinematicsCalculator deltaCalc = new RotatableDeltaKinematicsCalculator();
-	
-	private double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-	private String connectedVersion;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
-	    if (enabled) {
-	        if (!connected) {
-	            try {
-	                connect();
-	            }
-	            catch (Exception e) {
-	                e.printStackTrace();
-	                throw e;
-	            }
-	        }
-	        enableVacuumPump(false);              		// Turn the vacuum pump OFF
-	        enablePowerSupply(true);              		// Turn power supply ON
-	        if (powerSupplyOn)					  		// Exception should catch but guard just in case
-	        {
-				Thread.sleep(500,0);                	// Delay for a bit, wait for power supply to stabilize.
-				setXyzMotorEnable(true);				// Enable power for XYZ stepper motors
-	    		enableEndEffectorRingLight(true); 		// Turn off down-looking LED ring light
-				Thread.sleep(50,0);                 	// Delay for a bit, wait for power supply to stabilize.
-		        home(null);                         	// home the machine
-	        }
-			
-	    } //if (enabled)
-	    else{
-	    	if (connected)
-	    	{
-	    		enableEndEffectorRingLight(false); 		// Turn off down-looking LED ring light
-	    		enableUpLookingRingLight(false);   		// Turn off up-looking LED ring light
-	    		if (powerSupplyOn)
-	    		{
-			        home(null);                        	// home the machine
-			        enableVacuumPump(false);           	// Turn the vacuum pump OFF
-					setXyzMotorEnable(false);  			// Disable power for XYZ stepper motors
-			        enablePowerSupply(false);          	// Turn off the power supply
-	    		}
-	    	}
-	    }
-	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, boolean on)
-			throws Exception {
-		if (actuator.getIndex() == 0) {
-			//TODO: Currently disabled... We don't have a pin to assign this to
-		}
-	}
-	
-	@Override
-	public void home(ReferenceHead head) throws Exception {
-		RawStepTriplet rs = deltaCalc.getHomePosRaw();
-		sendJsonCommand(String.format("{'hom':{'x':%d,'y':%d,'z':%d}}", rs.x, rs.y, rs.z), 10000);
-		
-		Location homLoc = deltaCalc.getHomePosCartesian();
-		logger.debug(String.format("Home position: X=%.2f, Y=%.2f, Z=%.2f",homLoc.getX(),homLoc.getY(),homLoc.getZ() ));
-		x = homLoc.getX();
-		y = homLoc.getY();
-		z = homLoc.getZ();
-		//TODO: Fire off head event to get the DRO to update to the new values
-	}
-	
-	@Override
-	public Location getLocation(ReferenceHeadMountable hm) {
-		//TODO: Request raw step positions from FireStep, do forward delta kinematics, throw exception if they don't match this class's Cartesian pos.
-		return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
-	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, double value)
-	  throws Exception {
-	  	//dwell();
-	    // TODO Auto-generated method stub
-	}
-	
-	@Override
-	public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-			throws Exception {
-	    location = location.subtract(hm.getHeadOffsets());
-	    location = location.convertToUnits(LengthUnit.Millimeters);
-	    
-	    int rotSteps = 0;
-	    RawStepTriplet rs = new RawStepTriplet(0,0,0);
-	    boolean moveXyz = false;
-	    boolean moveRot = false;
-	    
-	    //Check if we've rotated
-	    if (Math.abs(location.getRotation() - c) >= 0.01)
-	    {
-	    	moveRot = true;
-		    //Convert the rotation axis from degrees to steps
-		    rotSteps = (int)(location.getRotation() * nozzleStepsPerDegree + 0.5d);
-		    if ((rotSteps >= 32000) || (rotSteps <= -32000)) {
-		    	throw new Error(String.format("FireStep: Rotation axis raw position cannot exceed +/- 32000 steps",rotSteps));
-		    }
-	    }
-	    
-	    //Check if we've moved in XYZ
-	    Location currentLoc = new Location(LengthUnit.Millimeters, x, y, z, 0);
-	    if (Math.abs(location.getXyzDistanceTo(currentLoc)) >= 0.01) {
-	    	moveXyz = true;
-		    logger.debug(String.format("moveTo Cartesian: X: %.3f, Y: %.3f, Z: %.3f",location.getX(), location.getY(),location.getZ() ));
-		    
-		    // Calculate delta kinematics (returns angles)
-		    AngleTriplet angles = deltaCalc.calculateDelta(location);
-		    logger.debug(String.format("moveTo Delta: X: %.3f, Y: %.3f, Z: %.3f",angles.x, angles.y,angles.z ));
-		    
-		    // Convert angles into raw steps
-		    rs = deltaCalc.getRawSteps(angles);
-		    logger.debug(String.format("moveTo RawSteps: X: %d, Y: %d, Z: %d",rs.x, rs.y,rs.z ));
-	    }
-	    
-	    
-	    // Get feedrate in raw steps
-	    // Note that speed is defined by (maximum feed rate * speed) where speed is greater than 0 and typically less than or equal to 1. 
-	    // A speed of 0 means to move at the minimum possible speed.
-	    //TODO: Set feedrate based in raw steps, based off of 'feedRateMmPerMinute' and 'speed'
-	    // 'mv' is maximum velocity (pulses/second), and the default is 12800.
-
-	    int rawFeedrate = 12800; //12800 is FireStep's default feedrate
-	    rawFeedrate = (int)((double)rawFeedrate * speed); //Multiply rawFeedrate by speed, which should be 0 to 1
-	    if (moveXyz){
-	    	if (moveRot){ // Cartesian move with rotation.  Feedrate is (TBD)
-	    		logger.debug(String.format("moveTo: Cartesian move with rotation, feedrate=%d steps/second",rawFeedrate));
-	    		setRotMotorEnable(true);
-	    		sendJsonCommand(String.format("{'mov':{'x':%d,'y':%d,'z':%d, 'a':%d,'mv':%d}}",rs.x, rs.y, rs.z, rotSteps, rawFeedrate), 10000);
-	    	}
-	    	else{         // Cartesian move with no rotation.  Feedrate is just the cartesian feedrate
-	    		logger.debug(String.format("moveTo: Cartesian move, feedrate=%d steps/second",rawFeedrate));
-	    		sendJsonCommand(String.format("{'mov':{'x':%d,'y':%d,'z':%d,'mv':%d}}",rs.x, rs.y, rs.z, rawFeedrate), 10000);
-	    	}
-	    }
-	    else {
-	    	if (moveRot){ // Rotation, no Cartesian move.  Feedrate is just the rotation feedrate
-	    		setRotMotorEnable(true);
-	    		logger.debug(String.format("moveTo: Rotation move, feedrate=%d steps/second",rawFeedrate));
-	    		sendJsonCommand(String.format("{'mov':{'a':%d,'mv':%d}}",rotSteps, rawFeedrate), 10000);
-	    	}
-	    	else{         // No move, nothing to do
-	    		logger.debug("moveTo: No move, nothing to do");
-	    	}
-	    }
-	    	
-	    if (!Double.isNaN(location.getX())) {
-	        this.x = location.getX();
-	    }
-	    if (!Double.isNaN(location.getY())) {
-	        this.y = location.getY();
-	    }
-	    if (!Double.isNaN(location.getZ())) {
-	        this.z = location.getZ();
-	    }
-	    if (!Double.isNaN(location.getRotation())) {
-	        this.c = location.getRotation();
-	    }
-	}
-	
-	
-	@Override
-	public void pick(ReferenceNozzle nozzle) throws Exception {
-		setRotMotorEnable(true); // Enable the nozzle rotation
-		enableVacuumPump(true);  // Enable the pump
-	}
-	
-	@Override
-	public void place(ReferenceNozzle nozzle) throws Exception {
-		enableVacuumPump(false);
-		setRotMotorEnable(false);
-	}
-	
-	public synchronized void connect()
-			throws Exception {
-	    super.connect();
-	
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Grbl and we'll start getting some data. On others, Grbl may already
-		 * be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a change to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for FireStep to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-	
-		connectedVersion = "";
-		connected = true;
-		processStatusResponses(responses);
-	
-		for (int i = 0; i < 5 && !connected; i++) {
-			sendJsonCommand("{'sys':''}",100);
-		}
-		
-	if (!connected)  {
-			throw new Error(
-				String.format("Unable to receive connection response from FireStep. Check your port and baud rate, and that you are running at least version %f of Marlin", 
-						minimumRequiredVersion));
-		}
-		
-		//TODO: Commenting this out for now. Will implement version checks once we get the prototoype working.
-		//if (connectedVersion < minimumRequiredVersion) {
-		//	throw new Error(String.format("This driver requires Marlin version %.2f or higher. You are running version %.2f", minimumRequiredVersion, connectedVersion));
-		//}
-		
-	    //TODO: Allow configuration of modular tools 
-		setXyzMotorEnable(false);    // Disable all motors
-		setMotorDirection(true,true,false); // Set all motor directions to 'normal'
-		setHomingSpeed(200);				// Set the homing speed to something slower than default
-		sendJsonCommand("{'ape':34}", 100); // Set the enable pin for axis 'a' to tool 4 (this is an ugly hack and should go away)
-		// Turn off the stepper drivers
-		setEnabled(false);
-	}
-	
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
-		try {
-		    super.disconnect();
-	    }
-	    catch (Exception e) {
-	        logger.error("disconnect()", e);
-	    }
-		disconnectRequested = false;
-	}
-	
-	private void setMotorDirection(boolean xyz, boolean rot, boolean enable) throws Exception {
-	    logger.debug(String.format("%s%s Stepper motor Direction set to %s", xyz?"XYZ":"", rot?"A":"", enable?"enabled":"disabled" ));
-	    sendFireStepConfig(xyz, rot, "dh", enable?"true":"false");
-	}
-
-	private void setXyzMotorEnable(boolean enable) throws Exception {
-	    logger.debug(String.format("XYZ Stepper motor Enable set to %s", enable?"enabled":"disabled" ));
-	    sendFireStepConfig(true, false, "en", enable?"true":"false");
-	}
-	
-	private void setRotMotorEnable(boolean enable) throws Exception {
-	    logger.debug(String.format("Rotation Stepper motor Enable set to %s", enable?"enabled":"disabled" ));
-	    if (enable) {
-	    	if (nozzleEnabled) {
-	    		//Already enabled, nothing to do
-	    	}
-	    	else
-	    	{
-	    	    sendFireStepConfig(false, true, "en", "true"); //Enable power for XYZ stepper motors
-				Thread.sleep(200,0);                  // Delay for a bit, wait for stepper motor coils to stabilize.
-	    	}
-	    }
-	    else //if not enabled
-	    {
-	    	if (nozzleEnabled) {
-	    	    sendFireStepConfig(false, true, "en", "false"); //Enable power for XYZ stepper motors
-	    	}
-	    	else
-	    	{
-	    		//Already disabled, nothing to do
-	    	}
-	    }
-	    nozzleEnabled = enable; //Set state variable	    
-	}
-
-	private void setHomingSpeed(int delay) throws Exception {
-		sendJsonCommand(String.format("{'xsd':%d,'ysd':%d,'zsd':%d}",delay,delay,delay), 100);       // Search delay (think this is the homing speed)
-	}
-	
-
-	private void enablePowerSupply(boolean enable) throws Exception {
-	    logger.debug(String.format("FireStep: Power supply: %s", enable?"Turned ON":"Turned OFF" ));
-		toggleDigitalPin(28,enable);
-		powerSupplyOn = enable;
-	}
-	
-	private void enableEndEffectorRingLight(boolean enable) throws Exception {
-	    logger.debug(String.format("FireStep: End effector LED ring light: %s", enable?"Turned ON":"Turned OFF" ));
-		toggleDigitalPin(4,enable);
-	}
-	
-	private void enableUpLookingRingLight(boolean enable) throws Exception {
-	    logger.debug(String.format("FireStep: Up-looking LED ring light: %s", enable?"Turned ON":"Turned OFF" ));
-		toggleDigitalPin(5,enable);
-	}
-	
-	private void enableVacuumPump(boolean enable) throws Exception {
-	    logger.debug(String.format("FireStep: Vacuum pump: %s", enable?"Enabled":"Disabled" ));
-		toggleDigitalPin(26,enable);
-	}
-
-	private void toggleDigitalPin(int pin, boolean state) throws Exception {
-	    logger.debug(String.format("FireStep: Toggling digital pin %d to %s", pin, state?"HIGH":"LOW" ));
+    private static final Logger logger = LoggerFactory.getLogger(FireStepDriver.class);
+    private static final double minimumRequiredVersion = 1.0;
+
+    // NOTE: This is ignored out because FireStep doesn't use feed rates per se.. it just does
+    // everything rather quickly and smoothly.
+    @Attribute
+    private double feedRateMmPerMinute;
+
+    // @Attribute
+    private double nozzleStepsPerDegree = 8.888888888;
+    private boolean nozzleEnabled = false;
+    private boolean powerSupplyOn = false;
+    private RotatableDeltaKinematicsCalculator deltaCalc = new RotatableDeltaKinematicsCalculator();
+
+    private double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    private String connectedVersion;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
+        if (enabled) {
+            if (!connected) {
+                try {
+                    connect();
+                }
+                catch (Exception e) {
+                    e.printStackTrace();
+                    throw e;
+                }
+            }
+            enableVacuumPump(false); // Turn the vacuum pump OFF
+            enablePowerSupply(true); // Turn power supply ON
+            if (powerSupplyOn) // Exception should catch but guard just in case
+            {
+                Thread.sleep(500, 0); // Delay for a bit, wait for power supply to stabilize.
+                setXyzMotorEnable(true); // Enable power for XYZ stepper motors
+                enableEndEffectorRingLight(true); // Turn off down-looking LED ring light
+                Thread.sleep(50, 0); // Delay for a bit, wait for power supply to stabilize.
+                home(null); // home the machine
+            }
+
+        } // if (enabled)
+        else {
+            if (connected) {
+                enableEndEffectorRingLight(false); // Turn off down-looking LED ring light
+                enableUpLookingRingLight(false); // Turn off up-looking LED ring light
+                if (powerSupplyOn) {
+                    home(null); // home the machine
+                    enableVacuumPump(false); // Turn the vacuum pump OFF
+                    setXyzMotorEnable(false); // Disable power for XYZ stepper motors
+                    enablePowerSupply(false); // Turn off the power supply
+                }
+            }
+        }
+    }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        if (actuator.getIndex() == 0) {
+            // TODO: Currently disabled... We don't have a pin to assign this to
+        }
+    }
+
+    @Override
+    public void home(ReferenceHead head) throws Exception {
+        RawStepTriplet rs = deltaCalc.getHomePosRaw();
+        sendJsonCommand(String.format("{'hom':{'x':%d,'y':%d,'z':%d}}", rs.x, rs.y, rs.z), 10000);
+
+        Location homLoc = deltaCalc.getHomePosCartesian();
+        logger.debug(String.format("Home position: X=%.2f, Y=%.2f, Z=%.2f", homLoc.getX(),
+                homLoc.getY(), homLoc.getZ()));
+        x = homLoc.getX();
+        y = homLoc.getY();
+        z = homLoc.getZ();
+        // TODO: Fire off head event to get the DRO to update to the new values
+    }
+
+    @Override
+    public Location getLocation(ReferenceHeadMountable hm) {
+        // TODO: Request raw step positions from FireStep, do forward delta kinematics, throw
+        // exception if they don't match this class's Cartesian pos.
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
+    }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
+        // dwell();
+        // TODO Auto-generated method stub
+    }
+
+    @Override
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
+        location = location.subtract(hm.getHeadOffsets());
+        location = location.convertToUnits(LengthUnit.Millimeters);
+
+        int rotSteps = 0;
+        RawStepTriplet rs = new RawStepTriplet(0, 0, 0);
+        boolean moveXyz = false;
+        boolean moveRot = false;
+
+        // Check if we've rotated
+        if (Math.abs(location.getRotation() - c) >= 0.01) {
+            moveRot = true;
+            // Convert the rotation axis from degrees to steps
+            rotSteps = (int) (location.getRotation() * nozzleStepsPerDegree + 0.5d);
+            if ((rotSteps >= 32000) || (rotSteps <= -32000)) {
+                throw new Error(String.format(
+                        "FireStep: Rotation axis raw position cannot exceed +/- 32000 steps",
+                        rotSteps));
+            }
+        }
+
+        // Check if we've moved in XYZ
+        Location currentLoc = new Location(LengthUnit.Millimeters, x, y, z, 0);
+        if (Math.abs(location.getXyzDistanceTo(currentLoc)) >= 0.01) {
+            moveXyz = true;
+            logger.debug(String.format("moveTo Cartesian: X: %.3f, Y: %.3f, Z: %.3f",
+                    location.getX(), location.getY(), location.getZ()));
+
+            // Calculate delta kinematics (returns angles)
+            AngleTriplet angles = deltaCalc.calculateDelta(location);
+            logger.debug(String.format("moveTo Delta: X: %.3f, Y: %.3f, Z: %.3f", angles.x,
+                    angles.y, angles.z));
+
+            // Convert angles into raw steps
+            rs = deltaCalc.getRawSteps(angles);
+            logger.debug(String.format("moveTo RawSteps: X: %d, Y: %d, Z: %d", rs.x, rs.y, rs.z));
+        }
+
+
+        // Get feedrate in raw steps
+        // Note that speed is defined by (maximum feed rate * speed) where speed is greater than 0
+        // and typically less than or equal to 1.
+        // A speed of 0 means to move at the minimum possible speed.
+        // TODO: Set feedrate based in raw steps, based off of 'feedRateMmPerMinute' and 'speed'
+        // 'mv' is maximum velocity (pulses/second), and the default is 12800.
+
+        int rawFeedrate = 12800; // 12800 is FireStep's default feedrate
+        rawFeedrate = (int) ((double) rawFeedrate * speed); // Multiply rawFeedrate by speed, which
+                                                            // should be 0 to 1
+        if (moveXyz) {
+            if (moveRot) { // Cartesian move with rotation. Feedrate is (TBD)
+                logger.debug(String.format(
+                        "moveTo: Cartesian move with rotation, feedrate=%d steps/second",
+                        rawFeedrate));
+                setRotMotorEnable(true);
+                sendJsonCommand(String.format("{'mov':{'x':%d,'y':%d,'z':%d, 'a':%d,'mv':%d}}",
+                        rs.x, rs.y, rs.z, rotSteps, rawFeedrate), 10000);
+            }
+            else { // Cartesian move with no rotation. Feedrate is just the cartesian feedrate
+                logger.debug(String.format("moveTo: Cartesian move, feedrate=%d steps/second",
+                        rawFeedrate));
+                sendJsonCommand(String.format("{'mov':{'x':%d,'y':%d,'z':%d,'mv':%d}}", rs.x, rs.y,
+                        rs.z, rawFeedrate), 10000);
+            }
+        }
+        else {
+            if (moveRot) { // Rotation, no Cartesian move. Feedrate is just the rotation feedrate
+                setRotMotorEnable(true);
+                logger.debug(String.format("moveTo: Rotation move, feedrate=%d steps/second",
+                        rawFeedrate));
+                sendJsonCommand(String.format("{'mov':{'a':%d,'mv':%d}}", rotSteps, rawFeedrate),
+                        10000);
+            }
+            else { // No move, nothing to do
+                logger.debug("moveTo: No move, nothing to do");
+            }
+        }
+
+        if (!Double.isNaN(location.getX())) {
+            this.x = location.getX();
+        }
+        if (!Double.isNaN(location.getY())) {
+            this.y = location.getY();
+        }
+        if (!Double.isNaN(location.getZ())) {
+            this.z = location.getZ();
+        }
+        if (!Double.isNaN(location.getRotation())) {
+            this.c = location.getRotation();
+        }
+    }
+
+
+    @Override
+    public void pick(ReferenceNozzle nozzle) throws Exception {
+        setRotMotorEnable(true); // Enable the nozzle rotation
+        enableVacuumPump(true); // Enable the pump
+    }
+
+    @Override
+    public void place(ReferenceNozzle nozzle) throws Exception {
+        enableVacuumPump(false);
+        setRotMotorEnable(false);
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Grbl and we'll start
+         * getting some data. On others, Grbl may already be running and we will get nothing on
+         * connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a change to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for FireStep to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        connectedVersion = "";
+        connected = true;
+        processStatusResponses(responses);
+
+        for (int i = 0; i < 5 && !connected; i++) {
+            sendJsonCommand("{'sys':''}", 100);
+        }
+
+        if (!connected) {
+            throw new Error(String.format(
+                    "Unable to receive connection response from FireStep. Check your port and baud rate, and that you are running at least version %f of Marlin",
+                    minimumRequiredVersion));
+        }
+
+        // TODO: Commenting this out for now. Will implement version checks once we get the
+        // prototoype working.
+        // if (connectedVersion < minimumRequiredVersion) {
+        // throw new Error(String.format("This driver requires Marlin version %.2f or higher. You
+        // are running version %.2f", minimumRequiredVersion, connectedVersion));
+        // }
+
+        // TODO: Allow configuration of modular tools
+        setXyzMotorEnable(false); // Disable all motors
+        setMotorDirection(true, true, false); // Set all motor directions to 'normal'
+        setHomingSpeed(200); // Set the homing speed to something slower than default
+        sendJsonCommand("{'ape':34}", 100); // Set the enable pin for axis 'a' to tool 4 (this is an
+                                            // ugly hack and should go away)
+        // Turn off the stepper drivers
+        setEnabled(false);
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+
         try {
-			sendJsonCommand(String.format("{'iod%d':%s}", pin, state?"true":"false"),100);
-		} catch (Exception e) {
-			// TODO Auto-generated catch block
-			e.printStackTrace();
-		}
-	}
-
-	private void sendFireStepConfig(boolean xyz, boolean rot, String param, String value) throws Exception {
-	    if (xyz && rot) {
-			sendJsonCommand(String.format("{'x%s':%s,'y%s':%s,'z%s':%s,'a%s':%s}",param,value,param,value,param,value,param,value), 100);
-	    }
-	    else if (xyz) {
-			sendJsonCommand(String.format("{'x%s':%s,'y%s':%s,'z%s':%s}",param,value,param,value,param,value), 100);
-	    }
-	    else if (rot) {
-			sendJsonCommand(String.format("{'a%s':%s}",param,value), 100);
-	    }
-	}
-	
-	private void processStatusResponses(List<String> responses) {
-		for (String response : responses) 
-		{
-			if (response.startsWith("FireStep")) {
-				logger.debug("echo: " + response);
-				String[] versionComponents = response.split(" ");
-				connectedVersion = versionComponents[1];
-				connected = true;
-				logger.debug(String.format("Connected to FireStep Version: %s", connectedVersion));
-			}
-			else
-			{
-				//TODO: Debug returned stuff here
-			}
-		}
-	}
-	
-	private void sendJsonCommand(String command, long timeout) throws Exception {
-		List<String> responses = sendCommand(command.replaceAll("'", "\""), timeout);
-		processStatusResponses(responses);
-	}
-	
-	private List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("sendCommand({}, {})", command, timeout);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	//Serial receive thread
-	public void run() {
-		while (!disconnectRequested) {
-	        String line;
-	        try {
-	            line = readLine().trim();
-	        }
-	        catch (TimeoutException ex) {
-	            continue;
-	        }
-	        catch (IOException e) {
-	            logger.error("Read error", e);
-	            return;
-	        }
-	        line = line.trim();
-			logger.debug(line);
-			responseQueue.offer(line);
-			//if (line.equals("ok") || line.startsWith("error: ")) {
-			if (line.isEmpty() == false) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-	
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
-	@Override
-	public Wizard getConfigurationWizard() {
-		//return null;
-	    return new FireStepDriverWizard(this);
-	}
-	@Override
-	public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName();
-	}
-	
-	@Override
-	public PropertySheetHolder[] getChildPropertySheetHolders() {
-	    // TODO Auto-generated method stub
-	    return null;
-	}
-	
-	@Override
-	public Action[] getPropertySheetHolderActions() {
-	    // TODO Auto-generated method stub
-	    return null;
-	}
-	
-	@Override
-	public PropertySheet[] getPropertySheets() {
-	    return new PropertySheet[] {
-	            new PropertySheetWizardAdapter(getConfigurationWizard())
-	    };
-	}
+            super.disconnect();
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+        disconnectRequested = false;
+    }
+
+    private void setMotorDirection(boolean xyz, boolean rot, boolean enable) throws Exception {
+        logger.debug(String.format("%s%s Stepper motor Direction set to %s", xyz ? "XYZ" : "",
+                rot ? "A" : "", enable ? "enabled" : "disabled"));
+        sendFireStepConfig(xyz, rot, "dh", enable ? "true" : "false");
+    }
+
+    private void setXyzMotorEnable(boolean enable) throws Exception {
+        logger.debug(String.format("XYZ Stepper motor Enable set to %s",
+                enable ? "enabled" : "disabled"));
+        sendFireStepConfig(true, false, "en", enable ? "true" : "false");
+    }
+
+    private void setRotMotorEnable(boolean enable) throws Exception {
+        logger.debug(String.format("Rotation Stepper motor Enable set to %s",
+                enable ? "enabled" : "disabled"));
+        if (enable) {
+            if (nozzleEnabled) {
+                // Already enabled, nothing to do
+            }
+            else {
+                sendFireStepConfig(false, true, "en", "true"); // Enable power for XYZ stepper
+                                                               // motors
+                Thread.sleep(200, 0); // Delay for a bit, wait for stepper motor coils to stabilize.
+            }
+        }
+        else // if not enabled
+        {
+            if (nozzleEnabled) {
+                sendFireStepConfig(false, true, "en", "false"); // Enable power for XYZ stepper
+                                                                // motors
+            }
+            else {
+                // Already disabled, nothing to do
+            }
+        }
+        nozzleEnabled = enable; // Set state variable
+    }
+
+    private void setHomingSpeed(int delay) throws Exception {
+        sendJsonCommand(String.format("{'xsd':%d,'ysd':%d,'zsd':%d}", delay, delay, delay), 100); // Search
+                                                                                                  // delay
+                                                                                                  // (think
+                                                                                                  // this
+                                                                                                  // is
+                                                                                                  // the
+                                                                                                  // homing
+                                                                                                  // speed)
+    }
+
+
+    private void enablePowerSupply(boolean enable) throws Exception {
+        logger.debug(
+                String.format("FireStep: Power supply: %s", enable ? "Turned ON" : "Turned OFF"));
+        toggleDigitalPin(28, enable);
+        powerSupplyOn = enable;
+    }
+
+    private void enableEndEffectorRingLight(boolean enable) throws Exception {
+        logger.debug(String.format("FireStep: End effector LED ring light: %s",
+                enable ? "Turned ON" : "Turned OFF"));
+        toggleDigitalPin(4, enable);
+    }
+
+    private void enableUpLookingRingLight(boolean enable) throws Exception {
+        logger.debug(String.format("FireStep: Up-looking LED ring light: %s",
+                enable ? "Turned ON" : "Turned OFF"));
+        toggleDigitalPin(5, enable);
+    }
+
+    private void enableVacuumPump(boolean enable) throws Exception {
+        logger.debug(String.format("FireStep: Vacuum pump: %s", enable ? "Enabled" : "Disabled"));
+        toggleDigitalPin(26, enable);
+    }
+
+    private void toggleDigitalPin(int pin, boolean state) throws Exception {
+        logger.debug(String.format("FireStep: Toggling digital pin %d to %s", pin,
+                state ? "HIGH" : "LOW"));
+        try {
+            sendJsonCommand(String.format("{'iod%d':%s}", pin, state ? "true" : "false"), 100);
+        }
+        catch (Exception e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+    }
+
+    private void sendFireStepConfig(boolean xyz, boolean rot, String param, String value)
+            throws Exception {
+        if (xyz && rot) {
+            sendJsonCommand(String.format("{'x%s':%s,'y%s':%s,'z%s':%s,'a%s':%s}", param, value,
+                    param, value, param, value, param, value), 100);
+        }
+        else if (xyz) {
+            sendJsonCommand(String.format("{'x%s':%s,'y%s':%s,'z%s':%s}", param, value, param,
+                    value, param, value), 100);
+        }
+        else if (rot) {
+            sendJsonCommand(String.format("{'a%s':%s}", param, value), 100);
+        }
+    }
+
+    private void processStatusResponses(List<String> responses) {
+        for (String response : responses) {
+            if (response.startsWith("FireStep")) {
+                logger.debug("echo: " + response);
+                String[] versionComponents = response.split(" ");
+                connectedVersion = versionComponents[1];
+                connected = true;
+                logger.debug(String.format("Connected to FireStep Version: %s", connectedVersion));
+            }
+            else {
+                // TODO: Debug returned stuff here
+            }
+        }
+    }
+
+    private void sendJsonCommand(String command, long timeout) throws Exception {
+        List<String> responses = sendCommand(command.replaceAll("'", "\""), timeout);
+        processStatusResponses(responses);
+    }
+
+    private List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("sendCommand({}, {})", command, timeout);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    // Serial receive thread
+    public void run() {
+        while (!disconnectRequested) {
+            String line;
+            try {
+                line = readLine().trim();
+            }
+            catch (TimeoutException ex) {
+                continue;
+            }
+            catch (IOException e) {
+                logger.error("Read error", e);
+                return;
+            }
+            line = line.trim();
+            logger.debug(line);
+            responseQueue.offer(line);
+            // if (line.equals("ok") || line.startsWith("error: ")) {
+            if (line.isEmpty() == false) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        // return null;
+        return new FireStepDriverWizard(this);
+    }
+
+    @Override
+    public String getPropertySheetHolderTitle() {
+        return getClass().getSimpleName();
+    }
+
+    @Override
+    public PropertySheetHolder[] getChildPropertySheetHolders() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public Action[] getPropertySheetHolderActions() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public PropertySheet[] getPropertySheets() {
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
 }
diff --git a/src/main/java/org/firepick/driver/MarlinDriver.java b/src/main/java/org/firepick/driver/MarlinDriver.java
index 9f01760a1b..fc5bd41121 100755
--- a/src/main/java/org/firepick/driver/MarlinDriver.java
+++ b/src/main/java/org/firepick/driver/MarlinDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 // This file is intended to support the RepRap Marlin motion controller.
@@ -51,96 +49,95 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * TODO: Consider adding some type of heartbeat to the firmware.  
+ * TODO: Consider adding some type of heartbeat to the firmware.
  */
 public class MarlinDriver extends AbstractSerialPortDriver implements Runnable {
-	private static final Logger logger = LoggerFactory.getLogger(MarlinDriver.class);
-	private static final double minimumRequiredVersion = 1.0;
-	
-	@Attribute(required=false)
-	private double feedRateMmPerMinute = 5000;
-	
-	
-	private double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-	private double connectedVersion;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-//	public MarlinDriver() {
-//        Configuration.get().addListener(new ConfigurationListener.Adapter() {
-//            @Override
-//            public void configurationComplete(Configuration configuration)
-//                    throws Exception {
-//                connect();
-//            }
-//        });
-//	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, boolean on)
-			throws Exception {
-		if (actuator.getIndex() == 0) {
-			sendCommand(on ? "M8" : "M9");
-			dwell();
-		}
-	}
-	
-	
-	
-	@Override
-	public void home(ReferenceHead head) throws Exception {
-		List<String> responses;
-		sendCommand("M999");
-		sendCommand("M82"); // Was M83, 6/21/2015, NJ
-		sendCommand("G28");
-	
-		//For some machines, home is not 0,0,0.  Send an M114 command to get the current position, after homing.
-		responses = sendCommand("M114");
-	
-	  //We're expecting (Note, this is the modified Marlin M114 response, for FirePick Delta): 
-	  //  M114 X:0.00 Y:0.00 Z:65.39 E:0.00
- 		//  dX:-66.88 dY:-66.88 dZ:-66.88 CalcZ=-247.50
-		for (String response : responses) {
-			if (response.startsWith("M114 ")) {
-				logger.debug("echo: " + response);
-				String[] coords = response.split(" ");
-				x = Double.parseDouble(coords[1].substring(2));
-				y = Double.parseDouble(coords[2].substring(2));
-				z = Double.parseDouble(coords[3].substring(2));
-				c = Double.parseDouble(coords[4].substring(2));
-			}
-		}
-
-		//x = y = z= c = 0;
-	}
-	
-	@Override
-  public Location getLocation(ReferenceHeadMountable hm) {
-    return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
-  }
-
-  @Override
-  public void actuate(ReferenceActuator actuator, double value)
-      throws Exception {
-      	dwell();
+    private static final Logger logger = LoggerFactory.getLogger(MarlinDriver.class);
+    private static final double minimumRequiredVersion = 1.0;
+
+    @Attribute(required = false)
+    private double feedRateMmPerMinute = 5000;
+
+
+    private double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    private double connectedVersion;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    // public MarlinDriver() {
+    // Configuration.get().addListener(new ConfigurationListener.Adapter() {
+    // @Override
+    // public void configurationComplete(Configuration configuration)
+    // throws Exception {
+    // connect();
+    // }
+    // });
+    // }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        if (actuator.getIndex() == 0) {
+            sendCommand(on ? "M8" : "M9");
+            dwell();
+        }
+    }
+
+
+
+    @Override
+    public void home(ReferenceHead head) throws Exception {
+        List<String> responses;
+        sendCommand("M999");
+        sendCommand("M82"); // Was M83, 6/21/2015, NJ
+        sendCommand("G28");
+
+        // For some machines, home is not 0,0,0. Send an M114 command to get the current position,
+        // after homing.
+        responses = sendCommand("M114");
+
+        // We're expecting (Note, this is the modified Marlin M114 response, for FirePick Delta):
+        // M114 X:0.00 Y:0.00 Z:65.39 E:0.00
+        // dX:-66.88 dY:-66.88 dZ:-66.88 CalcZ=-247.50
+        for (String response : responses) {
+            if (response.startsWith("M114 ")) {
+                logger.debug("echo: " + response);
+                String[] coords = response.split(" ");
+                x = Double.parseDouble(coords[1].substring(2));
+                y = Double.parseDouble(coords[2].substring(2));
+                z = Double.parseDouble(coords[3].substring(2));
+                c = Double.parseDouble(coords[4].substring(2));
+            }
+        }
+
+        // x = y = z= c = 0;
+    }
+
+    @Override
+    public Location getLocation(ReferenceHeadMountable hm) {
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
+    }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
+        dwell();
         // TODO Auto-generated method stub
-  }
+    }
 
-  @Override
-	public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-			throws Exception {
+    @Override
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
+
         StringBuffer sb = new StringBuffer();
         if (!Double.isNaN(x) && x != this.x) {
             sb.append(String.format(Locale.US, "X%2.2f ", x));
@@ -171,12 +168,12 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         if (!Double.isNaN(c)) {
             this.c = c;
         }
-        
+
         dwell();
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
         if (enabled) {
             if (!connected) {
                 try {
@@ -187,155 +184,155 @@ public void setEnabled(boolean enabled) throws Exception {
                     throw e;
                 }
             }
-            sendCommand("M5");       // Turn the vacuum pump OFF
-    		sendCommand("M80");      // Turn power supply ON
-    		Thread.sleep(500,0);     // Delay for a bit, wait for power supply to stabilize.
-            sendCommand("M999");     // Clear errors
-            sendCommand("M17");      // Enable power for all stepper motors
+            sendCommand("M5"); // Turn the vacuum pump OFF
+            sendCommand("M80"); // Turn power supply ON
+            Thread.sleep(500, 0); // Delay for a bit, wait for power supply to stabilize.
+            sendCommand("M999"); // Clear errors
+            sendCommand("M17"); // Enable power for all stepper motors
             sendCommand("M420R255"); // Turn on down-looking LED ring light
             sendCommand("M421R255"); // Turn on up-looking LED ring light
-        } //if (enabled)
-        else{
-        	if (connected)
-        	{
-                sendCommand("M5");       // Turn the vacuum pump OFF
-                sendCommand("M18");      // Disable all stepper motors.  Same as M84.
-                sendCommand("M420R0");   // Turn off down-looking LED ring light
-                sendCommand("M421R0");   // Turn off up-looking LED ring light
-        		sendCommand("M81");      // Turn power supply OFF
-        	}
+        } // if (enabled)
+        else {
+            if (connected) {
+                sendCommand("M5"); // Turn the vacuum pump OFF
+                sendCommand("M18"); // Disable all stepper motors. Same as M84.
+                sendCommand("M420R0"); // Turn off down-looking LED ring light
+                sendCommand("M421R0"); // Turn off up-looking LED ring light
+                sendCommand("M81"); // Turn power supply OFF
+            }
         }
-	}
-
-	@Override
-	public void pick(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M4");
-		dwell();
-		
-	}
-
-	@Override
-	public void place(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M5");
-		dwell();
-	}
-
-	public synchronized void connect()
-			throws Exception {
-	    super.connect();
-
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Grbl and we'll start getting some data. On others, Grbl may already
-		 * be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a change to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for Marlin to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-
-		connectedVersion = 1.0;
-		connected = false; //DouglasPearless changed from true to false
-		processConnectionResponses(responses);
-
-		for (int i = 0; i < 5 && !connected; i++) {
-			responses = sendCommand("M115", 5000);
-			processConnectionResponses(responses);
-		}
-		
-  if (!connected)  {
-			throw new Error(
-				String.format("Unable to receive connection response from Marlin. Check your port and baud rate, and that you are running at least version %f of Marlin", 
-						minimumRequiredVersion));
-		}
-		
-		//TODO: Commenting this out for now. Will implement version checks once we get the prototoype working.
-		//if (connectedVersion < minimumRequiredVersion) {
-		//	throw new Error(String.format("This driver requires Marlin version %.2f or higher. You are running version %.2f", minimumRequiredVersion, connectedVersion));
-		//}
-		
-		// We are connected to at least the minimum required version now
-		// So perform some setup
-		
-		// Turn off the stepper drivers
-		setEnabled(false);
-		
-		// Reset all axes to 0, in case the firmware was not reset on
-		// connect.
-		sendCommand("G92 X0 Y0 Z0 E0");
-	}
-	
-	private void processConnectionResponses(List<String> responses) {
-		for (String response : responses) {
-			if (response.startsWith("Marlin")) {
-				logger.debug("echo: " + response);
-				String[] versionComponents = response.split("n");
-				connectedVersion = Double.parseDouble(versionComponents[1]);
-				connected = true;
-				logger.debug(String.format("Connected to Marlin Version: %.2f", connectedVersion));
-			}
-		}
-	}
-
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
-		try {
-		    super.disconnect();
+    }
+
+    @Override
+    public void pick(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M4");
+        dwell();
+
+    }
+
+    @Override
+    public void place(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M5");
+        dwell();
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Grbl and we'll start
+         * getting some data. On others, Grbl may already be running and we will get nothing on
+         * connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a change to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for Marlin to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        connectedVersion = 1.0;
+        connected = false; // DouglasPearless changed from true to false
+        processConnectionResponses(responses);
+
+        for (int i = 0; i < 5 && !connected; i++) {
+            responses = sendCommand("M115", 5000);
+            processConnectionResponses(responses);
+        }
+
+        if (!connected) {
+            throw new Error(String.format(
+                    "Unable to receive connection response from Marlin. Check your port and baud rate, and that you are running at least version %f of Marlin",
+                    minimumRequiredVersion));
+        }
+
+        // TODO: Commenting this out for now. Will implement version checks once we get the
+        // prototoype working.
+        // if (connectedVersion < minimumRequiredVersion) {
+        // throw new Error(String.format("This driver requires Marlin version %.2f or higher. You
+        // are running version %.2f", minimumRequiredVersion, connectedVersion));
+        // }
+
+        // We are connected to at least the minimum required version now
+        // So perform some setup
+
+        // Turn off the stepper drivers
+        setEnabled(false);
+
+        // Reset all axes to 0, in case the firmware was not reset on
+        // connect.
+        sendCommand("G92 X0 Y0 Z0 E0");
+    }
+
+    private void processConnectionResponses(List<String> responses) {
+        for (String response : responses) {
+            if (response.startsWith("Marlin")) {
+                logger.debug("echo: " + response);
+                String[] versionComponents = response.split("n");
+                connectedVersion = Double.parseDouble(versionComponents[1]);
+                connected = true;
+                logger.debug(String.format("Connected to Marlin Version: %.2f", connectedVersion));
+            }
+        }
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+
+        try {
+            super.disconnect();
         }
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-		disconnectRequested = false;
-	}
-
-
-	private List<String> sendCommand(String command) throws Exception {
-		return sendCommand(command, -1);
-	}
-	
-	private List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("sendCommand({}, {})", command, timeout);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	//Serial receive thread
-	public void run() {
-		while (!disconnectRequested) {
+        disconnectRequested = false;
+    }
+
+
+    private List<String> sendCommand(String command) throws Exception {
+        return sendCommand(command, -1);
+    }
+
+    private List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("sendCommand({}, {})", command, timeout);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    // Serial receive thread
+    public void run() {
+        while (!disconnectRequested) {
             String line;
             try {
                 line = readLine().trim();
@@ -348,39 +345,41 @@ public void run() {
                 return;
             }
             line = line.trim();
-			logger.debug(line);
-			responseQueue.offer(line);
-			if (line.equals("ok") || line.startsWith("error: ")) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-
-	/**
-	 * Causes Marlin to block until all commands are complete.
-	 * @throws Exception
-	 */
-	private void dwell() throws Exception {
-		sendCommand("M400");
-		//sendCommand("G4 P0");
-	}
-
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
+            logger.debug(line);
+            responseQueue.offer(line);
+            if (line.equals("ok") || line.startsWith("error: ")) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    /**
+     * Causes Marlin to block until all commands are complete.
+     * 
+     * @throws Exception
+     */
+    private void dwell() throws Exception {
+        sendCommand("M400");
+        // sendCommand("G4 P0");
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return new MarlinDriverWizard(this);
     }
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName();
@@ -400,8 +399,6 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 }
diff --git a/src/main/java/org/firepick/driver/SmoothieDriver.java b/src/main/java/org/firepick/driver/SmoothieDriver.java
index 40a766361c..86c795ca31 100755
--- a/src/main/java/org/firepick/driver/SmoothieDriver.java
+++ b/src/main/java/org/firepick/driver/SmoothieDriver.java
@@ -1,29 +1,28 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 // This file is intended to support the RepRap Marlin motion controller.
 // It is a mashup of TinygDriver.java and GrblDriver.java.
 // - Neil Jansen (njansen1@gmail.com) 6/30/2014
 // - Douglas Pearless (Douglas.Pearless@gmail.com) This is based on Neil's Marlin driver
-//   and is written for my fork of Smoothie, which adds the M115 command and other features required by FPD 2015-08-12
+// and is written for my fork of Smoothie, which adds the M115 command and other features required
+// by FPD 2015-08-12
 package org.firepick.driver;
 
 import java.io.IOException;
@@ -52,93 +51,92 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * TODO: Consider adding some type of heartbeat to the firmware.  
+ * TODO: Consider adding some type of heartbeat to the firmware.
  */
 public class SmoothieDriver extends AbstractSerialPortDriver implements Runnable {
-	private static final Logger logger = LoggerFactory.getLogger(SmoothieDriver.class);
-	private static final double minimumRequiredVersion = 1.0;
-	
-	@Attribute(required=false)
-	private double feedRateMmPerMinute = 5000;
-	
-	
-	private double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-	//private double connectedVersion;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-//	public SmootiheDriver() {
-//        Configuration.get().addListener(new ConfigurationListener.Adapter() {
-//            @Override
-//            public void configurationComplete(Configuration configuration)
-//                    throws Exception {
-//                connect();
-//            }
-//        });
-//	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, boolean on)
-			throws Exception {
-		if (actuator.getIndex() == 0) {
-			sendCommand(on ? "M8" : "M9");
-			dwell();
-		}
-	}
-	
-	
-	
-	@Override
-	public void home(ReferenceHead head) throws Exception {
-		List<String> responses;
-		sendCommand("M999");
-		sendCommand("M82");
-		sendCommand("G28");
-	
-		//For some machines, home is not 0,0,0.  Send an M114 command to get the current position, after homing.
-		responses = sendCommand("M114");
-	
-		for (String response : responses) {
-			if (response.toUpperCase().startsWith("OK ")) {
-				logger.debug("echo: " + response);
-				String[] coords = response.split(" ");
-				x = Double.parseDouble(coords[2].substring(2));
-				y = Double.parseDouble(coords[3].substring(2));
-				z = Double.parseDouble(coords[4].substring(2));
-				c = Double.parseDouble(coords[9].substring(2));
-			}
-		}
-
-		//x = y = z= c = 0;
-	}
-	
-	@Override
-  public Location getLocation(ReferenceHeadMountable hm) {
-    return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
-  }
-
-  @Override
-  public void actuate(ReferenceActuator actuator, double value)
-      throws Exception {
-      	dwell();
+    private static final Logger logger = LoggerFactory.getLogger(SmoothieDriver.class);
+    private static final double minimumRequiredVersion = 1.0;
+
+    @Attribute(required = false)
+    private double feedRateMmPerMinute = 5000;
+
+
+    private double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    // private double connectedVersion;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    // public SmootiheDriver() {
+    // Configuration.get().addListener(new ConfigurationListener.Adapter() {
+    // @Override
+    // public void configurationComplete(Configuration configuration)
+    // throws Exception {
+    // connect();
+    // }
+    // });
+    // }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        if (actuator.getIndex() == 0) {
+            sendCommand(on ? "M8" : "M9");
+            dwell();
+        }
+    }
+
+
+
+    @Override
+    public void home(ReferenceHead head) throws Exception {
+        List<String> responses;
+        sendCommand("M999");
+        sendCommand("M82");
+        sendCommand("G28");
+
+        // For some machines, home is not 0,0,0. Send an M114 command to get the current position,
+        // after homing.
+        responses = sendCommand("M114");
+
+        for (String response : responses) {
+            if (response.toUpperCase().startsWith("OK ")) {
+                logger.debug("echo: " + response);
+                String[] coords = response.split(" ");
+                x = Double.parseDouble(coords[2].substring(2));
+                y = Double.parseDouble(coords[3].substring(2));
+                z = Double.parseDouble(coords[4].substring(2));
+                c = Double.parseDouble(coords[9].substring(2));
+            }
+        }
+
+        // x = y = z= c = 0;
+    }
+
+    @Override
+    public Location getLocation(ReferenceHeadMountable hm) {
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
+    }
+
+    @Override
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
+        dwell();
         // TODO Auto-generated method stub
-  }
+    }
 
-  @Override
-	public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-			throws Exception {
+    @Override
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
+
         StringBuffer sb = new StringBuffer();
         if (!Double.isNaN(x) && x != this.x) {
             sb.append(String.format(Locale.US, "X%2.2f ", x));
@@ -169,12 +167,12 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         if (!Double.isNaN(c)) {
             this.c = c;
         }
-        
+
         dwell();
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
         if (enabled) {
             if (!connected) {
                 try {
@@ -185,154 +183,156 @@ public void setEnabled(boolean enabled) throws Exception {
                     throw e;
                 }
             }
-            sendCommand("M5");       // Turn the vacuum pump OFF
-    		sendCommand("M80");      // Turn power supply ON
-    		Thread.sleep(500,0);     // Delay for a bit, wait for power supply to stabilize.
-            sendCommand("M999");     // Clear errors
-            sendCommand("M17");      // Enable power for all stepper motors
+            sendCommand("M5"); // Turn the vacuum pump OFF
+            sendCommand("M80"); // Turn power supply ON
+            Thread.sleep(500, 0); // Delay for a bit, wait for power supply to stabilize.
+            sendCommand("M999"); // Clear errors
+            sendCommand("M17"); // Enable power for all stepper motors
             sendCommand("M420R255"); // Turn on down-looking LED ring light
             sendCommand("M421R255"); // Turn on up-looking LED ring light
-        } //if (enabled)
-        else{
-        	if (connected)
-        	{
-                sendCommand("M5");       // Turn the vacuum pump OFF
-                sendCommand("M18");      // Disable all stepper motors.  Same as M84.
-                sendCommand("M420R0");   // Turn off down-looking LED ring light
-                sendCommand("M421R0");   // Turn off up-looking LED ring light
-        		sendCommand("M81");      // Turn power supply OFF
-        	}
+        } // if (enabled)
+        else {
+            if (connected) {
+                sendCommand("M5"); // Turn the vacuum pump OFF
+                sendCommand("M18"); // Disable all stepper motors. Same as M84.
+                sendCommand("M420R0"); // Turn off down-looking LED ring light
+                sendCommand("M421R0"); // Turn off up-looking LED ring light
+                sendCommand("M81"); // Turn power supply OFF
+            }
+        }
+    }
+
+    @Override
+    public void pick(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M4");
+        dwell();
+
+    }
+
+    @Override
+    public void place(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M5");
+        dwell();
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Grbl and we'll start
+         * getting some data. On others, Grbl may already be running and we will get nothing on
+         * connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a change to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for Smoothie to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        // connectedVersion = 1.0;
+        connected = false;
+        processConnectionResponses(responses); // Flush out any start up messages
+
+        // Now try to determine the firmware level
+        for (int i = 0; i < 5 && !connected; i++) {
+            responses = sendCommand("M115", 5000);
+            processConnectionResponses(responses);
+        }
+
+        if (!connected) {
+            throw new Error(String.format(
+                    "Unable to receive connection response from Smoothie. Check your port and baud rate, and that you are running the latest version of Smoothie from https://github.com/DouglasPearless/Smoothieware",
+                    minimumRequiredVersion));
+        }
+
+        // Turn off the stepper drivers
+        setEnabled(false);
+
+        // Reset all axes to 0, in case the firmware was not reset on
+        // connect.
+        sendCommand("G92 X0 Y0 Z0 E0");
+    }
+
+    private void processConnectionResponses(List<String> responses) {
+        for (String response : responses) {
+            if (response.toUpperCase().startsWith("SMOOTHIE")) {
+                logger.debug("echo: " + response);
+                logger.debug(String.format("Connected to Smoothie"));
+            }
+            else if (response.toUpperCase().startsWith("PROTOCOL")) {
+                logger.debug("echo: " + response);
+                String[] versionComponents = response.split(" ");
+
+                if (versionComponents[3].toUpperCase().startsWith("DOUGLASPEARLESS")) {
+                    connected = true;
+                    logger.debug(String
+                            .format("Connected to Smoothie with the correct firmware version"));
+                }
+                else
+                    logger.debug(String.format(
+                            "Wrong version of Smoothie, please obtain the latest version from https://github.com/DouglasPearless/Smoothieware"));
+            }
+        }
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
         }
-	}
-
-	@Override
-	public void pick(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M4");
-		dwell();
-		
-	}
-
-	@Override
-	public void place(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M5");
-		dwell();
-	}
-
-	public synchronized void connect()
-			throws Exception {
-	    super.connect();
-
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Grbl and we'll start getting some data. On others, Grbl may already
-		 * be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a change to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for Smoothie to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-
-//		connectedVersion = 1.0;
-		connected = false;
-		processConnectionResponses(responses);  //Flush out any start up messages
-
-		//Now try to determine the firmware level
-		for (int i = 0; i < 5 && !connected; i++) {
-			responses = sendCommand("M115", 5000);
-			processConnectionResponses(responses);
-		}
-		
-  if	(!connected)  {
-			throw new Error(
-				String.format("Unable to receive connection response from Smoothie. Check your port and baud rate, and that you are running the latest version of Smoothie from https://github.com/DouglasPearless/Smoothieware", 
-						minimumRequiredVersion));
-		}
-		
-		// Turn off the stepper drivers
-		setEnabled(false);
-		
-		// Reset all axes to 0, in case the firmware was not reset on
-		// connect.
-		sendCommand("G92 X0 Y0 Z0 E0");
-	}
-	
-	private void processConnectionResponses(List<String> responses) {
-		for (String response : responses) {
-			if (response.toUpperCase().startsWith("SMOOTHIE")) {
-				logger.debug("echo: " + response);
-				logger.debug(String.format("Connected to Smoothie"));
-			} else if (response.toUpperCase().startsWith("PROTOCOL")) {
-				logger.debug("echo: " + response);
-				String[] versionComponents = response.split(" ");
-
-				if (versionComponents[3].toUpperCase().startsWith("DOUGLASPEARLESS")) {
-					connected = true;
-					logger.debug(String.format("Connected to Smoothie with the correct firmware version"));
-				} else
-					logger.debug(String.format("Wrong version of Smoothie, please obtain the latest version from https://github.com/DouglasPearless/Smoothieware"));
-			}
-		}
-	}
-
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
-		try {
-		    super.disconnect();
+
+        try {
+            super.disconnect();
         }
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-		disconnectRequested = false;
-	}
-
-
-	private List<String> sendCommand(String command) throws Exception {
-		return sendCommand(command, 500); // changed from -1
-	}
-	
-	private List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("sendCommand({}, {})", command, timeout);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	//Serial receive thread
-	public void run() {
-		while (!disconnectRequested) {
+        disconnectRequested = false;
+    }
+
+
+    private List<String> sendCommand(String command) throws Exception {
+        return sendCommand(command, 500); // changed from -1
+    }
+
+    private List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("sendCommand({}, {})", command, timeout);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    // Serial receive thread
+    public void run() {
+        while (!disconnectRequested) {
             String line;
             try {
                 line = readLine().trim();
@@ -345,39 +345,41 @@ public void run() {
                 return;
             }
             line = line.trim();
-			logger.debug(line);
-			responseQueue.offer(line);
-			if (line.equals("ok") || line.startsWith("error: ")) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-
-	/**
-	 * Causes Smoothie to block until all commands are complete.
-	 * @throws Exception
-	 */
-	private void dwell() throws Exception {
-		sendCommand("M400");
-		//sendCommand("G4 P0");
-	}
-
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
+            logger.debug(line);
+            responseQueue.offer(line);
+            if (line.equals("ok") || line.startsWith("error: ")) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    /**
+     * Causes Smoothie to block until all commands are complete.
+     * 
+     * @throws Exception
+     */
+    private void dwell() throws Exception {
+        sendCommand("M400");
+        // sendCommand("G4 P0");
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return new SmoothieDriverWizard(this);
     }
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName();
@@ -397,8 +399,6 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 }
diff --git a/src/main/java/org/firepick/driver/wizards/FireStepDriverWizard.java b/src/main/java/org/firepick/driver/wizards/FireStepDriverWizard.java
index cc90ffac5f..1be062df62 100755
--- a/src/main/java/org/firepick/driver/wizards/FireStepDriverWizard.java
+++ b/src/main/java/org/firepick/driver/wizards/FireStepDriverWizard.java
@@ -1,32 +1,30 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.driver.wizards;
 
 import org.firepick.driver.FireStepDriver;
 import org.openpnp.machine.reference.driver.wizards.AbstractSerialPortDriverConfigurationWizard;
 
-public class FireStepDriverWizard  extends AbstractSerialPortDriverConfigurationWizard {
+public class FireStepDriverWizard extends AbstractSerialPortDriverConfigurationWizard {
     private final FireStepDriver driver;
-    
+
     public FireStepDriverWizard(FireStepDriver driver) {
         super(driver);
         this.driver = driver;
diff --git a/src/main/java/org/firepick/driver/wizards/MarlinDriverWizard.java b/src/main/java/org/firepick/driver/wizards/MarlinDriverWizard.java
index b0bd45d113..2c7dd4b36f 100755
--- a/src/main/java/org/firepick/driver/wizards/MarlinDriverWizard.java
+++ b/src/main/java/org/firepick/driver/wizards/MarlinDriverWizard.java
@@ -1,32 +1,30 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.driver.wizards;
 
 import org.firepick.driver.MarlinDriver;
 import org.openpnp.machine.reference.driver.wizards.AbstractSerialPortDriverConfigurationWizard;
 
-public class MarlinDriverWizard  extends AbstractSerialPortDriverConfigurationWizard {
+public class MarlinDriverWizard extends AbstractSerialPortDriverConfigurationWizard {
     private final MarlinDriver driver;
-    
+
     public MarlinDriverWizard(MarlinDriver driver) {
         super(driver);
         this.driver = driver;
diff --git a/src/main/java/org/firepick/driver/wizards/SmoothieDriverWizard.java b/src/main/java/org/firepick/driver/wizards/SmoothieDriverWizard.java
index 794211920d..09ea70bba2 100755
--- a/src/main/java/org/firepick/driver/wizards/SmoothieDriverWizard.java
+++ b/src/main/java/org/firepick/driver/wizards/SmoothieDriverWizard.java
@@ -1,32 +1,30 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.driver.wizards;
 
 import org.firepick.driver.SmoothieDriver;
 import org.openpnp.machine.reference.driver.wizards.AbstractSerialPortDriverConfigurationWizard;
 
-public class SmoothieDriverWizard  extends AbstractSerialPortDriverConfigurationWizard {
+public class SmoothieDriverWizard extends AbstractSerialPortDriverConfigurationWizard {
     private final SmoothieDriver driver;
-    
+
     public SmoothieDriverWizard(SmoothieDriver driver) {
         super(driver);
         this.driver = driver;
diff --git a/src/main/java/org/firepick/kinematics/RotatableDeltaKinematicsCalculator.java b/src/main/java/org/firepick/kinematics/RotatableDeltaKinematicsCalculator.java
index 96866dea84..a3e672ff95 100755
--- a/src/main/java/org/firepick/kinematics/RotatableDeltaKinematicsCalculator.java
+++ b/src/main/java/org/firepick/kinematics/RotatableDeltaKinematicsCalculator.java
@@ -1,23 +1,21 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.kinematics;
 
@@ -28,170 +26,180 @@
 
 public class RotatableDeltaKinematicsCalculator {
 
-    //TODO: These should eventually become configurable.
-	private double DELTA_Z_OFFSET = 268.000;
-	private double DELTA_EE_OFFS = 15.000;
-	private double TOOL_OFFSET = 30.500;
-	private double Z_CALC_OFFSET = ((DELTA_Z_OFFSET - TOOL_OFFSET - DELTA_EE_OFFS) * -1);
-	
-	private double HOME_ANGLE_X  = -67.200; // Angle of the "X" endstop sensor (0=horizontal)
-	private double HOME_ANGLE_Y  = -67.200; // Angle of the "Y" endstop sensor (0=horizontal)
-	private double HOME_ANGLE_Z  = -67.200; // Angle of the "Z" endstop sensor (0=horizontal)
-
-	private double deltaE  = 131.636; // End effector length
-	private double deltaF  = 190.526; // Base length
-	private double deltaRe = 270.000; // Carbon rod length
-	private double deltaRf = 90.000;  // Servo horn length
-	
-	private double XYZ_FULL_STEPS_PER_ROTATION = 200.0;
-	private double XYZ_MICROSTEPS = 16.0;
-	private double SMALL_PULLEY_TEETH = 16.0;
-	private double BIG_PULLEY_TEETH = 150.0;
-	private double PULLEY_REDUCTION = BIG_PULLEY_TEETH/SMALL_PULLEY_TEETH;
-	private double XYZ_STEPS = (XYZ_FULL_STEPS_PER_ROTATION*XYZ_MICROSTEPS*PULLEY_REDUCTION)/360.0;
-	
-	public class RotatableDeltaKinematicsException extends Exception {
-		public RotatableDeltaKinematicsException(String message){
-		     super(message);
-		}
-	}
-	
-	//Return raw steps, given an angle
-	public int getRawStepsFromAngle(double angle)
-	{
-		return (int)(angle * XYZ_STEPS + 0.5d);
-	}
-	
-	//Get the raw step home positions for the three axes
-	public RawStepTriplet getHomePosRaw()
-	{
-		return new RawStepTriplet(getRawStepsFromAngle(HOME_ANGLE_X),getRawStepsFromAngle(HOME_ANGLE_Y),getRawStepsFromAngle(HOME_ANGLE_Z));
-	}
-	
-	//Get the homing angles for the three axes
-	public AngleTriplet getHomePos()
-	{
-		return new AngleTriplet(HOME_ANGLE_X, HOME_ANGLE_Y, HOME_ANGLE_Z);
-	}
-	
-	public Location getHomePosCartesian() throws RotatableDeltaKinematicsException {
-		return delta_calcForward(getHomePos());
-	}
-	
-	//Get the raw steps for a specified angle
-	public RawStepTriplet getRawSteps(AngleTriplet deltaCalc)
-	{
-		return new RawStepTriplet(getRawStepsFromAngle(deltaCalc.x),getRawStepsFromAngle(deltaCalc.y),getRawStepsFromAngle(deltaCalc.z));
-	}
-	
-	
-	//Delta calc stuff
+    // TODO: These should eventually become configurable.
+    private double DELTA_Z_OFFSET = 268.000;
+    private double DELTA_EE_OFFS = 15.000;
+    private double TOOL_OFFSET = 30.500;
+    private double Z_CALC_OFFSET = ((DELTA_Z_OFFSET - TOOL_OFFSET - DELTA_EE_OFFS) * -1);
+
+    private double HOME_ANGLE_X = -67.200; // Angle of the "X" endstop sensor (0=horizontal)
+    private double HOME_ANGLE_Y = -67.200; // Angle of the "Y" endstop sensor (0=horizontal)
+    private double HOME_ANGLE_Z = -67.200; // Angle of the "Z" endstop sensor (0=horizontal)
+
+    private double deltaE = 131.636; // End effector length
+    private double deltaF = 190.526; // Base length
+    private double deltaRe = 270.000; // Carbon rod length
+    private double deltaRf = 90.000; // Servo horn length
+
+    private double XYZ_FULL_STEPS_PER_ROTATION = 200.0;
+    private double XYZ_MICROSTEPS = 16.0;
+    private double SMALL_PULLEY_TEETH = 16.0;
+    private double BIG_PULLEY_TEETH = 150.0;
+    private double PULLEY_REDUCTION = BIG_PULLEY_TEETH / SMALL_PULLEY_TEETH;
+    private double XYZ_STEPS =
+            (XYZ_FULL_STEPS_PER_ROTATION * XYZ_MICROSTEPS * PULLEY_REDUCTION) / 360.0;
+
+    public class RotatableDeltaKinematicsException extends Exception {
+        public RotatableDeltaKinematicsException(String message) {
+            super(message);
+        }
+    }
+
+    // Return raw steps, given an angle
+    public int getRawStepsFromAngle(double angle) {
+        return (int) (angle * XYZ_STEPS + 0.5d);
+    }
+
+    // Get the raw step home positions for the three axes
+    public RawStepTriplet getHomePosRaw() {
+        return new RawStepTriplet(getRawStepsFromAngle(HOME_ANGLE_X),
+                getRawStepsFromAngle(HOME_ANGLE_Y), getRawStepsFromAngle(HOME_ANGLE_Z));
+    }
+
+    // Get the homing angles for the three axes
+    public AngleTriplet getHomePos() {
+        return new AngleTriplet(HOME_ANGLE_X, HOME_ANGLE_Y, HOME_ANGLE_Z);
+    }
+
+    public Location getHomePosCartesian() throws RotatableDeltaKinematicsException {
+        return delta_calcForward(getHomePos());
+    }
+
+    // Get the raw steps for a specified angle
+    public RawStepTriplet getRawSteps(AngleTriplet deltaCalc) {
+        return new RawStepTriplet(getRawStepsFromAngle(deltaCalc.x),
+                getRawStepsFromAngle(deltaCalc.y), getRawStepsFromAngle(deltaCalc.z));
+    }
+
+
+    // Delta calc stuff
     private static final double sin120 = Math.sqrt(3.0) / 2.0;
     private static final double cos120 = -0.5;
     private static final double tan60 = Math.sqrt(3.0);
     private static final double sin30 = 0.5;
     private static final double tan30 = 1 / Math.sqrt(3.0);
-    
-    public AngleTriplet calculateDelta(Location cartesianLoc) throws RotatableDeltaKinematicsException 
-    {
-  	  //trossen tutorial puts the "X" in the front/middle. FPD puts this arm in the back/middle for aesthetics.
-  	  double rotated_x = -1 * cartesianLoc.getX();
-  	  double rotated_y = -1 * cartesianLoc.getY();
-  	  double z_with_offset = cartesianLoc.getZ() + Z_CALC_OFFSET; //The delta calc below places zero at the top.  Subtract the Z offset to make zero at the bottom.
-  	  
-	  AngleTriplet solution = new AngleTriplet(0,0,0);
-  	  try
-  	  {
-  	  	  solution.x = calculateYZ(rotated_x,                           rotated_y,                         z_with_offset);
-  	  	  solution.y = calculateYZ(rotated_x*cos120 + rotated_y*sin120, rotated_y*cos120-rotated_x*sin120, z_with_offset);  // rotate coords to +120 deg
-  	  	  solution.z = calculateYZ(rotated_x*cos120 - rotated_y*sin120, rotated_y*cos120+rotated_x*sin120, z_with_offset);  // rotate coords to -120 deg
-  	  	  solution.successfulCalc = true;
-  	  }
-  	  catch (RotatableDeltaKinematicsException e)
-  	  {
-  		  throw new RotatableDeltaKinematicsException(String.format("Delta calcInverse: Non-existing point for Cartesian location x=%.3f, y=%.3f, z=%.3f, Z_CALC_OFFSET=%.3f", cartesianLoc.getX(), cartesianLoc.getY(), cartesianLoc.getZ(),Z_CALC_OFFSET ));
-  	  }
-  	  return solution;
+
+    public AngleTriplet calculateDelta(Location cartesianLoc)
+            throws RotatableDeltaKinematicsException {
+        // trossen tutorial puts the "X" in the front/middle. FPD puts this arm in the back/middle
+        // for aesthetics.
+        double rotated_x = -1 * cartesianLoc.getX();
+        double rotated_y = -1 * cartesianLoc.getY();
+        double z_with_offset = cartesianLoc.getZ() + Z_CALC_OFFSET; // The delta calc below places
+                                                                    // zero at the top. Subtract the
+                                                                    // Z offset to make zero at the
+                                                                    // bottom.
+
+        AngleTriplet solution = new AngleTriplet(0, 0, 0);
+        try {
+            solution.x = calculateYZ(rotated_x, rotated_y, z_with_offset);
+            solution.y = calculateYZ(rotated_x * cos120 + rotated_y * sin120,
+                    rotated_y * cos120 - rotated_x * sin120, z_with_offset); // rotate coords to
+                                                                             // +120 deg
+            solution.z = calculateYZ(rotated_x * cos120 - rotated_y * sin120,
+                    rotated_y * cos120 + rotated_x * sin120, z_with_offset); // rotate coords to
+                                                                             // -120 deg
+            solution.successfulCalc = true;
+        }
+        catch (RotatableDeltaKinematicsException e) {
+            throw new RotatableDeltaKinematicsException(String.format(
+                    "Delta calcInverse: Non-existing point for Cartesian location x=%.3f, y=%.3f, z=%.3f, Z_CALC_OFFSET=%.3f",
+                    cartesianLoc.getX(), cartesianLoc.getY(), cartesianLoc.getZ(), Z_CALC_OFFSET));
+        }
+        return solution;
+    }
+
+    // Helper function for calculateDelta()
+    private double calculateYZ(double x, double y, double z)
+            throws RotatableDeltaKinematicsException {
+
+        double y1 = -0.5 * 0.57735 * deltaF; // f/2 * tg 30
+        double y0 = y - (0.5 * 0.57735 * deltaE); // shift center to edge
+        // z = a + b*y
+        double a = (x * x + y0 * y0 + z * z + deltaRf * deltaRf - deltaRe * deltaRe - y1 * y1)
+                / (2 * z);
+        double b = (y1 - y0) / z;
+        // discriminant
+        double d = -(a + b * y1) * (a + b * y1) + deltaRf * (b * b * deltaRf + deltaRf);
+        if (d < 0) {
+            throw new RotatableDeltaKinematicsException("Delta calcInverse: Non-existing point"); // non-existing
+                                                                                                  // point
+        }
+        else {
+            double yj = (y1 - a * b - Math.sqrt(d)) / (b * b + 1); // choosing outer point
+            double zj = a + b * yj;
+            return (180.0 * Math.atan(-zj / (y1 - yj)) / Math.PI + ((yj > y1) ? 180.0 : 0.0));
+        }
+        // return 0;
+
+    }
+
+    // forward kinematics: (theta1, theta2, theta3) -> (x0, y0, z0)
+    // returned status: 0=OK, -1=non-existing position
+    public Location delta_calcForward(AngleTriplet angles)
+            throws RotatableDeltaKinematicsException {
+        double t = (deltaF - deltaE) * tan30 / 2;
+        double dtr = Math.PI / 180.0;
+        double theta1 = angles.x * dtr;
+        double theta2 = angles.y * dtr;
+        double theta3 = angles.z * dtr;
+
+        double y1 = -(t + deltaRf * Math.cos(theta1));
+        double z1 = -deltaRf * Math.sin(theta1);
+
+        double y2 = (t + deltaRf * Math.cos(theta2)) * sin30;
+        double x2 = y2 * tan60;
+        double z2 = -deltaRf * Math.sin(theta2);
+
+        double y3 = (t + deltaRf * Math.cos(theta3)) * sin30;
+        double x3 = -y3 * tan60;
+        double z3 = -deltaRf * Math.sin(theta3);
+
+        double dnm = (y2 - y1) * x3 - (y3 - y1) * x2;
+
+        double w1 = y1 * y1 + z1 * z1;
+        double w2 = x2 * x2 + y2 * y2 + z2 * z2;
+        double w3 = x3 * x3 + y3 * y3 + z3 * z3;
+
+        // x = (a1*z + b1)/dnm
+        double a1 = (z2 - z1) * (y3 - y1) - (z3 - z1) * (y2 - y1);
+        double b1 = -((w2 - w1) * (y3 - y1) - (w3 - w1) * (y2 - y1)) / 2.0;
+
+        // y = (a2*z + b2)/dnm;
+        double a2 = -(z2 - z1) * x3 + (z3 - z1) * x2;
+        double b2 = ((w2 - w1) * x3 - (w3 - w1) * x2) / 2.0;
+
+        // a*z^2 + b*z + c = 0
+        double a = a1 * a1 + a2 * a2 + dnm * dnm;
+        double b = 2 * (a1 * b1 + a2 * (b2 - y1 * dnm) - z1 * dnm * dnm);
+        double c = (b2 - y1 * dnm) * (b2 - y1 * dnm) + b1 * b1
+                + dnm * dnm * (z1 * z1 - deltaRe * deltaRe);
+
+        // discriminant
+        double d = b * b - (float) 4.0 * a * c;
+        if (d < 0) {
+            throw new RotatableDeltaKinematicsException(String.format(
+                    "Delta calcForward: Non-existing point for angles x=%.3f, y=%.3f, z=%.3f",
+                    angles.x, angles.y, angles.z));
+        }
+
+
+        double z = -(double) 0.5 * (b + Math.sqrt(d)) / a;
+        double x = (a1 * z + b1) / dnm;
+        double y = (a2 * z + b2) / dnm;
+
+        z -= Z_CALC_OFFSET; // NJ
+
+        return new Location(LengthUnit.Millimeters, x, y, z, 0);
     }
-    
-    //Helper function for calculateDelta()
-	private double calculateYZ(double x, double y, double z) throws RotatableDeltaKinematicsException {
-
-  	  double y1 = -0.5 * 0.57735 * deltaF; // f/2 * tg 30
-      double y0 = y - (0.5 * 0.57735       * deltaE);    // shift center to edge
-      // z = a + b*y
-      double a = (x*x + y0*y0 + z*z +deltaRf*deltaRf - deltaRe*deltaRe - y1*y1) / (2*z);
-      double b = (y1-y0)/z;
-      // discriminant
-      double d = -(a+b*y1)*(a+b*y1)+deltaRf*(b*b*deltaRf+deltaRf); 
-      if (d < 0)
-      {
-    	  throw new RotatableDeltaKinematicsException("Delta calcInverse: Non-existing point"); // non-existing point
-      }
-      else
-      {
-          double yj = (y1 - a*b - Math.sqrt(d))/(b*b + 1); // choosing outer point
-          double zj = a + b*yj;
-          return (180.0*Math.atan(-zj/(y1 - yj))/Math.PI + ((yj>y1)?180.0:0.0));
-      }
-      //return 0;
-
-	}
-	
-	// forward kinematics: (theta1, theta2, theta3) -> (x0, y0, z0)
-	// returned status: 0=OK, -1=non-existing position
-	public Location delta_calcForward(AngleTriplet angles)  throws RotatableDeltaKinematicsException 
-	{
-	    double t = (deltaF-deltaE)*tan30/2;
-	    double dtr = Math.PI/180.0;
-	    double theta1 = angles.x * dtr;
-	    double theta2 = angles.y * dtr;
-	    double theta3 = angles.z * dtr;
-	 
-	    double y1 = -(t + deltaRf * Math.cos(theta1));
-	    double z1 = -deltaRf * Math.sin(theta1);
-	 
-	    double y2 = (t + deltaRf * Math.cos(theta2)) * sin30;
-	    double x2 = y2 * tan60;
-	    double z2 = -deltaRf * Math.sin(theta2);
-	 
-	    double y3 = (t + deltaRf * Math.cos(theta3)) * sin30;
-	    double x3 = -y3 * tan60;
-	    double z3 = -deltaRf * Math.sin(theta3);
-	 
-	    double dnm = (y2-y1)*x3-(y3-y1)*x2;
-	 
-	    double w1 = y1*y1 + z1*z1;
-	    double w2 = x2*x2 + y2*y2 + z2*z2;
-	    double w3 = x3*x3 + y3*y3 + z3*z3;
-	     
-	    // x = (a1*z + b1)/dnm
-	    double a1 = (z2-z1)*(y3-y1)-(z3-z1)*(y2-y1);
-	    double b1 = -((w2-w1)*(y3-y1)-(w3-w1)*(y2-y1))/2.0;
-	 
-	    // y = (a2*z + b2)/dnm;
-	    double a2 = -(z2-z1)*x3+(z3-z1)*x2;
-	    double b2 = ((w2-w1)*x3 - (w3-w1)*x2)/2.0;
-	 
-	    // a*z^2 + b*z + c = 0
-	    double a = a1*a1 + a2*a2 + dnm*dnm;
-	    double b = 2*(a1*b1 + a2*(b2-y1*dnm) - z1*dnm*dnm);
-	    double c = (b2-y1*dnm)*(b2-y1*dnm) + b1*b1 + dnm*dnm*(z1*z1 - deltaRe*deltaRe);
-	  
-	    // discriminant
-	    double d = b*b - (float)4.0*a*c;
-	    if (d < 0)
-    	{
-	    	throw new RotatableDeltaKinematicsException(String.format("Delta calcForward: Non-existing point for angles x=%.3f, y=%.3f, z=%.3f", angles.x, angles.y, angles.z));
-    	}
-	 
-	    
-	    double z = -(double)0.5 * (b+Math.sqrt(d))/a;
-	    double x = (a1*z + b1)/dnm;
-	    double y = (a2*z + b2)/dnm;
-	    
-	    z -= Z_CALC_OFFSET; //NJ
-	    
-	    return new Location(LengthUnit.Millimeters, x, y, z, 0);
-	}
 }
diff --git a/src/main/java/org/firepick/model/AngleTriplet.java b/src/main/java/org/firepick/model/AngleTriplet.java
index bc93a2e80e..0d6a344eaa 100755
--- a/src/main/java/org/firepick/model/AngleTriplet.java
+++ b/src/main/java/org/firepick/model/AngleTriplet.java
@@ -1,37 +1,34 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.model;
 
-public class AngleTriplet 
-{
-	public AngleTriplet(double x, double y, double z)
-	{
-		this.x = x;
-		this.y = y;
-		this.z = z;
-		this.successfulCalc = false;
-	}
-	public double x = 0;
-	public double y = 0;
-	public double z = 0;
-	public boolean successfulCalc = false;
+public class AngleTriplet {
+    public AngleTriplet(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        this.successfulCalc = false;
+    }
+
+    public double x = 0;
+    public double y = 0;
+    public double z = 0;
+    public boolean successfulCalc = false;
 }
diff --git a/src/main/java/org/firepick/model/Emc02.java b/src/main/java/org/firepick/model/Emc02.java
index 230d3c4258..b083ad9cb4 100755
--- a/src/main/java/org/firepick/model/Emc02.java
+++ b/src/main/java/org/firepick/model/Emc02.java
@@ -1,28 +1,26 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.model;
 
 public class Emc02 {
-	// TODO: Modular tools
-	// TODO: Pin assignments
-	// TODO: 
+    // TODO: Modular tools
+    // TODO: Pin assignments
+    // TODO:
 }
diff --git a/src/main/java/org/firepick/model/RawStepTriplet.java b/src/main/java/org/firepick/model/RawStepTriplet.java
index cf07111219..8b8124f887 100755
--- a/src/main/java/org/firepick/model/RawStepTriplet.java
+++ b/src/main/java/org/firepick/model/RawStepTriplet.java
@@ -1,35 +1,32 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.firepick.model;
 
-public class RawStepTriplet 
-{
-	public RawStepTriplet(int x, int y, int z)
-	{
-		this.x = x;
-		this.y = y;
-		this.z = z;
-	}
-	public int x = 0;
-	public int y = 0;
-	public int z = 0;
+public class RawStepTriplet {
+    public RawStepTriplet(int x, int y, int z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public int x = 0;
+    public int y = 0;
+    public int z = 0;
 }
diff --git a/src/main/java/org/openpnp/CameraListener.java b/src/main/java/org/openpnp/CameraListener.java
index e11ce5f823..accba3b427 100755
--- a/src/main/java/org/openpnp/CameraListener.java
+++ b/src/main/java/org/openpnp/CameraListener.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp;
@@ -24,5 +22,5 @@
 import java.awt.image.BufferedImage;
 
 public interface CameraListener {
-	public void frameReceived(BufferedImage img);
+    public void frameReceived(BufferedImage img);
 }
diff --git a/src/main/java/org/openpnp/ConfigurationListener.java b/src/main/java/org/openpnp/ConfigurationListener.java
index 60b03254b8..2fe51c2dbe 100755
--- a/src/main/java/org/openpnp/ConfigurationListener.java
+++ b/src/main/java/org/openpnp/ConfigurationListener.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp;
@@ -25,40 +23,33 @@
 
 public interface ConfigurationListener {
     /**
-     * Called by Configuration when it has been loaded from disk. This method
-     * will also be called when the ConfigurationListener is added to the
-     * Configuration if the Configuration has already been loaded. When this
-     * method is called, the Configuration may not yet be complete. This method
-     * is intended to function as a chance for listeners to resolve parts of
-     * their Configuration that depend on other Configuration objects.
+     * Called by Configuration when it has been loaded from disk. This method will also be called
+     * when the ConfigurationListener is added to the Configuration if the Configuration has already
+     * been loaded. When this method is called, the Configuration may not yet be complete. This
+     * method is intended to function as a chance for listeners to resolve parts of their
+     * Configuration that depend on other Configuration objects.
      * 
      * @param configuration
      */
-    public void configurationLoaded(Configuration configuration)
-            throws Exception;
+    public void configurationLoaded(Configuration configuration) throws Exception;
 
     /**
-     * Called by Configuration after all existing listeners have been notified
-     * with configurationLoaded. This is a signal that the Configuration is
-     * complete and resolved and is ready to be used for runtime tasks. This
-     * method will also be called when the ConfigurationListener is added to the
-     * Configuration if the Configuration has already been loaded.
+     * Called by Configuration after all existing listeners have been notified with
+     * configurationLoaded. This is a signal that the Configuration is complete and resolved and is
+     * ready to be used for runtime tasks. This method will also be called when the
+     * ConfigurationListener is added to the Configuration if the Configuration has already been
+     * loaded.
      * 
      * @param configuration
      * @throws Exception
      */
-    public void configurationComplete(Configuration configuration)
-            throws Exception;
-    
+    public void configurationComplete(Configuration configuration) throws Exception;
+
     public static class Adapter implements ConfigurationListener {
         @Override
-        public void configurationLoaded(Configuration configuration)
-                throws Exception {
-        }
+        public void configurationLoaded(Configuration configuration) throws Exception {}
 
         @Override
-        public void configurationComplete(Configuration configuration)
-                throws Exception {
-        }
+        public void configurationComplete(Configuration configuration) throws Exception {}
     }
 }
diff --git a/src/main/java/org/openpnp/JobProcessorDelegate.java b/src/main/java/org/openpnp/JobProcessorDelegate.java
index 0795da7e0f..e4db5628b3 100755
--- a/src/main/java/org/openpnp/JobProcessorDelegate.java
+++ b/src/main/java/org/openpnp/JobProcessorDelegate.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp;
@@ -27,13 +25,14 @@
 import org.openpnp.spi.JobProcessor.PickRetryAction;
 
 public interface JobProcessorDelegate {
-	/**
-	 * Notifies the delegate that the machine failed to pick the part and waits for
-	 * a PickRetryAction response to determine what to do next.
-	 * @param board
-	 * @param part
-	 * @param feeder
-	 * @return
-	 */
-	public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder);
+    /**
+     * Notifies the delegate that the machine failed to pick the part and waits for a
+     * PickRetryAction response to determine what to do next.
+     * 
+     * @param board
+     * @param part
+     * @param feeder
+     * @return
+     */
+    public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder);
 }
diff --git a/src/main/java/org/openpnp/JobProcessorListener.java b/src/main/java/org/openpnp/JobProcessorListener.java
index 6e44e6c179..b5fc039e61 100755
--- a/src/main/java/org/openpnp/JobProcessorListener.java
+++ b/src/main/java/org/openpnp/JobProcessorListener.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp;
@@ -29,100 +27,91 @@
 
 /**
  * Allows an interested listener to receive events as the JobProcessor does it's work. Methods in
- * this interface are for passive observers.  
+ * this interface are for passive observers.
  *
  */
 public interface JobProcessorListener {
-	public void jobLoaded(Job job);
-	
-	/**
-	 * Indicates that the state of the Job has changed. This is generally in response to
-	 * one of the Job control methods such as start(), pause(), resume(), or stop() being
-	 * called. 
-	 * @param state
-	 */
-	public void jobStateChanged(JobState state);
-	
-	public void jobEncounteredError(JobError error, String description);
-	
-	/**
-	 * Fired when the JobProcessor has begun operations that include the
-	 * given Placement.
-	 * @param board
-	 * @param placement
-	 */
-	public void partProcessingStarted(BoardLocation board, Placement placement);
-	
-	/**
-	 * Fired when the JobProcessor has completed the pick operation for the
-	 * given Placement.
-	 * @param board
-	 * @param placement
-	 */
-	public void partPicked(BoardLocation board, Placement placement);
-	
-	/**
-	 * Fired when the JobProcessor has completed the place operation for the
-	 * given Placement.
-	 * @param board
-	 * @param placement
-	 */
-	public void partPlaced(BoardLocation board, Placement placement);
-	
-	/**
-	 * Fired when the JobProcessor has completed all operations regarding the
-	 * given Placement.
-	 * @param board
-	 * @param placement
-	 */
-	public void partProcessingCompleted(BoardLocation board, Placement placement);
-	
-	// TODO Maybe partProcessingFailed with a reason
-	
-	// TODO Add job progress information, especially after pre-processing
-	// so that listeners can know the total placement count to be processed.
-	
-	/**
-	 * Fired when the JobProcessor is able to report detailed, human readable
-	 * status information about the Job's progress.
-	 * @param status
-	 */
-	public void detailedStatusUpdated(String status);
-	
-	static public class Adapter implements JobProcessorListener {
-
-		@Override
-		public void jobLoaded(Job job) {
-		}
-
-		@Override
-		public void jobStateChanged(JobState state) {
-		}
-
-		@Override
-		public void jobEncounteredError(JobError error, String description) {
-		}
-
-		@Override
-		public void partProcessingStarted(BoardLocation board,
-				Placement placement) {
-		}
-
-		@Override
-		public void partPicked(BoardLocation board, Placement placement) {
-		}
-
-		@Override
-		public void partPlaced(BoardLocation board, Placement placement) {
-		}
-
-		@Override
-		public void partProcessingCompleted(BoardLocation board,
-				Placement placement) {
-		}
-
-		@Override
-		public void detailedStatusUpdated(String status) {
-		}
-	}
+    public void jobLoaded(Job job);
+
+    /**
+     * Indicates that the state of the Job has changed. This is generally in response to one of the
+     * Job control methods such as start(), pause(), resume(), or stop() being called.
+     * 
+     * @param state
+     */
+    public void jobStateChanged(JobState state);
+
+    public void jobEncounteredError(JobError error, String description);
+
+    /**
+     * Fired when the JobProcessor has begun operations that include the given Placement.
+     * 
+     * @param board
+     * @param placement
+     */
+    public void partProcessingStarted(BoardLocation board, Placement placement);
+
+    /**
+     * Fired when the JobProcessor has completed the pick operation for the given Placement.
+     * 
+     * @param board
+     * @param placement
+     */
+    public void partPicked(BoardLocation board, Placement placement);
+
+    /**
+     * Fired when the JobProcessor has completed the place operation for the given Placement.
+     * 
+     * @param board
+     * @param placement
+     */
+    public void partPlaced(BoardLocation board, Placement placement);
+
+    /**
+     * Fired when the JobProcessor has completed all operations regarding the given Placement.
+     * 
+     * @param board
+     * @param placement
+     */
+    public void partProcessingCompleted(BoardLocation board, Placement placement);
+
+    // TODO Maybe partProcessingFailed with a reason
+
+    // TODO Add job progress information, especially after pre-processing
+    // so that listeners can know the total placement count to be processed.
+
+    /**
+     * Fired when the JobProcessor is able to report detailed, human readable status information
+     * about the Job's progress.
+     * 
+     * @param status
+     */
+    public void detailedStatusUpdated(String status);
+
+    static public class Adapter implements JobProcessorListener {
+
+        @Override
+        public void jobLoaded(Job job) {}
+
+        @Override
+        public void jobStateChanged(JobState state) {}
+
+        @Override
+        public void jobEncounteredError(JobError error, String description) {}
+
+        @Override
+        public void partProcessingStarted(BoardLocation board, Placement placement) {}
+
+        @Override
+        public void partPicked(BoardLocation board, Placement placement) {}
+
+        @Override
+        public void partPlaced(BoardLocation board, Placement placement) {}
+
+        @Override
+        public void partProcessingCompleted(BoardLocation board, Placement placement) {}
+
+        @Override
+        public void detailedStatusUpdated(String status) {}
+    }
 }
diff --git a/src/main/java/org/openpnp/Main.java b/src/main/java/org/openpnp/Main.java
index a4162b84e8..52bc077c8e 100755
--- a/src/main/java/org/openpnp/Main.java
+++ b/src/main/java/org/openpnp/Main.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp;
 
@@ -34,72 +32,74 @@
 
 /**
  * Start with -Xdock:name=OpenPnP on Mac to make it prettier.
+ * 
  * @author jason
  *
  */
 public class Main {
-	private static Logger logger;
-	
-	public static String getVersion() {
-		String version = Main.class.getPackage().getImplementationVersion();
-		if (version == null) {
-			version = "INTERNAL BUILD";
-		}
-		return version;
-	}
-	
-	public static void main(String[] args) {
-		// http://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/07-NativePlatformIntegration/NativePlatformIntegration.html#//apple_ref/doc/uid/TP40001909-212952-TPXREF134
-		System.setProperty("apple.laf.useScreenMenuBar", "true");
-		try {
-			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
-		}
-		catch (Exception e) {
-			throw new Error(e);
-		}
-		
-		File configurationDirectory = new File(System.getProperty("user.home"));
-		configurationDirectory = new File(configurationDirectory, ".openpnp");
-		
-		if (System.getProperty("configDir") != null) {
-		    configurationDirectory = new File(System.getProperty("configDir"));
-		}
-		
-		// If the log4j.properties is not in the configuration directory, copy
-		// the default over.
-		File log4jConfigurationFile = new File(configurationDirectory, "log4j.properties");
-		if (!log4jConfigurationFile.exists()) {
-			try {
-				FileUtils.copyURLToFile(ClassLoader.getSystemResource("log4j.properties"), log4jConfigurationFile);
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-		}
-		
-		// Use the local configuration if it exists.
-		if (log4jConfigurationFile.exists()) {
-			System.setProperty("log4j.configuration", log4jConfigurationFile.toURI().toString());
-		}
-		
-		// We don't create a logger until log4j has been configured or it tries
-		// to configure itself.
-		logger = LoggerFactory.getLogger(Main.class);
-		
-		logger.debug(String.format("OpenPnP %s Started.", Main.getVersion()));
-		
-		Configuration.initialize(configurationDirectory);
-		final Configuration configuration = Configuration.get();
-		EventQueue.invokeLater(new Runnable() {
-			public void run() {
-				try {
-					MainFrame frame = new MainFrame(configuration);
-					frame.setVisible(true);
-				}
-				catch (Exception e) {
-					e.printStackTrace();
-				}
-			}
-		});
-	}
+    private static Logger logger;
+
+    public static String getVersion() {
+        String version = Main.class.getPackage().getImplementationVersion();
+        if (version == null) {
+            version = "INTERNAL BUILD";
+        }
+        return version;
+    }
+
+    public static void main(String[] args) {
+        // http://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/07-NativePlatformIntegration/NativePlatformIntegration.html#//apple_ref/doc/uid/TP40001909-212952-TPXREF134
+        System.setProperty("apple.laf.useScreenMenuBar", "true");
+        try {
+            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        }
+        catch (Exception e) {
+            throw new Error(e);
+        }
+
+        File configurationDirectory = new File(System.getProperty("user.home"));
+        configurationDirectory = new File(configurationDirectory, ".openpnp");
+
+        if (System.getProperty("configDir") != null) {
+            configurationDirectory = new File(System.getProperty("configDir"));
+        }
+
+        // If the log4j.properties is not in the configuration directory, copy
+        // the default over.
+        File log4jConfigurationFile = new File(configurationDirectory, "log4j.properties");
+        if (!log4jConfigurationFile.exists()) {
+            try {
+                FileUtils.copyURLToFile(ClassLoader.getSystemResource("log4j.properties"),
+                        log4jConfigurationFile);
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Use the local configuration if it exists.
+        if (log4jConfigurationFile.exists()) {
+            System.setProperty("log4j.configuration", log4jConfigurationFile.toURI().toString());
+        }
+
+        // We don't create a logger until log4j has been configured or it tries
+        // to configure itself.
+        logger = LoggerFactory.getLogger(Main.class);
+
+        logger.debug(String.format("OpenPnP %s Started.", Main.getVersion()));
+
+        Configuration.initialize(configurationDirectory);
+        final Configuration configuration = Configuration.get();
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                try {
+                    MainFrame frame = new MainFrame(configuration);
+                    frame.setVisible(true);
+                }
+                catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+    }
 }
diff --git a/src/main/java/org/openpnp/experiments/FiducialTest.java b/src/main/java/org/openpnp/experiments/FiducialTest.java
index 52263f7c34..84c99b3b9c 100755
--- a/src/main/java/org/openpnp/experiments/FiducialTest.java
+++ b/src/main/java/org/openpnp/experiments/FiducialTest.java
@@ -1,6 +1,5 @@
 /**
- * FiducialTest code provided by Cri S. Demonstrates round fiducial finding
- * using contours.
+ * FiducialTest code provided by Cri S. Demonstrates round fiducial finding using contours.
  */
 
 package org.openpnp.experiments;
@@ -39,7 +38,7 @@
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
-    }    
+    }
 
     public static void showResult(String name, Mat img) {
         // Imgproc.resize(img, img, new Size(640, 480));
@@ -57,13 +56,12 @@ public static void showResult(String name, Mat img) {
             // frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
             frame.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)
                     .put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "EXIT");
-            frame.getRootPane().getActionMap()
-                    .put("EXIT", new AbstractAction() {
-                        public void actionPerformed(ActionEvent e) {
-                            // frame.dispose();
-                            System.exit(0);
-                        }
-                    });
+            frame.getRootPane().getActionMap().put("EXIT", new AbstractAction() {
+                public void actionPerformed(ActionEvent e) {
+                    // frame.dispose();
+                    System.exit(0);
+                }
+            });
         }
         catch (Exception e) {
             e.printStackTrace();
@@ -94,8 +92,7 @@ static public Point fiducial(Mat gray, int min, int max) throws Exception {
         Imgproc.threshold(bw, bw, 100, 255, 0);
         showResult("Canny", bw);
         // scan blobs
-        Imgproc.findContours(bw, contours, dummy, Imgproc.RETR_LIST,
-                Imgproc.CHAIN_APPROX_SIMPLE);
+        Imgproc.findContours(bw, contours, dummy, Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);
         // get dimension, in java bit different
 
         final MatOfPoint2f temp = new MatOfPoint2f();
@@ -112,8 +109,7 @@ static public Point fiducial(Mat gray, int min, int max) throws Exception {
             l = Imgproc.arcLength(temp, true);
             a = Imgproc.contourArea(contours.get(i));
             t = (a / (Math.PI * Math.pow(box.get(i).size.width / 2, 2)));
-            if (f <= 0.8 || f >= 1.2 || t >= 1.2 || t <= 0.8
-                    || box.get(i).size.width < min
+            if (f <= 0.8 || f >= 1.2 || t >= 1.2 || t <= 0.8 || box.get(i).size.width < min
                     || box.get(i).size.width > max || a < 100.) {
                 contours.remove(i);
                 continue;
@@ -152,8 +148,8 @@ static public Point fiducial(Mat gray, int min, int max) throws Exception {
             Imgproc.drawContours(dst, contours, i, new Scalar(0, 0, 255), 2); // java
                                                                               // thing
             Core.circle(dst, ret, 4, new Scalar(0, 255, 255), -1);
-            Core.circle(dst, new Point(r.x + r.width / 2, r.y + r.height / 2),
-                    4, new Scalar(0, 0, 255), -1);
+            Core.circle(dst, new Point(r.x + r.width / 2, r.y + r.height / 2), 4,
+                    new Scalar(0, 0, 255), -1);
             showResult("found", dst);
             // <<<<<<<<<<< end of debug
             // do java problem, it don't have supixel resulution, as cv version
@@ -168,16 +164,13 @@ static public Point fiducial(Mat gray, int min, int max) throws Exception {
 
     public static void main(String[] args) throws Exception {
         int min = 0, max = 999999;
-        args = new String[] {
-                "",
+        args = new String[] {"",
                 "/Users/jason/.openpnp/org.openpnp.machine.reference.vision.OpenCvVisionProvider/camera_41173395697117969.png",
-                "/Users/jason/Desktop/result.png"
-        };
+                "/Users/jason/Desktop/result.png"};
         if (args.length > 2)
             ;
         else {
-            System.out
-                    .println("Usage: <prg> <image> <result> [ <min-pixel> <max-pixel> ]");
+            System.out.println("Usage: <prg> <image> <result> [ <min-pixel> <max-pixel> ]");
             return;
         }
         if (args.length > 4) {
diff --git a/src/main/java/org/openpnp/gui/AboutDialog.java b/src/main/java/org/openpnp/gui/AboutDialog.java
index 85e271b126..82d869dd70 100755
--- a/src/main/java/org/openpnp/gui/AboutDialog.java
+++ b/src/main/java/org/openpnp/gui/AboutDialog.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui;
 
@@ -41,41 +39,40 @@
 @SuppressWarnings("serial")
 public class AboutDialog extends JDialog {
 
-	private final JPanel contentPanel = new JPanel();
+    private final JPanel contentPanel = new JPanel();
 
-	public AboutDialog(Frame frame) {
-		super(frame, true);
-		setTitle("About OpenPnP");
-		setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
-		setBounds(100, 100, 347, 360);
-		getContentPane().setLayout(new BorderLayout());
-		contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
-		getContentPane().add(contentPanel, BorderLayout.CENTER);
-		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
-		JLabel lblOpenpnp = new JLabel("OpenPnP");
-		lblOpenpnp.setAlignmentX(Component.CENTER_ALIGNMENT);
-		lblOpenpnp.setFont(new Font("Lucida Grande", Font.BOLD, 32));
-		contentPanel.add(lblOpenpnp);
-		JLabel lblCopyright = new JLabel(
-				"Copyright © 2011, 2012, 2013 Jason von Nieda");
-		lblCopyright.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
-		lblCopyright.setAlignmentX(Component.CENTER_ALIGNMENT);
-		contentPanel.add(lblCopyright);
-		JLabel lblVersion = new JLabel("Version: " + Main.getVersion());
-		lblVersion.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
-		lblVersion.setAlignmentX(Component.CENTER_ALIGNMENT);
-		contentPanel.add(lblVersion);
-		JPanel buttonPane = new JPanel();
-		buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
-		getContentPane().add(buttonPane, BorderLayout.SOUTH);
-		JButton okButton = new JButton("OK");
-		okButton.addActionListener(new ActionListener() {
-			public void actionPerformed(ActionEvent arg0) {
-				setVisible(false);
-			}
-		});
-		okButton.setActionCommand("OK");
-		buttonPane.add(okButton);
-		getRootPane().setDefaultButton(okButton);
-	}
+    public AboutDialog(Frame frame) {
+        super(frame, true);
+        setTitle("About OpenPnP");
+        setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
+        setBounds(100, 100, 347, 360);
+        getContentPane().setLayout(new BorderLayout());
+        contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
+        getContentPane().add(contentPanel, BorderLayout.CENTER);
+        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
+        JLabel lblOpenpnp = new JLabel("OpenPnP");
+        lblOpenpnp.setAlignmentX(Component.CENTER_ALIGNMENT);
+        lblOpenpnp.setFont(new Font("Lucida Grande", Font.BOLD, 32));
+        contentPanel.add(lblOpenpnp);
+        JLabel lblCopyright = new JLabel("Copyright © 2011, 2012, 2013 Jason von Nieda");
+        lblCopyright.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
+        lblCopyright.setAlignmentX(Component.CENTER_ALIGNMENT);
+        contentPanel.add(lblCopyright);
+        JLabel lblVersion = new JLabel("Version: " + Main.getVersion());
+        lblVersion.setFont(new Font("Lucida Grande", Font.PLAIN, 10));
+        lblVersion.setAlignmentX(Component.CENTER_ALIGNMENT);
+        contentPanel.add(lblVersion);
+        JPanel buttonPane = new JPanel();
+        buttonPane.setLayout(new FlowLayout(FlowLayout.RIGHT));
+        getContentPane().add(buttonPane, BorderLayout.SOUTH);
+        JButton okButton = new JButton("OK");
+        okButton.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent arg0) {
+                setVisible(false);
+            }
+        });
+        okButton.setActionCommand("OK");
+        buttonPane.add(okButton);
+        getRootPane().setDefaultButton(okButton);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/CamerasPanel.java b/src/main/java/org/openpnp/gui/CamerasPanel.java
index f194bc9c8e..d39444c769 100755
--- a/src/main/java/org/openpnp/gui/CamerasPanel.java
+++ b/src/main/java/org/openpnp/gui/CamerasPanel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui;
 
@@ -74,143 +72,142 @@
 
 @SuppressWarnings("serial")
 public class CamerasPanel extends JPanel implements WizardContainer {
-	private final static Logger logger = LoggerFactory.getLogger(CamerasPanel.class);
-
-	private static final String PREF_DIVIDER_POSITION = "CamerasPanel.dividerPosition";
-	private static final int PREF_DIVIDER_POSITION_DEF = -1;
-	
-	private final Frame frame;
-	private final Configuration configuration;
-	
-	private JTable table;
-
-	private CamerasTableModel tableModel;
-	private TableRowSorter<CamerasTableModel> tableSorter;
-	private JTextField searchTextField;
-	private JComboBox headsComboBox;
-
-	private Preferences prefs = Preferences.userNodeForPackage(CamerasPanel.class);
-
-	public CamerasPanel(Frame frame, Configuration configuration) {
-		this.frame = frame;
-		this.configuration = configuration;
-		
-		setLayout(new BorderLayout(0, 0));
-		tableModel = new CamerasTableModel(configuration);
-
-		JPanel panel = new JPanel();
-		add(panel, BorderLayout.NORTH);
-		panel.setLayout(new BorderLayout(0, 0));
-
-		JToolBar toolBar = new JToolBar();
-		toolBar.setFloatable(false);
-		panel.add(toolBar, BorderLayout.CENTER);
-		
-		JButton btnNewCamera = new JButton(newCameraAction);
-		btnNewCamera.setHideActionText(true);
-		toolBar.add(btnNewCamera);
-		
-		JButton btnDeleteCamera = new JButton(deleteCameraAction);
-		btnDeleteCamera.setHideActionText(true);
-		toolBar.add(btnDeleteCamera);
-		
-		JPanel panel_1 = new JPanel();
-		panel.add(panel_1, BorderLayout.EAST);
-
-		JLabel lblSearch = new JLabel("Search");
-		panel_1.add(lblSearch);
-
-		searchTextField = new JTextField();
+    private final static Logger logger = LoggerFactory.getLogger(CamerasPanel.class);
+
+    private static final String PREF_DIVIDER_POSITION = "CamerasPanel.dividerPosition";
+    private static final int PREF_DIVIDER_POSITION_DEF = -1;
+
+    private final Frame frame;
+    private final Configuration configuration;
+
+    private JTable table;
+
+    private CamerasTableModel tableModel;
+    private TableRowSorter<CamerasTableModel> tableSorter;
+    private JTextField searchTextField;
+    private JComboBox headsComboBox;
+
+    private Preferences prefs = Preferences.userNodeForPackage(CamerasPanel.class);
+
+    public CamerasPanel(Frame frame, Configuration configuration) {
+        this.frame = frame;
+        this.configuration = configuration;
+
+        setLayout(new BorderLayout(0, 0));
+        tableModel = new CamerasTableModel(configuration);
+
+        JPanel panel = new JPanel();
+        add(panel, BorderLayout.NORTH);
+        panel.setLayout(new BorderLayout(0, 0));
+
+        JToolBar toolBar = new JToolBar();
+        toolBar.setFloatable(false);
+        panel.add(toolBar, BorderLayout.CENTER);
+
+        JButton btnNewCamera = new JButton(newCameraAction);
+        btnNewCamera.setHideActionText(true);
+        toolBar.add(btnNewCamera);
+
+        JButton btnDeleteCamera = new JButton(deleteCameraAction);
+        btnDeleteCamera.setHideActionText(true);
+        toolBar.add(btnDeleteCamera);
+
+        JPanel panel_1 = new JPanel();
+        panel.add(panel_1, BorderLayout.EAST);
+
+        JLabel lblSearch = new JLabel("Search");
+        panel_1.add(lblSearch);
+
+        searchTextField = new JTextField();
         searchTextField.getDocument().addDocumentListener(new DocumentListener() {
             @Override
             public void removeUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void insertUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void changedUpdate(DocumentEvent e) {
                 search();
             }
         });
-		panel_1.add(searchTextField);
-		searchTextField.setColumns(15);
-
-		JComboBox lookingComboBox = new JComboBox(Looking.values());
-		headsComboBox = new JComboBox();
-		
-		table = new AutoSelectTextTable(tableModel);
-		tableSorter = new TableRowSorter<>(tableModel);
-		table.getColumnModel().getColumn(2).setCellEditor(new DefaultCellEditor(lookingComboBox));
-		table.getColumnModel().getColumn(3).setCellEditor(new DefaultCellEditor(headsComboBox));
-		
-		final JSplitPane splitPane = new JSplitPane();
-		splitPane.setContinuousLayout(true);
-		splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
-		splitPane.addPropertyChangeListener("dividerLocation",
-				new PropertyChangeListener() {
-					@Override
-					public void propertyChange(PropertyChangeEvent evt) {
-						prefs.putInt(PREF_DIVIDER_POSITION,
-								splitPane.getDividerLocation());
-					}
-				});
-		
-		
-		
-		add(splitPane, BorderLayout.CENTER);
-		splitPane.setLeftComponent(new JScrollPane(table));
-		table.setRowSorter(tableSorter);
-		table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-		
-		JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
-		splitPane.setRightComponent(tabbedPane);
-		
-		generalConfigPanel = new JPanel();
-		tabbedPane.addTab("General Configuration", null, generalConfigPanel, null);
-		generalConfigPanel.setLayout(new BorderLayout(0, 0));
-		
+        panel_1.add(searchTextField);
+        searchTextField.setColumns(15);
+
+        JComboBox lookingComboBox = new JComboBox(Looking.values());
+        headsComboBox = new JComboBox();
+
+        table = new AutoSelectTextTable(tableModel);
+        tableSorter = new TableRowSorter<>(tableModel);
+        table.getColumnModel().getColumn(2).setCellEditor(new DefaultCellEditor(lookingComboBox));
+        table.getColumnModel().getColumn(3).setCellEditor(new DefaultCellEditor(headsComboBox));
+
+        final JSplitPane splitPane = new JSplitPane();
+        splitPane.setContinuousLayout(true);
+        splitPane
+                .setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
+        splitPane.addPropertyChangeListener("dividerLocation", new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent evt) {
+                prefs.putInt(PREF_DIVIDER_POSITION, splitPane.getDividerLocation());
+            }
+        });
+
+
+
+        add(splitPane, BorderLayout.CENTER);
+        splitPane.setLeftComponent(new JScrollPane(table));
+        table.setRowSorter(tableSorter);
+        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+
+        JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
+        splitPane.setRightComponent(tabbedPane);
+
+        generalConfigPanel = new JPanel();
+        tabbedPane.addTab("General Configuration", null, generalConfigPanel, null);
+        generalConfigPanel.setLayout(new BorderLayout(0, 0));
+
         cameraSpecificConfigPanel = new JPanel();
         tabbedPane.addTab("Camera Specific", null, cameraSpecificConfigPanel, null);
         cameraSpecificConfigPanel.setLayout(new BorderLayout(0, 0));
-        
+
         visionProviderConfigPanel = new JPanel();
         tabbedPane.addTab("Vision Provider", null, visionProviderConfigPanel, null);
         visionProviderConfigPanel.setLayout(new BorderLayout(0, 0));
-        
-		table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
-			@Override
-			public void valueChanged(ListSelectionEvent e) {
-				if (e.getValueIsAdjusting()) {
-					return;
-				}
-				int index = table.getSelectedRow();
-				
-				generalConfigPanel.removeAll();
+
+        table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+                int index = table.getSelectedRow();
+
+                generalConfigPanel.removeAll();
                 cameraSpecificConfigPanel.removeAll();
                 visionProviderConfigPanel.removeAll();
-                
-				if (index != -1) {
-					index = table.convertRowIndexToModel(index);
-					Camera camera = tableModel.getCamera(index);
-					Wizard generalConfigWizard = new CameraConfigurationWizard(camera);
-					if (generalConfigWizard != null) {
-						generalConfigWizard.setWizardContainer(CamerasPanel.this);
-						JPanel panel = generalConfigWizard.getWizardPanel();
-						generalConfigPanel.add(panel);
-					}
-					
+
+                if (index != -1) {
+                    index = table.convertRowIndexToModel(index);
+                    Camera camera = tableModel.getCamera(index);
+                    Wizard generalConfigWizard = new CameraConfigurationWizard(camera);
+                    if (generalConfigWizard != null) {
+                        generalConfigWizard.setWizardContainer(CamerasPanel.this);
+                        JPanel panel = generalConfigWizard.getWizardPanel();
+                        generalConfigPanel.add(panel);
+                    }
+
                     Wizard cameraSpecificConfigWizard = camera.getConfigurationWizard();
                     if (cameraSpecificConfigWizard != null) {
                         cameraSpecificConfigWizard.setWizardContainer(CamerasPanel.this);
                         JPanel panel = cameraSpecificConfigWizard.getWizardPanel();
                         cameraSpecificConfigPanel.add(panel);
                     }
-                    
+
                     VisionProvider visionProvider = camera.getVisionProvider();
                     if (visionProvider != null) {
                         Wizard visionProviderConfigWizard = visionProvider.getConfigurationWizard();
@@ -220,24 +217,24 @@ public void valueChanged(ListSelectionEvent e) {
                             visionProviderConfigPanel.add(panel);
                         }
                     }
-				}
-				
-				revalidate();
-				repaint();
-			}
-		});
-		
+                }
+
+                revalidate();
+                repaint();
+            }
+        });
+
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             public void configurationComplete(Configuration configuration) throws Exception {
                 headsComboBox.removeAllItems();
-                headsComboBox.addItem(new HeadCellValue((Head) null)); 
+                headsComboBox.addItem(new HeadCellValue((Head) null));
                 for (Head head : configuration.getMachine().getHeads()) {
                     headsComboBox.addItem(new HeadCellValue(head));
                 }
             }
         });
-	}
-	
+    }
+
     private Camera getSelectedCamera() {
         int index = table.getSelectedRow();
 
@@ -250,90 +247,82 @@ private Camera getSelectedCamera() {
     }
 
     private void search() {
-		RowFilter<CamerasTableModel, Object> rf = null;
-		// If current expression doesn't parse, don't update.
-		try {
-			rf = RowFilter.regexFilter("(?i)" + searchTextField.getText().trim());
-		}
-		catch (PatternSyntaxException e) {
-			logger.warn("Search failed", e);
-			return;
-		}
-		tableSorter.setRowFilter(rf);
-	}
-
-	@Override
-	public void wizardCompleted(Wizard wizard) {
-	}
-
-	@Override
-	public void wizardCancelled(Wizard wizard) {
-	}
-	
-	public Action newCameraAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.add);
-			putValue(NAME, "New Camera...");
-			putValue(SHORT_DESCRIPTION,
-					"Create a new camera.");
-		}
-		
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			ClassSelectionDialog<Camera> dialog = new ClassSelectionDialog<>(
-					JOptionPane.getFrameForComponent(CamerasPanel.this),
-					"Select Camera...",
-					"Please select a Camera implemention from the list below.",
-					configuration.getMachine().getCompatibleCameraClasses());
-			dialog.setVisible(true);
-			Class<? extends Camera> cameraClass = dialog.getSelectedClass();
-			if (cameraClass == null) {
-				return;
-			}
-			try {
-				Camera camera = cameraClass.newInstance();
-				
-				camera.setUnitsPerPixel(new Location(Configuration.get().getSystemUnits()));
-				try {
-					if (camera.getVisionProvider() == null) {
-						camera.setVisionProvider(new OpenCvVisionProvider());
-					}
-				}
-				catch (Exception e) {
-					logger.debug("Couldn't set default vision provider. Meh.");
-				}
-				
-				
-				configuration.getMachine().addCamera(camera);
-				
-				MainFrame.cameraPanel.addCamera(camera);
-				tableModel.refresh();
-				Helpers.selectLastTableRow(table);
-			}
-			catch (Exception e) {
-				MessageBoxes.errorBox(
-						JOptionPane.getFrameForComponent(CamerasPanel.this), 
-						"Camera Error", 
-						e);
-			}
-		}
-	};
-
-	public Action deleteCameraAction = new AbstractAction("Delete Camera") {
-		{
-			putValue(SMALL_ICON, Icons.delete);
-			putValue(NAME, "Delete Camera");
-			putValue(SHORT_DESCRIPTION,
-					"Delete the currently selected camera.");
-		}
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-		    Camera camera = getSelectedCamera();
-            int ret = JOptionPane.showConfirmDialog(
-                    getTopLevelAncestor(), 
+        RowFilter<CamerasTableModel, Object> rf = null;
+        // If current expression doesn't parse, don't update.
+        try {
+            rf = RowFilter.regexFilter("(?i)" + searchTextField.getText().trim());
+        }
+        catch (PatternSyntaxException e) {
+            logger.warn("Search failed", e);
+            return;
+        }
+        tableSorter.setRowFilter(rf);
+    }
+
+    @Override
+    public void wizardCompleted(Wizard wizard) {}
+
+    @Override
+    public void wizardCancelled(Wizard wizard) {}
+
+    public Action newCameraAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.add);
+            putValue(NAME, "New Camera...");
+            putValue(SHORT_DESCRIPTION, "Create a new camera.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            ClassSelectionDialog<Camera> dialog = new ClassSelectionDialog<>(
+                    JOptionPane.getFrameForComponent(CamerasPanel.this), "Select Camera...",
+                    "Please select a Camera implemention from the list below.",
+                    configuration.getMachine().getCompatibleCameraClasses());
+            dialog.setVisible(true);
+            Class<? extends Camera> cameraClass = dialog.getSelectedClass();
+            if (cameraClass == null) {
+                return;
+            }
+            try {
+                Camera camera = cameraClass.newInstance();
+
+                camera.setUnitsPerPixel(new Location(Configuration.get().getSystemUnits()));
+                try {
+                    if (camera.getVisionProvider() == null) {
+                        camera.setVisionProvider(new OpenCvVisionProvider());
+                    }
+                }
+                catch (Exception e) {
+                    logger.debug("Couldn't set default vision provider. Meh.");
+                }
+
+
+                configuration.getMachine().addCamera(camera);
+
+                MainFrame.cameraPanel.addCamera(camera);
+                tableModel.refresh();
+                Helpers.selectLastTableRow(table);
+            }
+            catch (Exception e) {
+                MessageBoxes.errorBox(JOptionPane.getFrameForComponent(CamerasPanel.this),
+                        "Camera Error", e);
+            }
+        }
+    };
+
+    public Action deleteCameraAction = new AbstractAction("Delete Camera") {
+        {
+            putValue(SMALL_ICON, Icons.delete);
+            putValue(NAME, "Delete Camera");
+            putValue(SHORT_DESCRIPTION, "Delete the currently selected camera.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            Camera camera = getSelectedCamera();
+            int ret = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
                     "Are you sure you want to delete " + camera.getName() + "?",
-                    "Delete " + camera.getName() + "?",
-                    JOptionPane.YES_NO_OPTION);
+                    "Delete " + camera.getName() + "?", JOptionPane.YES_NO_OPTION);
             if (ret == JOptionPane.YES_OPTION) {
                 if (camera.getHead() != null) {
                     camera.getHead().removeCamera(camera);
@@ -342,16 +331,14 @@ public void actionPerformed(ActionEvent arg0) {
                     configuration.getMachine().removeCamera(camera);
                 }
                 tableModel.refresh();
-                MessageBoxes.errorBox(
-                        getTopLevelAncestor(), 
-                        "Restart Required", 
-                        camera.getName() + " has been removed. Please restart OpenPnP for the changes to take effect.");
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Restart Required", camera.getName()
+                        + " has been removed. Please restart OpenPnP for the changes to take effect.");
             }
-		}
-	};
-	
-	
-	private JPanel generalConfigPanel;
+        }
+    };
+
+
+    private JPanel generalConfigPanel;
     private JPanel cameraSpecificConfigPanel;
     private JPanel visionProviderConfigPanel;
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/FeedersPanel.java b/src/main/java/org/openpnp/gui/FeedersPanel.java
index 6a96a1989e..668c5846a6 100755
--- a/src/main/java/org/openpnp/gui/FeedersPanel.java
+++ b/src/main/java/org/openpnp/gui/FeedersPanel.java
@@ -1,30 +1,26 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
 
 import java.awt.BorderLayout;
 import java.awt.event.ActionEvent;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
 import java.util.prefs.Preferences;
@@ -51,9 +47,7 @@
 import javax.swing.table.TableRowSorter;
 
 import org.openpnp.gui.components.AutoSelectTextTable;
-import org.openpnp.gui.components.CameraView;
 import org.openpnp.gui.components.ClassSelectionDialog;
-import org.openpnp.gui.components.reticle.OutlineReticle;
 import org.openpnp.gui.support.ActionGroup;
 import org.openpnp.gui.support.Helpers;
 import org.openpnp.gui.support.Icons;
@@ -63,7 +57,6 @@
 import org.openpnp.gui.tablemodel.FeedersTableModel;
 import org.openpnp.model.Configuration;
 import org.openpnp.model.Location;
-import org.openpnp.model.Outline;
 import org.openpnp.model.Part;
 import org.openpnp.spi.Camera;
 import org.openpnp.spi.Feeder;
@@ -75,148 +68,144 @@
 
 @SuppressWarnings("serial")
 public class FeedersPanel extends JPanel implements WizardContainer {
-	private final static Logger logger = LoggerFactory
-			.getLogger(FeedersPanel.class);
+    private final static Logger logger = LoggerFactory.getLogger(FeedersPanel.class);
 
-	private final Configuration configuration;
-	private final MainFrame mainFrame;
+    private final Configuration configuration;
+    private final MainFrame mainFrame;
 
-	private static final String PREF_DIVIDER_POSITION = "FeedersPanel.dividerPosition";
-	private static final int PREF_DIVIDER_POSITION_DEF = -1;
+    private static final String PREF_DIVIDER_POSITION = "FeedersPanel.dividerPosition";
+    private static final int PREF_DIVIDER_POSITION_DEF = -1;
 
-	private JTable table;
+    private JTable table;
 
-	private FeedersTableModel tableModel;
-	private TableRowSorter<FeedersTableModel> tableSorter;
-	private JTextField searchTextField;
+    private FeedersTableModel tableModel;
+    private TableRowSorter<FeedersTableModel> tableSorter;
+    private JTextField searchTextField;
     private JPanel configurationPanel;
 
-	private ActionGroup feederSelectedActionGroup;
+    private ActionGroup feederSelectedActionGroup;
 
-	private Preferences prefs = Preferences
-			.userNodeForPackage(FeedersPanel.class);
+    private Preferences prefs = Preferences.userNodeForPackage(FeedersPanel.class);
 
-	public FeedersPanel(Configuration configuration, MainFrame mainFrame) {
-		this.configuration = configuration;
-		this.mainFrame = mainFrame;
+    public FeedersPanel(Configuration configuration, MainFrame mainFrame) {
+        this.configuration = configuration;
+        this.mainFrame = mainFrame;
 
-		setLayout(new BorderLayout(0, 0));
-		tableModel = new FeedersTableModel(configuration);
+        setLayout(new BorderLayout(0, 0));
+        tableModel = new FeedersTableModel(configuration);
 
-		JPanel panel = new JPanel();
-		add(panel, BorderLayout.NORTH);
-		panel.setLayout(new BorderLayout(0, 0));
+        JPanel panel = new JPanel();
+        add(panel, BorderLayout.NORTH);
+        panel.setLayout(new BorderLayout(0, 0));
 
-		JToolBar toolBar = new JToolBar();
-		toolBar.setFloatable(false);
-		panel.add(toolBar, BorderLayout.CENTER);
+        JToolBar toolBar = new JToolBar();
+        toolBar.setFloatable(false);
+        panel.add(toolBar, BorderLayout.CENTER);
 
-		JButton btnNewFeeder = new JButton(newFeederAction);
-		btnNewFeeder.setHideActionText(true);
-		toolBar.add(btnNewFeeder);
+        JButton btnNewFeeder = new JButton(newFeederAction);
+        btnNewFeeder.setHideActionText(true);
+        toolBar.add(btnNewFeeder);
 
-		JButton btnDeleteFeeder = new JButton(deleteFeederAction);
-		btnDeleteFeeder.setHideActionText(true);
-		toolBar.add(btnDeleteFeeder);
+        JButton btnDeleteFeeder = new JButton(deleteFeederAction);
+        btnDeleteFeeder.setHideActionText(true);
+        toolBar.add(btnDeleteFeeder);
 
-		toolBar.addSeparator();
+        toolBar.addSeparator();
         toolBar.add(feedFeederAction);
         toolBar.add(moveCameraToPickLocation);
         toolBar.add(moveToolToPickLocation);
         toolBar.add(pickFeederAction);
 
-		JPanel panel_1 = new JPanel();
-		panel.add(panel_1, BorderLayout.EAST);
+        JPanel panel_1 = new JPanel();
+        panel.add(panel_1, BorderLayout.EAST);
 
-		JLabel lblSearch = new JLabel("Search");
-		panel_1.add(lblSearch);
+        JLabel lblSearch = new JLabel("Search");
+        panel_1.add(lblSearch);
 
-		searchTextField = new JTextField();
+        searchTextField = new JTextField();
         searchTextField.getDocument().addDocumentListener(new DocumentListener() {
             @Override
             public void removeUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void insertUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void changedUpdate(DocumentEvent e) {
                 search();
             }
         });
-		panel_1.add(searchTextField);
-		searchTextField.setColumns(15);
-		table = new AutoSelectTextTable(tableModel);
-		tableSorter = new TableRowSorter<>(tableModel);
-
-		final JSplitPane splitPane = new JSplitPane();
-		splitPane.setContinuousLayout(true);
-		splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION,
-				PREF_DIVIDER_POSITION_DEF));
-		splitPane.addPropertyChangeListener("dividerLocation",
-				new PropertyChangeListener() {
-					@Override
-					public void propertyChange(PropertyChangeEvent evt) {
-						prefs.putInt(PREF_DIVIDER_POSITION,
-								splitPane.getDividerLocation());
-					}
-				});
-		add(splitPane, BorderLayout.CENTER);
-
-		table.setRowSorter(tableSorter);
-		table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-		
-		configurationPanel = new JPanel();
-		configurationPanel.setBorder(new TitledBorder(null, "Configuration", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-
-		feederSelectedActionGroup = new ActionGroup(deleteFeederAction,
-				feedFeederAction, pickFeederAction,
-				moveCameraToPickLocation, moveToolToPickLocation);
-
-		table.getSelectionModel().addListSelectionListener(
-				new ListSelectionListener() {
-					@Override
-					public void valueChanged(ListSelectionEvent e) {
-						if (e.getValueIsAdjusting()) {
-							return;
-						}
-
-						Feeder feeder = getSelectedFeeder();
-
-						feederSelectedActionGroup.setEnabled(feeder != null);
-
-						configurationPanel.removeAll();
-						if (feeder != null) {
-							Wizard wizard = feeder.getConfigurationWizard();
-							if (wizard != null) {
-								wizard.setWizardContainer(FeedersPanel.this);
-								JPanel panel = wizard.getWizardPanel();
-								configurationPanel.add(panel);
-							}
-						}
-						revalidate();
-						repaint();
-					}
-				});
-		
-		feederSelectedActionGroup.setEnabled(false);
-		
+        panel_1.add(searchTextField);
+        searchTextField.setColumns(15);
+        table = new AutoSelectTextTable(tableModel);
+        tableSorter = new TableRowSorter<>(tableModel);
+
+        final JSplitPane splitPane = new JSplitPane();
+        splitPane.setContinuousLayout(true);
+        splitPane
+                .setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
+        splitPane.addPropertyChangeListener("dividerLocation", new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent evt) {
+                prefs.putInt(PREF_DIVIDER_POSITION, splitPane.getDividerLocation());
+            }
+        });
+        add(splitPane, BorderLayout.CENTER);
+
+        table.setRowSorter(tableSorter);
+        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+
+        configurationPanel = new JPanel();
+        configurationPanel.setBorder(new TitledBorder(null, "Configuration", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+
+        feederSelectedActionGroup = new ActionGroup(deleteFeederAction, feedFeederAction,
+                pickFeederAction, moveCameraToPickLocation, moveToolToPickLocation);
+
+        table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+
+                Feeder feeder = getSelectedFeeder();
+
+                feederSelectedActionGroup.setEnabled(feeder != null);
+
+                configurationPanel.removeAll();
+                if (feeder != null) {
+                    Wizard wizard = feeder.getConfigurationWizard();
+                    if (wizard != null) {
+                        wizard.setWizardContainer(FeedersPanel.this);
+                        JPanel panel = wizard.getWizardPanel();
+                        configurationPanel.add(panel);
+                    }
+                }
+                revalidate();
+                repaint();
+            }
+        });
+
+        feederSelectedActionGroup.setEnabled(false);
+
         splitPane.setLeftComponent(new JScrollPane(table));
         splitPane.setRightComponent(configurationPanel);
         configurationPanel.setLayout(new BorderLayout(0, 0));
-	}
-	
-	/**
-	 * Activate the Feeders tab and show the Feeder for the specified Part. If
-	 * none exists, prompt the user to create a new one.
-	 * @param feeder
-	 */
-	public void showFeederForPart(Part part) {
-	    mainFrame.showTab("Feeders");
+    }
+
+    /**
+     * Activate the Feeders tab and show the Feeder for the specified Part. If none exists, prompt
+     * the user to create a new one.
+     * 
+     * @param feeder
+     */
+    public void showFeederForPart(Part part) {
+        mainFrame.showTab("Feeders");
 
         Feeder feeder = findFeeder(part);
         if (feeder == null) {
@@ -231,59 +220,54 @@ public void showFeederForPart(Part part) {
                 }
             }
         }
-	}
-	
-	private Feeder findFeeder(Part part) {
+    }
+
+    private Feeder findFeeder(Part part) {
         for (int i = 0; i < tableModel.getRowCount(); i++) {
             if (tableModel.getFeeder(i).getPart() == part) {
                 return tableModel.getFeeder(i);
             }
         }
         return null;
-	}
-
-	private Feeder getSelectedFeeder() {
-		int index = table.getSelectedRow();
-
-		if (index == -1) {
-			return null;
-		}
-
-		index = table.convertRowIndexToModel(index);
-		return tableModel.getFeeder(index);
-	}
-
-	private void search() {
-		RowFilter<FeedersTableModel, Object> rf = null;
-		// If current expression doesn't parse, don't update.
-		try {
-			rf = RowFilter.regexFilter("(?i)"
-					+ searchTextField.getText().trim());
-		}
-		catch (PatternSyntaxException e) {
-			logger.warn("Search failed", e);
-			return;
-		}
-		tableSorter.setRowFilter(rf);
-	}
-
-	@Override
-	public void wizardCompleted(Wizard wizard) {
-		// Repaint the table so that any changed fields get updated.
-		table.repaint();
-	}
-
-	@Override
-	public void wizardCancelled(Wizard wizard) {
-	}
-	
-	private void newFeeder(Part part) {
+    }
+
+    private Feeder getSelectedFeeder() {
+        int index = table.getSelectedRow();
+
+        if (index == -1) {
+            return null;
+        }
+
+        index = table.convertRowIndexToModel(index);
+        return tableModel.getFeeder(index);
+    }
+
+    private void search() {
+        RowFilter<FeedersTableModel, Object> rf = null;
+        // If current expression doesn't parse, don't update.
+        try {
+            rf = RowFilter.regexFilter("(?i)" + searchTextField.getText().trim());
+        }
+        catch (PatternSyntaxException e) {
+            logger.warn("Search failed", e);
+            return;
+        }
+        tableSorter.setRowFilter(rf);
+    }
+
+    @Override
+    public void wizardCompleted(Wizard wizard) {
+        // Repaint the table so that any changed fields get updated.
+        table.repaint();
+    }
+
+    @Override
+    public void wizardCancelled(Wizard wizard) {}
+
+    private void newFeeder(Part part) {
         if (Configuration.get().getParts().size() == 0) {
-            MessageBoxes
-                    .errorBox(
-                            getTopLevelAncestor(),
-                            "Error",
-                            "There are currently no parts defined in the system. Please create at least one part before creating a feeder.");
+            MessageBoxes.errorBox(getTopLevelAncestor(), "Error",
+                    "There are currently no parts defined in the system. Please create at least one part before creating a feeder.");
             return;
         }
 
@@ -294,11 +278,10 @@ private void newFeeder(Part part) {
         else {
             title = "Select Feeder for " + part.getId() + "...";
         }
-        ClassSelectionDialog<Feeder> dialog = new ClassSelectionDialog<>(
-                JOptionPane.getFrameForComponent(FeedersPanel.this),
-                title,
-                "Please select a Feeder implemention from the list below.",
-                configuration.getMachine().getCompatibleFeederClasses());
+        ClassSelectionDialog<Feeder> dialog =
+                new ClassSelectionDialog<>(JOptionPane.getFrameForComponent(FeedersPanel.this),
+                        title, "Please select a Feeder implemention from the list below.",
+                        configuration.getMachine().getCompatibleFeederClasses());
         dialog.setVisible(true);
         Class<? extends Feeder> feederClass = dialog.getSelectedClass();
         if (feederClass == null) {
@@ -308,58 +291,54 @@ private void newFeeder(Part part) {
             Feeder feeder = feederClass.newInstance();
 
             feeder.setPart(part == null ? Configuration.get().getParts().get(0) : part);
-            
+
             configuration.getMachine().addFeeder(feeder);
             tableModel.refresh();
             Helpers.selectLastTableRow(table);
         }
         catch (Exception e) {
-            MessageBoxes.errorBox(
-                    JOptionPane.getFrameForComponent(FeedersPanel.this),
+            MessageBoxes.errorBox(JOptionPane.getFrameForComponent(FeedersPanel.this),
                     "Feeder Error", e);
         }
-	}
-
-	public Action newFeederAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.add);
-			putValue(NAME, "New Feeder...");
-			putValue(SHORT_DESCRIPTION, "Create a new feeder.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-		    newFeeder(null);
-		}
-	};
-
-	public Action deleteFeederAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.delete);
-			putValue(NAME, "Delete Feeder");
-			putValue(SHORT_DESCRIPTION, "Delete the selected feeder.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-            int ret = JOptionPane.showConfirmDialog(
-                    getTopLevelAncestor(), 
+    }
+
+    public Action newFeederAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.add);
+            putValue(NAME, "New Feeder...");
+            putValue(SHORT_DESCRIPTION, "Create a new feeder.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            newFeeder(null);
+        }
+    };
+
+    public Action deleteFeederAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.delete);
+            putValue(NAME, "Delete Feeder");
+            putValue(SHORT_DESCRIPTION, "Delete the selected feeder.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            int ret = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
                     "Are you sure you want to delete " + getSelectedFeeder().getName() + "?",
-                    "Delete " + getSelectedFeeder().getName() + "?",
-                    JOptionPane.YES_NO_OPTION);
+                    "Delete " + getSelectedFeeder().getName() + "?", JOptionPane.YES_NO_OPTION);
             if (ret == JOptionPane.YES_OPTION) {
                 configuration.getMachine().removeFeeder(getSelectedFeeder());
                 tableModel.refresh();
             }
-		}
-	};
+        }
+    };
 
     public Action feedFeederAction = new AbstractAction() {
         {
             putValue(SMALL_ICON, Icons.feed);
             putValue(NAME, "Feed");
-            putValue(SHORT_DESCRIPTION,
-                    "Command the selected feeder to perform a feed operation.");
+            putValue(SHORT_DESCRIPTION, "Command the selected feeder to perform a feed operation.");
         }
 
         @Override
@@ -368,7 +347,7 @@ public void actionPerformed(ActionEvent arg0) {
                 public void run() {
                     Feeder feeder = getSelectedFeeder();
                     Nozzle nozzle = MainFrame.machineControlsPanel.getSelectedNozzle();
-                    
+
                     try {
                         nozzle.moveToSafeZ(1.0);
                         feeder.feed(nozzle);
@@ -376,8 +355,7 @@ public void run() {
                         MovableUtils.moveToLocationAtSafeZ(nozzle, pickLocation, 1.0);
                     }
                     catch (Exception e) {
-                        MessageBoxes.errorBox(FeedersPanel.this, "Feed Error",
-                                e);
+                        MessageBoxes.errorBox(FeedersPanel.this, "Feed Error", e);
                     }
                 }
             }.start();
@@ -388,8 +366,7 @@ public void run() {
         {
             putValue(SMALL_ICON, Icons.load);
             putValue(NAME, "Pick");
-            putValue(SHORT_DESCRIPTION,
-                    "Perform a feed and pick on the selected feeder.");
+            putValue(SHORT_DESCRIPTION, "Perform a feed and pick on the selected feeder.");
         }
 
         @Override
@@ -398,7 +375,7 @@ public void actionPerformed(ActionEvent arg0) {
                 public void run() {
                     Feeder feeder = getSelectedFeeder();
                     Nozzle nozzle = MainFrame.machineControlsPanel.getSelectedNozzle();
-                    
+
                     try {
                         nozzle.moveToSafeZ(1.0);
                         feeder.feed(nozzle);
@@ -408,8 +385,7 @@ public void run() {
                         nozzle.moveToSafeZ(1.0);
                     }
                     catch (Exception e) {
-                        MessageBoxes.errorBox(FeedersPanel.this, "Feed Error",
-                                e);
+                        MessageBoxes.errorBox(FeedersPanel.this, "Feed Error", e);
                     }
                 }
             }.start();
@@ -426,16 +402,13 @@ public void run() {
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 Feeder feeder = getSelectedFeeder();
-                Camera camera = MainFrame
-                		.machineControlsPanel
-                		.getSelectedTool()
-                		.getHead()
-                		.getDefaultCamera();
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
                 Location pickLocation = feeder.getPickLocation();
                 MovableUtils.moveToLocationAtSafeZ(camera, pickLocation, 1.0);
-        	});
+            });
         }
     };
 
@@ -453,17 +426,16 @@ public void actionPerformed(ActionEvent arg0) {
                 public void run() {
                     Feeder feeder = getSelectedFeeder();
                     Nozzle nozzle = MainFrame.machineControlsPanel.getSelectedNozzle();
-                    
+
                     try {
                         Location pickLocation = feeder.getPickLocation();
                         MovableUtils.moveToLocationAtSafeZ(nozzle, pickLocation, 1.0);
                     }
                     catch (Exception e) {
-                        MessageBoxes.errorBox(FeedersPanel.this, "Movement Error",
-                                e);
+                        MessageBoxes.errorBox(FeedersPanel.this, "Movement Error", e);
                     }
                 }
             }.start();
         }
     };
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/FootprintPanel.java b/src/main/java/org/openpnp/gui/FootprintPanel.java
index 066bf7b7b6..150341570d 100755
--- a/src/main/java/org/openpnp/gui/FootprintPanel.java
+++ b/src/main/java/org/openpnp/gui/FootprintPanel.java
@@ -197,7 +197,8 @@ private void showReticle() {
             cameraView.removeReticle(FootprintPanel.class.getName());
             Reticle reticle = new FootprintReticle(footprint);
             cameraView.setReticle(FootprintPanel.class.getName(), reticle);
-        } catch (Exception e) {
+        }
+        catch (Exception e) {
             e.printStackTrace();
         }
     }
diff --git a/src/main/java/org/openpnp/gui/JobPanel.java b/src/main/java/org/openpnp/gui/JobPanel.java
index bf74c937a5..e550b776c9 100755
--- a/src/main/java/org/openpnp/gui/JobPanel.java
+++ b/src/main/java/org/openpnp/gui/JobPanel.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
@@ -26,8 +24,6 @@
 import java.awt.FileDialog;
 import java.awt.Frame;
 import java.awt.event.ActionEvent;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
 import java.io.File;
@@ -61,7 +57,6 @@
 import org.openpnp.JobProcessorDelegate;
 import org.openpnp.JobProcessorListener;
 import org.openpnp.gui.components.AutoSelectTextTable;
-import org.openpnp.gui.components.CameraView;
 import org.openpnp.gui.importer.BoardImporter;
 import org.openpnp.gui.processes.TwoPlacementBoardLocationProcess;
 import org.openpnp.gui.support.ActionGroup;
@@ -85,7 +80,6 @@
 import org.openpnp.spi.JobProcessor.JobError;
 import org.openpnp.spi.JobProcessor.JobState;
 import org.openpnp.spi.JobProcessor.PickRetryAction;
-import org.openpnp.spi.Locatable;
 import org.openpnp.spi.Machine;
 import org.openpnp.spi.MachineListener;
 import org.openpnp.util.MovableUtils;
@@ -97,8 +91,7 @@
 @SuppressWarnings("serial")
 public class JobPanel extends JPanel {
     @SuppressWarnings("unused")
-    private static final Logger logger = LoggerFactory
-            .getLogger(JobPanel.class);
+    private static final Logger logger = LoggerFactory.getLogger(JobPanel.class);
 
     final private Configuration configuration;
     final private MainFrame frame;
@@ -129,7 +122,7 @@
 
     private final JobPlacementsPanel jobPlacementsPanel;
     private final JobPastePanel jobPastePanel;
-    
+
     private JTabbedPane tabbedPane;
 
     public JobPanel(Configuration configuration, MainFrame frame,
@@ -142,8 +135,7 @@ public JobPanel(Configuration configuration, MainFrame frame,
         jobSaveActionGroup.setEnabled(false);
 
         boardLocationSelectionActionGroup = new ActionGroup(removeBoardAction,
-                captureCameraBoardLocationAction,
-                captureToolBoardLocationAction,
+                captureCameraBoardLocationAction, captureToolBoardLocationAction,
                 moveCameraToBoardLocationAction, moveToolToBoardLocationAction,
                 twoPointLocateBoardLocationAction, fiducialCheckAction);
         boardLocationSelectionActionGroup.setEnabled(false);
@@ -156,21 +148,18 @@ public JobPanel(Configuration configuration, MainFrame frame,
 
         boardLocationsTable = new AutoSelectTextTable(boardLocationsTableModel);
         boardLocationsTable.setAutoCreateRowSorter(true);
-        boardLocationsTable
-                .setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-        boardLocationsTable.setDefaultEditor(Side.class, new DefaultCellEditor(
-                sidesComboBox));
+        boardLocationsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+        boardLocationsTable.setDefaultEditor(Side.class, new DefaultCellEditor(sidesComboBox));
 
-        boardLocationsTable.getSelectionModel().addListSelectionListener(
-                new ListSelectionListener() {
+        boardLocationsTable.getSelectionModel()
+                .addListSelectionListener(new ListSelectionListener() {
                     @Override
                     public void valueChanged(ListSelectionEvent e) {
                         if (e.getValueIsAdjusting()) {
                             return;
                         }
                         BoardLocation boardLocation = getSelectedBoardLocation();
-                        boardLocationSelectionActionGroup
-                                .setEnabled(boardLocation != null);
+                        boardLocationSelectionActionGroup.setEnabled(boardLocation != null);
                         jobPlacementsPanel.setBoardLocation(boardLocation);
                         jobPastePanel.setBoardLocation(boardLocation);
                     }
@@ -181,22 +170,18 @@ public void valueChanged(ListSelectionEvent e) {
         splitPane = new JSplitPane();
         splitPane.setBorder(null);
         splitPane.setContinuousLayout(true);
-        splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION,
-                PREF_DIVIDER_POSITION_DEF));
-        splitPane.addPropertyChangeListener("dividerLocation",
-                new PropertyChangeListener() {
-                    @Override
-                    public void propertyChange(PropertyChangeEvent evt) {
-                        prefs.putInt(PREF_DIVIDER_POSITION,
-                                splitPane.getDividerLocation());
-                    }
-                });
+        splitPane
+                .setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
+        splitPane.addPropertyChangeListener("dividerLocation", new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent evt) {
+                prefs.putInt(PREF_DIVIDER_POSITION, splitPane.getDividerLocation());
+            }
+        });
 
         JPanel pnlBoards = new JPanel();
-        pnlBoards.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "Boards",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
-                new Color(0, 0, 0)));
+        pnlBoards.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Boards", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
         pnlBoards.setLayout(new BorderLayout(0, 0));
 
         JToolBar toolBarBoards = new JToolBar();
@@ -223,29 +208,24 @@ public void propertyChange(PropertyChangeEvent evt) {
         btnRemoveBoard.setHideActionText(true);
         toolBarBoards.add(btnRemoveBoard);
         toolBarBoards.addSeparator();
-        JButton btnCaptureCameraBoardLocation = new JButton(
-                captureCameraBoardLocationAction);
+        JButton btnCaptureCameraBoardLocation = new JButton(captureCameraBoardLocationAction);
         btnCaptureCameraBoardLocation.setHideActionText(true);
         toolBarBoards.add(btnCaptureCameraBoardLocation);
 
-        JButton btnCaptureToolBoardLocation = new JButton(
-                captureToolBoardLocationAction);
+        JButton btnCaptureToolBoardLocation = new JButton(captureToolBoardLocationAction);
         btnCaptureToolBoardLocation.setHideActionText(true);
         toolBarBoards.add(btnCaptureToolBoardLocation);
 
-        JButton btnPositionCameraBoardLocation = new JButton(
-                moveCameraToBoardLocationAction);
+        JButton btnPositionCameraBoardLocation = new JButton(moveCameraToBoardLocationAction);
         btnPositionCameraBoardLocation.setHideActionText(true);
         toolBarBoards.add(btnPositionCameraBoardLocation);
 
-        JButton btnPositionToolBoardLocation = new JButton(
-                moveToolToBoardLocationAction);
+        JButton btnPositionToolBoardLocation = new JButton(moveToolToBoardLocationAction);
         btnPositionToolBoardLocation.setHideActionText(true);
         toolBarBoards.add(btnPositionToolBoardLocation);
         toolBarBoards.addSeparator();
 
-        JButton btnTwoPointBoardLocation = new JButton(
-                twoPointLocateBoardLocationAction);
+        JButton btnTwoPointBoardLocation = new JButton(twoPointLocateBoardLocationAction);
         toolBarBoards.add(btnTwoPointBoardLocation);
         btnTwoPointBoardLocation.setHideActionText(true);
 
@@ -262,14 +242,14 @@ public void propertyChange(PropertyChangeEvent evt) {
 
         tabbedPane = new JTabbedPane(JTabbedPane.TOP);
         pnlRight.add(tabbedPane, BorderLayout.CENTER);
-        
+
         tabbedPane.addChangeListener(new ChangeListener() {
             public void stateChanged(ChangeEvent e) {
                 Machine machine = Configuration.get().getMachine();
                 JobProcessor.Type type = getSelectedJobProcessorType();
                 setJobProcessor(machine.getJobProcessors().get(type));
             }
-        });        
+        });
 
         jobPastePanel = new JobPastePanel(this);
         jobPlacementsPanel = new JobPlacementsPanel(this);
@@ -278,12 +258,11 @@ public void stateChanged(ChangeEvent e) {
 
         mnOpenRecent = new JMenu("Open Recent Job...");
         loadRecentJobs();
-        
+
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
-            public void configurationComplete(Configuration configuration)
-                    throws Exception {
+            public void configurationComplete(Configuration configuration) throws Exception {
                 Machine machine = configuration.getMachine();
-                
+
                 machine.addListener(machineListener);
 
                 for (JobProcessor jobProcessor : machine.getJobProcessors().values()) {
@@ -297,7 +276,8 @@ public void configurationComplete(Configuration configuration)
                     // the JobProcessor but this fails on some Linux based systems,
                     // so here we detect if it failed and force setting it.
                     if (jobProcessor == null) {
-                        setJobProcessor(machine.getJobProcessors().get(JobProcessor.Type.PickAndPlace));
+                        setJobProcessor(
+                                machine.getJobProcessors().get(JobProcessor.Type.PickAndPlace));
                     }
                 }
                 if (machine.getJobProcessors().get(JobProcessor.Type.SolderPaste) != null) {
@@ -306,10 +286,11 @@ public void configurationComplete(Configuration configuration)
                     // the JobProcessor but this fails on some Linux based systems,
                     // so here we detect if it failed and force setting it.
                     if (jobProcessor == null) {
-                        setJobProcessor(machine.getJobProcessors().get(JobProcessor.Type.SolderPaste));
+                        setJobProcessor(
+                                machine.getJobProcessors().get(JobProcessor.Type.SolderPaste));
                     }
                 }
-                
+
                 // Create an empty Job if one is not loaded
                 if (jobProcessor.getJob() == null) {
                     Job job = new Job();
@@ -318,7 +299,7 @@ public void configurationComplete(Configuration configuration)
             }
         });
     }
-    
+
     public JobProcessor.Type getSelectedJobProcessorType() {
         String activeTabTitle = tabbedPane.getTitleAt(tabbedPane.getSelectedIndex());
         if (activeTabTitle.equals("Solder Paste")) {
@@ -331,30 +312,30 @@ else if (activeTabTitle.equals("Pick and Place")) {
             throw new Error("Unknown job tab title: " + activeTabTitle);
         }
     }
-    
+
     /**
-     * Unregister the listener and delegate for the JobProcessor, set the new
-     * JobProcessor and add the listener and delegate back. If a job was
-     * previously loaded into the JobProcessor, load it into the new one.
+     * Unregister the listener and delegate for the JobProcessor, set the new JobProcessor and add
+     * the listener and delegate back. If a job was previously loaded into the JobProcessor, load it
+     * into the new one.
+     * 
+     * The sequencing of making this work is a bit complex. When the app is starting the following
+     * happens: 1. The UI is created and shown. At this time no JobProcessor is set. 2. The
+     * Configuration is loaded and the completion listener is called. 3. The Configuration listener
+     * checks which JobProcessors are registered and adds tabs for each. 4. The first tab that is
+     * added causes a selection event to happen, which fires a ChangeEvent on the ChangeListener
+     * above. 5. The ChangeListener checks which tab was selected and calls this method with the
+     * appropriate JobProcessor.
      * 
-     * The sequencing of making this work is a bit complex. When the app is
-     * starting the following happens:
-     * 1. The UI is created and shown. At this time no JobProcessor is set.
-     * 2. The Configuration is loaded and the completion listener is called.
-     * 3. The Configuration listener checks which JobProcessors are registered
-     * and adds tabs for each.
-     * 4. The first tab that is added causes a selection event to happen, which
-     * fires a ChangeEvent on the ChangeListener above.
-     * 5. The ChangeListener checks which tab was selected and calls this
-     * method with the appropriate JobProcessor.
      * @param jobProcessor
      */
     private void setJobProcessor(JobProcessor jobProcessor) {
         Job job = null;
         if (this.jobProcessor != null) {
             job = this.jobProcessor.getJob();
-            if (this.jobProcessor.getState() != null && this.jobProcessor.getState() != JobProcessor.JobState.Stopped) {
-                throw new AssertionError("this.jobProcessor.getState() " + this.jobProcessor.getState() + " != JobProcessor.JobState.Stopped");
+            if (this.jobProcessor.getState() != null
+                    && this.jobProcessor.getState() != JobProcessor.JobState.Stopped) {
+                throw new AssertionError("this.jobProcessor.getState() "
+                        + this.jobProcessor.getState() + " != JobProcessor.JobState.Stopped");
             }
             this.jobProcessor.removeListener(jobProcessorListener);
             this.jobProcessor.setDelegate(null);
@@ -366,7 +347,7 @@ private void setJobProcessor(JobProcessor jobProcessor) {
             jobProcessor.load(job);
         }
     }
-    
+
     public JobPlacementsPanel getJobPlacementsPanel() {
         return jobPlacementsPanel;
     }
@@ -397,8 +378,7 @@ private void saveRecentJobs() {
         }
         // update with what we have now
         for (int i = 0; i < recentJobs.size(); i++) {
-            prefs.put(PREF_RECENT_FILES + "_" + i, recentJobs.get(i)
-                    .getAbsolutePath());
+            prefs.put(PREF_RECENT_FILES + "_" + i, recentJobs.get(i).getAbsolutePath());
         }
         updateRecentJobsMenu();
     }
@@ -417,8 +397,7 @@ private void addRecentJob(File file) {
     }
 
     public void refreshSelectedBoardRow() {
-        boardLocationsTableModel.fireTableRowsUpdated(
-                boardLocationsTable.getSelectedRow(),
+        boardLocationsTableModel.fireTableRowsUpdated(boardLocationsTable.getSelectedRow(),
                 boardLocationsTable.getSelectedRow());
     }
 
@@ -429,14 +408,13 @@ public BoardLocation getSelectedBoardLocation() {
         }
         else {
             index = boardLocationsTable.convertRowIndexToModel(index);
-            return JobPanel.this.jobProcessor.getJob().getBoardLocations()
-                    .get(index);
+            return JobPanel.this.jobProcessor.getJob().getBoardLocations().get(index);
         }
     }
 
     /**
-     * Checks if there are any modifications that need to be saved. Prompts the
-     * user if there are. Returns true if it's okay to exit.
+     * Checks if there are any modifications that need to be saved. Prompts the user if there are.
+     * Returns true if it's okay to exit.
      * 
      * @return
      */
@@ -453,8 +431,7 @@ public boolean checkForModifications() {
     private boolean checkForJobModifications() {
         if (jobProcessor.getJob().isDirty()) {
             Job job = jobProcessor.getJob();
-            String name = (job.getFile() == null ? UNTITLED_JOB_FILENAME : job
-                    .getFile().getName());
+            String name = (job.getFile() == null ? UNTITLED_JOB_FILENAME : job.getFile().getName());
             int result = JOptionPane.showConfirmDialog(frame,
                     "Do you want to save your changes to " + name + "?" + "\n"
                             + "If you don't save, your changes will be lost.",
@@ -472,23 +449,18 @@ else if (result == JOptionPane.CANCEL_OPTION) {
     private boolean checkForBoardModifications() {
         for (Board board : configuration.getBoards()) {
             if (board.isDirty()) {
-                int result = JOptionPane
-                        .showConfirmDialog(
-                                getTopLevelAncestor(),
-                                "Do you want to save your changes to "
-                                        + board.getFile().getName()
-                                        + "?"
-                                        + "\n"
-                                        + "If you don't save, your changes will be lost.",
-                                "Save " + board.getFile().getName() + "?",
-                                JOptionPane.YES_NO_CANCEL_OPTION);
+                int result = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
+                        "Do you want to save your changes to " + board.getFile().getName() + "?"
+                                + "\n" + "If you don't save, your changes will be lost.",
+                        "Save " + board.getFile().getName() + "?",
+                        JOptionPane.YES_NO_CANCEL_OPTION);
                 if (result == JOptionPane.YES_OPTION) {
                     try {
                         configuration.saveBoard(board);
                     }
                     catch (Exception e) {
-                        MessageBoxes.errorBox(getTopLevelAncestor(),
-                                "Board Save Error", e.getMessage());
+                        MessageBoxes.errorBox(getTopLevelAncestor(), "Board Save Error",
+                                e.getMessage());
                         return false;
                     }
                 }
@@ -519,8 +491,7 @@ private boolean saveJob() {
     }
 
     private boolean saveJobAs() {
-        FileDialog fileDialog = new FileDialog(frame, "Save Job As...",
-                FileDialog.SAVE);
+        FileDialog fileDialog = new FileDialog(frame, "Save Job As...", FileDialog.SAVE);
         fileDialog.setFilenameFilter(new FilenameFilter() {
             @Override
             public boolean accept(File dir, String name) {
@@ -538,13 +509,9 @@ public boolean accept(File dir, String name) {
             }
             File file = new File(new File(fileDialog.getDirectory()), filename);
             if (file.exists()) {
-                int ret = JOptionPane
-                        .showConfirmDialog(
-                                getTopLevelAncestor(),
-                                file.getName()
-                                        + " already exists. Do you want to replace it?",
-                                "Replace file?", JOptionPane.YES_NO_OPTION,
-                                JOptionPane.WARNING_MESSAGE);
+                int ret = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
+                        file.getName() + " already exists. Do you want to replace it?",
+                        "Replace file?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
                 if (ret != JOptionPane.YES_OPTION) {
                     return false;
                 }
@@ -560,18 +527,15 @@ public boolean accept(File dir, String name) {
     }
 
     /**
-     * Updates the Job controls based on the Job state and the Machine's
-     * readiness.
+     * Updates the Job controls based on the Job state and the Machine's readiness.
      */
     private void updateJobActions() {
         JobState state = jobProcessor.getState();
         if (state == JobState.Stopped) {
             startPauseResumeJobAction.setEnabled(true);
             startPauseResumeJobAction.putValue(AbstractAction.NAME, "Start");
-            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON,
-                    Icons.start);
-            startPauseResumeJobAction.putValue(
-                    AbstractAction.SHORT_DESCRIPTION,
+            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON, Icons.start);
+            startPauseResumeJobAction.putValue(AbstractAction.SHORT_DESCRIPTION,
                     "Start processing the job.");
             stopJobAction.setEnabled(false);
             stepJobAction.setEnabled(true);
@@ -580,10 +544,8 @@ private void updateJobActions() {
         else if (state == JobState.Running) {
             startPauseResumeJobAction.setEnabled(true);
             startPauseResumeJobAction.putValue(AbstractAction.NAME, "Pause");
-            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON,
-                    Icons.pause);
-            startPauseResumeJobAction.putValue(
-                    AbstractAction.SHORT_DESCRIPTION,
+            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON, Icons.pause);
+            startPauseResumeJobAction.putValue(AbstractAction.SHORT_DESCRIPTION,
                     "Pause processing of the job.");
             stopJobAction.setEnabled(true);
             stepJobAction.setEnabled(false);
@@ -592,10 +554,8 @@ else if (state == JobState.Running) {
         else if (state == JobState.Paused) {
             startPauseResumeJobAction.setEnabled(true);
             startPauseResumeJobAction.putValue(AbstractAction.NAME, "Resume");
-            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON,
-                    Icons.start);
-            startPauseResumeJobAction.putValue(
-                    AbstractAction.SHORT_DESCRIPTION,
+            startPauseResumeJobAction.putValue(AbstractAction.SMALL_ICON, Icons.start);
+            startPauseResumeJobAction.putValue(AbstractAction.SHORT_DESCRIPTION,
                     "Resume processing of the job.");
             stopJobAction.setEnabled(true);
             stepJobAction.setEnabled(true);
@@ -613,10 +573,8 @@ else if (state == JobState.Paused) {
 
     private void updateTitle() {
         Job job = jobProcessor.getJob();
-        String title = String.format("OpenPnP - %s%s",
-                job.isDirty() ? "*" : "",
-                (job.getFile() == null ? UNTITLED_JOB_FILENAME : job.getFile()
-                        .getName()));
+        String title = String.format("OpenPnP - %s%s", job.isDirty() ? "*" : "",
+                (job.getFile() == null ? UNTITLED_JOB_FILENAME : job.getFile().getName()));
         frame.setTitle(title);
     }
 
@@ -637,8 +595,7 @@ public void importBoard(Class<? extends BoardImporter> boardImporterClass) {
         }
 
         try {
-            Board importedBoard = boardImporter
-                    .importBoard((Frame) getTopLevelAncestor());
+            Board importedBoard = boardImporter.importBoard((Frame) getTopLevelAncestor());
             if (importedBoard != null) {
                 Board existingBoard = getSelectedBoardLocation().getBoard();
                 for (Placement placement : importedBoard.getPlacements()) {
@@ -649,7 +606,8 @@ public void importBoard(Class<? extends BoardImporter> boardImporterClass) {
                     // interface to be more intuitive. The Gerber importer tends
                     // to return everything in Inches, so this is a method to
                     // try to get it closer to what the user expects to see.
-                    pad.setLocation(pad.getLocation().convertToUnits(getSelectedBoardLocation().getLocation().getUnits()));
+                    pad.setLocation(pad.getLocation()
+                            .convertToUnits(getSelectedBoardLocation().getLocation().getUnits()));
                     existingBoard.addSolderPastePad(pad);
                 }
                 jobPlacementsPanel.setBoardLocation(getSelectedBoardLocation());
@@ -679,8 +637,7 @@ public boolean accept(File dir, String name) {
                 if (fileDialog.getFile() == null) {
                     return;
                 }
-                File file = new File(new File(fileDialog.getDirectory()),
-                        fileDialog.getFile());
+                File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
                 Job job = configuration.loadJob(file);
                 jobProcessor.load(job);
                 addRecentJob(file);
@@ -731,8 +688,7 @@ public void actionPerformed(ActionEvent arg0) {
                     jobProcessor.start();
                 }
                 catch (Exception e) {
-                    MessageBoxes.errorBox(frame, "Job Start Error",
-                            e.getMessage());
+                    MessageBoxes.errorBox(frame, "Job Start Error", e.getMessage());
                 }
             }
             else if (state == JobState.Paused) {
@@ -748,8 +704,7 @@ else if (state == JobState.Running) {
         {
             putValue(SMALL_ICON, Icons.step);
             putValue(NAME, "Step");
-            putValue(SHORT_DESCRIPTION,
-                    "Process one step of the job and pause.");
+            putValue(SHORT_DESCRIPTION, "Process one step of the job and pause.");
         }
 
         @Override
@@ -780,14 +735,12 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.neww);
             putValue(NAME, "New Board...");
-            putValue(SHORT_DESCRIPTION,
-                    "Create a new board and add it to the job.");
+            putValue(SHORT_DESCRIPTION, "Create a new board and add it to the job.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-            FileDialog fileDialog = new FileDialog(frame,
-                    "Save New Board As...", FileDialog.SAVE);
+            FileDialog fileDialog = new FileDialog(frame, "Save New Board As...", FileDialog.SAVE);
             fileDialog.setFilenameFilter(new FilenameFilter() {
                 @Override
                 public boolean accept(File dir, String name) {
@@ -803,8 +756,7 @@ public boolean accept(File dir, String name) {
                 if (!filename.toLowerCase().endsWith(".board.xml")) {
                     filename = filename + ".board.xml";
                 }
-                File file = new File(new File(fileDialog.getDirectory()),
-                        filename);
+                File file = new File(new File(fileDialog.getDirectory()), filename);
 
                 Board board = configuration.getBoard(file);
                 BoardLocation boardLocation = new BoardLocation(board);
@@ -815,8 +767,7 @@ public boolean accept(File dir, String name) {
             }
             catch (Exception e) {
                 e.printStackTrace();
-                MessageBoxes.errorBox(frame, "Unable to create new board",
-                        e.getMessage());
+                MessageBoxes.errorBox(frame, "Unable to create new board", e.getMessage());
             }
         }
     };
@@ -842,8 +793,7 @@ public boolean accept(File dir, String name) {
                 if (fileDialog.getFile() == null) {
                     return;
                 }
-                File file = new File(new File(fileDialog.getDirectory()),
-                        fileDialog.getFile());
+                File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
 
                 Board board = configuration.getBoard(file);
                 BoardLocation boardLocation = new BoardLocation(board);
@@ -855,8 +805,7 @@ public boolean accept(File dir, String name) {
             }
             catch (Exception e) {
                 e.printStackTrace();
-                MessageBoxes.errorBox(frame, "Board load failed",
-                        e.getMessage());
+                MessageBoxes.errorBox(frame, "Board load failed", e.getMessage());
             }
         }
     };
@@ -865,8 +814,7 @@ public boolean accept(File dir, String name) {
         {
             putValue(SMALL_ICON, Icons.delete);
             putValue(NAME, "Remove Board");
-            putValue(SHORT_DESCRIPTION,
-                    "Remove the selected board from the job.");
+            putValue(SHORT_DESCRIPTION, "Remove the selected board from the job.");
         }
 
         @Override
@@ -874,10 +822,9 @@ public void actionPerformed(ActionEvent arg0) {
             int index = boardLocationsTable.getSelectedRow();
             if (index != -1) {
                 index = boardLocationsTable.convertRowIndexToModel(index);
-                BoardLocation boardLocation = JobPanel.this.jobProcessor
-                        .getJob().getBoardLocations().get(index);
-                JobPanel.this.jobProcessor.getJob().removeBoardLocation(
-                        boardLocation);
+                BoardLocation boardLocation =
+                        JobPanel.this.jobProcessor.getJob().getBoardLocations().get(index);
+                JobPanel.this.jobProcessor.getJob().removeBoardLocation(boardLocation);
                 boardLocationsTableModel.fireTableDataChanged();
             }
         }
@@ -893,15 +840,15 @@ public void actionPerformed(ActionEvent arg0) {
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
-            	Camera camera = tool.getHead().getDefaultCamera();
+            UiUtils.messageBoxOnException(() -> {
+                HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
+                Camera camera = tool.getHead().getDefaultCamera();
                 double z = getSelectedBoardLocation().getLocation().getZ();
-                getSelectedBoardLocation().setLocation(camera.getLocation().derive(null, null, z, null));
-                boardLocationsTableModel.fireTableRowsUpdated(
-                        boardLocationsTable.getSelectedRow(),
+                getSelectedBoardLocation()
+                        .setLocation(camera.getLocation().derive(null, null, z, null));
+                boardLocationsTableModel.fireTableRowsUpdated(boardLocationsTable.getSelectedRow(),
                         boardLocationsTable.getSelectedRow());
-        	});
+            });
         }
     };
 
@@ -909,57 +856,53 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.captureTool);
             putValue(NAME, "Capture Tool Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Set the board's location to the tool's current position.");
+            putValue(SHORT_DESCRIPTION, "Set the board's location to the tool's current position.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
-                double z = getSelectedBoardLocation().getLocation().getZ();
-                getSelectedBoardLocation().setLocation(tool.getLocation().derive(null, null, z, null));
-            boardLocationsTableModel.fireTableRowsUpdated(
-                    boardLocationsTable.getSelectedRow(),
+            HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
+            double z = getSelectedBoardLocation().getLocation().getZ();
+            getSelectedBoardLocation().setLocation(tool.getLocation().derive(null, null, z, null));
+            boardLocationsTableModel.fireTableRowsUpdated(boardLocationsTable.getSelectedRow(),
                     boardLocationsTable.getSelectedRow());
         }
     };
 
-    public final Action moveCameraToBoardLocationAction = new AbstractAction(
-            "Move Camera To Board Location") {
-        {
-            putValue(SMALL_ICON, Icons.centerCamera);
-            putValue(NAME, "Move Camera To Board Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the camera at the board's location.");
-        }
+    public final Action moveCameraToBoardLocationAction =
+            new AbstractAction("Move Camera To Board Location") {
+                {
+                    putValue(SMALL_ICON, Icons.centerCamera);
+                    putValue(NAME, "Move Camera To Board Location");
+                    putValue(SHORT_DESCRIPTION, "Position the camera at the board's location.");
+                }
 
-        @Override
-        public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
-        		HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
-            	Camera camera = tool.getHead().getDefaultCamera();
-            	MainFrame.cameraPanel.ensureCameraVisible(camera);
-                Location location = getSelectedBoardLocation().getLocation();
-                MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-        	});
-        }
-    };
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.submitUiMachineTask(() -> {
+                        HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
+                        Camera camera = tool.getHead().getDefaultCamera();
+                        MainFrame.cameraPanel.ensureCameraVisible(camera);
+                        Location location = getSelectedBoardLocation().getLocation();
+                        MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
+                    });
+                }
+            };
 
     public final Action moveToolToBoardLocationAction = new AbstractAction() {
         {
             putValue(SMALL_ICON, Icons.centerTool);
             putValue(NAME, "Move Tool To Board Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the tool at the board's location.");
+            putValue(SHORT_DESCRIPTION, "Position the tool at the board's location.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
                 Location location = getSelectedBoardLocation().getLocation();
                 MovableUtils.moveToLocationAtSafeZ(tool, location, 1.0);
-        	});
+            });
         }
     };
 
@@ -973,9 +916,9 @@ public void actionPerformed(ActionEvent arg0) {
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
+            UiUtils.messageBoxOnException(() -> {
                 new TwoPlacementBoardLocationProcess(frame, JobPanel.this);
-        	});
+            });
         }
     };
 
@@ -989,7 +932,7 @@ public void actionPerformed(ActionEvent arg0) {
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 Location location = FiducialLocator.locateBoard(getSelectedBoardLocation());
                 getSelectedBoardLocation().setLocation(location);
                 refreshSelectedBoardRow();
@@ -997,7 +940,7 @@ public void actionPerformed(ActionEvent arg0) {
                 Camera camera = tool.getHead().getDefaultCamera();
                 MainFrame.cameraPanel.ensureCameraVisible(camera);
                 MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-        	});
+            });
         }
     };
 
@@ -1049,8 +992,8 @@ public void jobLoaded(Job job) {
 
         @Override
         public void jobEncounteredError(JobError error, String description) {
-            MessageBoxes.errorBox(frame, error.toString(), description
-                    + "\n\nThe job will be paused.");
+            MessageBoxes.errorBox(frame, error.toString(),
+                    description + "\n\nThe job will be paused.");
             // TODO: Implement a way to retry, abort, etc.
             jobProcessor.pause();
         }
@@ -1058,8 +1001,7 @@ public void jobEncounteredError(JobError error, String description) {
 
     private final JobProcessorDelegate jobProcessorDelegate = new JobProcessorDelegate() {
         @Override
-        public PickRetryAction partPickFailed(BoardLocation board, Part part,
-                Feeder feeder) {
+        public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder) {
             return PickRetryAction.SkipAndContinue;
         }
     };
@@ -1077,11 +1019,12 @@ public void machineDisabled(Machine machine, String reason) {
         }
     };
 
-    private final PropertyChangeListener titlePropertyChangeListener = new PropertyChangeListener() {
-        @Override
-        public void propertyChange(PropertyChangeEvent evt) {
-            updateTitle();
-            jobSaveActionGroup.setEnabled(jobProcessor.getJob().isDirty());
-        }
-    };
+    private final PropertyChangeListener titlePropertyChangeListener =
+            new PropertyChangeListener() {
+                @Override
+                public void propertyChange(PropertyChangeEvent evt) {
+                    updateTitle();
+                    jobSaveActionGroup.setEnabled(jobProcessor.getJob().isDirty());
+                }
+            };
 }
diff --git a/src/main/java/org/openpnp/gui/JobPastePanel.java b/src/main/java/org/openpnp/gui/JobPastePanel.java
index 098a2ee1ff..ece5eb7fb2 100755
--- a/src/main/java/org/openpnp/gui/JobPastePanel.java
+++ b/src/main/java/org/openpnp/gui/JobPastePanel.java
@@ -58,10 +58,10 @@
 
     private static Color typeColorIgnore = new Color(252, 255, 157);
     private static Color typeColorPaste = new Color(157, 255, 168);
-    
+
     public JobPastePanel(JobPanel jobPanel) {
         Configuration configuration = Configuration.get();
-        
+
         boardLocationSelectionActionGroup = new ActionGroup(newAction);
         boardLocationSelectionActionGroup.setEnabled(false);
 
@@ -71,7 +71,8 @@ public JobPastePanel(JobPanel jobPanel) {
         multiSelectionActionGroup = new ActionGroup(removeAction, setTypeAction);
         multiSelectionActionGroup.setEnabled(false);
 
-        captureAndPositionActionGroup = new ActionGroup(moveCameraToPadLocation, moveToolToPadLocation);
+        captureAndPositionActionGroup =
+                new ActionGroup(moveCameraToPadLocation, moveToolToPadLocation);
         captureAndPositionActionGroup.setEnabled(false);
 
         JComboBox<Side> sidesComboBox = new JComboBox(Side.values());
@@ -91,13 +92,11 @@ public JobPastePanel(JobPanel jobPanel) {
         toolBar.addSeparator();
 
 
-        JButton btnPositionCameraPositionLocation = new JButton(
-                moveCameraToPadLocation);
+        JButton btnPositionCameraPositionLocation = new JButton(moveCameraToPadLocation);
         btnPositionCameraPositionLocation.setHideActionText(true);
         toolBar.add(btnPositionCameraPositionLocation);
 
-        JButton btnPositionToolPositionLocation = new JButton(
-                moveToolToPadLocation);
+        JButton btnPositionToolPositionLocation = new JButton(moveToolToPadLocation);
         btnPositionToolPositionLocation.setHideActionText(true);
         toolBar.add(btnPositionToolPositionLocation);
 
@@ -108,37 +107,34 @@ public JobPastePanel(JobPanel jobPanel) {
         table = new AutoSelectTextTable(tableModel);
         table.setAutoCreateRowSorter(true);
         table.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
-        
-        table.setDefaultEditor(Side.class, new DefaultCellEditor(
-                sidesComboBox));
-
-        table.setDefaultRenderer(Type.class,
-                new TypeRenderer());
-        table.setDefaultEditor(Type.class, new DefaultCellEditor(
-                typesComboBox));
-        
-        table.getSelectionModel().addListSelectionListener(
-                new ListSelectionListener() {
-                    @Override
-                    public void valueChanged(ListSelectionEvent e) {
-                        if (e.getValueIsAdjusting()) {
-                            return;
-                        }
-                        
-                        if (getSelections().size() > 1) {
-                            // multi select
-                            singleSelectionActionGroup.setEnabled(false);
-                            captureAndPositionActionGroup.setEnabled(false);
-                            multiSelectionActionGroup.setEnabled(true);
-                        }
-                        else {
-                            // single select, or no select
-                            multiSelectionActionGroup.setEnabled(false);
-                            singleSelectionActionGroup.setEnabled(getSelection() != null);
-                            captureAndPositionActionGroup.setEnabled(getSelection() != null && getSelection().getSide() == boardLocation.getSide());
-                        }
-                    }
-                });
+
+        table.setDefaultEditor(Side.class, new DefaultCellEditor(sidesComboBox));
+
+        table.setDefaultRenderer(Type.class, new TypeRenderer());
+        table.setDefaultEditor(Type.class, new DefaultCellEditor(typesComboBox));
+
+        table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+
+                if (getSelections().size() > 1) {
+                    // multi select
+                    singleSelectionActionGroup.setEnabled(false);
+                    captureAndPositionActionGroup.setEnabled(false);
+                    multiSelectionActionGroup.setEnabled(true);
+                }
+                else {
+                    // single select, or no select
+                    multiSelectionActionGroup.setEnabled(false);
+                    singleSelectionActionGroup.setEnabled(getSelection() != null);
+                    captureAndPositionActionGroup.setEnabled(getSelection() != null
+                            && getSelection().getSide() == boardLocation.getSide());
+                }
+            }
+        });
         table.addKeyListener(new KeyAdapter() {
             @Override
             public void keyTyped(KeyEvent e) {
@@ -152,9 +148,9 @@ public void keyTyped(KeyEvent e) {
                 }
             }
         });
-        
+
         JPopupMenu popupMenu = new JPopupMenu();
-        
+
         JMenu setTypeMenu = new JMenu(setTypeAction);
         for (BoardPad.Type type : BoardPad.Type.values()) {
             setTypeMenu.add(new SetTypeAction(type));
@@ -163,11 +159,11 @@ public void keyTyped(KeyEvent e) {
 
         JMenu setSideMenu = new JMenu(setSideAction);
         for (Board.Side side : Board.Side.values()) {
-        	setSideMenu.add(new SetSideAction(side));
+            setSideMenu.add(new SetSideAction(side));
         }
         popupMenu.add(setSideMenu);
 
-        table.setComponentPopupMenu(popupMenu);                
+        table.setComponentPopupMenu(popupMenu);
 
         JScrollPane scrollPane = new JScrollPane(table);
         add(scrollPane, BorderLayout.CENTER);
@@ -192,7 +188,7 @@ public BoardPad getSelection() {
         }
         return selectedPads.get(0);
     }
-    
+
     public List<BoardPad> getSelections() {
         ArrayList<BoardPad> rows = new ArrayList<>();
         if (boardLocation == null) {
@@ -210,8 +206,7 @@ public BoardPad getSelection() {
         {
             putValue(SMALL_ICON, Icons.add);
             putValue(NAME, "New Pad");
-            putValue(SHORT_DESCRIPTION,
-                    "Create a new pad and add it to the board.");
+            putValue(SHORT_DESCRIPTION, "Create a new pad and add it to the board.");
         }
 
         @Override
@@ -221,12 +216,10 @@ public void actionPerformed(ActionEvent arg0) {
             padClasses.add(Pad.Circle.class);
             padClasses.add(Pad.Ellipse.class);
             // See note on Pad.Line
-//            padClasses.add(Pad.Line.class);
+            // padClasses.add(Pad.Line.class);
             ClassSelectionDialog<Pad> dialog = new ClassSelectionDialog<>(
-                    JOptionPane.getFrameForComponent(JobPastePanel.this),
-                    "Select Pad...",
-                    "Please select a pad type from the list below.",
-                    padClasses);
+                    JOptionPane.getFrameForComponent(JobPastePanel.this), "Select Pad...",
+                    "Please select a pad type from the list below.", padClasses);
             dialog.setVisible(true);
             Class<? extends Pad> padClass = dialog.getSelectedClass();
             if (padClass == null) {
@@ -235,8 +228,7 @@ public void actionPerformed(ActionEvent arg0) {
             try {
                 Pad pad = padClass.newInstance();
                 BoardPad boardPad = new BoardPad();
-                boardPad.setLocation(new Location(Configuration.get()
-                        .getSystemUnits()));
+                boardPad.setLocation(new Location(Configuration.get().getSystemUnits()));
                 boardPad.setPad(pad);
 
                 boardLocation.getBoard().addSolderPastePad(boardPad);
@@ -244,8 +236,7 @@ public void actionPerformed(ActionEvent arg0) {
                 Helpers.selectLastTableRow(table);
             }
             catch (Exception e) {
-                MessageBoxes.errorBox(
-                        JOptionPane.getFrameForComponent(JobPastePanel.this),
+                MessageBoxes.errorBox(JOptionPane.getFrameForComponent(JobPastePanel.this),
                         "Pad Error", e);
             }
         }
@@ -255,8 +246,7 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.delete);
             putValue(NAME, "Remove Pad");
-            putValue(SHORT_DESCRIPTION,
-                    "Remove the currently selected pad.");
+            putValue(SHORT_DESCRIPTION, "Remove the currently selected pad.");
         }
 
         @Override
@@ -272,24 +262,19 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.centerCamera);
             putValue(NAME, "Move Camera To Pad Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the camera at the pad's location.");
+            putValue(SHORT_DESCRIPTION, "Position the camera at the pad's location.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
-                Location location = Utils2D.calculateBoardPlacementLocation(
-                		boardLocation,
-                		getSelection().getLocation());
-
-                Camera camera = MainFrame
-                		.machineControlsPanel
-                		.getSelectedTool()
-                		.getHead()
-                		.getDefaultCamera();
+            UiUtils.submitUiMachineTask(() -> {
+                Location location = Utils2D.calculateBoardPlacementLocation(boardLocation,
+                        getSelection().getLocation());
+
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
                 MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-        	});
+            });
         }
     };
 
@@ -297,15 +282,13 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.centerTool);
             putValue(NAME, "Move Tool To Pad Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the tool at the pad's location.");
+            putValue(SHORT_DESCRIPTION, "Position the tool at the pad's location.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-            Location location = Utils2D.calculateBoardPlacementLocation(
-            		boardLocation,
-            		getSelection().getLocation());
+            Location location = Utils2D.calculateBoardPlacementLocation(boardLocation,
+                    getSelection().getLocation());
 
             PasteDispenser dispenser = MainFrame.machineControlsPanel.getSelectedPasteDispenser();
             UiUtils.submitUiMachineTask(() -> {
@@ -313,22 +296,20 @@ public void actionPerformed(ActionEvent arg0) {
             });
         }
     };
-    
+
     public final Action setTypeAction = new AbstractAction() {
         {
             putValue(NAME, "Set Type");
-            putValue(SHORT_DESCRIPTION,
-                    "Set pad type(s) to...");
+            putValue(SHORT_DESCRIPTION, "Set pad type(s) to...");
         }
 
         @Override
-        public void actionPerformed(ActionEvent arg0) {
-        }
+        public void actionPerformed(ActionEvent arg0) {}
     };
-    
+
     class SetTypeAction extends AbstractAction {
         final BoardPad.Type type;
-        
+
         public SetTypeAction(BoardPad.Type type) {
             this.type = type;
             putValue(NAME, type.toString());
@@ -342,22 +323,20 @@ public void actionPerformed(ActionEvent arg0) {
             }
         }
     };
-    
+
     public final Action setSideAction = new AbstractAction() {
         {
             putValue(NAME, "Set Side");
-            putValue(SHORT_DESCRIPTION,
-                    "Set pad side(s) to...");
+            putValue(SHORT_DESCRIPTION, "Set pad side(s) to...");
         }
 
         @Override
-        public void actionPerformed(ActionEvent arg0) {
-        }
+        public void actionPerformed(ActionEvent arg0) {}
     };
-    
+
     class SetSideAction extends AbstractAction {
         final Board.Side side;
-        
+
         public SetSideAction(Board.Side side) {
             this.side = side;
             putValue(NAME, side.toString());
@@ -371,7 +350,7 @@ public void actionPerformed(ActionEvent arg0) {
             }
         }
     };
-    
+
     static class TypeRenderer extends DefaultTableCellRenderer {
         public void setValue(Object value) {
             Type type = (Type) value;
diff --git a/src/main/java/org/openpnp/gui/JobPlacementsPanel.java b/src/main/java/org/openpnp/gui/JobPlacementsPanel.java
index 1dc95d3de1..a041a674ee 100755
--- a/src/main/java/org/openpnp/gui/JobPlacementsPanel.java
+++ b/src/main/java/org/openpnp/gui/JobPlacementsPanel.java
@@ -48,7 +48,6 @@
 import org.openpnp.model.Placement;
 import org.openpnp.model.Placement.Type;
 import org.openpnp.spi.Camera;
-import org.openpnp.spi.Feeder;
 import org.openpnp.spi.HeadMountable;
 import org.openpnp.spi.Nozzle;
 import org.openpnp.util.MovableUtils;
@@ -63,7 +62,7 @@
     private ActionGroup multiSelectionActionGroup;
     private ActionGroup captureAndPositionActionGroup;
     private BoardLocation boardLocation;
-    
+
     private static Color typeColorIgnore = new Color(252, 255, 157);
     private static Color typeColorFiducial = new Color(157, 188, 255);
     private static Color typeColorPlace = new Color(157, 255, 168);
@@ -73,24 +72,23 @@
 
     public JobPlacementsPanel(JobPanel jobPanel) {
         Configuration configuration = Configuration.get();
-        
+
         boardLocationSelectionActionGroup = new ActionGroup(newAction);
         boardLocationSelectionActionGroup.setEnabled(false);
 
-        singleSelectionActionGroup = new ActionGroup(removeAction,
-                editPlacementFeederAction, setTypeAction);
+        singleSelectionActionGroup =
+                new ActionGroup(removeAction, editPlacementFeederAction, setTypeAction);
         singleSelectionActionGroup.setEnabled(false);
 
         multiSelectionActionGroup = new ActionGroup(removeAction, setTypeAction);
         multiSelectionActionGroup.setEnabled(false);
 
-        captureAndPositionActionGroup = new ActionGroup(
-                captureCameraPlacementLocation, captureToolPlacementLocation,
-                moveCameraToPlacementLocation, moveToolToPlacementLocation);
+        captureAndPositionActionGroup =
+                new ActionGroup(captureCameraPlacementLocation, captureToolPlacementLocation,
+                        moveCameraToPlacementLocation, moveToolToPlacementLocation);
         captureAndPositionActionGroup.setEnabled(false);
 
-        JComboBox<PartsComboBoxModel> partsComboBox = new JComboBox(
-                new PartsComboBoxModel());
+        JComboBox<PartsComboBoxModel> partsComboBox = new JComboBox(new PartsComboBoxModel());
         partsComboBox.setRenderer(new IdentifiableListCellRenderer<Part>());
         JComboBox<Side> sidesComboBox = new JComboBox(Side.values());
         JComboBox<Type> typesComboBox = new JComboBox(Type.values());
@@ -107,23 +105,19 @@ public JobPlacementsPanel(JobPanel jobPanel) {
         btnRemovePlacement.setHideActionText(true);
         toolBarPlacements.add(btnRemovePlacement);
         toolBarPlacements.addSeparator();
-        JButton btnCaptureCameraPlacementLocation = new JButton(
-                captureCameraPlacementLocation);
+        JButton btnCaptureCameraPlacementLocation = new JButton(captureCameraPlacementLocation);
         btnCaptureCameraPlacementLocation.setHideActionText(true);
         toolBarPlacements.add(btnCaptureCameraPlacementLocation);
 
-        JButton btnCaptureToolPlacementLocation = new JButton(
-                captureToolPlacementLocation);
+        JButton btnCaptureToolPlacementLocation = new JButton(captureToolPlacementLocation);
         btnCaptureToolPlacementLocation.setHideActionText(true);
         toolBarPlacements.add(btnCaptureToolPlacementLocation);
 
-        JButton btnPositionCameraPositionLocation = new JButton(
-                moveCameraToPlacementLocation);
+        JButton btnPositionCameraPositionLocation = new JButton(moveCameraToPlacementLocation);
         btnPositionCameraPositionLocation.setHideActionText(true);
         toolBarPlacements.add(btnPositionCameraPositionLocation);
 
-        JButton btnPositionToolPositionLocation = new JButton(
-                moveToolToPlacementLocation);
+        JButton btnPositionToolPositionLocation = new JButton(moveToolToPlacementLocation);
         btnPositionToolPositionLocation.setHideActionText(true);
         toolBarPlacements.add(btnPositionToolPositionLocation);
 
@@ -138,52 +132,43 @@ public JobPlacementsPanel(JobPanel jobPanel) {
         table = new AutoSelectTextTable(tableModel);
         table.setAutoCreateRowSorter(true);
         table.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
-        table.setDefaultEditor(Side.class, new DefaultCellEditor(
-                sidesComboBox));
-        table.setDefaultEditor(Part.class, new DefaultCellEditor(
-                partsComboBox));
-        table.setDefaultEditor(Type.class, new DefaultCellEditor(
-                typesComboBox));
-        table.setDefaultRenderer(Part.class,
-                new IdentifiableTableCellRenderer<Part>());
-        table.setDefaultRenderer(PlacementsTableModel.Status.class,
-                new StatusRenderer());
-        table.setDefaultRenderer(Placement.Type.class,
-                new TypeRenderer());
-        table.getSelectionModel().addListSelectionListener(
-                new ListSelectionListener() {
-                    @Override
-                    public void valueChanged(ListSelectionEvent e) {
-                        if (e.getValueIsAdjusting()) {
-                            return;
-                        }
-                        
-                        if (getSelections().size() > 1) {
-                            // multi select
-                            singleSelectionActionGroup.setEnabled(false);
-                            captureAndPositionActionGroup.setEnabled(false);
-                            multiSelectionActionGroup.setEnabled(true);
-                        }
-                        else {
-                            // single select, or no select
-                            multiSelectionActionGroup.setEnabled(false);
-                            singleSelectionActionGroup.setEnabled(getSelection() != null);
-                            captureAndPositionActionGroup.setEnabled(getSelection() != null && getSelection().getSide() == boardLocation.getSide());
-                        }
-                    }
-                });
+        table.setDefaultEditor(Side.class, new DefaultCellEditor(sidesComboBox));
+        table.setDefaultEditor(Part.class, new DefaultCellEditor(partsComboBox));
+        table.setDefaultEditor(Type.class, new DefaultCellEditor(typesComboBox));
+        table.setDefaultRenderer(Part.class, new IdentifiableTableCellRenderer<Part>());
+        table.setDefaultRenderer(PlacementsTableModel.Status.class, new StatusRenderer());
+        table.setDefaultRenderer(Placement.Type.class, new TypeRenderer());
+        table.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+
+                if (getSelections().size() > 1) {
+                    // multi select
+                    singleSelectionActionGroup.setEnabled(false);
+                    captureAndPositionActionGroup.setEnabled(false);
+                    multiSelectionActionGroup.setEnabled(true);
+                }
+                else {
+                    // single select, or no select
+                    multiSelectionActionGroup.setEnabled(false);
+                    singleSelectionActionGroup.setEnabled(getSelection() != null);
+                    captureAndPositionActionGroup.setEnabled(getSelection() != null
+                            && getSelection().getSide() == boardLocation.getSide());
+                }
+            }
+        });
         table.addMouseListener(new MouseAdapter() {
             public void mouseClicked(MouseEvent mouseEvent) {
                 if (mouseEvent.getClickCount() != 2) {
                     return;
                 }
-                int row = table.rowAtPoint(new Point(mouseEvent
-                        .getX(), mouseEvent.getY()));
-                int col = table.columnAtPoint(new Point(mouseEvent
-                        .getX(), mouseEvent.getY()));
+                int row = table.rowAtPoint(new Point(mouseEvent.getX(), mouseEvent.getY()));
+                int col = table.columnAtPoint(new Point(mouseEvent.getX(), mouseEvent.getY()));
                 if (tableModel.getColumnClass(col) == Status.class) {
-                    Status status = (Status) tableModel.getValueAt(
-                            row, col);
+                    Status status = (Status) tableModel.getValueAt(row, col);
                     // TODO: This is some sample code for handling the user
                     // wishing to do something with the status. Not using it
                     // right now but leaving it here for the future.
@@ -204,9 +189,9 @@ public void keyTyped(KeyEvent e) {
                 }
             }
         });
-        
+
         JPopupMenu popupMenu = new JPopupMenu();
-        
+
         JMenu setTypeMenu = new JMenu(setTypeAction);
         for (Placement.Type type : Placement.Type.values()) {
             setTypeMenu.add(new SetTypeAction(type));
@@ -215,16 +200,16 @@ public void keyTyped(KeyEvent e) {
 
         JMenu setSideMenu = new JMenu(setSideAction);
         for (Board.Side side : Board.Side.values()) {
-        	setSideMenu.add(new SetSideAction(side));
+            setSideMenu.add(new SetSideAction(side));
         }
         popupMenu.add(setSideMenu);
 
-        table.setComponentPopupMenu(popupMenu);        
+        table.setComponentPopupMenu(popupMenu);
 
         JScrollPane scrollPane = new JScrollPane(table);
         add(scrollPane, BorderLayout.CENTER);
     }
-    
+
     public void setBoardLocation(BoardLocation boardLocation) {
         this.boardLocation = boardLocation;
         if (boardLocation == null) {
@@ -244,7 +229,7 @@ public Placement getSelection() {
         }
         return selectedPlacements.get(0);
     }
-    
+
     public List<Placement> getSelections() {
         ArrayList<Placement> placements = new ArrayList<>();
         if (boardLocation == null) {
@@ -262,18 +247,14 @@ public Placement getSelection() {
         {
             putValue(SMALL_ICON, Icons.add);
             putValue(NAME, "New Placement");
-            putValue(SHORT_DESCRIPTION,
-                    "Create a new placement and add it to the board.");
+            putValue(SHORT_DESCRIPTION, "Create a new placement and add it to the board.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
             if (Configuration.get().getParts().size() == 0) {
-                MessageBoxes
-                        .errorBox(
-                                getTopLevelAncestor(),
-                                "Error",
-                                "There are currently no parts defined in the system. Please create at least one part before creating a placement.");
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Error",
+                        "There are currently no parts defined in the system. Please create at least one part before creating a placement.");
                 return;
             }
 
@@ -286,8 +267,7 @@ public void actionPerformed(ActionEvent arg0) {
             Placement placement = new Placement(id);
 
             placement.setPart(Configuration.get().getParts().get(0));
-            placement.setLocation(new Location(Configuration.get()
-                    .getSystemUnits()));
+            placement.setLocation(new Location(Configuration.get().getSystemUnits()));
 
             boardLocation.getBoard().addPlacement(placement);
             tableModel.fireTableDataChanged();
@@ -299,8 +279,7 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.delete);
             putValue(NAME, "Remove Placement(s)");
-            putValue(SHORT_DESCRIPTION,
-                    "Remove the currently selected placement(s).");
+            putValue(SHORT_DESCRIPTION, "Remove the currently selected placement(s).");
         }
 
         @Override
@@ -316,24 +295,19 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.centerCamera);
             putValue(NAME, "Move Camera To Placement Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the camera at the placement's location.");
+            putValue(SHORT_DESCRIPTION, "Position the camera at the placement's location.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
-                Location location = Utils2D.calculateBoardPlacementLocation(
-                		boardLocation,
-                		getSelection().getLocation());
-
-                Camera camera = MainFrame
-                		.machineControlsPanel
-                		.getSelectedTool()
-                		.getHead()
-                		.getDefaultCamera();
+            UiUtils.submitUiMachineTask(() -> {
+                Location location = Utils2D.calculateBoardPlacementLocation(boardLocation,
+                        getSelection().getLocation());
+
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
                 MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-        	});
+            });
         }
     };
 
@@ -341,18 +315,15 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.centerTool);
             putValue(NAME, "Move Tool To Placement Location");
-            putValue(SHORT_DESCRIPTION,
-                    "Position the tool at the placement's location.");
+            putValue(SHORT_DESCRIPTION, "Position the tool at the placement's location.");
         }
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-            Location location = Utils2D.calculateBoardPlacementLocation(
-            		boardLocation,
-            		getSelection().getLocation());
+            Location location = Utils2D.calculateBoardPlacementLocation(boardLocation,
+                    getSelection().getLocation());
 
-            Nozzle nozzle = MainFrame.machineControlsPanel
-                    .getSelectedNozzle();
+            Nozzle nozzle = MainFrame.machineControlsPanel.getSelectedNozzle();
             UiUtils.submitUiMachineTask(() -> {
                 MovableUtils.moveToLocationAtSafeZ(nozzle, location, 1.0);
             });
@@ -369,15 +340,14 @@ public void actionPerformed(ActionEvent arg0) {
 
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
-            	Camera camera = tool.getHead().getDefaultCamera();
+            UiUtils.messageBoxOnException(() -> {
+                HeadMountable tool = MainFrame.machineControlsPanel.getSelectedTool();
+                Camera camera = tool.getHead().getDefaultCamera();
                 Location placementLocation = Utils2D.calculateBoardPlacementLocationInverse(
-                		boardLocation,
-                        camera.getLocation());
+                        boardLocation, camera.getLocation());
                 getSelection().setLocation(placementLocation);
                 table.repaint();
-        	});
+            });
         }
     };
 
@@ -393,10 +363,8 @@ public void actionPerformed(ActionEvent arg0) {
         public void actionPerformed(ActionEvent arg0) {
             Nozzle nozzle = MainFrame.machineControlsPanel.getSelectedNozzle();
             Location placementLocation = Utils2D
-                    .calculateBoardPlacementLocationInverse(
-                		boardLocation,
-                        nozzle.getLocation());
-                getSelection().setLocation(placementLocation);
+                    .calculateBoardPlacementLocationInverse(boardLocation, nozzle.getLocation());
+            getSelection().setLocation(placementLocation);
             table.repaint();
         }
     };
@@ -405,8 +373,7 @@ public void actionPerformed(ActionEvent arg0) {
         {
             putValue(SMALL_ICON, Icons.editFeeder);
             putValue(NAME, "Edit Placement Feeder");
-            putValue(SHORT_DESCRIPTION,
-                    "Edit the placement's associated feeder definition.");
+            putValue(SHORT_DESCRIPTION, "Edit the placement's associated feeder definition.");
         }
 
         @Override
@@ -415,22 +382,20 @@ public void actionPerformed(ActionEvent arg0) {
             MainFrame.feedersPanel.showFeederForPart(placement.getPart());
         }
     };
-    
+
     public final Action setTypeAction = new AbstractAction() {
         {
             putValue(NAME, "Set Type");
-            putValue(SHORT_DESCRIPTION,
-                    "Set placement type(s) to...");
+            putValue(SHORT_DESCRIPTION, "Set placement type(s) to...");
         }
 
         @Override
-        public void actionPerformed(ActionEvent arg0) {
-        }
+        public void actionPerformed(ActionEvent arg0) {}
     };
-    
+
     class SetTypeAction extends AbstractAction {
         final Placement.Type type;
-        
+
         public SetTypeAction(Placement.Type type) {
             this.type = type;
             putValue(NAME, type.toString());
@@ -444,22 +409,20 @@ public void actionPerformed(ActionEvent arg0) {
             }
         }
     };
-    
+
     public final Action setSideAction = new AbstractAction() {
         {
             putValue(NAME, "Set Side");
-            putValue(SHORT_DESCRIPTION,
-                    "Set placement side(s) to...");
+            putValue(SHORT_DESCRIPTION, "Set placement side(s) to...");
         }
 
         @Override
-        public void actionPerformed(ActionEvent arg0) {
-        }
+        public void actionPerformed(ActionEvent arg0) {}
     };
-    
+
     class SetSideAction extends AbstractAction {
         final Board.Side side;
-        
+
         public SetSideAction(Board.Side side) {
             this.side = side;
             putValue(NAME, side.toString());
@@ -473,7 +436,7 @@ public void actionPerformed(ActionEvent arg0) {
             }
         }
     };
-    
+
     static class TypeRenderer extends DefaultTableCellRenderer {
         public void setValue(Object value) {
             Type type = (Type) value;
@@ -495,7 +458,7 @@ else if (type == Type.Place) {
             }
         }
     }
-    
+
     static class StatusRenderer extends DefaultTableCellRenderer {
         public void setValue(Object value) {
             Status status = (Status) value;
diff --git a/src/main/java/org/openpnp/gui/JogControlsPanel.java b/src/main/java/org/openpnp/gui/JogControlsPanel.java
index b97810b81b..bcf4583ed6 100755
--- a/src/main/java/org/openpnp/gui/JogControlsPanel.java
+++ b/src/main/java/org/openpnp/gui/JogControlsPanel.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
@@ -56,47 +54,46 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 /**
- * Contains controls, DROs and status for the machine. Controls: C right / left,
- * X + / -, Y + / -, Z + / -, stop, pause, slider for jog increment DROs: X, Y,
- * Z, C Radio buttons to select mm or inch.
+ * Contains controls, DROs and status for the machine. Controls: C right / left, X + / -, Y + / -, Z
+ * + / -, stop, pause, slider for jog increment DROs: X, Y, Z, C Radio buttons to select mm or inch.
  * 
  * @author jason
  */
 public class JogControlsPanel extends JPanel {
-	private final MachineControlsPanel machineControlsPanel;
-	private final Frame frame;
-	private final Configuration configuration;
+    private final MachineControlsPanel machineControlsPanel;
+    private final Frame frame;
+    private final Configuration configuration;
     private JPanel panelActuators;
     private JPanel panelDispensers;
 
-	/**
-	 * Create the panel.
-	 */
-	public JogControlsPanel(Configuration configuration,
-			MachineControlsPanel machineControlsPanel, Frame frame) {
-		this.machineControlsPanel = machineControlsPanel;
-		this.frame = frame;
-		this.configuration = configuration;
-
-		createUi();
-
-		configuration.addListener(configurationListener);
-	}
-
-	@Override
-	public void setEnabled(boolean enabled) {
-		super.setEnabled(enabled);
-		xPlusAction.setEnabled(enabled);
-		xMinusAction.setEnabled(enabled);
-		yPlusAction.setEnabled(enabled);
-		yMinusAction.setEnabled(enabled);
-		zPlusAction.setEnabled(enabled);
-		zMinusAction.setEnabled(enabled);
-		cPlusAction.setEnabled(enabled);
-		cMinusAction.setEnabled(enabled);
-		pickAction.setEnabled(enabled);
-		placeAction.setEnabled(enabled);
-		safezAction.setEnabled(enabled);
+    /**
+     * Create the panel.
+     */
+    public JogControlsPanel(Configuration configuration, MachineControlsPanel machineControlsPanel,
+            Frame frame) {
+        this.machineControlsPanel = machineControlsPanel;
+        this.frame = frame;
+        this.configuration = configuration;
+
+        createUi();
+
+        configuration.addListener(configurationListener);
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        super.setEnabled(enabled);
+        xPlusAction.setEnabled(enabled);
+        xMinusAction.setEnabled(enabled);
+        yPlusAction.setEnabled(enabled);
+        yMinusAction.setEnabled(enabled);
+        zPlusAction.setEnabled(enabled);
+        zMinusAction.setEnabled(enabled);
+        cPlusAction.setEnabled(enabled);
+        cMinusAction.setEnabled(enabled);
+        pickAction.setEnabled(enabled);
+        placeAction.setEnabled(enabled);
+        safezAction.setEnabled(enabled);
         xyZeroAction.setEnabled(enabled);
         zZeroAction.setEnabled(enabled);
         cZeroAction.setEnabled(enabled);
@@ -106,19 +103,19 @@ public void setEnabled(boolean enabled) {
         for (Component c : panelDispensers.getComponents()) {
             c.setEnabled(enabled);
         }
-	}
+    }
 
     private void jog(final int x, final int y, final int z, final int c) {
         UiUtils.submitUiMachineTask(() -> {
-            Location l = machineControlsPanel.getSelectedNozzle().getLocation().convertToUnits(Configuration.get().getSystemUnits());
+            Location l = machineControlsPanel.getSelectedNozzle().getLocation()
+                    .convertToUnits(Configuration.get().getSystemUnits());
             double xPos = l.getX();
             double yPos = l.getY();
             double zPos = l.getZ();
             double cPos = l.getRotation();
 
-            double jogIncrement = new Length(machineControlsPanel
-                    .getJogIncrement(), configuration.getSystemUnits())
-                    .getValue();
+            double jogIncrement = new Length(machineControlsPanel.getJogIncrement(),
+                    configuration.getSystemUnits()).getValue();
 
             if (x > 0) {
                 xPos += jogIncrement;
@@ -147,203 +144,192 @@ else if (z < 0) {
             else if (c < 0) {
                 cPos -= jogIncrement;
             }
-            
-            machineControlsPanel.getSelectedNozzle().moveTo(new Location(l.getUnits(), xPos, yPos, zPos, cPos), 1.0);
+
+            machineControlsPanel.getSelectedNozzle()
+                    .moveTo(new Location(l.getUnits(), xPos, yPos, zPos, cPos), 1.0);
         });
     }
 
     private void zero(boolean xy, boolean z, boolean c) {
         UiUtils.submitUiMachineTask(() -> {
-            Location l = machineControlsPanel.getSelectedNozzle().getLocation().convertToUnits(Configuration.get().getSystemUnits());
+            Location l = machineControlsPanel.getSelectedNozzle().getLocation()
+                    .convertToUnits(Configuration.get().getSystemUnits());
             l = l.derive(xy ? 0d : null, xy ? 0d : null, z ? 0d : null, c ? 0d : null);
             machineControlsPanel.getSelectedNozzle().moveTo(l, 1.0);
         });
     }
 
-	private void createUi() {
-		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
-		
-		JPanel panel = new JPanel();
-		panel.setBorder(new TitledBorder(null, "", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		add(panel);
-
-		JPanel panelControls = new JPanel();
-		panel.add(panelControls);
-		panelControls.setLayout(new FormLayout(new ColumnSpec[] {
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,},
-		    new RowSpec[] {
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		JButton homeButton = new JButton(machineControlsPanel.homeAction);
-		homeButton.setHideActionText(true);
-		panelControls.add(homeButton, "2, 2");
-		
-		JLabel lblXy = new JLabel("X/Y");
-		lblXy.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
-		lblXy.setHorizontalAlignment(SwingConstants.CENTER);
-		panelControls.add(lblXy, "8, 2, fill, default");
-		
-		JLabel lblZ = new JLabel("Z");
-		lblZ.setHorizontalAlignment(SwingConstants.CENTER);
-		lblZ.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
-		panelControls.add(lblZ, "14, 2");
-		
-		JButton yPlusButton = new JButton(yPlusAction);
-		yPlusButton.setHideActionText(true);
-		panelControls.add(yPlusButton, "8, 4");
-		
-		JButton zUpButton = new JButton(zPlusAction);
-		zUpButton.setHideActionText(true);
-		panelControls.add(zUpButton, "14, 4");
-		
-		JButton xMinusButton = new JButton(xMinusAction);
-		xMinusButton.setHideActionText(true);
-		panelControls.add(xMinusButton, "6, 6");
-		
-		JButton homeXyButton = new JButton(xyZeroAction);
-		homeXyButton.setHideActionText(true);
-		panelControls.add(homeXyButton, "8, 6");
-		
-		JButton xPlusButton = new JButton(xPlusAction);
-		xPlusButton.setHideActionText(true);
-		panelControls.add(xPlusButton, "10, 6");
-		
-		JButton homeZButton = new JButton(zZeroAction);
-		homeZButton.setHideActionText(true);
-		panelControls.add(homeZButton, "14, 6");
-		
-		JButton yMinusButton = new JButton(yMinusAction);
-		yMinusButton.setHideActionText(true);
-		panelControls.add(yMinusButton, "8, 8");
-		
-		JButton zDownButton = new JButton(zMinusAction);
-		zDownButton.setHideActionText(true);
-		panelControls.add(zDownButton, "14, 8");
-		
-		JLabel lblC = new JLabel("C");
-		lblC.setHorizontalAlignment(SwingConstants.CENTER);
-		lblC.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
-		panelControls.add(lblC, "2, 12");
-		
-		JButton counterclockwiseButton = new JButton(cPlusAction);
-		counterclockwiseButton.setHideActionText(true);
-		panelControls.add(counterclockwiseButton, "6, 12");
-		
-		JButton homeCButton = new JButton(cZeroAction);
-		homeCButton.setHideActionText(true);
-		panelControls.add(homeCButton, "8, 12");
-		
-		JButton clockwiseButton = new JButton(cMinusAction);
-		clockwiseButton.setHideActionText(true);
-		panelControls.add(clockwiseButton, "10, 12");
-
-		JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
-		add(tabbedPane);
-
-		JPanel panelSpecial = new JPanel();
-		tabbedPane.addTab("Special Commands", null, panelSpecial, null);
-		FlowLayout flowLayout_1 = (FlowLayout) panelSpecial.getLayout();
-		flowLayout_1.setAlignment(FlowLayout.LEFT);
-
-		panelActuators = new JPanel();
-		tabbedPane.addTab("Actuators", null, panelActuators, null);
-		FlowLayout fl_panelActuators = (FlowLayout) panelActuators.getLayout();
-		fl_panelActuators.setAlignment(FlowLayout.LEFT);
-		
-		JButton btnPick = new JButton(pickAction);
-		panelSpecial.add(btnPick);
-		
-		JButton btnPlace = new JButton(placeAction);
-		panelSpecial.add(btnPlace);
-		
-		JButton btnSafeZ = new JButton(safezAction);
-		panelSpecial.add(btnSafeZ);
-		
-		panelDispensers = new JPanel();
-		FlowLayout flowLayout = (FlowLayout) panelDispensers.getLayout();
-		flowLayout.setAlignment(FlowLayout.LEFT);
-		tabbedPane.addTab("Paste Dispensers", null, panelDispensers, null);
-	}
-
-	@SuppressWarnings("serial")
-	public Action yPlusAction = new AbstractAction("Y+", Icons.arrowUp) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(0, 1, 0, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action yMinusAction = new AbstractAction("Y-", Icons.arrowDown) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(0, -1, 0, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action xPlusAction = new AbstractAction("X+", Icons.arrowRight) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(1, 0, 0, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action xMinusAction = new AbstractAction("X-", Icons.arrowLeft) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(-1, 0, 0, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action zPlusAction = new AbstractAction("Z+", Icons.arrowUp) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(0, 0, 1, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action zMinusAction = new AbstractAction("Z-", Icons.arrowDown) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(0, 0, -1, 0);
-		}
-	};
-
-	@SuppressWarnings("serial")
-	public Action cPlusAction = new AbstractAction("C+", Icons.rotateCounterclockwise) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			jog(0, 0, 0, 1);
-		}
-	};
+    private void createUi() {
+        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
+
+        JPanel panel = new JPanel();
+        panel.setBorder(
+                new TitledBorder(null, "", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        add(panel);
+
+        JPanel panelControls = new JPanel();
+        panel.add(panelControls);
+        panelControls.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JButton homeButton = new JButton(machineControlsPanel.homeAction);
+        homeButton.setHideActionText(true);
+        panelControls.add(homeButton, "2, 2");
+
+        JLabel lblXy = new JLabel("X/Y");
+        lblXy.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
+        lblXy.setHorizontalAlignment(SwingConstants.CENTER);
+        panelControls.add(lblXy, "8, 2, fill, default");
+
+        JLabel lblZ = new JLabel("Z");
+        lblZ.setHorizontalAlignment(SwingConstants.CENTER);
+        lblZ.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
+        panelControls.add(lblZ, "14, 2");
+
+        JButton yPlusButton = new JButton(yPlusAction);
+        yPlusButton.setHideActionText(true);
+        panelControls.add(yPlusButton, "8, 4");
+
+        JButton zUpButton = new JButton(zPlusAction);
+        zUpButton.setHideActionText(true);
+        panelControls.add(zUpButton, "14, 4");
+
+        JButton xMinusButton = new JButton(xMinusAction);
+        xMinusButton.setHideActionText(true);
+        panelControls.add(xMinusButton, "6, 6");
+
+        JButton homeXyButton = new JButton(xyZeroAction);
+        homeXyButton.setHideActionText(true);
+        panelControls.add(homeXyButton, "8, 6");
+
+        JButton xPlusButton = new JButton(xPlusAction);
+        xPlusButton.setHideActionText(true);
+        panelControls.add(xPlusButton, "10, 6");
+
+        JButton homeZButton = new JButton(zZeroAction);
+        homeZButton.setHideActionText(true);
+        panelControls.add(homeZButton, "14, 6");
+
+        JButton yMinusButton = new JButton(yMinusAction);
+        yMinusButton.setHideActionText(true);
+        panelControls.add(yMinusButton, "8, 8");
+
+        JButton zDownButton = new JButton(zMinusAction);
+        zDownButton.setHideActionText(true);
+        panelControls.add(zDownButton, "14, 8");
+
+        JLabel lblC = new JLabel("C");
+        lblC.setHorizontalAlignment(SwingConstants.CENTER);
+        lblC.setFont(new Font("Lucida Grande", Font.PLAIN, 22));
+        panelControls.add(lblC, "2, 12");
+
+        JButton counterclockwiseButton = new JButton(cPlusAction);
+        counterclockwiseButton.setHideActionText(true);
+        panelControls.add(counterclockwiseButton, "6, 12");
+
+        JButton homeCButton = new JButton(cZeroAction);
+        homeCButton.setHideActionText(true);
+        panelControls.add(homeCButton, "8, 12");
+
+        JButton clockwiseButton = new JButton(cMinusAction);
+        clockwiseButton.setHideActionText(true);
+        panelControls.add(clockwiseButton, "10, 12");
+
+        JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
+        add(tabbedPane);
+
+        JPanel panelSpecial = new JPanel();
+        tabbedPane.addTab("Special Commands", null, panelSpecial, null);
+        FlowLayout flowLayout_1 = (FlowLayout) panelSpecial.getLayout();
+        flowLayout_1.setAlignment(FlowLayout.LEFT);
+
+        panelActuators = new JPanel();
+        tabbedPane.addTab("Actuators", null, panelActuators, null);
+        FlowLayout fl_panelActuators = (FlowLayout) panelActuators.getLayout();
+        fl_panelActuators.setAlignment(FlowLayout.LEFT);
+
+        JButton btnPick = new JButton(pickAction);
+        panelSpecial.add(btnPick);
+
+        JButton btnPlace = new JButton(placeAction);
+        panelSpecial.add(btnPlace);
+
+        JButton btnSafeZ = new JButton(safezAction);
+        panelSpecial.add(btnSafeZ);
+
+        panelDispensers = new JPanel();
+        FlowLayout flowLayout = (FlowLayout) panelDispensers.getLayout();
+        flowLayout.setAlignment(FlowLayout.LEFT);
+        tabbedPane.addTab("Paste Dispensers", null, panelDispensers, null);
+    }
+
+    @SuppressWarnings("serial")
+    public Action yPlusAction = new AbstractAction("Y+", Icons.arrowUp) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(0, 1, 0, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action yMinusAction = new AbstractAction("Y-", Icons.arrowDown) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(0, -1, 0, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action xPlusAction = new AbstractAction("X+", Icons.arrowRight) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(1, 0, 0, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action xMinusAction = new AbstractAction("X-", Icons.arrowLeft) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(-1, 0, 0, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action zPlusAction = new AbstractAction("Z+", Icons.arrowUp) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(0, 0, 1, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action zMinusAction = new AbstractAction("Z-", Icons.arrowDown) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(0, 0, -1, 0);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action cPlusAction = new AbstractAction("C+", Icons.rotateCounterclockwise) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            jog(0, 0, 0, 1);
+        }
+    };
 
     @SuppressWarnings("serial")
     public Action cMinusAction = new AbstractAction("C-", Icons.rotateClockwise) {
@@ -381,9 +367,9 @@ public void actionPerformed(ActionEvent arg0) {
     public Action pickAction = new AbstractAction("Pick") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 machineControlsPanel.getSelectedNozzle().pick();
-        	});
+            });
         }
     };
 
@@ -391,63 +377,63 @@ public void actionPerformed(ActionEvent arg0) {
     public Action placeAction = new AbstractAction("Place") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 machineControlsPanel.getSelectedNozzle().place();
-        	});
+            });
         }
     };
-    
+
     @SuppressWarnings("serial")
     public Action safezAction = new AbstractAction("Head Safe Z") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 Configuration.get().getMachine().getDefaultHead().moveToSafeZ(1.0);
-        	});
+            });
         }
     };
 
-	private ConfigurationListener configurationListener = new ConfigurationListener.Adapter() {
-		@Override
-		public void configurationComplete(Configuration configuration) throws Exception {
-			panelActuators.removeAll();
+    private ConfigurationListener configurationListener = new ConfigurationListener.Adapter() {
+        @Override
+        public void configurationComplete(Configuration configuration) throws Exception {
+            panelActuators.removeAll();
+
+            Machine machine = Configuration.get().getMachine();
 
-			Machine machine = Configuration.get().getMachine();
-			
-			for (final Head head : machine.getHeads()) {
+            for (final Head head : machine.getHeads()) {
                 for (Actuator actuator : head.getActuators()) {
                     final Actuator actuator_f = actuator;
-                    final JToggleButton actuatorButton = new JToggleButton(
-                            head.getName() + ":" + actuator_f.getName());
+                    final JToggleButton actuatorButton =
+                            new JToggleButton(head.getName() + ":" + actuator_f.getName());
                     actuatorButton.setFocusable(false);
                     actuatorButton.addActionListener(new ActionListener() {
                         @Override
                         public void actionPerformed(ActionEvent e) {
                             final boolean state = actuatorButton.isSelected();
-                        	UiUtils.submitUiMachineTask(() -> {
+                            UiUtils.submitUiMachineTask(() -> {
                                 actuator_f.actuate(state);
-                        	});
+                            });
                         }
                     });
                     panelActuators.add(actuatorButton);
                 }
                 for (final PasteDispenser dispenser : head.getPasteDispensers()) {
-                    final JButton dispenserButton = new JButton(
-                            head.getName() + ":" + dispenser.getName());
+                    final JButton dispenserButton =
+                            new JButton(head.getName() + ":" + dispenser.getName());
                     dispenserButton.setFocusable(false);
                     dispenserButton.addActionListener(new ActionListener() {
                         @Override
                         public void actionPerformed(ActionEvent e) {
-                        	UiUtils.submitUiMachineTask(() -> {
+                            UiUtils.submitUiMachineTask(() -> {
                                 dispenser.dispense(null, null, 250);
-                        	});
+                            });
                         }
                     });
                     panelDispensers.add(dispenserButton);
                 }
-			}
+            }
 
-			setEnabled(machineControlsPanel.isEnabled());
-		}
-	};
+            setEnabled(machineControlsPanel.isEnabled());
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/MachineControlsPanel.java b/src/main/java/org/openpnp/gui/MachineControlsPanel.java
index 86e53fea27..2910a29199 100755
--- a/src/main/java/org/openpnp/gui/MachineControlsPanel.java
+++ b/src/main/java/org/openpnp/gui/MachineControlsPanel.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
@@ -37,7 +35,6 @@
 import java.awt.event.MouseEvent;
 import java.util.Hashtable;
 import java.util.Locale;
-import java.util.concurrent.Callable;
 
 import javax.swing.AbstractAction;
 import javax.swing.Action;
@@ -73,92 +70,89 @@
 import org.openpnp.util.MovableUtils;
 import org.openpnp.util.UiUtils;
 
-import com.google.common.util.concurrent.FutureCallback;
 import com.jgoodies.forms.layout.ColumnSpec;
 import com.jgoodies.forms.layout.FormLayout;
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
 public class MachineControlsPanel extends JPanel {
-	private final JFrame frame;
-	private final CameraPanel cameraPanel;
-	private final Configuration configuration;
-
-	private Nozzle selectedNozzle;
-
-	private JTextField textFieldX;
-	private JTextField textFieldY;
-	private JTextField textFieldC;
-	private JTextField textFieldZ;
-	private JButton btnStartStop;
-	private JSlider sliderIncrements;
+    private final JFrame frame;
+    private final CameraPanel cameraPanel;
+    private final Configuration configuration;
+
+    private Nozzle selectedNozzle;
+
+    private JTextField textFieldX;
+    private JTextField textFieldY;
+    private JTextField textFieldC;
+    private JTextField textFieldZ;
+    private JButton btnStartStop;
+    private JSlider sliderIncrements;
     private JComboBox comboBoxNozzles;
-	
-	
-	private Color startColor = Color.green;
-	private Color stopColor = new Color(178, 34, 34);
-	private Color droNormalColor = new Color(0xBDFFBE);
-	private Color droEditingColor = new Color(0xF0F0A1);
-	private Color droWarningColor = new Color(0xFF5C5C);
-	private Color droSavedColor = new Color(0x90cce0);
-	
-	private JogControlsPanel jogControlsPanel;
-	private JDialog jogControlsWindow;
-	
-	private volatile double savedX = Double.NaN, savedY = Double.NaN, savedZ = Double.NaN, savedC = Double.NaN; 
-	
-	/**
-	 * Create the panel.
-	 */
-	public MachineControlsPanel(Configuration configuration, JFrame frame, CameraPanel cameraPanel) {
-		this.frame = frame;
-		this.cameraPanel = cameraPanel;
-		this.configuration = configuration;
-		
-		jogControlsPanel = new JogControlsPanel(configuration, this, frame);
-		
-		createUi();
-		
-		configuration.addListener(configurationListener);
-
-		jogControlsWindow = new JDialog(frame, "Jog Controls");
-		jogControlsWindow.setResizable(false);
-		jogControlsWindow.getContentPane().setLayout(new BorderLayout());
-		jogControlsWindow.getContentPane().add(jogControlsPanel);
-	}
-	
-	public void setSelectedNozzle(Nozzle nozzle) {
-	    selectedNozzle = nozzle;
-	    comboBoxNozzles.setSelectedItem(selectedNozzle);
-	    updateDros();
-	}
-	
+
+
+    private Color startColor = Color.green;
+    private Color stopColor = new Color(178, 34, 34);
+    private Color droNormalColor = new Color(0xBDFFBE);
+    private Color droEditingColor = new Color(0xF0F0A1);
+    private Color droWarningColor = new Color(0xFF5C5C);
+    private Color droSavedColor = new Color(0x90cce0);
+
+    private JogControlsPanel jogControlsPanel;
+    private JDialog jogControlsWindow;
+
+    private volatile double savedX = Double.NaN, savedY = Double.NaN, savedZ = Double.NaN,
+            savedC = Double.NaN;
+
+    /**
+     * Create the panel.
+     */
+    public MachineControlsPanel(Configuration configuration, JFrame frame,
+            CameraPanel cameraPanel) {
+        this.frame = frame;
+        this.cameraPanel = cameraPanel;
+        this.configuration = configuration;
+
+        jogControlsPanel = new JogControlsPanel(configuration, this, frame);
+
+        createUi();
+
+        configuration.addListener(configurationListener);
+
+        jogControlsWindow = new JDialog(frame, "Jog Controls");
+        jogControlsWindow.setResizable(false);
+        jogControlsWindow.getContentPane().setLayout(new BorderLayout());
+        jogControlsWindow.getContentPane().add(jogControlsPanel);
+    }
+
+    public void setSelectedNozzle(Nozzle nozzle) {
+        selectedNozzle = nozzle;
+        comboBoxNozzles.setSelectedItem(selectedNozzle);
+        updateDros();
+    }
+
     public Nozzle getSelectedNozzle() {
         return selectedNozzle;
     }
-    
+
     public PasteDispenser getSelectedPasteDispenser() {
         try {
             // TODO: We don't actually have a way to select a dispenser yet, so
             // until we do we just return the first one.
-            return Configuration
-            		.get()
-            		.getMachine()
-            		.getDefaultHead()
-            		.getDefaultPasteDispenser();
+            return Configuration.get().getMachine().getDefaultHead().getDefaultPasteDispenser();
         }
         catch (Exception e) {
             return null;
         }
     }
-    
+
     /**
-     * Returns the selected Nozzle or PasteDispenser depending on which type
-     * of Job is selected.
+     * Returns the selected Nozzle or PasteDispenser depending on which type of Job is selected.
+     * 
      * @return
      */
     public HeadMountable getSelectedTool() {
-    	JobProcessor.Type jobProcessorType = MainFrame.jobPanel.getSelectedJobProcessorType(); 
+        JobProcessor.Type jobProcessorType = MainFrame.jobPanel.getSelectedJobProcessorType();
         if (jobProcessorType == JobProcessor.Type.PickAndPlace) {
             return getSelectedNozzle();
         }
@@ -169,155 +163,154 @@ else if (jobProcessorType == JobProcessor.Type.SolderPaste) {
             throw new Error("Unknown tool type: " + jobProcessorType);
         }
     }
-    
-	public JogControlsPanel getJogControlsPanel() {
-		return jogControlsPanel;
-	}
-	
-	private void setUnits(LengthUnit units) {
-		if (units == LengthUnit.Millimeters) {
-			Hashtable<Integer, JLabel> incrementsLabels = new Hashtable<>();
-			incrementsLabels.put(1, new JLabel("0.01"));
-			incrementsLabels.put(2, new JLabel("0.1"));
-			incrementsLabels.put(3, new JLabel("1.0"));
+
+    public JogControlsPanel getJogControlsPanel() {
+        return jogControlsPanel;
+    }
+
+    private void setUnits(LengthUnit units) {
+        if (units == LengthUnit.Millimeters) {
+            Hashtable<Integer, JLabel> incrementsLabels = new Hashtable<>();
+            incrementsLabels.put(1, new JLabel("0.01"));
+            incrementsLabels.put(2, new JLabel("0.1"));
+            incrementsLabels.put(3, new JLabel("1.0"));
             incrementsLabels.put(4, new JLabel("10"));
             incrementsLabels.put(5, new JLabel("100"));
-			sliderIncrements.setLabelTable(incrementsLabels);
-		}
-		else if (units == LengthUnit.Inches) {
-			Hashtable<Integer, JLabel> incrementsLabels = new Hashtable<>();
-			incrementsLabels.put(1, new JLabel("0.001"));
-			incrementsLabels.put(2, new JLabel("0.01"));
-			incrementsLabels.put(3, new JLabel("0.1"));
+            sliderIncrements.setLabelTable(incrementsLabels);
+        }
+        else if (units == LengthUnit.Inches) {
+            Hashtable<Integer, JLabel> incrementsLabels = new Hashtable<>();
+            incrementsLabels.put(1, new JLabel("0.001"));
+            incrementsLabels.put(2, new JLabel("0.01"));
+            incrementsLabels.put(3, new JLabel("0.1"));
             incrementsLabels.put(4, new JLabel("1.0"));
             incrementsLabels.put(5, new JLabel("10.0"));
-			sliderIncrements.setLabelTable(incrementsLabels);
-		}
-		else {
-			throw new Error("setUnits() not implemented for " + units);
-		}
-		updateDros();
-	}
-
-	public double getJogIncrement() {
-		if (configuration.getSystemUnits() == LengthUnit.Millimeters) {
-			return 0.01 * Math.pow(10, sliderIncrements.getValue() - 1);
-		}
-		else if (configuration.getSystemUnits() == LengthUnit.Inches) {
-			return 0.001 * Math.pow(10, sliderIncrements.getValue() - 1);
-		}
-		else {
-			throw new Error("getJogIncrement() not implemented for " + configuration.getSystemUnits());
-		}
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) {
-		super.setEnabled(enabled);
-		homeAction.setEnabled(enabled);
-		jogControlsPanel.setEnabled(enabled);
-		targetCameraAction.setEnabled(enabled);
-		targetToolAction.setEnabled(enabled);
-	}
-	
-	public Location getCurrentLocation() {
+            sliderIncrements.setLabelTable(incrementsLabels);
+        }
+        else {
+            throw new Error("setUnits() not implemented for " + units);
+        }
+        updateDros();
+    }
+
+    public double getJogIncrement() {
+        if (configuration.getSystemUnits() == LengthUnit.Millimeters) {
+            return 0.01 * Math.pow(10, sliderIncrements.getValue() - 1);
+        }
+        else if (configuration.getSystemUnits() == LengthUnit.Inches) {
+            return 0.001 * Math.pow(10, sliderIncrements.getValue() - 1);
+        }
+        else {
+            throw new Error(
+                    "getJogIncrement() not implemented for " + configuration.getSystemUnits());
+        }
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        super.setEnabled(enabled);
+        homeAction.setEnabled(enabled);
+        jogControlsPanel.setEnabled(enabled);
+        targetCameraAction.setEnabled(enabled);
+        targetToolAction.setEnabled(enabled);
+    }
+
+    public Location getCurrentLocation() {
         if (selectedNozzle == null) {
             return null;
         }
-        
+
         Location l = selectedNozzle.getLocation();
         l = l.convertToUnits(configuration.getSystemUnits());
-        
+
         return l;
-	}
-	
-	public void updateDros() {
-	    Location l = getCurrentLocation();
-	    if (l == null) {
-	        return;
-	    }
-	    
-		double x, y, z, c;
-		
-		x = l.getX();
-		y = l.getY();
-		z = l.getZ();
-		c = l.getRotation();
-		
+    }
+
+    public void updateDros() {
+        Location l = getCurrentLocation();
+        if (l == null) {
+            return;
+        }
+
+        double x, y, z, c;
+
+        x = l.getX();
+        y = l.getY();
+        z = l.getZ();
+        c = l.getRotation();
+
         double savedX = this.savedX;
-		if (!Double.isNaN(savedX)) {
+        if (!Double.isNaN(savedX)) {
             x -= savedX;
         }
-        
+
         double savedY = this.savedY;
         if (!Double.isNaN(savedY)) {
             y -= savedY;
         }
-        
+
         double savedZ = this.savedZ;
         if (!Double.isNaN(savedZ)) {
             z -= savedZ;
         }
-        
+
         double savedC = this.savedC;
         if (!Double.isNaN(savedC)) {
             c -= savedC;
         }
-        
-		textFieldX.setText(String.format(Locale.US,configuration.getLengthDisplayFormat(), x));
-		textFieldY.setText(String.format(Locale.US,configuration.getLengthDisplayFormat(), y));
-		textFieldZ.setText(String.format(Locale.US,configuration.getLengthDisplayFormat(), z));
-		textFieldC.setText(String.format(Locale.US,configuration.getLengthDisplayFormat(), c));
-	}
-	
-	private void createUi() {
-		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
-		
-		ButtonGroup buttonGroup = new ButtonGroup();
-		
-		JPanel panel = new JPanel();
-		add(panel);
-		panel.setLayout(new FormLayout(new ColumnSpec[] {
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        ColumnSpec.decode("default:grow"),},
-		    new RowSpec[] {
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		comboBoxNozzles = new JComboBox();
-		comboBoxNozzles.addActionListener(new ActionListener() {
+
+        textFieldX.setText(String.format(Locale.US, configuration.getLengthDisplayFormat(), x));
+        textFieldY.setText(String.format(Locale.US, configuration.getLengthDisplayFormat(), y));
+        textFieldZ.setText(String.format(Locale.US, configuration.getLengthDisplayFormat(), z));
+        textFieldC.setText(String.format(Locale.US, configuration.getLengthDisplayFormat(), c));
+    }
+
+    private void createUi() {
+        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
+
+        ButtonGroup buttonGroup = new ButtonGroup();
+
+        JPanel panel = new JPanel();
+        add(panel);
+        panel.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                        ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        comboBoxNozzles = new JComboBox();
+        comboBoxNozzles.addActionListener(new ActionListener() {
             @Override
             public void actionPerformed(ActionEvent e) {
                 setSelectedNozzle(((NozzleItem) comboBoxNozzles.getSelectedItem()).getNozzle());
             }
         });
-		panel.add(comboBoxNozzles, "2, 2, fill, default");
-		
-		JPanel panelDrosParent = new JPanel();
-		add(panelDrosParent);
-		panelDrosParent.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
-		
-		JPanel panelDros = new JPanel();
-		panelDrosParent.add(panelDros);
-		panelDros.setLayout(new BoxLayout(panelDros, BoxLayout.Y_AXIS));
-		
-		JPanel panelDrosFirstLine = new JPanel();
-		panelDros.add(panelDrosFirstLine);
-		panelDrosFirstLine.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
-		
-		JLabel lblX = new JLabel("X");
-		lblX.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		panelDrosFirstLine.add(lblX);
-		
-		textFieldX = new JTextField();
-		textFieldX.setEditable(false);
-		textFieldX.setFocusTraversalKeysEnabled(false);
-		textFieldX.setSelectionColor(droEditingColor);
-		textFieldX.setDisabledTextColor(Color.BLACK);
-		textFieldX.setBackground(droNormalColor);
-		textFieldX.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		textFieldX.setText("0000.0000");
-		textFieldX.addMouseListener(new MouseAdapter() {
+        panel.add(comboBoxNozzles, "2, 2, fill, default");
+
+        JPanel panelDrosParent = new JPanel();
+        add(panelDrosParent);
+        panelDrosParent.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
+
+        JPanel panelDros = new JPanel();
+        panelDrosParent.add(panelDros);
+        panelDros.setLayout(new BoxLayout(panelDros, BoxLayout.Y_AXIS));
+
+        JPanel panelDrosFirstLine = new JPanel();
+        panelDros.add(panelDrosFirstLine);
+        panelDrosFirstLine.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
+
+        JLabel lblX = new JLabel("X");
+        lblX.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        panelDrosFirstLine.add(lblX);
+
+        textFieldX = new JTextField();
+        textFieldX.setEditable(false);
+        textFieldX.setFocusTraversalKeysEnabled(false);
+        textFieldX.setSelectionColor(droEditingColor);
+        textFieldX.setDisabledTextColor(Color.BLACK);
+        textFieldX.setBackground(droNormalColor);
+        textFieldX.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        textFieldX.setText("0000.0000");
+        textFieldX.addMouseListener(new MouseAdapter() {
             @Override
             public void mouseClicked(MouseEvent e) {
                 if (SwingUtilities.isRightMouseButton(e)) {
@@ -326,24 +319,24 @@ public void mouseClicked(MouseEvent e) {
                 saveXAction.actionPerformed(null);
             }
         });
-		panelDrosFirstLine.add(textFieldX);
-		textFieldX.setColumns(6);
-		
-		Component horizontalStrut = Box.createHorizontalStrut(15);
-		panelDrosFirstLine.add(horizontalStrut);
-		
-		JLabel lblY = new JLabel("Y");
-		lblY.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		panelDrosFirstLine.add(lblY);
-		
-		textFieldY = new JTextField();
-		textFieldY.setEditable(false);
-		textFieldY.setFocusTraversalKeysEnabled(false);
-		textFieldY.setSelectionColor(droEditingColor);
-		textFieldY.setDisabledTextColor(Color.BLACK);
-		textFieldY.setBackground(droNormalColor);
-		textFieldY.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		textFieldY.setText("0000.0000");
+        panelDrosFirstLine.add(textFieldX);
+        textFieldX.setColumns(6);
+
+        Component horizontalStrut = Box.createHorizontalStrut(15);
+        panelDrosFirstLine.add(horizontalStrut);
+
+        JLabel lblY = new JLabel("Y");
+        lblY.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        panelDrosFirstLine.add(lblY);
+
+        textFieldY = new JTextField();
+        textFieldY.setEditable(false);
+        textFieldY.setFocusTraversalKeysEnabled(false);
+        textFieldY.setSelectionColor(droEditingColor);
+        textFieldY.setDisabledTextColor(Color.BLACK);
+        textFieldY.setBackground(droNormalColor);
+        textFieldY.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        textFieldY.setText("0000.0000");
         textFieldY.addMouseListener(new MouseAdapter() {
             @Override
             public void mouseClicked(MouseEvent e) {
@@ -353,30 +346,30 @@ public void mouseClicked(MouseEvent e) {
                 saveYAction.actionPerformed(null);
             }
         });
-		panelDrosFirstLine.add(textFieldY);
-		textFieldY.setColumns(6);
-		
-		JButton btnTargetTool = new JButton(targetToolAction);
-		panelDrosFirstLine.add(btnTargetTool);
-		btnTargetTool.setToolTipText("Position the tool at the camera's current location.");
-		
-		JPanel panelDrosSecondLine = new JPanel();
-		panelDros.add(panelDrosSecondLine);
-		panelDrosSecondLine.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
-		
-		JLabel lblC = new JLabel("C");
-		lblC.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		panelDrosSecondLine.add(lblC);
-		
-		textFieldC = new JTextField();
-		textFieldC.setEditable(false);
-		textFieldC.setFocusTraversalKeysEnabled(false);
-		textFieldC.setSelectionColor(droEditingColor);
-		textFieldC.setDisabledTextColor(Color.BLACK);
-		textFieldC.setBackground(droNormalColor);
-		textFieldC.setText("0000.0000");
-		textFieldC.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		textFieldC.setColumns(6);
+        panelDrosFirstLine.add(textFieldY);
+        textFieldY.setColumns(6);
+
+        JButton btnTargetTool = new JButton(targetToolAction);
+        panelDrosFirstLine.add(btnTargetTool);
+        btnTargetTool.setToolTipText("Position the tool at the camera's current location.");
+
+        JPanel panelDrosSecondLine = new JPanel();
+        panelDros.add(panelDrosSecondLine);
+        panelDrosSecondLine.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));
+
+        JLabel lblC = new JLabel("C");
+        lblC.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        panelDrosSecondLine.add(lblC);
+
+        textFieldC = new JTextField();
+        textFieldC.setEditable(false);
+        textFieldC.setFocusTraversalKeysEnabled(false);
+        textFieldC.setSelectionColor(droEditingColor);
+        textFieldC.setDisabledTextColor(Color.BLACK);
+        textFieldC.setBackground(droNormalColor);
+        textFieldC.setText("0000.0000");
+        textFieldC.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        textFieldC.setColumns(6);
         textFieldC.addMouseListener(new MouseAdapter() {
             @Override
             public void mouseClicked(MouseEvent e) {
@@ -386,24 +379,24 @@ public void mouseClicked(MouseEvent e) {
                 saveCAction.actionPerformed(null);
             }
         });
-		panelDrosSecondLine.add(textFieldC);
-		
-		Component horizontalStrut_1 = Box.createHorizontalStrut(15);
-		panelDrosSecondLine.add(horizontalStrut_1);
-		
-		JLabel lblZ = new JLabel("Z");
-		lblZ.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		panelDrosSecondLine.add(lblZ);
-		
-		textFieldZ = new JTextField();
-		textFieldZ.setEditable(false);
-		textFieldZ.setFocusTraversalKeysEnabled(false);
-		textFieldZ.setSelectionColor(droEditingColor);
-		textFieldZ.setDisabledTextColor(Color.BLACK);
-		textFieldZ.setBackground(droNormalColor);
-		textFieldZ.setText("0000.0000");
-		textFieldZ.setFont(new Font("Lucida Grande", Font.BOLD, 24));
-		textFieldZ.setColumns(6);
+        panelDrosSecondLine.add(textFieldC);
+
+        Component horizontalStrut_1 = Box.createHorizontalStrut(15);
+        panelDrosSecondLine.add(horizontalStrut_1);
+
+        JLabel lblZ = new JLabel("Z");
+        lblZ.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        panelDrosSecondLine.add(lblZ);
+
+        textFieldZ = new JTextField();
+        textFieldZ.setEditable(false);
+        textFieldZ.setFocusTraversalKeysEnabled(false);
+        textFieldZ.setSelectionColor(droEditingColor);
+        textFieldZ.setDisabledTextColor(Color.BLACK);
+        textFieldZ.setBackground(droNormalColor);
+        textFieldZ.setText("0000.0000");
+        textFieldZ.setFont(new Font("Lucida Grande", Font.BOLD, 24));
+        textFieldZ.setColumns(6);
         textFieldZ.addMouseListener(new MouseAdapter() {
             @Override
             public void mouseClicked(MouseEvent e) {
@@ -413,96 +406,94 @@ public void mouseClicked(MouseEvent e) {
                 saveZAction.actionPerformed(null);
             }
         });
-		panelDrosSecondLine.add(textFieldZ);
-		
-		JButton btnTargetCamera = new JButton(targetCameraAction);
-		panelDrosSecondLine.add(btnTargetCamera);
-		btnTargetCamera.setToolTipText("Position the camera at the tool's current location.");
-		
-		JPanel panelIncrements = new JPanel();
-		add(panelIncrements);
-		
-		sliderIncrements = new JSlider();
-		panelIncrements.add(sliderIncrements);
-		sliderIncrements.setMajorTickSpacing(1);
-		sliderIncrements.setValue(1);
-		sliderIncrements.setSnapToTicks(true);
-		sliderIncrements.setPaintLabels(true);
-		sliderIncrements.setPaintTicks(true);
-		sliderIncrements.setMinimum(1);
-		sliderIncrements.setMaximum(5);
-		
-		JPanel panelStartStop = new JPanel();
-		add(panelStartStop);
-		panelStartStop.setLayout(new BorderLayout(0, 0));
-		
-		btnStartStop = new JButton(startMachineAction);
-		btnStartStop.setFocusable(true);
-		btnStartStop.setForeground(startColor);
-		panelStartStop.add(btnStartStop);
-		btnStartStop.setFont(new Font("Lucida Grande", Font.BOLD, 48));
-		btnStartStop.setPreferredSize(new Dimension(160, 70));
-		
-		setFocusTraversalPolicy(focusPolicy);
-		setFocusTraversalPolicyProvider(true);
-	}
-	
-	private FocusTraversalPolicy focusPolicy = new FocusTraversalPolicy() {
-		@Override
-		public Component getComponentAfter(Container aContainer,
-				Component aComponent) {
-			return sliderIncrements;
-		}
-
-		@Override
-		public Component getComponentBefore(Container aContainer,
-				Component aComponent) {
-			return sliderIncrements;
-		}
-
-		@Override
-		public Component getDefaultComponent(Container aContainer) {
-			return sliderIncrements;
-		}
-
-		@Override
-		public Component getFirstComponent(Container aContainer) {
-			return sliderIncrements;
-		}
-
-		@Override
-		public Component getInitialComponent(Window window) {
-			return sliderIncrements;
-		}
-
-		@Override
-		public Component getLastComponent(Container aContainer) {
-			return sliderIncrements;
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	private Action stopMachineAction = new AbstractAction("STOP") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			setEnabled(false);
-			new Thread(() -> {
-	            try {
-	                Configuration.get().getMachine().setEnabled(false);
-	                setEnabled(true);
-	            }
-	            catch (Exception t) {
-	                MessageBoxes.errorBox(MachineControlsPanel.this, "Stop Failed", t.getMessage());
-	                setEnabled(true);
-	            }
-			}).start();
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	private Action startMachineAction = new AbstractAction("START") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
+        panelDrosSecondLine.add(textFieldZ);
+
+        JButton btnTargetCamera = new JButton(targetCameraAction);
+        panelDrosSecondLine.add(btnTargetCamera);
+        btnTargetCamera.setToolTipText("Position the camera at the tool's current location.");
+
+        JPanel panelIncrements = new JPanel();
+        add(panelIncrements);
+
+        sliderIncrements = new JSlider();
+        panelIncrements.add(sliderIncrements);
+        sliderIncrements.setMajorTickSpacing(1);
+        sliderIncrements.setValue(1);
+        sliderIncrements.setSnapToTicks(true);
+        sliderIncrements.setPaintLabels(true);
+        sliderIncrements.setPaintTicks(true);
+        sliderIncrements.setMinimum(1);
+        sliderIncrements.setMaximum(5);
+
+        JPanel panelStartStop = new JPanel();
+        add(panelStartStop);
+        panelStartStop.setLayout(new BorderLayout(0, 0));
+
+        btnStartStop = new JButton(startMachineAction);
+        btnStartStop.setFocusable(true);
+        btnStartStop.setForeground(startColor);
+        panelStartStop.add(btnStartStop);
+        btnStartStop.setFont(new Font("Lucida Grande", Font.BOLD, 48));
+        btnStartStop.setPreferredSize(new Dimension(160, 70));
+
+        setFocusTraversalPolicy(focusPolicy);
+        setFocusTraversalPolicyProvider(true);
+    }
+
+    private FocusTraversalPolicy focusPolicy = new FocusTraversalPolicy() {
+        @Override
+        public Component getComponentAfter(Container aContainer, Component aComponent) {
+            return sliderIncrements;
+        }
+
+        @Override
+        public Component getComponentBefore(Container aContainer, Component aComponent) {
+            return sliderIncrements;
+        }
+
+        @Override
+        public Component getDefaultComponent(Container aContainer) {
+            return sliderIncrements;
+        }
+
+        @Override
+        public Component getFirstComponent(Container aContainer) {
+            return sliderIncrements;
+        }
+
+        @Override
+        public Component getInitialComponent(Window window) {
+            return sliderIncrements;
+        }
+
+        @Override
+        public Component getLastComponent(Container aContainer) {
+            return sliderIncrements;
+        }
+    };
+
+    @SuppressWarnings("serial")
+    private Action stopMachineAction = new AbstractAction("STOP") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            setEnabled(false);
+            new Thread(() -> {
+                try {
+                    Configuration.get().getMachine().setEnabled(false);
+                    setEnabled(true);
+                }
+                catch (Exception t) {
+                    MessageBoxes.errorBox(MachineControlsPanel.this, "Stop Failed", t.getMessage());
+                    setEnabled(true);
+                }
+            }).start();
+        }
+    };
+
+    @SuppressWarnings("serial")
+    private Action startMachineAction = new AbstractAction("START") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
             setEnabled(false);
             new Thread(() -> {
                 try {
@@ -510,85 +501,88 @@ public void actionPerformed(ActionEvent arg0) {
                     setEnabled(true);
                 }
                 catch (Exception t) {
-                    MessageBoxes.errorBox(MachineControlsPanel.this, "Start Failed", t.getMessage());
+                    MessageBoxes.errorBox(MachineControlsPanel.this, "Start Failed",
+                            t.getMessage());
                     setEnabled(true);
                 }
             }).start();
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	public Action homeAction = new AbstractAction("Home", Icons.home) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.submitUiMachineTask(() -> {
-				selectedNozzle.getHead().home();
-			});
-		}
-	};
-	
-	public Action showHideJogControlsWindowAction = new AbstractAction("Show Jog Controls") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			if (jogControlsWindow.isVisible()) {
-			    // Hide
-				jogControlsWindow.setVisible(false);
-				putValue(AbstractAction.NAME, "Show Jog Controls");
-			}
-			else {
-			    // Show
-				jogControlsWindow.setVisible(true);
-				jogControlsWindow.pack();
-				int x = (int) getLocationOnScreen().getX();
-				int y = (int) getLocationOnScreen().getY();
-				x += (getSize().getWidth() / 2) - (jogControlsWindow.getSize().getWidth() / 2);
-				y += getSize().getHeight();
-				jogControlsWindow.setLocation(x, y);
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action homeAction = new AbstractAction("Home", Icons.home) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            UiUtils.submitUiMachineTask(() -> {
+                selectedNozzle.getHead().home();
+            });
+        }
+    };
+
+    public Action showHideJogControlsWindowAction = new AbstractAction("Show Jog Controls") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            if (jogControlsWindow.isVisible()) {
+                // Hide
+                jogControlsWindow.setVisible(false);
+                putValue(AbstractAction.NAME, "Show Jog Controls");
+            }
+            else {
+                // Show
+                jogControlsWindow.setVisible(true);
+                jogControlsWindow.pack();
+                int x = (int) getLocationOnScreen().getX();
+                int y = (int) getLocationOnScreen().getY();
+                x += (getSize().getWidth() / 2) - (jogControlsWindow.getSize().getWidth() / 2);
+                y += getSize().getHeight();
+                jogControlsWindow.setLocation(x, y);
                 putValue(AbstractAction.NAME, "Hide Jog Controls");
-			}
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	public Action raiseIncrementAction = new AbstractAction("Raise Jog Increment") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			sliderIncrements.setValue(Math.min(sliderIncrements.getMaximum(), sliderIncrements.getValue() + 1));
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	public Action lowerIncrementAction = new AbstractAction("Lower Jog Increment") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			sliderIncrements.setValue(Math.max(sliderIncrements.getMinimum(), sliderIncrements.getValue() - 1));
-		}
-	};
-	
-	@SuppressWarnings("serial")
-	public Action targetToolAction = new AbstractAction(null, Icons.centerTool) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.submitUiMachineTask(() -> {
-				HeadMountable tool = getSelectedTool();
-				Camera camera = tool.getHead().getDefaultCamera();
-				MovableUtils.moveToLocationAtSafeZ(tool, camera.getLocation(), 1.0);
-			});
-		}
-	};
-	
+            }
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action raiseIncrementAction = new AbstractAction("Raise Jog Increment") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            sliderIncrements.setValue(
+                    Math.min(sliderIncrements.getMaximum(), sliderIncrements.getValue() + 1));
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action lowerIncrementAction = new AbstractAction("Lower Jog Increment") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            sliderIncrements.setValue(
+                    Math.max(sliderIncrements.getMinimum(), sliderIncrements.getValue() - 1));
+        }
+    };
+
+    @SuppressWarnings("serial")
+    public Action targetToolAction = new AbstractAction(null, Icons.centerTool) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            UiUtils.submitUiMachineTask(() -> {
+                HeadMountable tool = getSelectedTool();
+                Camera camera = tool.getHead().getDefaultCamera();
+                MovableUtils.moveToLocationAtSafeZ(tool, camera.getLocation(), 1.0);
+            });
+        }
+    };
+
     @SuppressWarnings("serial")
     public Action targetCameraAction = new AbstractAction(null, Icons.centerCamera) {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-			UiUtils.submitUiMachineTask(() -> {
-				HeadMountable tool = getSelectedTool();
-				Camera camera = tool.getHead().getDefaultCamera();
-				MovableUtils.moveToLocationAtSafeZ(camera, tool.getLocation(), 1.0);
-			});
+            UiUtils.submitUiMachineTask(() -> {
+                HeadMountable tool = getSelectedTool();
+                Camera camera = tool.getHead().getDefaultCamera();
+                MovableUtils.moveToLocationAtSafeZ(camera, tool.getLocation(), 1.0);
+            });
         }
     };
-    
+
     @SuppressWarnings("serial")
     public Action saveXAction = new AbstractAction(null) {
         @Override
@@ -608,7 +602,7 @@ public void run() {
             });
         }
     };
-    
+
     @SuppressWarnings("serial")
     public Action saveYAction = new AbstractAction(null) {
         @Override
@@ -628,7 +622,7 @@ public void run() {
             });
         }
     };
-    
+
     @SuppressWarnings("serial")
     public Action saveZAction = new AbstractAction(null) {
         @Override
@@ -648,7 +642,7 @@ public void run() {
             });
         }
     };
-    
+
     @SuppressWarnings("serial")
     public Action saveCAction = new AbstractAction(null) {
         @Override
@@ -668,71 +662,71 @@ public void run() {
             });
         }
     };
-    
-	private MachineListener machineListener = new MachineListener.Adapter() {
-		@Override
-		public void machineHeadActivity(Machine machine, Head head) {
-			EventQueue.invokeLater(new Runnable() {
-				public void run() {
-					updateDros();
-				}
-			});
-		}
-
-		@Override
-		public void machineEnabled(Machine machine) {
-			btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
-			btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
-			setEnabled(true);
-			EventQueue.invokeLater(new Runnable() {
-				public void run() {
-					updateDros();
-				}
-			});
-		}
-
-		@Override
-		public void machineEnableFailed(Machine machine, String reason) {
-			btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
-			btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
-		}
-
-		@Override
-		public void machineDisabled(Machine machine, String reason) {
-			btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
-			btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
-			setEnabled(false);
-		}
-
-		@Override
-		public void machineDisableFailed(Machine machine, String reason) {
-			btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
-			btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
-		}
-	};
-	
-	private ConfigurationListener configurationListener = new ConfigurationListener.Adapter() {
-		@Override
-		public void configurationComplete(Configuration configuration) {
-		    Machine machine = configuration.getMachine();
-			if (machine != null) {
-				machine.removeListener(machineListener);
-			}
-			
-			for (Head head : machine.getHeads()) {
-	            for (Nozzle nozzle : head.getNozzles()) {
-	                comboBoxNozzles.addItem(new NozzleItem(nozzle));
-	            }
-			}
-			setSelectedNozzle(((NozzleItem) comboBoxNozzles.getItemAt(0)).getNozzle());
-			
-			setUnits(configuration.getSystemUnits());
-			machine.addListener(machineListener);
-			
-			btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
-			btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
-
-			setEnabled(machine.isEnabled());
-		}
-	};
+
+    private MachineListener machineListener = new MachineListener.Adapter() {
+        @Override
+        public void machineHeadActivity(Machine machine, Head head) {
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    updateDros();
+                }
+            });
+        }
+
+        @Override
+        public void machineEnabled(Machine machine) {
+            btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
+            btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
+            setEnabled(true);
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    updateDros();
+                }
+            });
+        }
+
+        @Override
+        public void machineEnableFailed(Machine machine, String reason) {
+            btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
+            btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
+        }
+
+        @Override
+        public void machineDisabled(Machine machine, String reason) {
+            btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
+            btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
+            setEnabled(false);
+        }
+
+        @Override
+        public void machineDisableFailed(Machine machine, String reason) {
+            btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
+            btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
+        }
+    };
+
+    private ConfigurationListener configurationListener = new ConfigurationListener.Adapter() {
+        @Override
+        public void configurationComplete(Configuration configuration) {
+            Machine machine = configuration.getMachine();
+            if (machine != null) {
+                machine.removeListener(machineListener);
+            }
+
+            for (Head head : machine.getHeads()) {
+                for (Nozzle nozzle : head.getNozzles()) {
+                    comboBoxNozzles.addItem(new NozzleItem(nozzle));
+                }
+            }
+            setSelectedNozzle(((NozzleItem) comboBoxNozzles.getItemAt(0)).getNozzle());
+
+            setUnits(configuration.getSystemUnits());
+            machine.addListener(machineListener);
+
+            btnStartStop.setAction(machine.isEnabled() ? stopMachineAction : startMachineAction);
+            btnStartStop.setForeground(machine.isEnabled() ? stopColor : startColor);
+
+            setEnabled(machine.isEnabled());
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/MachineSetupPanel.java b/src/main/java/org/openpnp/gui/MachineSetupPanel.java
index 94df093f6e..887eefdf5b 100755
--- a/src/main/java/org/openpnp/gui/MachineSetupPanel.java
+++ b/src/main/java/org/openpnp/gui/MachineSetupPanel.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
@@ -51,7 +49,6 @@
 import javax.swing.tree.TreeSelectionModel;
 
 import org.openpnp.ConfigurationListener;
-import org.openpnp.gui.support.Icons;
 import org.openpnp.gui.support.Wizard;
 import org.openpnp.gui.support.WizardContainer;
 import org.openpnp.model.Configuration;
@@ -62,88 +59,84 @@
 
 @SuppressWarnings("serial")
 public class MachineSetupPanel extends JPanel implements WizardContainer {
-	private final static Logger logger = LoggerFactory
-			.getLogger(MachineSetupPanel.class);
+    private final static Logger logger = LoggerFactory.getLogger(MachineSetupPanel.class);
 
-	private static final String PREF_DIVIDER_POSITION = "MachineSetupPanel.dividerPosition";
-	private static final int PREF_DIVIDER_POSITION_DEF = -1;
+    private static final String PREF_DIVIDER_POSITION = "MachineSetupPanel.dividerPosition";
+    private static final int PREF_DIVIDER_POSITION_DEF = -1;
 
-	private JTextField searchTextField;
+    private JTextField searchTextField;
 
-	private Preferences prefs = Preferences
-			.userNodeForPackage(MachineSetupPanel.class);
-	private JTree tree;
-	private JTabbedPane tabbedPane;
-	private JToolBar toolBar;
+    private Preferences prefs = Preferences.userNodeForPackage(MachineSetupPanel.class);
+    private JTree tree;
+    private JTabbedPane tabbedPane;
+    private JToolBar toolBar;
 
-	public MachineSetupPanel() {
-		setLayout(new BorderLayout(0, 0));
+    public MachineSetupPanel() {
+        setLayout(new BorderLayout(0, 0));
 
-		JPanel panel = new JPanel();
-		add(panel, BorderLayout.NORTH);
-		panel.setLayout(new BorderLayout(0, 0));
+        JPanel panel = new JPanel();
+        add(panel, BorderLayout.NORTH);
+        panel.setLayout(new BorderLayout(0, 0));
 
-		toolBar = new JToolBar();
-		toolBar.setFloatable(false);
-		panel.add(toolBar, BorderLayout.CENTER);
+        toolBar = new JToolBar();
+        toolBar.setFloatable(false);
+        panel.add(toolBar, BorderLayout.CENTER);
 
-		JPanel panel_1 = new JPanel();
-		panel.add(panel_1, BorderLayout.EAST);
+        JPanel panel_1 = new JPanel();
+        panel.add(panel_1, BorderLayout.EAST);
 
-		JLabel lblSearch = new JLabel("Search");
-		panel_1.add(lblSearch);
+        JLabel lblSearch = new JLabel("Search");
+        panel_1.add(lblSearch);
 
-		searchTextField = new JTextField();
+        searchTextField = new JTextField();
         searchTextField.getDocument().addDocumentListener(new DocumentListener() {
             @Override
             public void removeUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void insertUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void changedUpdate(DocumentEvent e) {
                 search();
             }
         });
-		panel_1.add(searchTextField);
-		searchTextField.setColumns(15);
-
-		final JSplitPane splitPane = new JSplitPane();
-		splitPane.setContinuousLayout(true);
-		splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION,
-				PREF_DIVIDER_POSITION_DEF));
-		splitPane.addPropertyChangeListener("dividerLocation",
-				new PropertyChangeListener() {
-					@Override
-					public void propertyChange(PropertyChangeEvent evt) {
-						prefs.putInt(PREF_DIVIDER_POSITION,
-								splitPane.getDividerLocation());
-					}
-				});
-		add(splitPane, BorderLayout.CENTER);
+        panel_1.add(searchTextField);
+        searchTextField.setColumns(15);
+
+        final JSplitPane splitPane = new JSplitPane();
+        splitPane.setContinuousLayout(true);
+        splitPane
+                .setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
+        splitPane.addPropertyChangeListener("dividerLocation", new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent evt) {
+                prefs.putInt(PREF_DIVIDER_POSITION, splitPane.getDividerLocation());
+            }
+        });
+        add(splitPane, BorderLayout.CENTER);
 
         JScrollPane scrollPane = new JScrollPane();
         splitPane.setLeftComponent(scrollPane);
-        
+
         tree = new JTree();
         tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
         tree.setCellRenderer(treeCellRenderer);
         scrollPane.setViewportView(tree);
-        
+
         tabbedPane = new JTabbedPane(JTabbedPane.TOP);
         splitPane.setRightComponent(tabbedPane);
-        
+
         tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener() {
             @Override
             public void valueChanged(TreeSelectionEvent e) {
                 tabbedPane.removeAll();
                 toolBar.removeAll();
-                
+
                 TreePath path = tree.getSelectionPath();
                 for (Object o : path.getPath()) {
                     PropertySheetHolderTreeNode node = (PropertySheetHolderTreeNode) o;
@@ -157,8 +150,9 @@ public void valueChanged(TreeSelectionEvent e) {
                         }
                     }
                 }
-                
-                PropertySheetHolderTreeNode node = (PropertySheetHolderTreeNode) path.getLastPathComponent();
+
+                PropertySheetHolderTreeNode node =
+                        (PropertySheetHolderTreeNode) path.getLastPathComponent();
                 if (node != null) {
                     PropertySheet[] propertySheets = node.obj.getPropertySheets();
                     if (propertySheets != null) {
@@ -174,45 +168,40 @@ public void valueChanged(TreeSelectionEvent e) {
                         }
                     }
                 }
-                
+
                 revalidate();
                 repaint();
             }
         });
-        
+
         Configuration.get().addListener(new ConfigurationListener() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
-            }
-            
+            public void configurationLoaded(Configuration configuration) throws Exception {}
+
             @Override
-            public void configurationComplete(Configuration configuration)
-                    throws Exception {
-                tree.setModel(new DefaultTreeModel(new PropertySheetHolderTreeNode(Configuration.get().getMachine(), null)));
+            public void configurationComplete(Configuration configuration) throws Exception {
+                tree.setModel(new DefaultTreeModel(
+                        new PropertySheetHolderTreeNode(Configuration.get().getMachine(), null)));
                 for (int i = 0; i < tree.getRowCount(); i++) {
                     tree.expandRow(i);
                 }
             }
         });
-	}
+    }
+
+    private void search() {}
 
-	private void search() {
-	}
+    @Override
+    public void wizardCompleted(Wizard wizard) {}
 
-	@Override
-	public void wizardCompleted(Wizard wizard) {
-	}
+    @Override
+    public void wizardCancelled(Wizard wizard) {}
 
-	@Override
-	public void wizardCancelled(Wizard wizard) {
-	}
-	
     public class PropertySheetHolderTreeNode implements TreeNode {
         private final PropertySheetHolder obj;
         private final TreeNode parent;
         private final ArrayList<PropertySheetHolderTreeNode> children = new ArrayList<>();
-        
+
         public PropertySheetHolderTreeNode(PropertySheetHolder obj, TreeNode parent) {
             this.obj = obj;
             this.parent = parent;
@@ -223,11 +212,11 @@ public PropertySheetHolderTreeNode(PropertySheetHolder obj, TreeNode parent) {
                 }
             }
         }
-        
+
         public PropertySheetHolder getPropertySheetHolder() {
             return obj;
         }
-        
+
         @Override
         public TreeNode getChildAt(int childIndex) {
             return children.get(childIndex);
@@ -268,20 +257,20 @@ public String toString() {
             return obj.getPropertySheetHolderTitle();
         }
     }
-    
+
     private TreeCellRenderer treeCellRenderer = new DefaultTreeCellRenderer() {
         // http://stackoverflow.com/questions/20691946/set-icon-to-each-node-in-jtree
         @Override
-        public Component getTreeCellRendererComponent(JTree tree,
-            Object value, boolean selected, boolean expanded,
-            boolean leaf, int row, boolean hasFocus) {
-                super.getTreeCellRendererComponent(tree, value, selected,expanded, leaf, row, hasFocus);
-                if (value instanceof PropertySheetHolderTreeNode) {
-                    PropertySheetHolderTreeNode node = (PropertySheetHolderTreeNode) value;
-                    PropertySheetHolder psh = node.getPropertySheetHolder();
-                    setIcon(psh.getPropertySheetHolderIcon());
-                }
-                return this;
-        }    
+        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected,
+                boolean expanded, boolean leaf, int row, boolean hasFocus) {
+            super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row,
+                    hasFocus);
+            if (value instanceof PropertySheetHolderTreeNode) {
+                PropertySheetHolderTreeNode node = (PropertySheetHolderTreeNode) value;
+                PropertySheetHolder psh = node.getPropertySheetHolder();
+                setIcon(psh.getPropertySheetHolderIcon());
+            }
+            return this;
+        }
     };
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/MainFrame.java b/src/main/java/org/openpnp/gui/MainFrame.java
index 43d0319ef0..6973cc49ed 100755
--- a/src/main/java/org/openpnp/gui/MainFrame.java
+++ b/src/main/java/org/openpnp/gui/MainFrame.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui;
@@ -79,8 +77,6 @@
 import org.openpnp.gui.support.OSXAdapter;
 import org.openpnp.model.Configuration;
 import org.openpnp.model.LengthUnit;
-import org.openpnp.spi.Camera;
-import org.openpnp.spi.Head;
 import org.openpnp.spi.JobProcessor;
 
 /**
@@ -88,403 +84,377 @@
  */
 @SuppressWarnings("serial")
 public class MainFrame extends JFrame {
-	private static final String PREF_WINDOW_X = "MainFrame.windowX";
-	private static final int PREF_WINDOW_X_DEF = 0;
-	private static final String PREF_WINDOW_Y = "MainFrame.windowY";
-	private static final int PREF_WINDOW_Y_DEF = 0;
-	private static final String PREF_WINDOW_WIDTH = "MainFrame.windowWidth";
-	private static final int PREF_WINDOW_WIDTH_DEF = 1024;
-	private static final String PREF_WINDOW_HEIGHT = "MainFrame.windowHeight";
-	private static final int PREF_WINDOW_HEIGHT_DEF = 768;
-	private static final String PREF_DIVIDER_POSITION = "MainFrame.dividerPosition";
-	private static final int PREF_DIVIDER_POSITION_DEF = -1;
-
-	/*
-	 * TODO define accelerators and mnemonics
-	 * openJobMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,
-	 * Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
-	 */
-	private final Configuration configuration;
-
-	// TODO: Really should switch to some kind of DI model, but this will do
-	// for now.
-	public static MainFrame mainFrame;
-	public static MachineControlsPanel machineControlsPanel;
-	public static PartsPanel partsPanel;
-	public static PackagesPanel packagesPanel;
-	public static FeedersPanel feedersPanel;
-	public static JobPanel jobPanel;
-	public static CamerasPanel camerasPanel;
-	public static CameraPanel cameraPanel;
+    private static final String PREF_WINDOW_X = "MainFrame.windowX";
+    private static final int PREF_WINDOW_X_DEF = 0;
+    private static final String PREF_WINDOW_Y = "MainFrame.windowY";
+    private static final int PREF_WINDOW_Y_DEF = 0;
+    private static final String PREF_WINDOW_WIDTH = "MainFrame.windowWidth";
+    private static final int PREF_WINDOW_WIDTH_DEF = 1024;
+    private static final String PREF_WINDOW_HEIGHT = "MainFrame.windowHeight";
+    private static final int PREF_WINDOW_HEIGHT_DEF = 768;
+    private static final String PREF_DIVIDER_POSITION = "MainFrame.dividerPosition";
+    private static final int PREF_DIVIDER_POSITION_DEF = -1;
+
+    /*
+     * TODO define accelerators and mnemonics
+     * openJobMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,
+     * Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
+     */
+    private final Configuration configuration;
+
+    // TODO: Really should switch to some kind of DI model, but this will do
+    // for now.
+    public static MainFrame mainFrame;
+    public static MachineControlsPanel machineControlsPanel;
+    public static PartsPanel partsPanel;
+    public static PackagesPanel packagesPanel;
+    public static FeedersPanel feedersPanel;
+    public static JobPanel jobPanel;
+    public static CamerasPanel camerasPanel;
+    public static CameraPanel cameraPanel;
     public static MachineSetupPanel machineSetupPanel;
 
-	private JPanel contentPane;
-	private JLabel lblStatus;
-	private JTabbedPane panelBottom;
-	private JSplitPane splitPaneTopBottom;
-	private TitledBorder panelInstructionsBorder;
-
-	private Preferences prefs = Preferences.userNodeForPackage(MainFrame.class);
-	
-	private ActionListener instructionsCancelActionListener;
-	private ActionListener instructionsProceedActionListener;
-	
-	private JMenu mnImport;
-
-	public MainFrame(Configuration configuration) {
-	    mainFrame = this;
-		this.configuration = configuration;
-		LengthCellValue.setConfiguration(configuration);
-		HeadCellValue.setConfiguration(configuration);
-
-		setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
-
-		// Get handlers for Mac application menu in place.
-		boolean macOsXMenus = registerForMacOSXEvents();
-		
-		addWindowListener(new WindowAdapter() {
-			@Override
-			public void windowClosing(WindowEvent e) {
-				quit();
-			}
-		});
-		
+    private JPanel contentPane;
+    private JLabel lblStatus;
+    private JTabbedPane panelBottom;
+    private JSplitPane splitPaneTopBottom;
+    private TitledBorder panelInstructionsBorder;
+
+    private Preferences prefs = Preferences.userNodeForPackage(MainFrame.class);
+
+    private ActionListener instructionsCancelActionListener;
+    private ActionListener instructionsProceedActionListener;
+
+    private JMenu mnImport;
+
+    public MainFrame(Configuration configuration) {
+        mainFrame = this;
+        this.configuration = configuration;
+        LengthCellValue.setConfiguration(configuration);
+        HeadCellValue.setConfiguration(configuration);
+
+        setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
+
+        // Get handlers for Mac application menu in place.
+        boolean macOsXMenus = registerForMacOSXEvents();
+
+        addWindowListener(new WindowAdapter() {
+            @Override
+            public void windowClosing(WindowEvent e) {
+                quit();
+            }
+        });
+
         if (prefs.getInt(PREF_WINDOW_WIDTH, 50) < 50) {
             prefs.putInt(PREF_WINDOW_WIDTH, PREF_WINDOW_WIDTH_DEF);
         }
-        
+
         if (prefs.getInt(PREF_WINDOW_HEIGHT, 50) < 50) {
             prefs.putInt(PREF_WINDOW_HEIGHT, PREF_WINDOW_HEIGHT_DEF);
         }
-		        
-		setBounds(prefs.getInt(PREF_WINDOW_X, PREF_WINDOW_X_DEF),
-				prefs.getInt(PREF_WINDOW_Y, PREF_WINDOW_Y_DEF),
-				prefs.getInt(PREF_WINDOW_WIDTH, PREF_WINDOW_WIDTH_DEF),
-				prefs.getInt(PREF_WINDOW_HEIGHT, PREF_WINDOW_HEIGHT_DEF));
-
-		cameraPanel = new CameraPanel();
-		machineControlsPanel = new MachineControlsPanel(configuration, this,
-				cameraPanel);
-		jobPanel = new JobPanel(configuration, this, machineControlsPanel);
-		partsPanel = new PartsPanel(configuration, this);
-		packagesPanel = new PackagesPanel(configuration, this);
-		feedersPanel = new FeedersPanel(configuration, this);
-		camerasPanel = new CamerasPanel(this, configuration);
+
+        setBounds(prefs.getInt(PREF_WINDOW_X, PREF_WINDOW_X_DEF),
+                prefs.getInt(PREF_WINDOW_Y, PREF_WINDOW_Y_DEF),
+                prefs.getInt(PREF_WINDOW_WIDTH, PREF_WINDOW_WIDTH_DEF),
+                prefs.getInt(PREF_WINDOW_HEIGHT, PREF_WINDOW_HEIGHT_DEF));
+
+        cameraPanel = new CameraPanel();
+        machineControlsPanel = new MachineControlsPanel(configuration, this, cameraPanel);
+        jobPanel = new JobPanel(configuration, this, machineControlsPanel);
+        partsPanel = new PartsPanel(configuration, this);
+        packagesPanel = new PackagesPanel(configuration, this);
+        feedersPanel = new FeedersPanel(configuration, this);
+        camerasPanel = new CamerasPanel(this, configuration);
         machineSetupPanel = new MachineSetupPanel();
 
-		JMenuBar menuBar = new JMenuBar();
-		setJMenuBar(menuBar);
-
-		// File
-		//////////////////////////////////////////////////////////////////////
-		JMenu mnFile = new JMenu("File");
-		menuBar.add(mnFile);
-
-		mnFile.add(new JMenuItem(jobPanel.newJobAction));
-		mnFile.add(new JMenuItem(jobPanel.openJobAction));
-		
-		mnFile.add(jobPanel.mnOpenRecent);
-		
-		mnFile.addSeparator();
-		mnFile.add(new JMenuItem(jobPanel.saveJobAction));
-		mnFile.add(new JMenuItem(jobPanel.saveJobAsAction));
-		
-		
-		// File -> Import
-		//////////////////////////////////////////////////////////////////////
-		mnFile.addSeparator();
-		mnImport = new JMenu("Import Board");
-		mnFile.add(mnImport);
-		
-		
-		if (!macOsXMenus) {
-			mnFile.addSeparator();
-			mnFile.add(new JMenuItem(quitAction));
-		}
-
-		// Edit
-		//////////////////////////////////////////////////////////////////////
-		JMenu mnEdit = new JMenu("Edit");
-		menuBar.add(mnEdit);
-
-		mnEdit.add(new JMenuItem(jobPanel.newBoardAction));
-		mnEdit.add(new JMenuItem(jobPanel.addBoardAction));
-		mnEdit.add(new JMenuItem(jobPanel.removeBoardAction));
-		mnEdit.addSeparator();
-		mnEdit.add(new JMenuItem(jobPanel.captureToolBoardLocationAction));
-
-		// View
-		//////////////////////////////////////////////////////////////////////
-		JMenu mnView = new JMenu("View");
-		menuBar.add(mnView);
-
-		ButtonGroup buttonGroup = new ButtonGroup();
-
-		JMenu mnUnits = new JMenu("System Units");
-		mnView.add(mnUnits);
-
-		JMenuItem menuItem;
-		menuItem = new JCheckBoxMenuItem(inchesUnitSelected);
-		buttonGroup.add(menuItem);
-		if (configuration.getSystemUnits() == LengthUnit.Inches) {
-			menuItem.setSelected(true);
-		}
-		mnUnits.add(menuItem);
-		menuItem = new JCheckBoxMenuItem(millimetersUnitSelected);
-		buttonGroup.add(menuItem);
-		if (configuration.getSystemUnits() == LengthUnit.Millimeters) {
-			menuItem.setSelected(true);
-		}
-		mnUnits.add(menuItem);
-		
-		// Job Control
-		//////////////////////////////////////////////////////////////////////
-		JMenu mnJob = new JMenu("Job Control");
-		menuBar.add(mnJob);
-
-		mnJob.add(new JMenuItem(jobPanel.startPauseResumeJobAction));
-		mnJob.add(new JMenuItem(jobPanel.stepJobAction));
-		mnJob.add(new JMenuItem(jobPanel.stopJobAction));
-
-		// Machine
-		//////////////////////////////////////////////////////////////////////
-		JMenu mnCommands = new JMenu("Machine");
-		menuBar.add(mnCommands);
+        JMenuBar menuBar = new JMenuBar();
+        setJMenuBar(menuBar);
+
+        // File
+        //////////////////////////////////////////////////////////////////////
+        JMenu mnFile = new JMenu("File");
+        menuBar.add(mnFile);
+
+        mnFile.add(new JMenuItem(jobPanel.newJobAction));
+        mnFile.add(new JMenuItem(jobPanel.openJobAction));
+
+        mnFile.add(jobPanel.mnOpenRecent);
+
+        mnFile.addSeparator();
+        mnFile.add(new JMenuItem(jobPanel.saveJobAction));
+        mnFile.add(new JMenuItem(jobPanel.saveJobAsAction));
+
+
+        // File -> Import
+        //////////////////////////////////////////////////////////////////////
+        mnFile.addSeparator();
+        mnImport = new JMenu("Import Board");
+        mnFile.add(mnImport);
+
+
+        if (!macOsXMenus) {
+            mnFile.addSeparator();
+            mnFile.add(new JMenuItem(quitAction));
+        }
+
+        // Edit
+        //////////////////////////////////////////////////////////////////////
+        JMenu mnEdit = new JMenu("Edit");
+        menuBar.add(mnEdit);
+
+        mnEdit.add(new JMenuItem(jobPanel.newBoardAction));
+        mnEdit.add(new JMenuItem(jobPanel.addBoardAction));
+        mnEdit.add(new JMenuItem(jobPanel.removeBoardAction));
+        mnEdit.addSeparator();
+        mnEdit.add(new JMenuItem(jobPanel.captureToolBoardLocationAction));
+
+        // View
+        //////////////////////////////////////////////////////////////////////
+        JMenu mnView = new JMenu("View");
+        menuBar.add(mnView);
+
+        ButtonGroup buttonGroup = new ButtonGroup();
+
+        JMenu mnUnits = new JMenu("System Units");
+        mnView.add(mnUnits);
+
+        JMenuItem menuItem;
+        menuItem = new JCheckBoxMenuItem(inchesUnitSelected);
+        buttonGroup.add(menuItem);
+        if (configuration.getSystemUnits() == LengthUnit.Inches) {
+            menuItem.setSelected(true);
+        }
+        mnUnits.add(menuItem);
+        menuItem = new JCheckBoxMenuItem(millimetersUnitSelected);
+        buttonGroup.add(menuItem);
+        if (configuration.getSystemUnits() == LengthUnit.Millimeters) {
+            menuItem.setSelected(true);
+        }
+        mnUnits.add(menuItem);
+
+        // Job Control
+        //////////////////////////////////////////////////////////////////////
+        JMenu mnJob = new JMenu("Job Control");
+        menuBar.add(mnJob);
+
+        mnJob.add(new JMenuItem(jobPanel.startPauseResumeJobAction));
+        mnJob.add(new JMenuItem(jobPanel.stepJobAction));
+        mnJob.add(new JMenuItem(jobPanel.stopJobAction));
+
+        // Machine
+        //////////////////////////////////////////////////////////////////////
+        JMenu mnCommands = new JMenu("Machine");
+        menuBar.add(mnCommands);
 
         mnCommands.add(new JMenuItem(machineControlsPanel.homeAction));
         mnCommands.add(new JMenuItem(machineControlsPanel.showHideJogControlsWindowAction));
-		
-		// Help
-		/////////////////////////////////////////////////////////////////////
-		if (!macOsXMenus) {
-			JMenu mnHelp = new JMenu("Help");
-			menuBar.add(mnHelp);
-			
-			mnHelp.add(new JMenuItem(aboutAction));
-		}
-
-		contentPane = new JPanel();
-		contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
-		setContentPane(contentPane);
-		contentPane.setLayout(new BorderLayout(0, 0));
-
-		splitPaneTopBottom = new JSplitPane();
-		splitPaneTopBottom.setBorder(null);
-		splitPaneTopBottom.setOrientation(JSplitPane.VERTICAL_SPLIT);
-		splitPaneTopBottom.setContinuousLayout(true);
-		contentPane.add(splitPaneTopBottom, BorderLayout.CENTER);
-
-		JPanel panelTop = new JPanel();
-		splitPaneTopBottom.setLeftComponent(panelTop);
-		panelTop.setLayout(new BorderLayout(0, 0));
-
-		JPanel panelLeftColumn = new JPanel();
-		panelTop.add(panelLeftColumn, BorderLayout.WEST);
-		FlowLayout flowLayout = (FlowLayout) panelLeftColumn.getLayout();
-		flowLayout.setVgap(0);
-		flowLayout.setHgap(0);
-
-		JPanel panel = new JPanel();
-		panelLeftColumn.add(panel);
-		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
-
-		machineControlsPanel.setBorder(new TitledBorder(null,
-				"Machine Controls", TitledBorder.LEADING, TitledBorder.TOP,
-				null, null));
-
-		panel.add(machineControlsPanel);
-
-		// Add global hotkeys for the arrow keys
-		final Map<KeyStroke, Action> hotkeyActionMap = new HashMap<>();
-
-		int mask = KeyEvent.CTRL_DOWN_MASK;
-		
-		hotkeyActionMap
-				.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP,
-						mask), machineControlsPanel
-						.getJogControlsPanel().yPlusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN,
-				mask), machineControlsPanel
-				.getJogControlsPanel().yMinusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT,
-				mask), machineControlsPanel
-				.getJogControlsPanel().xMinusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT,
-				mask), machineControlsPanel
-				.getJogControlsPanel().xPlusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_QUOTE,
-				mask), machineControlsPanel
-				.getJogControlsPanel().zPlusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SLASH,
-				mask), machineControlsPanel
-				.getJogControlsPanel().zMinusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_COMMA,
-				mask), machineControlsPanel
-				.getJogControlsPanel().cPlusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD,
-				mask), machineControlsPanel
-				.getJogControlsPanel().cMinusAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS,
-				mask),
-				machineControlsPanel.lowerIncrementAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS,
-				mask),
-				machineControlsPanel.raiseIncrementAction);
-		hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
-				mask),
-				machineControlsPanel.showHideJogControlsWindowAction);
-
-		Toolkit.getDefaultToolkit().getSystemEventQueue()
-				.push(new EventQueue() {
-					@Override
-					protected void dispatchEvent(AWTEvent event) {
-						if (event instanceof KeyEvent) {
-							KeyStroke ks = KeyStroke
-									.getKeyStrokeForEvent((KeyEvent) event);
-							Action action = hotkeyActionMap.get(ks);
-							if (action != null && action.isEnabled()) {
-								action.actionPerformed(null);
-								return;
-							}
-						}
-						super.dispatchEvent(event);
-					}
-				});
-		
-		JPanel panelCameraAndInstructions = new JPanel(new BorderLayout());
-		panelCameraAndInstructions.add(cameraPanel, BorderLayout.CENTER);
-
-		panelTop.add(panelCameraAndInstructions, BorderLayout.CENTER);
-		cameraPanel.setBorder(new TitledBorder(null, "Cameras",
-				TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		
-		panelInstructions = new JPanel();
-		panelInstructions.setVisible(false);
-		panelInstructions.setBorder(panelInstructionsBorder = new TitledBorder(null, "Instructions", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		panelCameraAndInstructions.add(panelInstructions, BorderLayout.SOUTH);
-		panelInstructions.setLayout(new BorderLayout(0, 0));
-		
-		panelInstructionActions = new JPanel();
-		panelInstructionActions.setAlignmentY(Component.BOTTOM_ALIGNMENT);
-		panelInstructions.add(panelInstructionActions, BorderLayout.EAST);
-		panelInstructionActions.setLayout(new BorderLayout(0, 0));
-		
-		panel_2 = new JPanel();
-		FlowLayout flowLayout_2 = (FlowLayout) panel_2.getLayout();
-		flowLayout_2.setVgap(0);
-		flowLayout_2.setHgap(0);
-		panelInstructionActions.add(panel_2, BorderLayout.SOUTH);
-		
-		btnInstructionsCancel = new JButton("Cancel");
-		btnInstructionsCancel.addActionListener(new ActionListener() {
-			public void actionPerformed(ActionEvent arg0) {
-				if (instructionsCancelActionListener != null) {
-					instructionsCancelActionListener.actionPerformed(arg0);
-				}
-			}
-		});
-		panel_2.add(btnInstructionsCancel);
-		
-		btnInstructionsNext = new JButton("Next");
-		btnInstructionsNext.addActionListener(new ActionListener() {
-			public void actionPerformed(ActionEvent arg0) {
-				if (instructionsProceedActionListener != null) {
-					instructionsProceedActionListener.actionPerformed(arg0);
-				}
-			}
-		});
-		panel_2.add(btnInstructionsNext);
-		
-		panel_1 = new JPanel();
-		panelInstructions.add(panel_1, BorderLayout.CENTER);
-		panel_1.setLayout(new BorderLayout(0, 0));
-		
-		lblInstructions = new JTextPane();
-		lblInstructions.setFont(new Font("Lucida Grande", Font.PLAIN, 14));
-		lblInstructions.setBackground(UIManager.getColor("Panel.background"));
-		lblInstructions.setContentType("text/html");
-		lblInstructions.setEditable(false);
-		panel_1.add(lblInstructions);
-
-		panelBottom = new JTabbedPane(JTabbedPane.TOP);
-		splitPaneTopBottom.setRightComponent(panelBottom);
-
-		lblStatus = new JLabel(" ");
-		lblStatus.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null,
-				null, null));
-		contentPane.add(lblStatus, BorderLayout.SOUTH);
-
-		splitPaneTopBottom.setDividerLocation(prefs.getInt(
-				PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
-		splitPaneTopBottom.addPropertyChangeListener("dividerLocation",
-				new PropertyChangeListener() {
-					@Override
-					public void propertyChange(PropertyChangeEvent evt) {
-						prefs.putInt(PREF_DIVIDER_POSITION,
-								splitPaneTopBottom.getDividerLocation());
-					}
-				});
-
-		panelBottom.addTab("Job", null, jobPanel, null);
-		panelBottom.addTab("Parts", null, partsPanel, null);
-		panelBottom.addTab("Packages", null, packagesPanel, null);
-		panelBottom.addTab("Feeders", null, feedersPanel, null);
-		panelBottom.addTab("Cameras", null, camerasPanel, null);
-        panelBottom.addTab("Machine Setup", null, machineSetupPanel, null);
 
-		registerBoardImporters();
-
-		addComponentListener(componentListener);
-
-		try {
-			configuration.load();
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			MessageBoxes
-					.errorBox(
-							this,
-							"Configuration Load Error",
-							"There was a problem loading the configuration. The reason was:<br/><br/>"
-									+ e.getMessage() + "<br/><br/>"
-									+ "Please check your configuration files and try again. They are located at: " 
-									+ configuration.getConfigurationDirectory().getAbsolutePath() + "<br/><br/>"
-									+ "If you would like to start with a fresh configuration, just delete the entire directory at the location above.<br/><br/>"
-									+ "OpenPnP will now exit.");
-			System.exit(1);
-		}
-
-        for (Head head : Configuration.get().getMachine().getHeads()) {
-            for (Camera camera : head.getCameras()) {
-                cameraPanel.addCamera(camera);
+        // Help
+        /////////////////////////////////////////////////////////////////////
+        if (!macOsXMenus) {
+            JMenu mnHelp = new JMenu("Help");
+            menuBar.add(mnHelp);
+
+            mnHelp.add(new JMenuItem(aboutAction));
+        }
+
+        contentPane = new JPanel();
+        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
+        setContentPane(contentPane);
+        contentPane.setLayout(new BorderLayout(0, 0));
+
+        splitPaneTopBottom = new JSplitPane();
+        splitPaneTopBottom.setBorder(null);
+        splitPaneTopBottom.setOrientation(JSplitPane.VERTICAL_SPLIT);
+        splitPaneTopBottom.setContinuousLayout(true);
+        contentPane.add(splitPaneTopBottom, BorderLayout.CENTER);
+
+        JPanel panelTop = new JPanel();
+        splitPaneTopBottom.setLeftComponent(panelTop);
+        panelTop.setLayout(new BorderLayout(0, 0));
+
+        JPanel panelLeftColumn = new JPanel();
+        panelTop.add(panelLeftColumn, BorderLayout.WEST);
+        FlowLayout flowLayout = (FlowLayout) panelLeftColumn.getLayout();
+        flowLayout.setVgap(0);
+        flowLayout.setHgap(0);
+
+        JPanel panel = new JPanel();
+        panelLeftColumn.add(panel);
+        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
+
+        machineControlsPanel.setBorder(new TitledBorder(null, "Machine Controls",
+                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+
+        panel.add(machineControlsPanel);
+
+        // Add global hotkeys for the arrow keys
+        final Map<KeyStroke, Action> hotkeyActionMap = new HashMap<>();
+
+        int mask = KeyEvent.CTRL_DOWN_MASK;
+
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, mask),
+                machineControlsPanel.getJogControlsPanel().yPlusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, mask),
+                machineControlsPanel.getJogControlsPanel().yMinusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, mask),
+                machineControlsPanel.getJogControlsPanel().xMinusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, mask),
+                machineControlsPanel.getJogControlsPanel().xPlusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_QUOTE, mask),
+                machineControlsPanel.getJogControlsPanel().zPlusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_SLASH, mask),
+                machineControlsPanel.getJogControlsPanel().zMinusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_COMMA, mask),
+                machineControlsPanel.getJogControlsPanel().cPlusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD, mask),
+                machineControlsPanel.getJogControlsPanel().cMinusAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, mask),
+                machineControlsPanel.lowerIncrementAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_EQUALS, mask),
+                machineControlsPanel.raiseIncrementAction);
+        hotkeyActionMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, mask),
+                machineControlsPanel.showHideJogControlsWindowAction);
+
+        Toolkit.getDefaultToolkit().getSystemEventQueue().push(new EventQueue() {
+            @Override
+            protected void dispatchEvent(AWTEvent event) {
+                if (event instanceof KeyEvent) {
+                    KeyStroke ks = KeyStroke.getKeyStrokeForEvent((KeyEvent) event);
+                    Action action = hotkeyActionMap.get(ks);
+                    if (action != null && action.isEnabled()) {
+                        action.actionPerformed(null);
+                        return;
+                    }
+                }
+                super.dispatchEvent(event);
+            }
+        });
+
+        JPanel panelCameraAndInstructions = new JPanel(new BorderLayout());
+        panelCameraAndInstructions.add(cameraPanel, BorderLayout.CENTER);
+
+        panelTop.add(panelCameraAndInstructions, BorderLayout.CENTER);
+        cameraPanel.setBorder(new TitledBorder(null, "Cameras", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+
+        panelInstructions = new JPanel();
+        panelInstructions.setVisible(false);
+        panelInstructions.setBorder(panelInstructionsBorder = new TitledBorder(null, "Instructions",
+                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelCameraAndInstructions.add(panelInstructions, BorderLayout.SOUTH);
+        panelInstructions.setLayout(new BorderLayout(0, 0));
+
+        panelInstructionActions = new JPanel();
+        panelInstructionActions.setAlignmentY(Component.BOTTOM_ALIGNMENT);
+        panelInstructions.add(panelInstructionActions, BorderLayout.EAST);
+        panelInstructionActions.setLayout(new BorderLayout(0, 0));
+
+        panel_2 = new JPanel();
+        FlowLayout flowLayout_2 = (FlowLayout) panel_2.getLayout();
+        flowLayout_2.setVgap(0);
+        flowLayout_2.setHgap(0);
+        panelInstructionActions.add(panel_2, BorderLayout.SOUTH);
+
+        btnInstructionsCancel = new JButton("Cancel");
+        btnInstructionsCancel.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent arg0) {
+                if (instructionsCancelActionListener != null) {
+                    instructionsCancelActionListener.actionPerformed(arg0);
+                }
+            }
+        });
+        panel_2.add(btnInstructionsCancel);
+
+        btnInstructionsNext = new JButton("Next");
+        btnInstructionsNext.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent arg0) {
+                if (instructionsProceedActionListener != null) {
+                    instructionsProceedActionListener.actionPerformed(arg0);
+                }
             }
+        });
+        panel_2.add(btnInstructionsNext);
+
+        panel_1 = new JPanel();
+        panelInstructions.add(panel_1, BorderLayout.CENTER);
+        panel_1.setLayout(new BorderLayout(0, 0));
+
+        lblInstructions = new JTextPane();
+        lblInstructions.setFont(new Font("Lucida Grande", Font.PLAIN, 14));
+        lblInstructions.setBackground(UIManager.getColor("Panel.background"));
+        lblInstructions.setContentType("text/html");
+        lblInstructions.setEditable(false);
+        panel_1.add(lblInstructions);
+
+        panelBottom = new JTabbedPane(JTabbedPane.TOP);
+        splitPaneTopBottom.setRightComponent(panelBottom);
+
+        lblStatus = new JLabel(" ");
+        lblStatus.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
+        contentPane.add(lblStatus, BorderLayout.SOUTH);
+
+        splitPaneTopBottom
+                .setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION, PREF_DIVIDER_POSITION_DEF));
+        splitPaneTopBottom.addPropertyChangeListener("dividerLocation",
+                new PropertyChangeListener() {
+                    @Override
+                    public void propertyChange(PropertyChangeEvent evt) {
+                        prefs.putInt(PREF_DIVIDER_POSITION,
+                                splitPaneTopBottom.getDividerLocation());
+                    }
+                });
+
+        panelBottom.addTab("Job", null, jobPanel, null);
+        panelBottom.addTab("Parts", null, partsPanel, null);
+        panelBottom.addTab("Packages", null, packagesPanel, null);
+        panelBottom.addTab("Feeders", null, feedersPanel, null);
+        panelBottom.addTab("Cameras", null, camerasPanel, null);
+        panelBottom.addTab("Machine Setup", null, machineSetupPanel, null);
+
+        registerBoardImporters();
+
+        addComponentListener(componentListener);
+
+        try {
+            configuration.load();
         }
-        for (Camera camera : configuration.getMachine().getCameras()) {
-            cameraPanel.addCamera(camera);
+        catch (Exception e) {
+            e.printStackTrace();
+            MessageBoxes.errorBox(this, "Configuration Load Error",
+                    "There was a problem loading the configuration. The reason was:<br/><br/>"
+                            + e.getMessage() + "<br/><br/>"
+                            + "Please check your configuration files and try again. They are located at: "
+                            + configuration.getConfigurationDirectory().getAbsolutePath()
+                            + "<br/><br/>"
+                            + "If you would like to start with a fresh configuration, just delete the entire directory at the location above.<br/><br/>"
+                            + "OpenPnP will now exit.");
+            System.exit(1);
         }
 
-		configuration.addListener(new ConfigurationListener.Adapter() {
-		    @Override
-            public void configurationComplete(Configuration configuration)
-                    throws Exception {
-		        for (JobProcessor jobProcessor : configuration.getMachine().getJobProcessors().values()) {
-	                jobProcessor.addListener(jobProcessorListener);
-		        }
+        configuration.addListener(new ConfigurationListener.Adapter() {
+            @Override
+            public void configurationComplete(Configuration configuration) throws Exception {
+                for (JobProcessor jobProcessor : configuration.getMachine().getJobProcessors()
+                        .values()) {
+                    jobProcessor.addListener(jobProcessorListener);
+                }
             }
-		});
-	}
-	
-	private void registerBoardImporters() {
+        });
+    }
+
+    private void registerBoardImporters() {
         registerBoardImporter(EagleBoardImporter.class);
         registerBoardImporter(EagleMountsmdUlpImporter.class);
         registerBoardImporter(KicadPosImporter.class);
         registerBoardImporter(NamedCSVImporter.class);
         registerBoardImporter(SolderPasteGerberImporter.class);
-	}
-	
+    }
+
     /**
-     * Register a BoardImporter with the system, causing it to gain a menu
-     * location in the File->Import menu.
+     * Register a BoardImporter with the system, causing it to gain a menu location in the
+     * File->Import menu.
+     * 
      * @param importer
      */
     public void registerBoardImporter(final Class<? extends BoardImporter> boardImporterClass) {
@@ -500,7 +470,7 @@ public void registerBoardImporter(final Class<? extends BoardImporter> boardImpo
                 putValue(NAME, boardImporter.getImporterName());
                 putValue(SHORT_DESCRIPTION, boardImporter.getImporterDescription());
             }
-            
+
             @Override
             public void actionPerformed(ActionEvent e) {
                 jobPanel.importBoard(boardImporterClass);
@@ -508,97 +478,88 @@ public void actionPerformed(ActionEvent e) {
         });
         mnImport.add(menuItem);
     }
-    
-	public void showInstructions(
-			String title,
-			String instructions, 
-			boolean showCancelButton, 
-			boolean showProceedButton, 
-			String proceedButtonText,
-			ActionListener cancelActionListener,
-			ActionListener proceedActionListener) {
-		panelInstructionsBorder.setTitle(title);
-		lblInstructions.setText(instructions);
-		btnInstructionsCancel.setVisible(showCancelButton);
-		btnInstructionsNext.setVisible(showProceedButton);
-		btnInstructionsNext.setText(proceedButtonText);
-		instructionsCancelActionListener = cancelActionListener;
-		instructionsProceedActionListener = proceedActionListener;
-		panelInstructions.setVisible(true);
-		doLayout();
-		panelInstructions.repaint();
-	}
-	
-	public void hideInstructions() {
-		panelInstructions.setVisible(false);
-		doLayout();
-	}
-
-	public boolean registerForMacOSXEvents() {
-		if ((System.getProperty("os.name").toLowerCase().startsWith("mac os x"))) {
-			try {
-				// Generate and register the OSXAdapter, passing it a hash of
-				// all the methods we wish to
-				// use as delegates for various
-				// com.apple.eawt.ApplicationListener methods
-				OSXAdapter.setQuitHandler(this,
-						getClass().getDeclaredMethod("quit", (Class[]) null));
-				OSXAdapter.setAboutHandler(this,
-						getClass().getDeclaredMethod("about", (Class[]) null));
-				// OSXAdapter.setPreferencesHandler(this, getClass()
-				// .getDeclaredMethod("preferences", (Class[]) null));
-				// OSXAdapter.setFileHandler(
-				// this,
-				// getClass().getDeclaredMethod("loadImageFile",
-				// new Class[] { String.class }));
-			}
-			catch (Exception e) {
-				System.err.println("Error while loading the OSXAdapter:");
-				e.printStackTrace();
-			}
-			return true;
-		}
-		return false;
-	}
-
-	public void about() {
-		AboutDialog dialog = new AboutDialog(this);
-		dialog.setSize(350, 350);
-		dialog.setLocationRelativeTo(null);
-		dialog.setVisible(true);		
-	}
-
-	public boolean quit() {
-		try {
-			Preferences.userRoot().flush();
-		}
-		catch (Exception e) {
-
-		}
-
-		// Save the configuration
-		try {
-			configuration.save();
-		}
-		catch (Exception e) {
+
+    public void showInstructions(String title, String instructions, boolean showCancelButton,
+            boolean showProceedButton, String proceedButtonText,
+            ActionListener cancelActionListener, ActionListener proceedActionListener) {
+        panelInstructionsBorder.setTitle(title);
+        lblInstructions.setText(instructions);
+        btnInstructionsCancel.setVisible(showCancelButton);
+        btnInstructionsNext.setVisible(showProceedButton);
+        btnInstructionsNext.setText(proceedButtonText);
+        instructionsCancelActionListener = cancelActionListener;
+        instructionsProceedActionListener = proceedActionListener;
+        panelInstructions.setVisible(true);
+        doLayout();
+        panelInstructions.repaint();
+    }
+
+    public void hideInstructions() {
+        panelInstructions.setVisible(false);
+        doLayout();
+    }
+
+    public boolean registerForMacOSXEvents() {
+        if ((System.getProperty("os.name").toLowerCase().startsWith("mac os x"))) {
+            try {
+                // Generate and register the OSXAdapter, passing it a hash of
+                // all the methods we wish to
+                // use as delegates for various
+                // com.apple.eawt.ApplicationListener methods
+                OSXAdapter.setQuitHandler(this,
+                        getClass().getDeclaredMethod("quit", (Class[]) null));
+                OSXAdapter.setAboutHandler(this,
+                        getClass().getDeclaredMethod("about", (Class[]) null));
+                // OSXAdapter.setPreferencesHandler(this, getClass()
+                // .getDeclaredMethod("preferences", (Class[]) null));
+                // OSXAdapter.setFileHandler(
+                // this,
+                // getClass().getDeclaredMethod("loadImageFile",
+                // new Class[] { String.class }));
+            }
+            catch (Exception e) {
+                System.err.println("Error while loading the OSXAdapter:");
+                e.printStackTrace();
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public void about() {
+        AboutDialog dialog = new AboutDialog(this);
+        dialog.setSize(350, 350);
+        dialog.setLocationRelativeTo(null);
+        dialog.setVisible(true);
+    }
+
+    public boolean quit() {
+        try {
+            Preferences.userRoot().flush();
+        }
+        catch (Exception e) {
+
+        }
+
+        // Save the configuration
+        try {
+            configuration.save();
+        }
+        catch (Exception e) {
             String message = "There was a problem saving the configuration. The reason was:\n\n"
-                    + e.getMessage()
-                    + "\n\nDo you want to quit without saving?";
-             message = message.replaceAll("\n", "<br/>");
-             message = message.replaceAll("\r", "");
-             message = "<html><body width=\"400\">" + message + "</body></html>";
-             int result = JOptionPane.showConfirmDialog(
-                     this, 
-                     message, 
-                     "Configuration Save Error", 
-                     JOptionPane.YES_NO_OPTION);
-             if (result != JOptionPane.YES_OPTION) {
-                 return false;
-             }
-		}
-		if (!jobPanel.checkForModifications()) {
-			return false;
-		}
+                    + e.getMessage() + "\n\nDo you want to quit without saving?";
+            message = message.replaceAll("\n", "<br/>");
+            message = message.replaceAll("\r", "");
+            message = "<html><body width=\"400\">" + message + "</body></html>";
+            int result = JOptionPane.showConfirmDialog(this, message, "Configuration Save Error",
+                    JOptionPane.YES_NO_OPTION);
+            if (result != JOptionPane.YES_OPTION) {
+                return false;
+            }
+        }
+        if (!jobPanel.checkForModifications()) {
+            return false;
+        }
         // Attempt to stop the machine on quit
         try {
             configuration.getMachine().setEnabled(false);
@@ -613,75 +574,73 @@ public boolean quit() {
         catch (Exception e) {
             e.printStackTrace();
         }
-		System.exit(0);
-		return true;
-	}
-	
-	public void showTab(String title) {
-	    int index = panelBottom.indexOfTab(title);
-	    panelBottom.setSelectedIndex(index);
-	}
-
-	private JobProcessorListener jobProcessorListener = new JobProcessorListener.Adapter() {
-		@Override
-		public void detailedStatusUpdated(String status) {
-			lblStatus.setText(status);
-		}
-	};
-
-	private ComponentListener componentListener = new ComponentAdapter() {
-		@Override
-		public void componentMoved(ComponentEvent e) {
-			prefs.putInt(PREF_WINDOW_X, getLocation().x);
-			prefs.putInt(PREF_WINDOW_Y, getLocation().y);
-		}
-
-		@Override
-		public void componentResized(ComponentEvent e) {
-			prefs.putInt(PREF_WINDOW_WIDTH, getSize().width);
-			prefs.putInt(PREF_WINDOW_HEIGHT, getSize().height);
-		}
-	};
-
-	private Action inchesUnitSelected = new AbstractAction(
-			LengthUnit.Inches.name()) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			configuration.setSystemUnits(LengthUnit.Inches);
-			MessageBoxes.errorBox(MainFrame.this, "Notice",
-					"Please restart OpenPnP for the changes to take effect.");
-		}
-	};
-
-	private Action millimetersUnitSelected = new AbstractAction(
-			LengthUnit.Millimeters.name()) {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			configuration.setSystemUnits(LengthUnit.Millimeters);
-			MessageBoxes.errorBox(MainFrame.this, "Notice",
-					"Please restart OpenPnP for the changes to take effect.");
-		}
-	};
-	
-	private Action quitAction = new AbstractAction("Exit") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			quit();
-		}
-	};
-	
-	private Action aboutAction = new AbstractAction("About") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			about();
-		}
-	};
-	
-	private JPanel panelInstructions;
-	private JPanel panelInstructionActions;
-	private JPanel panel_1;
-	private JButton btnInstructionsNext;
-	private JButton btnInstructionsCancel;
-	private JTextPane lblInstructions;
-	private JPanel panel_2;
+        System.exit(0);
+        return true;
+    }
+
+    public void showTab(String title) {
+        int index = panelBottom.indexOfTab(title);
+        panelBottom.setSelectedIndex(index);
+    }
+
+    private JobProcessorListener jobProcessorListener = new JobProcessorListener.Adapter() {
+        @Override
+        public void detailedStatusUpdated(String status) {
+            lblStatus.setText(status);
+        }
+    };
+
+    private ComponentListener componentListener = new ComponentAdapter() {
+        @Override
+        public void componentMoved(ComponentEvent e) {
+            prefs.putInt(PREF_WINDOW_X, getLocation().x);
+            prefs.putInt(PREF_WINDOW_Y, getLocation().y);
+        }
+
+        @Override
+        public void componentResized(ComponentEvent e) {
+            prefs.putInt(PREF_WINDOW_WIDTH, getSize().width);
+            prefs.putInt(PREF_WINDOW_HEIGHT, getSize().height);
+        }
+    };
+
+    private Action inchesUnitSelected = new AbstractAction(LengthUnit.Inches.name()) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            configuration.setSystemUnits(LengthUnit.Inches);
+            MessageBoxes.errorBox(MainFrame.this, "Notice",
+                    "Please restart OpenPnP for the changes to take effect.");
+        }
+    };
+
+    private Action millimetersUnitSelected = new AbstractAction(LengthUnit.Millimeters.name()) {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            configuration.setSystemUnits(LengthUnit.Millimeters);
+            MessageBoxes.errorBox(MainFrame.this, "Notice",
+                    "Please restart OpenPnP for the changes to take effect.");
+        }
+    };
+
+    private Action quitAction = new AbstractAction("Exit") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            quit();
+        }
+    };
+
+    private Action aboutAction = new AbstractAction("About") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            about();
+        }
+    };
+
+    private JPanel panelInstructions;
+    private JPanel panelInstructionActions;
+    private JPanel panel_1;
+    private JButton btnInstructionsNext;
+    private JButton btnInstructionsCancel;
+    private JTextPane lblInstructions;
+    private JPanel panel_2;
 }
diff --git a/src/main/java/org/openpnp/gui/PackagesPanel.java b/src/main/java/org/openpnp/gui/PackagesPanel.java
index 1a9b14ed92..967e0685ab 100755
--- a/src/main/java/org/openpnp/gui/PackagesPanel.java
+++ b/src/main/java/org/openpnp/gui/PackagesPanel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is package of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is package of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui;
 
@@ -73,222 +71,225 @@
 
 @SuppressWarnings("serial")
 public class PackagesPanel extends JPanel {
-	private final static Logger logger = LoggerFactory.getLogger(PackagesPanel.class);
-
-	private static final String PREF_DIVIDER_POSITION = "PackagesPanel.dividerPosition";
-	private static final int PREF_DIVIDER_POSITION_DEF = -1;
-
-	final private Configuration configuration;
-	final private Frame frame;
-	
-	private PackagesTableModel packagesTableModel;
-	private TableRowSorter<PackagesTableModel> packagesTableSorter;
-	private JTextField searchTextField;
-	private JTable packagesTable;
-	private ActionGroup packageSelectedActionGroup;
-
-	private Preferences prefs = Preferences.userNodeForPackage(PackagesPanel.class);
-
-	public PackagesPanel(Configuration configuration, Frame frame) {
-		this.configuration = configuration;
-		this.frame = frame;
-		
-		setLayout(new BorderLayout(0, 0));
-		packagesTableModel = new PackagesTableModel(configuration);
-		packagesTableSorter = new TableRowSorter<>(packagesTableModel);
-
-		JPanel toolbarAndSearch = new JPanel();
-		add(toolbarAndSearch, BorderLayout.NORTH);
-		toolbarAndSearch.setLayout(new BorderLayout(0, 0));
-
-		JToolBar toolBar = new JToolBar();
-		toolBar.setFloatable(false);
-		toolbarAndSearch.add(toolBar);
-
-		JPanel panel_1 = new JPanel();
-		toolbarAndSearch.add(panel_1, BorderLayout.EAST);
-
-		JLabel lblSearch = new JLabel("Search");
-		panel_1.add(lblSearch);
-
-		searchTextField = new JTextField();
-		searchTextField.getDocument().addDocumentListener(new DocumentListener() {
+    private final static Logger logger = LoggerFactory.getLogger(PackagesPanel.class);
+
+    private static final String PREF_DIVIDER_POSITION = "PackagesPanel.dividerPosition";
+    private static final int PREF_DIVIDER_POSITION_DEF = -1;
+
+    final private Configuration configuration;
+    final private Frame frame;
+
+    private PackagesTableModel packagesTableModel;
+    private TableRowSorter<PackagesTableModel> packagesTableSorter;
+    private JTextField searchTextField;
+    private JTable packagesTable;
+    private ActionGroup packageSelectedActionGroup;
+
+    private Preferences prefs = Preferences.userNodeForPackage(PackagesPanel.class);
+
+    public PackagesPanel(Configuration configuration, Frame frame) {
+        this.configuration = configuration;
+        this.frame = frame;
+
+        setLayout(new BorderLayout(0, 0));
+        packagesTableModel = new PackagesTableModel(configuration);
+        packagesTableSorter = new TableRowSorter<>(packagesTableModel);
+
+        JPanel toolbarAndSearch = new JPanel();
+        add(toolbarAndSearch, BorderLayout.NORTH);
+        toolbarAndSearch.setLayout(new BorderLayout(0, 0));
+
+        JToolBar toolBar = new JToolBar();
+        toolBar.setFloatable(false);
+        toolbarAndSearch.add(toolBar);
+
+        JPanel panel_1 = new JPanel();
+        toolbarAndSearch.add(panel_1, BorderLayout.EAST);
+
+        JLabel lblSearch = new JLabel("Search");
+        panel_1.add(lblSearch);
+
+        searchTextField = new JTextField();
+        searchTextField.getDocument().addDocumentListener(new DocumentListener() {
             @Override
             public void removeUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void insertUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void changedUpdate(DocumentEvent e) {
                 search();
             }
         });
-		panel_1.add(searchTextField);
-		searchTextField.setColumns(15);
-		    
-		JSplitPane splitPane = new JSplitPane();
+        panel_1.add(searchTextField);
+        searchTextField.setColumns(15);
+
+        JSplitPane splitPane = new JSplitPane();
         splitPane.setContinuousLayout(true);
-//        splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION,
-//                PREF_DIVIDER_POSITION_DEF));
-        splitPane.addPropertyChangeListener("dividerLocation",
-                new PropertyChangeListener() {
-                    @Override
-                    public void propertyChange(PropertyChangeEvent evt) {
-                        prefs.putInt(PREF_DIVIDER_POSITION,
-                                splitPane.getDividerLocation());
-                    }
-                });
+        // splitPane.setDividerLocation(prefs.getInt(PREF_DIVIDER_POSITION,
+        // PREF_DIVIDER_POSITION_DEF));
+        splitPane.addPropertyChangeListener("dividerLocation", new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent evt) {
+                prefs.putInt(PREF_DIVIDER_POSITION, splitPane.getDividerLocation());
+            }
+        });
         add(splitPane, BorderLayout.CENTER);
-        
+
         JTabbedPane tabbedPane = new JTabbedPane(JTabbedPane.TOP);
-//        JPanel settingsPanel = new JPanel();
-//        tabbedPane.add("Settings", settingsPanel);
+        // JPanel settingsPanel = new JPanel();
+        // tabbedPane.add("Settings", settingsPanel);
         JPanel footprintPanel = new JPanel();
         footprintPanel.setLayout(new BorderLayout());
         tabbedPane.add("Footprint", footprintPanel);
-        
-		
-		packagesTable = new AutoSelectTextTable(packagesTableModel);
-		packagesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-		
-		packagesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+
+
+        packagesTable = new AutoSelectTextTable(packagesTableModel);
+        packagesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+
+        packagesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
             @Override
             public void valueChanged(ListSelectionEvent e) {
                 if (e.getValueIsAdjusting()) {
                     return;
                 }
-                
+
                 Package pkg = getSelectedPackage();
-                
+
                 packageSelectedActionGroup.setEnabled(pkg != null);
-                
+
                 footprintPanel.removeAll();
-                
+
                 if (pkg != null) {
                     footprintPanel.add(new FootprintPanel(pkg.getFootprint()), BorderLayout.CENTER);
                 }
-                
+
                 revalidate();
                 repaint();
             }
         });
-        
-		packagesTable.setRowSorter(packagesTableSorter);
+
+        packagesTable.setRowSorter(packagesTableSorter);
 
         splitPane.setLeftComponent(new JScrollPane(packagesTable));
         splitPane.setRightComponent(tabbedPane);
-        
-        packageSelectedActionGroup = new ActionGroup(deletePackageAction, copyPackageToClipboardAction);
+
+        packageSelectedActionGroup =
+                new ActionGroup(deletePackageAction, copyPackageToClipboardAction);
         packageSelectedActionGroup.setEnabled(false);
-		
-		toolBar.add(newPackageAction);
-		toolBar.add(deletePackageAction);
-		toolBar.addSeparator();
+
+        toolBar.add(newPackageAction);
+        toolBar.add(deletePackageAction);
+        toolBar.addSeparator();
         toolBar.add(copyPackageToClipboardAction);
         toolBar.add(pastePackageToClipboardAction);
-		
+
         addComponentListener(new ComponentAdapter() {
-            @Override     
+            @Override
             public void componentHidden(ComponentEvent e) {
                 try {
-                    Camera camera = Configuration.get().getMachine().getDefaultHead().getDefaultCamera();
+                    Camera camera =
+                            Configuration.get().getMachine().getDefaultHead().getDefaultCamera();
                     CameraView cameraView = MainFrame.cameraPanel.getCameraView(camera);
                     if (cameraView == null) {
                         return;
                     }
-                    cameraView.removeReticle(FootprintPanel.class.getName());       
+                    cameraView.removeReticle(FootprintPanel.class.getName());
                 }
                 catch (Exception e1) {
                 }
-            }     
+            }
         });
-	}
-	
-	private Package getSelectedPackage() {
-		int index = packagesTable.getSelectedRow();
-		if (index == -1) {
-			return null;
-		}
-		index = packagesTable.convertRowIndexToModel(index);
-		return packagesTableModel.getPackage(index);
-	}
-	
-	private void search() {
-		RowFilter<PackagesTableModel, Object> rf = null;
-		// If current expression doesn't parse, don't update.
-		try {
-			rf = RowFilter.regexFilter("(?i)"
-					+ searchTextField.getText().trim());
-		}
-		catch (PatternSyntaxException e) {
-			logger.warn("Search failed", e);
-			return;
-		}
-		packagesTableSorter.setRowFilter(rf);
-	}
-
-	public final Action newPackageAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.add);
-			putValue(NAME, "New Package...");
-			putValue(SHORT_DESCRIPTION, "Create a new package, specifying it's ID.");
-		}
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			String id;
-			while ((id = JOptionPane.showInputDialog(frame, "Please enter an ID for the new package.")) != null) {
-				if (configuration.getPackage(id) != null) {
-					MessageBoxes.errorBox(frame, "Error", "Package ID " + id + " already exists.");
-					continue;
-				}
-				Package this_package = new Package(id);
-				
-				configuration.addPackage(this_package);
-				packagesTableModel.fireTableDataChanged();
-				Helpers.selectLastTableRow(packagesTable);
-				break;
-			}
-		}
-	};
-	
+    }
+
+    private Package getSelectedPackage() {
+        int index = packagesTable.getSelectedRow();
+        if (index == -1) {
+            return null;
+        }
+        index = packagesTable.convertRowIndexToModel(index);
+        return packagesTableModel.getPackage(index);
+    }
+
+    private void search() {
+        RowFilter<PackagesTableModel, Object> rf = null;
+        // If current expression doesn't parse, don't update.
+        try {
+            rf = RowFilter.regexFilter("(?i)" + searchTextField.getText().trim());
+        }
+        catch (PatternSyntaxException e) {
+            logger.warn("Search failed", e);
+            return;
+        }
+        packagesTableSorter.setRowFilter(rf);
+    }
+
+    public final Action newPackageAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.add);
+            putValue(NAME, "New Package...");
+            putValue(SHORT_DESCRIPTION, "Create a new package, specifying it's ID.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            String id;
+            while ((id = JOptionPane.showInputDialog(frame,
+                    "Please enter an ID for the new package.")) != null) {
+                if (configuration.getPackage(id) != null) {
+                    MessageBoxes.errorBox(frame, "Error", "Package ID " + id + " already exists.");
+                    continue;
+                }
+                Package this_package = new Package(id);
+
+                configuration.addPackage(this_package);
+                packagesTableModel.fireTableDataChanged();
+                Helpers.selectLastTableRow(packagesTable);
+                break;
+            }
+        }
+    };
+
     public final Action deletePackageAction = new AbstractAction() {
         {
             putValue(SMALL_ICON, Icons.delete);
             putValue(NAME, "Delete Package");
             putValue(SHORT_DESCRIPTION, "Delete the currently selected package.");
         }
+
         @Override
         public void actionPerformed(ActionEvent arg0) {
             // Check to make sure there are no parts using this package.
             for (Part part : Configuration.get().getParts()) {
                 if (part.getPackage() == getSelectedPackage()) {
-                    MessageBoxes.errorBox(getTopLevelAncestor(), "Error", getSelectedPackage().getId() + " cannot be deleted. It is used by " + part.getId());
+                    MessageBoxes.errorBox(getTopLevelAncestor(), "Error",
+                            getSelectedPackage().getId() + " cannot be deleted. It is used by "
+                                    + part.getId());
                     return;
                 }
             }
-            int ret = JOptionPane.showConfirmDialog(
-                    getTopLevelAncestor(), 
+            int ret = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
                     "Are you sure you want to delete " + getSelectedPackage().getId() + "?",
-                    "Delete " + getSelectedPackage().getId() + "?",
-                    JOptionPane.YES_NO_OPTION);
+                    "Delete " + getSelectedPackage().getId() + "?", JOptionPane.YES_NO_OPTION);
             if (ret == JOptionPane.YES_OPTION) {
                 Configuration.get().removePackage(getSelectedPackage());
             }
         }
     };
 
-    // TODO: add to enable group
     public final Action copyPackageToClipboardAction = new AbstractAction() {
         {
             putValue(SMALL_ICON, Icons.copy);
             putValue(NAME, "Copy Package to Clipboard");
-            putValue(SHORT_DESCRIPTION, "Copy the currently selected package to the clipboard in text format.");
+            putValue(SHORT_DESCRIPTION,
+                    "Copy the currently selected package to the clipboard in text format.");
         }
+
         @Override
         public void actionPerformed(ActionEvent arg0) {
             Package pkg = getSelectedPackage();
@@ -308,13 +309,14 @@ public void actionPerformed(ActionEvent arg0) {
             }
         }
     };
-    
+
     public final Action pastePackageToClipboardAction = new AbstractAction() {
         {
             putValue(SMALL_ICON, Icons.paste);
             putValue(NAME, "Create Package from Clipboard");
             putValue(SHORT_DESCRIPTION, "Create a new package from a definition on the clipboard.");
         }
+
         @Override
         public void actionPerformed(ActionEvent arg0) {
             try {
@@ -323,7 +325,7 @@ public void actionPerformed(ActionEvent arg0) {
                 String s = (String) clipboard.getData(DataFlavor.stringFlavor);
                 StringReader r = new StringReader(s);
                 Package pkg = ser.read(Package.class, s);
-                for (int i = 0; ; i++) {
+                for (int i = 0;; i++) {
                     if (Configuration.get().getPackage(pkg.getId() + "-" + i) == null) {
                         pkg.setId(pkg.getId() + "-" + i);
                         Configuration.get().addPackage(pkg);
diff --git a/src/main/java/org/openpnp/gui/PartsPanel.java b/src/main/java/org/openpnp/gui/PartsPanel.java
index 43888844d5..18aaf22153 100755
--- a/src/main/java/org/openpnp/gui/PartsPanel.java
+++ b/src/main/java/org/openpnp/gui/PartsPanel.java
@@ -1,31 +1,27 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui;
 
 import java.awt.BorderLayout;
 import java.awt.Frame;
 import java.awt.event.ActionEvent;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
 import java.util.regex.PatternSyntaxException;
 
 import javax.swing.AbstractAction;
@@ -49,9 +45,6 @@
 import javax.swing.table.TableRowSorter;
 
 import org.openpnp.gui.components.AutoSelectTextTable;
-import org.openpnp.gui.components.CameraView;
-import org.openpnp.gui.components.reticle.OutlineReticle;
-import org.openpnp.gui.components.reticle.Reticle;
 import org.openpnp.gui.support.Helpers;
 import org.openpnp.gui.support.Icons;
 import org.openpnp.gui.support.IdentifiableListCellRenderer;
@@ -66,164 +59,163 @@
 
 @SuppressWarnings("serial")
 public class PartsPanel extends JPanel {
-	private final static Logger logger = LoggerFactory.getLogger(PartsPanel.class);
-	
-	final private Configuration configuration;
-	final private Frame frame;
-	
-	private PartsTableModel partsTableModel;
-	private TableRowSorter<PartsTableModel> partsTableSorter;
-	private JTextField searchTextField;
-	private JTable partsTable;
-
-	public PartsPanel(Configuration configuration, Frame frame) {
-		this.configuration = configuration;
-		this.frame = frame;
-		
-		setLayout(new BorderLayout(0, 0));
-		partsTableModel = new PartsTableModel();
-		partsTableSorter = new TableRowSorter<>(partsTableModel);
-
-		JPanel panel_5 = new JPanel();
-		add(panel_5, BorderLayout.NORTH);
-		panel_5.setLayout(new BorderLayout(0, 0));
-
-		JToolBar toolBar = new JToolBar();
-		toolBar.setFloatable(false);
-		panel_5.add(toolBar);
-
-		JPanel panel_1 = new JPanel();
-		panel_5.add(panel_1, BorderLayout.EAST);
-
-		JLabel lblSearch = new JLabel("Search");
-		panel_1.add(lblSearch);
-
-		searchTextField = new JTextField();
-		searchTextField.getDocument().addDocumentListener(new DocumentListener() {
+    private final static Logger logger = LoggerFactory.getLogger(PartsPanel.class);
+
+    final private Configuration configuration;
+    final private Frame frame;
+
+    private PartsTableModel partsTableModel;
+    private TableRowSorter<PartsTableModel> partsTableSorter;
+    private JTextField searchTextField;
+    private JTable partsTable;
+
+    public PartsPanel(Configuration configuration, Frame frame) {
+        this.configuration = configuration;
+        this.frame = frame;
+
+        setLayout(new BorderLayout(0, 0));
+        partsTableModel = new PartsTableModel();
+        partsTableSorter = new TableRowSorter<>(partsTableModel);
+
+        JPanel panel_5 = new JPanel();
+        add(panel_5, BorderLayout.NORTH);
+        panel_5.setLayout(new BorderLayout(0, 0));
+
+        JToolBar toolBar = new JToolBar();
+        toolBar.setFloatable(false);
+        panel_5.add(toolBar);
+
+        JPanel panel_1 = new JPanel();
+        panel_5.add(panel_1, BorderLayout.EAST);
+
+        JLabel lblSearch = new JLabel("Search");
+        panel_1.add(lblSearch);
+
+        searchTextField = new JTextField();
+        searchTextField.getDocument().addDocumentListener(new DocumentListener() {
             @Override
             public void removeUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void insertUpdate(DocumentEvent e) {
                 search();
             }
-            
+
             @Override
             public void changedUpdate(DocumentEvent e) {
                 search();
             }
         });
-		panel_1.add(searchTextField);
-		searchTextField.setColumns(15);
-		
-		JComboBox packagesCombo = new JComboBox(new PackagesComboBoxModel());
-		packagesCombo.setRenderer(new IdentifiableListCellRenderer<org.openpnp.model.Package>());
-
-		partsTable = new AutoSelectTextTable(partsTableModel);
-		partsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-		partsTable.setDefaultEditor(org.openpnp.model.Package.class, new DefaultCellEditor(packagesCombo));
-		partsTable.setDefaultRenderer(org.openpnp.model.Package.class, new IdentifiableTableCellRenderer<org.openpnp.model.Package>());
-		
-		add(new JScrollPane(partsTable), BorderLayout.CENTER);
-
-		partsTable.setRowSorter(partsTableSorter);
-		
-		partsTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
-			@Override
-			public void valueChanged(ListSelectionEvent e) {
-				if (e.getValueIsAdjusting()) {
-					return;
-				}
-				Part part = getSelectedPart();
-				
-				deletePartAction.setEnabled(part != null);
-			}
-		});
-		
-		deletePartAction.setEnabled(false);
-		
-		JButton btnNewPart = toolBar.add(newPartAction);
-		btnNewPart.setToolTipText("");
-		JButton btnDeletePart = toolBar.add(deletePartAction);
-		btnDeletePart.setToolTipText("");
-	}
-	
-	private Part getSelectedPart() {
-		int index = partsTable.getSelectedRow();
-		if (index == -1) {
-			return null;
-		}
-		index = partsTable.convertRowIndexToModel(index);
-		return partsTableModel.getPart(index);
-	}
-	
-	private void search() {
-		RowFilter<PartsTableModel, Object> rf = null;
-		// If current expression doesn't parse, don't update.
-		try {
-			rf = RowFilter.regexFilter("(?i)"
-					+ searchTextField.getText().trim());
-		}
-		catch (PatternSyntaxException e) {
-			logger.warn("Search failed", e);
-			return;
-		}
-		partsTableSorter.setRowFilter(rf);
-	}
-
-	public final Action newPartAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.add);
-			putValue(NAME, "New Part...");
-			putValue(SHORT_DESCRIPTION, "Create a new part, specifying it's ID.");
-		}
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			if (Configuration.get().getPackages().size() == 0) {
-				MessageBoxes
-						.errorBox(
-								getTopLevelAncestor(),
-								"Error",
-								"There are currently no packages defined in the system. Please create at least one package before creating a part.");
-				return;
-			}
-			
-			String id;
-			while ((id = JOptionPane.showInputDialog(frame, "Please enter an ID for the new part.")) != null) {
-				if (configuration.getPart(id) != null) {
-					MessageBoxes.errorBox(frame, "Error", "Part ID " + id + " already exists.");
-					continue;
-				}
-				Part part = new Part(id);
-				
-				part.setPackage(Configuration.get().getPackages().get(0));
-				
-				configuration.addPart(part);
-				partsTableModel.fireTableDataChanged();
-				Helpers.selectLastTableRow(partsTable);
-				break;
-			}
-		}
-	};
-	
-	public final Action deletePartAction = new AbstractAction() {
-		{
-			putValue(SMALL_ICON, Icons.delete);
-			putValue(NAME, "Delete Part");
-			putValue(SHORT_DESCRIPTION, "Delete the currently selected part.");
-		}
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-		    int ret = JOptionPane.showConfirmDialog(
-		            getTopLevelAncestor(), 
-		            "Are you sure you want to delete " + getSelectedPart().getId() + "?",
-		            "Delete " + getSelectedPart().getId() + "?",
-		            JOptionPane.YES_NO_OPTION);
-		    if (ret == JOptionPane.YES_OPTION) {
-	            Configuration.get().removePart(getSelectedPart());
-		    }
-		}
-	};
+        panel_1.add(searchTextField);
+        searchTextField.setColumns(15);
+
+        JComboBox packagesCombo = new JComboBox(new PackagesComboBoxModel());
+        packagesCombo.setRenderer(new IdentifiableListCellRenderer<org.openpnp.model.Package>());
+
+        partsTable = new AutoSelectTextTable(partsTableModel);
+        partsTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+        partsTable.setDefaultEditor(org.openpnp.model.Package.class,
+                new DefaultCellEditor(packagesCombo));
+        partsTable.setDefaultRenderer(org.openpnp.model.Package.class,
+                new IdentifiableTableCellRenderer<org.openpnp.model.Package>());
+
+        add(new JScrollPane(partsTable), BorderLayout.CENTER);
+
+        partsTable.setRowSorter(partsTableSorter);
+
+        partsTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+                Part part = getSelectedPart();
+
+                deletePartAction.setEnabled(part != null);
+            }
+        });
+
+        deletePartAction.setEnabled(false);
+
+        JButton btnNewPart = toolBar.add(newPartAction);
+        btnNewPart.setToolTipText("");
+        JButton btnDeletePart = toolBar.add(deletePartAction);
+        btnDeletePart.setToolTipText("");
+    }
+
+    private Part getSelectedPart() {
+        int index = partsTable.getSelectedRow();
+        if (index == -1) {
+            return null;
+        }
+        index = partsTable.convertRowIndexToModel(index);
+        return partsTableModel.getPart(index);
+    }
+
+    private void search() {
+        RowFilter<PartsTableModel, Object> rf = null;
+        // If current expression doesn't parse, don't update.
+        try {
+            rf = RowFilter.regexFilter("(?i)" + searchTextField.getText().trim());
+        }
+        catch (PatternSyntaxException e) {
+            logger.warn("Search failed", e);
+            return;
+        }
+        partsTableSorter.setRowFilter(rf);
+    }
+
+    public final Action newPartAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.add);
+            putValue(NAME, "New Part...");
+            putValue(SHORT_DESCRIPTION, "Create a new part, specifying it's ID.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            if (Configuration.get().getPackages().size() == 0) {
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Error",
+                        "There are currently no packages defined in the system. Please create at least one package before creating a part.");
+                return;
+            }
+
+            String id;
+            while ((id = JOptionPane.showInputDialog(frame,
+                    "Please enter an ID for the new part.")) != null) {
+                if (configuration.getPart(id) != null) {
+                    MessageBoxes.errorBox(frame, "Error", "Part ID " + id + " already exists.");
+                    continue;
+                }
+                Part part = new Part(id);
+
+                part.setPackage(Configuration.get().getPackages().get(0));
+
+                configuration.addPart(part);
+                partsTableModel.fireTableDataChanged();
+                Helpers.selectLastTableRow(partsTable);
+                break;
+            }
+        }
+    };
+
+    public final Action deletePartAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.delete);
+            putValue(NAME, "Delete Part");
+            putValue(SHORT_DESCRIPTION, "Delete the currently selected part.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            int ret = JOptionPane.showConfirmDialog(getTopLevelAncestor(),
+                    "Are you sure you want to delete " + getSelectedPart().getId() + "?",
+                    "Delete " + getSelectedPart().getId() + "?", JOptionPane.YES_NO_OPTION);
+            if (ret == JOptionPane.YES_OPTION) {
+                Configuration.get().removePart(getSelectedPart());
+            }
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/components/AutoSelectTextTable.java b/src/main/java/org/openpnp/gui/components/AutoSelectTextTable.java
index d2ea81b9fc..46a6a6bf30 100755
--- a/src/main/java/org/openpnp/gui/components/AutoSelectTextTable.java
+++ b/src/main/java/org/openpnp/gui/components/AutoSelectTextTable.java
@@ -20,267 +20,239 @@
  * 
  * The RXTable provides some extensions to the default JTable
  *
- * 1) Select All editing - when a text related cell is placed in editing mode
- *    the text is selected. Controlled by invoking a "setSelectAll..." method.
+ * 1) Select All editing - when a text related cell is placed in editing mode the text is selected.
+ * Controlled by invoking a "setSelectAll..." method.
  *
  * 2) reorderColumns - static convenience method for reodering table columns
  */
 @SuppressWarnings("serial")
-public class AutoSelectTextTable extends JTable
-{
-	private boolean isSelectAllForMouseEvent = true;
-	private boolean isSelectAllForActionEvent = true;
-	private boolean isSelectAllForKeyEvent = true;
+public class AutoSelectTextTable extends JTable {
+    private boolean isSelectAllForMouseEvent = true;
+    private boolean isSelectAllForActionEvent = true;
+    private boolean isSelectAllForKeyEvent = true;
 
-//
-// Constructors
-//
+    //
+    // Constructors
+    //
     /**
-     * Constructs a default <code>RXTable</code> that is initialized with a default
-     * data model, a default column model, and a default selection
-     * model.
+     * Constructs a default <code>RXTable</code> that is initialized with a default data model, a
+     * default column model, and a default selection model.
      */
-    public AutoSelectTextTable()
-    {
+    public AutoSelectTextTable() {
         this(null, null, null);
     }
 
     /**
-     * Constructs a <code>RXTable</code> that is initialized with
-     * <code>dm</code> as the data model, a default column model,
-     * and a default selection model.
+     * Constructs a <code>RXTable</code> that is initialized with <code>dm</code> as the data model,
+     * a default column model, and a default selection model.
      *
-     * @param dm        the data model for the table
+     * @param dm the data model for the table
      */
-    public AutoSelectTextTable(TableModel dm)
-    {
+    public AutoSelectTextTable(TableModel dm) {
         this(dm, null, null);
     }
 
     /**
-     * Constructs a <code>RXTable</code> that is initialized with
-     * <code>dm</code> as the data model, <code>cm</code>
-     * as the column model, and a default selection model.
+     * Constructs a <code>RXTable</code> that is initialized with <code>dm</code> as the data model,
+     * <code>cm</code> as the column model, and a default selection model.
      *
-     * @param dm        the data model for the table
-     * @param cm        the column model for the table
+     * @param dm the data model for the table
+     * @param cm the column model for the table
      */
-    public AutoSelectTextTable(TableModel dm, TableColumnModel cm)
-    {
+    public AutoSelectTextTable(TableModel dm, TableColumnModel cm) {
         this(dm, cm, null);
     }
 
     /**
-     * Constructs a <code>RXTable</code> that is initialized with
-     * <code>dm</code> as the data model, <code>cm</code> as the
-     * column model, and <code>sm</code> as the selection model.
-     * If any of the parameters are <code>null</code> this method
-     * will initialize the table with the corresponding default model.
-     * The <code>autoCreateColumnsFromModel</code> flag is set to false
-     * if <code>cm</code> is non-null, otherwise it is set to true
-     * and the column model is populated with suitable
-     * <code>TableColumns</code> for the columns in <code>dm</code>.
+     * Constructs a <code>RXTable</code> that is initialized with <code>dm</code> as the data model,
+     * <code>cm</code> as the column model, and <code>sm</code> as the selection model. If any of
+     * the parameters are <code>null</code> this method will initialize the table with the
+     * corresponding default model. The <code>autoCreateColumnsFromModel</code> flag is set to false
+     * if <code>cm</code> is non-null, otherwise it is set to true and the column model is populated
+     * with suitable <code>TableColumns</code> for the columns in <code>dm</code>.
      *
-     * @param dm        the data model for the table
-     * @param cm        the column model for the table
-     * @param sm        the row selection model for the table
+     * @param dm the data model for the table
+     * @param cm the column model for the table
+     * @param sm the row selection model for the table
      */
-    public AutoSelectTextTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm)
-    {
+    public AutoSelectTextTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {
         super(dm, cm, sm);
     }
 
     /**
-     * Constructs a <code>RXTable</code> with <code>numRows</code>
-     * and <code>numColumns</code> of empty cells using
-     * <code>DefaultTableModel</code>.  The columns will have
-     * names of the form "A", "B", "C", etc.
+     * Constructs a <code>RXTable</code> with <code>numRows</code> and <code>numColumns</code> of
+     * empty cells using <code>DefaultTableModel</code>. The columns will have names of the form
+     * "A", "B", "C", etc.
      *
-     * @param numRows           the number of rows the table holds
-     * @param numColumns        the number of columns the table holds
+     * @param numRows the number of rows the table holds
+     * @param numColumns the number of columns the table holds
      */
-    public AutoSelectTextTable(int numRows, int numColumns)
-    {
+    public AutoSelectTextTable(int numRows, int numColumns) {
         this(new DefaultTableModel(numRows, numColumns));
     }
 
     /**
-     * Constructs a <code>RXTable</code> to display the values in the
-     * <code>Vector</code> of <code>Vectors</code>, <code>rowData</code>,
-     * with column names, <code>columnNames</code>.  The
-     * <code>Vectors</code> contained in <code>rowData</code>
-     * should contain the values for that row. In other words,
-     * the value of the cell at row 1, column 5 can be obtained
-     * with the following code:
+     * Constructs a <code>RXTable</code> to display the values in the <code>Vector</code> of
+     * <code>Vectors</code>, <code>rowData</code>, with column names, <code>columnNames</code>. The
+     * <code>Vectors</code> contained in <code>rowData</code> should contain the values for that
+     * row. In other words, the value of the cell at row 1, column 5 can be obtained with the
+     * following code:
      * <p>
-     * <pre>((Vector)rowData.elementAt(1)).elementAt(5);</pre>
+     * 
+     * <pre>
+     * ((Vector) rowData.elementAt(1)).elementAt(5);
+     * </pre>
      * <p>
-     * @param rowData           the data for the new table
-     * @param columnNames       names of each column
+     * 
+     * @param rowData the data for the new table
+     * @param columnNames names of each column
      */
-    public AutoSelectTextTable(Vector rowData, Vector columnNames)
-    {
+    public AutoSelectTextTable(Vector rowData, Vector columnNames) {
         this(new DefaultTableModel(rowData, columnNames));
     }
 
     /**
      * Constructs a <code>RXTable</code> to display the values in the two dimensional array,
-     * <code>rowData</code>, with column names, <code>columnNames</code>.
-     * <code>rowData</code> is an array of rows, so the value of the cell at row 1,
-     * column 5 can be obtained with the following code:
+     * <code>rowData</code>, with column names, <code>columnNames</code>. <code>rowData</code> is an
+     * array of rows, so the value of the cell at row 1, column 5 can be obtained with the following
+     * code:
      * <p>
-     * <pre> rowData[1][5]; </pre>
+     * 
+     * <pre>
+     *  rowData[1][5];
+     * </pre>
      * <p>
      * All rows must be of the same length as <code>columnNames</code>.
      * <p>
-     * @param rowData           the data for the new table
-     * @param columnNames       names of each column
+     * 
+     * @param rowData the data for the new table
+     * @param columnNames names of each column
      */
-    public AutoSelectTextTable(final Object[][] rowData, final Object[] columnNames)
-    {
+    public AutoSelectTextTable(final Object[][] rowData, final Object[] columnNames) {
         super(rowData, columnNames);
     }
-//
-//  Overridden methods
-//
-	/*
-	 *  Override to provide Select All editing functionality
-	 */
-	public boolean editCellAt(int row, int column, EventObject e)
-	{
-		boolean result = super.editCellAt(row, column, e);
 
-		if (isSelectAllForMouseEvent
-		||  isSelectAllForActionEvent
-		||  isSelectAllForKeyEvent)
-		{
-			selectAll(e);
-		}
+    //
+    // Overridden methods
+    //
+    /*
+     * Override to provide Select All editing functionality
+     */
+    public boolean editCellAt(int row, int column, EventObject e) {
+        boolean result = super.editCellAt(row, column, e);
 
-		return result;
-	}
+        if (isSelectAllForMouseEvent || isSelectAllForActionEvent || isSelectAllForKeyEvent) {
+            selectAll(e);
+        }
 
-	/*
-	 * Select the text when editing on a text related cell is started
-	 */
-	private void selectAll(EventObject e)
-	{
-		final Component editor = getEditorComponent();
+        return result;
+    }
 
-		if (editor == null
-		|| ! (editor instanceof JTextComponent))
-			return;
+    /*
+     * Select the text when editing on a text related cell is started
+     */
+    private void selectAll(EventObject e) {
+        final Component editor = getEditorComponent();
 
-		if (e == null)
-		{
-			((JTextComponent)editor).selectAll();
-			return;
-		}
+        if (editor == null || !(editor instanceof JTextComponent))
+            return;
 
-		//  Typing in the cell was used to activate the editor
+        if (e == null) {
+            ((JTextComponent) editor).selectAll();
+            return;
+        }
 
-		if (e instanceof KeyEvent && isSelectAllForKeyEvent)
-		{
-			((JTextComponent)editor).selectAll();
-			return;
-		}
+        // Typing in the cell was used to activate the editor
 
-		//  F2 was used to activate the editor
+        if (e instanceof KeyEvent && isSelectAllForKeyEvent) {
+            ((JTextComponent) editor).selectAll();
+            return;
+        }
 
-		if (e instanceof ActionEvent && isSelectAllForActionEvent)
-		{
-			((JTextComponent)editor).selectAll();
-			return;
-		}
+        // F2 was used to activate the editor
 
-		//  A mouse click was used to activate the editor.
-		//  Generally this is a double click and the second mouse click is
-		//  passed to the editor which would remove the text selection unless
-		//  we use the invokeLater()
+        if (e instanceof ActionEvent && isSelectAllForActionEvent) {
+            ((JTextComponent) editor).selectAll();
+            return;
+        }
 
-		if (e instanceof MouseEvent && isSelectAllForMouseEvent)
-		{
-			SwingUtilities.invokeLater(new Runnable()
-			{
-				public void run()
-				{
-					((JTextComponent)editor).selectAll();
-				}
-			});
-		}
-	}
+        // A mouse click was used to activate the editor.
+        // Generally this is a double click and the second mouse click is
+        // passed to the editor which would remove the text selection unless
+        // we use the invokeLater()
+
+        if (e instanceof MouseEvent && isSelectAllForMouseEvent) {
+            SwingUtilities.invokeLater(new Runnable() {
+                public void run() {
+                    ((JTextComponent) editor).selectAll();
+                }
+            });
+        }
+    }
 
-//
-//  Newly added methods
-//
-	/*
-	 *  Sets the Select All property for for all event types
-	 */
-	public void setSelectAllForEdit(boolean isSelectAllForEdit)
-	{
-		setSelectAllForMouseEvent( isSelectAllForEdit );
-		setSelectAllForActionEvent( isSelectAllForEdit );
-		setSelectAllForKeyEvent( isSelectAllForEdit );
-	}
+    //
+    // Newly added methods
+    //
+    /*
+     * Sets the Select All property for for all event types
+     */
+    public void setSelectAllForEdit(boolean isSelectAllForEdit) {
+        setSelectAllForMouseEvent(isSelectAllForEdit);
+        setSelectAllForActionEvent(isSelectAllForEdit);
+        setSelectAllForKeyEvent(isSelectAllForEdit);
+    }
+
+    /*
+     * Set the Select All property when editing is invoked by the mouse
+     */
+    public void setSelectAllForMouseEvent(boolean isSelectAllForMouseEvent) {
+        this.isSelectAllForMouseEvent = isSelectAllForMouseEvent;
+    }
 
-	/*
-	 *  Set the Select All property when editing is invoked by the mouse
-	 */
-	public void setSelectAllForMouseEvent(boolean isSelectAllForMouseEvent)
-	{
-		this.isSelectAllForMouseEvent = isSelectAllForMouseEvent;
-	}
+    /*
+     * Set the Select All property when editing is invoked by the "F2" key
+     */
+    public void setSelectAllForActionEvent(boolean isSelectAllForActionEvent) {
+        this.isSelectAllForActionEvent = isSelectAllForActionEvent;
+    }
 
-	/*
-	 *  Set the Select All property when editing is invoked by the "F2" key
-	 */
-	public void setSelectAllForActionEvent(boolean isSelectAllForActionEvent)
-	{
-		this.isSelectAllForActionEvent = isSelectAllForActionEvent;
-	}
+    /*
+     * Set the Select All property when editing is invoked by typing directly into the cell
+     */
+    public void setSelectAllForKeyEvent(boolean isSelectAllForKeyEvent) {
+        this.isSelectAllForKeyEvent = isSelectAllForKeyEvent;
+    }
 
-	/*
-	 *  Set the Select All property when editing is invoked by
-	 *  typing directly into the cell
-	 */
-	public void setSelectAllForKeyEvent(boolean isSelectAllForKeyEvent)
-	{
-		this.isSelectAllForKeyEvent = isSelectAllForKeyEvent;
-	}
-	
-//    public void changeSelection(final int row, final int column, boolean toggle, boolean extend)
-//    {
-//        super.changeSelection(row, column, toggle, extend);
-//        editCellAt(row, column);
-//        transferFocus();
-//    } 
+    // public void changeSelection(final int row, final int column, boolean toggle, boolean extend)
+    // {
+    // super.changeSelection(row, column, toggle, extend);
+    // editCellAt(row, column);
+    // transferFocus();
+    // }
 
-//
-//  Static, convenience methods
-//
-	/**
-	 *  Convenience method to order the table columns of a table. The columns
-	 *  are ordered based on the column names specified in the array. If the
-	 *  column name is not found then no column is moved. This means you can
-	 *  specify a null value to preserve the current order of a given column.
-	 *
-     *  @param table        the table containing the columns to be sorted
-     *  @param columnNames  an array containing the column names in the
-     *                      order they should be displayed
-	 */
-	public static void reorderColumns(JTable table, Object... columnNames)
-	{
-		TableColumnModel model = table.getColumnModel();
+    //
+    // Static, convenience methods
+    //
+    /**
+     * Convenience method to order the table columns of a table. The columns are ordered based on
+     * the column names specified in the array. If the column name is not found then no column is
+     * moved. This means you can specify a null value to preserve the current order of a given
+     * column.
+     *
+     * @param table the table containing the columns to be sorted
+     * @param columnNames an array containing the column names in the order they should be displayed
+     */
+    public static void reorderColumns(JTable table, Object... columnNames) {
+        TableColumnModel model = table.getColumnModel();
 
-		for (int newIndex = 0; newIndex < columnNames.length; newIndex++)
-		{
-			try
-			{
-				Object columnName = columnNames[newIndex];
-				int index = model.getColumnIndex(columnName);
-				model.moveColumn(index, newIndex);
-			}
-			catch(IllegalArgumentException e) {}
-		}
-	}
-}  // End of Class RXTable
+        for (int newIndex = 0; newIndex < columnNames.length; newIndex++) {
+            try {
+                Object columnName = columnNames[newIndex];
+                int index = model.getColumnIndex(columnName);
+                model.moveColumn(index, newIndex);
+            }
+            catch (IllegalArgumentException e) {
+            }
+        }
+    }
+} // End of Class RXTable
diff --git a/src/main/java/org/openpnp/gui/components/CameraPanel.java b/src/main/java/org/openpnp/gui/components/CameraPanel.java
index 501be548ec..84d5ef9917 100755
--- a/src/main/java/org/openpnp/gui/components/CameraPanel.java
+++ b/src/main/java/org/openpnp/gui/components/CameraPanel.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components;
@@ -27,123 +25,165 @@
 import java.awt.event.ActionEvent;
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.prefs.Preferences;
 
 import javax.swing.AbstractAction;
 import javax.swing.JComboBox;
 import javax.swing.JPanel;
 
+import org.openpnp.ConfigurationListener;
 import org.openpnp.gui.support.CameraItem;
+import org.openpnp.model.Configuration;
 import org.openpnp.spi.Camera;
+import org.openpnp.spi.Head;
 
 /**
  * Shows a square grid of cameras or a blown up image from a single camera.
  */
 @SuppressWarnings("serial")
 public class CameraPanel extends JPanel {
-	private static int maximumFps = 15;
-	private static final String SHOW_NONE_ITEM = "Show None";
-	private static final String SHOW_ALL_ITEM = "Show All";
-
-	private Map<Camera, CameraView> cameraViews = new LinkedHashMap<>();
-
-	private JComboBox camerasCombo;
-	private JPanel camerasPanel;
-	
-	private CameraView selectedCameraView;
-	
-	public CameraPanel() {
-		createUi();
-	}
-
-	public void addCamera(Camera camera) {
-		CameraView cameraView = new CameraView(maximumFps / Math.max(cameraViews.size(), 1));
-		cameraView.setCamera(camera);
-		cameraViews.put(camera, cameraView);
-		camerasCombo.addItem(new CameraItem(camera));
-		if (cameraViews.size() == 1) {
-			// First camera being added, so select it
-			camerasCombo.setSelectedIndex(1);
-		}
-		else if (cameraViews.size() == 2) {
-			// Otherwise this is the second camera so mix in the 
-			// show all item.
-			camerasCombo.insertItemAt(SHOW_ALL_ITEM, 1);
-		}
-	}
-	
-	private void createUi() {
-		camerasPanel = new JPanel();
-
-		camerasCombo = new JComboBox();
-		camerasCombo.addActionListener(cameraSelectedAction);
-
-		setLayout(new BorderLayout());
-
-		camerasCombo.addItem(SHOW_NONE_ITEM);
-		
-		add(camerasCombo, BorderLayout.NORTH);
-		add(camerasPanel);
-	}
-	
-	/**
-	 * Make sure the given Camera is visible in the UI. If All Cameras is
-	 * selected we do nothing, otherwise we select the specified Camera.
-	 * @param camera
-	 * @return
-	 */
-	public void ensureCameraVisible(Camera camera) {
-		if (camerasCombo.getSelectedItem().equals(SHOW_ALL_ITEM)) {
-			return;
-		}
-		setSelectedCamera(camera);
-	}
-	
-	public CameraView setSelectedCamera(Camera camera) {
-		if (selectedCameraView != null && selectedCameraView.getCamera() == camera) {
-			return selectedCameraView;
-		}
-		for (int i = 0; i < camerasCombo.getItemCount(); i++) {
-			Object o = camerasCombo.getItemAt(i);
-			if (o instanceof CameraItem) {
-				Camera c = ((CameraItem) o).getCamera();
-				if (c == camera) {
-					camerasCombo.setSelectedIndex(i);
-					return selectedCameraView;
-				}
-			}
-		}
-		return null;
-	}
-	
-	public CameraView getCameraView(Camera camera) {
-		return cameraViews.get(camera);
-	}
-	
-	private AbstractAction cameraSelectedAction = new AbstractAction("") {
-		@Override
-		public void actionPerformed(ActionEvent ev) {
-			selectedCameraView = null;
-			camerasPanel.removeAll();
-			if (camerasCombo.getSelectedItem().equals(SHOW_NONE_ITEM)) {
-				camerasPanel.setLayout(new BorderLayout());
-				JPanel panel = new JPanel();
-				panel.setBackground(Color.black);
-				camerasPanel.add(panel);
-				selectedCameraView = null;
-			}
-			else if (camerasCombo.getSelectedItem().equals(SHOW_ALL_ITEM)) {
-				int columns = (int) Math.ceil(Math.sqrt(cameraViews.size()));
-				if (columns == 0) {
-					columns = 1;
-				}
-				camerasPanel.setLayout(new GridLayout(0, columns, 1, 1));
-				for (CameraView cameraView : cameraViews.values()) {
-					cameraView.setMaximumFps(maximumFps / Math.max(cameraViews.size(), 1));
-					camerasPanel.add(cameraView);
-					if (cameraViews.size() == 1) {
-						selectedCameraView = cameraView;
-					}
-				}
+    private static int maximumFps = 15;
+    private static final String SHOW_NONE_ITEM = "Show None";
+    private static final String SHOW_ALL_ITEM = "Show All";
+
+    private Map<Camera, CameraView> cameraViews = new LinkedHashMap<>();
+
+    private JComboBox camerasCombo;
+    private JPanel camerasPanel;
+
+    private CameraView selectedCameraView;
+
+
+    private static final String PREF_SELECTED_CAMERA_VIEW = "JobPanel.dividerPosition";
+    private Preferences prefs = Preferences.userNodeForPackage(CameraPanel.class);
+
+    public CameraPanel() {
+        createUi();
+        Configuration.get().addListener(new ConfigurationListener.Adapter() {
+            @Override
+            public void configurationComplete(Configuration configuration) throws Exception {
+                for (Head head : Configuration.get().getMachine().getHeads()) {
+                    for (Camera camera : head.getCameras()) {
+                        addCamera(camera);
+                    }
+                }
+                for (Camera camera : configuration.getMachine().getCameras()) {
+                    addCamera(camera);
+                }
+
+                String selectedCameraView = prefs.get(PREF_SELECTED_CAMERA_VIEW, null);
+                if (selectedCameraView != null) {
+                    for (int i = 0; i < camerasCombo.getItemCount(); i++) {
+                        Object o = camerasCombo.getItemAt(i);
+                        if (o.toString().equals(selectedCameraView)) {
+                            camerasCombo.setSelectedItem(o);
+                        }
+                    }
+                }
+                camerasCombo.addActionListener((event) -> {
+                    try {
+                        prefs.put(PREF_SELECTED_CAMERA_VIEW,
+                                camerasCombo.getSelectedItem().toString());
+                        prefs.flush();
+                    }
+                    catch (Exception e) {
+                        e.printStackTrace();
+                    }
+                });
+            }
+        });
+    }
+
+    public void addCamera(Camera camera) {
+        CameraView cameraView = new CameraView(maximumFps / Math.max(cameraViews.size(), 1));
+        cameraView.setCamera(camera);
+        cameraViews.put(camera, cameraView);
+        camerasCombo.addItem(new CameraItem(camera));
+        if (cameraViews.size() == 1) {
+            // First camera being added, so select it
+            camerasCombo.setSelectedIndex(1);
+        }
+        else if (cameraViews.size() == 2) {
+            // Otherwise this is the second camera so mix in the
+            // show all item.
+            camerasCombo.insertItemAt(SHOW_ALL_ITEM, 1);
+        }
+    }
+
+    private void createUi() {
+        camerasPanel = new JPanel();
+
+        camerasCombo = new JComboBox();
+        camerasCombo.addActionListener(cameraSelectedAction);
+
+        setLayout(new BorderLayout());
+
+        camerasCombo.addItem(SHOW_NONE_ITEM);
+
+        add(camerasCombo, BorderLayout.NORTH);
+        add(camerasPanel);
+    }
+
+    /**
+     * Make sure the given Camera is visible in the UI. If All Cameras is selected we do nothing,
+     * otherwise we select the specified Camera.
+     * 
+     * @param camera
+     * @return
+     */
+    public void ensureCameraVisible(Camera camera) {
+        if (camerasCombo.getSelectedItem().equals(SHOW_ALL_ITEM)) {
+            return;
+        }
+        setSelectedCamera(camera);
+    }
+
+    public CameraView setSelectedCamera(Camera camera) {
+        if (selectedCameraView != null && selectedCameraView.getCamera() == camera) {
+            return selectedCameraView;
+        }
+        for (int i = 0; i < camerasCombo.getItemCount(); i++) {
+            Object o = camerasCombo.getItemAt(i);
+            if (o instanceof CameraItem) {
+                Camera c = ((CameraItem) o).getCamera();
+                if (c == camera) {
+                    camerasCombo.setSelectedIndex(i);
+                    return selectedCameraView;
+                }
+            }
+        }
+        return null;
+    }
+
+    public CameraView getCameraView(Camera camera) {
+        return cameraViews.get(camera);
+    }
+
+    private AbstractAction cameraSelectedAction = new AbstractAction("") {
+        @Override
+        public void actionPerformed(ActionEvent ev) {
+            selectedCameraView = null;
+            camerasPanel.removeAll();
+            if (camerasCombo.getSelectedItem().equals(SHOW_NONE_ITEM)) {
+                camerasPanel.setLayout(new BorderLayout());
+                JPanel panel = new JPanel();
+                panel.setBackground(Color.black);
+                camerasPanel.add(panel);
+                selectedCameraView = null;
+            }
+            else if (camerasCombo.getSelectedItem().equals(SHOW_ALL_ITEM)) {
+                int columns = (int) Math.ceil(Math.sqrt(cameraViews.size()));
+                if (columns == 0) {
+                    columns = 1;
+                }
+                camerasPanel.setLayout(new GridLayout(0, columns, 1, 1));
+                for (CameraView cameraView : cameraViews.values()) {
+                    cameraView.setMaximumFps(maximumFps / Math.max(cameraViews.size(), 1));
+                    camerasPanel.add(cameraView);
+                    if (cameraViews.size() == 1) {
+                        selectedCameraView = cameraView;
+                    }
+                }
                 if (cameraViews.size() > 2) {
                     for (int i = 0; i < (columns * columns) - cameraViews.size(); i++) {
                         JPanel panel = new JPanel();
@@ -151,19 +191,19 @@ else if (camerasCombo.getSelectedItem().equals(SHOW_ALL_ITEM)) {
                         camerasPanel.add(panel);
                     }
                 }
-				selectedCameraView = null;
-			}
-			else {
-				camerasPanel.setLayout(new BorderLayout());
-				Camera camera = ((CameraItem) camerasCombo.getSelectedItem()).getCamera();
-				CameraView cameraView = getCameraView(camera);
-				cameraView.setMaximumFps(maximumFps);
-				camerasPanel.add(cameraView);
-				
-				selectedCameraView = cameraView;
-			}
-			revalidate();
-			repaint();
-		}
-	};
+                selectedCameraView = null;
+            }
+            else {
+                camerasPanel.setLayout(new BorderLayout());
+                Camera camera = ((CameraItem) camerasCombo.getSelectedItem()).getCamera();
+                CameraView cameraView = getCameraView(camera);
+                cameraView.setMaximumFps(maximumFps);
+                camerasPanel.add(cameraView);
+
+                selectedCameraView = cameraView;
+            }
+            revalidate();
+            repaint();
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraView.java b/src/main/java/org/openpnp/gui/components/CameraView.java
index 4a9de692ea..b94478e0c1 100755
--- a/src/main/java/org/openpnp/gui/components/CameraView.java
+++ b/src/main/java/org/openpnp/gui/components/CameraView.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components;
@@ -59,9 +57,7 @@
 import javax.swing.SwingUtilities;
 
 import org.openpnp.CameraListener;
-import org.openpnp.gui.MainFrame;
 import org.openpnp.gui.components.reticle.Reticle;
-import org.openpnp.gui.support.MessageBoxes;
 import org.openpnp.model.Configuration;
 import org.openpnp.model.Location;
 import org.openpnp.spi.Camera;
@@ -73,763 +69,702 @@
 
 @SuppressWarnings("serial")
 public class CameraView extends JComponent implements CameraListener {
-	private final static Logger logger = LoggerFactory
-			.getLogger(CameraView.class);
-	
-	private static final String PREF_RETICLE = "CamerView.reticle";
-	
-	private static final String DEFAULT_RETICLE_KEY = "DEFAULT_RETICLE_KEY";
-
-	private final static int HANDLE_DIAMETER = 8;
-
-	private enum HandlePosition {
-		NW, N, NE, E, SE, S, SW, W
-	}
-
-	private enum SelectionMode {
-		Resizing, Moving, Creating
-	}
-
-	/**
-	 * The Camera we are viewing.
-	 */
-	private Camera camera;
-
-	/**
-	 * The last frame received, reported by the Camera.
-	 */
-	private BufferedImage lastFrame;
-
-	/**
-	 * The maximum frames per second that we'll display.
-	 */
-	private int maximumFps;
-
-	private LinkedHashMap<Object, Reticle> reticles = new LinkedHashMap<>();
-
-	private JPopupMenu popupMenu;
-
-	/**
-	 * The last width and height of the component that we painted for. If the
-	 * width or height is different from these values at the start of paint
-	 * we'll recalculate all the scaling data.
-	 */
-	private double lastWidth, lastHeight;
-
-	/**
-	 * The last width and height of the image that we painted for. If the width
-	 * or height is different from these values at the start of paint we'll
-	 * recalculate all the scaling data.
-	 */
-	private double lastSourceWidth, lastSourceHeight;
-	
-	private Location lastUnitsPerPixel;
-
-	/**
-	 * The width and height of the image after it has been scaled to fit the
-	 * bounds of the component.
-	 */
-	private int scaledWidth, scaledHeight;
-
-	/**
-	 * The ratio of scaled width and height to unscaled width and height.
-	 * scaledWidth * scaleRatioX = sourceWidth. scaleRatioX = sourceWidth /
-	 * scaledWidth
-	 */
-	private double scaleRatioX, scaleRatioY;
-
-	/**
-	 * The Camera's units per pixel scaled at the same ratio as the image. That
-	 * is, each pixel in the scaled image is scaledUnitsPerPixelX wide and
-	 * scaledUnitsPerPixelY high.
-	 */
-	private double scaledUnitsPerPixelX, scaledUnitsPerPixelY;
-
-	/**
-	 * The top left position within the component at which the scaled image can
-	 * be drawn for it to be centered.
-	 */
-	private int imageX, imageY;
-
-	private boolean selectionEnabled;
-	/**
-	 * Rectangle describing the bounds of the selection in image coordinates.
-	 */
-	private Rectangle selection;
-	/**
-	 * The scaled version of the selection Rectangle. Rescaled any time the
-	 * component's size is changed.
-	 */
-	private Rectangle selectionScaled;
-	private SelectionMode selectionMode;
-	private HandlePosition selectionActiveHandle;
-	private int selectionStartX, selectionStartY;
-	private float selectionFlashOpacity;
-	private float selectionDashPhase;
-	private static float[] selectionDashProfile = new float[] { 6f, 6f };
-	// 11 is the sum of the dash lengths minus 1.
-	private static float selectionDashPhaseStart = 11f;
-
-	private CameraViewSelectionTextDelegate selectionTextDelegate;
-
-	private ScheduledExecutorService scheduledExecutor;
-
-	private Preferences prefs = Preferences
-			.userNodeForPackage(CameraView.class);
-	
-	private String text;
-	
-	private boolean showImageInfo;
-	
-	private List<CameraViewActionListener> actionListeners = new ArrayList<>();
-	
-	private CameraViewFilter cameraViewFilter;
-	
-	private long flashStartTimeMs;
-	private long flashLengthMs = 250;
-
-	public CameraView() {
-		setBackground(Color.black);
-		setOpaque(true);
-
-		String reticlePref = prefs.get(PREF_RETICLE, null);
-		try {
-			Reticle reticle = (Reticle) XmlSerialize.deserialize(reticlePref);
-			setDefaultReticle(reticle);
-		}
-		catch (Exception e) {
-			// logger.warn("Warning: Unable to load Reticle preference");
-		}
-
-		popupMenu = new CameraViewPopupMenu(this);
-
-		addMouseListener(mouseListener);
-		addMouseMotionListener(mouseMotionListener);
-		addComponentListener(componentListener);
-
-		scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
-
-		// TODO: Cancel this when it's not being used instead of spinning,
-		// or maybe create a real thread and wait().
-		scheduledExecutor.scheduleAtFixedRate(new Runnable() {
-			public void run() {
-				if (selectionEnabled && selection != null) {
-					// Adjust the dash phase so the line marches on the next
-					// paint
-					selectionDashPhase -= 1f;
-					if (selectionDashPhase < 0) {
-						selectionDashPhase = selectionDashPhaseStart;
-					}
-					repaint();
-				}
-			}
-		}, 0, 50, TimeUnit.MILLISECONDS);
-	}
-
-	public CameraView(int maximumFps) {
-		this();
-		setMaximumFps(maximumFps);
-	}
-	
-	public void addActionListener(CameraViewActionListener listener) {
-		if (!actionListeners.contains(listener)) {
-			actionListeners.add(listener);
-		}
-	}
-	
-	public boolean removeActionListener(CameraViewActionListener listener) {
-		return actionListeners.remove(listener);
-	}
-
-	public void setMaximumFps(int maximumFps) {
-		this.maximumFps = maximumFps;
-		// turn off capture for the camera we are replacing, if any
-		if (this.camera != null) {
-			this.camera.stopContinuousCapture(this);
-		}
-		// turn on capture for the new camera
-		if (this.camera != null) {
-			this.camera.startContinuousCapture(this, maximumFps);
-		}
-	}
-
-	public int getMaximumFps() {
-		return maximumFps;
-	}
-
-	public void setCamera(Camera camera) {
-		// turn off capture for the camera we are replacing, if any
-		if (this.camera != null) {
-			this.camera.stopContinuousCapture(this);
-		}
-		this.camera = camera;
-		// turn on capture for the new camera
-		if (this.camera != null) {
-			this.camera.startContinuousCapture(this, maximumFps);
-		}
-	}
-
-	public Camera getCamera() {
-		return camera;
-	}
-
-	public void setDefaultReticle(Reticle reticle) {
-		setReticle(DEFAULT_RETICLE_KEY, reticle);
-
-		prefs.put(PREF_RETICLE, XmlSerialize.serialize(reticle));
-		try {
-			prefs.flush();
-		}
-		catch (Exception e) {
-
-		}
-	}
-	
-	public Reticle getDefaultReticle() {
-		return reticles.get(DEFAULT_RETICLE_KEY);
-	}
-	
-	public void setReticle(Object key, Reticle reticle) {
-		if (reticle == null) {
-			removeReticle(key);
-		}
-		else {
-			reticles.put(key, reticle);
-		}
-	}
-	
-	public Reticle getReticle(Object key) {
-		return reticles.get(key);
-	}
-	
-	public Reticle removeReticle(Object key) {
-		return reticles.remove(key);
-	}
-
-	public CameraViewSelectionTextDelegate getSelectionTextDelegate() {
-		return selectionTextDelegate;
-	}
-
-	public void setSelectionTextDelegate(
-			CameraViewSelectionTextDelegate selectionTextDelegate) {
-		this.selectionTextDelegate = selectionTextDelegate;
-	}
-	
-	public String getText() {
-		return text;
-	}
-
-	public void setText(String text) {
-		this.text = text;
-	}
-	
-	/**
-	 * Causes a short flash in the CameraView to get the user's attention.
-	 */
-	public void flash() {
-		flashStartTimeMs = System.currentTimeMillis();
-		scheduledExecutor.scheduleAtFixedRate(
-			new Runnable() {
-				public void run() {
-					if (System.currentTimeMillis() - flashStartTimeMs < flashLengthMs) {
-						repaint();
-					}
-					else {
-						flashStartTimeMs = 0;
-						throw new RuntimeException();
-					}
-				}
-			}, 0, 30, TimeUnit.MILLISECONDS);
-	}
-	
-	public void setCameraViewFilter(CameraViewFilter cameraViewFilter) {
-		this.cameraViewFilter = cameraViewFilter;
-	}
-
-	/**
-	 * Show image instead of the camera image for milliseconds. After
-	 * milliseconds elapses the view goes back to showing the camera image.
-	 * The image should be the same width and height as the camera image
-	 * otherwise the behavior is undefined. This function is intended to
-	 * be used to briefly show the result of image processing. This is
-	 * a shortcut to setCameraViewFilter(CameraViewFilter) which simply
-	 * removes itself after the specified time.
-	 * @param image
-	 * @param millseconds
-	 */
-	public void showFilteredImage(final BufferedImage filteredImage, final long milliseconds) {
-		setCameraViewFilter(new CameraViewFilter() {
-        	long t = System.currentTimeMillis();
-        	
-			@Override
-			public BufferedImage filterCameraImage(Camera camera, BufferedImage image) {
-				if ((System.currentTimeMillis() - t) < milliseconds) {
-					return filteredImage;
-				}
-				else {
-					setCameraViewFilter(null);
-					return image;
-				}
-			}
-		});	
-	}
-
-	public BufferedImage captureSelectionImage() {
-		if (selection == null || lastFrame == null) {
-			return null;
-		}
-
-		selectionFlashOpacity = 1.0f;
-
-		ScheduledFuture future = scheduledExecutor.scheduleAtFixedRate(
-				new Runnable() {
-					public void run() {
-						if (selectionFlashOpacity > 0) {
-							selectionFlashOpacity -= 0.07;
-							selectionFlashOpacity = Math.max(0,
-									selectionFlashOpacity);
-							repaint();
-						}
-						else {
-							throw new RuntimeException();
-						}
-					}
-				}, 0, 30, TimeUnit.MILLISECONDS);
-
-		int sx = selection.x;
-		int sy = selection.y;
-		int sw = selection.width;
-		int sh = selection.height;
-
-		BufferedImage image = new BufferedImage(sw, sh,
-				BufferedImage.TYPE_INT_ARGB);
-		Graphics g = image.getGraphics();
-		g.drawImage(lastFrame, 0, 0, sw, sh, sx, sy, sx + sw, sy + sh, null);
-		g.dispose();
-
-		while (!future.isDone())
-			;
-
-		return image;
-	}
-
-	public Rectangle getSelection() {
-		return selection;
-	}
-
-	@Override
-	public void frameReceived(BufferedImage img) {
-		if (cameraViewFilter != null) {
-			img = cameraViewFilter.filterCameraImage(camera, img);
-		}
-		BufferedImage oldFrame = lastFrame;
-		lastFrame = img;
-		if (oldFrame == null
-				|| (oldFrame.getWidth() != img.getWidth() 
-				|| oldFrame.getHeight() != img.getHeight()
-				|| camera.getUnitsPerPixel() != lastUnitsPerPixel)) {
-			calculateScalingData();
-		}
-		repaint();
-	}
-
-	/**
-	 * Calculates a bunch of scaling data that we cache to speed up painting.
-	 * This is recalculated when the size of the component or the size of the
-	 * source changes. This method is synchronized, along with paintComponent()
-	 * so that the updates to the cached data are atomic.
-	 * TODO: Also need to update if the camera's units per pixels changes.
-	 */
-	private synchronized void calculateScalingData() {
-		BufferedImage image = lastFrame;
-
-		if (image == null) {
-			return;
-		}
-
-		Insets ins = getInsets();
-		int width = getWidth() - ins.left - ins.right;
-		int height = getHeight() - ins.top - ins.bottom;
-
-		double destWidth = width, destHeight = height;
-
-		lastWidth = width;
-		lastHeight = height;
-
-		lastSourceWidth = image.getWidth();
-		lastSourceHeight = image.getHeight();
-
-		double heightRatio = lastSourceHeight / destHeight;
-		double widthRatio = lastSourceWidth / destWidth;
-
-		if (heightRatio > widthRatio) {
-			double aspectRatio = lastSourceWidth / lastSourceHeight;
-			scaledHeight = (int) destHeight;
-			scaledWidth = (int) (scaledHeight * aspectRatio);
-		}
-		else {
-			double aspectRatio = lastSourceHeight / lastSourceWidth;
-			scaledWidth = (int) destWidth;
-			scaledHeight = (int) (scaledWidth * aspectRatio);
-		}
-
-		imageX = ins.left + (width / 2) - (scaledWidth / 2);
-		imageY = ins.top + (height / 2) - (scaledHeight / 2);
-
-		scaleRatioX = lastSourceWidth / (double) scaledWidth;
-		scaleRatioY = lastSourceHeight / (double) scaledHeight;
-
-		lastUnitsPerPixel = camera.getUnitsPerPixel();
-		scaledUnitsPerPixelX = lastUnitsPerPixel.getX() * scaleRatioX;
-		scaledUnitsPerPixelY = lastUnitsPerPixel.getY() * scaleRatioY;
-
-		if (selectionEnabled && selection != null) {
-			// setSelection() handles updating the scaled rectangle
-			setSelection(selection);
-		}
-	}
-
-	@Override
-	protected synchronized void paintComponent(Graphics g) {
-		super.paintComponent(g);
-		BufferedImage image = lastFrame;
-		Insets ins = getInsets();
-		int width = getWidth() - ins.left - ins.right;
-		int height = getHeight() - ins.top - ins.bottom;
-		Graphics2D g2d = (Graphics2D) g;
-		g.setColor(getBackground());
-		g2d.fillRect(ins.left, ins.top, width, height);
-		if (image != null) {
-			// Only render if there is a valid image.
-			g2d.drawImage(lastFrame, imageX, imageY, scaledWidth, scaledHeight,
-					null);
-
-			double c = camera.getLocation().getRotation();
-			
-			for (Reticle reticle : reticles.values()) {
-				reticle.draw(
-						g2d, 
-						camera.getUnitsPerPixel().getUnits(),
-						scaledUnitsPerPixelX, 
-						scaledUnitsPerPixelY, 
-						ins.left + (width / 2), 
-						ins.top + (height / 2),
-						scaledWidth, 
-						scaledHeight,
-						c);
-			}
-			
-			if (text != null) {
-				drawTextOverlay(g2d, 10, 10, text);
-			}
-			
-			if (showImageInfo && text == null) {
-			    drawImageInfo(g2d, 10, 10, image);
-			}
-
-			if (selectionEnabled && selection != null) {
-				paintSelection(g2d);
-			}
-		}
-		else {
-			g.setColor(Color.red);
-			g.drawLine(ins.left, ins.top, ins.right, ins.bottom);
-			g.drawLine(ins.right, ins.top, ins.left, ins.bottom);
-		}
-		
-		if (flashStartTimeMs > 0) {
-			long timeLeft = flashLengthMs - (System.currentTimeMillis() - flashStartTimeMs);
-			float alpha = (1f / flashLengthMs) * timeLeft;
-			alpha = Math.min(alpha, 1);
-			alpha = Math.max(alpha, 0);
-			g2d.setColor(new Color(1f, 1f, 1f, alpha));
-			g2d.fillRect(0, 0, getWidth(), getHeight());
-		}
-	}
-
-	private void paintSelection(Graphics2D g2d) {
-		int rx = selectionScaled.x;
-		int ry = selectionScaled.y;
-		int rw = selectionScaled.width;
-		int rh = selectionScaled.height;
-		int rx2 = rx + rw;
-		int ry2 = ry + rh;
-		int rxc = rx + rw / 2;
-		int ryc = ry + rh / 2;
-
-		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-				RenderingHints.VALUE_ANTIALIAS_ON);
-		// Draw the dashed rectangle, black background, white dashes
-		g2d.setColor(Color.black);
-		g2d.setStroke(new BasicStroke(1f));
-		g2d.drawRect(rx, ry, rw, rh);
-		g2d.setColor(Color.white);
-		g2d.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT,
-				BasicStroke.JOIN_BEVEL, 0, selectionDashProfile,
-				selectionDashPhase));
-		g2d.drawRect(rx, ry, rw, rh);
-
-		if (selectionMode != SelectionMode.Creating) {
-			// If we're not drawing a whole new rectangle, draw the
-			// handles for the existing one.
-			drawHandle(g2d, rx, ry);
-			drawHandle(g2d, rx2, ry);
-			drawHandle(g2d, rx, ry2);
-			drawHandle(g2d, rx2, ry2);
-
-			drawHandle(g2d, rxc, ry);
-			drawHandle(g2d, rx2, ryc);
-			drawHandle(g2d, rxc, ry2);
-			drawHandle(g2d, rx, ryc);
-		}
-
-		if (selectionTextDelegate != null) {
-			String text = selectionTextDelegate.getSelectionText(this);
-			if (text != null) {
-				// TODO: Be awesome like Apple and move the overlay inside
-				// the rect if it goes past the edge of the window
-				drawTextOverlay(g2d, (int) (rx + rw + 6), (int) (ry + rh + 6),
-						text);
-			}
-		}
-
-		if (selectionFlashOpacity > 0) {
-			g2d.setColor(new Color(1.0f, 1.0f, 1.0f, selectionFlashOpacity));
-			g2d.fillRect(rx, ry, rw, rh);
-		}
-	}
-
-	/**
-	 * Draws a standard handle centered on the given x and y position.
-	 * 
-	 * @param g2d
-	 * @param x
-	 * @param y
-	 */
-	private static void drawHandle(Graphics2D g2d, int x, int y) {
-		g2d.setStroke(new BasicStroke(1f));
-		g2d.setColor(new Color(153, 153, 187));
-		g2d.fillArc(x - HANDLE_DIAMETER / 2, y - HANDLE_DIAMETER / 2,
-				HANDLE_DIAMETER, HANDLE_DIAMETER, 0, 360);
-		g2d.setColor(Color.white);
-		g2d.drawArc(x - HANDLE_DIAMETER / 2, y - HANDLE_DIAMETER / 2,
-				HANDLE_DIAMETER, HANDLE_DIAMETER, 0, 360);
-	}
-
-	/**
-	 * Gets the HandlePosition, if any, at the given x and y. Returns null if
-	 * there is not a handle at that position.
-	 * 
-	 * @param x
-	 * @param y
-	 * @return
-	 */
-	private HandlePosition getSelectionHandleAtPosition(int x, int y) {
-		if (selection == null) {
-			return null;
-		}
-
-		int rx = selectionScaled.x;
-		int ry = selectionScaled.y;
-		int rw = selectionScaled.width;
-		int rh = selectionScaled.height;
-		int rx2 = rx + rw;
-		int ry2 = ry + rh;
-		int rxc = rx + rw / 2;
-		int ryc = ry + rh / 2;
-
-		if (isWithinHandle(x, y, rx, ry)) {
-			return HandlePosition.NW;
-		}
-		else if (isWithinHandle(x, y, rx2, ry)) {
-			return HandlePosition.NE;
-		}
-		else if (isWithinHandle(x, y, rx, ry2)) {
-			return HandlePosition.SW;
-		}
-		else if (isWithinHandle(x, y, rx2, ry2)) {
-			return HandlePosition.SE;
-		}
-		else if (isWithinHandle(x, y, rxc, ry)) {
-			return HandlePosition.N;
-		}
-		else if (isWithinHandle(x, y, rx2, ryc)) {
-			return HandlePosition.E;
-		}
-		else if (isWithinHandle(x, y, rxc, ry2)) {
-			return HandlePosition.S;
-		}
-		else if (isWithinHandle(x, y, rx, ryc)) {
-			return HandlePosition.W;
-		}
-		return null;
-	}
-
-	/**
-	 * A specialization of isWithin() that uses uses the bounding box of a
-	 * handle.
-	 * 
-	 * @param x
-	 * @param y
-	 * @param handleX
-	 * @param handleY
-	 * @return
-	 */
-	private static boolean isWithinHandle(int x, int y, int handleX, int handleY) {
-		return isWithin(x, y, handleX - 4, handleY - 4, 8, 8);
-	}
-
-	private static boolean isWithin(int pointX, int pointY, int boundsX,
-			int boundsY, int boundsWidth, int boundsHeight) {
-		return pointX >= boundsX && pointX <= (boundsX + boundsWidth)
-				&& pointY >= boundsY && pointY <= (boundsY + boundsHeight);
-	}
-
-	private static Rectangle normalizeRectangle(Rectangle r) {
-		return normalizeRectangle(r.x, r.y, r.width, r.height);
-	}
-
-	/**
-	 * Builds a rectangle with the given parameters. If the width or height is
-	 * negative the corresponding x or y value is modified and the width or
-	 * height is made positive.
-	 * 
-	 * @param x
-	 * @param y
-	 * @param width
-	 * @param height
-	 * @return
-	 */
-	private static Rectangle normalizeRectangle(int x, int y, int width,
-			int height) {
-		if (width < 0) {
-			width *= -1;
-			x -= width;
-		}
-		if (height < 0) {
-			height *= -1;
-			y -= height;
-		}
-		return new Rectangle(x, y, width, height);
-	}
-
-	/**
-	 * Draws text in a nice bubble at the given position. Newline characters in
-	 * the text cause line breaks.
-	 * 
-	 * @param g2d
-	 * @param topLeftX
-	 * @param topLeftY
-	 * @param text
-	 */
-	private static void drawTextOverlay(Graphics2D g2d, int topLeftX,
-			int topLeftY, String text) {
-		Insets insets = new Insets(10, 10, 10, 10);
-		int interLineSpacing = 4;
-		int cornerRadius = 8;
-		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-				RenderingHints.VALUE_ANTIALIAS_ON);
-		g2d.setStroke(new BasicStroke(1.0f));
-		g2d.setFont(g2d.getFont().deriveFont(12.0f));
-		String[] lines = text.split("\n");
-		List<TextLayout> textLayouts = new ArrayList<>();
-		int textWidth = 0, textHeight = 0;
-		for (String line : lines) {
-			TextLayout textLayout = new TextLayout(line, g2d.getFont(),
-					g2d.getFontRenderContext());
-			textWidth = (int) Math.max(textWidth, textLayout.getBounds()
-					.getWidth());
-			textHeight += (int) textLayout.getBounds().getHeight() + interLineSpacing;
-			textLayouts.add(textLayout);
-		}
-		textHeight -= interLineSpacing;
-		g2d.setColor(new Color(0, 0, 0, 0.75f));
-		g2d.fillRoundRect(
-				topLeftX, 
-				topLeftY, 
-				textWidth + insets.left + insets.right, 
-				textHeight + insets.top + insets.bottom,
-				cornerRadius,
-				cornerRadius);
-		g2d.setColor(Color.white);
-		g2d.drawRoundRect(
-				topLeftX, 
-				topLeftY, 
-				textWidth + insets.left + insets.right, 
-				textHeight + insets.top + insets.bottom,
-				cornerRadius,
-				cornerRadius);
-		int yPen = topLeftY + insets.top;
-		for (TextLayout textLayout : textLayouts) {
-			yPen += textLayout.getBounds().getHeight();
-			textLayout.draw(g2d, topLeftX + insets.left, yPen);
-			yPen += interLineSpacing;
-		}
-	}
-
-    private static void drawImageInfo(Graphics2D g2d, int topLeftX, int topLeftY, BufferedImage image) {
+    private final static Logger logger = LoggerFactory.getLogger(CameraView.class);
+
+    private static final String PREF_RETICLE = "CamerView.reticle";
+
+    private static final String DEFAULT_RETICLE_KEY = "DEFAULT_RETICLE_KEY";
+
+    private final static int HANDLE_DIAMETER = 8;
+
+    private enum HandlePosition {
+        NW, N, NE, E, SE, S, SW, W
+    }
+
+    private enum SelectionMode {
+        Resizing, Moving, Creating
+    }
+
+    /**
+     * The Camera we are viewing.
+     */
+    private Camera camera;
+
+    /**
+     * The last frame received, reported by the Camera.
+     */
+    private BufferedImage lastFrame;
+
+    /**
+     * The maximum frames per second that we'll display.
+     */
+    private int maximumFps;
+
+    private LinkedHashMap<Object, Reticle> reticles = new LinkedHashMap<>();
+
+    private JPopupMenu popupMenu;
+
+    /**
+     * The last width and height of the component that we painted for. If the width or height is
+     * different from these values at the start of paint we'll recalculate all the scaling data.
+     */
+    private double lastWidth, lastHeight;
+
+    /**
+     * The last width and height of the image that we painted for. If the width or height is
+     * different from these values at the start of paint we'll recalculate all the scaling data.
+     */
+    private double lastSourceWidth, lastSourceHeight;
+
+    private Location lastUnitsPerPixel;
+
+    /**
+     * The width and height of the image after it has been scaled to fit the bounds of the
+     * component.
+     */
+    private int scaledWidth, scaledHeight;
+
+    /**
+     * The ratio of scaled width and height to unscaled width and height. scaledWidth * scaleRatioX
+     * = sourceWidth. scaleRatioX = sourceWidth / scaledWidth
+     */
+    private double scaleRatioX, scaleRatioY;
+
+    /**
+     * The Camera's units per pixel scaled at the same ratio as the image. That is, each pixel in
+     * the scaled image is scaledUnitsPerPixelX wide and scaledUnitsPerPixelY high.
+     */
+    private double scaledUnitsPerPixelX, scaledUnitsPerPixelY;
+
+    /**
+     * The top left position within the component at which the scaled image can be drawn for it to
+     * be centered.
+     */
+    private int imageX, imageY;
+
+    private boolean selectionEnabled;
+    /**
+     * Rectangle describing the bounds of the selection in image coordinates.
+     */
+    private Rectangle selection;
+    /**
+     * The scaled version of the selection Rectangle. Rescaled any time the component's size is
+     * changed.
+     */
+    private Rectangle selectionScaled;
+    private SelectionMode selectionMode;
+    private HandlePosition selectionActiveHandle;
+    private int selectionStartX, selectionStartY;
+    private float selectionFlashOpacity;
+    private float selectionDashPhase;
+    private static float[] selectionDashProfile = new float[] {6f, 6f};
+    // 11 is the sum of the dash lengths minus 1.
+    private static float selectionDashPhaseStart = 11f;
+
+    private CameraViewSelectionTextDelegate selectionTextDelegate;
+
+    private ScheduledExecutorService scheduledExecutor;
+
+    private Preferences prefs = Preferences.userNodeForPackage(CameraView.class);
+
+    private String text;
+
+    private boolean showImageInfo;
+
+    private List<CameraViewActionListener> actionListeners = new ArrayList<>();
+
+    private CameraViewFilter cameraViewFilter;
+
+    private long flashStartTimeMs;
+    private long flashLengthMs = 250;
+
+    public CameraView() {
+        setBackground(Color.black);
+        setOpaque(true);
+
+        String reticlePref = prefs.get(PREF_RETICLE, null);
+        try {
+            Reticle reticle = (Reticle) XmlSerialize.deserialize(reticlePref);
+            setDefaultReticle(reticle);
+        }
+        catch (Exception e) {
+            // logger.warn("Warning: Unable to load Reticle preference");
+        }
+
+        popupMenu = new CameraViewPopupMenu(this);
+
+        addMouseListener(mouseListener);
+        addMouseMotionListener(mouseMotionListener);
+        addComponentListener(componentListener);
+
+        scheduledExecutor = Executors.newSingleThreadScheduledExecutor();
+
+        // TODO: Cancel this when it's not being used instead of spinning,
+        // or maybe create a real thread and wait().
+        scheduledExecutor.scheduleAtFixedRate(new Runnable() {
+            public void run() {
+                if (selectionEnabled && selection != null) {
+                    // Adjust the dash phase so the line marches on the next
+                    // paint
+                    selectionDashPhase -= 1f;
+                    if (selectionDashPhase < 0) {
+                        selectionDashPhase = selectionDashPhaseStart;
+                    }
+                    repaint();
+                }
+            }
+        }, 0, 50, TimeUnit.MILLISECONDS);
+    }
+
+    public CameraView(int maximumFps) {
+        this();
+        setMaximumFps(maximumFps);
+    }
+
+    public void addActionListener(CameraViewActionListener listener) {
+        if (!actionListeners.contains(listener)) {
+            actionListeners.add(listener);
+        }
+    }
+
+    public boolean removeActionListener(CameraViewActionListener listener) {
+        return actionListeners.remove(listener);
+    }
+
+    public void setMaximumFps(int maximumFps) {
+        this.maximumFps = maximumFps;
+        // turn off capture for the camera we are replacing, if any
+        if (this.camera != null) {
+            this.camera.stopContinuousCapture(this);
+        }
+        // turn on capture for the new camera
+        if (this.camera != null) {
+            this.camera.startContinuousCapture(this, maximumFps);
+        }
+    }
+
+    public int getMaximumFps() {
+        return maximumFps;
+    }
+
+    public void setCamera(Camera camera) {
+        // turn off capture for the camera we are replacing, if any
+        if (this.camera != null) {
+            this.camera.stopContinuousCapture(this);
+        }
+        this.camera = camera;
+        // turn on capture for the new camera
+        if (this.camera != null) {
+            this.camera.startContinuousCapture(this, maximumFps);
+        }
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    public void setDefaultReticle(Reticle reticle) {
+        setReticle(DEFAULT_RETICLE_KEY, reticle);
+
+        prefs.put(PREF_RETICLE, XmlSerialize.serialize(reticle));
+        try {
+            prefs.flush();
+        }
+        catch (Exception e) {
+
+        }
+    }
+
+    public Reticle getDefaultReticle() {
+        return reticles.get(DEFAULT_RETICLE_KEY);
+    }
+
+    public void setReticle(Object key, Reticle reticle) {
+        if (reticle == null) {
+            removeReticle(key);
+        }
+        else {
+            reticles.put(key, reticle);
+        }
+    }
+
+    public Reticle getReticle(Object key) {
+        return reticles.get(key);
+    }
+
+    public Reticle removeReticle(Object key) {
+        return reticles.remove(key);
+    }
+
+    public CameraViewSelectionTextDelegate getSelectionTextDelegate() {
+        return selectionTextDelegate;
+    }
+
+    public void setSelectionTextDelegate(CameraViewSelectionTextDelegate selectionTextDelegate) {
+        this.selectionTextDelegate = selectionTextDelegate;
+    }
+
+    public String getText() {
+        return text;
+    }
+
+    public void setText(String text) {
+        this.text = text;
+    }
+
+    /**
+     * Causes a short flash in the CameraView to get the user's attention.
+     */
+    public void flash() {
+        flashStartTimeMs = System.currentTimeMillis();
+        scheduledExecutor.scheduleAtFixedRate(new Runnable() {
+            public void run() {
+                if (System.currentTimeMillis() - flashStartTimeMs < flashLengthMs) {
+                    repaint();
+                }
+                else {
+                    flashStartTimeMs = 0;
+                    throw new RuntimeException();
+                }
+            }
+        }, 0, 30, TimeUnit.MILLISECONDS);
+    }
+
+    public void setCameraViewFilter(CameraViewFilter cameraViewFilter) {
+        this.cameraViewFilter = cameraViewFilter;
+    }
+
+    /**
+     * Show image instead of the camera image for milliseconds. After milliseconds elapses the view
+     * goes back to showing the camera image. The image should be the same width and height as the
+     * camera image otherwise the behavior is undefined. This function is intended to be used to
+     * briefly show the result of image processing. This is a shortcut to
+     * setCameraViewFilter(CameraViewFilter) which simply removes itself after the specified time.
+     * 
+     * @param image
+     * @param millseconds
+     */
+    public void showFilteredImage(final BufferedImage filteredImage, final long milliseconds) {
+        setCameraViewFilter(new CameraViewFilter() {
+            long t = System.currentTimeMillis();
+
+            @Override
+            public BufferedImage filterCameraImage(Camera camera, BufferedImage image) {
+                if ((System.currentTimeMillis() - t) < milliseconds) {
+                    return filteredImage;
+                }
+                else {
+                    setCameraViewFilter(null);
+                    return image;
+                }
+            }
+        });
+    }
+
+    public BufferedImage captureSelectionImage() {
+        if (selection == null || lastFrame == null) {
+            return null;
+        }
+
+        selectionFlashOpacity = 1.0f;
+
+        ScheduledFuture future = scheduledExecutor.scheduleAtFixedRate(new Runnable() {
+            public void run() {
+                if (selectionFlashOpacity > 0) {
+                    selectionFlashOpacity -= 0.07;
+                    selectionFlashOpacity = Math.max(0, selectionFlashOpacity);
+                    repaint();
+                }
+                else {
+                    throw new RuntimeException();
+                }
+            }
+        }, 0, 30, TimeUnit.MILLISECONDS);
+
+        int sx = selection.x;
+        int sy = selection.y;
+        int sw = selection.width;
+        int sh = selection.height;
+
+        BufferedImage image = new BufferedImage(sw, sh, BufferedImage.TYPE_INT_ARGB);
+        Graphics g = image.getGraphics();
+        g.drawImage(lastFrame, 0, 0, sw, sh, sx, sy, sx + sw, sy + sh, null);
+        g.dispose();
+
+        while (!future.isDone());
+
+        return image;
+    }
+
+    public Rectangle getSelection() {
+        return selection;
+    }
+
+    @Override
+    public void frameReceived(BufferedImage img) {
+        if (cameraViewFilter != null) {
+            img = cameraViewFilter.filterCameraImage(camera, img);
+        }
+        BufferedImage oldFrame = lastFrame;
+        lastFrame = img;
+        if (oldFrame == null
+                || (oldFrame.getWidth() != img.getWidth() || oldFrame.getHeight() != img.getHeight()
+                        || camera.getUnitsPerPixel() != lastUnitsPerPixel)) {
+            calculateScalingData();
+        }
+        repaint();
+    }
+
+    /**
+     * Calculates a bunch of scaling data that we cache to speed up painting. This is recalculated
+     * when the size of the component or the size of the source changes. This method is
+     * synchronized, along with paintComponent() so that the updates to the cached data are atomic.
+     */
+    private synchronized void calculateScalingData() {
+        BufferedImage image = lastFrame;
+
+        if (image == null) {
+            return;
+        }
+
+        Insets ins = getInsets();
+        int width = getWidth() - ins.left - ins.right;
+        int height = getHeight() - ins.top - ins.bottom;
+
+        double destWidth = width, destHeight = height;
+
+        lastWidth = width;
+        lastHeight = height;
+
+        lastSourceWidth = image.getWidth();
+        lastSourceHeight = image.getHeight();
+
+        double heightRatio = lastSourceHeight / destHeight;
+        double widthRatio = lastSourceWidth / destWidth;
+
+        if (heightRatio > widthRatio) {
+            double aspectRatio = lastSourceWidth / lastSourceHeight;
+            scaledHeight = (int) destHeight;
+            scaledWidth = (int) (scaledHeight * aspectRatio);
+        }
+        else {
+            double aspectRatio = lastSourceHeight / lastSourceWidth;
+            scaledWidth = (int) destWidth;
+            scaledHeight = (int) (scaledWidth * aspectRatio);
+        }
+
+        imageX = ins.left + (width / 2) - (scaledWidth / 2);
+        imageY = ins.top + (height / 2) - (scaledHeight / 2);
+
+        scaleRatioX = lastSourceWidth / (double) scaledWidth;
+        scaleRatioY = lastSourceHeight / (double) scaledHeight;
+
+        lastUnitsPerPixel = camera.getUnitsPerPixel();
+        scaledUnitsPerPixelX = lastUnitsPerPixel.getX() * scaleRatioX;
+        scaledUnitsPerPixelY = lastUnitsPerPixel.getY() * scaleRatioY;
+
+        if (selectionEnabled && selection != null) {
+            // setSelection() handles updating the scaled rectangle
+            setSelection(selection);
+        }
+    }
+
+    @Override
+    protected synchronized void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        BufferedImage image = lastFrame;
+        Insets ins = getInsets();
+        int width = getWidth() - ins.left - ins.right;
+        int height = getHeight() - ins.top - ins.bottom;
+        Graphics2D g2d = (Graphics2D) g;
+        g.setColor(getBackground());
+        g2d.fillRect(ins.left, ins.top, width, height);
+        if (image != null) {
+            // Only render if there is a valid image.
+            g2d.drawImage(lastFrame, imageX, imageY, scaledWidth, scaledHeight, null);
+
+            double c = camera.getLocation().getRotation();
+
+            for (Reticle reticle : reticles.values()) {
+                reticle.draw(g2d, camera.getUnitsPerPixel().getUnits(), scaledUnitsPerPixelX,
+                        scaledUnitsPerPixelY, ins.left + (width / 2), ins.top + (height / 2),
+                        scaledWidth, scaledHeight, c);
+            }
+
+            if (text != null) {
+                drawTextOverlay(g2d, 10, 10, text);
+            }
+
+            if (showImageInfo && text == null) {
+                drawImageInfo(g2d, 10, 10, image);
+            }
+
+            if (selectionEnabled && selection != null) {
+                paintSelection(g2d);
+            }
+        }
+        else {
+            g.setColor(Color.red);
+            g.drawLine(ins.left, ins.top, ins.right, ins.bottom);
+            g.drawLine(ins.right, ins.top, ins.left, ins.bottom);
+        }
+
+        if (flashStartTimeMs > 0) {
+            long timeLeft = flashLengthMs - (System.currentTimeMillis() - flashStartTimeMs);
+            float alpha = (1f / flashLengthMs) * timeLeft;
+            alpha = Math.min(alpha, 1);
+            alpha = Math.max(alpha, 0);
+            g2d.setColor(new Color(1f, 1f, 1f, alpha));
+            g2d.fillRect(0, 0, getWidth(), getHeight());
+        }
+    }
+
+    private void paintSelection(Graphics2D g2d) {
+        int rx = selectionScaled.x;
+        int ry = selectionScaled.y;
+        int rw = selectionScaled.width;
+        int rh = selectionScaled.height;
+        int rx2 = rx + rw;
+        int ry2 = ry + rh;
+        int rxc = rx + rw / 2;
+        int ryc = ry + rh / 2;
+
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        // Draw the dashed rectangle, black background, white dashes
+        g2d.setColor(Color.black);
+        g2d.setStroke(new BasicStroke(1f));
+        g2d.drawRect(rx, ry, rw, rh);
+        g2d.setColor(Color.white);
+        g2d.setStroke(new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0,
+                selectionDashProfile, selectionDashPhase));
+        g2d.drawRect(rx, ry, rw, rh);
+
+        if (selectionMode != SelectionMode.Creating) {
+            // If we're not drawing a whole new rectangle, draw the
+            // handles for the existing one.
+            drawHandle(g2d, rx, ry);
+            drawHandle(g2d, rx2, ry);
+            drawHandle(g2d, rx, ry2);
+            drawHandle(g2d, rx2, ry2);
+
+            drawHandle(g2d, rxc, ry);
+            drawHandle(g2d, rx2, ryc);
+            drawHandle(g2d, rxc, ry2);
+            drawHandle(g2d, rx, ryc);
+        }
+
+        if (selectionTextDelegate != null) {
+            String text = selectionTextDelegate.getSelectionText(this);
+            if (text != null) {
+                // TODO: Be awesome like Apple and move the overlay inside
+                // the rect if it goes past the edge of the window
+                drawTextOverlay(g2d, (int) (rx + rw + 6), (int) (ry + rh + 6), text);
+            }
+        }
+
+        if (selectionFlashOpacity > 0) {
+            g2d.setColor(new Color(1.0f, 1.0f, 1.0f, selectionFlashOpacity));
+            g2d.fillRect(rx, ry, rw, rh);
+        }
+    }
+
+    /**
+     * Draws a standard handle centered on the given x and y position.
+     * 
+     * @param g2d
+     * @param x
+     * @param y
+     */
+    private static void drawHandle(Graphics2D g2d, int x, int y) {
+        g2d.setStroke(new BasicStroke(1f));
+        g2d.setColor(new Color(153, 153, 187));
+        g2d.fillArc(x - HANDLE_DIAMETER / 2, y - HANDLE_DIAMETER / 2, HANDLE_DIAMETER,
+                HANDLE_DIAMETER, 0, 360);
+        g2d.setColor(Color.white);
+        g2d.drawArc(x - HANDLE_DIAMETER / 2, y - HANDLE_DIAMETER / 2, HANDLE_DIAMETER,
+                HANDLE_DIAMETER, 0, 360);
+    }
+
+    /**
+     * Gets the HandlePosition, if any, at the given x and y. Returns null if there is not a handle
+     * at that position.
+     * 
+     * @param x
+     * @param y
+     * @return
+     */
+    private HandlePosition getSelectionHandleAtPosition(int x, int y) {
+        if (selection == null) {
+            return null;
+        }
+
+        int rx = selectionScaled.x;
+        int ry = selectionScaled.y;
+        int rw = selectionScaled.width;
+        int rh = selectionScaled.height;
+        int rx2 = rx + rw;
+        int ry2 = ry + rh;
+        int rxc = rx + rw / 2;
+        int ryc = ry + rh / 2;
+
+        if (isWithinHandle(x, y, rx, ry)) {
+            return HandlePosition.NW;
+        }
+        else if (isWithinHandle(x, y, rx2, ry)) {
+            return HandlePosition.NE;
+        }
+        else if (isWithinHandle(x, y, rx, ry2)) {
+            return HandlePosition.SW;
+        }
+        else if (isWithinHandle(x, y, rx2, ry2)) {
+            return HandlePosition.SE;
+        }
+        else if (isWithinHandle(x, y, rxc, ry)) {
+            return HandlePosition.N;
+        }
+        else if (isWithinHandle(x, y, rx2, ryc)) {
+            return HandlePosition.E;
+        }
+        else if (isWithinHandle(x, y, rxc, ry2)) {
+            return HandlePosition.S;
+        }
+        else if (isWithinHandle(x, y, rx, ryc)) {
+            return HandlePosition.W;
+        }
+        return null;
+    }
+
+    /**
+     * A specialization of isWithin() that uses uses the bounding box of a handle.
+     * 
+     * @param x
+     * @param y
+     * @param handleX
+     * @param handleY
+     * @return
+     */
+    private static boolean isWithinHandle(int x, int y, int handleX, int handleY) {
+        return isWithin(x, y, handleX - 4, handleY - 4, 8, 8);
+    }
+
+    private static boolean isWithin(int pointX, int pointY, int boundsX, int boundsY,
+            int boundsWidth, int boundsHeight) {
+        return pointX >= boundsX && pointX <= (boundsX + boundsWidth) && pointY >= boundsY
+                && pointY <= (boundsY + boundsHeight);
+    }
+
+    private static Rectangle normalizeRectangle(Rectangle r) {
+        return normalizeRectangle(r.x, r.y, r.width, r.height);
+    }
+
+    /**
+     * Builds a rectangle with the given parameters. If the width or height is negative the
+     * corresponding x or y value is modified and the width or height is made positive.
+     * 
+     * @param x
+     * @param y
+     * @param width
+     * @param height
+     * @return
+     */
+    private static Rectangle normalizeRectangle(int x, int y, int width, int height) {
+        if (width < 0) {
+            width *= -1;
+            x -= width;
+        }
+        if (height < 0) {
+            height *= -1;
+            y -= height;
+        }
+        return new Rectangle(x, y, width, height);
+    }
+
+    /**
+     * Draws text in a nice bubble at the given position. Newline characters in the text cause line
+     * breaks.
+     * 
+     * @param g2d
+     * @param topLeftX
+     * @param topLeftY
+     * @param text
+     */
+    private static void drawTextOverlay(Graphics2D g2d, int topLeftX, int topLeftY, String text) {
+        Insets insets = new Insets(10, 10, 10, 10);
+        int interLineSpacing = 4;
+        int cornerRadius = 8;
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setStroke(new BasicStroke(1.0f));
+        g2d.setFont(g2d.getFont().deriveFont(12.0f));
+        String[] lines = text.split("\n");
+        List<TextLayout> textLayouts = new ArrayList<>();
+        int textWidth = 0, textHeight = 0;
+        for (String line : lines) {
+            TextLayout textLayout = new TextLayout(line, g2d.getFont(), g2d.getFontRenderContext());
+            textWidth = (int) Math.max(textWidth, textLayout.getBounds().getWidth());
+            textHeight += (int) textLayout.getBounds().getHeight() + interLineSpacing;
+            textLayouts.add(textLayout);
+        }
+        textHeight -= interLineSpacing;
+        g2d.setColor(new Color(0, 0, 0, 0.75f));
+        g2d.fillRoundRect(topLeftX, topLeftY, textWidth + insets.left + insets.right,
+                textHeight + insets.top + insets.bottom, cornerRadius, cornerRadius);
+        g2d.setColor(Color.white);
+        g2d.drawRoundRect(topLeftX, topLeftY, textWidth + insets.left + insets.right,
+                textHeight + insets.top + insets.bottom, cornerRadius, cornerRadius);
+        int yPen = topLeftY + insets.top;
+        for (TextLayout textLayout : textLayouts) {
+            yPen += textLayout.getBounds().getHeight();
+            textLayout.draw(g2d, topLeftX + insets.left, yPen);
+            yPen += interLineSpacing;
+        }
+    }
+
+    private static void drawImageInfo(Graphics2D g2d, int topLeftX, int topLeftY,
+            BufferedImage image) {
         if (image == null) {
-        	return;
+            return;
         }
-    	String text = String.format("Resolution: %d x %d\nHistogram:",
-                image.getWidth(), 
+        String text = String.format("Resolution: %d x %d\nHistogram:", image.getWidth(),
                 image.getHeight());
         Insets insets = new Insets(10, 10, 10, 10);
         int interLineSpacing = 4;
         int cornerRadius = 8;
-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-                RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g2d.setStroke(new BasicStroke(1.0f));
         g2d.setFont(g2d.getFont().deriveFont(12.0f));
         String[] lines = text.split("\n");
         List<TextLayout> textLayouts = new ArrayList<>();
         int textWidth = 0, textHeight = 0;
         for (String line : lines) {
-            TextLayout textLayout = new TextLayout(line, g2d.getFont(),
-                    g2d.getFontRenderContext());
-            textWidth = (int) Math.max(textWidth, textLayout.getBounds()
-                    .getWidth());
+            TextLayout textLayout = new TextLayout(line, g2d.getFont(), g2d.getFontRenderContext());
+            textWidth = (int) Math.max(textWidth, textLayout.getBounds().getWidth());
             textHeight += (int) textLayout.getBounds().getHeight() + interLineSpacing;
             textLayouts.add(textLayout);
         }
         textHeight -= interLineSpacing;
-        
+
         int histogramHeight = 50 + 2;
         int histogramWidth = 255 + 2;
-        
+
         int width = Math.max(textWidth, histogramWidth);
         int height = textHeight + histogramHeight;
-        
+
         g2d.setColor(new Color(0, 0, 0, 0.75f));
-        g2d.fillRoundRect(
-                topLeftX, 
-                topLeftY, 
-                width + insets.left + insets.right, 
-                height + insets.top + insets.bottom,
-                cornerRadius,
-                cornerRadius);
+        g2d.fillRoundRect(topLeftX, topLeftY, width + insets.left + insets.right,
+                height + insets.top + insets.bottom, cornerRadius, cornerRadius);
         g2d.setColor(Color.white);
-        g2d.drawRoundRect(
-                topLeftX, 
-                topLeftY, 
-                width + insets.left + insets.right, 
-                height + insets.top + insets.bottom,
-                cornerRadius,
-                cornerRadius);
+        g2d.drawRoundRect(topLeftX, topLeftY, width + insets.left + insets.right,
+                height + insets.top + insets.bottom, cornerRadius, cornerRadius);
         int yPen = topLeftY + insets.top;
         for (TextLayout textLayout : textLayouts) {
             yPen += textLayout.getBounds().getHeight();
             textLayout.draw(g2d, topLeftX + insets.left, yPen);
             yPen += interLineSpacing;
         }
-        
+
         g2d.setColor(new Color(1, 1, 1, 0.20f));
-        g2d.fillRect(
-            topLeftX + insets.left,
-            yPen,
-            histogramWidth,
-            histogramHeight);
-        
+        g2d.fillRect(topLeftX + insets.left, yPen, histogramWidth, histogramHeight);
+
         // Calculate the histogram
         long[][] histogram = new long[3][256];
         for (int y = 0; y < image.getHeight(); y++) {
@@ -852,155 +787,146 @@ private static void drawImageInfo(Graphics2D g2d, int topLeftX, int topLeftY, Bu
         }
         // and scale it to 50 pixels tall
         double scale = 50.0 / maxVal;
-        Color[] colors = new Color[] {
-                Color.red,
-                Color.green,
-                Color.blue
-        };
+        Color[] colors = new Color[] {Color.red, Color.green, Color.blue};
         for (int channel = 0; channel < 3; channel++) {
             g2d.setColor(colors[channel]);
             for (int bucket = 0; bucket < 256; bucket++) {
                 int value = (int) (histogram[channel][bucket] * scale);
-                g2d.drawLine(
-                        topLeftX + insets.left + 1 + bucket,
-                        yPen + 1 + 50 - value,
-                        topLeftX + insets.left + 1 + bucket,
-                        yPen + 1 + 50 - value);
+                g2d.drawLine(topLeftX + insets.left + 1 + bucket, yPen + 1 + 50 - value,
+                        topLeftX + insets.left + 1 + bucket, yPen + 1 + 50 - value);
             }
         }
     }
 
-	/**
-	 * Changes the HandlePosition to it's inverse if the given rectangle has a
-	 * negative width, height or both.
-	 * 
-	 * @param r
-	 */
-	private static HandlePosition getOpposingHandle(Rectangle r,
-			HandlePosition handlePosition) {
-		if (r.getWidth() < 0 && r.getHeight() < 0) {
-			if (handlePosition == HandlePosition.NW) {
-				return HandlePosition.SE;
-			}
-			else if (handlePosition == HandlePosition.NE) {
-				return HandlePosition.SW;
-			}
-			else if (handlePosition == HandlePosition.SE) {
-				return HandlePosition.NW;
-			}
-			else if (handlePosition == HandlePosition.SW) {
-				return HandlePosition.NE;
-			}
-		}
-		else if (r.getWidth() < 0) {
-			if (handlePosition == HandlePosition.NW) {
-				return HandlePosition.NE;
-			}
-			else if (handlePosition == HandlePosition.NE) {
-				return HandlePosition.NW;
-			}
-			else if (handlePosition == HandlePosition.SE) {
-				return HandlePosition.SW;
-			}
-			else if (handlePosition == HandlePosition.SW) {
-				return HandlePosition.SE;
-			}
-			else if (handlePosition == HandlePosition.E) {
-				return HandlePosition.W;
-			}
-			else if (handlePosition == HandlePosition.W) {
-				return HandlePosition.E;
-			}
-		}
-		else if (r.getHeight() < 0) {
-			if (handlePosition == HandlePosition.SW) {
-				return HandlePosition.NW;
-			}
-			else if (handlePosition == HandlePosition.SE) {
-				return HandlePosition.NE;
-			}
-			else if (handlePosition == HandlePosition.NW) {
-				return HandlePosition.SW;
-			}
-			else if (handlePosition == HandlePosition.NE) {
-				return HandlePosition.SE;
-			}
-			else if (handlePosition == HandlePosition.S) {
-				return HandlePosition.N;
-			}
-			else if (handlePosition == HandlePosition.N) {
-				return HandlePosition.S;
-			}
-		}
-		return handlePosition;
-	}
-
-	/**
-	 * Set the selection rectangle in image coordinates.
-	 * 
-	 * @param x
-	 * @param y
-	 * @param width
-	 * @param height
-	 */
-	public void setSelection(int x, int y, int width, int height) {
-		setSelection(new Rectangle(x, y, width, height));
-	}
-
-	/**
-	 * Set the selection rectangle in image coordinates.
-	 * 
-	 * @param r
-	 */
-	public void setSelection(Rectangle r) {
-		if (r == null) {
-			selection = null;
-			selectionMode = null;
-		}
-		else {
-			selectionActiveHandle = getOpposingHandle(r, selectionActiveHandle);
-			selection = normalizeRectangle(r);
-
-			int rx = (int) (imageX + selection.x / scaleRatioX);
-			int ry = (int) (imageY + selection.y / scaleRatioY);
-			int rw = (int) (selection.width / scaleRatioX);
-			int rh = (int) (selection.height / scaleRatioY);
-			selectionScaled = new Rectangle(rx, ry, rw, rh);
-		}
-	}
-
-	/**
-	 * Set the selection rectangle in component coordinates. Updates the
-	 * selection property with the properly scaled coordinates.
-	 * 
-	 * @param x
-	 * @param y
-	 * @param width
-	 * @param height
-	 */
-	private void setScaledSelection(int x, int y, int width, int height) {
-		selectionScaled = new Rectangle(x, y, width, height);
-		selectionActiveHandle = getOpposingHandle(selectionScaled,
-				selectionActiveHandle);
-		selectionScaled = normalizeRectangle(selectionScaled);
-
-		int rx = (int) ((x - imageX) * scaleRatioX);
-		int ry = (int) ((y - imageY) * scaleRatioY);
-		int rw = (int) (width * scaleRatioX);
-		int rh = (int) (height * scaleRatioY);
-
-		selection = new Rectangle(rx, ry, rw, rh);
-	}
-
-	public boolean isSelectionEnabled() {
-		return selectionEnabled;
-	}
-
-	public void setSelectionEnabled(boolean selectionEnabled) {
-		this.selectionEnabled = selectionEnabled;
-	}
-	
-	public boolean isShowImageInfo() {
+    /**
+     * Changes the HandlePosition to it's inverse if the given rectangle has a negative width,
+     * height or both.
+     * 
+     * @param r
+     */
+    private static HandlePosition getOpposingHandle(Rectangle r, HandlePosition handlePosition) {
+        if (r.getWidth() < 0 && r.getHeight() < 0) {
+            if (handlePosition == HandlePosition.NW) {
+                return HandlePosition.SE;
+            }
+            else if (handlePosition == HandlePosition.NE) {
+                return HandlePosition.SW;
+            }
+            else if (handlePosition == HandlePosition.SE) {
+                return HandlePosition.NW;
+            }
+            else if (handlePosition == HandlePosition.SW) {
+                return HandlePosition.NE;
+            }
+        }
+        else if (r.getWidth() < 0) {
+            if (handlePosition == HandlePosition.NW) {
+                return HandlePosition.NE;
+            }
+            else if (handlePosition == HandlePosition.NE) {
+                return HandlePosition.NW;
+            }
+            else if (handlePosition == HandlePosition.SE) {
+                return HandlePosition.SW;
+            }
+            else if (handlePosition == HandlePosition.SW) {
+                return HandlePosition.SE;
+            }
+            else if (handlePosition == HandlePosition.E) {
+                return HandlePosition.W;
+            }
+            else if (handlePosition == HandlePosition.W) {
+                return HandlePosition.E;
+            }
+        }
+        else if (r.getHeight() < 0) {
+            if (handlePosition == HandlePosition.SW) {
+                return HandlePosition.NW;
+            }
+            else if (handlePosition == HandlePosition.SE) {
+                return HandlePosition.NE;
+            }
+            else if (handlePosition == HandlePosition.NW) {
+                return HandlePosition.SW;
+            }
+            else if (handlePosition == HandlePosition.NE) {
+                return HandlePosition.SE;
+            }
+            else if (handlePosition == HandlePosition.S) {
+                return HandlePosition.N;
+            }
+            else if (handlePosition == HandlePosition.N) {
+                return HandlePosition.S;
+            }
+        }
+        return handlePosition;
+    }
+
+    /**
+     * Set the selection rectangle in image coordinates.
+     * 
+     * @param x
+     * @param y
+     * @param width
+     * @param height
+     */
+    public void setSelection(int x, int y, int width, int height) {
+        setSelection(new Rectangle(x, y, width, height));
+    }
+
+    /**
+     * Set the selection rectangle in image coordinates.
+     * 
+     * @param r
+     */
+    public void setSelection(Rectangle r) {
+        if (r == null) {
+            selection = null;
+            selectionMode = null;
+        }
+        else {
+            selectionActiveHandle = getOpposingHandle(r, selectionActiveHandle);
+            selection = normalizeRectangle(r);
+
+            int rx = (int) (imageX + selection.x / scaleRatioX);
+            int ry = (int) (imageY + selection.y / scaleRatioY);
+            int rw = (int) (selection.width / scaleRatioX);
+            int rh = (int) (selection.height / scaleRatioY);
+            selectionScaled = new Rectangle(rx, ry, rw, rh);
+        }
+    }
+
+    /**
+     * Set the selection rectangle in component coordinates. Updates the selection property with the
+     * properly scaled coordinates.
+     * 
+     * @param x
+     * @param y
+     * @param width
+     * @param height
+     */
+    private void setScaledSelection(int x, int y, int width, int height) {
+        selectionScaled = new Rectangle(x, y, width, height);
+        selectionActiveHandle = getOpposingHandle(selectionScaled, selectionActiveHandle);
+        selectionScaled = normalizeRectangle(selectionScaled);
+
+        int rx = (int) ((x - imageX) * scaleRatioX);
+        int ry = (int) ((y - imageY) * scaleRatioY);
+        int rw = (int) (width * scaleRatioX);
+        int rh = (int) (height * scaleRatioY);
+
+        selection = new Rectangle(rx, ry, rw, rh);
+    }
+
+    public boolean isSelectionEnabled() {
+        return selectionEnabled;
+    }
+
+    public void setSelectionEnabled(boolean selectionEnabled) {
+        this.selectionEnabled = selectionEnabled;
+    }
+
+    public boolean isShowImageInfo() {
         return showImageInfo;
     }
 
@@ -1008,88 +934,85 @@ public void setShowImageInfo(boolean showImageInfo) {
         this.showImageInfo = showImageInfo;
     }
 
-    public static Cursor getCursorForHandlePosition(
-			HandlePosition handlePosition) {
-		switch (handlePosition) {
-		case NW:
-			return Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR);
-		case N:
-			return Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR);
-		case NE:
-			return Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR);
-		case E:
-			return Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR);
-		case SE:
-			return Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR);
-		case S:
-			return Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR);
-		case SW:
-			return Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR);
-		case W:
-			return Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR);
-		}
-		return null;
-	}
-
-	/**
-	 * Updates the Cursor to reflect the current state of the component.
-	 */
-	private void updateCursor() {
-		if (selectionEnabled) {
-			if (selectionMode == SelectionMode.Moving) {
-				setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
-			}
-			else if (selectionMode == SelectionMode.Resizing) {
-				setCursor(getCursorForHandlePosition(selectionActiveHandle));
-			}
-			else if (selectionMode == null && selection != null) {
-				int x = getMousePosition().x;
-				int y = getMousePosition().y;
-
-				HandlePosition handlePosition = getSelectionHandleAtPosition(x,
-						y);
-				if (handlePosition != null) {
-					setCursor(getCursorForHandlePosition(handlePosition));
-				}
-				else if (selectionScaled.contains(x, y)) {
-					setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
-				}
-				else {
-					setCursor(Cursor
-							.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
-				}
-			}
-			else {
-				setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
-			}
-		}
-		else {
-			setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
-		}
-	}
-	
-	/**
-	 * Capture the current image (unscaled, unmodified) and write it to disk.
-	 */
-	private void captureSnapshot() {
-		try {
-			flash();
-			File dir = new File(Configuration.get().getConfigurationDirectory(), "snapshots");
-			dir.mkdirs();
-			DateFormat df = new SimpleDateFormat("YYYY-MM-dd_HH.mm.ss.SSS");
-			File file = new File(dir, camera.getName() + "_" + df.format(new Date()) + ".png");
-			ImageIO.write(lastFrame, "png", file);
-		}
-		catch (Exception e1) {
-			e1.printStackTrace();
-		}
-	}
-	
-	private void fireActionEvent(MouseEvent e) {
-		if (actionListeners.isEmpty()) {
-			return;
-		}
-		
+    public static Cursor getCursorForHandlePosition(HandlePosition handlePosition) {
+        switch (handlePosition) {
+            case NW:
+                return Cursor.getPredefinedCursor(Cursor.NW_RESIZE_CURSOR);
+            case N:
+                return Cursor.getPredefinedCursor(Cursor.N_RESIZE_CURSOR);
+            case NE:
+                return Cursor.getPredefinedCursor(Cursor.NE_RESIZE_CURSOR);
+            case E:
+                return Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR);
+            case SE:
+                return Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR);
+            case S:
+                return Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR);
+            case SW:
+                return Cursor.getPredefinedCursor(Cursor.SW_RESIZE_CURSOR);
+            case W:
+                return Cursor.getPredefinedCursor(Cursor.W_RESIZE_CURSOR);
+        }
+        return null;
+    }
+
+    /**
+     * Updates the Cursor to reflect the current state of the component.
+     */
+    private void updateCursor() {
+        if (selectionEnabled) {
+            if (selectionMode == SelectionMode.Moving) {
+                setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
+            }
+            else if (selectionMode == SelectionMode.Resizing) {
+                setCursor(getCursorForHandlePosition(selectionActiveHandle));
+            }
+            else if (selectionMode == null && selection != null) {
+                int x = getMousePosition().x;
+                int y = getMousePosition().y;
+
+                HandlePosition handlePosition = getSelectionHandleAtPosition(x, y);
+                if (handlePosition != null) {
+                    setCursor(getCursorForHandlePosition(handlePosition));
+                }
+                else if (selectionScaled.contains(x, y)) {
+                    setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
+                }
+                else {
+                    setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
+                }
+            }
+            else {
+                setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
+            }
+        }
+        else {
+            setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
+        }
+    }
+
+    /**
+     * Capture the current image (unscaled, unmodified) and write it to disk.
+     */
+    private void captureSnapshot() {
+        try {
+            flash();
+            File dir = new File(Configuration.get().getConfigurationDirectory(), "snapshots");
+            dir.mkdirs();
+            DateFormat df = new SimpleDateFormat("YYYY-MM-dd_HH.mm.ss.SSS");
+            File file = new File(dir, camera.getName() + "_" + df.format(new Date()) + ".png");
+            ImageIO.write(lastFrame, "png", file);
+        }
+        catch (Exception e1) {
+            e1.printStackTrace();
+        }
+    }
+
+    private void fireActionEvent(MouseEvent e) {
+        if (actionListeners.isEmpty()) {
+            return;
+        }
+
         int x = e.getX();
         int y = e.getY();
 
@@ -1111,23 +1034,18 @@ private void fireActionEvent(MouseEvent e) {
 
         // Create a location in the Camera's units per pixel's units
         // and with the values of the offsets.
-        Location offsets = camera.getUnitsPerPixel().derive(offsetX,
-                offsetY, 0.0, 0.0);
+        Location offsets = camera.getUnitsPerPixel().derive(offsetX, offsetY, 0.0, 0.0);
         // Add the offsets to the Camera's position.
         Location location = camera.getLocation().add(offsets);
-		CameraViewActionEvent action = new CameraViewActionEvent(
-				CameraView.this, 
-				e.getX(), 
-				e.getY(), 
-				e.getX() * scaledUnitsPerPixelX, 
-				e.getY() * scaledUnitsPerPixelY,
-				location);
-		for (CameraViewActionListener listener : new ArrayList<>(actionListeners)) {
-			listener.actionPerformed(action);
-		}
-	}
-	
-	private void moveToClick(MouseEvent e) {
+        CameraViewActionEvent action =
+                new CameraViewActionEvent(CameraView.this, e.getX(), e.getY(),
+                        e.getX() * scaledUnitsPerPixelX, e.getY() * scaledUnitsPerPixelY, location);
+        for (CameraViewActionListener listener : new ArrayList<>(actionListeners)) {
+            listener.actionPerformed(action);
+        }
+    }
+
+    private void moveToClick(MouseEvent e) {
         int x = e.getX();
         int y = e.getY();
 
@@ -1149,33 +1067,30 @@ private void moveToClick(MouseEvent e) {
 
         // Create a location in the Camera's units per pixel's units
         // and with the values of the offsets.
-        Location offsets = camera.getUnitsPerPixel().derive(offsetX,
-                offsetY, 0.0, 0.0);
+        Location offsets = camera.getUnitsPerPixel().derive(offsetX, offsetY, 0.0, 0.0);
         // Add the offsets to the Camera's position.
         Location location = camera.getLocation().add(offsets);
         // And move there.
         UiUtils.submitUiMachineTask(() -> {
             MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
         });
-	}
-	
-	private void beginSelection(MouseEvent e) {
+    }
+
+    private void beginSelection(MouseEvent e) {
         // If we're not doing anything currently, we can start
         // a new operation.
         if (selectionMode == null) {
             int x = e.getX();
             int y = e.getY();
-            
+
             // See if there is a handle under the cursor.
-            HandlePosition handlePosition = getSelectionHandleAtPosition(
-                    x, y);
+            HandlePosition handlePosition = getSelectionHandleAtPosition(x, y);
             if (handlePosition != null) {
                 selectionMode = SelectionMode.Resizing;
                 selectionActiveHandle = handlePosition;
             }
             // If not, perhaps they want to move the rectangle
-            else if (selection != null
-                    && selectionScaled.contains(x, y)) {
+            else if (selection != null && selectionScaled.contains(x, y)) {
 
                 selectionMode = SelectionMode.Moving;
                 // Store the distance between the rectangle's origin and
@@ -1190,82 +1105,78 @@ else if (selection != null
                 selectionStartY = y;
             }
         }
-	}
-	
-	private void continueSelection(MouseEvent e) {
-		int x = e.getX();
-		int y = e.getY();
-
-		if (selectionMode == SelectionMode.Resizing) {
-			int rx = selectionScaled.x;
-			int ry = selectionScaled.y;
-			int rw = selectionScaled.width;
-			int rh = selectionScaled.height;
-
-			if (selectionActiveHandle == HandlePosition.NW) {
-				setScaledSelection(x, y, (rw - (x - rx)),
-						(rh - (y - ry)));
-			}
-			else if (selectionActiveHandle == HandlePosition.NE) {
-				setScaledSelection(rx, y, x - rx, (rh - (y - ry)));
-			}
-			else if (selectionActiveHandle == HandlePosition.N) {
-				setScaledSelection(rx, y, rw, (rh - (y - ry)));
-			}
-			else if (selectionActiveHandle == HandlePosition.E) {
-				setScaledSelection(rx, ry, rw + (x - (rx + rw)), rh);
-			}
-			else if (selectionActiveHandle == HandlePosition.SE) {
-				setScaledSelection(rx, ry, rw + (x - (rx + rw)), rh
-						+ (y - (ry + rh)));
-			}
-			else if (selectionActiveHandle == HandlePosition.S) {
-				setScaledSelection(rx, ry, rw, rh + (y - (ry + rh)));
-			}
-			else if (selectionActiveHandle == HandlePosition.SW) {
-				setScaledSelection(x, ry, (rw - (x - rx)), rh
-						+ (y - (ry + rh)));
-			}
-			else if (selectionActiveHandle == HandlePosition.W) {
-				setScaledSelection(x, ry, (rw - (x - rx)), rh);
-			}
-		}
-		else if (selectionMode == SelectionMode.Moving) {
-			setScaledSelection(x - selectionStartX,
-					y - selectionStartY, selectionScaled.width,
-					selectionScaled.height);
-		}
-		else if (selectionMode == SelectionMode.Creating) {
-			int sx = selectionStartX;
-			int sy = selectionStartY;
-			int w = x - sx;
-			int h = y - sy;
-			setScaledSelection(sx, sy, w, h);
-		}
-		updateCursor();
-		repaint();
-	}
-	
-	private void endSelection() {
-		selectionMode = null;
-		selectionActiveHandle = null;
-	}
-
-	private MouseListener mouseListener = new MouseAdapter() {
-		@Override
-		public void mouseClicked(MouseEvent e) {
-			if (e.isPopupTrigger() || e.isShiftDown() || SwingUtilities.isRightMouseButton(e)) {
-				return;
-			}
-			// double click captures an image from the camera and writes it to disk. 
-			if (e.getClickCount() == 2) {
-				captureSnapshot();
-			}
-			else {
-				fireActionEvent(e);
-			}
-		}
-		
+    }
+
+    private void continueSelection(MouseEvent e) {
+        int x = e.getX();
+        int y = e.getY();
+
+        if (selectionMode == SelectionMode.Resizing) {
+            int rx = selectionScaled.x;
+            int ry = selectionScaled.y;
+            int rw = selectionScaled.width;
+            int rh = selectionScaled.height;
+
+            if (selectionActiveHandle == HandlePosition.NW) {
+                setScaledSelection(x, y, (rw - (x - rx)), (rh - (y - ry)));
+            }
+            else if (selectionActiveHandle == HandlePosition.NE) {
+                setScaledSelection(rx, y, x - rx, (rh - (y - ry)));
+            }
+            else if (selectionActiveHandle == HandlePosition.N) {
+                setScaledSelection(rx, y, rw, (rh - (y - ry)));
+            }
+            else if (selectionActiveHandle == HandlePosition.E) {
+                setScaledSelection(rx, ry, rw + (x - (rx + rw)), rh);
+            }
+            else if (selectionActiveHandle == HandlePosition.SE) {
+                setScaledSelection(rx, ry, rw + (x - (rx + rw)), rh + (y - (ry + rh)));
+            }
+            else if (selectionActiveHandle == HandlePosition.S) {
+                setScaledSelection(rx, ry, rw, rh + (y - (ry + rh)));
+            }
+            else if (selectionActiveHandle == HandlePosition.SW) {
+                setScaledSelection(x, ry, (rw - (x - rx)), rh + (y - (ry + rh)));
+            }
+            else if (selectionActiveHandle == HandlePosition.W) {
+                setScaledSelection(x, ry, (rw - (x - rx)), rh);
+            }
+        }
+        else if (selectionMode == SelectionMode.Moving) {
+            setScaledSelection(x - selectionStartX, y - selectionStartY, selectionScaled.width,
+                    selectionScaled.height);
+        }
+        else if (selectionMode == SelectionMode.Creating) {
+            int sx = selectionStartX;
+            int sy = selectionStartY;
+            int w = x - sx;
+            int h = y - sy;
+            setScaledSelection(sx, sy, w, h);
+        }
+        updateCursor();
+        repaint();
+    }
+
+    private void endSelection() {
+        selectionMode = null;
+        selectionActiveHandle = null;
+    }
+
+    private MouseListener mouseListener = new MouseAdapter() {
+        @Override
+        public void mouseClicked(MouseEvent e) {
+            if (e.isPopupTrigger() || e.isShiftDown() || SwingUtilities.isRightMouseButton(e)) {
+                return;
+            }
+            // double click captures an image from the camera and writes it to disk.
+            if (e.getClickCount() == 2) {
+                captureSnapshot();
+            }
+            else {
+                fireActionEvent(e);
+            }
+        }
+
         @Override
         public void mousePressed(MouseEvent e) {
             if (e.isPopupTrigger()) {
@@ -1273,60 +1184,58 @@ public void mousePressed(MouseEvent e) {
                 return;
             }
             else if (e.isShiftDown()) {
-            	moveToClick(e);
+                moveToClick(e);
             }
             else if (selectionEnabled) {
-            	beginSelection(e);
+                beginSelection(e);
+            }
+        }
+
+        @Override
+        public void mouseReleased(MouseEvent e) {
+            if (e.isPopupTrigger()) {
+                popupMenu.show(e.getComponent(), e.getX(), e.getY());
+                return;
+            }
+            else {
+                endSelection();
             }
         }
+    };
 
-		@Override
-		public void mouseReleased(MouseEvent e) {
-			if (e.isPopupTrigger()) {
-				popupMenu.show(e.getComponent(), e.getX(), e.getY());
-				return;
-			}
-			else {
-				endSelection();
-			}
-		}
-	};
-
-	private MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {
-		@Override
-		public void mouseMoved(MouseEvent e) {
-			updateCursor();
-		}
-                
-		@Override
-		public void mouseDragged(MouseEvent e) {
-			if (selectionEnabled) {
-				continueSelection(e);
-			}
-		}
-	};
-
-	private ComponentListener componentListener = new ComponentAdapter() {
-		@Override
-		public void componentResized(ComponentEvent e) {
-			calculateScalingData();
-		}
-	};
-
-	public CameraViewSelectionTextDelegate pixelsAndUnitsTextSelectionDelegate = new CameraViewSelectionTextDelegate() {
-		@Override
-		public String getSelectionText(CameraView cameraView) {
-			double widthInUnits = selection.width
-					* camera.getUnitsPerPixel().getX();
-			double heightInUnits = selection.height
-					* camera.getUnitsPerPixel().getY();
-
-			String text = String.format(Locale.US,"%dpx, %dpx\n%2.3f%s, %2.3f%s",
-					(int) selection.getWidth(), (int) selection.getHeight(),
-					widthInUnits, camera.getUnitsPerPixel().getUnits()
-							.getShortName(), heightInUnits, camera
-							.getUnitsPerPixel().getUnits().getShortName());
-			return text;
-		}
-	};
+    private MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {
+        @Override
+        public void mouseMoved(MouseEvent e) {
+            updateCursor();
+        }
+
+        @Override
+        public void mouseDragged(MouseEvent e) {
+            if (selectionEnabled) {
+                continueSelection(e);
+            }
+        }
+    };
+
+    private ComponentListener componentListener = new ComponentAdapter() {
+        @Override
+        public void componentResized(ComponentEvent e) {
+            calculateScalingData();
+        }
+    };
+
+    public CameraViewSelectionTextDelegate pixelsAndUnitsTextSelectionDelegate =
+            new CameraViewSelectionTextDelegate() {
+                @Override
+                public String getSelectionText(CameraView cameraView) {
+                    double widthInUnits = selection.width * camera.getUnitsPerPixel().getX();
+                    double heightInUnits = selection.height * camera.getUnitsPerPixel().getY();
+
+                    String text = String.format(Locale.US, "%dpx, %dpx\n%2.3f%s, %2.3f%s",
+                            (int) selection.getWidth(), (int) selection.getHeight(), widthInUnits,
+                            camera.getUnitsPerPixel().getUnits().getShortName(), heightInUnits,
+                            camera.getUnitsPerPixel().getUnits().getShortName());
+                    return text;
+                }
+            };
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraViewActionEvent.java b/src/main/java/org/openpnp/gui/components/CameraViewActionEvent.java
index 551b6e5f1c..dcd4cae275 100755
--- a/src/main/java/org/openpnp/gui/components/CameraViewActionEvent.java
+++ b/src/main/java/org/openpnp/gui/components/CameraViewActionEvent.java
@@ -1,84 +1,77 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.components;
 
 import org.openpnp.model.Location;
 
 public class CameraViewActionEvent {
-	public int componentX, componentY;
-	public double physicalX, physicalY;
-	public Location location;
-	
-	public CameraViewActionEvent(
-			CameraView source, 
-			int componentX, 
-			int componentY, 
-			double physicalX, 
-			double physicalY,
-			Location location) {
-		this.componentX = componentX;
-		this.componentY = componentY;
-		this.physicalX = physicalX;
-		this.physicalY = physicalY;
-		this.location = location;
-	}
+    public int componentX, componentY;
+    public double physicalX, physicalY;
+    public Location location;
+
+    public CameraViewActionEvent(CameraView source, int componentX, int componentY,
+            double physicalX, double physicalY, Location location) {
+        this.componentX = componentX;
+        this.componentY = componentY;
+        this.physicalX = physicalX;
+        this.physicalY = physicalY;
+        this.location = location;
+    }
 
-	public int getComponentX() {
-		return componentX;
-	}
+    public int getComponentX() {
+        return componentX;
+    }
 
-	public void setComponentX(int componentX) {
-		this.componentX = componentX;
-	}
+    public void setComponentX(int componentX) {
+        this.componentX = componentX;
+    }
 
-	public int getComponentY() {
-		return componentY;
-	}
+    public int getComponentY() {
+        return componentY;
+    }
 
-	public void setComponentY(int componentY) {
-		this.componentY = componentY;
-	}
+    public void setComponentY(int componentY) {
+        this.componentY = componentY;
+    }
 
-	public double getPhysicalX() {
-		return physicalX;
-	}
+    public double getPhysicalX() {
+        return physicalX;
+    }
 
-	public void setPhysicalX(double physicalX) {
-		this.physicalX = physicalX;
-	}
+    public void setPhysicalX(double physicalX) {
+        this.physicalX = physicalX;
+    }
 
-	public double getPhysicalY() {
-		return physicalY;
-	}
+    public double getPhysicalY() {
+        return physicalY;
+    }
 
-	public void setPhysicalY(double physicalY) {
-		this.physicalY = physicalY;
-	}
+    public void setPhysicalY(double physicalY) {
+        this.physicalY = physicalY;
+    }
 
-	public Location getLocation() {
-		return location;
-	}
+    public Location getLocation() {
+        return location;
+    }
 
-	public void setLocation(Location location) {
-		this.location = location;
-	}
+    public void setLocation(Location location) {
+        this.location = location;
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraViewActionListener.java b/src/main/java/org/openpnp/gui/components/CameraViewActionListener.java
index de57358595..acc23ad60d 100755
--- a/src/main/java/org/openpnp/gui/components/CameraViewActionListener.java
+++ b/src/main/java/org/openpnp/gui/components/CameraViewActionListener.java
@@ -1,32 +1,30 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.components;
 
 /**
- * A Listener that is notified when an action is performed in a CameraView.
- * Differs from 
+ * A Listener that is notified when an action is performed in a CameraView. Differs from
+ * 
  * @author jason
  *
  */
 public interface CameraViewActionListener {
-	void actionPerformed(CameraViewActionEvent action);
+    void actionPerformed(CameraViewActionEvent action);
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraViewFilter.java b/src/main/java/org/openpnp/gui/components/CameraViewFilter.java
index 8fbc08ce46..38626a5626 100755
--- a/src/main/java/org/openpnp/gui/components/CameraViewFilter.java
+++ b/src/main/java/org/openpnp/gui/components/CameraViewFilter.java
@@ -5,5 +5,5 @@
 import org.openpnp.spi.Camera;
 
 public interface CameraViewFilter {
-	public BufferedImage filterCameraImage(Camera camera, BufferedImage image);
+    public BufferedImage filterCameraImage(Camera camera, BufferedImage image);
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraViewPopupMenu.java b/src/main/java/org/openpnp/gui/components/CameraViewPopupMenu.java
index 954acb2462..e7951236f6 100755
--- a/src/main/java/org/openpnp/gui/components/CameraViewPopupMenu.java
+++ b/src/main/java/org/openpnp/gui/components/CameraViewPopupMenu.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components;
@@ -45,340 +43,343 @@
 // making a redundant call to setReticle on every property update. Fix that somehow.
 @SuppressWarnings("serial")
 public class CameraViewPopupMenu extends JPopupMenu {
-	private CameraView cameraView;
-	private JMenu reticleMenu;
-	private JMenu reticleOptionsMenu;
-	
-	public CameraViewPopupMenu(CameraView cameraView) {
-		this.cameraView = cameraView;
-		
-		reticleMenu = createReticleMenu();
-		JMenu maxFpsMenu = createMaxFpsMenu();
-		
-		add(reticleMenu);
-		add(maxFpsMenu);
-		
-	    JCheckBoxMenuItem chkShowImageInfo = new JCheckBoxMenuItem(showImageInfoAction);
-	    chkShowImageInfo.setSelected(cameraView.isShowImageInfo());
-	    add(chkShowImageInfo);
-
-		
-		if (cameraView.getDefaultReticle() != null) {
-			if (cameraView.getDefaultReticle() instanceof RulerReticle) {
-				setReticleOptionsMenu(createRulerReticleOptionsMenu((RulerReticle) cameraView.getDefaultReticle()));
-			}
-			else if (cameraView.getDefaultReticle() instanceof FiducialReticle) {
-				setReticleOptionsMenu(createFiducialReticleOptionsMenu((FiducialReticle) cameraView.getDefaultReticle()));
-			}
-			else if (cameraView.getDefaultReticle() instanceof CrosshairReticle) {
-                setReticleOptionsMenu(createCrosshairReticleOptionsMenu((CrosshairReticle) cameraView.getDefaultReticle()));
-            }
-		}
-	}
-	
-	private JMenu createMaxFpsMenu() {
-		ButtonGroup buttonGroup = new ButtonGroup();
-		JMenu menu = new JMenu("Maximum FPS");
-		JRadioButtonMenuItem menuItem;
-		
-		menuItem = new JRadioButtonMenuItem("1");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("5");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("10");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("15");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("24");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("30");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("45");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("60");
-		menuItem.addActionListener(maxFpsAction);
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		
-		return menu;
-	}
-	
-	private JMenu createReticleMenu() {
-		JMenu menu = new JMenu("Reticle");
-
-		ButtonGroup buttonGroup = new ButtonGroup();
-		
-		JRadioButtonMenuItem menuItem;
-		
-		Reticle reticle = cameraView.getDefaultReticle();
-		
-		menuItem = new JRadioButtonMenuItem(noReticleAction);
-		if (reticle == null) {
-			menuItem.setSelected(true);
-		}
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		
-		menuItem = new JRadioButtonMenuItem(crosshairReticleAction);
-		if (reticle != null && reticle.getClass() == CrosshairReticle.class) {
-			menuItem.setSelected(true);
-		}
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		
-		menuItem = new JRadioButtonMenuItem(rulerReticleAction);
-		if (reticle != null && reticle.getClass() == RulerReticle.class) {
-			menuItem.setSelected(true);
-		}
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		
-		menuItem = new JRadioButtonMenuItem(fiducialReticleAction);
-		if (reticle != null && reticle.getClass() == FiducialReticle.class) {
-			menuItem.setSelected(true);
-		}
-		buttonGroup.add(menuItem);
-		menu.add(menuItem);
-		
-		return menu;
-	}
-	
-	private JMenu createCrosshairReticleOptionsMenu(final CrosshairReticle reticle) {
-		JMenu menu = new JMenu("Options");
-		
-		ButtonGroup buttonGroup = new ButtonGroup();
-		
-		JRadioButtonMenuItem menuItem;
-		
-		menuItem = new JRadioButtonMenuItem("Red");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.red) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.red);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Green");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.green) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.green);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Yellow");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.yellow) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.yellow);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Blue");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.blue) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.blue);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("White");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.white) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.white);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(menuItem);
-		
-		return menu;
-	}
-	
-	private JMenu createRulerReticleOptionsMenu(final RulerReticle reticle) {
-		JMenu menu = new JMenu("Options");
-		
-		JMenu subMenu;
-		JRadioButtonMenuItem menuItem;
-		ButtonGroup buttonGroup;
-		
-		subMenu = new JMenu("Color");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("Red");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.red) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.red);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Green");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.green) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.green);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Yellow");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.yellow) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.yellow);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Blue");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.blue) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.blue);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("White");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.white) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.white);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-		
-		subMenu = new JMenu("Units");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("Millimeters");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnits() == LengthUnit.Millimeters) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnits(LengthUnit.Millimeters);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Inches");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnits() == LengthUnit.Inches) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnits(LengthUnit.Inches);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-
-		subMenu = new JMenu("Units Per Tick");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("0.1");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnitsPerTick() == 0.1) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnitsPerTick(0.1);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("0.25");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnitsPerTick() == 0.25) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnitsPerTick(0.25);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("0.50");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnitsPerTick() == 0.50) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnitsPerTick(0.50);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
+    private CameraView cameraView;
+    private JMenu reticleMenu;
+    private JMenu reticleOptionsMenu;
+
+    public CameraViewPopupMenu(CameraView cameraView) {
+        this.cameraView = cameraView;
+
+        reticleMenu = createReticleMenu();
+        JMenu maxFpsMenu = createMaxFpsMenu();
+
+        add(reticleMenu);
+        add(maxFpsMenu);
+
+        JCheckBoxMenuItem chkShowImageInfo = new JCheckBoxMenuItem(showImageInfoAction);
+        chkShowImageInfo.setSelected(cameraView.isShowImageInfo());
+        add(chkShowImageInfo);
+
+
+        if (cameraView.getDefaultReticle() != null) {
+            if (cameraView.getDefaultReticle() instanceof RulerReticle) {
+                setReticleOptionsMenu(createRulerReticleOptionsMenu(
+                        (RulerReticle) cameraView.getDefaultReticle()));
+            }
+            else if (cameraView.getDefaultReticle() instanceof FiducialReticle) {
+                setReticleOptionsMenu(createFiducialReticleOptionsMenu(
+                        (FiducialReticle) cameraView.getDefaultReticle()));
+            }
+            else if (cameraView.getDefaultReticle() instanceof CrosshairReticle) {
+                setReticleOptionsMenu(createCrosshairReticleOptionsMenu(
+                        (CrosshairReticle) cameraView.getDefaultReticle()));
+            }
+        }
+    }
+
+    private JMenu createMaxFpsMenu() {
+        ButtonGroup buttonGroup = new ButtonGroup();
+        JMenu menu = new JMenu("Maximum FPS");
+        JRadioButtonMenuItem menuItem;
+
+        menuItem = new JRadioButtonMenuItem("1");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("5");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("10");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("15");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("24");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("30");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("45");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("60");
+        menuItem.addActionListener(maxFpsAction);
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+
+        return menu;
+    }
+
+    private JMenu createReticleMenu() {
+        JMenu menu = new JMenu("Reticle");
+
+        ButtonGroup buttonGroup = new ButtonGroup();
+
+        JRadioButtonMenuItem menuItem;
+
+        Reticle reticle = cameraView.getDefaultReticle();
+
+        menuItem = new JRadioButtonMenuItem(noReticleAction);
+        if (reticle == null) {
+            menuItem.setSelected(true);
+        }
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+
+        menuItem = new JRadioButtonMenuItem(crosshairReticleAction);
+        if (reticle != null && reticle.getClass() == CrosshairReticle.class) {
+            menuItem.setSelected(true);
+        }
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+
+        menuItem = new JRadioButtonMenuItem(rulerReticleAction);
+        if (reticle != null && reticle.getClass() == RulerReticle.class) {
+            menuItem.setSelected(true);
+        }
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+
+        menuItem = new JRadioButtonMenuItem(fiducialReticleAction);
+        if (reticle != null && reticle.getClass() == FiducialReticle.class) {
+            menuItem.setSelected(true);
+        }
+        buttonGroup.add(menuItem);
+        menu.add(menuItem);
+
+        return menu;
+    }
+
+    private JMenu createCrosshairReticleOptionsMenu(final CrosshairReticle reticle) {
+        JMenu menu = new JMenu("Options");
+
+        ButtonGroup buttonGroup = new ButtonGroup();
+
+        JRadioButtonMenuItem menuItem;
+
+        menuItem = new JRadioButtonMenuItem("Red");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.red) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.red);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Green");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.green) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.green);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Yellow");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.yellow) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.yellow);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Blue");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.blue) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.blue);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("White");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.white) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.white);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(menuItem);
+
+        return menu;
+    }
+
+    private JMenu createRulerReticleOptionsMenu(final RulerReticle reticle) {
+        JMenu menu = new JMenu("Options");
+
+        JMenu subMenu;
+        JRadioButtonMenuItem menuItem;
+        ButtonGroup buttonGroup;
+
+        subMenu = new JMenu("Color");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("Red");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.red) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.red);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Green");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.green) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.green);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Yellow");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.yellow) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.yellow);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Blue");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.blue) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.blue);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("White");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.white) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.white);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        subMenu = new JMenu("Units");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("Millimeters");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnits() == LengthUnit.Millimeters) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnits(LengthUnit.Millimeters);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Inches");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnits() == LengthUnit.Inches) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnits(LengthUnit.Inches);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        subMenu = new JMenu("Units Per Tick");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("0.1");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnitsPerTick() == 0.1) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnitsPerTick(0.1);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("0.25");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnitsPerTick() == 0.25) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnitsPerTick(0.25);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("0.50");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnitsPerTick() == 0.50) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnitsPerTick(0.50);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
         subMenu.add(menuItem);
         menuItem = new JRadioButtonMenuItem("1");
         buttonGroup.add(menuItem);
@@ -418,252 +419,253 @@ public void actionPerformed(ActionEvent e) {
                 cameraView.setDefaultReticle(reticle);
             }
         });
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("10");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnitsPerTick() == 10) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnitsPerTick(10);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-		
-		return menu;
-	}
-	
-	private JMenu createFiducialReticleOptionsMenu(final FiducialReticle reticle) {
-		JMenu menu = new JMenu("Options");
-		
-		JMenu subMenu;
-		JRadioButtonMenuItem menuItem;
-		ButtonGroup buttonGroup;
-		
-		subMenu = new JMenu("Color");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("Red");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.red) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.red);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Green");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.green) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.green);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Yellow");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.yellow) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.yellow);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Blue");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.blue) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.blue);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("White");
-		buttonGroup.add(menuItem);
-		if (reticle.getColor() == Color.white) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setColor(Color.white);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-		
-		subMenu = new JMenu("Units");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("Millimeters");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnits() == LengthUnit.Millimeters) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnits(LengthUnit.Millimeters);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Inches");
-		buttonGroup.add(menuItem);
-		if (reticle.getUnits() == LengthUnit.Inches) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setUnits(LengthUnit.Inches);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-
-		subMenu = new JMenu("Shape");
-		buttonGroup = new ButtonGroup();
-		menuItem = new JRadioButtonMenuItem("Circle");
-		buttonGroup.add(menuItem);
-		if (reticle.getShape() == FiducialReticle.Shape.Circle) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setShape(FiducialReticle.Shape.Circle);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menuItem = new JRadioButtonMenuItem("Square");
-		buttonGroup.add(menuItem);
-		if (reticle.getShape() == FiducialReticle.Shape.Square) {
-			menuItem.setSelected(true);
-		}
-		menuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setShape(FiducialReticle.Shape.Square);
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		subMenu.add(menuItem);
-		menu.add(subMenu);
-		
-		JCheckBoxMenuItem chkMenuItem = new JCheckBoxMenuItem("Filled");
-		chkMenuItem.setSelected(reticle.isFilled());
-		chkMenuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				reticle.setFilled(((JCheckBoxMenuItem)e.getSource()).isSelected());
-				cameraView.setDefaultReticle(reticle);
-			}
-		});
-		menu.add(chkMenuItem);
-		
-		JMenuItem inputMenuItem = new JMenuItem("Size");
-		inputMenuItem.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent e) {
-				String result = JOptionPane.showInputDialog(cameraView,
-						String.format("Enter the size in %s", reticle.getUnits().toString().toLowerCase()),
-						reticle.getSize() + "");
-				if (result != null) {
-					reticle.setSize(Double.valueOf(result));
-					cameraView.setDefaultReticle(reticle);
-				}
-			}
-		});
-		menu.add(inputMenuItem);
-		
-		return menu;
-	}
-	
-	private void setReticleOptionsMenu(JMenu menu) {
-		if (reticleOptionsMenu != null) {
-			reticleMenu.remove(reticleMenu.getMenuComponentCount() - 1);
-			reticleMenu.remove(reticleMenu.getMenuComponentCount() - 1);
-		}
-		if (menu != null) {
-			reticleMenu.addSeparator();
-			reticleMenu.add(menu);
-		}
-		reticleOptionsMenu = menu;
-	}
-	
-	private Action showImageInfoAction = new AbstractAction("Show Image Info?") {
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("10");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnitsPerTick() == 10) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnitsPerTick(10);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        return menu;
+    }
+
+    private JMenu createFiducialReticleOptionsMenu(final FiducialReticle reticle) {
+        JMenu menu = new JMenu("Options");
+
+        JMenu subMenu;
+        JRadioButtonMenuItem menuItem;
+        ButtonGroup buttonGroup;
+
+        subMenu = new JMenu("Color");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("Red");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.red) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.red);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Green");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.green) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.green);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Yellow");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.yellow) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.yellow);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Blue");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.blue) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.blue);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("White");
+        buttonGroup.add(menuItem);
+        if (reticle.getColor() == Color.white) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setColor(Color.white);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        subMenu = new JMenu("Units");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("Millimeters");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnits() == LengthUnit.Millimeters) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnits(LengthUnit.Millimeters);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Inches");
+        buttonGroup.add(menuItem);
+        if (reticle.getUnits() == LengthUnit.Inches) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setUnits(LengthUnit.Inches);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        subMenu = new JMenu("Shape");
+        buttonGroup = new ButtonGroup();
+        menuItem = new JRadioButtonMenuItem("Circle");
+        buttonGroup.add(menuItem);
+        if (reticle.getShape() == FiducialReticle.Shape.Circle) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setShape(FiducialReticle.Shape.Circle);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menuItem = new JRadioButtonMenuItem("Square");
+        buttonGroup.add(menuItem);
+        if (reticle.getShape() == FiducialReticle.Shape.Square) {
+            menuItem.setSelected(true);
+        }
+        menuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setShape(FiducialReticle.Shape.Square);
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        subMenu.add(menuItem);
+        menu.add(subMenu);
+
+        JCheckBoxMenuItem chkMenuItem = new JCheckBoxMenuItem("Filled");
+        chkMenuItem.setSelected(reticle.isFilled());
+        chkMenuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                reticle.setFilled(((JCheckBoxMenuItem) e.getSource()).isSelected());
+                cameraView.setDefaultReticle(reticle);
+            }
+        });
+        menu.add(chkMenuItem);
+
+        JMenuItem inputMenuItem = new JMenuItem("Size");
+        inputMenuItem.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                String result = JOptionPane.showInputDialog(cameraView,
+                        String.format("Enter the size in %s",
+                                reticle.getUnits().toString().toLowerCase()),
+                        reticle.getSize() + "");
+                if (result != null) {
+                    reticle.setSize(Double.valueOf(result));
+                    cameraView.setDefaultReticle(reticle);
+                }
+            }
+        });
+        menu.add(inputMenuItem);
+
+        return menu;
+    }
+
+    private void setReticleOptionsMenu(JMenu menu) {
+        if (reticleOptionsMenu != null) {
+            reticleMenu.remove(reticleMenu.getMenuComponentCount() - 1);
+            reticleMenu.remove(reticleMenu.getMenuComponentCount() - 1);
+        }
+        if (menu != null) {
+            reticleMenu.addSeparator();
+            reticleMenu.add(menu);
+        }
+        reticleOptionsMenu = menu;
+    }
+
+    private Action showImageInfoAction = new AbstractAction("Show Image Info?") {
         @Override
         public void actionPerformed(ActionEvent e) {
             cameraView.setShowImageInfo(((JCheckBoxMenuItem) e.getSource()).isSelected());
         }
-	};
-	
-	private Action noReticleAction = new AbstractAction("None") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			setReticleOptionsMenu(null);
-			cameraView.setDefaultReticle(null);
-		}
-	};
-	
-	private Action crosshairReticleAction = new AbstractAction("Crosshair") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			CrosshairReticle reticle = new CrosshairReticle();
-			JMenu optionsMenu = createCrosshairReticleOptionsMenu(reticle);
-			setReticleOptionsMenu(optionsMenu);
-			cameraView.setDefaultReticle(reticle);
-		}
-	};
-	
-	private Action rulerReticleAction = new AbstractAction("Ruler") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			RulerReticle reticle = new RulerReticle();
-			JMenu optionsMenu = createRulerReticleOptionsMenu(reticle);
-			setReticleOptionsMenu(optionsMenu);
-			cameraView.setDefaultReticle(reticle);
-		}
-	};
-	
-	private Action fiducialReticleAction = new AbstractAction("Fiducial") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			FiducialReticle reticle = new FiducialReticle();
-			JMenu optionsMenu = createFiducialReticleOptionsMenu(reticle);
-			setReticleOptionsMenu(optionsMenu);
-			cameraView.setDefaultReticle(reticle);
-		}
-	};
-	
-	private Action maxFpsAction = new AbstractAction() {
-		@Override
-		public void actionPerformed(ActionEvent e) {
-			int maximumFps = Integer.parseInt(e.getActionCommand());
-			cameraView.setMaximumFps(maximumFps);
-		}
-	};
+    };
+
+    private Action noReticleAction = new AbstractAction("None") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            setReticleOptionsMenu(null);
+            cameraView.setDefaultReticle(null);
+        }
+    };
+
+    private Action crosshairReticleAction = new AbstractAction("Crosshair") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            CrosshairReticle reticle = new CrosshairReticle();
+            JMenu optionsMenu = createCrosshairReticleOptionsMenu(reticle);
+            setReticleOptionsMenu(optionsMenu);
+            cameraView.setDefaultReticle(reticle);
+        }
+    };
+
+    private Action rulerReticleAction = new AbstractAction("Ruler") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            RulerReticle reticle = new RulerReticle();
+            JMenu optionsMenu = createRulerReticleOptionsMenu(reticle);
+            setReticleOptionsMenu(optionsMenu);
+            cameraView.setDefaultReticle(reticle);
+        }
+    };
+
+    private Action fiducialReticleAction = new AbstractAction("Fiducial") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            FiducialReticle reticle = new FiducialReticle();
+            JMenu optionsMenu = createFiducialReticleOptionsMenu(reticle);
+            setReticleOptionsMenu(optionsMenu);
+            cameraView.setDefaultReticle(reticle);
+        }
+    };
+
+    private Action maxFpsAction = new AbstractAction() {
+        @Override
+        public void actionPerformed(ActionEvent e) {
+            int maximumFps = Integer.parseInt(e.getActionCommand());
+            cameraView.setMaximumFps(maximumFps);
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/components/CameraViewSelectionTextDelegate.java b/src/main/java/org/openpnp/gui/components/CameraViewSelectionTextDelegate.java
index 9f953e8ff4..678a34f047 100755
--- a/src/main/java/org/openpnp/gui/components/CameraViewSelectionTextDelegate.java
+++ b/src/main/java/org/openpnp/gui/components/CameraViewSelectionTextDelegate.java
@@ -1,26 +1,24 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.components;
 
 public interface CameraViewSelectionTextDelegate {
-	public String getSelectionText(CameraView cameraView);
+    public String getSelectionText(CameraView cameraView);
 }
diff --git a/src/main/java/org/openpnp/gui/components/ClassSelectionDialog.java b/src/main/java/org/openpnp/gui/components/ClassSelectionDialog.java
index 823d051453..a5cf586550 100755
--- a/src/main/java/org/openpnp/gui/components/ClassSelectionDialog.java
+++ b/src/main/java/org/openpnp/gui/components/ClassSelectionDialog.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components;
@@ -50,112 +48,109 @@
 
 @SuppressWarnings("serial")
 public class ClassSelectionDialog<T> extends JDialog {
-	private Class<? extends T> selectedClass;
-	private JList list;
-
-	public ClassSelectionDialog(Frame parent, String title, String description,
-			List<Class<? extends T>> classes) {
-		super(parent, title, true);
-
-		JPanel panel = new JPanel();
-		panel.setBorder(new EmptyBorder(8, 8, 4, 8));
-		getContentPane().add(panel, BorderLayout.CENTER);
-		panel.setLayout(new BorderLayout(0, 0));
-
-		JPanel panelActions = new JPanel();
-		panel.add(panelActions, BorderLayout.SOUTH);
-		panelActions.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));
-
-		JButton btnCancel = new JButton(cancelAction);
-		panelActions.add(btnCancel);
-
-		JButton btnSelect = new JButton(selectAction);
-		panelActions.add(btnSelect);
-
-		JLabel lblDescription = new JLabel(
-				"Please select an implemention class from the given list. Or whatever.");
-		lblDescription.setBorder(new EmptyBorder(4, 4, 8, 4));
-		panel.add(lblDescription, BorderLayout.NORTH);
-		lblDescription.setHorizontalAlignment(SwingConstants.LEFT);
-
-		lblDescription.setText(description);
-		list = new JList();
-		list.addMouseListener(new MouseAdapter() {
-			@Override
-			public void mouseClicked(MouseEvent e) {
-				if (e.getClickCount() == 2) {
-					selectAction.actionPerformed(null);
-				}
-			}
-		});
-		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-		list.setBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null));
-		panel.add(list, BorderLayout.CENTER);
-		// setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
-		setSize(400, 400);
-		setLocationRelativeTo(parent);
-
-		DefaultListModel listModel = new DefaultListModel();
-		list.setModel(listModel);
-		for (Class<? extends T> clz : classes) {
-			listModel.addElement(new ClassListItem<>(clz));
-		}
-
-		list.addListSelectionListener(new ListSelectionListener() {
-			@Override
-			public void valueChanged(ListSelectionEvent e) {
-				if (e.getValueIsAdjusting()) {
-					return;
-				}
-				selectAction.setEnabled(ClassSelectionDialog.this.list
-						.getSelectedValue() != null);
-			}
-		});
-
-		JRootPane rootPane = getRootPane();
-		KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-		InputMap inputMap = rootPane
-				.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
-		inputMap.put(stroke, "ESCAPE");
-		rootPane.getActionMap().put("ESCAPE", cancelAction);
-
-		selectAction.setEnabled(false);
-	}
-
-	private final Action selectAction = new AbstractAction("Accept") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			selectedClass = ((ClassListItem<T>) list.getSelectedValue())
-					.getTheClass();
-			setVisible(false);
-		}
-	};
-
-	private final Action cancelAction = new AbstractAction("Cancel") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			setVisible(false);
-		}
-	};
-
-	public Class<? extends T> getSelectedClass() {
-		return selectedClass;
-	}
-
-	private class ClassListItem<T1> {
-		private Class<? extends T1> clz;
-
-		public ClassListItem(Class<? extends T1> clz) {
-			this.clz = clz;
-		}
-
-		@Override
-		public String toString() {
-			return clz.getSimpleName();
-		}
-
-		public Class<? extends T1> getTheClass() {
-			return clz;
-		}
-	}
+    private Class<? extends T> selectedClass;
+    private JList list;
+
+    public ClassSelectionDialog(Frame parent, String title, String description,
+            List<Class<? extends T>> classes) {
+        super(parent, title, true);
+
+        JPanel panel = new JPanel();
+        panel.setBorder(new EmptyBorder(8, 8, 4, 8));
+        getContentPane().add(panel, BorderLayout.CENTER);
+        panel.setLayout(new BorderLayout(0, 0));
+
+        JPanel panelActions = new JPanel();
+        panel.add(panelActions, BorderLayout.SOUTH);
+        panelActions.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 5));
+
+        JButton btnCancel = new JButton(cancelAction);
+        panelActions.add(btnCancel);
+
+        JButton btnSelect = new JButton(selectAction);
+        panelActions.add(btnSelect);
+
+        JLabel lblDescription =
+                new JLabel("Please select an implemention class from the list.");
+        lblDescription.setBorder(new EmptyBorder(4, 4, 8, 4));
+        panel.add(lblDescription, BorderLayout.NORTH);
+        lblDescription.setHorizontalAlignment(SwingConstants.LEFT);
+
+        lblDescription.setText(description);
+        list = new JList();
+        list.addMouseListener(new MouseAdapter() {
+            @Override
+            public void mouseClicked(MouseEvent e) {
+                if (e.getClickCount() == 2) {
+                    selectAction.actionPerformed(null);
+                }
+            }
+        });
+        list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+        list.setBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null));
+        panel.add(list, BorderLayout.CENTER);
+        // setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
+        setSize(400, 400);
+        setLocationRelativeTo(parent);
+
+        DefaultListModel listModel = new DefaultListModel();
+        list.setModel(listModel);
+        for (Class<? extends T> clz : classes) {
+            listModel.addElement(new ClassListItem<>(clz));
+        }
+
+        list.addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+                selectAction.setEnabled(ClassSelectionDialog.this.list.getSelectedValue() != null);
+            }
+        });
+
+        JRootPane rootPane = getRootPane();
+        KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
+        InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+        inputMap.put(stroke, "ESCAPE");
+        rootPane.getActionMap().put("ESCAPE", cancelAction);
+
+        selectAction.setEnabled(false);
+    }
+
+    private final Action selectAction = new AbstractAction("Accept") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            selectedClass = ((ClassListItem<T>) list.getSelectedValue()).getTheClass();
+            setVisible(false);
+        }
+    };
+
+    private final Action cancelAction = new AbstractAction("Cancel") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            setVisible(false);
+        }
+    };
+
+    public Class<? extends T> getSelectedClass() {
+        return selectedClass;
+    }
+
+    private class ClassListItem<T1> {
+        private Class<? extends T1> clz;
+
+        public ClassListItem(Class<? extends T1> clz) {
+            this.clz = clz;
+        }
+
+        @Override
+        public String toString() {
+            return clz.getSimpleName();
+        }
+
+        public Class<? extends T1> getTheClass() {
+            return clz;
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/ComponentDecorators.java b/src/main/java/org/openpnp/gui/components/ComponentDecorators.java
index 8099a42368..ec7020a4bd 100755
--- a/src/main/java/org/openpnp/gui/components/ComponentDecorators.java
+++ b/src/main/java/org/openpnp/gui/components/ComponentDecorators.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.components;
 
@@ -33,62 +31,64 @@
 import org.openpnp.model.Length;
 
 public class ComponentDecorators {
-	/**
-	 * Adds an auto selection decoration to the JTextField. Whenever the
-	 * JTextField gains focus the text in it will be selected.
-	 * @param textField
-	 */
-	public static void decorateWithAutoSelect(JTextField textField) {
-		textField.addFocusListener(new FocusAdapter() {
-			@Override
-			public void focusGained(FocusEvent event) {
-				((JTextField) event.getComponent()).selectAll();
-			}
-		});
-		textField.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent event) {
-				((JTextField) event.getSource()).selectAll();
-			}
-		});
-	}
-	
-	/**
-	 * Adds a length conversion decoration to the JTextField. When the
-	 * JTextField loses focus or has it's action triggered the text
-	 * will be converted to a Length value in the system units and then
-	 * have it's text replaced with the value.
-	 * @param textField
-	 */
-	public static void decorateWithLengthConversion(JTextField textField) {
-		textField.addActionListener(new ActionListener() {
-			@Override
-			public void actionPerformed(ActionEvent event) {
-				convertLength(((JTextField) event.getSource()));
-			}
-		});
-		textField.addFocusListener(new FocusAdapter() {
-			@Override
-			public void focusLost(FocusEvent event) {
-				convertLength(((JTextField) event.getSource()));
-			}
-		});
-	}
-	
-	public static void decorateWithAutoSelectAndLengthConversion(JTextField textField) {
-		decorateWithAutoSelect(textField);
-		decorateWithLengthConversion(textField);
-	}
+    /**
+     * Adds an auto selection decoration to the JTextField. Whenever the JTextField gains focus the
+     * text in it will be selected.
+     * 
+     * @param textField
+     */
+    public static void decorateWithAutoSelect(JTextField textField) {
+        textField.addFocusListener(new FocusAdapter() {
+            @Override
+            public void focusGained(FocusEvent event) {
+                ((JTextField) event.getComponent()).selectAll();
+            }
+        });
+        textField.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent event) {
+                ((JTextField) event.getSource()).selectAll();
+            }
+        });
+    }
+
+    /**
+     * Adds a length conversion decoration to the JTextField. When the JTextField loses focus or has
+     * it's action triggered the text will be converted to a Length value in the system units and
+     * then have it's text replaced with the value.
+     * 
+     * @param textField
+     */
+    public static void decorateWithLengthConversion(JTextField textField) {
+        textField.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent event) {
+                convertLength(((JTextField) event.getSource()));
+            }
+        });
+        textField.addFocusListener(new FocusAdapter() {
+            @Override
+            public void focusLost(FocusEvent event) {
+                convertLength(((JTextField) event.getSource()));
+            }
+        });
+    }
+
+    public static void decorateWithAutoSelectAndLengthConversion(JTextField textField) {
+        decorateWithAutoSelect(textField);
+        decorateWithLengthConversion(textField);
+    }
 
-	private static void convertLength(JTextField textField) {
-		Length length = Length.parse(textField.getText(), false);
-		if (length == null) {
-			return;
-		}
-		if (length.getUnits() == null) {
-			length.setUnits(Configuration.get().getSystemUnits());
-		}
-		length = length.convertToUnits(Configuration.get().getSystemUnits());
-		textField.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), length.getValue()));
-	}
+    private static void convertLength(JTextField textField) {
+        Length length = Length.parse(textField.getText(), false);
+        if (length == null) {
+            return;
+        }
+        if (length.getUnits() == null) {
+            length.setUnits(Configuration.get().getSystemUnits());
+        }
+        length = length.convertToUnits(Configuration.get().getSystemUnits());
+        textField.setText(String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                length.getValue()));
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/LocationButtonsPanel.java b/src/main/java/org/openpnp/gui/components/LocationButtonsPanel.java
index afbdd415e3..ddb5e5b429 100755
--- a/src/main/java/org/openpnp/gui/components/LocationButtonsPanel.java
+++ b/src/main/java/org/openpnp/gui/components/LocationButtonsPanel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.components;
 
@@ -44,220 +42,199 @@
 import org.openpnp.util.UiUtils;
 
 /**
- * A JPanel of 4 small buttons that assist in setting locations. The buttons
- * are Capture Camera Coordinates, Capture Tool Coordinates, Move Camera
- * to Coordinates and Move Tool to Coordinates. If the actuatorId property
- * is set, this causes the component to use the specified Actuator in place
- * of the tool. 
+ * A JPanel of 4 small buttons that assist in setting locations. The buttons are Capture Camera
+ * Coordinates, Capture Tool Coordinates, Move Camera to Coordinates and Move Tool to Coordinates.
+ * If the actuatorId property is set, this causes the component to use the specified Actuator in
+ * place of the tool.
  */
 @SuppressWarnings("serial")
 public class LocationButtonsPanel extends JPanel {
-	private JTextField textFieldX, textFieldY, textFieldZ, textFieldC;
-	private String actuatorName;
-
-	private JButton buttonCenterTool;
-	private JButton buttonCaptureCamera;
-	private JButton buttonCaptureTool;
-	
-	public LocationButtonsPanel(JTextField textFieldX, JTextField textFieldY,
-			JTextField textFieldZ, JTextField textFieldC) {
-		FlowLayout flowLayout = (FlowLayout) getLayout();
-		flowLayout.setVgap(0);
-		flowLayout.setHgap(2);
-		this.textFieldX = textFieldX;
-		this.textFieldY = textFieldY;
-		this.textFieldZ = textFieldZ;
-		this.textFieldC = textFieldC;
-
-		buttonCaptureCamera = new JButton(captureCameraCoordinatesAction);
-		buttonCaptureCamera.setHideActionText(true);
-		add(buttonCaptureCamera);
-
-		buttonCaptureTool = new JButton(captureToolCoordinatesAction);
-		buttonCaptureTool.setHideActionText(true);
-		add(buttonCaptureTool);
-
-		JButton buttonCenterCamera = new JButton(positionCameraAction);
-		buttonCenterCamera.setHideActionText(true);
-		add(buttonCenterCamera);
-
-		buttonCenterTool = new JButton(positionToolAction);
-		buttonCenterTool.setHideActionText(true);
-		add(buttonCenterTool);
-		
-		buttonCenterToolNoSafeZ = new JButton(positionToolNoSafeZAction);
-		buttonCenterToolNoSafeZ.setHideActionText(true);
-
-		setActuatorName(null);
-	}
-	
-	public void setShowPositionToolNoSafeZ(boolean b) {
-	    if (b) {
-	        add(buttonCenterToolNoSafeZ);
-	    }
-	    else {
-	        remove(buttonCenterToolNoSafeZ);
-	    }
-	}
-	
-	public void setActuatorName(String actuatorName) {
-		this.actuatorName = actuatorName;
-		if (actuatorName == null || actuatorName.trim().length() == 0) {
-			buttonCaptureTool.setAction(captureToolCoordinatesAction);
-			buttonCenterTool.setAction(positionToolAction);
-		}
-		else {
-			buttonCaptureTool.setAction(captureActuatorCoordinatesAction);
-			buttonCenterTool.setAction(positionActuatorAction);
-		}
-	}
-
-	public String getActuatorName() {
-		return actuatorName;
-	}
-	
-	public HeadMountable getTool() throws Exception {
-		return MainFrame.machineControlsPanel.getSelectedNozzle();
-	}
-	
-	public Camera getCamera() throws Exception {
-		return getTool().getHead().getDefaultCamera();
-	}
-	
-	/**
-	 * Get the Actuator with the name provided by setActuatorName() that is
-	 * on the same Head as the tool from getTool(). 
-	 * @return
-	 * @throws Exception
-	 */
-	public Actuator getActuator() throws Exception {
-		if (actuatorName == null) {
-			return null;
-		}
-		HeadMountable tool = getTool();
-		Head head = tool.getHead();
-		Actuator actuator = head.getActuator(actuatorName);
-		if (actuator == null) {
-			throw new Exception(String.format(
-					"No Actuator with name %s on Head %s",
-					actuatorName, 
-					head.getName()));
-		}
-		return actuator;
-	}
-
-	private Location getParsedLocation() {
-	    double x = 0, y = 0, z = 0, rotation = 0;
-		if (textFieldX != null) {
-			x = Length.parse(textFieldX.getText()).getValue();
-		}
-		if (textFieldY != null) {
-			y = Length.parse(textFieldY.getText()).getValue();
-		}
-		if (textFieldZ != null) {
-			z = Length.parse(textFieldZ.getText()).getValue();
-		}
-		if (textFieldC != null) {
-			rotation = Double.parseDouble(textFieldC.getText());
-		}
-		return new Location(Configuration.get().getSystemUnits(), x, y, z, rotation);
-	}
-
-	private Action captureCameraCoordinatesAction = new AbstractAction(
-			"Get Camera Coordinates", Icons.captureCamera) {
-		{
-			putValue(Action.SHORT_DESCRIPTION,
-					"Capture the location that the camera is centered on.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.messageBoxOnException(() -> {
-				Location l = getCamera().getLocation();
-				Helpers.copyLocationIntoTextFields(l, textFieldX, textFieldY,
-						null, textFieldC);
-			});
-		}
-	};
-
-	private Action captureToolCoordinatesAction = new AbstractAction(
-			"Get Tool Coordinates", Icons.captureTool) {
-		{
-			putValue(Action.SHORT_DESCRIPTION,
-					"Capture the location that the tool is centered on.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.messageBoxOnException(() -> {
-				Location l = getTool().getLocation();
-				Helpers.copyLocationIntoTextFields(l, textFieldX, textFieldY,
-						textFieldZ, textFieldC);
-			});
-		}
-	};
-
-	private Action captureActuatorCoordinatesAction = new AbstractAction(
-			"Get Actuator Coordinates", Icons.capturePin) {
-		{
-			putValue(Action.SHORT_DESCRIPTION,
-					"Capture the location that the actuator is centered on.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.messageBoxOnException(() -> {
-				Actuator actuator = getActuator();
-				if (actuator == null) {
-					return;
-				}
-				Helpers.copyLocationIntoTextFields(actuator.getLocation(), 
-						textFieldX, textFieldY,
-						textFieldZ, textFieldC);
-			});
-			
-		}
-	};
-
-	private Action positionCameraAction = new AbstractAction("Position Camera",
-			Icons.centerCamera) {
-		{
-			putValue(Action.SHORT_DESCRIPTION,
-					"Position the camera over the center of the location.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.submitUiMachineTask(() -> {
-				Camera camera = getCamera();
-	            Location location = getParsedLocation();
-			    MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-			});
-		}
-	};
-
-    private Action positionToolAction = new AbstractAction("Position Tool",
-            Icons.centerTool) {
-        {
-            putValue(Action.SHORT_DESCRIPTION,
-                    "Position the tool over the center of the location.");
+    private JTextField textFieldX, textFieldY, textFieldZ, textFieldC;
+    private String actuatorName;
+
+    private JButton buttonCenterTool;
+    private JButton buttonCaptureCamera;
+    private JButton buttonCaptureTool;
+
+    public LocationButtonsPanel(JTextField textFieldX, JTextField textFieldY, JTextField textFieldZ,
+            JTextField textFieldC) {
+        FlowLayout flowLayout = (FlowLayout) getLayout();
+        flowLayout.setVgap(0);
+        flowLayout.setHgap(2);
+        this.textFieldX = textFieldX;
+        this.textFieldY = textFieldY;
+        this.textFieldZ = textFieldZ;
+        this.textFieldC = textFieldC;
+
+        buttonCaptureCamera = new JButton(captureCameraCoordinatesAction);
+        buttonCaptureCamera.setHideActionText(true);
+        add(buttonCaptureCamera);
+
+        buttonCaptureTool = new JButton(captureToolCoordinatesAction);
+        buttonCaptureTool.setHideActionText(true);
+        add(buttonCaptureTool);
+
+        JButton buttonCenterCamera = new JButton(positionCameraAction);
+        buttonCenterCamera.setHideActionText(true);
+        add(buttonCenterCamera);
+
+        buttonCenterTool = new JButton(positionToolAction);
+        buttonCenterTool.setHideActionText(true);
+        add(buttonCenterTool);
+
+        buttonCenterToolNoSafeZ = new JButton(positionToolNoSafeZAction);
+        buttonCenterToolNoSafeZ.setHideActionText(true);
+
+        setActuatorName(null);
+    }
+
+    public void setShowPositionToolNoSafeZ(boolean b) {
+        if (b) {
+            add(buttonCenterToolNoSafeZ);
+        }
+        else {
+            remove(buttonCenterToolNoSafeZ);
         }
+    }
 
-        @Override
-        public void actionPerformed(ActionEvent arg0) {
-            UiUtils.submitUiMachineTask(() -> {
-                HeadMountable tool = getTool();
-                Location location = getParsedLocation();
-                MovableUtils.moveToLocationAtSafeZ(tool, location, 1.0);
-            });
+    public void setActuatorName(String actuatorName) {
+        this.actuatorName = actuatorName;
+        if (actuatorName == null || actuatorName.trim().length() == 0) {
+            buttonCaptureTool.setAction(captureToolCoordinatesAction);
+            buttonCenterTool.setAction(positionToolAction);
         }
-    };
+        else {
+            buttonCaptureTool.setAction(captureActuatorCoordinatesAction);
+            buttonCenterTool.setAction(positionActuatorAction);
+        }
+    }
+
+    public String getActuatorName() {
+        return actuatorName;
+    }
 
-    private Action positionToolNoSafeZAction = new AbstractAction("Position Tool (Without Safe Z)",
-            Icons.centerToolNoSafeZ) {
+    public HeadMountable getTool() throws Exception {
+        return MainFrame.machineControlsPanel.getSelectedNozzle();
+    }
+
+    public Camera getCamera() throws Exception {
+        return getTool().getHead().getDefaultCamera();
+    }
+
+    /**
+     * Get the Actuator with the name provided by setActuatorName() that is on the same Head as the
+     * tool from getTool().
+     * 
+     * @return
+     * @throws Exception
+     */
+    public Actuator getActuator() throws Exception {
+        if (actuatorName == null) {
+            return null;
+        }
+        HeadMountable tool = getTool();
+        Head head = tool.getHead();
+        Actuator actuator = head.getActuator(actuatorName);
+        if (actuator == null) {
+            throw new Exception(String.format("No Actuator with name %s on Head %s", actuatorName,
+                    head.getName()));
+        }
+        return actuator;
+    }
+
+    private Location getParsedLocation() {
+        double x = 0, y = 0, z = 0, rotation = 0;
+        if (textFieldX != null) {
+            x = Length.parse(textFieldX.getText()).getValue();
+        }
+        if (textFieldY != null) {
+            y = Length.parse(textFieldY.getText()).getValue();
+        }
+        if (textFieldZ != null) {
+            z = Length.parse(textFieldZ.getText()).getValue();
+        }
+        if (textFieldC != null) {
+            rotation = Double.parseDouble(textFieldC.getText());
+        }
+        return new Location(Configuration.get().getSystemUnits(), x, y, z, rotation);
+    }
+
+    private Action captureCameraCoordinatesAction =
+            new AbstractAction("Get Camera Coordinates", Icons.captureCamera) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Capture the location that the camera is centered on.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.messageBoxOnException(() -> {
+                        Location l = getCamera().getLocation();
+                        Helpers.copyLocationIntoTextFields(l, textFieldX, textFieldY, null,
+                                textFieldC);
+                    });
+                }
+            };
+
+    private Action captureToolCoordinatesAction =
+            new AbstractAction("Get Tool Coordinates", Icons.captureTool) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Capture the location that the tool is centered on.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.messageBoxOnException(() -> {
+                        Location l = getTool().getLocation();
+                        Helpers.copyLocationIntoTextFields(l, textFieldX, textFieldY, textFieldZ,
+                                textFieldC);
+                    });
+                }
+            };
+
+    private Action captureActuatorCoordinatesAction =
+            new AbstractAction("Get Actuator Coordinates", Icons.capturePin) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Capture the location that the actuator is centered on.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.messageBoxOnException(() -> {
+                        Actuator actuator = getActuator();
+                        if (actuator == null) {
+                            return;
+                        }
+                        Helpers.copyLocationIntoTextFields(actuator.getLocation(), textFieldX,
+                                textFieldY, textFieldZ, textFieldC);
+                    });
+
+                }
+            };
+
+    private Action positionCameraAction =
+            new AbstractAction("Position Camera", Icons.centerCamera) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Position the camera over the center of the location.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.submitUiMachineTask(() -> {
+                        Camera camera = getCamera();
+                        Location location = getParsedLocation();
+                        MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
+                    });
+                }
+            };
+
+    private Action positionToolAction = new AbstractAction("Position Tool", Icons.centerTool) {
         {
             putValue(Action.SHORT_DESCRIPTION,
-                    "Position the tool over the center of the location without first moving to Safe Z.");
+                    "Position the tool over the center of the location.");
         }
 
         @Override
@@ -265,26 +242,43 @@ public void actionPerformed(ActionEvent arg0) {
             UiUtils.submitUiMachineTask(() -> {
                 HeadMountable tool = getTool();
                 Location location = getParsedLocation();
-                tool.moveTo(location, 1.0);
+                MovableUtils.moveToLocationAtSafeZ(tool, location, 1.0);
             });
         }
     };
 
-	private Action positionActuatorAction = new AbstractAction(
-			"Position Actuator", Icons.centerPin) {
-		{
-			putValue(Action.SHORT_DESCRIPTION,
-					"Position the actuator over the center of the location.");
-		}
-
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			UiUtils.submitUiMachineTask(() -> {
-				Actuator actuator = getActuator();
-	            Location location = getParsedLocation();
-			    MovableUtils.moveToLocationAtSafeZ(actuator, location, 1.0);
-			});
-		}
-	};
-	private JButton buttonCenterToolNoSafeZ;
+    private Action positionToolNoSafeZAction =
+            new AbstractAction("Position Tool (Without Safe Z)", Icons.centerToolNoSafeZ) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Position the tool over the center of the location without first moving to Safe Z.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.submitUiMachineTask(() -> {
+                        HeadMountable tool = getTool();
+                        Location location = getParsedLocation();
+                        tool.moveTo(location, 1.0);
+                    });
+                }
+            };
+
+    private Action positionActuatorAction =
+            new AbstractAction("Position Actuator", Icons.centerPin) {
+                {
+                    putValue(Action.SHORT_DESCRIPTION,
+                            "Position the actuator over the center of the location.");
+                }
+
+                @Override
+                public void actionPerformed(ActionEvent arg0) {
+                    UiUtils.submitUiMachineTask(() -> {
+                        Actuator actuator = getActuator();
+                        Location location = getParsedLocation();
+                        MovableUtils.moveToLocationAtSafeZ(actuator, location, 1.0);
+                    });
+                }
+            };
+    private JButton buttonCenterToolNoSafeZ;
 }
diff --git a/src/main/java/org/openpnp/gui/components/SeparatorComboBox.java b/src/main/java/org/openpnp/gui/components/SeparatorComboBox.java
index 5072f264ff..5f88ba7cc8 100755
--- a/src/main/java/org/openpnp/gui/components/SeparatorComboBox.java
+++ b/src/main/java/org/openpnp/gui/components/SeparatorComboBox.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components;
@@ -33,151 +31,135 @@
 import javax.swing.ListCellRenderer;
 
 /**
- *  Class that allows you to add a JSeparator to the ComboBoxModel.
+ * Class that allows you to add a JSeparator to the ComboBoxModel.
  *
- *  The separator is rendered as a horizontal line. Using the Up/Down arrow
- *  keys will cause the combo box selection to skip over the separator.
- *  If you attempt to select the separator with the mouse, the selection
- *  will be ignored and the drop down will remain open.
+ * The separator is rendered as a horizontal line. Using the Up/Down arrow keys will cause the combo
+ * box selection to skip over the separator. If you attempt to select the separator with the mouse,
+ * the selection will be ignored and the drop down will remain open.
  */
 @SuppressWarnings("serial")
-public class SeparatorComboBox extends JComboBox implements KeyListener
-{
-	//  Track key presses and releases
-
-	private boolean released = true;
-
-	//  Track when the separator has been selected
-	private boolean separatorSelected = false;
-
-	/**
-	 *  Standard constructor. See JComboBox API for details
-	 */
-	public SeparatorComboBox()
-	{
-		super();
-		init();
-	}
-
-	/**
-	 *  Standard constructor. See JComboBox API for details
-	 */
-	public SeparatorComboBox(ComboBoxModel model)
-	{
-		super(model);
-		init();
-	}
-
-	/**
-	 *  Standard constructor. See JComboBox API for details
-	 */
-	public SeparatorComboBox(Object[] items)
-	{
-		super(items);
-		init();
-	}
-
-	/**
-	 *  Standard constructor. See JComboBox API for details
-	 */
-	public SeparatorComboBox(Vector<?> items)
-	{
-		super(items);
-		init();
-	}
-
-	private void init()
-	{
-		setRenderer( new SeparatorRenderer() );
-		addKeyListener(this);
-	}
-
-	/**
-	 *	Prevent selection of the separator by keyboard or mouse
-	 */
-	@Override
-	public void setSelectedIndex(int index)
-	{
-		Object value = getItemAt(index);
-
-		//  Attempting to select a separator
-
-		if (value instanceof JSeparator)
-		{
-			//  If no keys have been pressed then we must be using the mouse.
-			//  Prevent selection of the Separator when using the mouse
-
-			if (released)
-			{
-				separatorSelected = true;
-				return;
-			}
-
-			//  Skip over the Separator when using the Up/Down keys
-
-			int current = getSelectedIndex();
-			index += (index > current) ? 1 : -1;
-
-			if (index == -1 || index >= dataModel.getSize())
-				return;
-		}
-
-		super.setSelectedIndex(index);
-	}
-
-	/**
-	 *  Prevent closing of the popup when attempting to select the
-	 *  separator with the mouse.
-	 */
-	@Override
-	public void setPopupVisible(boolean visible)
-	{
-		//  Keep the popup open when the separator was clicked on
-
-		if (separatorSelected)
-		{
-			separatorSelected = false;
-			return;
-		}
-
-		super.setPopupVisible(visible);
-	}
-
-//
-//  Implement the KeyListener interface
-//
-	public void keyPressed(KeyEvent e)
-	{
-		released = false;
-	}
-
-	public void keyReleased(KeyEvent e)
-	{
-		released = true;
-	}
-
-	public void keyTyped(KeyEvent e) {}
-
-	/**
-	 *  Class to render the JSeparator compenent
-	 */
-	class SeparatorRenderer implements ListCellRenderer
-	{
-		private ListCellRenderer renderer;
-		
-		public SeparatorRenderer() {
-			renderer = new JComboBox().getRenderer();
-		}
-		
-		public Component getListCellRendererComponent(JList list, Object value,
-			int index, boolean isSelected, boolean cellHasFocus)
-		{
-			if (value instanceof JSeparator) {
-				return (JSeparator)value;
-			}
-			else {
-				return renderer.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
-			}
-		}
-	}
+public class SeparatorComboBox extends JComboBox implements KeyListener {
+    // Track key presses and releases
+
+    private boolean released = true;
+
+    // Track when the separator has been selected
+    private boolean separatorSelected = false;
+
+    /**
+     * Standard constructor. See JComboBox API for details
+     */
+    public SeparatorComboBox() {
+        super();
+        init();
+    }
+
+    /**
+     * Standard constructor. See JComboBox API for details
+     */
+    public SeparatorComboBox(ComboBoxModel model) {
+        super(model);
+        init();
+    }
+
+    /**
+     * Standard constructor. See JComboBox API for details
+     */
+    public SeparatorComboBox(Object[] items) {
+        super(items);
+        init();
+    }
+
+    /**
+     * Standard constructor. See JComboBox API for details
+     */
+    public SeparatorComboBox(Vector<?> items) {
+        super(items);
+        init();
+    }
+
+    private void init() {
+        setRenderer(new SeparatorRenderer());
+        addKeyListener(this);
+    }
+
+    /**
+     * Prevent selection of the separator by keyboard or mouse
+     */
+    @Override
+    public void setSelectedIndex(int index) {
+        Object value = getItemAt(index);
+
+        // Attempting to select a separator
+
+        if (value instanceof JSeparator) {
+            // If no keys have been pressed then we must be using the mouse.
+            // Prevent selection of the Separator when using the mouse
+
+            if (released) {
+                separatorSelected = true;
+                return;
+            }
+
+            // Skip over the Separator when using the Up/Down keys
+
+            int current = getSelectedIndex();
+            index += (index > current) ? 1 : -1;
+
+            if (index == -1 || index >= dataModel.getSize())
+                return;
+        }
+
+        super.setSelectedIndex(index);
+    }
+
+    /**
+     * Prevent closing of the popup when attempting to select the separator with the mouse.
+     */
+    @Override
+    public void setPopupVisible(boolean visible) {
+        // Keep the popup open when the separator was clicked on
+
+        if (separatorSelected) {
+            separatorSelected = false;
+            return;
+        }
+
+        super.setPopupVisible(visible);
+    }
+
+    //
+    // Implement the KeyListener interface
+    //
+    public void keyPressed(KeyEvent e) {
+        released = false;
+    }
+
+    public void keyReleased(KeyEvent e) {
+        released = true;
+    }
+
+    public void keyTyped(KeyEvent e) {}
+
+    /**
+     * Class to render the JSeparator compenent
+     */
+    class SeparatorRenderer implements ListCellRenderer {
+        private ListCellRenderer renderer;
+
+        public SeparatorRenderer() {
+            renderer = new JComboBox().getRenderer();
+        }
+
+        public Component getListCellRendererComponent(JList list, Object value, int index,
+                boolean isSelected, boolean cellHasFocus) {
+            if (value instanceof JSeparator) {
+                return (JSeparator) value;
+            }
+            else {
+                return renderer.getListCellRendererComponent(list, value, index, isSelected,
+                        cellHasFocus);
+            }
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/reticle/CrosshairReticle.java b/src/main/java/org/openpnp/gui/components/reticle/CrosshairReticle.java
index 673c05bd67..8ad58756c5 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/CrosshairReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/CrosshairReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -49,17 +47,15 @@ public void setColor(Color color) {
 
     @Override
     public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
-            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY,
-            double viewPortCenterX, double viewPortCenterY, int viewPortWidth,
-            int viewPortHeight, double rotation) {
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
 
         g2d.setStroke(new BasicStroke(1f));
-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-                RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
 
         // Calculate half the diagonal size of the viewport.
-        int halfDiagonal = (int) (Math.sqrt(Math.pow(viewPortWidth, 2)
-                + Math.pow(viewPortHeight, 2)) / 2.0);
+        int halfDiagonal =
+                (int) (Math.sqrt(Math.pow(viewPortWidth, 2) + Math.pow(viewPortHeight, 2)) / 2.0);
 
         AffineTransform origTx = g2d.getTransform();
 
diff --git a/src/main/java/org/openpnp/gui/components/reticle/FiducialReticle.java b/src/main/java/org/openpnp/gui/components/reticle/FiducialReticle.java
index 1d71f8aee2..099411113a 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/FiducialReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/FiducialReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -83,18 +81,15 @@ public void setSize(double size) {
 
     @Override
     public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
-            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY,
-            double viewPortCenterX, double viewPortCenterY, int viewPortWidth,
-            int viewPortHeight, double rotation) {
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
 
-        super.draw(g2d, cameraUnitsPerPixelUnits, cameraUnitsPerPixelX,
-                cameraUnitsPerPixelY, viewPortCenterX, viewPortCenterY,
-                viewPortWidth, viewPortHeight, rotation);
+        super.draw(g2d, cameraUnitsPerPixelUnits, cameraUnitsPerPixelX, cameraUnitsPerPixelY,
+                viewPortCenterX, viewPortCenterY, viewPortWidth, viewPortHeight, rotation);
 
         g2d.setColor(color);
         g2d.setStroke(new BasicStroke(1f));
-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-                RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
 
         AffineTransform origTx = g2d.getTransform();
 
@@ -102,10 +97,10 @@ public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
         // AffineTransform rotates positive clockwise, so we invert the value.
         g2d.rotate(Math.toRadians(-rotation));
 
-        double pixelsPerUnitX = 1.0 / new Length(cameraUnitsPerPixelX,
-                cameraUnitsPerPixelUnits).convertToUnits(this.units).getValue();
-        double pixelsPerUnitY = 1.0 / new Length(cameraUnitsPerPixelY,
-                cameraUnitsPerPixelUnits).convertToUnits(this.units).getValue();
+        double pixelsPerUnitX = 1.0 / new Length(cameraUnitsPerPixelX, cameraUnitsPerPixelUnits)
+                .convertToUnits(this.units).getValue();
+        double pixelsPerUnitY = 1.0 / new Length(cameraUnitsPerPixelY, cameraUnitsPerPixelUnits)
+                .convertToUnits(this.units).getValue();
 
         int width = (int) (size * pixelsPerUnitX);
         int height = (int) (size * pixelsPerUnitY);
diff --git a/src/main/java/org/openpnp/gui/components/reticle/FootprintReticle.java b/src/main/java/org/openpnp/gui/components/reticle/FootprintReticle.java
index 0f378700f8..e1576fd936 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/FootprintReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/FootprintReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -33,54 +31,47 @@
 import org.openpnp.model.LengthUnit;
 
 public class FootprintReticle implements Reticle {
-	private Color color;
-	private Footprint footprint;
-	
-	public FootprintReticle(Footprint footprint) {
-	    this.footprint = footprint;
-	    this.color = Color.yellow;
-	}
-	
+    private Color color;
+    private Footprint footprint;
+
+    public FootprintReticle(Footprint footprint) {
+        this.footprint = footprint;
+        this.color = Color.yellow;
+    }
+
     @Override
-	public void draw(Graphics2D g2d,
-			LengthUnit cameraUnitsPerPixelUnits,
-			double cameraUnitsPerPixelX, 
-			double cameraUnitsPerPixelY, 
-			double viewPortCenterX, 
-			double viewPortCenterY,
-			int viewPortWidth,
-			int viewPortHeight,
-			double rotation) {
-		
-		g2d.setStroke(new BasicStroke(1f));
-		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-				RenderingHints.VALUE_ANTIALIAS_ON);
-		g2d.setColor(color);
-		
-		Shape shape = footprint.getShape();
-		if (shape == null) {
-		    return;
-		}
-		// Determine the scaling factor to go from Outline units to
-		// Camera units.
-		Length l = new Length(1, footprint.getUnits());
-		l = l.convertToUnits(cameraUnitsPerPixelUnits);
-		double unitScale = l.getValue();
-		
-		// Create a transform to scale the Shape by
-		AffineTransform tx = new AffineTransform();
-		
+    public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
+
+        g2d.setStroke(new BasicStroke(1f));
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setColor(color);
+
+        Shape shape = footprint.getShape();
+        if (shape == null) {
+            return;
+        }
+        // Determine the scaling factor to go from Outline units to
+        // Camera units.
+        Length l = new Length(1, footprint.getUnits());
+        l = l.convertToUnits(cameraUnitsPerPixelUnits);
+        double unitScale = l.getValue();
+
+        // Create a transform to scale the Shape by
+        AffineTransform tx = new AffineTransform();
+
         tx.translate(viewPortCenterX, viewPortCenterY);
         // AffineTransform rotates positive clockwise, so we invert the value.
         tx.rotate(Math.toRadians(-rotation));
-        
+
         // First we scale by units to convert the units and then we scale
         // by the camera X and Y units per pixels to get pixel locations.
-		tx.scale(unitScale, unitScale);
-		tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
-		
-		// Transform the Shape and draw it out.
-		shape = tx.createTransformedShape(shape);
-		g2d.draw(shape);
-	}
+        tx.scale(unitScale, unitScale);
+        tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
+
+        // Transform the Shape and draw it out.
+        shape = tx.createTransformedShape(shape);
+        g2d.draw(shape);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/reticle/OutlineReticle.java b/src/main/java/org/openpnp/gui/components/reticle/OutlineReticle.java
index 37fe976c59..e5dad050d7 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/OutlineReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/OutlineReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -33,71 +31,64 @@
 import org.openpnp.model.Outline;
 
 public class OutlineReticle implements Reticle {
-	private Color color;
-	private Outline outline;
-	
-	public OutlineReticle(Outline outline) {
-		setOutline(outline);
-		setColor(Color.red);
-	}
-	
-	public Color getColor() {
-		return color;
-	}
-
-	public void setColor(Color color) {
-		this.color = color;
-	}
-	
-	public Outline getOutline() {
-		return outline;
-	}
-
-	public void setOutline(Outline outline) {
-		this.outline = outline;
-	}
-
-	@Override
-	public void draw(Graphics2D g2d,
-			LengthUnit cameraUnitsPerPixelUnits,
-			double cameraUnitsPerPixelX, 
-			double cameraUnitsPerPixelY, 
-			double viewPortCenterX, 
-			double viewPortCenterY,
-			int viewPortWidth,
-			int viewPortHeight,
-			double rotation) {
-		
-		g2d.setStroke(new BasicStroke(1f));
-		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-				RenderingHints.VALUE_ANTIALIAS_ON);
-		g2d.setColor(color);
-		
-
-		Shape shape = outline.getShape();
-		if (shape == null) {
-		    return;
-		}
-		// Determine the scaling factor to go from Outline units to
-		// Camera units.
-		Length l = new Length(1, outline.getUnits());
-		l = l.convertToUnits(cameraUnitsPerPixelUnits);
-		double unitScale = l.getValue();
-		
-		// Create a transform to scale the Shape by
-		AffineTransform tx = new AffineTransform();
-		
+    private Color color;
+    private Outline outline;
+
+    public OutlineReticle(Outline outline) {
+        setOutline(outline);
+        setColor(Color.red);
+    }
+
+    public Color getColor() {
+        return color;
+    }
+
+    public void setColor(Color color) {
+        this.color = color;
+    }
+
+    public Outline getOutline() {
+        return outline;
+    }
+
+    public void setOutline(Outline outline) {
+        this.outline = outline;
+    }
+
+    @Override
+    public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
+
+        g2d.setStroke(new BasicStroke(1f));
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setColor(color);
+
+
+        Shape shape = outline.getShape();
+        if (shape == null) {
+            return;
+        }
+        // Determine the scaling factor to go from Outline units to
+        // Camera units.
+        Length l = new Length(1, outline.getUnits());
+        l = l.convertToUnits(cameraUnitsPerPixelUnits);
+        double unitScale = l.getValue();
+
+        // Create a transform to scale the Shape by
+        AffineTransform tx = new AffineTransform();
+
         tx.translate(viewPortCenterX, viewPortCenterY);
         // AffineTransform rotates positive clockwise, so we invert the value.
         tx.rotate(Math.toRadians(-rotation));
-        
+
         // First we scale by units to convert the units and then we scale
         // by the camera X and Y units per pixels to get pixel locations.
-		tx.scale(unitScale, unitScale);
-		tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
-		
-		// Transform the Shape and draw it out.
-		shape = tx.createTransformedShape(shape);
-		g2d.draw(shape);
-	}
+        tx.scale(unitScale, unitScale);
+        tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
+
+        // Transform the Shape and draw it out.
+        shape = tx.createTransformedShape(shape);
+        g2d.draw(shape);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/reticle/PackageReticle.java b/src/main/java/org/openpnp/gui/components/reticle/PackageReticle.java
index 2412ef3c10..9e565e596a 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/PackageReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/PackageReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -33,22 +31,22 @@
 import org.openpnp.model.LengthUnit;
 
 public class PackageReticle implements Reticle {
-	private Color color;
-	private org.openpnp.model.Package pkg;
-	
-	public PackageReticle(org.openpnp.model.Package pkg) {
-		setPkg(pkg);
-		setColor(Color.yellow);
-	}
-	
-	public Color getColor() {
-		return color;
-	}
-
-	public void setColor(Color color) {
-		this.color = color;
-	}
-	
+    private Color color;
+    private org.openpnp.model.Package pkg;
+
+    public PackageReticle(org.openpnp.model.Package pkg) {
+        setPkg(pkg);
+        setColor(Color.yellow);
+    }
+
+    public Color getColor() {
+        return color;
+    }
+
+    public void setColor(Color color) {
+        this.color = color;
+    }
+
     public org.openpnp.model.Package getPkg() {
         return pkg;
     }
@@ -58,50 +56,43 @@ public void setPkg(org.openpnp.model.Package pkg) {
     }
 
     @Override
-	public void draw(Graphics2D g2d,
-			LengthUnit cameraUnitsPerPixelUnits,
-			double cameraUnitsPerPixelX, 
-			double cameraUnitsPerPixelY, 
-			double viewPortCenterX, 
-			double viewPortCenterY,
-			int viewPortWidth,
-			int viewPortHeight,
-			double rotation) {
-		
-		g2d.setStroke(new BasicStroke(1f));
-		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-				RenderingHints.VALUE_ANTIALIAS_ON);
-		g2d.setColor(color);
-		
-
-		Footprint footprint = pkg.getFootprint();
-		if (footprint == null) {
-		    return;
-		}
-		Shape shape = footprint.getShape();
-		if (shape == null) {
-		    return;
-		}
-		// Determine the scaling factor to go from Outline units to
-		// Camera units.
-		Length l = new Length(1, footprint.getUnits());
-		l = l.convertToUnits(cameraUnitsPerPixelUnits);
-		double unitScale = l.getValue();
-		
-		// Create a transform to scale the Shape by
-		AffineTransform tx = new AffineTransform();
-		
+    public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
+
+        g2d.setStroke(new BasicStroke(1f));
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setColor(color);
+
+
+        Footprint footprint = pkg.getFootprint();
+        if (footprint == null) {
+            return;
+        }
+        Shape shape = footprint.getShape();
+        if (shape == null) {
+            return;
+        }
+        // Determine the scaling factor to go from Outline units to
+        // Camera units.
+        Length l = new Length(1, footprint.getUnits());
+        l = l.convertToUnits(cameraUnitsPerPixelUnits);
+        double unitScale = l.getValue();
+
+        // Create a transform to scale the Shape by
+        AffineTransform tx = new AffineTransform();
+
         tx.translate(viewPortCenterX, viewPortCenterY);
         // AffineTransform rotates positive clockwise, so we invert the value.
         tx.rotate(Math.toRadians(-rotation));
-        
+
         // First we scale by units to convert the units and then we scale
         // by the camera X and Y units per pixels to get pixel locations.
-		tx.scale(unitScale, unitScale);
-		tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
-		
-		// Transform the Shape and draw it out.
-		shape = tx.createTransformedShape(shape);
-		g2d.fill(shape);
-	}
+        tx.scale(unitScale, unitScale);
+        tx.scale(1.0 / cameraUnitsPerPixelX, 1.0 / cameraUnitsPerPixelY);
+
+        // Transform the Shape and draw it out.
+        shape = tx.createTransformedShape(shape);
+        g2d.fill(shape);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/components/reticle/Reticle.java b/src/main/java/org/openpnp/gui/components/reticle/Reticle.java
index 727951de23..7e5dedf24c 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/Reticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/Reticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -27,14 +25,7 @@
 
 
 public interface Reticle {
-	public void draw(
-			Graphics2D g2d, 
-			LengthUnit cameraUnitsPerPixelUnits,
-			double cameraUnitsPerPixelX, 
-			double cameraUnitsPerPixelY, 
-			double viewPortCenterX, 
-			double viewPortCenterY,
-			int viewPortWidth,
-			int viewPortHeight,
-			double rotation);
+    public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation);
 }
diff --git a/src/main/java/org/openpnp/gui/components/reticle/RulerReticle.java b/src/main/java/org/openpnp/gui/components/reticle/RulerReticle.java
index be7d3d5c44..874a84556f 100755
--- a/src/main/java/org/openpnp/gui/components/reticle/RulerReticle.java
+++ b/src/main/java/org/openpnp/gui/components/reticle/RulerReticle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.components.reticle;
@@ -59,21 +57,18 @@ public void setUnitsPerTick(double unitsPerTick) {
 
     @Override
     public void draw(Graphics2D g2d, LengthUnit cameraUnitsPerPixelUnits,
-            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY,
-            double viewPortCenterX, double viewPortCenterY, int viewPortWidth,
-            int viewPortHeight, double rotation) {
+            double cameraUnitsPerPixelX, double cameraUnitsPerPixelY, double viewPortCenterX,
+            double viewPortCenterY, int viewPortWidth, int viewPortHeight, double rotation) {
 
-        super.draw(g2d, cameraUnitsPerPixelUnits, cameraUnitsPerPixelX,
-                cameraUnitsPerPixelY, viewPortCenterX, viewPortCenterY,
-                viewPortWidth, viewPortHeight, rotation);
+        super.draw(g2d, cameraUnitsPerPixelUnits, cameraUnitsPerPixelX, cameraUnitsPerPixelY,
+                viewPortCenterX, viewPortCenterY, viewPortWidth, viewPortHeight, rotation);
 
         g2d.setStroke(new BasicStroke(1f));
-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-                RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
 
         // Calculate half the diagonal size of the viewport.
-        int halfDiagonal = (int) (Math.sqrt(Math.pow(viewPortWidth, 2)
-                + Math.pow(viewPortHeight, 2)) / 2.0);
+        int halfDiagonal =
+                (int) (Math.sqrt(Math.pow(viewPortWidth, 2) + Math.pow(viewPortHeight, 2)) / 2.0);
 
         AffineTransform origTx = g2d.getTransform();
 
diff --git a/src/main/java/org/openpnp/gui/importer/BoardImporter.java b/src/main/java/org/openpnp/gui/importer/BoardImporter.java
index 4504a49466..9d9f4d8934 100755
--- a/src/main/java/org/openpnp/gui/importer/BoardImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/BoardImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -26,7 +24,9 @@
 import org.openpnp.model.Board;
 
 public interface BoardImporter {
-	public Board importBoard(Frame parent) throws Exception;
-	public String getImporterName();
-	public String getImporterDescription();
+    public Board importBoard(Frame parent) throws Exception;
+
+    public String getImporterName();
+
+    public String getImporterDescription();
 }
diff --git a/src/main/java/org/openpnp/gui/importer/EagleBoardImporter.java b/src/main/java/org/openpnp/gui/importer/EagleBoardImporter.java
index 5a0b0743c6..480a34c6e6 100755
--- a/src/main/java/org/openpnp/gui/importer/EagleBoardImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/EagleBoardImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2015 Douglas Pearless <Douglas.Pearless@gmail.com>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2015 Douglas Pearless <Douglas.Pearless@gmail.com>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -76,18 +74,19 @@
 
 @SuppressWarnings("serial")
 public class EagleBoardImporter implements BoardImporter {
-	private final static Logger logger = LoggerFactory.getLogger(EagleBoardImporter.class);
-	
+    private final static Logger logger = LoggerFactory.getLogger(EagleBoardImporter.class);
+
     private final static String NAME = "CadSoft EAGLE Board";
-    private final static String DESCRIPTION = "Import files directly from EAGLE's <filename>.brd file.";
+    private final static String DESCRIPTION =
+            "Import files directly from EAGLE's <filename>.brd file.";
 
-	private static Board board;
-	private File boardFile;
-	static private Double mil_to_mm = 0.0254;
+    private static Board board;
+    private File boardFile;
+    static private Double mil_to_mm = 0.0254;
 
-	@Override
+    @Override
     public String getImporterName() {
-	    return NAME;
+        return NAME;
     }
 
     @Override
@@ -96,351 +95,572 @@ public String getImporterDescription() {
     }
 
     @Override
-	public Board importBoard(Frame parent) throws Exception {
+    public Board importBoard(Frame parent) throws Exception {
         Dlg dlg = new Dlg(parent);
-		dlg.setVisible(true);
-		return board;
-	}
-    
-	private static List<Placement> parseFile(File file, Side side, boolean createMissingParts) throws Exception {
-		
-		String dimensionLayer = "";
-		String topLayer    = "";
-		String bottomLayer = "";
-		String tCreamLayer = "";
-		String bCreamLayer = "";
-		
-		String mmMinCreamFrame_string;
-		double mmMinCreamFrame_number = 0;
-		String mmMaxCreamFrame_string;
-		double mmMaxCreamFrame_number = 0;
-		String libraryId = "";
-		String packageId = "";
-		Part part = null;
-		
-		List<BoardPad> pads = new ArrayList<>();
-		
-		ArrayList<Placement> placements = new ArrayList<>();
-		//we don't use the 'side' parameter as we can read this from the .brd file
-		//in the future we could use the side parameter to restrict this from only parsing one side or the other or both
-		
-		EagleLoader boardToProcess = new EagleLoader(file);
-		if (boardToProcess.board != null ) {
-			
-			//first establish which is the Dimension, Top, Bottom, tCream and bCream layers in case the board has non-standard layer numbering
-			for (Layer layer : boardToProcess.layers.getLayer() ) {
-				if (layer.getName().equalsIgnoreCase("Dimension")) {
-					dimensionLayer = layer.getNumber();
-				} else if (layer.getName().equalsIgnoreCase("Top")) {
-					topLayer = layer.getNumber();
-				} else if (layer.getName().equalsIgnoreCase("Bottom")) {
-					bottomLayer = layer.getNumber();
-				} else if (layer.getName().equalsIgnoreCase("tCream")) {
-					tCreamLayer = layer.getNumber();
-				} else if (layer.getName().equalsIgnoreCase("bCream")) {
-					bCreamLayer = layer.getNumber();
-				}
-			}
-			
-			//Now we want to establish the width of the board which we need to record
-			Double x_boundary = 0.0;
-			for (Object e:  boardToProcess.board.getPlain().getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole()) {
-				if (e instanceof org.openpnp.model.eagle.xml.Wire) {
-					if (((org.openpnp.model.eagle.xml.Wire) e).getLayer().equalsIgnoreCase(dimensionLayer)) {
-						x_boundary = Math.max( x_boundary,  Double.parseDouble(((org.openpnp.model.eagle.xml.Wire) e).getX1() ));
-						x_boundary = Math.max( x_boundary,  Double.parseDouble(((org.openpnp.model.eagle.xml.Wire) e).getX2() ));
-					}
-				}
-			}
-			Point center = new Point(x_boundary/2,0); //note that we set x = maximum x point on the Y=0;
-			
-			// determine the parameters for the pads based on DesignRules
-			for (Param params : boardToProcess.board.getDesignrules().getParam() ) {
-
-				if (params.getName().compareToIgnoreCase("mlMinCreamFrame")==0) { //found exact match when 0 returned
-					mmMinCreamFrame_string = params.getValue().replaceAll("[A-Za-z ]", ""); //remove all letters, i.e. 0mil becomes 0
-					if (params.getValue().toUpperCase().endsWith("MIL")) {
-						mmMinCreamFrame_number = Double.parseDouble(mmMinCreamFrame_string) * mil_to_mm;
-					} else if (params.getValue().toUpperCase().endsWith("MM")) {
-						mmMinCreamFrame_number = Double.parseDouble(mmMinCreamFrame_string) * mil_to_mm;
-					} else throw new Exception("mlMinCream must either be in mil or mm"); // Force the importer to abort, something is very wrong
-				}
-				if (params.getName().compareToIgnoreCase("mlMaxCreamFrame")==0) { //found exact match when 0 returned
-					mmMaxCreamFrame_string = params.getValue().replaceAll("[A-Za-z ]", ""); //remove all letters, i.e. "0mil" becomes 0
-					if (params.getValue().toUpperCase().endsWith("MIL")) {
-						mmMaxCreamFrame_number = Double.parseDouble(mmMaxCreamFrame_string) * mil_to_mm;
-					} else if (params.getValue().toUpperCase().endsWith("MM")) {
-						mmMaxCreamFrame_number = Double.parseDouble(mmMaxCreamFrame_string);
-					} else throw new Exception("mlMaxCream must either be in mil or mm"); // Force the importer to abort, something is very wrong
-				}				
-			}
-			// Now we know the min and max tolerance for the cream (aka solder paste)
-			// which are mmMinCreamFrame_number and mmMaxCreamFrame_number and are in mm (converted from mil as required)
-			
-			//Now we got through each of the parts 
-			if( ! boardToProcess.board.getElements().getElement().isEmpty()){
-				
-				// Process each of the element items
-				for (Element element : boardToProcess.board.getElements().getElement() ) {
-					//first we determine if the part is on the top layer or bottom layer
-					
-					Side element_side;
-					String rot = element.getRot();
-					if (rot.toUpperCase().startsWith("M"))
-						//The part is mirrored and therefore is on the bottom of the board
-						element_side = Side.Bottom;
-					else
-						element_side = Side.Top;
-					
-					//Now determine if we want to process this part based on which side of the board it is on
-					
-					if (side != null) { //null means process both sides
-						if (side != element_side) continue; //exit this loop and process the next element
-					}
-					
-					String rot_number = rot.replaceAll("[A-Za-z ]", ""); //remove all letters, i.e. R180 becomes 180
-
-					Placement placement = new Placement(element.getName());
-					double rotation = Double.parseDouble(rot_number);
-					double x = Double.parseDouble(element.getX());
-					double y = Double.parseDouble(element.getY());
-					placement.setLocation(new Location(
-					        LengthUnit.Millimeters,
-					        x,
-					        y,
-					        0,
-					        rotation));
-					
-					//placement now contains where the package is on the PCB, we need to work out where the pads
-					//are relative to the 'placement'
-					Configuration cfg = Configuration.get();
-		            if (cfg != null && createMissingParts) {
-		                String value = element.getValue(); // Value
-		                packageId = element.getPackage(); //Package
-		                libraryId = element.getLibrary(); //Library that contains the package
-		                
-		                String pkgId  = libraryId + "-" + packageId;
-		                
-		                String partId = libraryId + "-" + packageId;
-		                if (value.trim().length() > 0) {
-		                    partId += "-" + value;
-		                }
-		                
-		                part = cfg.getPart(partId);
-		                Package pkg = cfg.getPackage(pkgId);
-		                
-		                if ((part == null) || (pkg == null)) {
-		                    
-		                    if (pkg == null) {
-		                        pkg = new Package(pkgId);
-            		            cfg.addPackage(pkg); //save the package in the configuration file
-            		            if (part != null) {
-            		            	cfg.removePart(part);//we have to remove the part so we can re-add it with the correct package & library
-            		            	part = null;
-            		            }
-            		            
-		                    }
-		                	if (part == null) {
-		                		part = new Part(partId);
-            			        part.setPackage(pkg);
-// TODO            			        part.setLibrary(libraryId);
-            			        cfg.addPart(part); //save the package in the configuration file
-		                	}
-            			        cfg.addPart(part);
-		                    }
-		                }
-		                placement.setPart(part);
-		                
-			            //Now we have the part, we now need to add the SolderPastePad to the board
-			            //Note, Eagle has the concept of minimum and max from the edge of the pad so we need to 
-			            //adjust the pad to be the size as the mid-point between the minimum and max
-			            //in practice these are usually 0, which means we paste the entire pad
-
-                        if ( ! boardToProcess.board.getLibraries().getLibrary().isEmpty()) {
-                        	for (Library library: boardToProcess.board.getLibraries().getLibrary()) {
-                        		if (library.getName().equalsIgnoreCase(libraryId)) {
-                        			//we have found the library, now to scan for the package we want
-                        			if ( !library.getPackages().getPackage().isEmpty()) {
-                        				
-                        				ListIterator<org.openpnp.model.eagle.xml.Package> it = library.getPackages().getPackage().listIterator();
-                        				
-                        				while(it.hasNext()) {
-
-                        					org.openpnp.model.eagle.xml.Package pak = (org.openpnp.model.eagle.xml.Package) it.next();
-		                        			if (pak.getName().equalsIgnoreCase(packageId)) {
-
-		                		                for (Object e: pak.getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd()) {
-		                        					if (e instanceof org.openpnp.model.eagle.xml.Smd) {
-		                        						//we have found the correct package in the correct library and we need to to add the pad to the boardPads
-
-		                        						if (!((org.openpnp.model.eagle.xml.Smd) e).getCream().equalsIgnoreCase("No")) { //if cream="no" then we do not paste this pad 
-		                        							
-		                        							Pad.RoundRectangle pad = new Pad.RoundRectangle();
-		                        							pad.setUnits(LengthUnit.Millimeters);
-		                        			            
-		                        							// TODO check that these reduce the pad to the halfway between the minimum & maximum tolerances
-		                        							pad.setHeight(Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getDx())-(mmMaxCreamFrame_number-mmMinCreamFrame_number)/2);
-		                        							pad.setWidth(Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getDy())-(mmMaxCreamFrame_number-mmMinCreamFrame_number)/2);
-		                        			            
-		                        							pad.setRoundness(0);
-		                        							pad.setRoundness(Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getRoundness()));
-		                        			            
-		                        							//first find out how is the package defined
-		                        							Double pad_rotation = Double.parseDouble(rot_number);
-		                        							//now rotate the pad by its own rotation relative to its origin and make sure we don't turn through 360 degrees
-		                        							pad_rotation += Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getRot().replaceAll("[A-Za-z ]", "")) % 360; 
-		                        			            
-		                        							Point A = new Point(Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getX())+x,Double.parseDouble(((org.openpnp.model.eagle.xml.Smd) e).getY())+y);
-		                        			            
-		                        							Point part_center = new Point(x,y);
-		                        			            
-		                        							if (element_side == Side.Top) {
-		                        								if (rotation > 180)
-		                        									A = Utils2D.rotateTranslateCenterPoint(A, rotation,0,0,part_center); //rotate the part-pin
-		                        								else
-		                        									A = Utils2D.rotateTranslateCenterPoint(A, -rotation,0,0,part_center); //rotate the part-pin
-		                        							} else if (element_side == Side.Bottom) {
-		                        								if (rotation > 180)
-		                        									A = Utils2D.rotateTranslateCenterPoint(A, rotation,0,0,part_center); //rotate the part-pin
-		                        								else
-		                        									A = Utils2D.rotateTranslateCenterPoint(A, -(180-rotation),0,0,part_center); //rotate the part-pin
-
-		                        								//Mirror along the Y axis of the board
-		                        								if (A.getX() < center.getX()) {
-		                        									Double offset = center.getX()-A.getX();
-		                        									A.setX(center.getX()+offset); //mirror left to right across the centre of the board
-		                        								} else {
-		                        									Double offset = A.getX() - center.getX();
-		                        									A.setX(center.getX()-offset);
-		                        								}
-		                        								//Mirror along the X axis of the part's center line
-		                        								if (A.getY() < y) {
-		                        									Double offset = y-A.getY();
-		                        									A.setY(y+offset); //mirror top to bottom across the centre of the part
-		                        								} else {
-		                        									Double offset = A.getY()-y;
-		                        									A.setY(y-offset); //mirror bottom to top across the centre of the part
-		                        								}
-		                        					    
-		                        							}
-		                        			            
-		                        							// TODO Need to write the logic for pad rotation
-		                        							//A = Utils2D.rotateTranslateCenterPoint(A, pad_rotation,0,0,center);
-		                        							//
-		                        			            
-		                        			            
-		                        							BoardPad boardPad = new BoardPad(
-		                        			                    pad,
-		                        			                    new Location(LengthUnit.Millimeters,
-						                		    			        A.getX(),
-						                		    			        A.getY(),
-						                		    			        0,
-						                		    			        pad_rotation)
-		                        			                    );
-				                		                      
-		                        							// TODO add support for Circle pads
-		                        			            
-		                        							boardPad.setName(element.getName() + "-" + ((org.openpnp.model.eagle.xml.Smd) e).getName());
-				                		                
-		                        							if ( ((org.openpnp.model.eagle.xml.Smd) e).getLayer().equalsIgnoreCase(topLayer) ) { //is the pad on top
-				                		                		if (element_side == Side.Top) 		// part is on the top
-				                		                			boardPad.setSide(Side.Top);		//pad is on the top
-				                		                		else
-				                		                			boardPad.setSide(Side.Bottom);	//part is on top, but pat is on the bottom
-				                		                	}
-				                		                	else if ( ((org.openpnp.model.eagle.xml.Smd) e).getLayer().equalsIgnoreCase(bottomLayer) ){ //is the pad on the bottom
-				                		                		if (element_side == Side.Top)		//part is top
-				                		                			boardPad.setSide(Side.Bottom);	//pad stays on the bottom
-				                		                		else
-				                		                			boardPad.setSide(Side.Top);		//pad moves to the top
-				                		                	}
-				                		                	else
-				                		                	logger.info("Warning: " + file + "contains a SMD pad that is not on a topLayer or bottomLayer");
-				                		      
-				                		                	// TODO figure out if it is possible for an SMD pad to have a drill, it appears not !!
-				                		                	//pad.setdrillDiameter(0);
-				                		                
-				                		                	// TODO later we need to associate a list of pads to a board.
-				                		                	pads.add(boardPad);
-				                		                
-				                		                	board.addSolderPastePad(boardPad); //This adds the pad to the SolderPaste
-		                        						}    	
-		                        					} else if (e instanceof org.openpnp.model.eagle.xml.Pad) {
-		                        						
-		                        						// TODO implement pasting for through hole pads
-		                        						
-		                        					} else if (e instanceof org.openpnp.model.eagle.xml.Polygon) {
-		                        						//We have a polygon is it on a tCream or bCream layer, otherwise ignore it
-		                        						if (((org.openpnp.model.eagle.xml.Polygon) e).getLayer().equalsIgnoreCase(tCreamLayer) || 
-		                        								((org.openpnp.model.eagle.xml.Polygon) e).getLayer().equalsIgnoreCase(bCreamLayer) ) {
-			                        						logger.info("Warning: " + file + " contains a Polygon pad - this functionality has been implmented as the smallest bounded rectangle and may over paste the area");
-			                        						logger.info("Layer" + ((org.openpnp.model.eagle.xml.Polygon) e).getLayer().toString());
-			                        						Double vertex_x_min = 0.0;
-			                        						Double vertex_x_max = 0.0;
-			                        						Double vertex_y_min = 0.0;
-			                        						Double vertex_y_max = 0.0;
-		                        							ListIterator<org.openpnp.model.eagle.xml.Vertex> vertex_it = ((org.openpnp.model.eagle.xml.Polygon) e).getVertex().listIterator();
-		                        							while(vertex_it.hasNext()) {
-		                        								org.openpnp.model.eagle.xml.Vertex vertex = (Vertex) vertex_it.next();
-		                        								vertex_x_min = Math.min(vertex_x_min, Double.parseDouble(vertex.getX()) );
-		                        								vertex_x_max = Math.max(vertex_x_max, Double.parseDouble(vertex.getX()) );
-		                        								vertex_y_min = Math.min(vertex_y_min, Double.parseDouble(vertex.getY()) );
-		                        								vertex_y_max = Math.max(vertex_y_max, Double.parseDouble(vertex.getY()) );
-		                        								logger.info("Vertex: X=" + vertex.getX() + " y=" + vertex.getY());
-		                        							}
-		                        							// TODO implement polygon pad in Pad.java
-			                        			            Pad.RoundRectangle pad = new Pad.RoundRectangle();
-			                        			            pad.setUnits(LengthUnit.Millimeters);
-			                        			            pad.setRoundness(0);
-			                        			            pad.setHeight((vertex_y_max - vertex_y_min));
-					                		                pad.setWidth((vertex_x_max - vertex_x_min));
-					                		                
-			                        			            BoardPad boardPad = new BoardPad(
-			                        			                    pad,
-			                        			                    new Location(LengthUnit.Millimeters,
-			                        			                    		x+(vertex_x_max + vertex_x_min)/2,
-			                        			                    		y+(vertex_y_max + vertex_y_min)/2,
-							                		    			        0,
-							                		    			        0)
-			                        			                    );
-			                        			            logger.info("Pad generated width is " + pad.getWidth() + " height " + pad.getHeight() + " centered at x = " + boardPad.getLocation().getX() + " y = " + boardPad.getLocation().getY());
-			                        			            boardPad.setName(element.getName() + "-" +"Polygon "); //Polygons are not named so just name it as "Polygon"
-			                        			            
-		                        							if (((org.openpnp.model.eagle.xml.Polygon) e).getLayer().equalsIgnoreCase(tCreamLayer))
-		                        								boardPad.setSide(Side.Top);
-		                        							else
-		                        								boardPad.setSide(Side.Bottom);
-		                        							
-					                		                pads.add(boardPad);
-					                		                
-					                						board.addSolderPastePad(boardPad); //This adds the pad to the SolderPaste
-		                        						}
-		                        					}
-                        						}
-                        					}
-                        				}
-                        			}
-                        		}
+        dlg.setVisible(true);
+        return board;
+    }
+
+    private static List<Placement> parseFile(File file, Side side, boolean createMissingParts)
+            throws Exception {
+
+        String dimensionLayer = "";
+        String topLayer = "";
+        String bottomLayer = "";
+        String tCreamLayer = "";
+        String bCreamLayer = "";
+
+        String mmMinCreamFrame_string;
+        double mmMinCreamFrame_number = 0;
+        String mmMaxCreamFrame_string;
+        double mmMaxCreamFrame_number = 0;
+        String libraryId = "";
+        String packageId = "";
+        Part part = null;
+
+        List<BoardPad> pads = new ArrayList<>();
+
+        ArrayList<Placement> placements = new ArrayList<>();
+        // we don't use the 'side' parameter as we can read this from the .brd file
+        // in the future we could use the side parameter to restrict this from only parsing one side
+        // or the other or both
+
+        EagleLoader boardToProcess = new EagleLoader(file);
+        if (boardToProcess.board != null) {
+
+            // first establish which is the Dimension, Top, Bottom, tCream and bCream layers in case
+            // the board has non-standard layer numbering
+            for (Layer layer : boardToProcess.layers.getLayer()) {
+                if (layer.getName().equalsIgnoreCase("Dimension")) {
+                    dimensionLayer = layer.getNumber();
+                }
+                else if (layer.getName().equalsIgnoreCase("Top")) {
+                    topLayer = layer.getNumber();
+                }
+                else if (layer.getName().equalsIgnoreCase("Bottom")) {
+                    bottomLayer = layer.getNumber();
+                }
+                else if (layer.getName().equalsIgnoreCase("tCream")) {
+                    tCreamLayer = layer.getNumber();
+                }
+                else if (layer.getName().equalsIgnoreCase("bCream")) {
+                    bCreamLayer = layer.getNumber();
+                }
+            }
+
+            // Now we want to establish the width of the board which we need to record
+            Double x_boundary = 0.0;
+            for (Object e : boardToProcess.board.getPlain()
+                    .getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole()) {
+                if (e instanceof org.openpnp.model.eagle.xml.Wire) {
+                    if (((org.openpnp.model.eagle.xml.Wire) e).getLayer()
+                            .equalsIgnoreCase(dimensionLayer)) {
+                        x_boundary = Math.max(x_boundary,
+                                Double.parseDouble(((org.openpnp.model.eagle.xml.Wire) e).getX1()));
+                        x_boundary = Math.max(x_boundary,
+                                Double.parseDouble(((org.openpnp.model.eagle.xml.Wire) e).getX2()));
+                    }
+                }
+            }
+            Point center = new Point(x_boundary / 2, 0); // note that we set x = maximum x point on
+                                                         // the Y=0;
+
+            // determine the parameters for the pads based on DesignRules
+            for (Param params : boardToProcess.board.getDesignrules().getParam()) {
+
+                if (params.getName().compareToIgnoreCase("mlMinCreamFrame") == 0) { // found exact
+                                                                                    // match when 0
+                                                                                    // returned
+                    mmMinCreamFrame_string = params.getValue().replaceAll("[A-Za-z ]", ""); // remove
+                                                                                            // all
+                                                                                            // letters,
+                                                                                            // i.e.
+                                                                                            // 0mil
+                                                                                            // becomes
+                                                                                            // 0
+                    if (params.getValue().toUpperCase().endsWith("MIL")) {
+                        mmMinCreamFrame_number =
+                                Double.parseDouble(mmMinCreamFrame_string) * mil_to_mm;
+                    }
+                    else if (params.getValue().toUpperCase().endsWith("MM")) {
+                        mmMinCreamFrame_number =
+                                Double.parseDouble(mmMinCreamFrame_string) * mil_to_mm;
+                    }
+                    else
+                        throw new Exception("mlMinCream must either be in mil or mm"); // Force the
+                                                                                       // importer
+                                                                                       // to abort,
+                                                                                       // something
+                                                                                       // is very
+                                                                                       // wrong
+                }
+                if (params.getName().compareToIgnoreCase("mlMaxCreamFrame") == 0) { // found exact
+                                                                                    // match when 0
+                                                                                    // returned
+                    mmMaxCreamFrame_string = params.getValue().replaceAll("[A-Za-z ]", ""); // remove
+                                                                                            // all
+                                                                                            // letters,
+                                                                                            // i.e.
+                                                                                            // "0mil"
+                                                                                            // becomes
+                                                                                            // 0
+                    if (params.getValue().toUpperCase().endsWith("MIL")) {
+                        mmMaxCreamFrame_number =
+                                Double.parseDouble(mmMaxCreamFrame_string) * mil_to_mm;
+                    }
+                    else if (params.getValue().toUpperCase().endsWith("MM")) {
+                        mmMaxCreamFrame_number = Double.parseDouble(mmMaxCreamFrame_string);
+                    }
+                    else
+                        throw new Exception("mlMaxCream must either be in mil or mm"); // Force the
+                                                                                       // importer
+                                                                                       // to abort,
+                                                                                       // something
+                                                                                       // is very
+                                                                                       // wrong
+                }
+            }
+            // Now we know the min and max tolerance for the cream (aka solder paste)
+            // which are mmMinCreamFrame_number and mmMaxCreamFrame_number and are in mm (converted
+            // from mil as required)
+
+            // Now we got through each of the parts
+            if (!boardToProcess.board.getElements().getElement().isEmpty()) {
+
+                // Process each of the element items
+                for (Element element : boardToProcess.board.getElements().getElement()) {
+                    // first we determine if the part is on the top layer or bottom layer
+
+                    Side element_side;
+                    String rot = element.getRot();
+                    if (rot.toUpperCase().startsWith("M"))
+                        // The part is mirrored and therefore is on the bottom of the board
+                        element_side = Side.Bottom;
+                    else
+                        element_side = Side.Top;
+
+                    // Now determine if we want to process this part based on which side of the
+                    // board it is on
+
+                    if (side != null) { // null means process both sides
+                        if (side != element_side)
+                            continue; // exit this loop and process the next element
+                    }
+
+                    String rot_number = rot.replaceAll("[A-Za-z ]", ""); // remove all letters, i.e.
+                                                                         // R180 becomes 180
+
+                    Placement placement = new Placement(element.getName());
+                    double rotation = Double.parseDouble(rot_number);
+                    double x = Double.parseDouble(element.getX());
+                    double y = Double.parseDouble(element.getY());
+                    placement.setLocation(new Location(LengthUnit.Millimeters, x, y, 0, rotation));
+
+                    // placement now contains where the package is on the PCB, we need to work out
+                    // where the pads
+                    // are relative to the 'placement'
+                    Configuration cfg = Configuration.get();
+                    if (cfg != null && createMissingParts) {
+                        String value = element.getValue(); // Value
+                        packageId = element.getPackage(); // Package
+                        libraryId = element.getLibrary(); // Library that contains the package
+
+                        String pkgId = libraryId + "-" + packageId;
+
+                        String partId = libraryId + "-" + packageId;
+                        if (value.trim().length() > 0) {
+                            partId += "-" + value;
+                        }
+
+                        part = cfg.getPart(partId);
+                        Package pkg = cfg.getPackage(pkgId);
+
+                        if ((part == null) || (pkg == null)) {
+
+                            if (pkg == null) {
+                                pkg = new Package(pkgId);
+                                cfg.addPackage(pkg); // save the package in the configuration file
+                                if (part != null) {
+                                    cfg.removePart(part);// we have to remove the part so we can
+                                                         // re-add it with the correct package &
+                                                         // library
+                                    part = null;
+                                }
+
+                            }
+                            if (part == null) {
+                                part = new Part(partId);
+                                part.setPackage(pkg);
+                                // TODO part.setLibrary(libraryId);
+                                cfg.addPart(part); // save the package in the configuration file
+                            }
+                            cfg.addPart(part);
                         }
-		            }
-
-					placement.setSide(element_side);
-					placements.add(placement);
-					board.addPlacement(placement); //this adds the placement to the Pick and Place list
-
-				}
-			}
-		}
-		if (boardToProcess.library != null ) {
-			
-		}
-		if (boardToProcess.schematic != null ) {
-			
-		}
-
-		return placements;
-	}
-	
+                    }
+                    placement.setPart(part);
+
+                    // Now we have the part, we now need to add the SolderPastePad to the board
+                    // Note, Eagle has the concept of minimum and max from the edge of the pad so we
+                    // need to
+                    // adjust the pad to be the size as the mid-point between the minimum and max
+                    // in practice these are usually 0, which means we paste the entire pad
+
+                    if (!boardToProcess.board.getLibraries().getLibrary().isEmpty()) {
+                        for (Library library : boardToProcess.board.getLibraries().getLibrary()) {
+                            if (library.getName().equalsIgnoreCase(libraryId)) {
+                                // we have found the library, now to scan for the package we want
+                                if (!library.getPackages().getPackage().isEmpty()) {
+
+                                    ListIterator<org.openpnp.model.eagle.xml.Package> it =
+                                            library.getPackages().getPackage().listIterator();
+
+                                    while (it.hasNext()) {
+
+                                        org.openpnp.model.eagle.xml.Package pak =
+                                                (org.openpnp.model.eagle.xml.Package) it.next();
+                                        if (pak.getName().equalsIgnoreCase(packageId)) {
+
+                                            for (Object e : pak
+                                                    .getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd()) {
+                                                if (e instanceof org.openpnp.model.eagle.xml.Smd) {
+                                                    // we have found the correct package in the
+                                                    // correct library and we need to to add the pad
+                                                    // to the boardPads
+
+                                                    if (!((org.openpnp.model.eagle.xml.Smd) e)
+                                                            .getCream().equalsIgnoreCase("No")) { // if
+                                                                                                  // cream="no"
+                                                                                                  // then
+                                                                                                  // we
+                                                                                                  // do
+                                                                                                  // not
+                                                                                                  // paste
+                                                                                                  // this
+                                                                                                  // pad
+
+                                                        Pad.RoundRectangle pad =
+                                                                new Pad.RoundRectangle();
+                                                        pad.setUnits(LengthUnit.Millimeters);
+
+                                                        // TODO check that these reduce the pad to
+                                                        // the halfway between the minimum & maximum
+                                                        // tolerances
+                                                        pad.setHeight(Double.parseDouble(
+                                                                ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                        .getDx())
+                                                                - (mmMaxCreamFrame_number
+                                                                        - mmMinCreamFrame_number)
+                                                                        / 2);
+                                                        pad.setWidth(Double.parseDouble(
+                                                                ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                        .getDy())
+                                                                - (mmMaxCreamFrame_number
+                                                                        - mmMinCreamFrame_number)
+                                                                        / 2);
+
+                                                        pad.setRoundness(0);
+                                                        pad.setRoundness(Double.parseDouble(
+                                                                ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                        .getRoundness()));
+
+                                                        // first find out how is the package defined
+                                                        Double pad_rotation =
+                                                                Double.parseDouble(rot_number);
+                                                        // now rotate the pad by its own rotation
+                                                        // relative to its origin and make sure we
+                                                        // don't turn through 360 degrees
+                                                        pad_rotation += Double.parseDouble(
+                                                                ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                        .getRot().replaceAll(
+                                                                                "[A-Za-z ]", ""))
+                                                                % 360;
+
+                                                        Point A = new Point(
+                                                                Double.parseDouble(
+                                                                        ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                                .getX())
+                                                                        + x,
+                                                                Double.parseDouble(
+                                                                        ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                                .getY())
+                                                                        + y);
+
+                                                        Point part_center = new Point(x, y);
+
+                                                        if (element_side == Side.Top) {
+                                                            if (rotation > 180)
+                                                                A = Utils2D
+                                                                        .rotateTranslateCenterPoint(
+                                                                                A, rotation, 0, 0,
+                                                                                part_center); // rotate
+                                                                                              // the
+                                                                                              // part-pin
+                                                            else
+                                                                A = Utils2D
+                                                                        .rotateTranslateCenterPoint(
+                                                                                A, -rotation, 0, 0,
+                                                                                part_center); // rotate
+                                                                                              // the
+                                                                                              // part-pin
+                                                        }
+                                                        else if (element_side == Side.Bottom) {
+                                                            if (rotation > 180)
+                                                                A = Utils2D
+                                                                        .rotateTranslateCenterPoint(
+                                                                                A, rotation, 0, 0,
+                                                                                part_center); // rotate
+                                                                                              // the
+                                                                                              // part-pin
+                                                            else
+                                                                A = Utils2D
+                                                                        .rotateTranslateCenterPoint(
+                                                                                A,
+                                                                                -(180 - rotation),
+                                                                                0, 0, part_center); // rotate
+                                                                                                    // the
+                                                                                                    // part-pin
+
+                                                            // Mirror along the Y axis of the board
+                                                            if (A.getX() < center.getX()) {
+                                                                Double offset =
+                                                                        center.getX() - A.getX();
+                                                                A.setX(center.getX() + offset); // mirror
+                                                                                                // left
+                                                                                                // to
+                                                                                                // right
+                                                                                                // across
+                                                                                                // the
+                                                                                                // centre
+                                                                                                // of
+                                                                                                // the
+                                                                                                // board
+                                                            }
+                                                            else {
+                                                                Double offset =
+                                                                        A.getX() - center.getX();
+                                                                A.setX(center.getX() - offset);
+                                                            }
+                                                            // Mirror along the X axis of the part's
+                                                            // center line
+                                                            if (A.getY() < y) {
+                                                                Double offset = y - A.getY();
+                                                                A.setY(y + offset); // mirror top to
+                                                                                    // bottom across
+                                                                                    // the centre of
+                                                                                    // the part
+                                                            }
+                                                            else {
+                                                                Double offset = A.getY() - y;
+                                                                A.setY(y - offset); // mirror bottom
+                                                                                    // to top across
+                                                                                    // the centre of
+                                                                                    // the part
+                                                            }
+
+                                                        }
+
+                                                        // TODO Need to write the logic for pad
+                                                        // rotation
+                                                        // A = Utils2D.rotateTranslateCenterPoint(A,
+                                                        // pad_rotation,0,0,center);
+                                                        //
+
+
+                                                        BoardPad boardPad = new BoardPad(pad,
+                                                                new Location(LengthUnit.Millimeters,
+                                                                        A.getX(), A.getY(), 0,
+                                                                        pad_rotation));
+
+                                                        // TODO add support for Circle pads
+
+                                                        boardPad.setName(element.getName() + "-"
+                                                                + ((org.openpnp.model.eagle.xml.Smd) e)
+                                                                        .getName());
+
+                                                        if (((org.openpnp.model.eagle.xml.Smd) e)
+                                                                .getLayer()
+                                                                .equalsIgnoreCase(topLayer)) { // is
+                                                                                               // the
+                                                                                               // pad
+                                                                                               // on
+                                                                                               // top
+                                                            if (element_side == Side.Top) // part is
+                                                                                          // on the
+                                                                                          // top
+                                                                boardPad.setSide(Side.Top); // pad
+                                                                                            // is on
+                                                                                            // the
+                                                                                            // top
+                                                            else
+                                                                boardPad.setSide(Side.Bottom); // part
+                                                                                               // is
+                                                                                               // on
+                                                                                               // top,
+                                                                                               // but
+                                                                                               // pat
+                                                                                               // is
+                                                                                               // on
+                                                                                               // the
+                                                                                               // bottom
+                                                        }
+                                                        else if (((org.openpnp.model.eagle.xml.Smd) e)
+                                                                .getLayer()
+                                                                .equalsIgnoreCase(bottomLayer)) { // is
+                                                                                                  // the
+                                                                                                  // pad
+                                                                                                  // on
+                                                                                                  // the
+                                                                                                  // bottom
+                                                            if (element_side == Side.Top) // part is
+                                                                                          // top
+                                                                boardPad.setSide(Side.Bottom); // pad
+                                                                                               // stays
+                                                                                               // on
+                                                                                               // the
+                                                                                               // bottom
+                                                            else
+                                                                boardPad.setSide(Side.Top); // pad
+                                                                                            // moves
+                                                                                            // to
+                                                                                            // the
+                                                                                            // top
+                                                        }
+                                                        else
+                                                            logger.info("Warning: " + file
+                                                                    + "contains a SMD pad that is not on a topLayer or bottomLayer");
+
+                                                        // TODO figure out if it is possible for an
+                                                        // SMD pad to have a drill, it appears not
+                                                        // !!
+                                                        // pad.setdrillDiameter(0);
+
+                                                        // TODO later we need to associate a list of
+                                                        // pads to a board.
+                                                        pads.add(boardPad);
+
+                                                        board.addSolderPastePad(boardPad); // This
+                                                                                           // adds
+                                                                                           // the
+                                                                                           // pad to
+                                                                                           // the
+                                                                                           // SolderPaste
+                                                    }
+                                                }
+                                                else if (e instanceof org.openpnp.model.eagle.xml.Pad) {
+
+                                                    // TODO implement pasting for through hole pads
+
+                                                }
+                                                else if (e instanceof org.openpnp.model.eagle.xml.Polygon) {
+                                                    // We have a polygon is it on a tCream or bCream
+                                                    // layer, otherwise ignore it
+                                                    if (((org.openpnp.model.eagle.xml.Polygon) e)
+                                                            .getLayer()
+                                                            .equalsIgnoreCase(tCreamLayer)
+                                                            || ((org.openpnp.model.eagle.xml.Polygon) e)
+                                                                    .getLayer().equalsIgnoreCase(
+                                                                            bCreamLayer)) {
+                                                        logger.info("Warning: " + file
+                                                                + " contains a Polygon pad - this functionality has been implmented as the smallest bounded rectangle and may over paste the area");
+                                                        logger.info(
+                                                                "Layer" + ((org.openpnp.model.eagle.xml.Polygon) e)
+                                                                        .getLayer().toString());
+                                                        Double vertex_x_min = 0.0;
+                                                        Double vertex_x_max = 0.0;
+                                                        Double vertex_y_min = 0.0;
+                                                        Double vertex_y_max = 0.0;
+                                                        ListIterator<org.openpnp.model.eagle.xml.Vertex> vertex_it =
+                                                                ((org.openpnp.model.eagle.xml.Polygon) e)
+                                                                        .getVertex().listIterator();
+                                                        while (vertex_it.hasNext()) {
+                                                            org.openpnp.model.eagle.xml.Vertex vertex =
+                                                                    (Vertex) vertex_it.next();
+                                                            vertex_x_min = Math.min(vertex_x_min,
+                                                                    Double.parseDouble(
+                                                                            vertex.getX()));
+                                                            vertex_x_max = Math.max(vertex_x_max,
+                                                                    Double.parseDouble(
+                                                                            vertex.getX()));
+                                                            vertex_y_min = Math.min(vertex_y_min,
+                                                                    Double.parseDouble(
+                                                                            vertex.getY()));
+                                                            vertex_y_max = Math.max(vertex_y_max,
+                                                                    Double.parseDouble(
+                                                                            vertex.getY()));
+                                                            logger.info("Vertex: X=" + vertex.getX()
+                                                                    + " y=" + vertex.getY());
+                                                        }
+                                                        // TODO implement polygon pad in Pad.java
+                                                        Pad.RoundRectangle pad =
+                                                                new Pad.RoundRectangle();
+                                                        pad.setUnits(LengthUnit.Millimeters);
+                                                        pad.setRoundness(0);
+                                                        pad.setHeight(
+                                                                (vertex_y_max - vertex_y_min));
+                                                        pad.setWidth((vertex_x_max - vertex_x_min));
+
+                                                        BoardPad boardPad = new BoardPad(pad,
+                                                                new Location(LengthUnit.Millimeters,
+                                                                        x + (vertex_x_max
+                                                                                + vertex_x_min) / 2,
+                                                                        y + (vertex_y_max
+                                                                                + vertex_y_min) / 2,
+                                                                        0, 0));
+                                                        logger.info("Pad generated width is "
+                                                                + pad.getWidth() + " height "
+                                                                + pad.getHeight()
+                                                                + " centered at x = "
+                                                                + boardPad.getLocation().getX()
+                                                                + " y = "
+                                                                + boardPad.getLocation().getY());
+                                                        boardPad.setName(element.getName() + "-"
+                                                                + "Polygon "); // Polygons are not
+                                                                               // named so just name
+                                                                               // it as "Polygon"
+
+                                                        if (((org.openpnp.model.eagle.xml.Polygon) e)
+                                                                .getLayer()
+                                                                .equalsIgnoreCase(tCreamLayer))
+                                                            boardPad.setSide(Side.Top);
+                                                        else
+                                                            boardPad.setSide(Side.Bottom);
+
+                                                        pads.add(boardPad);
+
+                                                        board.addSolderPastePad(boardPad); // This
+                                                                                           // adds
+                                                                                           // the
+                                                                                           // pad to
+                                                                                           // the
+                                                                                           // SolderPaste
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+
+                    placement.setSide(element_side);
+                    placements.add(placement);
+                    board.addPlacement(placement); // this adds the placement to the Pick and Place
+                                                   // list
+
+                }
+            }
+        }
+        if (boardToProcess.library != null) {
+
+        }
+        if (boardToProcess.schematic != null) {
+
+        }
+
+        return placements;
+    }
+
     class Dlg extends JDialog {
         private JTextField textFieldBoardFile;
         private final Action browseBoardFileAction = new SwingAction();
@@ -449,96 +669,87 @@ else if ( ((org.openpnp.model.eagle.xml.Smd) e).getLayer().equalsIgnoreCase(bott
         private JCheckBox chckbxCreateMissingParts;
         private JCheckBox chckbxImportTop;
         private JCheckBox chckbxImportBottom;
-        
+
         public Dlg(Frame parent) {
             super(parent, DESCRIPTION, true);
             getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
-            
+
             JPanel panel = new JPanel();
-            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP,
+                    null, null));
             getContentPane().add(panel);
-            panel.setLayout(new FormLayout(new ColumnSpec[] {
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,},
-                new RowSpec[] {
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,}));
-            
+            panel.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                            FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                            FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
             JLabel lblBoardFilebrd = new JLabel("Eagle PCB Board File (.brd)");
             panel.add(lblBoardFilebrd, "2, 2, right, default");
-            
+
             textFieldBoardFile = new JTextField();
             panel.add(textFieldBoardFile, "4, 2, fill, default");
             textFieldBoardFile.setColumns(10);
-            
+
             JButton btnBrowse = new JButton("Browse");
             btnBrowse.setAction(browseBoardFileAction);
             panel.add(btnBrowse, "6, 2");
-                       
+
             JPanel panel_1 = new JPanel();
-            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING,
+                    TitledBorder.TOP, null, null));
             getContentPane().add(panel_1);
-            panel_1.setLayout(new FormLayout(new ColumnSpec[] {
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,},
-                new RowSpec[] {
-                	FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,
-                	FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,}));
-            
+            panel_1.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
             chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
             chckbxCreateMissingParts.setSelected(true);
             panel_1.add(chckbxCreateMissingParts, "2, 2");
-            
-            chckbxImportTop =    new JCheckBox("Import Parts on the Top of the board");
+
+            chckbxImportTop = new JCheckBox("Import Parts on the Top of the board");
             chckbxImportTop.setSelected(true);
             panel_1.add(chckbxImportTop, "2, 4");
-            
+
             chckbxImportBottom = new JCheckBox("Import Parts on the Bottom of the board");
             chckbxImportBottom.setSelected(true);
             panel_1.add(chckbxImportBottom, "2, 6");
-            
+
             JSeparator separator = new JSeparator();
             getContentPane().add(separator);
-            
+
             JPanel panel_2 = new JPanel();
             FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
             flowLayout.setAlignment(FlowLayout.RIGHT);
             getContentPane().add(panel_2);
-            
+
             JButton btnCancel = new JButton("Cancel");
             btnCancel.setAction(cancelAction);
             panel_2.add(btnCancel);
-            
+
             JButton btnImport = new JButton("Import");
             btnImport.setAction(importAction);
             panel_2.add(btnImport);
-            
+
             setSize(400, 400);
             setLocationRelativeTo(parent);
-            
+
             JRootPane rootPane = getRootPane();
             KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-            InputMap inputMap = rootPane
-                    .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+            InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
             inputMap.put(stroke, "ESCAPE");
             rootPane.getActionMap().put("ESCAPE", cancelAction);
         }
-        
+
         private class SwingAction extends AbstractAction {
             public SwingAction() {
                 putValue(NAME, "Browse");
                 putValue(SHORT_DESCRIPTION, "Browse");
             }
+
             public void actionPerformed(ActionEvent e) {
                 FileDialog fileDialog = new FileDialog(Dlg.this);
                 fileDialog.setFilenameFilter(new FilenameFilter() {
@@ -561,18 +772,25 @@ public SwingAction_2() {
                 putValue(NAME, "Import");
                 putValue(SHORT_DESCRIPTION, "Import");
             }
+
             public void actionPerformed(ActionEvent e) {
                 boardFile = new File(textFieldBoardFile.getText());
                 board = new Board();
                 List<Placement> placements = new ArrayList<>();
                 try {
                     if (boardFile.exists()) {
-                    	if (chckbxImportTop.isSelected() && chckbxImportBottom.isSelected())
-                    		placements.addAll(parseFile(boardFile, null, chckbxCreateMissingParts.isSelected())); //both Top and Bottom of the board
-                    	else if(chckbxImportTop.isSelected())
-                    		placements.addAll(parseFile(boardFile, Side.Top, chckbxCreateMissingParts.isSelected())); //Just the Top side of the board
-                    	else if(chckbxImportBottom.isSelected())
-                    		placements.addAll(parseFile(boardFile, Side.Bottom, chckbxCreateMissingParts.isSelected())); //Just the Bottom side of the board                    	
+                        if (chckbxImportTop.isSelected() && chckbxImportBottom.isSelected())
+                            placements.addAll(parseFile(boardFile, null,
+                                    chckbxCreateMissingParts.isSelected())); // both Top and Bottom
+                                                                             // of the board
+                        else if (chckbxImportTop.isSelected())
+                            placements.addAll(parseFile(boardFile, Side.Top,
+                                    chckbxCreateMissingParts.isSelected())); // Just the Top side of
+                                                                             // the board
+                        else if (chckbxImportBottom.isSelected())
+                            placements.addAll(parseFile(boardFile, Side.Bottom,
+                                    chckbxCreateMissingParts.isSelected())); // Just the Bottom side
+                                                                             // of the board
                     }
                 }
                 catch (Exception e1) {
@@ -583,12 +801,13 @@ else if(chckbxImportBottom.isSelected())
                 setVisible(false);
             }
         }
-        
+
         private class SwingAction_3 extends AbstractAction {
             public SwingAction_3() {
                 putValue(NAME, "Cancel");
                 putValue(SHORT_DESCRIPTION, "Cancel");
             }
+
             public void actionPerformed(ActionEvent e) {
                 setVisible(false);
             }
diff --git a/src/main/java/org/openpnp/gui/importer/EagleMountsmdUlpImporter.java b/src/main/java/org/openpnp/gui/importer/EagleMountsmdUlpImporter.java
index acd3c38f79..33bfccb785 100755
--- a/src/main/java/org/openpnp/gui/importer/EagleMountsmdUlpImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/EagleMountsmdUlpImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -70,13 +68,13 @@
 public class EagleMountsmdUlpImporter implements BoardImporter {
     private final static String NAME = "EAGLE mountsmd.ulp";
     private final static String DESCRIPTION = "Import files generated by EAGLE's mountsmd.ulp.";
-    
-	private Board board;
-	private File topFile, bottomFile;
-	
-	@Override
+
+    private Board board;
+    private File topFile, bottomFile;
+
+    @Override
     public String getImporterName() {
-	    return NAME;
+        return NAME;
     }
 
     @Override
@@ -85,36 +83,36 @@ public String getImporterDescription() {
     }
 
     @Override
-	public Board importBoard(Frame parent) throws Exception {
+    public Board importBoard(Frame parent) throws Exception {
         Dlg dlg = new Dlg(parent);
-		dlg.setVisible(true);
-		return board;
-	}
-    
-	private static List<Placement> parseFile(File file, Side side, boolean createMissingParts) throws Exception {
-		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
-		ArrayList<Placement> placements = new ArrayList<>();
-		String line;
-		while ((line = reader.readLine()) != null) {
-			line = line.trim();
-			if (line.length() == 0) {
-				continue;
-			}
-
-			// C1 41.91 34.93 180 0.1uF C0805
-			// T10 21.59 14.22  90  SOT23-BEC
-			// printf("%s %5.2f %5.2f %3.0f %s %s\n",
-            Pattern pattern = Pattern.compile("(\\S+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d{1,3})\\s(.*)\\s(.*)");
-			Matcher matcher = pattern.matcher(line);
-			matcher.matches();
-			Placement placement = new Placement(matcher.group(1));
-			placement.setLocation(new Location(
-			        LengthUnit.Millimeters,
-			        Double.parseDouble(matcher.group(2)),
-			        Double.parseDouble(matcher.group(3)),
-			        0,
-			        Double.parseDouble(matcher.group(4))));
-			Configuration cfg = Configuration.get();
+        dlg.setVisible(true);
+        return board;
+    }
+
+    private static List<Placement> parseFile(File file, Side side, boolean createMissingParts)
+            throws Exception {
+        BufferedReader reader =
+                new BufferedReader(new InputStreamReader(new FileInputStream(file)));
+        ArrayList<Placement> placements = new ArrayList<>();
+        String line;
+        while ((line = reader.readLine()) != null) {
+            line = line.trim();
+            if (line.length() == 0) {
+                continue;
+            }
+
+            // C1 41.91 34.93 180 0.1uF C0805
+            // T10 21.59 14.22 90 SOT23-BEC
+            // printf("%s %5.2f %5.2f %3.0f %s %s\n",
+            Pattern pattern = Pattern.compile(
+                    "(\\S+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d{1,3})\\s(.*)\\s(.*)");
+            Matcher matcher = pattern.matcher(line);
+            matcher.matches();
+            Placement placement = new Placement(matcher.group(1));
+            placement.setLocation(new Location(LengthUnit.Millimeters,
+                    Double.parseDouble(matcher.group(2)), Double.parseDouble(matcher.group(3)), 0,
+                    Double.parseDouble(matcher.group(4))));
+            Configuration cfg = Configuration.get();
             if (cfg != null && createMissingParts) {
                 String value = matcher.group(5);
                 String packageId = matcher.group(6);
@@ -139,13 +137,13 @@ public Board importBoard(Frame parent) throws Exception {
 
             }
 
-			placement.setSide(side);
-			placements.add(placement);
-		}
-		reader.close();
-		return placements;
-	}
-	
+            placement.setSide(side);
+            placements.add(placement);
+        }
+        reader.close();
+        return placements;
+    }
+
     class Dlg extends JDialog {
         private JTextField textFieldTopFile;
         private JTextField textFieldBottomFile;
@@ -154,95 +152,88 @@ public Board importBoard(Frame parent) throws Exception {
         private final Action importAction = new SwingAction_2();
         private final Action cancelAction = new SwingAction_3();
         private JCheckBox chckbxCreateMissingParts;
-        
+
         public Dlg(Frame parent) {
             super(parent, DESCRIPTION, true);
             getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
-            
+
             JPanel panel = new JPanel();
-            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP,
+                    null, null));
             getContentPane().add(panel);
-            panel.setLayout(new FormLayout(new ColumnSpec[] {
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,},
-                new RowSpec[] {
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,}));
-            
+            panel.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                            FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                            FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
             JLabel lblTopFilemnt = new JLabel("Top File (.mnt)");
             panel.add(lblTopFilemnt, "2, 2, right, default");
-            
+
             textFieldTopFile = new JTextField();
             panel.add(textFieldTopFile, "4, 2, fill, default");
             textFieldTopFile.setColumns(10);
-            
+
             JButton btnBrowse = new JButton("Browse");
             btnBrowse.setAction(browseTopFileAction);
             panel.add(btnBrowse, "6, 2");
-            
+
             JLabel lblBottomFilemnb = new JLabel("Bottom File (.mnb)");
             panel.add(lblBottomFilemnb, "2, 4, right, default");
-            
+
             textFieldBottomFile = new JTextField();
             panel.add(textFieldBottomFile, "4, 4, fill, default");
             textFieldBottomFile.setColumns(10);
-            
+
             JButton btnBrowse_1 = new JButton("Browse");
             btnBrowse_1.setAction(browseBottomFileAction);
             panel.add(btnBrowse_1, "6, 4");
-            
+
             JPanel panel_1 = new JPanel();
-            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING,
+                    TitledBorder.TOP, null, null));
             getContentPane().add(panel_1);
-            panel_1.setLayout(new FormLayout(new ColumnSpec[] {
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    FormSpecs.DEFAULT_COLSPEC,},
-                new RowSpec[] {
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,}));
-            
+            panel_1.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
             chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
             chckbxCreateMissingParts.setSelected(true);
             panel_1.add(chckbxCreateMissingParts, "2, 2");
-            
+
             JSeparator separator = new JSeparator();
             getContentPane().add(separator);
-            
+
             JPanel panel_2 = new JPanel();
             FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
             flowLayout.setAlignment(FlowLayout.RIGHT);
             getContentPane().add(panel_2);
-            
+
             JButton btnCancel = new JButton("Cancel");
             btnCancel.setAction(cancelAction);
             panel_2.add(btnCancel);
-            
+
             JButton btnImport = new JButton("Import");
             btnImport.setAction(importAction);
             panel_2.add(btnImport);
-            
+
             setSize(400, 400);
             setLocationRelativeTo(parent);
-            
+
             JRootPane rootPane = getRootPane();
             KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-            InputMap inputMap = rootPane
-                    .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+            InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
             inputMap.put(stroke, "ESCAPE");
             rootPane.getActionMap().put("ESCAPE", cancelAction);
         }
-        
+
         private class SwingAction extends AbstractAction {
             public SwingAction() {
                 putValue(NAME, "Browse");
                 putValue(SHORT_DESCRIPTION, "Browse");
             }
+
             public void actionPerformed(ActionEvent e) {
                 FileDialog fileDialog = new FileDialog(Dlg.this);
                 fileDialog.setFilenameFilter(new FilenameFilter() {
@@ -259,12 +250,13 @@ public boolean accept(File dir, String name) {
                 textFieldTopFile.setText(file.getAbsolutePath());
             }
         }
-        
+
         private class SwingAction_1 extends AbstractAction {
             public SwingAction_1() {
                 putValue(NAME, "Browse");
                 putValue(SHORT_DESCRIPTION, "Browse");
             }
+
             public void actionPerformed(ActionEvent e) {
                 FileDialog fileDialog = new FileDialog(Dlg.this);
                 fileDialog.setFilenameFilter(new FilenameFilter() {
@@ -287,6 +279,7 @@ public SwingAction_2() {
                 putValue(NAME, "Import");
                 putValue(SHORT_DESCRIPTION, "Import");
             }
+
             public void actionPerformed(ActionEvent e) {
                 topFile = new File(textFieldTopFile.getText());
                 bottomFile = new File(textFieldBottomFile.getText());
@@ -294,10 +287,12 @@ public void actionPerformed(ActionEvent e) {
                 List<Placement> placements = new ArrayList<>();
                 try {
                     if (topFile.exists()) {
-                        placements.addAll(parseFile(topFile, Side.Top, chckbxCreateMissingParts.isSelected()));
+                        placements.addAll(parseFile(topFile, Side.Top,
+                                chckbxCreateMissingParts.isSelected()));
                     }
                     if (bottomFile.exists()) {
-                        placements.addAll(parseFile(bottomFile, Side.Bottom, chckbxCreateMissingParts.isSelected()));
+                        placements.addAll(parseFile(bottomFile, Side.Bottom,
+                                chckbxCreateMissingParts.isSelected()));
                     }
                 }
                 catch (Exception e1) {
@@ -310,12 +305,13 @@ public void actionPerformed(ActionEvent e) {
                 setVisible(false);
             }
         }
-        
+
         private class SwingAction_3 extends AbstractAction {
             public SwingAction_3() {
                 putValue(NAME, "Cancel");
                 putValue(SHORT_DESCRIPTION, "Cancel");
             }
+
             public void actionPerformed(ActionEvent e) {
                 setVisible(false);
             }
diff --git a/src/main/java/org/openpnp/gui/importer/KicadPosImporter.java b/src/main/java/org/openpnp/gui/importer/KicadPosImporter.java
index 343d6b563d..fa8fe45ef5 100755
--- a/src/main/java/org/openpnp/gui/importer/KicadPosImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/KicadPosImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -72,11 +70,11 @@
     private final static String DESCRIPTION = "Import KiCAD .pos Files.";
 
     private Board board;
-	private File topFile, bottomFile;
-	
-	@Override
+    private File topFile, bottomFile;
+
+    @Override
     public String getImporterName() {
-	    return NAME;
+        return NAME;
     }
 
     @Override
@@ -85,56 +83,56 @@ public String getImporterDescription() {
     }
 
     @Override
-	public Board importBoard(Frame parent) throws Exception {
+    public Board importBoard(Frame parent) throws Exception {
         Dlg dlg = new Dlg(parent);
-		dlg.setVisible(true);
-		return board;
-	}
-	
-	private static List<Placement> parseFile(File file, Side side, boolean createMissingParts) throws Exception {
-		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
-		ArrayList<Placement> placements = new ArrayList<>();
-		String line;
-
-//		See: http://bazaar.launchpad.net/~kicad-product-committers/kicad/product/view/head:/pcbnew/exporters/gen_modules_placefile.cpp
-//		### Module positions - created on Tue 25 Mar 2014 03:42:43 PM PDT ###
-//		### Printed by Pcbnew version pcbnew (2014-01-24 BZR 4632)-product
-//		## Unit = mm, Angle = deg.
-//		## Side : F.Cu
-//		# Ref    Val                  Package         PosX       PosY        Rot     Side
-//		C1       100u             Capacitors_SMD:c  128.9050   -52.0700       0.0    F.Cu
-//		C2       100u             Capacitors_SMD:c   93.3450   -77.4700     180.0    F.Cu
-//		C3       100u             Capacitors_SMD:c   67.9450   -77.4700     180.0    F.Cu
-		
-		Pattern pattern = Pattern.compile("(\\S+)\\s+(.*?)\\s+(.*?)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s(.*?)");
-		
-		while ((line = reader.readLine()) != null) {
-			line = line.trim();
-			if (line.length() == 0 || line.charAt(0) == '#') {
-				continue;
-			}
-
-
-
-			Matcher matcher = pattern.matcher(line);
-			matcher.matches();
-			
-			String placementId = matcher.group(1);
-			String partValue = matcher.group(2);
-			String pkgName = matcher.group(3);
-			double placementX = Double.parseDouble(matcher.group(4));
-			double placementY = Double.parseDouble(matcher.group(5));
-			double placementRotation = Double.parseDouble(matcher.group(6));
-			String placementLayer = matcher.group(7);
-			
-			Placement placement = new Placement(placementId);
-			placement.setLocation(new Location(
-			        LengthUnit.Millimeters,
-			        placementX,
-			        placementY,
-			        0,
-			        placementRotation));
-			Configuration cfg = Configuration.get();
+        dlg.setVisible(true);
+        return board;
+    }
+
+    private static List<Placement> parseFile(File file, Side side, boolean createMissingParts)
+            throws Exception {
+        BufferedReader reader =
+                new BufferedReader(new InputStreamReader(new FileInputStream(file)));
+        ArrayList<Placement> placements = new ArrayList<>();
+        String line;
+
+        // See:
+        // http://bazaar.launchpad.net/~kicad-product-committers/kicad/product/view/head:/pcbnew/exporters/gen_modules_placefile.cpp
+        // ### Module positions - created on Tue 25 Mar 2014 03:42:43 PM PDT ###
+        // ### Printed by Pcbnew version pcbnew (2014-01-24 BZR 4632)-product
+        // ## Unit = mm, Angle = deg.
+        // ## Side : F.Cu
+        // # Ref Val Package PosX PosY Rot Side
+        // C1 100u Capacitors_SMD:c 128.9050 -52.0700 0.0 F.Cu
+        // C2 100u Capacitors_SMD:c 93.3450 -77.4700 180.0 F.Cu
+        // C3 100u Capacitors_SMD:c 67.9450 -77.4700 180.0 F.Cu
+
+        Pattern pattern = Pattern.compile(
+                "(\\S+)\\s+(.*?)\\s+(.*?)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s+(-?\\d+\\.\\d+)\\s(.*?)");
+
+        while ((line = reader.readLine()) != null) {
+            line = line.trim();
+            if (line.length() == 0 || line.charAt(0) == '#') {
+                continue;
+            }
+
+
+
+            Matcher matcher = pattern.matcher(line);
+            matcher.matches();
+
+            String placementId = matcher.group(1);
+            String partValue = matcher.group(2);
+            String pkgName = matcher.group(3);
+            double placementX = Double.parseDouble(matcher.group(4));
+            double placementY = Double.parseDouble(matcher.group(5));
+            double placementRotation = Double.parseDouble(matcher.group(6));
+            String placementLayer = matcher.group(7);
+
+            Placement placement = new Placement(placementId);
+            placement.setLocation(new Location(LengthUnit.Millimeters, placementX, placementY, 0,
+                    placementRotation));
+            Configuration cfg = Configuration.get();
             if (cfg != null && createMissingParts) {
                 String partId = pkgName + "-" + partValue;
                 Part part = cfg.getPart(partId);
@@ -153,186 +151,184 @@ public Board importBoard(Frame parent) throws Exception {
 
             }
 
-			placement.setSide(side);
-			placements.add(placement);
-		}
-		reader.close();
-		return placements;
-	}
-	
-	class Dlg extends JDialog {
-	    private JTextField textFieldTopFile;
-	    private JTextField textFieldBottomFile;
-	    private final Action browseTopFileAction = new SwingAction();
-	    private final Action browseBottomFileAction = new SwingAction_1();
-	    private final Action importAction = new SwingAction_2();
-	    private final Action cancelAction = new SwingAction_3();
-	    private JCheckBox chckbxCreateMissingParts;
-
-	    public Dlg(Frame parent) {
-	        super(parent, DESCRIPTION, true);
-	        getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
-	        
-	        JPanel panel = new JPanel();
-	        panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-	        getContentPane().add(panel);
-	        panel.setLayout(new FormLayout(new ColumnSpec[] {
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                ColumnSpec.decode("default:grow"),
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,},
-	            new RowSpec[] {
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,}));
-	        
-	        JLabel lblTopFilemnt = new JLabel("Top File (.pos)");
-	        panel.add(lblTopFilemnt, "2, 2, right, default");
-	        
-	        textFieldTopFile = new JTextField();
-	        panel.add(textFieldTopFile, "4, 2, fill, default");
-	        textFieldTopFile.setColumns(10);
-	        
-	        JButton btnBrowse = new JButton("Browse");
-	        btnBrowse.setAction(browseTopFileAction);
-	        panel.add(btnBrowse, "6, 2");
-	        
-	        JLabel lblBottomFilemnb = new JLabel("Bottom File (.pos)");
-	        panel.add(lblBottomFilemnb, "2, 4, right, default");
-	        
-	        textFieldBottomFile = new JTextField();
-	        panel.add(textFieldBottomFile, "4, 4, fill, default");
-	        textFieldBottomFile.setColumns(10);
-	        
-	        JButton btnBrowse_1 = new JButton("Browse");
-	        btnBrowse_1.setAction(browseBottomFileAction);
-	        panel.add(btnBrowse_1, "6, 4");
-	        
-	        JPanel panel_1 = new JPanel();
-	        panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-	        getContentPane().add(panel_1);
-	        panel_1.setLayout(new FormLayout(new ColumnSpec[] {
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,},
-	            new RowSpec[] {
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,}));
-	        
-	        chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
-	        chckbxCreateMissingParts.setSelected(true);
-	        panel_1.add(chckbxCreateMissingParts, "2, 2");
-	        
-	        JSeparator separator = new JSeparator();
-	        getContentPane().add(separator);
-	        
-	        JPanel panel_2 = new JPanel();
-	        FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
-	        flowLayout.setAlignment(FlowLayout.RIGHT);
-	        getContentPane().add(panel_2);
-	        
-	        JButton btnCancel = new JButton("Cancel");
-	        btnCancel.setAction(cancelAction);
-	        panel_2.add(btnCancel);
-	        
-	        JButton btnImport = new JButton("Import");
-	        btnImport.setAction(importAction);
-	        panel_2.add(btnImport);
-	        
-	        setSize(400, 400);
-	        setLocationRelativeTo(parent);
-	        
-	        JRootPane rootPane = getRootPane();
-	        KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-	        InputMap inputMap = rootPane
-	                .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
-	        inputMap.put(stroke, "ESCAPE");
-	        rootPane.getActionMap().put("ESCAPE", cancelAction);
-	    }
-	    
-	    private class SwingAction extends AbstractAction {
-	        public SwingAction() {
-	            putValue(NAME, "Browse");
-	            putValue(SHORT_DESCRIPTION, "Browse");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            FileDialog fileDialog = new FileDialog(Dlg.this);
-	            fileDialog.setFilenameFilter(new FilenameFilter() {
-	                @Override
-	                public boolean accept(File dir, String name) {
-	                    return name.toLowerCase().endsWith(".pos");
-	                }
-	            });
-	            fileDialog.setVisible(true);
-	            if (fileDialog.getFile() == null) {
-	                return;
-	            }
-	            File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
-	            textFieldTopFile.setText(file.getAbsolutePath());
-	        }
-	    }
-	    
-	    private class SwingAction_1 extends AbstractAction {
-	        public SwingAction_1() {
-	            putValue(NAME, "Browse");
-	            putValue(SHORT_DESCRIPTION, "Browse");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            FileDialog fileDialog = new FileDialog(Dlg.this);
-	            fileDialog.setFilenameFilter(new FilenameFilter() {
-	                @Override
-	                public boolean accept(File dir, String name) {
-	                    return name.toLowerCase().endsWith(".pos");
-	                }
-	            });
-	            fileDialog.setVisible(true);
-	            if (fileDialog.getFile() == null) {
-	                return;
-	            }
-	            File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
-	            textFieldBottomFile.setText(file.getAbsolutePath());
-	        }
-	    }
-
-	    private class SwingAction_2 extends AbstractAction {
-	        public SwingAction_2() {
-	            putValue(NAME, "Import");
-	            putValue(SHORT_DESCRIPTION, "Import");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            topFile = new File(textFieldTopFile.getText());
-	            bottomFile = new File(textFieldBottomFile.getText());
-	            board = new Board();
-	            List<Placement> placements = new ArrayList<>();
-	            try {
-	                if (topFile.exists()) {
-	                    placements.addAll(parseFile(topFile, Side.Top, chckbxCreateMissingParts.isSelected()));
-	                }
-	                if (bottomFile.exists()) {
-	                    placements.addAll(parseFile(bottomFile, Side.Bottom, chckbxCreateMissingParts.isSelected()));
-	                }
-	            }
-	            catch (Exception e1) {
-	                MessageBoxes.errorBox(Dlg.this, "Import Error", e1);
-	                return;
-	            }
-	            for (Placement placement : placements) {
-	                board.addPlacement(placement);
-	            }
-	            setVisible(false);
-	        }
-	    }
-	    
-	    private class SwingAction_3 extends AbstractAction {
-	        public SwingAction_3() {
-	            putValue(NAME, "Cancel");
-	            putValue(SHORT_DESCRIPTION, "Cancel");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            setVisible(false);
-	        }
-	    }
-	}
+            placement.setSide(side);
+            placements.add(placement);
+        }
+        reader.close();
+        return placements;
+    }
+
+    class Dlg extends JDialog {
+        private JTextField textFieldTopFile;
+        private JTextField textFieldBottomFile;
+        private final Action browseTopFileAction = new SwingAction();
+        private final Action browseBottomFileAction = new SwingAction_1();
+        private final Action importAction = new SwingAction_2();
+        private final Action cancelAction = new SwingAction_3();
+        private JCheckBox chckbxCreateMissingParts;
+
+        public Dlg(Frame parent) {
+            super(parent, DESCRIPTION, true);
+            getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
+
+            JPanel panel = new JPanel();
+            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP,
+                    null, null));
+            getContentPane().add(panel);
+            panel.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                            FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                            FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+            JLabel lblTopFilemnt = new JLabel("Top File (.pos)");
+            panel.add(lblTopFilemnt, "2, 2, right, default");
+
+            textFieldTopFile = new JTextField();
+            panel.add(textFieldTopFile, "4, 2, fill, default");
+            textFieldTopFile.setColumns(10);
+
+            JButton btnBrowse = new JButton("Browse");
+            btnBrowse.setAction(browseTopFileAction);
+            panel.add(btnBrowse, "6, 2");
+
+            JLabel lblBottomFilemnb = new JLabel("Bottom File (.pos)");
+            panel.add(lblBottomFilemnb, "2, 4, right, default");
+
+            textFieldBottomFile = new JTextField();
+            panel.add(textFieldBottomFile, "4, 4, fill, default");
+            textFieldBottomFile.setColumns(10);
+
+            JButton btnBrowse_1 = new JButton("Browse");
+            btnBrowse_1.setAction(browseBottomFileAction);
+            panel.add(btnBrowse_1, "6, 4");
+
+            JPanel panel_1 = new JPanel();
+            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING,
+                    TitledBorder.TOP, null, null));
+            getContentPane().add(panel_1);
+            panel_1.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+            chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
+            chckbxCreateMissingParts.setSelected(true);
+            panel_1.add(chckbxCreateMissingParts, "2, 2");
+
+            JSeparator separator = new JSeparator();
+            getContentPane().add(separator);
+
+            JPanel panel_2 = new JPanel();
+            FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
+            flowLayout.setAlignment(FlowLayout.RIGHT);
+            getContentPane().add(panel_2);
+
+            JButton btnCancel = new JButton("Cancel");
+            btnCancel.setAction(cancelAction);
+            panel_2.add(btnCancel);
+
+            JButton btnImport = new JButton("Import");
+            btnImport.setAction(importAction);
+            panel_2.add(btnImport);
+
+            setSize(400, 400);
+            setLocationRelativeTo(parent);
+
+            JRootPane rootPane = getRootPane();
+            KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
+            InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+            inputMap.put(stroke, "ESCAPE");
+            rootPane.getActionMap().put("ESCAPE", cancelAction);
+        }
+
+        private class SwingAction extends AbstractAction {
+            public SwingAction() {
+                putValue(NAME, "Browse");
+                putValue(SHORT_DESCRIPTION, "Browse");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                FileDialog fileDialog = new FileDialog(Dlg.this);
+                fileDialog.setFilenameFilter(new FilenameFilter() {
+                    @Override
+                    public boolean accept(File dir, String name) {
+                        return name.toLowerCase().endsWith(".pos");
+                    }
+                });
+                fileDialog.setVisible(true);
+                if (fileDialog.getFile() == null) {
+                    return;
+                }
+                File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
+                textFieldTopFile.setText(file.getAbsolutePath());
+            }
+        }
+
+        private class SwingAction_1 extends AbstractAction {
+            public SwingAction_1() {
+                putValue(NAME, "Browse");
+                putValue(SHORT_DESCRIPTION, "Browse");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                FileDialog fileDialog = new FileDialog(Dlg.this);
+                fileDialog.setFilenameFilter(new FilenameFilter() {
+                    @Override
+                    public boolean accept(File dir, String name) {
+                        return name.toLowerCase().endsWith(".pos");
+                    }
+                });
+                fileDialog.setVisible(true);
+                if (fileDialog.getFile() == null) {
+                    return;
+                }
+                File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
+                textFieldBottomFile.setText(file.getAbsolutePath());
+            }
+        }
+
+        private class SwingAction_2 extends AbstractAction {
+            public SwingAction_2() {
+                putValue(NAME, "Import");
+                putValue(SHORT_DESCRIPTION, "Import");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                topFile = new File(textFieldTopFile.getText());
+                bottomFile = new File(textFieldBottomFile.getText());
+                board = new Board();
+                List<Placement> placements = new ArrayList<>();
+                try {
+                    if (topFile.exists()) {
+                        placements.addAll(parseFile(topFile, Side.Top,
+                                chckbxCreateMissingParts.isSelected()));
+                    }
+                    if (bottomFile.exists()) {
+                        placements.addAll(parseFile(bottomFile, Side.Bottom,
+                                chckbxCreateMissingParts.isSelected()));
+                    }
+                }
+                catch (Exception e1) {
+                    MessageBoxes.errorBox(Dlg.this, "Import Error", e1);
+                    return;
+                }
+                for (Placement placement : placements) {
+                    board.addPlacement(placement);
+                }
+                setVisible(false);
+            }
+        }
+
+        private class SwingAction_3 extends AbstractAction {
+            public SwingAction_3() {
+                putValue(NAME, "Cancel");
+                putValue(SHORT_DESCRIPTION, "Cancel");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                setVisible(false);
+            }
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/importer/NamedCSVImporter.java b/src/main/java/org/openpnp/gui/importer/NamedCSVImporter.java
index 10980d25cc..96de3c97b0 100755
--- a/src/main/java/org/openpnp/gui/importer/NamedCSVImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/NamedCSVImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -73,16 +71,15 @@
 public class NamedCSVImporter implements BoardImporter {
     private final static String NAME = "Named CSV";
     private final static String DESCRIPTION = "Import Named Comma Separated Values Files.";
- private static final Logger logger = LoggerFactory
-            .getLogger(NamedCSVImporter.class);
+    private static final Logger logger = LoggerFactory.getLogger(NamedCSVImporter.class);
 
 
     private Board board;
-	private File topFile, bottomFile;
-	
-	@Override
+    private File topFile, bottomFile;
+
+    @Override
     public String getImporterName() {
-	    return NAME;
+        return NAME;
     }
 
     @Override
@@ -91,365 +88,363 @@ public String getImporterDescription() {
     }
 
     @Override
-	public Board importBoard(Frame parent) throws Exception {
+    public Board importBoard(Frame parent) throws Exception {
         Dlg dlg = new Dlg(parent);
-		dlg.setVisible(true);
-		return board;
-	}
-	
+        dlg.setVisible(true);
+        return board;
+    }
 
-//////////////////////////////////////////////////////////
-/*
-public class CSVParseDemo {
-    public static void main(String[] args) throws IOException {
-	if (args.length < 1) {
-	    System.out.println("Usage: java CSVParseDemo <csv_file>");
-	    return;
-	}
-
-	CSVParser parser = new CSVParser(new FileReader(args[0]), CSVStrategy.DEFAULT);
-	String[] values = parser.getLine();
-	while (values != null) {
-	    printValues(parser.getLineNumber(), values);
-	    values = parser.getLine();
-	}
+
+    //////////////////////////////////////////////////////////
+    /*
+     * public class CSVParseDemo { public static void main(String[] args) throws IOException { if
+     * (args.length < 1) { System.out.println("Usage: java CSVParseDemo <csv_file>"); return; }
+     * 
+     * CSVParser parser = new CSVParser(new FileReader(args[0]), CSVStrategy.DEFAULT); String[]
+     * values = parser.getLine(); while (values != null) { printValues(parser.getLineNumber(),
+     * values); values = parser.getLine(); } }
+     * 
+     * private static void printValues(int lineNumber, String[] as) { System.out.println("Line " +
+     * lineNumber + " has " + as.length + " values:"); for (String s: as) { System.out.println("\t|"
+     * + s + "|"); } System.out.println(); } }
+     */
+    //////////////////////////////////////////////////////////
+    // if((str.indexOf("val")!=-1||str.indexOf("comment"))&&str.indexOf("val")!=-1&&str.indexOf("val")!=-1&&
+
+    private static final String Refs[] =
+            {"Designator", "designator", "Part", "part", "Component", "component", "RefDes", "Ref"};
+    private static final String Vals[] = {"Value", "value", "Val", "val", "Comment", "comment"};
+    private static final String Packs[] =
+            {"Footprint", "footprint", "Package", "package", "Pattern", "pattern"};
+    private static final String Xs[] = {"X", "x", "X (mm)", "x (mm)", "Ref X", "ref x", "PosX"};
+    private static final String Ys[] = {"Y", "x", "Y (mm)", "x (mm)", "Ref Y", "ref x", "PosY"};
+    private static final String Rots[] = {"Rotation", "rotation", "Rot", "rot", "Rotate"};
+    private static final String TBs[] = {"Layer", "layer", "Side", "side", "TB", "tb"};
+    //////////////////////////////////////////////////////////
+    static private int Ref = -1, Val = -1, Pack = -1, X = -1, Y = -1, Rot = -1, TB = -1, Len = 0;
+    static private char comma = ',';
+    //////////////////////////////////////////////////////////
+
+    private static int checkCSV(String str[], String val[]) {
+        for (int i = 0; i < str.length; i++)
+            for (int j = 0; j < val.length; j++)
+                if (str[i].equals(val[j])) {
+                    logger.trace("checkCSV: " + val[j] + " = " + j);
+                    return j;
+                }
+        return -1;
     }
 
-    private static void printValues(int lineNumber, String[] as) {
-	System.out.println("Line " + lineNumber + " has " + as.length + " values:");
-	for (String s: as) {
-	    System.out.println("\t|" + s + "|");
-	}
-	System.out.println();
+    private static boolean checkCSV(String str[]) {
+        for (int i = 0; i < str.length; i++)
+            logger.trace("checkCSV: " + i + " -> " + str[i]);
+        if ((Ref = checkCSV(Refs, str)) != -1 && (Val = checkCSV(Vals, str)) != -1
+                && (Pack = checkCSV(Packs, str)) != -1 && (X = checkCSV(Xs, str)) != -1
+                && (Y = checkCSV(Ys, str)) != -1 && (Rot = checkCSV(Rots, str)) != -1
+                && (TB = checkCSV(TBs, str)) != -2) {
+            Len = Ref <= Len ? Len : Ref;
+            Len = Val <= Len ? Len : Val;
+            Len = Pack <= Len ? Len : Pack;
+            Len = X <= Len ? Len : X;
+            Len = Y <= Len ? Len : Y;
+            Len = Rot <= Len ? Len : Rot;
+            Len = TB <= Len ? Len : TB;
+            logger.trace("checkCSV: Len = " + Len);
+            return true;
+        }
+        logger.trace("checkCSV: Ref = " + Ref);
+        logger.trace("checkCSV: Val = " + Val);
+        logger.trace("checkCSV: Pack = " + Pack);
+        logger.trace("checkCSV: X = " + X);
+        logger.trace("checkCSV: Y = " + Y);
+        logger.trace("checkCSV: Rot = " + Rot);
+        logger.trace("checkCSV: TB = " + TB);
+        Ref = -1;
+        Val = -1;
+        Pack = -1;
+        X = -1;
+        Y = -1;
+        Rot = -1;
+        TB = -1;
+        Len = 0;
+        return false;
     }
-}
-*/
-//////////////////////////////////////////////////////////
-//	if((str.indexOf("val")!=-1||str.indexOf("comment"))&&str.indexOf("val")!=-1&&str.indexOf("val")!=-1&&
-
-	private static final String Refs[] = { "Designator", "designator", "Part", "part", "Component", "component", "RefDes" , "Ref" };
-	private static final String Vals[] = { "Value", "value", "Val", "val", "Comment" , "comment" };
-	private static final String Packs[] = { "Footprint", "footprint","Package", "package", "Pattern" , "pattern" };
-	private static final String Xs[] = { "X", "x", "X (mm)", "x (mm)", "Ref X", "ref x" , "PosX" };
-	private static final String Ys[] = { "Y", "x", "Y (mm)", "x (mm)", "Ref Y", "ref x" , "PosY" };
-	private static final String Rots[] = { "Rotation", "rotation", "Rot", "rot" , "Rotate" };
-	private static final String TBs[] = {  "Layer", "layer", "Side", "side", "TB" , "tb" };
-//////////////////////////////////////////////////////////
-	static private int Ref=-1,Val=-1,Pack=-1,X=-1,Y=-1,Rot=-1,TB=-1,Len=0; 
-	static private char comma=',';
-//////////////////////////////////////////////////////////
-
-	private static int checkCSV(String str[],String val[]) {
-		for(int i=0;i<str.length;i++) 
-			for(int j=0;j<val.length;j++) 
-				if(str[i].equals(val[j])) 
-	  {
-		logger.trace("checkCSV: "+val[j]+" = "+j);
-					return j;
-	  }
-		return -1;
-	}
-	private static boolean checkCSV(String str[]) {
-		for(int i=0;i<str.length;i++)
-		logger.trace("checkCSV: "+i+" -> "+str[i]);
-		if(
-		  (Ref =checkCSV(Refs ,str))!=-1
-		&&(Val =checkCSV(Vals ,str))!=-1
-		&&(Pack=checkCSV(Packs,str))!=-1
-		&&(X   =checkCSV(Xs   ,str))!=-1
-		&&(Y   =checkCSV(Ys   ,str))!=-1
-		&&(Rot =checkCSV(Rots ,str))!=-1
-		&&(TB  =checkCSV(TBs  ,str))!=-2
-		  ) {
-			Len=Ref<=Len?Len:Ref;
-			Len=Val<=Len?Len:Val;
-			Len=Pack<=Len?Len:Pack;
-			Len=X<=Len?Len:X;
-			Len=Y<=Len?Len:Y;
-			Len=Rot<=Len?Len:Rot;
-			Len=TB<=Len?Len:TB;
-		logger.trace("checkCSV: Len = "+Len);
-			return true;
-		}
-		logger.trace("checkCSV: Ref = "+Ref);
-		logger.trace("checkCSV: Val = "+Val);
-		logger.trace("checkCSV: Pack = "+Pack);
-		logger.trace("checkCSV: X = "+X);
-		logger.trace("checkCSV: Y = "+Y);
-		logger.trace("checkCSV: Rot = "+Rot);
-		logger.trace("checkCSV: TB = "+TB);
-		Ref=-1;Val=-1;Pack=-1;X=-1;Y=-1;Rot=-1;TB=-1;Len=0;
-		return false;
-	}
-
-	private static boolean checkLine(String str) throws Exception {
-		logger.trace("checkLine: "+str); int e=0;
-		if(str.charAt(0)=='#') str=str.substring(1); 
-		if(str==null) return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("X")==-1&&str.indexOf("x")==-1) return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("Y")==-1&&str.indexOf("y")==-1) return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("Rot")==-1&&str.indexOf("rot")==-1) return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("val")==-1&&str.indexOf("Val")==-1
-		&& str.indexOf("Comment")==-1&&str.indexOf("comment")==-1) 
-			return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("ootprint")==-1&&str.indexOf("ackage")==-1
-		&& str.indexOf("attern")==-1)
-			return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		if(str.indexOf("Designator")==-1&&str.indexOf("designator")==-1
-		&& str.indexOf("Part")==-1&&str.indexOf("part")==-1 
-		&& str.indexOf("Component")==-1&&str.indexOf("component")==-1 
-		&& str.indexOf("RefDes")==-1&&str.indexOf("Ref")==-1) 
-			return false;
-		logger.trace("checkLine: "+ e++ +" ok");
-		// seems to have data
-		String as[],at[][];
-		CSVParser csvParser = new CSVParser( new StringReader(str) );
-		as=csvParser.getLine(); comma=',';
-		logger.trace("checkLine: comma "+as.length);
-		if(as.length>=6&&checkCSV(as)) return true;
-		logger.trace("checkLine: "+ e++ +" ok");
-		at=csvParser.parse(str,comma='\t'); 
-		logger.trace("checkLine: tab "+as.length);
-		if(at.length>0&&at[0].length>=6&&checkCSV(at[0])) return true;
-		logger.trace("checkLine: "+ e++ +" ok");
-/*
-		at=csvParser.parse(str,comma=' '); 
-		logger.trace("checkLine: space "+as.length);
-		if(at.length>0&&at[0].length>=6&&checkCSV(at[0])) return true;
-		logger.trace("checkLine: done "+ e++ +" ok");
-*/
-		return false;
-	}
 
-/*
-CSVParser csvParser = new CSVParser( new FileInputStream("datei.csv") );
-for ( String as[]; (as = csvParser.getLine()) != null; )
-	if(as.length<=Len) continue;
-	else 		
-  System.out.println( csvParser.lastLineNumber() + " " + t );
-*/
-//////////////////////////////////////////////////////////
-
-	private static List<Placement> parseFile(File file, boolean createMissingParts) throws Exception {
-		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
-		ArrayList<Placement> placements = new ArrayList<>();
-		String line;
-
-		for(int i=0;i++<10&&(line = reader.readLine()) != null;) {
-                        line = line.trim();
-                        if (line.length() == 0) continue;
-			if(checkLine(line)) break;
-		}
-
-
-			if(Len==0) {
-				reader.close();
-				throw new Exception("Unable to parse CSV File Names");
-			}
-
-		//CSVParser csvParser = new CSVParser(new FileInputStream(file));
-		CSVParser csvParser = new CSVParser(reader,comma);
-		for ( String as[] ; (as = csvParser.getLine()) != null; )
-			if(as.length<=Len) continue;
-			else {
-
-		logger.trace("CSV: "+as.length);
-		for(int i=0;i<as.length;i++)
-			logger.trace("CSV("+i+") |"+as[i]+"|");
-		logger.trace("");
-			double placementX = Double.parseDouble(as[X].replace(",",".").replace(" ", "").replace("mm",""));
-			double placementY = Double.parseDouble(as[Y].replace(",",".").replace(" ", "").replace("mm",""));
-			double placementRotation = Double.parseDouble(as[Rot].replace(",",".").replace(" ", ""));
-			while(placementRotation> 180.0) placementRotation-=360.0;
-			while(placementRotation<-180.0) placementRotation+=360.0;
-			
-		logger.trace("ok");
-
-			Placement placement = new Placement(as[Ref]);
-			placement.setLocation(new Location(
-			        LengthUnit.Millimeters,
-			        placementX,
-			        placementY,
-			        0,
-			        placementRotation));
-			Configuration cfg = Configuration.get();
-            if (cfg != null && createMissingParts) {
-                String partId = as[Pack] + "-" + as[Val];
-                Part part = cfg.getPart(partId);
-                if (part == null) {
-                    part = new Part(partId);
-                    Package pkg = cfg.getPackage(as[Pack]);
-                    if (pkg == null) {
-                        pkg = new Package(as[Pack]);
-                        cfg.addPackage(pkg);
+    private static boolean checkLine(String str) throws Exception {
+        logger.trace("checkLine: " + str);
+        int e = 0;
+        if (str.charAt(0) == '#')
+            str = str.substring(1);
+        if (str == null)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("X") == -1 && str.indexOf("x") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("Y") == -1 && str.indexOf("y") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("Rot") == -1 && str.indexOf("rot") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("val") == -1 && str.indexOf("Val") == -1 && str.indexOf("Comment") == -1
+                && str.indexOf("comment") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("ootprint") == -1 && str.indexOf("ackage") == -1
+                && str.indexOf("attern") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        if (str.indexOf("Designator") == -1 && str.indexOf("designator") == -1
+                && str.indexOf("Part") == -1 && str.indexOf("part") == -1
+                && str.indexOf("Component") == -1 && str.indexOf("component") == -1
+                && str.indexOf("RefDes") == -1 && str.indexOf("Ref") == -1)
+            return false;
+        logger.trace("checkLine: " + e++ + " ok");
+        // seems to have data
+        String as[], at[][];
+        CSVParser csvParser = new CSVParser(new StringReader(str));
+        as = csvParser.getLine();
+        comma = ',';
+        logger.trace("checkLine: comma " + as.length);
+        if (as.length >= 6 && checkCSV(as))
+            return true;
+        logger.trace("checkLine: " + e++ + " ok");
+        at = csvParser.parse(str, comma = '\t');
+        logger.trace("checkLine: tab " + as.length);
+        if (at.length > 0 && at[0].length >= 6 && checkCSV(at[0]))
+            return true;
+        logger.trace("checkLine: " + e++ + " ok");
+        /*
+         * at=csvParser.parse(str,comma=' '); logger.trace("checkLine: space "+as.length);
+         * if(at.length>0&&at[0].length>=6&&checkCSV(at[0])) return true; logger.trace(
+         * "checkLine: done "+ e++ +" ok");
+         */
+        return false;
+    }
+
+    /*
+     * CSVParser csvParser = new CSVParser( new FileInputStream("datei.csv") ); for ( String as[];
+     * (as = csvParser.getLine()) != null; ) if(as.length<=Len) continue; else System.out.println(
+     * csvParser.lastLineNumber() + " " + t );
+     */
+    //////////////////////////////////////////////////////////
+
+    private static List<Placement> parseFile(File file, boolean createMissingParts)
+            throws Exception {
+        BufferedReader reader =
+                new BufferedReader(new InputStreamReader(new FileInputStream(file)));
+        ArrayList<Placement> placements = new ArrayList<>();
+        String line;
+
+        for (int i = 0; i++ < 10 && (line = reader.readLine()) != null;) {
+            line = line.trim();
+            if (line.length() == 0)
+                continue;
+            if (checkLine(line))
+                break;
+        }
+
+
+        if (Len == 0) {
+            reader.close();
+            throw new Exception("Unable to parse CSV File Names");
+        }
+
+        // CSVParser csvParser = new CSVParser(new FileInputStream(file));
+        CSVParser csvParser = new CSVParser(reader, comma);
+        for (String as[]; (as = csvParser.getLine()) != null;)
+            if (as.length <= Len)
+                continue;
+            else {
+
+                logger.trace("CSV: " + as.length);
+                for (int i = 0; i < as.length; i++)
+                    logger.trace("CSV(" + i + ") |" + as[i] + "|");
+                logger.trace("");
+                double placementX = Double
+                        .parseDouble(as[X].replace(",", ".").replace(" ", "").replace("mm", ""));
+                double placementY = Double
+                        .parseDouble(as[Y].replace(",", ".").replace(" ", "").replace("mm", ""));
+                double placementRotation =
+                        Double.parseDouble(as[Rot].replace(",", ".").replace(" ", ""));
+                while (placementRotation > 180.0)
+                    placementRotation -= 360.0;
+                while (placementRotation < -180.0)
+                    placementRotation += 360.0;
+
+                logger.trace("ok");
+
+                Placement placement = new Placement(as[Ref]);
+                placement.setLocation(new Location(LengthUnit.Millimeters, placementX, placementY,
+                        0, placementRotation));
+                Configuration cfg = Configuration.get();
+                if (cfg != null && createMissingParts) {
+                    String partId = as[Pack] + "-" + as[Val];
+                    Part part = cfg.getPart(partId);
+                    if (part == null) {
+                        part = new Part(partId);
+                        Package pkg = cfg.getPackage(as[Pack]);
+                        if (pkg == null) {
+                            pkg = new Package(as[Pack]);
+                            cfg.addPackage(pkg);
+                        }
+                        part.setPackage(pkg);
+
+                        cfg.addPart(part);
+                    }
+                    placement.setPart(part);
+
+                }
+
+                char c = 0;
+                if (TB != -1)
+                    c = as[TB].charAt(0);
+                placement.setSide(c == 'B' || c == 'b' ? Side.Bottom : Side.Top);
+                c = 0;
+                placements.add(placement);
+            }
+        logger.trace("ok");
+        reader.close();
+        logger.trace("ok");
+        return placements;
+    }
+
+    class Dlg extends JDialog {
+        private JTextField textFieldTopFile;
+        private final Action browseTopFileAction = new SwingAction();
+        private final Action importAction = new SwingAction_2();
+        private final Action cancelAction = new SwingAction_3();
+        private JCheckBox chckbxCreateMissingParts;
+
+        public Dlg(Frame parent) {
+            super(parent, DESCRIPTION, true);
+            getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
+
+            JPanel panel = new JPanel();
+            panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP,
+                    null, null));
+            getContentPane().add(panel);
+            panel.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                            FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                            FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                            FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+            JLabel lblTopFilemnt = new JLabel("Centeroid File (.csv)");
+            panel.add(lblTopFilemnt, "2, 2, right, default");
+
+            textFieldTopFile = new JTextField();
+            panel.add(textFieldTopFile, "4, 2, fill, default");
+            textFieldTopFile.setColumns(10);
+
+            JButton btnBrowse = new JButton("Browse");
+            btnBrowse.setAction(browseTopFileAction);
+            panel.add(btnBrowse, "6, 2");
+
+            JPanel panel_1 = new JPanel();
+            panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING,
+                    TitledBorder.TOP, null, null));
+            getContentPane().add(panel_1);
+            panel_1.setLayout(new FormLayout(
+                    new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                    new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+            chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
+            chckbxCreateMissingParts.setSelected(true);
+            panel_1.add(chckbxCreateMissingParts, "2, 2");
+
+            JSeparator separator = new JSeparator();
+            getContentPane().add(separator);
+
+            JPanel panel_2 = new JPanel();
+            FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
+            flowLayout.setAlignment(FlowLayout.RIGHT);
+            getContentPane().add(panel_2);
+
+            JButton btnCancel = new JButton("Cancel");
+            btnCancel.setAction(cancelAction);
+            panel_2.add(btnCancel);
+
+            JButton btnImport = new JButton("Import");
+            btnImport.setAction(importAction);
+            panel_2.add(btnImport);
+
+            setSize(400, 400);
+            setLocationRelativeTo(parent);
+
+            JRootPane rootPane = getRootPane();
+            KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
+            InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+            inputMap.put(stroke, "ESCAPE");
+            rootPane.getActionMap().put("ESCAPE", cancelAction);
+        }
+
+        private class SwingAction extends AbstractAction {
+            public SwingAction() {
+                putValue(NAME, "Browse");
+                putValue(SHORT_DESCRIPTION, "Browse");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                FileDialog fileDialog = new FileDialog(Dlg.this);
+                fileDialog.setFilenameFilter(new FilenameFilter() {
+                    @Override
+                    public boolean accept(File dir, String name) {
+                        return false || name.toLowerCase().endsWith(".csv")
+                                || name.toLowerCase().endsWith(".txt")
+                                || name.toLowerCase().endsWith(".dat");
                     }
-                    part.setPackage(pkg);
+                });
+                fileDialog.setVisible(true);
+                if (fileDialog.getFile() == null) {
+                    return;
+                }
+                File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
+                textFieldTopFile.setText(file.getAbsolutePath());
+            }
+        }
+
+
 
-                    cfg.addPart(part);
+        private class SwingAction_2 extends AbstractAction {
+            public SwingAction_2() {
+                putValue(NAME, "Import");
+                putValue(SHORT_DESCRIPTION, "Import");
+            }
+
+            public void actionPerformed(ActionEvent e) {
+                logger.debug("Parsing " + textFieldTopFile.getText() + " CSV FIle");
+                topFile = new File(textFieldTopFile.getText());
+                board = new Board();
+                List<Placement> placements = new ArrayList<>();
+                try {
+                    if (topFile.exists()) {
+                        placements
+                                .addAll(parseFile(topFile, chckbxCreateMissingParts.isSelected()));
+                    }
+                }
+                catch (Exception e1) {
+                    MessageBoxes.errorBox(Dlg.this, "Import Error", e1);
+                    return;
                 }
-                placement.setPart(part);
+                for (Placement placement : placements) {
+                    board.addPlacement(placement);
+                }
+                setVisible(false);
+            }
+        }
 
+        private class SwingAction_3 extends AbstractAction {
+            public SwingAction_3() {
+                putValue(NAME, "Cancel");
+                putValue(SHORT_DESCRIPTION, "Cancel");
             }
 
-		char c=0; 
-		if(TB!=-1) c=as[TB].charAt(0); 
-		placement.setSide(c=='B'||c=='b'?Side.Bottom:Side.Top);
-		c=0;
-			placements.add(placement);
-		}
-		logger.trace("ok");
-		reader.close();
-		logger.trace("ok");
-		return placements;
-	}
-	
-	class Dlg extends JDialog {
-	    private JTextField textFieldTopFile;
-	    private final Action browseTopFileAction = new SwingAction();
-	    private final Action importAction = new SwingAction_2();
-	    private final Action cancelAction = new SwingAction_3();
-	    private JCheckBox chckbxCreateMissingParts;
-
-	    public Dlg(Frame parent) {
-	        super(parent, DESCRIPTION, true);
-	        getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
-	        
-	        JPanel panel = new JPanel();
-	        panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-	        getContentPane().add(panel);
-	        panel.setLayout(new FormLayout(new ColumnSpec[] {
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                ColumnSpec.decode("default:grow"),
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,},
-	            new RowSpec[] {
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,}));
-	        
-	        JLabel lblTopFilemnt = new JLabel("Centeroid File (.csv)");
-	        panel.add(lblTopFilemnt, "2, 2, right, default");
-	        
-	        textFieldTopFile = new JTextField();
-	        panel.add(textFieldTopFile, "4, 2, fill, default");
-	        textFieldTopFile.setColumns(10);
-	        
-	        JButton btnBrowse = new JButton("Browse");
-	        btnBrowse.setAction(browseTopFileAction);
-	        panel.add(btnBrowse, "6, 2");
-	        
-	        JPanel panel_1 = new JPanel();
-	        panel_1.setBorder(new TitledBorder(null, "Options", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-	        getContentPane().add(panel_1);
-	        panel_1.setLayout(new FormLayout(new ColumnSpec[] {
-	                FormSpecs.RELATED_GAP_COLSPEC,
-	                FormSpecs.DEFAULT_COLSPEC,},
-	            new RowSpec[] {
-	                FormSpecs.RELATED_GAP_ROWSPEC,
-	                FormSpecs.DEFAULT_ROWSPEC,}));
-	        
-	        chckbxCreateMissingParts = new JCheckBox("Create Missing Parts");
-	        chckbxCreateMissingParts.setSelected(true);
-	        panel_1.add(chckbxCreateMissingParts, "2, 2");
-	        
-	        JSeparator separator = new JSeparator();
-	        getContentPane().add(separator);
-	        
-	        JPanel panel_2 = new JPanel();
-	        FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
-	        flowLayout.setAlignment(FlowLayout.RIGHT);
-	        getContentPane().add(panel_2);
-	        
-	        JButton btnCancel = new JButton("Cancel");
-	        btnCancel.setAction(cancelAction);
-	        panel_2.add(btnCancel);
-	        
-	        JButton btnImport = new JButton("Import");
-	        btnImport.setAction(importAction);
-	        panel_2.add(btnImport);
-	        
-	        setSize(400, 400);
-	        setLocationRelativeTo(parent);
-	        
-	        JRootPane rootPane = getRootPane();
-	        KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-	        InputMap inputMap = rootPane
-	                .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
-	        inputMap.put(stroke, "ESCAPE");
-	        rootPane.getActionMap().put("ESCAPE", cancelAction);
-	    }
-	    
-	    private class SwingAction extends AbstractAction {
-	        public SwingAction() {
-	            putValue(NAME, "Browse");
-	            putValue(SHORT_DESCRIPTION, "Browse");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            FileDialog fileDialog = new FileDialog(Dlg.this);
-	            fileDialog.setFilenameFilter(new FilenameFilter() {
-	                @Override
-	                public boolean accept(File dir, String name) {
-	                    return false 
-				|| name.toLowerCase().endsWith(".csv")
-				|| name.toLowerCase().endsWith(".txt")
-				|| name.toLowerCase().endsWith(".dat")
-				;
-	                }
-	            });
-	            fileDialog.setVisible(true);
-	            if (fileDialog.getFile() == null) {
-	                return;
-	            }
-	            File file = new File(new File(fileDialog.getDirectory()), fileDialog.getFile());
-	            textFieldTopFile.setText(file.getAbsolutePath());
-	        }
-	    }
-	    
-
-
-	    private class SwingAction_2 extends AbstractAction {
-	        public SwingAction_2() {
-	            putValue(NAME, "Import");
-	            putValue(SHORT_DESCRIPTION, "Import");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-		    logger.debug("Parsing "+textFieldTopFile.getText()+" CSV FIle");
-	            topFile = new File(textFieldTopFile.getText());
-	            board = new Board();
-	            List<Placement> placements = new ArrayList<>();
-	            try {
-	                if (topFile.exists()) {
-	                    placements.addAll(parseFile(topFile, chckbxCreateMissingParts.isSelected()));
-	                }
-	            }
-	            catch (Exception e1) {
-	                MessageBoxes.errorBox(Dlg.this, "Import Error", e1);
-	                return;
-	            }
-	            for (Placement placement : placements) {
-	                board.addPlacement(placement);
-	            }
-	            setVisible(false);
-	        }
-	    }
-	    
-	    private class SwingAction_3 extends AbstractAction {
-	        public SwingAction_3() {
-	            putValue(NAME, "Cancel");
-	            putValue(SHORT_DESCRIPTION, "Cancel");
-	        }
-	        public void actionPerformed(ActionEvent e) {
-	            setVisible(false);
-	        }
-	    }
-	}
+            public void actionPerformed(ActionEvent e) {
+                setVisible(false);
+            }
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporter.java b/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporter.java
index 123865c1d8..b74fe9c3e2 100755
--- a/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporter.java
+++ b/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporter.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.importer;
@@ -30,14 +28,14 @@
 public class SolderPasteGerberImporter implements BoardImporter {
     private final static String NAME = "Gerber Solder Paste Layer";
     final static String DESCRIPTION = "Import RS-274X Gerber solder paste layers.";
-    
-	Board board;
-	File topFile;
+
+    Board board;
+    File topFile;
     File bottomFile;
-	
-	@Override
+
+    @Override
     public String getImporterName() {
-	    return NAME;
+        return NAME;
     }
 
     @Override
@@ -46,9 +44,9 @@ public String getImporterDescription() {
     }
 
     @Override
-	public Board importBoard(Frame parent) throws Exception {
+    public Board importBoard(Frame parent) throws Exception {
         SolderPasteGerberImporterDlg dlg = new SolderPasteGerberImporterDlg(this, parent);
-		dlg.setVisible(true);
-		return board;
-	}
+        dlg.setVisible(true);
+        return board;
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporterDlg.java b/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporterDlg.java
index 90be80cbd9..13dac02a06 100755
--- a/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporterDlg.java
+++ b/src/main/java/org/openpnp/gui/importer/SolderPasteGerberImporterDlg.java
@@ -42,90 +42,86 @@
     private final Action browseBottomFileAction = new SwingAction_1();
     private final Action importAction = new SwingAction_2();
     private final Action cancelAction = new SwingAction_3();
-    
-    public SolderPasteGerberImporterDlg(SolderPasteGerberImporter solderPasteGerberImporter, Frame parent) {
+
+    public SolderPasteGerberImporterDlg(SolderPasteGerberImporter solderPasteGerberImporter,
+            Frame parent) {
         super(parent, SolderPasteGerberImporter.DESCRIPTION, true);
         this.solderPasteGerberImporter = solderPasteGerberImporter;
         getContentPane().setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));
-        
+
         JPanel panel = new JPanel();
-        panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panel.setBorder(new TitledBorder(null, "Files", TitledBorder.LEADING, TitledBorder.TOP,
+                null, null));
         getContentPane().add(panel);
-        panel.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panel.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblTopFilemnt = new JLabel("Top Paste Gerber");
         panel.add(lblTopFilemnt, "2, 2, right, default");
-        
+
         textFieldTopFile = new JTextField();
         panel.add(textFieldTopFile, "4, 2, fill, default");
         textFieldTopFile.setColumns(10);
-        
+
         JButton btnBrowse = new JButton("Browse");
         btnBrowse.setAction(browseTopFileAction);
         panel.add(btnBrowse, "6, 2");
-        
+
         JLabel lblBottomFilemnb = new JLabel("Bottom Paste Gerber");
         panel.add(lblBottomFilemnb, "2, 4, right, default");
-        
+
         textFieldBottomFile = new JTextField();
         panel.add(textFieldBottomFile, "4, 4, fill, default");
         textFieldBottomFile.setColumns(10);
-        
+
         JButton btnBrowse_1 = new JButton("Browse");
         btnBrowse_1.setAction(browseBottomFileAction);
         panel.add(btnBrowse_1, "6, 4");
-        
+
         JSeparator separator = new JSeparator();
         getContentPane().add(separator);
-        
+
         JPanel panel_2 = new JPanel();
         FlowLayout flowLayout = (FlowLayout) panel_2.getLayout();
         flowLayout.setAlignment(FlowLayout.RIGHT);
         getContentPane().add(panel_2);
-        
+
         JButton btnCancel = new JButton("Cancel");
         btnCancel.setAction(cancelAction);
         panel_2.add(btnCancel);
-        
+
         JButton btnImport = new JButton("Import");
         btnImport.setAction(importAction);
         panel_2.add(btnImport);
-        
+
         setSize(400, 400);
         setLocationRelativeTo(parent);
-        
+
         JRootPane rootPane = getRootPane();
         KeyStroke stroke = KeyStroke.getKeyStroke("ESCAPE");
-        InputMap inputMap = rootPane
-                .getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
+        InputMap inputMap = rootPane.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
         inputMap.put(stroke, "ESCAPE");
         rootPane.getActionMap().put("ESCAPE", cancelAction);
     }
-    
+
     private class SwingAction extends AbstractAction {
         public SwingAction() {
             putValue(NAME, "Browse");
             putValue(SHORT_DESCRIPTION, "Browse");
         }
+
         public void actionPerformed(ActionEvent e) {
             FileDialog fileDialog = new FileDialog(SolderPasteGerberImporterDlg.this);
-//            fileDialog.setFilenameFilter(new FilenameFilter() {
-//                @Override
-//                public boolean accept(File dir, String name) {
-//                    return name.toLowerCase().endsWith(".mnt");
-//                }
-//            });
+            // fileDialog.setFilenameFilter(new FilenameFilter() {
+            // @Override
+            // public boolean accept(File dir, String name) {
+            // return name.toLowerCase().endsWith(".mnt");
+            // }
+            // });
             fileDialog.setVisible(true);
             if (fileDialog.getFile() == null) {
                 return;
@@ -134,20 +130,21 @@ public void actionPerformed(ActionEvent e) {
             textFieldTopFile.setText(file.getAbsolutePath());
         }
     }
-    
+
     private class SwingAction_1 extends AbstractAction {
         public SwingAction_1() {
             putValue(NAME, "Browse");
             putValue(SHORT_DESCRIPTION, "Browse");
         }
+
         public void actionPerformed(ActionEvent e) {
             FileDialog fileDialog = new FileDialog(SolderPasteGerberImporterDlg.this);
-//            fileDialog.setFilenameFilter(new FilenameFilter() {
-//                @Override
-//                public boolean accept(File dir, String name) {
-//                    return name.toLowerCase().endsWith(".mnb");
-//                }
-//            });
+            // fileDialog.setFilenameFilter(new FilenameFilter() {
+            // @Override
+            // public boolean accept(File dir, String name) {
+            // return name.toLowerCase().endsWith(".mnb");
+            // }
+            // });
             fileDialog.setVisible(true);
             if (fileDialog.getFile() == null) {
                 return;
@@ -162,21 +159,27 @@ public SwingAction_2() {
             putValue(NAME, "Import");
             putValue(SHORT_DESCRIPTION, "Import");
         }
+
         public void actionPerformed(ActionEvent e) {
-            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.topFile = new File(textFieldTopFile.getText());
-            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile = new File(textFieldBottomFile.getText());
+            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.topFile =
+                    new File(textFieldTopFile.getText());
+            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile =
+                    new File(textFieldBottomFile.getText());
             SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.board = new Board();
             List<BoardPad> pads = new ArrayList<>();
             try {
                 if (SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.topFile.exists()) {
-                    List<BoardPad> topPads = new Rs274xParser().parseSolderPastePads(SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.topFile);
+                    List<BoardPad> topPads = new Rs274xParser().parseSolderPastePads(
+                            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.topFile);
                     for (BoardPad pad : topPads) {
                         pad.setSide(Side.Top);
                     }
                     pads.addAll(topPads);
                 }
-                if (SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile.exists()) {
-                    List<BoardPad> bottomPads = new Rs274xParser().parseSolderPastePads(SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile);
+                if (SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile
+                        .exists()) {
+                    List<BoardPad> bottomPads = new Rs274xParser().parseSolderPastePads(
+                            SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.bottomFile);
                     for (BoardPad pad : bottomPads) {
                         pad.setSide(Side.Bottom);
                     }
@@ -188,19 +191,21 @@ public void actionPerformed(ActionEvent e) {
                 return;
             }
             for (BoardPad pad : pads) {
-                SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.board.addSolderPastePad(pad);
+                SolderPasteGerberImporterDlg.this.solderPasteGerberImporter.board
+                        .addSolderPastePad(pad);
             }
             setVisible(false);
         }
     }
-    
+
     private class SwingAction_3 extends AbstractAction {
         public SwingAction_3() {
             putValue(NAME, "Cancel");
             putValue(SHORT_DESCRIPTION, "Cancel");
         }
+
         public void actionPerformed(ActionEvent e) {
             setVisible(false);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/importer/rs274x/Rs274xParser.java b/src/main/java/org/openpnp/gui/importer/rs274x/Rs274xParser.java
index b7868d7865..33d9daaf07 100755
--- a/src/main/java/org/openpnp/gui/importer/rs274x/Rs274xParser.java
+++ b/src/main/java/org/openpnp/gui/importer/rs274x/Rs274xParser.java
@@ -20,25 +20,22 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * A simple RS-274X parser. Not intended to be a general parser, but implements
- * only OpenPnP specific functionality.
+ * A simple RS-274X parser. Not intended to be a general parser, but implements only OpenPnP
+ * specific functionality.
  */
 public class Rs274xParser {
     private final static Logger logger = LoggerFactory.getLogger(Rs274xParser.class);
-    
+
     enum LevelPolarity {
-        Dark,
-        Clear
+        Dark, Clear
     }
-    
+
     enum InterpolationMode {
-        Linear,
-        Clockwise,
-        CounterClockwise
+        Linear, Clockwise, CounterClockwise
     }
-    
+
     private BufferedReader reader;
-    
+
     // Context
     private LengthUnit unit;
     private Aperture currentAperture;
@@ -56,21 +53,22 @@
      * Maps Aperture indexes to a count to aid in generation of pad names.
      */
     private Map<Integer, Integer> apertureUseCounts = new HashMap<>();
-    
+
     private boolean stopped;
     private int lineNumber;
     private ParseStatistics parseStatistics;
     private boolean regionStarted;
-    
+
     private List<BoardPad> pads;
 
     public Rs274xParser() {
         reset();
     }
-    
+
     /**
      * Parse the given File for solder paste pads.
-     * @see #parseSolderPastePads(Reader) 
+     * 
+     * @see #parseSolderPastePads(Reader)
      * @param file
      * @return
      * @throws Exception
@@ -79,19 +77,17 @@ public Rs274xParser() {
         logger.info("Parsing " + file);
         return parseSolderPastePads(new FileReader(file));
     }
-    
+
     /**
-     * Parse the input from the Reader extracting individual pads to be used
-     * for solder paste application. It is expected that the input is is
-     * an RS-274X Gerber solder paste layer.
+     * Parse the input from the Reader extracting individual pads to be used for solder paste
+     * application. It is expected that the input is is an RS-274X Gerber solder paste layer.
      * 
-     * Currently this code only parses out single flashes of rectangular,
-     * circular and oblong apertures. Ideas for future versions include
-     * rendering the entire file and uses blob detection and contour
-     * finding to create polygon pads.
+     * Currently this code only parses out single flashes of rectangular, circular and oblong
+     * apertures. Ideas for future versions include rendering the entire file and uses blob
+     * detection and contour finding to create polygon pads.
      * 
-     * Another option is to consider each operation it's own element/shape. 
-     * This is how gerbv seems to do it.
+     * Another option is to consider each operation it's own element/shape. This is how gerbv seems
+     * to do it.
      * 
      * @param reader
      * @return
@@ -99,9 +95,9 @@ public Rs274xParser() {
      */
     public List<BoardPad> parseSolderPastePads(Reader reader) throws Exception {
         reset();
-        
+
         this.reader = new BufferedReader(reader);
-        
+
         try {
             while (!stopped) {
                 readCommand();
@@ -111,10 +107,10 @@ public Rs274xParser() {
             parseStatistics.errored = true;
             error("Uncaught error: " + e.getMessage());
         }
-        
+
         return pads;
     }
-    
+
     private void readCommand() throws Exception {
         if (peek() == '%') {
             readExtendedCodeCommand();
@@ -123,7 +119,7 @@ private void readCommand() throws Exception {
             readFunctionCodeCommand();
         }
     }
-    
+
     private void readFunctionCodeCommand() throws Exception {
         // a command is either a D, G, M or coordinate data
         // followed by a D.
@@ -152,7 +148,7 @@ private void readFunctionCodeCommand() throws Exception {
                     readMcode();
                     return;
                 }
-                // TODO: See 7.2 Coordinate Data without Operation Code
+                    // TODO: See 7.2 Coordinate Data without Operation Code
                 case 'X': {
                     coordinate.x = readCoordinateValue();
                     break;
@@ -169,13 +165,13 @@ private void readFunctionCodeCommand() throws Exception {
                     arcCoordinate.y = readCoordinateValue();
                     break;
                 }
-                default : {
+                default: {
                     error("Unknown function code " + ((char) ch));
                 }
             }
         }
     }
-    
+
     // G54D06
     private void readGcode() throws Exception {
         int code = readInteger();
@@ -246,8 +242,9 @@ private void readGcode() throws Exception {
             }
         }
     }
-    
-    private void readDcode(Point2D.Double coordinate, Point2D.Double arcCoordinate) throws Exception {
+
+    private void readDcode(Point2D.Double coordinate, Point2D.Double arcCoordinate)
+            throws Exception {
         int code = readInteger();
         switch (code) {
             case 1: {
@@ -275,7 +272,7 @@ private void readDcode(Point2D.Double coordinate, Point2D.Double arcCoordinate)
             }
         }
     }
-    
+
     private void readMcode() throws Exception {
         int code = readInteger();
         switch (code) {
@@ -297,19 +294,21 @@ private void readMcode() throws Exception {
             }
         }
     }
-    
+
     /**
-     * Linear or circular interpolation. If in region mode, add a line or arc
-     * to the current contour. Otherwise draw a line or arc.
+     * Linear or circular interpolation. If in region mode, add a line or arc to the current
+     * contour. Otherwise draw a line or arc.
+     * 
      * @param coordinate
      * @param arcCoordinate
      * @throws Exception
      */
-    private void performD01(Point2D.Double coordinate, Point2D.Double arcCoordinate) throws Exception {
+    private void performD01(Point2D.Double coordinate, Point2D.Double arcCoordinate)
+            throws Exception {
         if (interpolationMode == null) {
             error("Interpolation most must be set before using D02");
         }
-        
+
         if (regionMode) {
             if (interpolationMode == InterpolationMode.Linear) {
                 addRegionLine(coordinate);
@@ -330,10 +329,10 @@ private void performD01(Point2D.Double coordinate, Point2D.Double arcCoordinate)
         }
         currentPoint = coordinate;
     }
-    
+
     /**
-     * Move / set the current coordinate. Additionally, in region mode end
-     * the current contour.
+     * Move / set the current coordinate. Additionally, in region mode end the current contour.
+     * 
      * @param coordinate
      * @throws Exception
      */
@@ -341,16 +340,17 @@ private void performD02(Point2D.Double coordinate) throws Exception {
         if (interpolationMode == null) {
             error("Interpolation mode must be set before using D02");
         }
-        
+
         if (regionMode) {
             closeRegion();
         }
-        
+
         currentPoint = coordinate;
     }
-    
+
     /**
      * Flash the current aperture at the given coordinate.
+     * 
      * @param coordinate
      * @throws Exception
      */
@@ -361,9 +361,9 @@ private void performD03(Point2D.Double coordinate) throws Exception {
         if (regionMode) {
             error("Can't flash in region mode");
         }
-        
+
         parseStatistics.flashCount++;
-        
+
         Integer counter = apertureUseCounts.get(currentAperture.getIndex());
         if (counter == null) {
             counter = 0;
@@ -372,17 +372,17 @@ private void performD03(Point2D.Double coordinate) throws Exception {
             counter++;
         }
         apertureUseCounts.put(currentAperture.getIndex(), counter);
-        
+
         BoardPad pad = currentAperture.createPad(unit, coordinate);
-        pad.setName(String.format("D%02d-%03d",  currentAperture.getIndex(), counter++));
+        pad.setName(String.format("D%02d-%03d", currentAperture.getIndex(), counter++));
         pads.add(pad);
         parseStatistics.padCount++;
 
         currentPoint = coordinate;
-        
+
         parseStatistics.flashPerformedCount++;
     }
-    
+
     private void enableRegionMode() throws Exception {
         if (regionMode) {
             error("Can't start region mode when already in region mode");
@@ -390,7 +390,7 @@ private void enableRegionMode() throws Exception {
         regionMode = true;
         regionStarted = false;
     }
-    
+
     private void addRegionLine(Point2D.Double coordinate) throws Exception {
         if (!regionMode) {
             error("Can't add region line outside of region mode");
@@ -401,8 +401,9 @@ private void addRegionLine(Point2D.Double coordinate) throws Exception {
         parseStatistics.regionLineCount++;
         warn("Linear interpolation in region mode not yet supported");
     }
-    
-    private void addRegionArc(Point2D.Double coordinate, Point2D.Double arcCoordinate) throws Exception {
+
+    private void addRegionArc(Point2D.Double coordinate, Point2D.Double arcCoordinate)
+            throws Exception {
         if (!regionMode) {
             error("Can't add region arc outside of region mode");
         }
@@ -412,7 +413,7 @@ private void addRegionArc(Point2D.Double coordinate, Point2D.Double arcCoordinat
         parseStatistics.regionArcCount++;
         warn("Circular interpolation in region mode not yet supported");
     }
-    
+
     private void closeRegion() throws Exception {
         if (!regionMode) {
             error("Can't end region when not in region mode");
@@ -422,7 +423,7 @@ private void closeRegion() throws Exception {
             parseStatistics.regionCount++;
         }
     }
-    
+
     private void disableRegionMode() throws Exception {
         if (!regionMode) {
             error("Can't exit region mode, not in region mode");
@@ -430,7 +431,7 @@ private void disableRegionMode() throws Exception {
         closeRegion();
         regionMode = false;
     }
-    
+
     private void readExtendedCodeCommand() throws Exception {
         if (read() != '%') {
             error("Expected start of extended code command");
@@ -451,7 +452,8 @@ private void readExtendedCodeCommand() throws Exception {
             }
             case "AD": {
                 // Assigns a D code number to an aperture definition. See 4.11.
-                // These commands can be used multiple times. It is recommended to put them in header of a file.
+                // These commands can be used multiple times. It is recommended to put them in
+                // header of a file.
                 readApertureDefinition();
                 break;
             }
@@ -472,7 +474,8 @@ private void readExtendedCodeCommand() throws Exception {
                 break;
             }
             case "LP": {
-                // Starts a new level and sets the ‘Level polarity’ graphics state parameter. See 4.14.
+                // Starts a new level and sets the ‘Level polarity’ graphics state parameter. See
+                // 4.14.
                 readUntil('*');
                 read();
                 break;
@@ -536,13 +539,13 @@ private void readExtendedCodeCommand() throws Exception {
             error("Expected end of extended code command");
         }
     }
-    
+
     private void readApertureDefinition() throws Exception {
         int ch;
         if (read() != 'D') {
             error("Expected aperture D code");
         }
-        
+
         int code = readInteger();
         int type = read();
         Aperture aperture = null;
@@ -564,12 +567,13 @@ private void readApertureDefinition() throws Exception {
                 break;
             }
             default: {
-                error(String.format("Unhandled aperture definition type %c, code %d", ((char) type), code));
+                error(String.format("Unhandled aperture definition type %c, code %d", ((char) type),
+                        code));
             }
         }
         apertures.put(code, aperture);
     }
-    
+
     private Aperture readRectangleApertureDefinition(int index) throws Exception {
         if (read() != ',') {
             error("Expected , in rectangle aperture definition");
@@ -589,7 +593,7 @@ private Aperture readRectangleApertureDefinition(int index) throws Exception {
         }
         return new RectangleAperture(index, width, height, holeDiameter);
     }
-    
+
     private Aperture readCircleApertureDefinition(int index) throws Exception {
         if (read() != ',') {
             error("Expected , in circle aperture definition");
@@ -605,7 +609,7 @@ private Aperture readCircleApertureDefinition(int index) throws Exception {
         }
         return new CircleAperture(index, diameter, holeDiameter);
     }
-    
+
     private Aperture readObroundApertureDefinition(int index) throws Exception {
         if (read() != ',') {
             error("Expected , in obround aperture definition");
@@ -625,25 +629,25 @@ private Aperture readObroundApertureDefinition(int index) throws Exception {
         }
         return new ObroundAperture(index, width, height, holeDiameter);
     }
-    
+
     private Aperture readPolygonApertureDefinition(int index) throws Exception {
         if (read() != ',') {
             error("Expected , in circle aperture definition");
         }
 
         double diameter = readDecimal();
-        
+
         if (read() != 'X') {
             error("Expected X in polygon aperture definition");
         }
         int numberOfVertices = readInteger();
-        
+
         Double rotation = null;
         if (peek() == 'X') {
             read();
             rotation = readDecimal();
         }
-        
+
         Double holeDiameter = null;
         if (peek() == 'X') {
             read();
@@ -654,7 +658,7 @@ private Aperture readPolygonApertureDefinition(int index) throws Exception {
         }
         return new PolygonAperture(index, diameter, numberOfVertices, rotation, holeDiameter);
     }
-    
+
     private void readUnit() throws Exception {
         String unitCode = readString(2);
         if (unitCode.equals("MM")) {
@@ -666,15 +670,15 @@ else if (unitCode.equals("IN")) {
         else {
             error("Unknown unit code " + unitCode);
         }
-        
+
         if (read() != '*') {
             error("Expected end of data block");
         }
     }
-    
+
     private void readCoordinateFormat() throws Exception {
         int ch;
-        
+
         while ("LTAI".indexOf((char) peek()) != -1) {
             ch = read();
             switch (ch) {
@@ -696,7 +700,7 @@ private void readCoordinateFormat() throws Exception {
                 }
             }
         }
-        
+
         int xI, xD, yI, yD;
 
         ch = read();
@@ -711,7 +715,7 @@ private void readCoordinateFormat() throws Exception {
         if (xD < 4 || xD > 6) {
             warn("Invalid coordinate format, X decimal part {}, should be >= 4 && <= 6", xD);
         }
-        
+
         ch = read();
         if (ch != 'Y') {
             error("Expected Y coordinate format");
@@ -724,19 +728,20 @@ private void readCoordinateFormat() throws Exception {
         if (yD < 4 || yD > 6) {
             warn("Invalid coordinate format, Y decimal part {}, should be >= 4 && <= 6", yD);
         }
-        
+
         if (xI != yI || xD != yD) {
-            error(String.format("Coordinate format X does not match Y: %d.%d != %d.%d", xI, xD, yI, yD));
+            error(String.format("Coordinate format X does not match Y: %d.%d != %d.%d", xI, xD, yI,
+                    yD));
         }
-        
+
         coordinateFormatIntegerLength = xI;
         coordinateFormatDecimalLength = xD;
-        
+
         if (read() != '*') {
             error("Expected end of data block");
         }
     }
-    
+
     private String readUntil(int ch) throws Exception {
         StringBuffer sb = new StringBuffer();
         while (peek() != ch) {
@@ -744,7 +749,7 @@ private String readUntil(int ch) throws Exception {
         }
         return sb.toString();
     }
-    
+
     private String readString(int length) throws Exception {
         StringBuffer sb = new StringBuffer();
         for (int i = 0; i < length; i++) {
@@ -752,7 +757,7 @@ private String readString(int length) throws Exception {
         }
         return sb.toString();
     }
-    
+
     private double readDecimal() throws Exception {
         boolean negative = false;
         int ch = peek();
@@ -770,7 +775,7 @@ else if (ch == '+') {
         }
         return (negative ? -1 : 1) * Double.parseDouble(sb.toString());
     }
-    
+
     private int readInteger() throws Exception {
         boolean negative = false;
         int ch = peek();
@@ -788,7 +793,7 @@ else if (ch == '+') {
         }
         return (negative ? -1 : 1) * Integer.parseInt(sb.toString());
     }
-    
+
     private double readCoordinateValue() throws Exception {
         if (coordinateFormatIncremental) {
             error("Incremental coordinate format not supported");
@@ -808,13 +813,14 @@ private double readCoordinateValue() throws Exception {
             sValue = "0" + sValue;
         }
         String integerPart = sValue.substring(0, coordinateFormatIntegerLength);
-        String decimalPart = sValue.substring(coordinateFormatIntegerLength, coordinateFormatIntegerLength + coordinateFormatDecimalLength - 1);
+        String decimalPart = sValue.substring(coordinateFormatIntegerLength,
+                coordinateFormatIntegerLength + coordinateFormatDecimalLength - 1);
         return (value < 0 ? -1 : 1) * Double.parseDouble(integerPart + "." + decimalPart);
     }
-    
+
     /**
-     * Read the next character in the stream, skipping any \r or \n that
-     * precede it.
+     * Read the next character in the stream, skipping any \r or \n that precede it.
+     * 
      * @return
      * @throws Exception
      */
@@ -826,10 +832,10 @@ private int read() throws Exception {
         }
         return ch;
     }
-    
+
     /**
-     * Peek at the next character in the stream, skipping any \r or \n that
-     * precede it.
+     * Peek at the next character in the stream, skipping any \r or \n that precede it.
+     * 
      * @return
      * @throws Exception
      */
@@ -837,9 +843,10 @@ private int peek() throws Exception {
         skipCrLf();
         return _peek();
     }
-    
+
     /**
-     * Consume any number of \r or \n, stopping when another character is found. 
+     * Consume any number of \r or \n, stopping when another character is found.
+     * 
      * @throws Exception
      */
     private void skipCrLf() throws Exception {
@@ -857,9 +864,10 @@ else if (ch == '\r') {
             }
         }
     }
-    
+
     /**
      * Return the next character in the reader without consuming it.
+     * 
      * @return
      * @throws Exception
      */
@@ -872,17 +880,16 @@ private int _peek() throws Exception {
         reader.reset();
         return ch;
     }
-    
+
     private void reset() {
         unit = null;
         currentAperture = null;
         currentPoint = new Point2D.Double(0, 0);
         levelPolarity = LevelPolarity.Dark;
         /*
-         * This is non-standard, but expected by Eagle, at least. The standard
-         * says that interpolation mode is undefined at the start of the file
-         * but Eagle does not appear to send a G01 at any point before it
-         * starts sending D01s. 
+         * This is non-standard, but expected by Eagle, at least. The standard says that
+         * interpolation mode is undefined at the start of the file but Eagle does not appear to
+         * send a G01 at any point before it starts sending D01s.
          */
         interpolationMode = InterpolationMode.Linear;
         stopped = false;
@@ -891,35 +898,35 @@ private void reset() {
         coordinateFormatDecimalLength = -1;
         coordinateFormatTrailingZeroOmission = false;
         coordinateFormatIncremental = false;
-        apertures = new HashMap<>();        
+        apertures = new HashMap<>();
         lineNumber = 1;
         pads = new ArrayList<>();
         regionStarted = false;
         apertureUseCounts = new HashMap<>();
-        
+
         parseStatistics = new ParseStatistics();
     }
-    
+
     private void warn(String s) {
         logger.warn("WARNING: " + lineNumber + ": " + s);
     }
-    
+
     private void warn(String fmt, Object o1) {
         logger.warn("WARNING: " + lineNumber + ": " + fmt, o1);
     }
-    
+
     private void warn(String fmt, Object o1, Object o2) {
         logger.warn("WARNING: " + lineNumber + ": " + fmt, o1, o2);
     }
-    
+
     private void warn(String fmt, Object[] o) {
         logger.warn("WARNING: " + lineNumber + ": " + fmt, o);
     }
-    
+
     private void error(String s) throws Exception {
         throw new Exception("ERROR: " + lineNumber + ": " + s);
     }
-    
+
     public static void main(String[] args) throws Exception {
         HashMap<File, ParseStatistics> results = new HashMap<>();
         File[] files = new File("/Users/jason/Desktop/paste_tests").listFiles();
@@ -939,7 +946,7 @@ public static void main(String[] args) throws Exception {
             }
             results.put(file, parser.parseStatistics);
         }
-        
+
         ParseStatistics total = new ParseStatistics();
         logger.info("");
         logger.info("");
@@ -955,7 +962,7 @@ public int compare(File o1, File o2) {
             total.add(stats);;
             logger.info(String.format("%-32s: %s", file.getName(), stats.toString()));
         }
-        String totalLine = String.format("%-32s: %s", "TOTALS", total.toString()); 
+        String totalLine = String.format("%-32s: %s", "TOTALS", total.toString());
         StringBuffer sb = new StringBuffer();
         for (int i = 0; i < totalLine.length(); i++) {
             sb.append("-");
@@ -963,85 +970,82 @@ public int compare(File o1, File o2) {
         logger.info(sb.toString());
         logger.info(totalLine);
     }
-    
+
     static abstract class Aperture {
         final protected int index;
-        
+
         public Aperture(int index) {
             this.index = index;
         }
-        
+
         public int getIndex() {
             return index;
         }
-        
+
         public abstract BoardPad createPad(LengthUnit unit, Point2D.Double coordinate);
     }
-    
+
     static abstract class StandardAperture extends Aperture {
         public StandardAperture(int index) {
             super(index);
         }
     }
-    
+
     static class RectangleAperture extends StandardAperture {
         public double width;
         public double height;
         public Double holeDiameter;
-        
+
         public RectangleAperture(int index, double width, double height, Double holeDiameter) {
             super(index);
             this.width = width;
             this.height = height;
             this.holeDiameter = holeDiameter;
         }
-        
+
         public BoardPad createPad(LengthUnit unit, Point2D.Double coordinate) {
             Pad.RoundRectangle pad = new Pad.RoundRectangle();
             pad.setUnits(unit);
             pad.setWidth(width);
             pad.setHeight(height);
             pad.setRoundness(0);
-            BoardPad boardPad = new BoardPad(
-                    pad,
-                    new Location(unit, coordinate.x, coordinate.y, 0, 0));
+            BoardPad boardPad =
+                    new BoardPad(pad, new Location(unit, coordinate.x, coordinate.y, 0, 0));
             return boardPad;
         }
 
         @Override
         public String toString() {
-            return "RectangleAperture [width=" + width + ", height=" + height
-                    + ", holeDiameter=" + holeDiameter + "]";
+            return "RectangleAperture [width=" + width + ", height=" + height + ", holeDiameter="
+                    + holeDiameter + "]";
         }
     }
-    
+
     static class CircleAperture extends StandardAperture {
         public double diameter;
         public Double holeDiameter;
-        
+
         public CircleAperture(int index, double diameter, Double holeDiameter) {
             super(index);
             this.diameter = diameter;
             this.holeDiameter = holeDiameter;
         }
-        
+
         public BoardPad createPad(LengthUnit unit, Point2D.Double coordinate) {
             Pad.Circle pad = new Pad.Circle();
             pad.setRadius(diameter / 2);
             pad.setUnits(unit);
-            BoardPad boardPad = new BoardPad(
-                    pad,
-                    new Location(unit, coordinate.x, coordinate.y, 0, 0));
+            BoardPad boardPad =
+                    new BoardPad(pad, new Location(unit, coordinate.x, coordinate.y, 0, 0));
             return boardPad;
         }
 
         @Override
         public String toString() {
-            return "CircleAperture [diameter=" + diameter + ", holeDiameter="
-                    + holeDiameter + "]";
+            return "CircleAperture [diameter=" + diameter + ", holeDiameter=" + holeDiameter + "]";
         }
     }
-    
+
     static class ObroundAperture extends RectangleAperture {
         public ObroundAperture(int index, double width, double height, Double holeDiameter) {
             super(index, width, height, holeDiameter);
@@ -1049,16 +1053,17 @@ public ObroundAperture(int index, double width, double height, Double holeDiamet
 
         @Override
         public String toString() {
-            return "ObroundAperture [width=" + width + ", height=" + height
-                    + ", holeDiameter=" + holeDiameter + "]";
+            return "ObroundAperture [width=" + width + ", height=" + height + ", holeDiameter="
+                    + holeDiameter + "]";
         }
     }
-    
+
     static class PolygonAperture extends CircleAperture {
         public int numberOfVertices;
         public Double rotation;
-        
-        public PolygonAperture(int index, double diameter, int numberOfVertices, Double rotation, Double holeDiameter) {
+
+        public PolygonAperture(int index, double diameter, int numberOfVertices, Double rotation,
+                Double holeDiameter) {
             super(index, diameter, holeDiameter);
             this.numberOfVertices = numberOfVertices;
             this.rotation = rotation;
@@ -1066,104 +1071,89 @@ public PolygonAperture(int index, double diameter, int numberOfVertices, Double
 
         @Override
         public String toString() {
-            return "PolygonAperture [numberOfVertices=" + numberOfVertices
-                    + ", rotation=" + rotation + ", diameter=" + diameter
-                    + ", holeDiameter=" + holeDiameter + "]";
+            return "PolygonAperture [numberOfVertices=" + numberOfVertices + ", rotation="
+                    + rotation + ", diameter=" + diameter + ", holeDiameter=" + holeDiameter + "]";
         }
     }
-    
+
     static class MacroAperture extends Aperture {
         public MacroAperture(int index) {
             super(index);
         }
-        
+
         @Override
         public BoardPad createPad(LengthUnit unit, java.awt.geom.Point2D.Double coordinate) {
             return null;
         }
     }
-    
+
     static class ParseStatistics {
         public int lineCount;
         public int linePerformedCount;
-        
+
         public int arcCount;
         public int arcPerformedCount;
-        
+
         public int regionLineCount;
         public int regionLinePerformedCount;
-        
+
         public int regionArcCount;
         public int regionArcPerformedCount;
-        
+
         public int regionCount;
         public int regionPerformedCount;
-        
+
         public int flashCount;
         public int flashPerformedCount;
-        
+
         public int padCount;
-        
+
         public boolean errored;
-        
+
         public double percent(double count, double total) {
             if (total == 0) {
                 return 100;
             }
             return (count / total) * 100;
         }
-        
+
         public void add(ParseStatistics p) {
             lineCount += p.lineCount;
             linePerformedCount += p.linePerformedCount;
-            
+
             arcCount += p.arcCount;
             arcPerformedCount += p.arcPerformedCount;
-            
+
             regionLineCount += p.regionLineCount;
             regionLinePerformedCount += p.regionLinePerformedCount;
-            
+
             regionArcCount += p.regionArcCount;
             regionArcPerformedCount += p.regionArcPerformedCount;
-            
+
             regionCount += p.regionCount;
             regionPerformedCount += p.regionPerformedCount;
-            
+
             flashCount += p.flashCount;
             flashPerformedCount += p.flashPerformedCount;
-            
+
             padCount += p.padCount;
         }
 
         @Override
         public String toString() {
             int total = flashCount + regionCount + lineCount + arcCount;
-            int totalPerformed = flashPerformedCount + regionPerformedCount + linePerformedCount + arcPerformedCount;
-            return String.format("%s Total %3.0f%% (%4d/%4d), Flash %3.0f%% (%4d/%4d), Line %3.0f%% (%4d/%4d), Arc %3.0f%% (%4d/%4d), Region %3.0f%% (%4d/%4d), Region line %3.0f%% (%4d/%4d), Region Arc %3.0f%% (%4d/%4d), Pads %4d",
-                    errored ? "FAIL" : "PASS",
-                    percent(totalPerformed, total),
-                    totalPerformed,
-                    total,
-                    percent(flashPerformedCount, flashCount),
-                    flashPerformedCount,
-                    flashCount,
-                    percent(linePerformedCount, lineCount),
-                    linePerformedCount,
-                    lineCount,
-                    percent(arcPerformedCount, arcCount),
-                    arcPerformedCount,
-                    arcCount,
-                    percent(regionPerformedCount, regionCount),
-                    regionPerformedCount,
-                    regionCount,
-                    percent(regionLinePerformedCount, regionLineCount),
-                    regionLinePerformedCount,
-                    regionLineCount,
-                    percent(regionArcPerformedCount, regionArcCount),
-                    regionArcPerformedCount,
-                    regionArcCount,
-                    padCount
-                    );
+            int totalPerformed = flashPerformedCount + regionPerformedCount + linePerformedCount
+                    + arcPerformedCount;
+            return String.format(
+                    "%s Total %3.0f%% (%4d/%4d), Flash %3.0f%% (%4d/%4d), Line %3.0f%% (%4d/%4d), Arc %3.0f%% (%4d/%4d), Region %3.0f%% (%4d/%4d), Region line %3.0f%% (%4d/%4d), Region Arc %3.0f%% (%4d/%4d), Pads %4d",
+                    errored ? "FAIL" : "PASS", percent(totalPerformed, total), totalPerformed,
+                    total, percent(flashPerformedCount, flashCount), flashPerformedCount,
+                    flashCount, percent(linePerformedCount, lineCount), linePerformedCount,
+                    lineCount, percent(arcPerformedCount, arcCount), arcPerformedCount, arcCount,
+                    percent(regionPerformedCount, regionCount), regionPerformedCount, regionCount,
+                    percent(regionLinePerformedCount, regionLineCount), regionLinePerformedCount,
+                    regionLineCount, percent(regionArcPerformedCount, regionArcCount),
+                    regionArcPerformedCount, regionArcCount, padCount);
         }
     }
 }
diff --git a/src/main/java/org/openpnp/gui/processes/TwoPlacementBoardLocationProcess.java b/src/main/java/org/openpnp/gui/processes/TwoPlacementBoardLocationProcess.java
index df996d3735..c69943b282 100755
--- a/src/main/java/org/openpnp/gui/processes/TwoPlacementBoardLocationProcess.java
+++ b/src/main/java/org/openpnp/gui/processes/TwoPlacementBoardLocationProcess.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.processes;
 
@@ -27,7 +25,6 @@
 import org.openpnp.gui.JobPanel;
 import org.openpnp.gui.MainFrame;
 import org.openpnp.gui.support.MessageBoxes;
-import org.openpnp.model.Board.Side;
 import org.openpnp.model.BoardLocation;
 import org.openpnp.model.Location;
 import org.openpnp.model.Placement;
@@ -39,78 +36,68 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Guides the user through the two point board location operation using
- * step by step instructions.
+ * Guides the user through the two point board location operation using step by step instructions.
  * 
  * TODO: Disable the BoardLocation table while active.
  */
 public class TwoPlacementBoardLocationProcess {
-	private static final Logger logger = LoggerFactory.getLogger(TwoPlacementBoardLocationProcess.class);
-	
-	private final MainFrame mainFrame;
-	private final JobPanel jobPanel;
-	private final Camera camera;
-	
-	private int step = -1;
-	private String[] instructions = new String[] {
-        "<html><body>Select an easily identifiable placement from the table below. It should be near the left edge of the board. Click Next to continue.</body></html>",          
-		"<html><body>Now, line up the camera's crosshairs with the center of the selected placement. Click Next to continue.</body></html>",			
-        "<html><body>Next, select a second placement from the table below. It should be near the right edge of the board. Click Next to continue.</body></html>",
-		"<html><body>Finally, line up the camera's crosshairs with the center of the selected placement. Click Next to continue.</body></html>",			
-		"<html><body>The board's location and rotation has been set. Click Finish to position the camera at the board's origin, or Cancel to quit.</body></html>",
-	};
-	
-	private Placement placementA, placementB;
-	private Location actualLocationA, actualLocationB;
-	
-	public TwoPlacementBoardLocationProcess(MainFrame mainFrame, JobPanel jobPanel) throws Exception {
-		this.mainFrame = mainFrame;
-		this.jobPanel = jobPanel;
-		this.camera = MainFrame
-				.machineControlsPanel
-				.getSelectedTool()
-				.getHead()
-				.getDefaultCamera();
-		advance();
-	}
-	
-	private void advance() {
-		boolean stepResult = true;
-		if (step == 0) {
-			stepResult = step1();
-		}
-		else if (step == 1) {
-			stepResult = step2();
-		}
-		else if (step == 2) {
-			stepResult = step3();
-		}
-		else if (step == 3) {
-			stepResult = step4();
-		}
-		else if (step == 4) {
-			stepResult = step5();
-		}
-		if (!stepResult) {
-			return;
-		}
-		step++;
-		if (step == 5) {
-			mainFrame.hideInstructions();
-		}
-		else {
-			String title = String.format("Set Board Location (%d / 5)", step + 1);
-			mainFrame.showInstructions(
-				title,
-				instructions[step], 
-				true, 
-				true, 
-				step == 4 ? "Finish" : "Next",
-				cancelActionListener,
-				proceedActionListener);
-		}
-	}
-	
+    private static final Logger logger =
+            LoggerFactory.getLogger(TwoPlacementBoardLocationProcess.class);
+
+    private final MainFrame mainFrame;
+    private final JobPanel jobPanel;
+    private final Camera camera;
+
+    private int step = -1;
+    private String[] instructions = new String[] {
+            "<html><body>Select an easily identifiable placement from the table below. It should be near the left edge of the board. Click Next to continue.</body></html>",
+            "<html><body>Now, line up the camera's crosshairs with the center of the selected placement. Click Next to continue.</body></html>",
+            "<html><body>Next, select a second placement from the table below. It should be near the right edge of the board. Click Next to continue.</body></html>",
+            "<html><body>Finally, line up the camera's crosshairs with the center of the selected placement. Click Next to continue.</body></html>",
+            "<html><body>The board's location and rotation has been set. Click Finish to position the camera at the board's origin, or Cancel to quit.</body></html>",};
+
+    private Placement placementA, placementB;
+    private Location actualLocationA, actualLocationB;
+
+    public TwoPlacementBoardLocationProcess(MainFrame mainFrame, JobPanel jobPanel)
+            throws Exception {
+        this.mainFrame = mainFrame;
+        this.jobPanel = jobPanel;
+        this.camera = MainFrame.machineControlsPanel.getSelectedTool().getHead().getDefaultCamera();
+        advance();
+    }
+
+    private void advance() {
+        boolean stepResult = true;
+        if (step == 0) {
+            stepResult = step1();
+        }
+        else if (step == 1) {
+            stepResult = step2();
+        }
+        else if (step == 2) {
+            stepResult = step3();
+        }
+        else if (step == 3) {
+            stepResult = step4();
+        }
+        else if (step == 4) {
+            stepResult = step5();
+        }
+        if (!stepResult) {
+            return;
+        }
+        step++;
+        if (step == 5) {
+            mainFrame.hideInstructions();
+        }
+        else {
+            String title = String.format("Set Board Location (%d / 5)", step + 1);
+            mainFrame.showInstructions(title, instructions[step], true, true,
+                    step == 4 ? "Finish" : "Next", cancelActionListener, proceedActionListener);
+        }
+    }
+
     private boolean step1() {
         placementA = jobPanel.getJobPlacementsPanel().getSelection();
         if (placementA == null) {
@@ -119,86 +106,81 @@ private boolean step1() {
         }
         return true;
     }
-    
-	private boolean step2() {
-		actualLocationA = camera.getLocation();
-		if (actualLocationA == null) {
-			MessageBoxes.errorBox(mainFrame, "Error", "Please position the camera.");
-			return false;
-		}
-		return true;
-	}
-	
-	private boolean step3() {
+
+    private boolean step2() {
+        actualLocationA = camera.getLocation();
+        if (actualLocationA == null) {
+            MessageBoxes.errorBox(mainFrame, "Error", "Please position the camera.");
+            return false;
+        }
+        return true;
+    }
+
+    private boolean step3() {
         placementB = jobPanel.getJobPlacementsPanel().getSelection();
         if (placementB == null || placementB == placementA) {
             MessageBoxes.errorBox(mainFrame, "Error", "Please select a second placement.");
             return false;
         }
-        
+
         if (placementA.getSide() != placementB.getSide()) {
-            MessageBoxes.errorBox(mainFrame, "Error", "Both placements must be on the same side of the board.");
+            MessageBoxes.errorBox(mainFrame, "Error",
+                    "Both placements must be on the same side of the board.");
             return false;
         }
-		return true;
-	}
-	
-	private boolean step4() {
+        return true;
+    }
+
+    private boolean step4() {
         actualLocationB = camera.getLocation();
         if (actualLocationB == null) {
             MessageBoxes.errorBox(mainFrame, "Error", "Please position the camera.");
             return false;
         }
-        
+
         // Calculate the angle and offset from the results
         BoardLocation boardLocation = jobPanel.getSelectedBoardLocation();
-        Location idealLocationA = Utils2D.calculateBoardPlacementLocation(boardLocation, placementA.getLocation());
-        Location idealLocationB = Utils2D.calculateBoardPlacementLocation(boardLocation, placementB.getLocation());
-        Location location = Utils2D.calculateAngleAndOffset2(
-                idealLocationA, 
-                idealLocationB, 
-                actualLocationA,
-                actualLocationB);
-        
+        Location idealLocationA =
+                Utils2D.calculateBoardPlacementLocation(boardLocation, placementA.getLocation());
+        Location idealLocationB =
+                Utils2D.calculateBoardPlacementLocation(boardLocation, placementB.getLocation());
+        Location location = Utils2D.calculateAngleAndOffset2(idealLocationA, idealLocationB,
+                actualLocationA, actualLocationB);
+
         location = boardLocation.getLocation().addWithRotation(location);
-        location = location.derive(
-                null, 
-                null, 
-                boardLocation.getLocation().convertToUnits(location.getUnits()).getZ(), 
-                null);
-        
-		jobPanel.getSelectedBoardLocation().setLocation(location);
-		jobPanel.refreshSelectedBoardRow();
-		
-		return true;
-	}
-	
-	private boolean step5() {
-		UiUtils.submitUiMachineTask(() -> {
-			Location location = jobPanel
-					.getSelectedBoardLocation()
-					.getLocation();
-			MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
-		});
-		
-		return true;
-	}
-	
-	private void cancel() {
-		mainFrame.hideInstructions();
-	}
-	
-	private final ActionListener proceedActionListener = new ActionListener() {
-		@Override
-		public void actionPerformed(ActionEvent e) {
-			advance();
-		}
-	};
-	
-	private final ActionListener cancelActionListener = new ActionListener() {
-		@Override
-		public void actionPerformed(ActionEvent e) {
-			cancel();
-		}
-	};
+        location = location.derive(null, null,
+                boardLocation.getLocation().convertToUnits(location.getUnits()).getZ(), null);
+
+        jobPanel.getSelectedBoardLocation().setLocation(location);
+        jobPanel.refreshSelectedBoardRow();
+
+        return true;
+    }
+
+    private boolean step5() {
+        UiUtils.submitUiMachineTask(() -> {
+            Location location = jobPanel.getSelectedBoardLocation().getLocation();
+            MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
+        });
+
+        return true;
+    }
+
+    private void cancel() {
+        mainFrame.hideInstructions();
+    }
+
+    private final ActionListener proceedActionListener = new ActionListener() {
+        @Override
+        public void actionPerformed(ActionEvent e) {
+            advance();
+        }
+    };
+
+    private final ActionListener cancelActionListener = new ActionListener() {
+        @Override
+        public void actionPerformed(ActionEvent e) {
+            cancel();
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/support/AbstractConfigurationWizard.java b/src/main/java/org/openpnp/gui/support/AbstractConfigurationWizard.java
index a399a99743..898249dd0c 100755
--- a/src/main/java/org/openpnp/gui/support/AbstractConfigurationWizard.java
+++ b/src/main/java/org/openpnp/gui/support/AbstractConfigurationWizard.java
@@ -1,23 +1,21 @@
 /*
-	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-	
-	This file is part of OpenPnP.
-	
-OpenPnP is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-OpenPnP is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-	
-	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -46,155 +44,153 @@
 import org.slf4j.LoggerFactory;
 
 public abstract class AbstractConfigurationWizard extends JPanel implements Wizard {
-	protected final Logger logger = LoggerFactory.getLogger(getClass());
-	protected WizardContainer wizardContainer;
-	private JButton btnApply;
-	private JButton btnReset;
-	protected JPanel contentPanel;
-	private JScrollPane scrollPane;
-	
-	private List<WrappedBinding> wrappedBindings = new ArrayList<>();
-	private ApplyResetBindingListener listener;
-	
-	public AbstractConfigurationWizard() {
-		setLayout(new BorderLayout());
-
-		contentPanel = new JPanel();
-		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
-
-		scrollPane = new JScrollPane(contentPanel);
-		
-		scrollPane.setBorder(null);
-		add(scrollPane, BorderLayout.CENTER);
-
-		JPanel panelActions = new JPanel();
-		panelActions.setLayout(new FlowLayout(FlowLayout.RIGHT));
-		add(panelActions, BorderLayout.SOUTH);
-
-		btnReset = new JButton(resetAction);
-		panelActions.add(btnReset);
-		
-		btnApply = new JButton(applyAction);
-		panelActions.add(btnApply);
-	}
-	
-	public abstract void createBindings();
-	
-	public void validateInput() throws Exception {
-		
-	}
-	
-	/**
-	 * This method should be called when the caller wishes to notify the user
-	 * that there has been a change to the state of the wizard. This is done
-	 * automatically for wrapped bindings but this method is provided for
-	 * operations that do not use wrapped bindings.
-	 */
-	protected void notifyChange() {
-	    applyAction.setEnabled(true);
-	    resetAction.setEnabled(true);
-	}
-	
-	/**
-	 * When overriding this method you should call super.loadFromModel()
-	 * AFTER doing any work that you need to do, not before.
-	 */
-	protected void loadFromModel() {
-		for (WrappedBinding wrappedBinding : wrappedBindings) {
-			wrappedBinding.reset();
-		}
-		applyAction.setEnabled(false);
-		resetAction.setEnabled(false);
-	}
+    protected final Logger logger = LoggerFactory.getLogger(getClass());
+    protected WizardContainer wizardContainer;
+    private JButton btnApply;
+    private JButton btnReset;
+    protected JPanel contentPanel;
+    private JScrollPane scrollPane;
+
+    private List<WrappedBinding> wrappedBindings = new ArrayList<>();
+    private ApplyResetBindingListener listener;
+
+    public AbstractConfigurationWizard() {
+        setLayout(new BorderLayout());
+
+        contentPanel = new JPanel();
+        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
+
+        scrollPane = new JScrollPane(contentPanel);
+
+        scrollPane.setBorder(null);
+        add(scrollPane, BorderLayout.CENTER);
+
+        JPanel panelActions = new JPanel();
+        panelActions.setLayout(new FlowLayout(FlowLayout.RIGHT));
+        add(panelActions, BorderLayout.SOUTH);
+
+        btnReset = new JButton(resetAction);
+        panelActions.add(btnReset);
+
+        btnApply = new JButton(applyAction);
+        panelActions.add(btnApply);
+    }
+
+    public abstract void createBindings();
+
+    public void validateInput() throws Exception {
+
+    }
+
+    /**
+     * This method should be called when the caller wishes to notify the user that there has been a
+     * change to the state of the wizard. This is done automatically for wrapped bindings but this
+     * method is provided for operations that do not use wrapped bindings.
+     */
+    protected void notifyChange() {
+        applyAction.setEnabled(true);
+        resetAction.setEnabled(true);
+    }
 
     /**
-     * When overriding this method you should call super.loadFromModel()
-     * AFTER doing any work that you need to do, not before.
+     * When overriding this method you should call super.loadFromModel() AFTER doing any work that
+     * you need to do, not before.
      */
-	protected void saveToModel() {
-		try {
-			validateInput();
-		}
-		catch (Exception e) {
-			MessageBoxes.errorBox(getTopLevelAncestor(), "Validation Error", e.getMessage());
-		}
-		for (WrappedBinding wrappedBinding : wrappedBindings) {
-			wrappedBinding.save();
-		}
-		applyAction.setEnabled(false);
-		resetAction.setEnabled(false);
-	}
-	
-	public WrappedBinding addWrappedBinding(Object source, String sourceProperty, JComponent component, String componentProperty, Converter converter) {
-		return addWrappedBinding(JBindings.bind(source, sourceProperty, component, componentProperty, converter));
-	}
-	
-	public WrappedBinding addWrappedBinding(Object source, String sourceProperty, JComponent component, String componentProperty) {
-		return addWrappedBinding(JBindings.bind(source, sourceProperty, component, componentProperty));
-	}
-	
-	public AutoBinding bind(UpdateStrategy updateStrategy, Object source, String sourceProperty, Object target, String targetProperty) {
-		AutoBinding binding = Bindings.createAutoBinding(
-				updateStrategy, 
-				source, 
-				BeanProperty.create(sourceProperty), 
-				target, 
-				BeanProperty.create(targetProperty));
-		binding.bind();
-		return binding;
-	}
-	
-	public AutoBinding bind(UpdateStrategy updateStrategy, Object source, String sourceProperty, Object target, String targetProperty, Converter converter) {
-		AutoBinding binding = Bindings.createAutoBinding(
-				updateStrategy, 
-				source, 
-				BeanProperty.create(sourceProperty), 
-				target, 
-				BeanProperty.create(targetProperty));
-		if (converter != null) {
-			binding.setConverter(converter);
-		}
-		binding.bind();
-		return binding;
-	}
-	
-	public WrappedBinding addWrappedBinding(WrappedBinding binding) {
-		binding.addBindingListener(listener);
-		wrappedBindings.add(binding);
-		return binding;
-	}
-	
-	@Override
-	public void setWizardContainer(WizardContainer wizardContainer) {
-		this.wizardContainer = wizardContainer;
-		scrollPane.getVerticalScrollBar().setUnitIncrement(Configuration.get().getVerticalScrollUnitIncrement());
-		listener = new ApplyResetBindingListener(applyAction, resetAction);
-		createBindings();
-		loadFromModel();
-	}
-
-	@Override
-	public JPanel getWizardPanel() {
-		return this;
-	}
-
-	@Override
-	public String getWizardName() {
-		return null;
-	}
-	
-	protected Action applyAction = new AbstractAction("Apply") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			saveToModel();
-			wizardContainer.wizardCompleted(AbstractConfigurationWizard.this);
-		}
-	};
-
-	protected Action resetAction = new AbstractAction("Reset") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			loadFromModel();
-		}
-	};
+    protected void loadFromModel() {
+        for (WrappedBinding wrappedBinding : wrappedBindings) {
+            wrappedBinding.reset();
+        }
+        applyAction.setEnabled(false);
+        resetAction.setEnabled(false);
+    }
+
+    /**
+     * When overriding this method you should call super.loadFromModel() AFTER doing any work that
+     * you need to do, not before.
+     */
+    protected void saveToModel() {
+        try {
+            validateInput();
+        }
+        catch (Exception e) {
+            MessageBoxes.errorBox(getTopLevelAncestor(), "Validation Error", e.getMessage());
+        }
+        for (WrappedBinding wrappedBinding : wrappedBindings) {
+            wrappedBinding.save();
+        }
+        applyAction.setEnabled(false);
+        resetAction.setEnabled(false);
+    }
+
+    public WrappedBinding addWrappedBinding(Object source, String sourceProperty,
+            JComponent component, String componentProperty, Converter converter) {
+        return addWrappedBinding(
+                JBindings.bind(source, sourceProperty, component, componentProperty, converter));
+    }
+
+    public WrappedBinding addWrappedBinding(Object source, String sourceProperty,
+            JComponent component, String componentProperty) {
+        return addWrappedBinding(
+                JBindings.bind(source, sourceProperty, component, componentProperty));
+    }
+
+    public AutoBinding bind(UpdateStrategy updateStrategy, Object source, String sourceProperty,
+            Object target, String targetProperty) {
+        AutoBinding binding = Bindings.createAutoBinding(updateStrategy, source,
+                BeanProperty.create(sourceProperty), target, BeanProperty.create(targetProperty));
+        binding.bind();
+        return binding;
+    }
+
+    public AutoBinding bind(UpdateStrategy updateStrategy, Object source, String sourceProperty,
+            Object target, String targetProperty, Converter converter) {
+        AutoBinding binding = Bindings.createAutoBinding(updateStrategy, source,
+                BeanProperty.create(sourceProperty), target, BeanProperty.create(targetProperty));
+        if (converter != null) {
+            binding.setConverter(converter);
+        }
+        binding.bind();
+        return binding;
+    }
+
+    public WrappedBinding addWrappedBinding(WrappedBinding binding) {
+        binding.addBindingListener(listener);
+        wrappedBindings.add(binding);
+        return binding;
+    }
+
+    @Override
+    public void setWizardContainer(WizardContainer wizardContainer) {
+        this.wizardContainer = wizardContainer;
+        scrollPane.getVerticalScrollBar()
+                .setUnitIncrement(Configuration.get().getVerticalScrollUnitIncrement());
+        listener = new ApplyResetBindingListener(applyAction, resetAction);
+        createBindings();
+        loadFromModel();
+    }
+
+    @Override
+    public JPanel getWizardPanel() {
+        return this;
+    }
+
+    @Override
+    public String getWizardName() {
+        return null;
+    }
+
+    protected Action applyAction = new AbstractAction("Apply") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            saveToModel();
+            wizardContainer.wizardCompleted(AbstractConfigurationWizard.this);
+        }
+    };
+
+    protected Action resetAction = new AbstractAction("Reset") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            loadFromModel();
+        }
+    };
 }
diff --git a/src/main/java/org/openpnp/gui/support/ActionGroup.java b/src/main/java/org/openpnp/gui/support/ActionGroup.java
index e417ef52cb..7a982f3ff6 100755
--- a/src/main/java/org/openpnp/gui/support/ActionGroup.java
+++ b/src/main/java/org/openpnp/gui/support/ActionGroup.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -27,25 +25,25 @@
 import javax.swing.Action;
 
 public class ActionGroup {
-	private Set<Action> actions = new HashSet<>();
-	
-	public ActionGroup(Action... actions) {
-		for (Action action : actions) {
-			this.actions.add(action);
-		}
-	}
-	
-	public void addAction(Action action) {
-		actions.add(action);
-	}
-	
-	public void removeAction(Action action) {
-		actions.remove(action);
-	}
-	
-	public void setEnabled(boolean enabled) {
-		for (Action action : actions) {
-			action.setEnabled(enabled);
-		}
-	}
+    private Set<Action> actions = new HashSet<>();
+
+    public ActionGroup(Action... actions) {
+        for (Action action : actions) {
+            this.actions.add(action);
+        }
+    }
+
+    public void addAction(Action action) {
+        actions.add(action);
+    }
+
+    public void removeAction(Action action) {
+        actions.remove(action);
+    }
+
+    public void setEnabled(boolean enabled) {
+        for (Action action : actions) {
+            action.setEnabled(enabled);
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/ActuatorItem.java b/src/main/java/org/openpnp/gui/support/ActuatorItem.java
index 6f49487225..01b22c3b08 100755
--- a/src/main/java/org/openpnp/gui/support/ActuatorItem.java
+++ b/src/main/java/org/openpnp/gui/support/ActuatorItem.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -24,18 +22,18 @@
 import org.openpnp.spi.Actuator;
 
 public class ActuatorItem {
-	private Actuator actuator;
-	
-	public ActuatorItem(Actuator actuator) {
-		this.actuator = actuator;
-	}
-	
-	public Actuator getActuator() {
-		return actuator;
-	}
-	
-	@Override
-	public String toString() {
-		return "Actuator: " + actuator.getName();
-	}
-}
\ No newline at end of file
+    private Actuator actuator;
+
+    public ActuatorItem(Actuator actuator) {
+        this.actuator = actuator;
+    }
+
+    public Actuator getActuator() {
+        return actuator;
+    }
+
+    @Override
+    public String toString() {
+        return "Actuator: " + actuator.getName();
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/support/ApplyResetBindingListener.java b/src/main/java/org/openpnp/gui/support/ApplyResetBindingListener.java
index cf0e1242aa..9ca775a5c2 100755
--- a/src/main/java/org/openpnp/gui/support/ApplyResetBindingListener.java
+++ b/src/main/java/org/openpnp/gui/support/ApplyResetBindingListener.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -28,22 +26,22 @@
 import org.jdesktop.beansbinding.Binding.SyncFailure;
 
 public class ApplyResetBindingListener extends AbstractBindingListener {
-	private final Action saveAction;
-	private final Action resetAction;
-	
-	public ApplyResetBindingListener(Action saveAction, Action resetAction) {
-		this.saveAction = saveAction;
-		this.resetAction = resetAction;
-	}
-	
-	@Override
-	public void syncFailed(Binding binding, SyncFailure failure) {
-		saveAction.setEnabled(false);
-	}
+    private final Action saveAction;
+    private final Action resetAction;
+
+    public ApplyResetBindingListener(Action saveAction, Action resetAction) {
+        this.saveAction = saveAction;
+        this.resetAction = resetAction;
+    }
+
+    @Override
+    public void syncFailed(Binding binding, SyncFailure failure) {
+        saveAction.setEnabled(false);
+    }
 
-	@Override
-	public void synced(Binding binding) {
-		saveAction.setEnabled(true);
-		resetAction.setEnabled(true);
-	}
+    @Override
+    public void synced(Binding binding) {
+        saveAction.setEnabled(true);
+        resetAction.setEnabled(true);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/BoundProperty.java b/src/main/java/org/openpnp/gui/support/BoundProperty.java
index e6f0fffde5..0f4223fd38 100755
--- a/src/main/java/org/openpnp/gui/support/BoundProperty.java
+++ b/src/main/java/org/openpnp/gui/support/BoundProperty.java
@@ -3,23 +3,23 @@
 import org.openpnp.model.AbstractModelObject;
 
 /**
- * A simple value wrapper that provides PropertyChangeListener support. Can
- * be used in place of basic fields.
+ * A simple value wrapper that provides PropertyChangeListener support. Can be used in place of
+ * basic fields.
  */
 public class BoundProperty<T> extends AbstractModelObject {
-	T value;
-	
-	public BoundProperty(T value) {
-		this.value = value;
-	}
-	
-	public T getValue() {
-		return value;
-	}
-	
-	public void setValue(T value) {
-		T oldValue = this.value;
-		this.value = value;
-		firePropertyChange("value", oldValue, value);
-	}
+    T value;
+
+    public BoundProperty(T value) {
+        this.value = value;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    public void setValue(T value) {
+        T oldValue = this.value;
+        this.value = value;
+        firePropertyChange("value", oldValue, value);
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/BufferedImageIconConverter.java b/src/main/java/org/openpnp/gui/support/BufferedImageIconConverter.java
index 6f769b0f7c..1db106a4d3 100755
--- a/src/main/java/org/openpnp/gui/support/BufferedImageIconConverter.java
+++ b/src/main/java/org/openpnp/gui/support/BufferedImageIconConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -29,19 +27,19 @@
 import org.jdesktop.beansbinding.Converter;
 
 public class BufferedImageIconConverter extends Converter<BufferedImage, Icon> {
-	@Override
-	public Icon convertForward(BufferedImage arg0) {
-		if (arg0 == null) {
-			return null;
-		}
-		return new ImageIcon(arg0);
-	}
-
-	@Override
-	public BufferedImage convertReverse(Icon arg0) {
-		if (arg0 == null) {
-			return null;
-		}
-		return (BufferedImage) ((ImageIcon) arg0).getImage();
-	}
+    @Override
+    public Icon convertForward(BufferedImage arg0) {
+        if (arg0 == null) {
+            return null;
+        }
+        return new ImageIcon(arg0);
+    }
+
+    @Override
+    public BufferedImage convertReverse(Icon arg0) {
+        if (arg0 == null) {
+            return null;
+        }
+        return (BufferedImage) ((ImageIcon) arg0).getImage();
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/CameraItem.java b/src/main/java/org/openpnp/gui/support/CameraItem.java
index aa29115412..47162a8ba9 100755
--- a/src/main/java/org/openpnp/gui/support/CameraItem.java
+++ b/src/main/java/org/openpnp/gui/support/CameraItem.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -24,18 +22,19 @@
 import org.openpnp.spi.Camera;
 
 public class CameraItem {
-	private Camera camera;
-	
-	public CameraItem(Camera camera) {
-		this.camera = camera;
-	}
-	
-	public Camera getCamera() {
-		return camera;
-	}
-	
-	@Override
-	public String toString() {
-	    return String.format("Camera: %s %s", camera.getName(), camera.getHead() != null ? String.format("(Head: %s)", camera.getHead().getName()) : "");
-	}
-}
\ No newline at end of file
+    private Camera camera;
+
+    public CameraItem(Camera camera) {
+        this.camera = camera;
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("Camera: %s %s", camera.getName(), camera.getHead() != null
+                ? String.format("(Head: %s)", camera.getHead().getName()) : "");
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/support/DoubleConverter.java b/src/main/java/org/openpnp/gui/support/DoubleConverter.java
index 0785644f0b..15e9ec48f3 100755
--- a/src/main/java/org/openpnp/gui/support/DoubleConverter.java
+++ b/src/main/java/org/openpnp/gui/support/DoubleConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,20 +24,20 @@
 import org.jdesktop.beansbinding.Converter;
 
 public class DoubleConverter extends Converter<Double, String> {
-	private String format;
-	
-	public DoubleConverter(String format) {
-		this.format = format;
-	}
-	
-	@Override
-	public String convertForward(Double arg0) {
-		return String.format(Locale.US,format, arg0);
-	}
-
-	@Override
-	public Double convertReverse(String arg0) {
-		return Double.parseDouble(arg0);
-	}
+    private String format;
+
+    public DoubleConverter(String format) {
+        this.format = format;
+    }
+
+    @Override
+    public String convertForward(Double arg0) {
+        return String.format(Locale.US, format, arg0);
+    }
+
+    @Override
+    public Double convertReverse(String arg0) {
+        return Double.parseDouble(arg0);
+    }
 
 }
diff --git a/src/main/java/org/openpnp/gui/support/HeadCellValue.java b/src/main/java/org/openpnp/gui/support/HeadCellValue.java
index 91710b7206..77ae1f72ca 100755
--- a/src/main/java/org/openpnp/gui/support/HeadCellValue.java
+++ b/src/main/java/org/openpnp/gui/support/HeadCellValue.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -25,48 +23,48 @@
 import org.openpnp.spi.Head;
 
 public class HeadCellValue {
-	private static Configuration configuration;
-	private Head head;
+    private static Configuration configuration;
+    private Head head;
 
-	public static void setConfiguration(Configuration configuration) {
-		HeadCellValue.configuration = configuration;
-	}
+    public static void setConfiguration(Configuration configuration) {
+        HeadCellValue.configuration = configuration;
+    }
 
-	public HeadCellValue(Head head) {
-		this.head = head;
-	}
+    public HeadCellValue(Head head) {
+        this.head = head;
+    }
 
-	public HeadCellValue(String value) {
-		Head head = configuration.getMachine().getHead(value);
-		if (head == null) {
-			throw new NullPointerException();
-		}
-		this.head = head;
-	}
+    public HeadCellValue(String value) {
+        Head head = configuration.getMachine().getHead(value);
+        if (head == null) {
+            throw new NullPointerException();
+        }
+        this.head = head;
+    }
 
-	public Head getHead() {
-		return head;
-	}
+    public Head getHead() {
+        return head;
+    }
 
-	public void setHead(Head head) {
-		this.head = head;
-	}
+    public void setHead(Head head) {
+        this.head = head;
+    }
 
-	@Override
-	public String toString() {
-		return head == null ? "NONE" : head.getName();
-	}
+    @Override
+    public String toString() {
+        return head == null ? "NONE" : head.getName();
+    }
 
-	@Override
-	public boolean equals(Object obj) {
-		if (! (obj instanceof HeadCellValue)) {
-			return false;
-		}
-		return ((HeadCellValue) obj).head == this.head;
-	}
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof HeadCellValue)) {
+            return false;
+        }
+        return ((HeadCellValue) obj).head == this.head;
+    }
 
-	@Override
-	public int hashCode() {
-		return this.head != null ? this.head.hashCode() : 0;
-	}
+    @Override
+    public int hashCode() {
+        return this.head != null ? this.head.hashCode() : 0;
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/Helpers.java b/src/main/java/org/openpnp/gui/support/Helpers.java
index 632ab0b414..d1aea58b0e 100755
--- a/src/main/java/org/openpnp/gui/support/Helpers.java
+++ b/src/main/java/org/openpnp/gui/support/Helpers.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -33,61 +31,68 @@
 import org.openpnp.model.Location;
 
 public class Helpers {
-	public static void copyLocationIntoTextFields(Location l, JTextField x, JTextField y, JTextField z) {
-		copyLocationIntoTextFields(l, x, y, z, null);
-	}
-	
-	public static void copyLocationIntoTextFields(Location l, JTextField x, JTextField y, JTextField z, JTextField rotation) {
-		if (x != null) {
-			x.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), l.getLengthX().getValue()));
-		}
-		if (y != null) {
-			y.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), l.getLengthY().getValue()));
-		}
-		if (z != null) {
-			z.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), l.getLengthZ().getValue()));
-		}
-		if (rotation != null) {
-			rotation.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), l.getRotation()));
-		}
-	}
-	
-	/**
-	 * Select the last row in a table. Handy for selecting a row that was
-	 * just added.
-	 * @param table
-	 */
-	public static void selectLastTableRow(JTable table) {
-		table.clearSelection();
-		int index = table.getRowCount() - 1;
-		index = table.convertRowIndexToView(index);
-		table.addRowSelectionInterval(index, index);
-	}
-	
-	/**
-	 * Create a unique name consisting of the prefix and an integer. The name
-	 * is guaranteed to be unique within the properties of the given Collection
-	 * using the given propertyName.
-	 * @param prefix
-	 * @param existingObjects Objects against which to compare the property
-	 * identified by propertyName against for the unique name.
-	 * @param propertyName The name of a String property.
-	 */
-	public static String createUniqueName(String prefix, Collection existingObjects, String propertyName) {
-		HashSet<String> names = new HashSet<>();
-		BeanProperty<Object, String> property = BeanProperty.create(propertyName);
-		for (Object o : existingObjects) {
-			if (o != null) {
-				names.add(property.getValue(o));
-			}
-		}
-		for (int i = 1; i < Integer.MAX_VALUE; i++) {
-			String name = prefix + i;
-			if (!names.contains(name)) {
-				return name;
-			}
-		}
-		
-		return null;
-	}
+    public static void copyLocationIntoTextFields(Location l, JTextField x, JTextField y,
+            JTextField z) {
+        copyLocationIntoTextFields(l, x, y, z, null);
+    }
+
+    public static void copyLocationIntoTextFields(Location l, JTextField x, JTextField y,
+            JTextField z, JTextField rotation) {
+        if (x != null) {
+            x.setText(String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                    l.getLengthX().getValue()));
+        }
+        if (y != null) {
+            y.setText(String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                    l.getLengthY().getValue()));
+        }
+        if (z != null) {
+            z.setText(String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                    l.getLengthZ().getValue()));
+        }
+        if (rotation != null) {
+            rotation.setText(String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                    l.getRotation()));
+        }
+    }
+
+    /**
+     * Select the last row in a table. Handy for selecting a row that was just added.
+     * 
+     * @param table
+     */
+    public static void selectLastTableRow(JTable table) {
+        table.clearSelection();
+        int index = table.getRowCount() - 1;
+        index = table.convertRowIndexToView(index);
+        table.addRowSelectionInterval(index, index);
+    }
+
+    /**
+     * Create a unique name consisting of the prefix and an integer. The name is guaranteed to be
+     * unique within the properties of the given Collection using the given propertyName.
+     * 
+     * @param prefix
+     * @param existingObjects Objects against which to compare the property identified by
+     *        propertyName against for the unique name.
+     * @param propertyName The name of a String property.
+     */
+    public static String createUniqueName(String prefix, Collection existingObjects,
+            String propertyName) {
+        HashSet<String> names = new HashSet<>();
+        BeanProperty<Object, String> property = BeanProperty.create(propertyName);
+        for (Object o : existingObjects) {
+            if (o != null) {
+                names.add(property.getValue(o));
+            }
+        }
+        for (int i = 1; i < Integer.MAX_VALUE; i++) {
+            String name = prefix + i;
+            if (!names.contains(name)) {
+                return name;
+            }
+        }
+
+        return null;
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/Icons.java b/src/main/java/org/openpnp/gui/support/Icons.java
index cfd7042d70..afc3a4077e 100755
--- a/src/main/java/org/openpnp/gui/support/Icons.java
+++ b/src/main/java/org/openpnp/gui/support/Icons.java
@@ -9,40 +9,46 @@
     public static Icon neww = getIcon("/icons/file-new.svg");
     public static Icon copy = getIcon("/icons/copy.svg");
     public static Icon paste = getIcon("/icons/paste.svg");
-    
+
     public static Icon captureCamera = getIcon("/icons/capture-camera.svg");
     public static Icon captureTool = getIcon("/icons/capture-nozzle.svg");
     public static Icon capturePin = getIcon("/icons/capture-actuator.svg");
-    
+
     public static Icon centerCamera = getIcon("/icons/position-camera.svg");
     public static Icon centerTool = getIcon("/icons/position-nozzle.svg");
     public static Icon centerToolNoSafeZ = getIcon("/icons/position-nozzle-no-safe-z.svg");
     public static Icon centerPin = getIcon("/icons/position-actuator.svg");
-    
+
     public static Icon start = getIcon("/icons/control-start.svg");
     public static Icon pause = getIcon("/icons/control-pause.svg");
     public static Icon step = getIcon("/icons/control-next.svg");
     public static Icon stop = getIcon("/icons/control-stop.svg");
-    
+
     public static Icon load = getIcon("/icons/nozzletip-load.svg");
     public static Icon unload = getIcon("/icons/nozzletip-unload.svg");
-    
+
     public static Icon twoPointLocate = getIcon("/icons/board-two-placement-locate.svg");
     public static Icon fiducialCheck = getIcon("/icons/board-fiducial-locate.svg");
 
     public static Icon feed = getIcon("/icons/feeder-feed.svg");
     public static Icon showPart = getIcon("/icons/feeder-show-part-outline.svg");
     public static Icon editFeeder = getIcon("/icons/feeder-edit.svg");
-    
+
     public static Icon arrowUp = getIcon("/icons/ic_arrow_upward_black_18px.svg");
     public static Icon arrowDown = getIcon("/icons/ic_arrow_downward_black_18px.svg");
     public static Icon arrowLeft = getIcon("/icons/ic_arrow_back_black_18px.svg");
     public static Icon arrowRight = getIcon("/icons/ic_arrow_forward_black_18px.svg");
     public static Icon home = getIcon("/icons/ic_home_black_18px.svg");
-    public static Icon refresh = getIcon("/icons/ic_home_black_18px.svg");
+    public static Icon refresh = getIcon("/icons/ic_refresh_black_18px.svg");
     public static Icon rotateClockwise = getIcon("/icons/ic_rotate_clockwise_black_18px.svg");
-    public static Icon rotateCounterclockwise = getIcon("/icons/ic_rotate_counterclockwise_black_18px.svg");
+    public static Icon rotateCounterclockwise =
+            getIcon("/icons/ic_rotate_counterclockwise_black_18px.svg");
     public static Icon zero = getIcon("/icons/ic_exposure_zero_black_18px.svg");
+    
+    public static Icon navigateFirst = getIcon("/icons/ic_first_page_black_18px.svg");
+    public static Icon navigateLast = getIcon("/icons/ic_last_page_black_18px.svg");
+    public static Icon navigatePrevious = getIcon("/icons/ic_chevron_left_black_18px.svg");
+    public static Icon navigateNext = getIcon("/icons/ic_chevron_right_black_18px.svg");
 
     public static Icon getIcon(String resourceName, int width, int height) {
         if (resourceName.endsWith(".svg")) {
@@ -52,8 +58,8 @@ public static Icon getIcon(String resourceName, int width, int height) {
             return new ImageIcon(Icons.class.getResource(resourceName));
         }
     }
-    
+
     public static Icon getIcon(String resourceName) {
         return getIcon(resourceName, 24, 24);
-    }    
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/IdentifiableComparator.java b/src/main/java/org/openpnp/gui/support/IdentifiableComparator.java
index a80c5633f6..321d66c62d 100755
--- a/src/main/java/org/openpnp/gui/support/IdentifiableComparator.java
+++ b/src/main/java/org/openpnp/gui/support/IdentifiableComparator.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,15 +24,15 @@
 import org.openpnp.model.Identifiable;
 
 public class IdentifiableComparator<T extends Identifiable> implements Comparator<T> {
-	public int compare(T o1, T o2) {
-		if (o1 == null) {
-			return 1;
-		}
-		else if (o2 == null) {
-			return -1;
-		}
-		else {
-			return o1.getId().compareTo(o2.getId());
-		}
-	}
+    public int compare(T o1, T o2) {
+        if (o1 == null) {
+            return 1;
+        }
+        else if (o2 == null) {
+            return -1;
+        }
+        else {
+            return o1.getId().compareTo(o2.getId());
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/IdentifiableListCellRenderer.java b/src/main/java/org/openpnp/gui/support/IdentifiableListCellRenderer.java
index 395ff4a2af..b07364c819 100755
--- a/src/main/java/org/openpnp/gui/support/IdentifiableListCellRenderer.java
+++ b/src/main/java/org/openpnp/gui/support/IdentifiableListCellRenderer.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -31,14 +29,14 @@
 
 @SuppressWarnings("serial")
 public class IdentifiableListCellRenderer<T extends Identifiable> extends DefaultListCellRenderer {
-	IdentifiableObjectToStringConverter<T> converter = new IdentifiableObjectToStringConverter<>();
-	
-	@Override
-	public Component getListCellRendererComponent(JList arg0, Object arg1,
-			int arg2, boolean arg3, boolean arg4) {
-		Component component = super.getListCellRendererComponent(arg0, arg1, arg2, arg3, arg4);
-		((JLabel) component).setText(converter.getPreferredStringForItem(arg1));
-		return component;
-	}
+    IdentifiableObjectToStringConverter<T> converter = new IdentifiableObjectToStringConverter<>();
+
+    @Override
+    public Component getListCellRendererComponent(JList arg0, Object arg1, int arg2, boolean arg3,
+            boolean arg4) {
+        Component component = super.getListCellRendererComponent(arg0, arg1, arg2, arg3, arg4);
+        ((JLabel) component).setText(converter.getPreferredStringForItem(arg1));
+        return component;
+    }
 
 }
diff --git a/src/main/java/org/openpnp/gui/support/IdentifiableObjectToStringConverter.java b/src/main/java/org/openpnp/gui/support/IdentifiableObjectToStringConverter.java
index e91d5ccd9b..ab727c0df3 100755
--- a/src/main/java/org/openpnp/gui/support/IdentifiableObjectToStringConverter.java
+++ b/src/main/java/org/openpnp/gui/support/IdentifiableObjectToStringConverter.java
@@ -1,35 +1,34 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
 import org.jdesktop.swingx.autocomplete.ObjectToStringConverter;
 import org.openpnp.model.Identifiable;
 
-public class IdentifiableObjectToStringConverter<T extends Identifiable> extends ObjectToStringConverter {
-	public String getPreferredStringForItem(Object o) {
-		if (o == null) {
-			return null;
-		}
-		T t = (T) o;
-		return t.getId() == null ? "" : t.getId();
-	}
+public class IdentifiableObjectToStringConverter<T extends Identifiable>
+        extends ObjectToStringConverter {
+    public String getPreferredStringForItem(Object o) {
+        if (o == null) {
+            return null;
+        }
+        T t = (T) o;
+        return t.getId() == null ? "" : t.getId();
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/IdentifiableTableCellRenderer.java b/src/main/java/org/openpnp/gui/support/IdentifiableTableCellRenderer.java
index ce6440139f..3c5b626074 100755
--- a/src/main/java/org/openpnp/gui/support/IdentifiableTableCellRenderer.java
+++ b/src/main/java/org/openpnp/gui/support/IdentifiableTableCellRenderer.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,11 +24,12 @@
 import org.openpnp.model.Identifiable;
 
 @SuppressWarnings("serial")
-public class IdentifiableTableCellRenderer<T extends Identifiable> extends DefaultTableCellRenderer {
-	IdentifiableObjectToStringConverter<T> converter = new IdentifiableObjectToStringConverter<>();
-	
-	@Override
-	protected void setValue(Object value) {
-		setText(converter.getPreferredStringForItem(value));
-	}
+public class IdentifiableTableCellRenderer<T extends Identifiable>
+        extends DefaultTableCellRenderer {
+    IdentifiableObjectToStringConverter<T> converter = new IdentifiableObjectToStringConverter<>();
+
+    @Override
+    protected void setValue(Object value) {
+        setText(converter.getPreferredStringForItem(value));
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/IntegerConverter.java b/src/main/java/org/openpnp/gui/support/IntegerConverter.java
index b0d7f8c2c2..e6d8409e52 100755
--- a/src/main/java/org/openpnp/gui/support/IntegerConverter.java
+++ b/src/main/java/org/openpnp/gui/support/IntegerConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,24 +24,24 @@
 import org.jdesktop.beansbinding.Converter;
 
 public class IntegerConverter extends Converter<Integer, String> {
-	private String format;
-	
-	public IntegerConverter() {
-		this("%d");
-	}
-	
-	public IntegerConverter(String format) {
-		this.format = format;
-	}
-	
-	@Override
-	public String convertForward(Integer arg0) {
-		return String.format(Locale.US,format, arg0);
-	}
-
-	@Override
-	public Integer convertReverse(String arg0) {
-		return Integer.parseInt(arg0);
-	}
+    private String format;
+
+    public IntegerConverter() {
+        this("%d");
+    }
+
+    public IntegerConverter(String format) {
+        this.format = format;
+    }
+
+    @Override
+    public String convertForward(Integer arg0) {
+        return String.format(Locale.US, format, arg0);
+    }
+
+    @Override
+    public Integer convertReverse(String arg0) {
+        return Integer.parseInt(arg0);
+    }
 
 }
diff --git a/src/main/java/org/openpnp/gui/support/JBindings.java b/src/main/java/org/openpnp/gui/support/JBindings.java
index da1ce6f382..4afa065d77 100755
--- a/src/main/java/org/openpnp/gui/support/JBindings.java
+++ b/src/main/java/org/openpnp/gui/support/JBindings.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -37,146 +35,125 @@
 import org.openpnp.model.AbstractModelObject;
 
 /**
- * Provides convenience bindings for JComponents that add value buffering and
- * visual feedback on conversion failure. Buffered values have a read-write
- * binding with the JComponent and a read binding with the source value. The
- * returned WrappedBinding allows you to save the buffered value to the source
- * or to reset it from the source.
+ * Provides convenience bindings for JComponents that add value buffering and visual feedback on
+ * conversion failure. Buffered values have a read-write binding with the JComponent and a read
+ * binding with the source value. The returned WrappedBinding allows you to save the buffered value
+ * to the source or to reset it from the source.
+ * 
  * @author Jason von Nieda <jason@vonnieda.org>
  */
 public class JBindings {
-	public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(
-			SS source, 
-			String sourcePropertyName, 
-			TS component, 
-			String targetPropertyName) {
-		return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, null, (BindingListener[]) null);
-	}
-	
-	public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(
-			SS source, 
-			String sourcePropertyName, 
-			TS component, 
-			String targetPropertyName, 
-			Converter<SV, TV> converter) {
-		return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, converter, (BindingListener[]) null);
-	}
-
-	public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(
-			SS source, 
-			String sourcePropertyName, 
-			TS component, 
-			String targetPropertyName, 
-			Converter<SV, TV> converter,
-			BindingListener... listeners) {
-		return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, converter, listeners);
-	}
-
-	public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(
-			SS source, 
-			String sourcePropertyName, 
-			TS component, 
-			String targetPropertyName, 
-			BindingListener... listeners) {
-		return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, null, listeners);
-	}
-
-	public static class WrappedBinding<SS, SV, TS extends JComponent, TV> {
-		private SS source;
-		private BeanProperty<SS, SV> sourceProperty;
-		private Wrapper<SV> wrapper;
-		private AutoBinding wrappedBinding;
-		
-		public final void addBindingListener(BindingListener listener) {
-			wrappedBinding.addBindingListener(listener);
-		}
-
-		public WrappedBinding(
-				SS source, 
-				String sourcePropertyName, 
-				TS component, 
-				String targetPropertyName, 
-				Converter<SV, TV> converter,
-				BindingListener... listeners) {
-			this.source = source;
-			this.sourceProperty = BeanProperty.create(sourcePropertyName);
-			this.wrapper = new Wrapper<>(sourceProperty.getValue(source));
-			BeanProperty<Wrapper<SV>, SV> wrapperProperty = BeanProperty.create("value");
-			BeanProperty<TS, TV> targetProperty = BeanProperty.create(targetPropertyName);
-			wrappedBinding = Bindings.createAutoBinding(
-					UpdateStrategy.READ_WRITE, 
-					wrapper,
-					wrapperProperty, 
-					component, 
-					targetProperty);
-			if (converter != null) {
-				wrappedBinding.setConverter(converter);
-			}
-			wrappedBinding.addBindingListener(new JComponentBackgroundUpdater(component));
-			if (listeners != null) {
-				for (BindingListener listener : listeners) {
-					wrappedBinding.addBindingListener(listener);
-				}
-			}
-			wrappedBinding.bind();
-			AutoBinding<SS, SV, Wrapper<SV>, SV> binding = Bindings.createAutoBinding(
-					UpdateStrategy.READ, 
-					source,
-					sourceProperty, 
-					wrapper, 
-					wrapperProperty);
-			binding.bind();
-		}
-		
-		public void save() {
-			sourceProperty.setValue(source, wrapper.getValue());
-		}
-		
-		public void reset() {
-			wrapper.setValue(sourceProperty.getValue(source));
-		}
-		
-		public Wrapper<SV> getWrapper() {
-			return wrapper;
-		}
-	}
-	
-	public static class Wrapper<T> extends AbstractModelObject {
-		private T value;
-		
-		public Wrapper(T value) {
-			this.value = value;
-		}
-		
-		public T getValue() {
-			return value;
-		}
-
-		public void setValue(T value) {
-			T oldValue = this.value;
-			this.value = value;
-			firePropertyChange("value", oldValue, this.value);
-		}
-	}
-	
-	private static class JComponentBackgroundUpdater extends AbstractBindingListener {
-		private static Color errorColor = new Color(0xff, 0xdd, 0xdd);
-		private JComponent component;
-		private Color oldBackground;
-		
-		public JComponentBackgroundUpdater(JComponent component) {
-			this.component = component;
-			oldBackground = component.getBackground();
-		}
-		
-		@Override
-		public void syncFailed(Binding binding, SyncFailure failure) {
-			component.setBackground(errorColor);
-		}
-
-		@Override
-		public void synced(Binding binding) {
-			component.setBackground(oldBackground);
-		}
-	}
+    public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(SS source,
+            String sourcePropertyName, TS component, String targetPropertyName) {
+        return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, null,
+                (BindingListener[]) null);
+    }
+
+    public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(SS source,
+            String sourcePropertyName, TS component, String targetPropertyName,
+            Converter<SV, TV> converter) {
+        return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName,
+                converter, (BindingListener[]) null);
+    }
+
+    public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(SS source,
+            String sourcePropertyName, TS component, String targetPropertyName,
+            Converter<SV, TV> converter, BindingListener... listeners) {
+        return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName,
+                converter, listeners);
+    }
+
+    public static <SS, SV, TS extends JComponent, TV> WrappedBinding<SS, SV, TS, TV> bind(SS source,
+            String sourcePropertyName, TS component, String targetPropertyName,
+            BindingListener... listeners) {
+        return new WrappedBinding<>(source, sourcePropertyName, component, targetPropertyName, null,
+                listeners);
+    }
+
+    public static class WrappedBinding<SS, SV, TS extends JComponent, TV> {
+        private SS source;
+        private BeanProperty<SS, SV> sourceProperty;
+        private Wrapper<SV> wrapper;
+        private AutoBinding wrappedBinding;
+
+        public final void addBindingListener(BindingListener listener) {
+            wrappedBinding.addBindingListener(listener);
+        }
+
+        public WrappedBinding(SS source, String sourcePropertyName, TS component,
+                String targetPropertyName, Converter<SV, TV> converter,
+                BindingListener... listeners) {
+            this.source = source;
+            this.sourceProperty = BeanProperty.create(sourcePropertyName);
+            this.wrapper = new Wrapper<>(sourceProperty.getValue(source));
+            BeanProperty<Wrapper<SV>, SV> wrapperProperty = BeanProperty.create("value");
+            BeanProperty<TS, TV> targetProperty = BeanProperty.create(targetPropertyName);
+            wrappedBinding = Bindings.createAutoBinding(UpdateStrategy.READ_WRITE, wrapper,
+                    wrapperProperty, component, targetProperty);
+            if (converter != null) {
+                wrappedBinding.setConverter(converter);
+            }
+            wrappedBinding.addBindingListener(new JComponentBackgroundUpdater(component));
+            if (listeners != null) {
+                for (BindingListener listener : listeners) {
+                    wrappedBinding.addBindingListener(listener);
+                }
+            }
+            wrappedBinding.bind();
+            AutoBinding<SS, SV, Wrapper<SV>, SV> binding = Bindings.createAutoBinding(
+                    UpdateStrategy.READ, source, sourceProperty, wrapper, wrapperProperty);
+            binding.bind();
+        }
+
+        public void save() {
+            sourceProperty.setValue(source, wrapper.getValue());
+        }
+
+        public void reset() {
+            wrapper.setValue(sourceProperty.getValue(source));
+        }
+
+        public Wrapper<SV> getWrapper() {
+            return wrapper;
+        }
+    }
+
+    public static class Wrapper<T> extends AbstractModelObject {
+        private T value;
+
+        public Wrapper(T value) {
+            this.value = value;
+        }
+
+        public T getValue() {
+            return value;
+        }
+
+        public void setValue(T value) {
+            T oldValue = this.value;
+            this.value = value;
+            firePropertyChange("value", oldValue, this.value);
+        }
+    }
+
+    private static class JComponentBackgroundUpdater extends AbstractBindingListener {
+        private static Color errorColor = new Color(0xff, 0xdd, 0xdd);
+        private JComponent component;
+        private Color oldBackground;
+
+        public JComponentBackgroundUpdater(JComponent component) {
+            this.component = component;
+            oldBackground = component.getBackground();
+        }
+
+        @Override
+        public void syncFailed(Binding binding, SyncFailure failure) {
+            component.setBackground(errorColor);
+        }
+
+        @Override
+        public void synced(Binding binding) {
+            component.setBackground(oldBackground);
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/LengthCellValue.java b/src/main/java/org/openpnp/gui/support/LengthCellValue.java
index 6e9ac595ce..9d6465f682 100755
--- a/src/main/java/org/openpnp/gui/support/LengthCellValue.java
+++ b/src/main/java/org/openpnp/gui/support/LengthCellValue.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -27,65 +25,67 @@
 import org.openpnp.model.Length;
 
 public class LengthCellValue {
-	private static Configuration configuration;
-	
-	private Length length;
-	
-	/**
-	 * When set, the toString() method will show the units contained within
-	 * the Length instead of converting to the system units.
-	 */
-	private boolean displayNativeUnits;
-	
-	public static void setConfiguration(Configuration configuration) {
-		LengthCellValue.configuration = configuration;
-	}
+    private static Configuration configuration;
+
+    private Length length;
+
+    /**
+     * When set, the toString() method will show the units contained within the Length instead of
+     * converting to the system units.
+     */
+    private boolean displayNativeUnits;
+
+    public static void setConfiguration(Configuration configuration) {
+        LengthCellValue.configuration = configuration;
+    }
+
+    public LengthCellValue(Length length, boolean displayNativeUnits) {
+        setLength(length);
+        setDisplayNativeUnits(displayNativeUnits);
+    }
 
-	public LengthCellValue(Length length, boolean displayNativeUnits) {
-		setLength(length);
-		setDisplayNativeUnits(displayNativeUnits);
-	}
+    public LengthCellValue(Length length) {
+        this(length, false);
+    }
 
-	public LengthCellValue(Length length) {
-		this(length, false);
-	}
+    public LengthCellValue(String value) {
+        Length length = Length.parse(value, false);
+        if (length == null) {
+            throw new NullPointerException();
+        }
+        setLength(length);
+    }
 
-	public LengthCellValue(String value) {
-		Length length = Length.parse(value, false);
-		if (length == null) {
-			throw new NullPointerException();
-		}
-		setLength(length);
-	}
+    public Length getLength() {
+        return length;
+    }
 
-	public Length getLength() {
-		return length;
-	}
+    public void setLength(Length length) {
+        this.length = length;
+    }
 
-	public void setLength(Length length) {
-		this.length = length;
-	}
-	
-	public boolean isDisplayNativeUnits() {
-		return displayNativeUnits;
-	}
+    public boolean isDisplayNativeUnits() {
+        return displayNativeUnits;
+    }
 
-	public void setDisplayNativeUnits(boolean displayNativeUnits) {
-		this.displayNativeUnits = displayNativeUnits;
-	}
+    public void setDisplayNativeUnits(boolean displayNativeUnits) {
+        this.displayNativeUnits = displayNativeUnits;
+    }
 
-	@Override
-	public String toString() {
-		Length l = length;
-		if (l.getUnits() == null) {
-			return String.format(Locale.US,configuration.getLengthDisplayFormatWithUnits(), l.getValue(), "?");
-		}
-		if (displayNativeUnits && l.getUnits() != configuration.getSystemUnits()) {
-			return String.format(Locale.US,configuration.getLengthDisplayFormatWithUnits(), l.getValue(), l.getUnits().getShortName());
-		}
-		else {
-			l = l.convertToUnits(configuration.getSystemUnits());
-			return String.format(Locale.US,configuration.getLengthDisplayFormat(), l.getValue());
-		}
-	}
+    @Override
+    public String toString() {
+        Length l = length;
+        if (l.getUnits() == null) {
+            return String.format(Locale.US, configuration.getLengthDisplayFormatWithUnits(),
+                    l.getValue(), "?");
+        }
+        if (displayNativeUnits && l.getUnits() != configuration.getSystemUnits()) {
+            return String.format(Locale.US, configuration.getLengthDisplayFormatWithUnits(),
+                    l.getValue(), l.getUnits().getShortName());
+        }
+        else {
+            l = l.convertToUnits(configuration.getSystemUnits());
+            return String.format(Locale.US, configuration.getLengthDisplayFormat(), l.getValue());
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/LengthConverter.java b/src/main/java/org/openpnp/gui/support/LengthConverter.java
index 15807a003f..5b56cfee70 100755
--- a/src/main/java/org/openpnp/gui/support/LengthConverter.java
+++ b/src/main/java/org/openpnp/gui/support/LengthConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -28,21 +26,22 @@
 import org.openpnp.model.Length;
 
 public class LengthConverter extends Converter<Length, String> {
-	@Override
-	public String convertForward(Length length) {
-		length = length.convertToUnits(Configuration.get().getSystemUnits());
-		return String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), length.getValue());
-	}
-	
-	@Override
-	public Length convertReverse(String s) {
-		Length length = Length.parse(s, false);
-		if (length == null) {
-			throw new RuntimeException("Unable to parse " + s);
-		}
-		if (length.getUnits() == null) {
-			length.setUnits(Configuration.get().getSystemUnits());
-		}
-		return length;
-	}
+    @Override
+    public String convertForward(Length length) {
+        length = length.convertToUnits(Configuration.get().getSystemUnits());
+        return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                length.getValue());
+    }
+
+    @Override
+    public Length convertReverse(String s) {
+        Length length = Length.parse(s, false);
+        if (length == null) {
+            throw new RuntimeException("Unable to parse " + s);
+        }
+        if (length.getUnits() == null) {
+            length.setUnits(Configuration.get().getSystemUnits());
+        }
+        return length;
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/LongConverter.java b/src/main/java/org/openpnp/gui/support/LongConverter.java
index ad67d40abb..9762e6d8ad 100755
--- a/src/main/java/org/openpnp/gui/support/LongConverter.java
+++ b/src/main/java/org/openpnp/gui/support/LongConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,24 +24,24 @@
 import org.jdesktop.beansbinding.Converter;
 
 public class LongConverter extends Converter<Long, String> {
-	private String format;
-	
-	public LongConverter() {
-		this("%d");
-	}
-	
-	public LongConverter(String format) {
-		this.format = format;
-	}
-	
-	@Override
-	public String convertForward(Long arg0) {
-		return String.format(Locale.US,format, arg0);
-	}
-
-	@Override
-	public Long convertReverse(String arg0) {
-		return Long.parseLong(arg0);
-	}
+    private String format;
+
+    public LongConverter() {
+        this("%d");
+    }
+
+    public LongConverter(String format) {
+        this.format = format;
+    }
+
+    @Override
+    public String convertForward(Long arg0) {
+        return String.format(Locale.US, format, arg0);
+    }
+
+    @Override
+    public Long convertReverse(String arg0) {
+        return Long.parseLong(arg0);
+    }
 
 }
diff --git a/src/main/java/org/openpnp/gui/support/MessageBoxes.java b/src/main/java/org/openpnp/gui/support/MessageBoxes.java
index c7a96aca48..229eaafe14 100755
--- a/src/main/java/org/openpnp/gui/support/MessageBoxes.java
+++ b/src/main/java/org/openpnp/gui/support/MessageBoxes.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -31,45 +29,42 @@
 import org.slf4j.LoggerFactory;
 
 public class MessageBoxes {
-	private static final Logger logger = LoggerFactory
-			.getLogger(MessageBoxes.class);
+    private static final Logger logger = LoggerFactory.getLogger(MessageBoxes.class);
+
+    public static void errorBox(Component parent, String title, Throwable cause) {
+        String message = null;
+        if (cause != null) {
+            message = cause.getMessage();
+            if (message == null || message.trim().isEmpty()) {
+                StringWriter stringWriter = new StringWriter();
+                PrintWriter writer = new PrintWriter(stringWriter);
+                cause.printStackTrace(writer);
+                writer.close();
+                message = stringWriter.toString();
+            }
+        }
+        if (message == null) {
+            message = "No message supplied.";
+        }
+        logger.debug("{}: {}", title, cause);
+        message = message.replaceAll("\n", "<br/>");
+        message = message.replaceAll("\r", "");
+        message = "<html><body width=\"400\">" + message + "</body></html>";
+        JOptionPane.showMessageDialog(parent, message, title, JOptionPane.ERROR_MESSAGE);
+    }
 
-	public static void errorBox(Component parent, String title, Throwable cause) {
-		String message = null;
-		if (cause != null) {
-			message = cause.getMessage();
-			if (message == null || message.trim().isEmpty()) {
-			    StringWriter stringWriter = new StringWriter();
-			    PrintWriter writer = new PrintWriter(stringWriter);
-			    cause.printStackTrace(writer);
-			    writer.close();
-			    message = stringWriter.toString(); 
-			}
-		}
-		if (message == null) {
-			message = "No message supplied.";
-		}
-		logger.debug("{}: {}", title, cause);
-		 message = message.replaceAll("\n", "<br/>");
-		 message = message.replaceAll("\r", "");
-         message = "<html><body width=\"400\">" + message + "</body></html>";
-		 JOptionPane.showMessageDialog(parent, message, title,
-		 JOptionPane.ERROR_MESSAGE);
-	}
+    public static void errorBox(Component parent, String title, String message) {
+        if (message == null) {
+            message = "";
+        }
+        logger.debug("{}: {}", title, message);
+        message = message.replaceAll("\n", "<br/>");
+        message = message.replaceAll("\r", "");
+        message = "<html><body width=\"400\">" + message + "</body></html>";
+        JOptionPane.showMessageDialog(parent, message, title, JOptionPane.ERROR_MESSAGE);
+    }
 
-	public static void errorBox(Component parent, String title, String message) {
-		if (message == null) {
-			message = "";
-		}
-		logger.debug("{}: {}", title, message);
-		 message = message.replaceAll("\n", "<br/>");
-		 message = message.replaceAll("\r", "");
-         message = "<html><body width=\"400\">" + message + "</body></html>";
-		 JOptionPane.showMessageDialog(parent, message, title,
-		 JOptionPane.ERROR_MESSAGE);
-	}
-	
-	public static void notYetImplemented(Component parent) {
-		errorBox(parent, "Not Yet Implemented", "This function is not yet implemented.");
-	}
+    public static void notYetImplemented(Component parent) {
+        errorBox(parent, "Not Yet Implemented", "This function is not yet implemented.");
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/MutableLocationProxy.java b/src/main/java/org/openpnp/gui/support/MutableLocationProxy.java
index 44e457fcd2..51fcb922b2 100755
--- a/src/main/java/org/openpnp/gui/support/MutableLocationProxy.java
+++ b/src/main/java/org/openpnp/gui/support/MutableLocationProxy.java
@@ -5,21 +5,21 @@
 import org.openpnp.model.Location;
 
 /**
- * A proxy class that allows bindings to mutate a Location field by field
- * by replacing the bound Location whenever a field is changed. 
+ * A proxy class that allows bindings to mutate a Location field by field by replacing the bound
+ * Location whenever a field is changed.
  */
 public class MutableLocationProxy extends AbstractModelObject {
     private Location location;
-    
+
     public Location getLocation() {
         return location;
     }
-    
+
     public void setLocation(Location location) {
         this.location = location;
         firePropertyChange("location", null, getLocation());
     }
-    
+
     public void setLengthX(Length l) {
         if (l.getUnits() != location.getUnits()) {
             location = location.convertToUnits(l.getUnits());
@@ -35,7 +35,7 @@ public void setLengthX(Length l) {
             firePropertyChange("location", null, getLocation());
         }
     }
-    
+
     public void setLengthY(Length l) {
         if (l.getUnits() != location.getUnits()) {
             location = location.convertToUnits(l.getUnits());
@@ -51,7 +51,7 @@ public void setLengthY(Length l) {
             firePropertyChange("location", null, getLocation());
         }
     }
-    
+
     public void setLengthZ(Length l) {
         if (l.getUnits() != location.getUnits()) {
             location = location.convertToUnits(l.getUnits());
@@ -67,25 +67,25 @@ public void setLengthZ(Length l) {
             firePropertyChange("location", null, getLocation());
         }
     }
-    
+
     public double getRotation() {
         return location.getRotation();
     }
-    
+
     public void setRotation(double rotation) {
         location = location.derive(null, null, null, rotation);
         firePropertyChange("rotation", null, getRotation());
         firePropertyChange("location", null, getLocation());
     }
-    
+
     public Length getLengthX() {
         return location.getLengthX();
     }
-    
+
     public Length getLengthY() {
         return location.getLengthY();
     }
-    
+
     public Length getLengthZ() {
         return location.getLengthZ();
     }
diff --git a/src/main/java/org/openpnp/gui/support/NozzleItem.java b/src/main/java/org/openpnp/gui/support/NozzleItem.java
index c28283b5bd..a1479ca9cf 100755
--- a/src/main/java/org/openpnp/gui/support/NozzleItem.java
+++ b/src/main/java/org/openpnp/gui/support/NozzleItem.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.gui.support;
@@ -24,18 +22,19 @@
 import org.openpnp.spi.Nozzle;
 
 public class NozzleItem {
-	private Nozzle nozzle;
-	
-	public NozzleItem(Nozzle nozzle) {
-		this.nozzle = nozzle;
-	}
-	
-	public Nozzle getNozzle() {
-		return nozzle;
-	}
-	
-	@Override
-	public String toString() {
-        return String.format("Nozzle: %s %s", nozzle.getName(), nozzle.getHead() != null ? String.format("(Head: %s)", nozzle.getHead().getName()) : "");
-	}
-}
\ No newline at end of file
+    private Nozzle nozzle;
+
+    public NozzleItem(Nozzle nozzle) {
+        this.nozzle = nozzle;
+    }
+
+    public Nozzle getNozzle() {
+        return nozzle;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("Nozzle: %s %s", nozzle.getName(), nozzle.getHead() != null
+                ? String.format("(Head: %s)", nozzle.getHead().getName()) : "");
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/support/OSXAdapter.java b/src/main/java/org/openpnp/gui/support/OSXAdapter.java
index 09692d29f2..eed8786d1c 100755
--- a/src/main/java/org/openpnp/gui/support/OSXAdapter.java
+++ b/src/main/java/org/openpnp/gui/support/OSXAdapter.java
@@ -1,81 +1,71 @@
 /*
+ * 
+ * File: OSXAdapter.java
+ * 
+ * Abstract: Hooks existing preferences/about/quit functionality from an existing Java app into
+ * handlers for the Mac OS X application menu. Uses a Proxy object to dynamically implement the
+ * com.apple.eawt.ApplicationListener interface and register it with the com.apple.eawt.Application
+ * object. This allows the complete project to be both built and run on any platform without any
+ * stubs or placeholders. Useful for developers looking to implement Mac OS X features while
+ * supporting multiple platforms with minimal impact.
+ * 
+ * Version: 2.0
+ * 
+ * Disclaimer: IMPORTANT: This Apple software is supplied to you by Apple Inc. ("Apple") in
+ * consideration of your agreement to the following terms, and your use, installation, modification
+ * or redistribution of this Apple software constitutes acceptance of these terms. If you do not
+ * agree with these terms, please do not use, install, modify or redistribute this Apple software.
+ * 
+ * In consideration of your agreement to abide by the following terms, and subject to these terms,
+ * Apple grants you a personal, non-exclusive license, under Apple's copyrights in this original
+ * Apple software (the "Apple Software"), to use, reproduce, modify and redistribute the Apple
+ * Software, with or without modifications, in source and/or binary forms; provided that if you
+ * redistribute the Apple Software in its entirety and without modifications, you must retain this
+ * notice and the following text and disclaimers in all such redistributions of the Apple Software.
+ * Neither the name, trademarks, service marks or logos of Apple Inc. may be used to endorse or
+ * promote products derived from the Apple Software without specific prior written permission from
+ * Apple. Except as expressly stated in this notice, no other rights or licenses, express or
+ * implied, are granted by Apple herein, including but not limited to any patent rights that may be
+ * infringed by your derivative works or by other works in which the Apple Software may be
+ * incorporated.
+ * 
+ * The Apple Software is provided by Apple on an "AS IS" basis. APPLE MAKES NO WARRANTIES, EXPRESS
+ * OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
+ * OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
+ * 
+ * IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
+ * OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
+ * MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY
+ * OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * Copyright © 2003-2007 Apple, Inc., All Rights Reserved
+ * 
+ */
 
-File: OSXAdapter.java
- 
-Abstract: Hooks existing preferences/about/quit functionality from an
-    existing Java app into handlers for the Mac OS X application menu.
-    Uses a Proxy object to dynamically implement the 
-    com.apple.eawt.ApplicationListener interface and register it with the
-    com.apple.eawt.Application object.  This allows the complete project
-    to be both built and run on any platform without any stubs or 
-    placeholders. Useful for developers looking to implement Mac OS X 
-    features while supporting multiple platforms with minimal impact.
-            
-Version: 2.0
- 
-Disclaimer: IMPORTANT:  This Apple software is supplied to you by 
-Apple Inc. ("Apple") in consideration of your agreement to the
-following terms, and your use, installation, modification or
-redistribution of this Apple software constitutes acceptance of these
-terms.  If you do not agree with these terms, please do not use,
-install, modify or redistribute this Apple software.
- 
-In consideration of your agreement to abide by the following terms, and
-subject to these terms, Apple grants you a personal, non-exclusive
-license, under Apple's copyrights in this original Apple software (the
-"Apple Software"), to use, reproduce, modify and redistribute the Apple
-Software, with or without modifications, in source and/or binary forms;
-provided that if you redistribute the Apple Software in its entirety and
-without modifications, you must retain this notice and the following
-text and disclaimers in all such redistributions of the Apple Software. 
-Neither the name, trademarks, service marks or logos of Apple Inc. 
-may be used to endorse or promote products derived from the Apple
-Software without specific prior written permission from Apple.  Except
-as expressly stated in this notice, no other rights or licenses, express
-or implied, are granted by Apple herein, including but not limited to
-any patent rights that may be infringed by your derivative works or by
-other works in which the Apple Software may be incorporated.
- 
-The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
-MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
-THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
-OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
- 
-IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
-OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
-MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
-AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
-STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
- 
-Copyright © 2003-2007 Apple, Inc., All Rights Reserved
- 
-*/
- 
 package org.openpnp.gui.support;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
- 
+
 public class OSXAdapter implements InvocationHandler {
- 
+
     protected Object targetObject;
     protected Method targetMethod;
     protected String proxySignature;
-    
+
     static Object macOSXApplication;
- 
+
     // Pass this method an Object and Method equipped to perform application shutdown logic
     // The method passed should return a boolean stating whether or not the quit should occur
     public static void setQuitHandler(Object target, Method quitHandler) {
         setHandler(new OSXAdapter("handleQuit", target, quitHandler));
     }
-    
+
     // Pass this method an Object and Method equipped to display application info
     // They will be called when the About menu item is selected from the application menu
     public static void setAboutHandler(Object target, Method aboutHandler) {
@@ -86,14 +76,17 @@ public static void setAboutHandler(Object target, Method aboutHandler) {
         // If we're setting a handler, enable the About menu item by calling
         // com.apple.eawt.Application reflectively
         try {
-            Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledAboutMenu", new Class[] { boolean.class });
-            enableAboutMethod.invoke(macOSXApplication, new Object[] { Boolean.valueOf(enableAboutMenu) });
-        } catch (Exception ex) {
+            Method enableAboutMethod = macOSXApplication.getClass()
+                    .getDeclaredMethod("setEnabledAboutMenu", new Class[] {boolean.class});
+            enableAboutMethod.invoke(macOSXApplication,
+                    new Object[] {Boolean.valueOf(enableAboutMenu)});
+        }
+        catch (Exception ex) {
             System.err.println("OSXAdapter could not access the About Menu");
             ex.printStackTrace();
         }
     }
-    
+
     // Pass this method an Object and a Method equipped to display application options
     // They will be called when the Preferences menu item is selected from the application menu
     public static void setPreferencesHandler(Object target, Method prefsHandler) {
@@ -104,16 +97,19 @@ public static void setPreferencesHandler(Object target, Method prefsHandler) {
         // If we're setting a handler, enable the Preferences menu item by calling
         // com.apple.eawt.Application reflectively
         try {
-            Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledPreferencesMenu", new Class[] { boolean.class });
-            enablePrefsMethod.invoke(macOSXApplication, new Object[] { Boolean.valueOf(enablePrefsMenu) });
-        } catch (Exception ex) {
+            Method enablePrefsMethod = macOSXApplication.getClass()
+                    .getDeclaredMethod("setEnabledPreferencesMenu", new Class[] {boolean.class});
+            enablePrefsMethod.invoke(macOSXApplication,
+                    new Object[] {Boolean.valueOf(enablePrefsMenu)});
+        }
+        catch (Exception ex) {
             System.err.println("OSXAdapter could not access the About Menu");
             ex.printStackTrace();
         }
     }
-    
+
     // Pass this method an Object and a Method equipped to handle document events from the Finder
-    // Documents are registered with the Finder via the CFBundleDocumentTypes dictionary in the 
+    // Documents are registered with the Finder via the CFBundleDocumentTypes dictionary in the
     // application bundle's Info.plist
     public static void setFileHandler(Object target, Method fileHandler) {
         setHandler(new OSXAdapter("handleOpenFile", target, fileHandler) {
@@ -122,60 +118,76 @@ public static void setFileHandler(Object target, Method fileHandler) {
             public boolean callTarget(Object appleEvent) {
                 if (appleEvent != null) {
                     try {
-                        Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[])null);
-                        String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[])null);
-                        this.targetMethod.invoke(this.targetObject, new Object[] { filename });
-                    } catch (Exception ex) {
-                        
+                        Method getFilenameMethod = appleEvent.getClass()
+                                .getDeclaredMethod("getFilename", (Class[]) null);
+                        String filename =
+                                (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
+                        this.targetMethod.invoke(this.targetObject, new Object[] {filename});
+                    }
+                    catch (Exception ex) {
+
                     }
                 }
                 return true;
             }
         });
     }
-    
-    // setHandler creates a Proxy object from the passed OSXAdapter and adds it as an ApplicationListener
+
+    // setHandler creates a Proxy object from the passed OSXAdapter and adds it as an
+    // ApplicationListener
     public static void setHandler(OSXAdapter adapter) {
         try {
             Class applicationClass = Class.forName("com.apple.eawt.Application");
             if (macOSXApplication == null) {
-                macOSXApplication = applicationClass.getConstructor((Class[])null).newInstance((Object[])null);
+                macOSXApplication = applicationClass.getConstructor((Class[]) null)
+                        .newInstance((Object[]) null);
             }
             Class applicationListenerClass = Class.forName("com.apple.eawt.ApplicationListener");
-            Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener", new Class[] { applicationListenerClass });
-            // Create a proxy object around this handler that can be reflectively added as an Apple ApplicationListener
-            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[] { applicationListenerClass }, adapter);
-            addListenerMethod.invoke(macOSXApplication, new Object[] { osxAdapterProxy });
-        } catch (ClassNotFoundException cnfe) {
-            System.err.println("This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled (" + cnfe + ")");
-        } catch (Exception ex) {  // Likely a NoSuchMethodException or an IllegalAccessException loading/invoking eawt.Application methods
+            Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener",
+                    new Class[] {applicationListenerClass});
+            // Create a proxy object around this handler that can be reflectively added as an Apple
+            // ApplicationListener
+            Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(),
+                    new Class[] {applicationListenerClass}, adapter);
+            addListenerMethod.invoke(macOSXApplication, new Object[] {osxAdapterProxy});
+        }
+        catch (ClassNotFoundException cnfe) {
+            System.err.println(
+                    "This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled ("
+                            + cnfe + ")");
+        }
+        catch (Exception ex) { // Likely a NoSuchMethodException or an IllegalAccessException
+                               // loading/invoking eawt.Application methods
             System.err.println("Mac OS X Adapter could not talk to EAWT:");
             ex.printStackTrace();
         }
     }
- 
-    // Each OSXAdapter has the name of the EAWT method it intends to listen for (handleAbout, for example),
+
+    // Each OSXAdapter has the name of the EAWT method it intends to listen for (handleAbout, for
+    // example),
     // the Object that will ultimately perform the task, and the Method to be called on that Object
     protected OSXAdapter(String proxySignature, Object target, Method handler) {
         this.proxySignature = proxySignature;
         this.targetObject = target;
         this.targetMethod = handler;
     }
-    
-    // Override this method to perform any operations on the event 
+
+    // Override this method to perform any operations on the event
     // that comes with the various callbacks
     // See setFileHandler above for an example
-    public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException {
-        Object result = targetMethod.invoke(targetObject, (Object[])null);
+    public boolean callTarget(Object appleEvent)
+            throws InvocationTargetException, IllegalAccessException {
+        Object result = targetMethod.invoke(targetObject, (Object[]) null);
         if (result == null) {
             return true;
         }
         return Boolean.valueOf(result.toString()).booleanValue();
     }
-    
+
     // InvocationHandler implementation
-    // This is the entry point for our proxy object; it is called every time an ApplicationListener method is invoked
-    public Object invoke (Object proxy, Method method, Object[] args) throws Throwable {
+    // This is the entry point for our proxy object; it is called every time an ApplicationListener
+    // method is invoked
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
         if (isCorrectMethod(method, args)) {
             boolean handled = callTarget(args[0]);
             setApplicationEventHandled(args[0], handled);
@@ -183,25 +195,29 @@ public Object invoke (Object proxy, Method method, Object[] args) throws Throwab
         // All of the ApplicationListener methods are void; return null regardless of what happens
         return null;
     }
-    
-    // Compare the method that was called to the intended method when the OSXAdapter instance was created
+
+    // Compare the method that was called to the intended method when the OSXAdapter instance was
+    // created
     // (e.g. handleAbout, handleQuit, handleOpenFile, etc.)
     protected boolean isCorrectMethod(Method method, Object[] args) {
-        return (targetMethod != null && proxySignature.equals(method.getName()) && args.length == 1);
+        return (targetMethod != null && proxySignature.equals(method.getName())
+                && args.length == 1);
     }
-    
+
     // It is important to mark the ApplicationEvent as handled and cancel the default behavior
     // This method checks for a boolean result from the proxy method and sets the event accordingly
     protected void setApplicationEventHandled(Object event, boolean handled) {
         if (event != null) {
             try {
-                Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled", new Class[] { boolean.class });
+                Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled",
+                        new Class[] {boolean.class});
                 // If the target method returns a boolean, use that as a hint
-                setHandledMethod.invoke(event, new Object[] { Boolean.valueOf(handled) });
-            } catch (Exception ex) {
+                setHandledMethod.invoke(event, new Object[] {Boolean.valueOf(handled)});
+            }
+            catch (Exception ex) {
                 System.err.println("OSXAdapter was unable to handle an ApplicationEvent: " + event);
                 ex.printStackTrace();
             }
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/support/PackagesComboBoxModel.java b/src/main/java/org/openpnp/gui/support/PackagesComboBoxModel.java
index e03830c43a..ede4cab6d8 100755
--- a/src/main/java/org/openpnp/gui/support/PackagesComboBoxModel.java
+++ b/src/main/java/org/openpnp/gui/support/PackagesComboBoxModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -32,24 +30,26 @@
 
 @SuppressWarnings("serial")
 public class PackagesComboBoxModel extends DefaultComboBoxModel implements PropertyChangeListener {
-	private IdentifiableComparator<org.openpnp.model.Package> comparator = new IdentifiableComparator<>();
-
-	public PackagesComboBoxModel() {
-		addAllElements();
-		Configuration.get().addPropertyChangeListener("packages", this);
-	}
-	
-	private void addAllElements() {
-		ArrayList<org.openpnp.model.Package> packages = new ArrayList<>(Configuration.get().getPackages());
-		Collections.sort(packages, comparator);
-		for (org.openpnp.model.Package pkg : packages) {
-			addElement(pkg);
-		}
-	}
-	
-	@Override
-	public void propertyChange(PropertyChangeEvent evt) {
-		removeAllElements();
-		addAllElements();
-	}
+    private IdentifiableComparator<org.openpnp.model.Package> comparator =
+            new IdentifiableComparator<>();
+
+    public PackagesComboBoxModel() {
+        addAllElements();
+        Configuration.get().addPropertyChangeListener("packages", this);
+    }
+
+    private void addAllElements() {
+        ArrayList<org.openpnp.model.Package> packages =
+                new ArrayList<>(Configuration.get().getPackages());
+        Collections.sort(packages, comparator);
+        for (org.openpnp.model.Package pkg : packages) {
+            addElement(pkg);
+        }
+    }
+
+    @Override
+    public void propertyChange(PropertyChangeEvent evt) {
+        removeAllElements();
+        addAllElements();
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/PartConverter.java b/src/main/java/org/openpnp/gui/support/PartConverter.java
index 866e3ae4c1..33cd7a4450 100755
--- a/src/main/java/org/openpnp/gui/support/PartConverter.java
+++ b/src/main/java/org/openpnp/gui/support/PartConverter.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -26,28 +24,29 @@
 import org.openpnp.model.Part;
 
 public class PartConverter extends Converter<Part, String> {
-	private Configuration configuration; 
-	private IdentifiableObjectToStringConverter<Part> toStringConverter = new IdentifiableObjectToStringConverter<>();
-	
-	public PartConverter(Configuration configuration) {
-		this.configuration = configuration;
-	}
-	
-	@Override
-	public String convertForward(Part part) {
-		return toStringConverter.getPreferredStringForItem(part);
-	}
+    private Configuration configuration;
+    private IdentifiableObjectToStringConverter<Part> toStringConverter =
+            new IdentifiableObjectToStringConverter<>();
+
+    public PartConverter(Configuration configuration) {
+        this.configuration = configuration;
+    }
+
+    @Override
+    public String convertForward(Part part) {
+        return toStringConverter.getPreferredStringForItem(part);
+    }
 
-	@Override
-	public Part convertReverse(String partId) {
-		if (partId == null) {
-			return null;
-		}
-		Part part = configuration.getPart(partId);
-		if (part == null) {
-			throw new RuntimeException("Invalid part id");
-		}
-		return part;
-	}
+    @Override
+    public Part convertReverse(String partId) {
+        if (partId == null) {
+            return null;
+        }
+        Part part = configuration.getPart(partId);
+        if (part == null) {
+            throw new RuntimeException("Invalid part id");
+        }
+        return part;
+    }
 
 }
diff --git a/src/main/java/org/openpnp/gui/support/PartsComboBoxModel.java b/src/main/java/org/openpnp/gui/support/PartsComboBoxModel.java
index e53352e6e1..e9dc2b8410 100755
--- a/src/main/java/org/openpnp/gui/support/PartsComboBoxModel.java
+++ b/src/main/java/org/openpnp/gui/support/PartsComboBoxModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
@@ -33,24 +31,24 @@
 
 @SuppressWarnings("serial")
 public class PartsComboBoxModel extends DefaultComboBoxModel implements PropertyChangeListener {
-	private IdentifiableComparator<Part> comparator = new IdentifiableComparator<>();
-	
-	public PartsComboBoxModel() {
-		addAllElements();
-		Configuration.get().addPropertyChangeListener("parts", this);
-	}
-	
-	private void addAllElements() {
-		ArrayList<Part> parts = new ArrayList<>(Configuration.get().getParts());
-		Collections.sort(parts, comparator);
-		for (Part part : parts) {
-			addElement(part);
-		}
-	}
-	
-	@Override
-	public void propertyChange(PropertyChangeEvent evt) {
-		removeAllElements();
-		addAllElements();
-	}
+    private IdentifiableComparator<Part> comparator = new IdentifiableComparator<>();
+
+    public PartsComboBoxModel() {
+        addAllElements();
+        Configuration.get().addPropertyChangeListener("parts", this);
+    }
+
+    private void addAllElements() {
+        ArrayList<Part> parts = new ArrayList<>(Configuration.get().getParts());
+        Collections.sort(parts, comparator);
+        for (Part part : parts) {
+            addElement(part);
+        }
+    }
+
+    @Override
+    public void propertyChange(PropertyChangeEvent evt) {
+        removeAllElements();
+        addAllElements();
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/support/PropertySheetWizardAdapter.java b/src/main/java/org/openpnp/gui/support/PropertySheetWizardAdapter.java
index 3132dfa6a1..d0726b11ad 100755
--- a/src/main/java/org/openpnp/gui/support/PropertySheetWizardAdapter.java
+++ b/src/main/java/org/openpnp/gui/support/PropertySheetWizardAdapter.java
@@ -7,11 +7,11 @@
 public class PropertySheetWizardAdapter implements PropertySheet, WizardContainer {
     private final Wizard wizard;
     private final String title;
-    
+
     public PropertySheetWizardAdapter(Wizard wizard) {
         this(wizard, wizard == null ? null : wizard.getWizardName());
     }
-    
+
     public PropertySheetWizardAdapter(Wizard wizard, String title) {
         this.wizard = wizard;
         this.title = title;
diff --git a/src/main/java/org/openpnp/gui/support/SvgIcon.java b/src/main/java/org/openpnp/gui/support/SvgIcon.java
index 0a006e0ed8..60bb1f2308 100755
--- a/src/main/java/org/openpnp/gui/support/SvgIcon.java
+++ b/src/main/java/org/openpnp/gui/support/SvgIcon.java
@@ -5,8 +5,8 @@
  *
  * Cameron McCormack <cam (at) mcc.id.au>
  *
- * Permission is hereby granted to use, copy, modify and distribte this
- * code for any purpose, without fee.
+ * Permission is hereby granted to use, copy, modify and distribte this code for any purpose,
+ * without fee.
  *
  * Initial version: April 21, 2005
  */
@@ -39,14 +39,14 @@
      * The BufferedImage generated from the SVG document.
      */
     protected BufferedImage bufferedImage;
-    
+
     protected Image bufferedImageDisabled;
 
     /**
      * The width of the rendered image.
      */
     protected int width;
-    
+
     /**
      * The height of the rendered image.
      */
@@ -54,6 +54,7 @@
 
     /**
      * Create a new SVGIcon object.
+     * 
      * @param uri The URI to read the SVG document from.
      */
     public SvgIcon(URL url, int width, int height) {
@@ -67,6 +68,7 @@ public SvgIcon(URL url, int width, int height) {
 
     /**
      * Create a new SVGIcon object.
+     * 
      * @param uri The URI to read the SVG document from.
      */
     public SvgIcon(URL url) {
@@ -128,6 +130,7 @@ public void paintIcon(Component c, Graphics g, int x, int y) {
 
         /**
          * Creates a new ARGB image with the specified dimension.
+         * 
          * @param width the image width in pixels
          * @param height the image height in pixels
          */
@@ -137,6 +140,7 @@ public BufferedImage createImage(int width, int height) {
 
         /**
          * Writes the specified image to the specified output.
+         * 
          * @param img the image to write
          * @param output the output where to store the image
          * @param TranscoderException if an error occured while storing the image
@@ -161,4 +165,4 @@ public void setDimensions(int w, int h) {
             hints.put(KEY_HEIGHT, new Float(h));
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/gui/support/Wizard.java b/src/main/java/org/openpnp/gui/support/Wizard.java
index 21abee3c84..4886553f67 100755
--- a/src/main/java/org/openpnp/gui/support/Wizard.java
+++ b/src/main/java/org/openpnp/gui/support/Wizard.java
@@ -1,30 +1,30 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
 import javax.swing.JPanel;
 
 public interface Wizard {
-	public void setWizardContainer(WizardContainer wizardContainer);
-	public JPanel getWizardPanel();
-	public String getWizardName();
+    public void setWizardContainer(WizardContainer wizardContainer);
+
+    public JPanel getWizardPanel();
+
+    public String getWizardName();
 }
diff --git a/src/main/java/org/openpnp/gui/support/WizardContainer.java b/src/main/java/org/openpnp/gui/support/WizardContainer.java
index 80f395ac74..de6e4045cb 100755
--- a/src/main/java/org/openpnp/gui/support/WizardContainer.java
+++ b/src/main/java/org/openpnp/gui/support/WizardContainer.java
@@ -1,29 +1,27 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.support;
 
 
 public interface WizardContainer {
-	public void wizardCompleted(Wizard wizard);
-	
-	public void wizardCancelled(Wizard wizard);
+    public void wizardCompleted(Wizard wizard);
+
+    public void wizardCancelled(Wizard wizard);
 }
diff --git a/src/main/java/org/openpnp/gui/tablemodel/BoardLocationsTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/BoardLocationsTableModel.java
index 74251d8be5..6df00a22f9 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/BoardLocationsTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/BoardLocationsTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -34,123 +32,105 @@
 import org.openpnp.model.Location;
 
 public class BoardLocationsTableModel extends AbstractTableModel {
-	private final Configuration configuration;
-	
-	private String[] columnNames = new String[] { 
-			"Board", 
-			"Width",
-			"Height",
-			"Side", 
-			"X",
-			"Y", 
-			"Z", 
-			"ø",
-			"Enabled?",
-			"Check Fids?"
-	};
-	
-	private Class[] columnTypes = new Class[] {
-			String.class,
-			LengthCellValue.class,
-			LengthCellValue.class,
-			Side.class,
-			LengthCellValue.class,
-			LengthCellValue.class,
-			LengthCellValue.class,
-			String.class,
-			Boolean.class,
-			Boolean.class
-	};
-	
-	private Job job;
-	
-	public BoardLocationsTableModel(Configuration configuration) {
-		this.configuration = configuration;
-	}
-
-	public void setJob(Job job) {
-		this.job = job;
-		fireTableDataChanged();
-	}
-	
-	public Job getJob() {
-	    return job;
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		if (job == null) {
-			return 0;
-		}
-		return job.getBoardLocations().size();
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return (columnIndex != 0);
-	}
-	
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			BoardLocation boardLocation = job.getBoardLocations().get(rowIndex);
-			if (columnIndex == 0) {
-				boardLocation.getBoard().setName((String) aValue);
-			}
-			else if (columnIndex == 1) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				Length length = value.getLength();
-				Location location = boardLocation.getBoard().getDimensions();
-				location = Length.setLocationField(configuration, location, length, Length.Field.X);
-				boardLocation.getBoard().setDimensions(location);
-			}
-			else if (columnIndex == 2) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				Length length = value.getLength();
-				Location location = boardLocation.getBoard().getDimensions();
-				location = Length.setLocationField(configuration, location, length, Length.Field.Y);
-				boardLocation.getBoard().setDimensions(location);
-			}
-			else if (columnIndex == 3) {
-				boardLocation.setSide((Side) aValue);
-				fireTableCellUpdated(rowIndex, columnIndex);
-			}
-			else if (columnIndex == 4) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				Length length = value.getLength();
-				Location location = boardLocation.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.X);
-				boardLocation.setLocation(location);
-			}
-			else if (columnIndex == 5) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				Length length = value.getLength();
-				Location location = boardLocation.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.Y);
-				boardLocation.setLocation(location);
-			}
-			else if (columnIndex == 6) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				Length length = value.getLength();
-				Location location = boardLocation.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.Z);
-				boardLocation.setLocation(location);
-			}
+    private final Configuration configuration;
+
+    private String[] columnNames = new String[] {"Board", "Width", "Height", "Side", "X", "Y", "Z",
+            "ø", "Enabled?", "Check Fids?"};
+
+    private Class[] columnTypes = new Class[] {String.class, LengthCellValue.class,
+            LengthCellValue.class, Side.class, LengthCellValue.class, LengthCellValue.class,
+            LengthCellValue.class, String.class, Boolean.class, Boolean.class};
+
+    private Job job;
+
+    public BoardLocationsTableModel(Configuration configuration) {
+        this.configuration = configuration;
+    }
+
+    public void setJob(Job job) {
+        this.job = job;
+        fireTableDataChanged();
+    }
+
+    public Job getJob() {
+        return job;
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        if (job == null) {
+            return 0;
+        }
+        return job.getBoardLocations().size();
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return (columnIndex != 0);
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            BoardLocation boardLocation = job.getBoardLocations().get(rowIndex);
+            if (columnIndex == 0) {
+                boardLocation.getBoard().setName((String) aValue);
+            }
+            else if (columnIndex == 1) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                Length length = value.getLength();
+                Location location = boardLocation.getBoard().getDimensions();
+                location = Length.setLocationField(configuration, location, length, Length.Field.X);
+                boardLocation.getBoard().setDimensions(location);
+            }
+            else if (columnIndex == 2) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                Length length = value.getLength();
+                Location location = boardLocation.getBoard().getDimensions();
+                location = Length.setLocationField(configuration, location, length, Length.Field.Y);
+                boardLocation.getBoard().setDimensions(location);
+            }
+            else if (columnIndex == 3) {
+                boardLocation.setSide((Side) aValue);
+                fireTableCellUpdated(rowIndex, columnIndex);
+            }
+            else if (columnIndex == 4) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                Length length = value.getLength();
+                Location location = boardLocation.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.X);
+                boardLocation.setLocation(location);
+            }
+            else if (columnIndex == 5) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                Length length = value.getLength();
+                Location location = boardLocation.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.Y);
+                boardLocation.setLocation(location);
+            }
+            else if (columnIndex == 6) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                Length length = value.getLength();
+                Location location = boardLocation.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.Z);
+                boardLocation.setLocation(location);
+            }
             else if (columnIndex == 7) {
-                boardLocation.setLocation(boardLocation.getLocation().derive(null, null, null, Double.parseDouble(aValue.toString())));
+                boardLocation.setLocation(boardLocation.getLocation().derive(null, null, null,
+                        Double.parseDouble(aValue.toString())));
             }
             else if (columnIndex == 8) {
                 boardLocation.setEnabled((Boolean) aValue);
@@ -158,39 +138,40 @@ else if (columnIndex == 8) {
             else if (columnIndex == 9) {
                 boardLocation.setCheckFiducials((Boolean) aValue);
             }
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-
-	public Object getValueAt(int row, int col) {
-		BoardLocation boardLocation = job.getBoardLocations().get(row);
-		Location loc = boardLocation.getLocation();
-		Location dim = boardLocation.getBoard().getDimensions();
-		switch (col) {
-		case 0:
-			return boardLocation.getBoard().getName();
-		case 1:
-			return new LengthCellValue(dim.getLengthX());
-		case 2:
-			return new LengthCellValue(dim.getLengthY());
-		case 3:
-			return boardLocation.getSide();
-		case 4:
-			return new LengthCellValue(loc.getLengthX());
-		case 5:
-			return new LengthCellValue(loc.getLengthY());
-		case 6:
-			return new LengthCellValue(loc.getLengthZ());
-        case 7:
-            return String.format(Locale.US,configuration.getLengthDisplayFormat(), loc.getRotation(), "");
-        case 8:
-            return boardLocation.isEnabled();
-        case 9:
-            return boardLocation.isCheckFiducials();
-		default:
-			return null;
-		}
-	}
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    public Object getValueAt(int row, int col) {
+        BoardLocation boardLocation = job.getBoardLocations().get(row);
+        Location loc = boardLocation.getLocation();
+        Location dim = boardLocation.getBoard().getDimensions();
+        switch (col) {
+            case 0:
+                return boardLocation.getBoard().getName();
+            case 1:
+                return new LengthCellValue(dim.getLengthX());
+            case 2:
+                return new LengthCellValue(dim.getLengthY());
+            case 3:
+                return boardLocation.getSide();
+            case 4:
+                return new LengthCellValue(loc.getLengthX());
+            case 5:
+                return new LengthCellValue(loc.getLengthY());
+            case 6:
+                return new LengthCellValue(loc.getLengthZ());
+            case 7:
+                return String.format(Locale.US, configuration.getLengthDisplayFormat(),
+                        loc.getRotation(), "");
+            case 8:
+                return boardLocation.isEnabled();
+            case 9:
+                return boardLocation.isCheckFiducials();
+            default:
+                return null;
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/gui/tablemodel/CamerasTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/CamerasTableModel.java
index dfe828cf1e..da93e15d5e 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/CamerasTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/CamerasTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -35,106 +33,106 @@
 import org.openpnp.spi.Head;
 
 public class CamerasTableModel extends AbstractTableModel {
-	final private Configuration configuration;
-	
-	private String[] columnNames = new String[] { "Name", "Type", "Looking", "Head" };
-	private List<Camera> cameras;
+    final private Configuration configuration;
 
-	public CamerasTableModel(Configuration configuration) {
-		this.configuration = configuration;
+    private String[] columnNames = new String[] {"Name", "Type", "Looking", "Head"};
+    private List<Camera> cameras;
+
+    public CamerasTableModel(Configuration configuration) {
+        this.configuration = configuration;
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             public void configurationComplete(Configuration configuration) throws Exception {
                 refresh();
             }
         });
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		return (cameras == null) ? 0 : cameras.size();
-	}
-	
-	public Camera getCamera(int index) {
-		return cameras.get(index);
-	}
-	
-	public void refresh() {
-		cameras = new ArrayList<>(Configuration.get().getMachine().getCameras());
-		for (Head head : Configuration.get().getMachine().getHeads()) {
-	        cameras.addAll(head.getCameras());
-		}
-		fireTableDataChanged();
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return columnIndex == 0 || columnIndex == 2 || columnIndex == 3;
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		if (columnIndex == 3) {
-			return HeadCellValue.class;
-		}
-		return super.getColumnClass(columnIndex);
-	}
-
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Camera camera = cameras.get(rowIndex);
-			if (columnIndex == 0) {
-			    camera.setName((String) aValue);
-			}
-			else if (columnIndex == 2) {
-				camera.setLooking((Looking) aValue);
-			}
-			else if (columnIndex == 3) {
-			    HeadCellValue value = (HeadCellValue) aValue;
-			    if (camera.getHead() == null) {
-			        Configuration.get().getMachine().removeCamera(camera);
-			    }
-			    else {
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (cameras == null) ? 0 : cameras.size();
+    }
+
+    public Camera getCamera(int index) {
+        return cameras.get(index);
+    }
+
+    public void refresh() {
+        cameras = new ArrayList<>(Configuration.get().getMachine().getCameras());
+        for (Head head : Configuration.get().getMachine().getHeads()) {
+            cameras.addAll(head.getCameras());
+        }
+        fireTableDataChanged();
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex == 0 || columnIndex == 2 || columnIndex == 3;
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        if (columnIndex == 3) {
+            return HeadCellValue.class;
+        }
+        return super.getColumnClass(columnIndex);
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Camera camera = cameras.get(rowIndex);
+            if (columnIndex == 0) {
+                camera.setName((String) aValue);
+            }
+            else if (columnIndex == 2) {
+                camera.setLooking((Looking) aValue);
+            }
+            else if (columnIndex == 3) {
+                HeadCellValue value = (HeadCellValue) aValue;
+                if (camera.getHead() == null) {
+                    Configuration.get().getMachine().removeCamera(camera);
+                }
+                else {
                     camera.getHead().removeCamera(camera);
-			    }
-			    
-			    if (value.getHead() == null) {
-			        Configuration.get().getMachine().addCamera(camera);
-			    }
-			    else {
-			        value.getHead().addCamera(camera);
-			    }
-			    camera.setHead(value.getHead());
-			}
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-	
-	public Object getValueAt(int row, int col) {
-		Camera camera = cameras.get(row);
-		Location loc = camera.getLocation();
-		switch (col) {
-		case 0:
-			return camera.getName();
-        case 1:
-            return camera.getClass().getSimpleName();
-        case 2:
-            return camera.getLooking();
-		case 3:
-			return new HeadCellValue(camera.getHead());
-			
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+                }
+
+                if (value.getHead() == null) {
+                    Configuration.get().getMachine().addCamera(camera);
+                }
+                else {
+                    value.getHead().addCamera(camera);
+                }
+                camera.setHead(value.getHead());
+            }
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    public Object getValueAt(int row, int col) {
+        Camera camera = cameras.get(row);
+        Location loc = camera.getLocation();
+        switch (col) {
+            case 0:
+                return camera.getName();
+            case 1:
+                return camera.getClass().getSimpleName();
+            case 2:
+                return camera.getLooking();
+            case 3:
+                return new HeadCellValue(camera.getHead());
+
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/FeedersTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/FeedersTableModel.java
index 0509b46a54..556396146f 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/FeedersTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/FeedersTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -32,88 +30,88 @@
 import org.openpnp.spi.Feeder;
 
 public class FeedersTableModel extends AbstractTableModel {
-	final private Configuration configuration;
-	
-	private String[] columnNames = new String[] { "Name", "Type", "Part", "Enabled" };
-	private List<Feeder> feeders;
+    final private Configuration configuration;
 
-	public FeedersTableModel(Configuration configuration) {
-		this.configuration = configuration;
+    private String[] columnNames = new String[] {"Name", "Type", "Part", "Enabled"};
+    private List<Feeder> feeders;
+
+    public FeedersTableModel(Configuration configuration) {
+        this.configuration = configuration;
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             public void configurationComplete(Configuration configuration) throws Exception {
                 refresh();
             }
         });
-	}
-
-	public void refresh() {
-		feeders = new ArrayList<>(configuration.getMachine().getFeeders());
-		fireTableDataChanged();
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		return (feeders == null) ? 0 : feeders.size();
-	}
-	
-	public Feeder getFeeder(int index) {
-		return feeders.get(index);
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return columnIndex == 0 || columnIndex == 3;
-	}
-	
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Feeder feeder = feeders.get(rowIndex);
-			if (columnIndex == 0) {
-			    feeder.setName((String) aValue);
-			}
-			else if (columnIndex == 3) {
-				feeder.setEnabled((Boolean) aValue);
-			}
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		if (columnIndex == 3) {
-			return Boolean.class;
-		}
-		return super.getColumnClass(columnIndex);
-	}
-
-	public Object getValueAt(int row, int col) {
-		switch (col) {
-		case 0:
-			return feeders.get(row).getName();
-		case 1:
-			return feeders.get(row).getClass().getSimpleName();
-        case 2: {
-            Part part = feeders.get(row).getPart();
-            if (part == null) {
-                return null;
+    }
+
+    public void refresh() {
+        feeders = new ArrayList<>(configuration.getMachine().getFeeders());
+        fireTableDataChanged();
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (feeders == null) ? 0 : feeders.size();
+    }
+
+    public Feeder getFeeder(int index) {
+        return feeders.get(index);
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex == 0 || columnIndex == 3;
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Feeder feeder = feeders.get(rowIndex);
+            if (columnIndex == 0) {
+                feeder.setName((String) aValue);
             }
-            return part.getId();
+            else if (columnIndex == 3) {
+                feeder.setEnabled((Boolean) aValue);
+            }
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        if (columnIndex == 3) {
+            return Boolean.class;
+        }
+        return super.getColumnClass(columnIndex);
+    }
+
+    public Object getValueAt(int row, int col) {
+        switch (col) {
+            case 0:
+                return feeders.get(row).getName();
+            case 1:
+                return feeders.get(row).getClass().getSimpleName();
+            case 2: {
+                Part part = feeders.get(row).getPart();
+                if (part == null) {
+                    return null;
+                }
+                return part.getId();
+            }
+            case 3:
+                return feeders.get(row).isEnabled();
+            default:
+                return null;
         }
-        case 3:
-            return feeders.get(row).isEnabled();
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/FootprintTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/FootprintTableModel.java
index 846a06b5b0..195fe8cf31 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/FootprintTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/FootprintTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -32,66 +30,53 @@
 import org.openpnp.model.Length;
 
 public class FootprintTableModel extends AbstractTableModel {
-	private String[] columnNames = new String[] {
-	    "Name",
-        "X", 
-        "Y",
-        "Width",
-        "Height",
-		"ø",
-        "% Round"
-		};
-	
-	private Class[] columnTypes = new Class[] {
-        String.class,
-		LengthCellValue.class,
-        LengthCellValue.class,
-        LengthCellValue.class,
-        LengthCellValue.class,
-        String.class,
-        String.class
-	};
-	
-	final private Footprint footprint;
-	
-	public FootprintTableModel(Footprint footprint) {
-	    this.footprint = footprint;
-	}
-	
-	public Pad getPad(int index) {
-	    return footprint.getPads().get(index);
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-	    if (footprint == null) {
-	        return 0;
-	    }
-		return footprint.getPads().size();
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-	    return true;
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Pad pad = footprint.getPads().get(rowIndex);
+    private String[] columnNames =
+            new String[] {"Name", "X", "Y", "Width", "Height", "ø", "% Round"};
+
+    private Class[] columnTypes =
+            new Class[] {String.class, LengthCellValue.class, LengthCellValue.class,
+                    LengthCellValue.class, LengthCellValue.class, String.class, String.class};
+
+    final private Footprint footprint;
+
+    public FootprintTableModel(Footprint footprint) {
+        this.footprint = footprint;
+    }
+
+    public Pad getPad(int index) {
+        return footprint.getPads().get(index);
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        if (footprint == null) {
+            return 0;
+        }
+        return footprint.getPads().size();
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return true;
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Pad pad = footprint.getPads().get(rowIndex);
             if (columnIndex == 0) {
                 pad.setName((String) aValue);
             }
@@ -140,31 +125,33 @@ else if (columnIndex == 6) {
                 val = Math.min(val, 100);
                 pad.setRoundness(val);
             }
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-	
-	public Object getValueAt(int row, int col) {
-	    Pad pad = footprint.getPads().get(row);
-		switch (col) {
-	    case 0:
-	        return pad.getName();
-        case 1:
-            return new LengthCellValue(new Length(pad.getX(), footprint.getUnits()), true);
-        case 2:
-            return new LengthCellValue(new Length(pad.getY(), footprint.getUnits()), true);
-        case 3:
-            return new LengthCellValue(new Length(pad.getWidth(), footprint.getUnits()), true);
-        case 4:
-            return new LengthCellValue(new Length(pad.getHeight(), footprint.getUnits()), true);
-        case 5:
-            return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(), pad.getRotation());
-        case 6:
-            return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(), pad.getRoundness());
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    public Object getValueAt(int row, int col) {
+        Pad pad = footprint.getPads().get(row);
+        switch (col) {
+            case 0:
+                return pad.getName();
+            case 1:
+                return new LengthCellValue(new Length(pad.getX(), footprint.getUnits()), true);
+            case 2:
+                return new LengthCellValue(new Length(pad.getY(), footprint.getUnits()), true);
+            case 3:
+                return new LengthCellValue(new Length(pad.getWidth(), footprint.getUnits()), true);
+            case 4:
+                return new LengthCellValue(new Length(pad.getHeight(), footprint.getUnits()), true);
+            case 5:
+                return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                        pad.getRotation());
+            case 6:
+                return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                        pad.getRoundness());
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/HeadsTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/HeadsTableModel.java
index cdefdb10a0..fa233ac00e 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/HeadsTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/HeadsTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -31,52 +29,52 @@
 import org.openpnp.spi.Head;
 
 public class HeadsTableModel extends AbstractTableModel {
-	final private Configuration configuration;
-	
-	private String[] columnNames = new String[] { "Name", "Type" };
-	private List<Head> heads;
+    final private Configuration configuration;
+
+    private String[] columnNames = new String[] {"Name", "Type"};
+    private List<Head> heads;
 
-	public HeadsTableModel(Configuration configuration) {
-		this.configuration = configuration;
+    public HeadsTableModel(Configuration configuration) {
+        this.configuration = configuration;
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             public void configurationComplete(Configuration configuration) throws Exception {
                 heads = new ArrayList<>(configuration.getMachine().getHeads());
                 fireTableDataChanged();
             }
         });
-	}
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (heads == null) ? 0 : heads.size();
+    }
 
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
+    public Head getHead(int index) {
+        return heads.get(index);
+    }
 
-	public int getColumnCount() {
-		return columnNames.length;
-	}
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return false;
+    }
 
-	public int getRowCount() {
-		return (heads == null) ? 0 : heads.size();
-	}
-	
-	public Head getHead(int index) {
-		return heads.get(index);
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return false;
-	}
-	
-	public Object getValueAt(int row, int col) {
-		Head head = heads.get(row);
-		switch (col) {
-		case 0:
-			return head.getName();
-		case 1:
-			return head.getClass().getSimpleName();
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+    public Object getValueAt(int row, int col) {
+        Head head = heads.get(row);
+        switch (col) {
+            case 0:
+                return head.getName();
+            case 1:
+                return head.getClass().getSimpleName();
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/PackagesTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/PackagesTableModel.java
index b867c8c1ba..bad40791c6 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/PackagesTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/PackagesTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is package of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is package of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -30,84 +28,78 @@
 
 import org.openpnp.model.Configuration;
 import org.openpnp.model.Package;
-//import org.openpnp.model.Package;
+// import org.openpnp.model.Package;
 
 @SuppressWarnings("serial")
 public class PackagesTableModel extends AbstractTableModel implements PropertyChangeListener {
-	final private Configuration configuration;
-	
-	private String[] columnNames = new String[] { 
-		"Id", 
-		"Description"
-	};
-	private Class[] columnTypes = new Class[] {
-		String.class,
-		String.class,
-	};
-	private List<Package> packages;
-
-	public PackagesTableModel(Configuration configuration) {
-		this.configuration = configuration;
-		configuration.addPropertyChangeListener("packages", this);
-		packages = new ArrayList<>(configuration.getPackages());
-		
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		return (packages == null) ? 0 : packages.size();
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return columnIndex == 1;
-	}
-	
-	public Package getPackage(int index) {
-		return packages.get(index);
-	}
-
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Package this_package = packages.get(rowIndex);
-			if (columnIndex == 1) {
-				this_package.setDescription((String) aValue);
-			}
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-
-	public Object getValueAt(int row, int col) {
-		Package this_package = packages.get(row);
-		switch (col) {
-		case 0:
-			return this_package.getId();
-		case 1:
-			 return this_package.getDescription();
-		default:
-			return null;
-		}
-	}
-
-	@Override
-	public void propertyChange(PropertyChangeEvent arg0) {
-		packages = new ArrayList<>(configuration.getPackages());
-		fireTableDataChanged();
-	}
-}
\ No newline at end of file
+    final private Configuration configuration;
+
+    private String[] columnNames = new String[] {"Id", "Description"};
+    private Class[] columnTypes = new Class[] {String.class, String.class,};
+    private List<Package> packages;
+
+    public PackagesTableModel(Configuration configuration) {
+        this.configuration = configuration;
+        configuration.addPropertyChangeListener("packages", this);
+        packages = new ArrayList<>(configuration.getPackages());
+
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (packages == null) ? 0 : packages.size();
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex == 1;
+    }
+
+    public Package getPackage(int index) {
+        return packages.get(index);
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Package this_package = packages.get(rowIndex);
+            if (columnIndex == 1) {
+                this_package.setDescription((String) aValue);
+            }
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    public Object getValueAt(int row, int col) {
+        Package this_package = packages.get(row);
+        switch (col) {
+            case 0:
+                return this_package.getId();
+            case 1:
+                return this_package.getDescription();
+            default:
+                return null;
+        }
+    }
+
+    @Override
+    public void propertyChange(PropertyChangeEvent arg0) {
+        packages = new ArrayList<>(configuration.getPackages());
+        fireTableDataChanged();
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/PadsTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/PadsTableModel.java
index 8f6bc6887d..35f272a5ea 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/PadsTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/PadsTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -35,116 +33,107 @@
 import org.openpnp.model.Location;
 
 public class PadsTableModel extends AbstractTableModel {
-	final Configuration configuration;
-	
-	private String[] columnNames = new String[] {
-	    "Name",
-		"Side", 
-        "X", 
-        "Y", 
-		"ø",
-        "Type"
-		};
-	
-	private Class[] columnTypes = new Class[] {
-        String.class,
-		Side.class,
-        LengthCellValue.class,
-        LengthCellValue.class,
-		String.class,
-        Type.class
-	};
-	
-	private Board board;
-
-	public PadsTableModel(Configuration configuration) {
-		this.configuration = configuration;
-	}
-
-	public void setBoard(Board board) {
-		this.board = board;
-		fireTableDataChanged();
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		return (board == null) ? 0 : board.getSolderPastePads().size();
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-	    return true;
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			BoardPad pad = board.getSolderPastePads().get(rowIndex);
+    final Configuration configuration;
+
+    private String[] columnNames = new String[] {"Name", "Side", "X", "Y", "ø", "Type"};
+
+    private Class[] columnTypes = new Class[] {String.class, Side.class, LengthCellValue.class,
+            LengthCellValue.class, String.class, Type.class};
+
+    private Board board;
+
+    public PadsTableModel(Configuration configuration) {
+        this.configuration = configuration;
+    }
+
+    public void setBoard(Board board) {
+        this.board = board;
+        fireTableDataChanged();
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (board == null) ? 0 : board.getSolderPastePads().size();
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return true;
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            BoardPad pad = board.getSolderPastePads().get(rowIndex);
             if (columnIndex == 0) {
                 pad.setName((String) aValue);
             }
             else if (columnIndex == 1) {
                 pad.setSide((Side) aValue);
             }
-			else if (columnIndex == 2) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				value.setDisplayNativeUnits(true);
-				Length length = value.getLength();
-				Location location = pad.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.X, true);
-				pad.setLocation(location);
-			}
-			else if (columnIndex == 3) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				value.setDisplayNativeUnits(true);
-				Length length = value.getLength();
-				Location location = pad.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.Y, true);
-				pad.setLocation(location);
-			}
+            else if (columnIndex == 2) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                value.setDisplayNativeUnits(true);
+                Length length = value.getLength();
+                Location location = pad.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.X,
+                        true);
+                pad.setLocation(location);
+            }
+            else if (columnIndex == 3) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                value.setDisplayNativeUnits(true);
+                Length length = value.getLength();
+                Location location = pad.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.Y,
+                        true);
+                pad.setLocation(location);
+            }
             else if (columnIndex == 4) {
-                pad.setLocation(pad.getLocation().derive(null, null, null, Double.parseDouble(aValue.toString())));
+                pad.setLocation(pad.getLocation().derive(null, null, null,
+                        Double.parseDouble(aValue.toString())));
             }
             else if (columnIndex == 5) {
                 pad.setType((Type) aValue);
             }
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-	
-	public Object getValueAt(int row, int col) {
-		BoardPad pad = board.getSolderPastePads().get(row);
-		Location loc = pad.getLocation();
-		switch (col) {
-	    case 0:
-	        return pad.getName();
-        case 1:
-            return pad.getSide();
-		case 2:
-			return new LengthCellValue(loc.getLengthX(), true);
-		case 3:
-			return new LengthCellValue(loc.getLengthY(), true);
-		case 4:
-			return String.format(Locale.US,configuration.getLengthDisplayFormat(), loc.getRotation());
-        case 5:
-            return pad.getType();
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    public Object getValueAt(int row, int col) {
+        BoardPad pad = board.getSolderPastePads().get(row);
+        Location loc = pad.getLocation();
+        switch (col) {
+            case 0:
+                return pad.getName();
+            case 1:
+                return pad.getSide();
+            case 2:
+                return new LengthCellValue(loc.getLengthX(), true);
+            case 3:
+                return new LengthCellValue(loc.getLengthY(), true);
+            case 4:
+                return String.format(Locale.US, configuration.getLengthDisplayFormat(),
+                        loc.getRotation());
+            case 5:
+                return pad.getType();
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/PartsTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/PartsTableModel.java
index 5d4d60fc5f..f40508eb7c 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/PartsTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/PartsTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -37,112 +35,103 @@
 
 @SuppressWarnings("serial")
 public class PartsTableModel extends AbstractTableModel implements PropertyChangeListener {
-	private String[] columnNames = new String[] { 
-		"Id", 
-		"Description",
-		"Height", 
-		"Package",
-		"Speed (0 - 1)"
-	};
-	private Class[] columnTypes = new Class[] {
-		String.class,
-		String.class,
-		LengthCellValue.class,
-		Package.class,
-		String.class
-	};
-	private List<Part> parts;
+    private String[] columnNames =
+            new String[] {"Id", "Description", "Height", "Package", "Speed (0 - 1)"};
+    private Class[] columnTypes = new Class[] {String.class, String.class, LengthCellValue.class,
+            Package.class, String.class};
+    private List<Part> parts;
+
+    public PartsTableModel() {
+        Configuration.get().addPropertyChangeListener("parts", this);
+        parts = new ArrayList<>(Configuration.get().getParts());
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
 
-	public PartsTableModel() {
-		Configuration.get().addPropertyChangeListener("parts", this);
-		parts = new ArrayList<>(Configuration.get().getParts());
-	}
+    public int getRowCount() {
+        return (parts == null) ? 0 : parts.size();
+    }
 
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
 
-	public int getColumnCount() {
-		return columnNames.length;
-	}
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex != 0;
+    }
 
-	public int getRowCount() {
-		return (parts == null) ? 0 : parts.size();
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return columnIndex != 0;
-	}
-	
-	public Part getPart(int index) {
-		return parts.get(index);
-	}
+    public Part getPart(int index) {
+        return parts.get(index);
+    }
 
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Part part = parts.get(rowIndex);
-			if (columnIndex == 1) {
-				part.setName((String) aValue);
-			}
-			else if (columnIndex == 2) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				value.setDisplayNativeUnits(true);
-				Length length = value.getLength();
-				Length oldLength = part.getHeight();
-				if (length.getUnits() == null) {
-					if (oldLength != null) {
-						length.setUnits(oldLength.getUnits());
-					}
-					if (length.getUnits() == null) {
-						length.setUnits(Configuration.get().getSystemUnits());
-					}
-				}
-				part.setHeight(length);
-			}
-			else if (columnIndex == 3) {
-				part.setPackage((Package) aValue);
-			}
-			else if (columnIndex == 4) {
-			    double val = Double.parseDouble(aValue.toString());
-			    val = Math.max(0, val);
-			    val = Math.min(1, val);
-			    part.setSpeed(val);
-			}
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Part part = parts.get(rowIndex);
+            if (columnIndex == 1) {
+                part.setName((String) aValue);
+            }
+            else if (columnIndex == 2) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                value.setDisplayNativeUnits(true);
+                Length length = value.getLength();
+                Length oldLength = part.getHeight();
+                if (length.getUnits() == null) {
+                    if (oldLength != null) {
+                        length.setUnits(oldLength.getUnits());
+                    }
+                    if (length.getUnits() == null) {
+                        length.setUnits(Configuration.get().getSystemUnits());
+                    }
+                }
+                part.setHeight(length);
+            }
+            else if (columnIndex == 3) {
+                part.setPackage((Package) aValue);
+            }
+            else if (columnIndex == 4) {
+                double val = Double.parseDouble(aValue.toString());
+                val = Math.max(0, val);
+                val = Math.min(1, val);
+                part.setSpeed(val);
+            }
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
 
-	public Object getValueAt(int row, int col) {
-		Part part = parts.get(row);
-		switch (col) {
-		case 0:
-			return part.getId();
-		case 1:
-			 return part.getName();
-		case 2:
-			return new LengthCellValue(part.getHeight(), true);
-		case 3:
-			 return part.getPackage();
-		case 4:
-            return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(), part.getSpeed());
-		default:
-			return null;
-		}
-	}
+    public Object getValueAt(int row, int col) {
+        Part part = parts.get(row);
+        switch (col) {
+            case 0:
+                return part.getId();
+            case 1:
+                return part.getName();
+            case 2:
+                return new LengthCellValue(part.getHeight(), true);
+            case 3:
+                return part.getPackage();
+            case 4:
+                return String.format(Locale.US, Configuration.get().getLengthDisplayFormat(),
+                        part.getSpeed());
+            default:
+                return null;
+        }
+    }
 
-	@Override
-	public void propertyChange(PropertyChangeEvent arg0) {
-		parts = new ArrayList<>(Configuration.get().getParts());
-		fireTableDataChanged();
-	}
-}
\ No newline at end of file
+    @Override
+    public void propertyChange(PropertyChangeEvent arg0) {
+        parts = new ArrayList<>(Configuration.get().getParts());
+        fireTableDataChanged();
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/tablemodel/PlacementsTableModel.java b/src/main/java/org/openpnp/gui/tablemodel/PlacementsTableModel.java
index e04af6524f..93addd7b68 100755
--- a/src/main/java/org/openpnp/gui/tablemodel/PlacementsTableModel.java
+++ b/src/main/java/org/openpnp/gui/tablemodel/PlacementsTableModel.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.tablemodel;
 
@@ -37,156 +35,142 @@
 import org.openpnp.spi.Feeder;
 
 public class PlacementsTableModel extends AbstractTableModel {
-	final Configuration configuration;
-	
-	private String[] columnNames = new String[] {
-		"Id", 
-		"Part", 
-		"Side", 
-		"X", 
-		"Y", 
-		"ø",
-		"Type",
-		"Status"
-		};
-	
-	private Class[] columnTypes = new Class[] {
-		String.class,
-		Part.class,
-		Side.class,
-		LengthCellValue.class,
-		LengthCellValue.class,
-		String.class,
-		Type.class,
-		Status.class
-	};
-	
-	public enum Status {
-	    Ready,
-	    MissingPart,
-	    MissingFeeder,
-	    ZeroPartHeight
-	}
-	
-	private Board board;
-
-	public PlacementsTableModel(Configuration configuration) {
-		this.configuration = configuration;
-	}
-
-	public void setBoard(Board board) {
-		this.board = board;
-		fireTableDataChanged();
-	}
-
-	@Override
-	public String getColumnName(int column) {
-		return columnNames[column];
-	}
-
-	public int getColumnCount() {
-		return columnNames.length;
-	}
-
-	public int getRowCount() {
-		return (board == null) ? 0 : board.getPlacements().size();
-	}
-	
-	@Override
-	public boolean isCellEditable(int rowIndex, int columnIndex) {
-		return columnIndex == 1 || columnIndex == 2 || columnIndex == 3 || columnIndex == 4 || columnIndex == 5 || columnIndex == 6;
-	}
-	
-	@Override
-	public Class<?> getColumnClass(int columnIndex) {
-		return columnTypes[columnIndex];
-	}
-
-	@Override
-	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
-		try {
-			Placement placement = board.getPlacements().get(rowIndex);
-			if (columnIndex == 1) {
-				placement.setPart((Part) aValue);
-			}
-			else if (columnIndex == 2) {
-				placement.setSide((Side) aValue);
-			}
-			else if (columnIndex == 3) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				value.setDisplayNativeUnits(true);
-				Length length = value.getLength();
-				Location location = placement.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.X, true);
-				placement.setLocation(location);
-			}
-			else if (columnIndex == 4) {
-				LengthCellValue value = (LengthCellValue) aValue;
-				value.setDisplayNativeUnits(true);
-				Length length = value.getLength();
-				Location location = placement.getLocation();
-				location = Length.setLocationField(configuration, location, length, Length.Field.Y, true);
-				placement.setLocation(location);
-			}
+    final Configuration configuration;
+
+    private String[] columnNames =
+            new String[] {"Id", "Part", "Side", "X", "Y", "ø", "Type", "Status"};
+
+    private Class[] columnTypes = new Class[] {String.class, Part.class, Side.class,
+            LengthCellValue.class, LengthCellValue.class, String.class, Type.class, Status.class};
+
+    public enum Status {
+        Ready, MissingPart, MissingFeeder, ZeroPartHeight
+    }
+
+    private Board board;
+
+    public PlacementsTableModel(Configuration configuration) {
+        this.configuration = configuration;
+    }
+
+    public void setBoard(Board board) {
+        this.board = board;
+        fireTableDataChanged();
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    public int getRowCount() {
+        return (board == null) ? 0 : board.getPlacements().size();
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex == 1 || columnIndex == 2 || columnIndex == 3 || columnIndex == 4
+                || columnIndex == 5 || columnIndex == 6;
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnTypes[columnIndex];
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        try {
+            Placement placement = board.getPlacements().get(rowIndex);
+            if (columnIndex == 1) {
+                placement.setPart((Part) aValue);
+            }
+            else if (columnIndex == 2) {
+                placement.setSide((Side) aValue);
+            }
+            else if (columnIndex == 3) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                value.setDisplayNativeUnits(true);
+                Length length = value.getLength();
+                Location location = placement.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.X,
+                        true);
+                placement.setLocation(location);
+            }
+            else if (columnIndex == 4) {
+                LengthCellValue value = (LengthCellValue) aValue;
+                value.setDisplayNativeUnits(true);
+                Length length = value.getLength();
+                Location location = placement.getLocation();
+                location = Length.setLocationField(configuration, location, length, Length.Field.Y,
+                        true);
+                placement.setLocation(location);
+            }
             else if (columnIndex == 5) {
-                placement.setLocation(placement.getLocation().derive(null, null, null, Double.parseDouble(aValue.toString())));
+                placement.setLocation(placement.getLocation().derive(null, null, null,
+                        Double.parseDouble(aValue.toString())));
             }
             else if (columnIndex == 6) {
                 placement.setType((Type) aValue);
             }
-		}
-		catch (Exception e) {
-			// TODO: dialog, bad input
-		}
-	}
-	
-	// TODO: Ideally this would all come from the JobPlanner, but this is a
-	// good start for now.
-	private Status getPlacementStatus(Placement placement) {
-	    if (placement.getPart() == null) {
-	        return Status.MissingPart;
-	    }
-	    if (placement.getType() == Placement.Type.Place) {
-	        boolean found = false;
-	        for (Feeder feeder : Configuration.get().getMachine().getFeeders()) {
-	            if (feeder.getPart() == placement.getPart() && feeder.isEnabled()) {
-	                found = true;
-	                break;
-	            }
-	        }
-	        if (!found) {
-	            return Status.MissingFeeder;
-	        }
-	        
-	        if (placement.getPart().getHeight().getValue() == 0) {
-	            return Status.ZeroPartHeight;
-	        }
-	    }
-	    return Status.Ready;
-	}
-
-	public Object getValueAt(int row, int col) {
-		Placement placement = board.getPlacements().get(row);
-		Location loc = placement.getLocation();
-		switch (col) {
-		case 0:
-			 return placement.getId();
-		case 1:
-			return placement.getPart();
-		case 2:
-			 return placement.getSide();
-		case 3:
-			return new LengthCellValue(loc.getLengthX(), true);
-		case 4:
-			return new LengthCellValue(loc.getLengthY(), true);
-		case 5:
-			return String.format(Locale.US,configuration.getLengthDisplayFormat(), loc.getRotation());
-		case 6:
-		    return placement.getType();
-		case 7:
-		    return getPlacementStatus(placement);
-		default:
-			return null;
-		}
-	}
-}
\ No newline at end of file
+        }
+        catch (Exception e) {
+            // TODO: dialog, bad input
+        }
+    }
+
+    // TODO: Ideally this would all come from the JobPlanner, but this is a
+    // good start for now.
+    private Status getPlacementStatus(Placement placement) {
+        if (placement.getPart() == null) {
+            return Status.MissingPart;
+        }
+        if (placement.getType() == Placement.Type.Place) {
+            boolean found = false;
+            for (Feeder feeder : Configuration.get().getMachine().getFeeders()) {
+                if (feeder.getPart() == placement.getPart() && feeder.isEnabled()) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                return Status.MissingFeeder;
+            }
+
+            if (placement.getPart().getHeight().getValue() == 0) {
+                return Status.ZeroPartHeight;
+            }
+        }
+        return Status.Ready;
+    }
+
+    public Object getValueAt(int row, int col) {
+        Placement placement = board.getPlacements().get(row);
+        Location loc = placement.getLocation();
+        switch (col) {
+            case 0:
+                return placement.getId();
+            case 1:
+                return placement.getPart();
+            case 2:
+                return placement.getSide();
+            case 3:
+                return new LengthCellValue(loc.getLengthX(), true);
+            case 4:
+                return new LengthCellValue(loc.getLengthY(), true);
+            case 5:
+                return String.format(Locale.US, configuration.getLengthDisplayFormat(),
+                        loc.getRotation());
+            case 6:
+                return placement.getType();
+            case 7:
+                return getPlacementStatus(placement);
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/gui/wizards/CameraConfigurationWizard.java b/src/main/java/org/openpnp/gui/wizards/CameraConfigurationWizard.java
index bfe9d97b0a..a3a239ffa4 100755
--- a/src/main/java/org/openpnp/gui/wizards/CameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/gui/wizards/CameraConfigurationWizard.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.gui.wizards;
 
@@ -42,7 +40,6 @@
 import org.openpnp.gui.support.AbstractConfigurationWizard;
 import org.openpnp.gui.support.LengthConverter;
 import org.openpnp.gui.support.LongConverter;
-import org.openpnp.gui.support.MessageBoxes;
 import org.openpnp.gui.support.MutableLocationProxy;
 import org.openpnp.model.Configuration;
 import org.openpnp.spi.Camera;
@@ -54,164 +51,156 @@
 
 @SuppressWarnings("serial")
 public class CameraConfigurationWizard extends AbstractConfigurationWizard {
-	private final Camera camera;
-	private JPanel panelUpp;
-	private JButton btnMeasure;
-	private JButton btnCancelMeasure;
+    private final Camera camera;
+    private JPanel panelUpp;
+    private JButton btnMeasure;
+    private JButton btnCancelMeasure;
     private JLabel lblUppInstructions;
-	
-	public CameraConfigurationWizard(Camera camera) {
-		this.camera = camera;
-
-		panelUpp = new JPanel();
-		contentPanel.add(panelUpp);
-		panelUpp.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "Units Per Pixel", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
-		panelUpp.setLayout(new FormLayout(new ColumnSpec[] {
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,},
-		    new RowSpec[] {
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		lblWidth = new JLabel("Width");
-		panelUpp.add(lblWidth, "2, 2");
-		
-		lblHeight = new JLabel("Height");
-		panelUpp.add(lblHeight, "4, 2");
-		
-		lblX = new JLabel("X");
-		panelUpp.add(lblX, "6, 2");
-		
-		lblY = new JLabel("Y");
-		panelUpp.add(lblY, "8, 2");
-		
-		textFieldWidth = new JTextField();
-		textFieldWidth.setText("1");
-		panelUpp.add(textFieldWidth, "2, 4");
-		textFieldWidth.setColumns(8);
-		
-		textFieldHeight = new JTextField();
-		textFieldHeight.setText("1");
-		panelUpp.add(textFieldHeight, "4, 4");
-		textFieldHeight.setColumns(8);
-		
-		textFieldUppX = new JTextField();
-		textFieldUppX.setColumns(8);
-		panelUpp.add(textFieldUppX, "6, 4, fill, default");
-		
-		textFieldUppY = new JTextField();
-		textFieldUppY.setColumns(8);
-		panelUpp.add(textFieldUppY, "8, 4, fill, default");
-		
-		btnMeasure = new JButton("Measure");
-		btnMeasure.setAction(measureAction);
-		panelUpp.add(btnMeasure, "10, 4");
-
-		btnCancelMeasure = new JButton("Cancel");
-		btnCancelMeasure.setAction(cancelMeasureAction);
-		panelUpp.add(btnCancelMeasure, "12, 4");
-		
-		lblUppInstructions = new JLabel("<html>\n<ol>\n<li>Place an object with a known width and height on the table. Graphing paper is a good, easy choice for this.\n<li>Enter the width and height of the object into the Width and Height fields.\n<li>Jog the camera to where it is centered over the object and in focus.\n<li>Press Measure and use the camera selection rectangle to measure the object. Press Confirm when finished.\n<li>The calculated units per pixel values will be inserted into the X and Y fields.\n</ol>\n</html>");
-		panelUpp.add(lblUppInstructions, "2, 6, 10, 1, default, fill");
-		
-		panelVision = new JPanel();
-		panelVision.setBorder(new TitledBorder(null, "Vision", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		contentPanel.add(panelVision);
-		panelVision.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		lblSettleTimems = new JLabel("Settle Time (ms)");
-		panelVision.add(lblSettleTimems, "2, 2, right, default");
-		
-		textFieldSettleTime = new JTextField();
-		panelVision.add(textFieldSettleTime, "4, 2, fill, default");
-		textFieldSettleTime.setColumns(10);
-	}
-
-	@Override
-	public void createBindings() {
-		LengthConverter lengthConverter = new LengthConverter();
+
+    public CameraConfigurationWizard(Camera camera) {
+        this.camera = camera;
+
+        panelUpp = new JPanel();
+        contentPanel.add(panelUpp);
+        panelUpp.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Units Per Pixel", TitledBorder.LEADING, TitledBorder.TOP, null,
+                new Color(0, 0, 0)));
+        panelUpp.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        lblWidth = new JLabel("Width");
+        panelUpp.add(lblWidth, "2, 2");
+
+        lblHeight = new JLabel("Height");
+        panelUpp.add(lblHeight, "4, 2");
+
+        lblX = new JLabel("X");
+        panelUpp.add(lblX, "6, 2");
+
+        lblY = new JLabel("Y");
+        panelUpp.add(lblY, "8, 2");
+
+        textFieldWidth = new JTextField();
+        textFieldWidth.setText("1");
+        panelUpp.add(textFieldWidth, "2, 4");
+        textFieldWidth.setColumns(8);
+
+        textFieldHeight = new JTextField();
+        textFieldHeight.setText("1");
+        panelUpp.add(textFieldHeight, "4, 4");
+        textFieldHeight.setColumns(8);
+
+        textFieldUppX = new JTextField();
+        textFieldUppX.setColumns(8);
+        panelUpp.add(textFieldUppX, "6, 4, fill, default");
+
+        textFieldUppY = new JTextField();
+        textFieldUppY.setColumns(8);
+        panelUpp.add(textFieldUppY, "8, 4, fill, default");
+
+        btnMeasure = new JButton("Measure");
+        btnMeasure.setAction(measureAction);
+        panelUpp.add(btnMeasure, "10, 4");
+
+        btnCancelMeasure = new JButton("Cancel");
+        btnCancelMeasure.setAction(cancelMeasureAction);
+        panelUpp.add(btnCancelMeasure, "12, 4");
+
+        lblUppInstructions = new JLabel(
+                "<html>\n<ol>\n<li>Place an object with a known width and height on the table. Graphing paper is a good, easy choice for this.\n<li>Enter the width and height of the object into the Width and Height fields.\n<li>Jog the camera to where it is centered over the object and in focus.\n<li>Press Measure and use the camera selection rectangle to measure the object. Press Confirm when finished.\n<li>The calculated units per pixel values will be inserted into the X and Y fields.\n</ol>\n</html>");
+        panelUpp.add(lblUppInstructions, "2, 6, 10, 1, default, fill");
+
+        panelVision = new JPanel();
+        panelVision.setBorder(new TitledBorder(null, "Vision", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        contentPanel.add(panelVision);
+        panelVision.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        lblSettleTimems = new JLabel("Settle Time (ms)");
+        panelVision.add(lblSettleTimems, "2, 2, right, default");
+
+        textFieldSettleTime = new JTextField();
+        panelVision.add(textFieldSettleTime, "4, 2, fill, default");
+        textFieldSettleTime.setColumns(10);
+    }
+
+    @Override
+    public void createBindings() {
+        LengthConverter lengthConverter = new LengthConverter();
         LongConverter longConverter = new LongConverter();
-        
-		MutableLocationProxy unitsPerPixel = new MutableLocationProxy();
+
+        MutableLocationProxy unitsPerPixel = new MutableLocationProxy();
         bind(UpdateStrategy.READ_WRITE, camera, "unitsPerPixel", unitsPerPixel, "location");
         addWrappedBinding(unitsPerPixel, "lengthX", textFieldUppX, "text", lengthConverter);
         addWrappedBinding(unitsPerPixel, "lengthY", textFieldUppY, "text", lengthConverter);
-        
+
         addWrappedBinding(camera, "settleTimeMs", textFieldSettleTime, "text", longConverter);
 
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldUppX);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldUppY);
-        
+
         ComponentDecorators.decorateWithAutoSelect(textFieldWidth);
         ComponentDecorators.decorateWithAutoSelect(textFieldHeight);
         ComponentDecorators.decorateWithAutoSelect(textFieldSettleTime);
-	}
-	
-	private Action measureAction = new AbstractAction("Measure") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			btnMeasure.setAction(confirmMeasureAction);
-			cancelMeasureAction.setEnabled(true);
-			CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
-			cameraView.setSelectionEnabled(true);
-			cameraView.setSelection(0, 0, 100, 100);
-		}
-	};
-	
-	private Action confirmMeasureAction = new AbstractAction("Confirm") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			btnMeasure.setAction(measureAction);
-			cancelMeasureAction.setEnabled(false);
-			CameraView cameraView = MainFrame.cameraPanel.getCameraView(camera);
-			cameraView.setSelectionEnabled(false);
-			Rectangle selection = cameraView.getSelection();
+    }
+
+    private Action measureAction = new AbstractAction("Measure") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            btnMeasure.setAction(confirmMeasureAction);
+            cancelMeasureAction.setEnabled(true);
+            CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+            cameraView.setSelectionEnabled(true);
+            cameraView.setSelection(0, 0, 100, 100);
+        }
+    };
+
+    private Action confirmMeasureAction = new AbstractAction("Confirm") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            btnMeasure.setAction(measureAction);
+            cancelMeasureAction.setEnabled(false);
+            CameraView cameraView = MainFrame.cameraPanel.getCameraView(camera);
+            cameraView.setSelectionEnabled(false);
+            Rectangle selection = cameraView.getSelection();
             double width = Double.parseDouble(textFieldWidth.getText());
             double height = Double.parseDouble(textFieldHeight.getText());
-			textFieldUppX.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), (width / selection.width)));
-			textFieldUppY.setText(String.format(Locale.US,Configuration.get().getLengthDisplayFormat(), (height / selection.height)));
-		}
-	};
-	
-	private Action cancelMeasureAction = new AbstractAction("Cancel") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			btnMeasure.setAction(measureAction);
-			cancelMeasureAction.setEnabled(false);
-			CameraView cameraView = MainFrame.cameraPanel.getCameraView(camera);
-			cameraView.setSelectionEnabled(false);
-		}
-	};
-	private JTextField textFieldWidth;
-	private JTextField textFieldHeight;
-	private JTextField textFieldUppX;
-	private JTextField textFieldUppY;
-	private JLabel lblWidth;
-	private JLabel lblHeight;
-	private JLabel lblX;
-	private JLabel lblY;
-	private JPanel panelVision;
-	private JLabel lblSettleTimems;
-	private JTextField textFieldSettleTime;
-}
\ No newline at end of file
+            textFieldUppX.setText(String.format(Locale.US,
+                    Configuration.get().getLengthDisplayFormat(), (width / selection.width)));
+            textFieldUppY.setText(String.format(Locale.US,
+                    Configuration.get().getLengthDisplayFormat(), (height / selection.height)));
+        }
+    };
+
+    private Action cancelMeasureAction = new AbstractAction("Cancel") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            btnMeasure.setAction(measureAction);
+            cancelMeasureAction.setEnabled(false);
+            CameraView cameraView = MainFrame.cameraPanel.getCameraView(camera);
+            cameraView.setSelectionEnabled(false);
+        }
+    };
+    private JTextField textFieldWidth;
+    private JTextField textFieldHeight;
+    private JTextField textFieldUppX;
+    private JTextField textFieldUppY;
+    private JLabel lblWidth;
+    private JLabel lblHeight;
+    private JLabel lblX;
+    private JLabel lblY;
+    private JPanel panelVision;
+    private JLabel lblSettleTimems;
+    private JTextField textFieldSettleTime;
+}
diff --git a/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriver.java b/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriver.java
index 841f3a8f12..7a9e0b3de6 100755
--- a/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriver.java
+++ b/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriver.java
@@ -27,21 +27,21 @@
 public class OpenBuildsDriver extends AbstractSerialPortDriver implements Runnable {
     private static final Logger logger = LoggerFactory.getLogger(OpenBuildsDriver.class);
 
-    @Attribute(required=false)
+    @Attribute(required = false)
     protected double feedRateMmPerMinute = 5000;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private double zCamRadius = 24;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private double zCamWheelRadius = 9.5;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private double zGap = 2;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private boolean homeZ = false;
-    
+
     protected double x, y, zA, c, c2;
     private Thread readerThread;
     private boolean disconnectRequested;
@@ -49,7 +49,7 @@
     private boolean connected;
     private LinkedBlockingQueue<String> responseQueue = new LinkedBlockingQueue<>();
     private boolean n1Picked, n2Picked;
-    
+
     @Override
     public void setEnabled(boolean enabled) throws Exception {
         if (enabled && !connected) {
@@ -71,11 +71,11 @@ public void setEnabled(boolean enabled) throws Exception {
                 n2Exhaust(false);
                 led(false);
                 pump(false);
-                
+
             }
         }
     }
-    
+
     @Override
     public void home(ReferenceHead head) throws Exception {
         if (homeZ) {
@@ -103,41 +103,37 @@ public void home(ReferenceHead head) throws Exception {
         // Update position
         getCurrentPosition();
     }
-    
-    
+
+
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
-//        if (actuator.getIndex() == 0) {
-//            sendCommand(on ? actuatorOnGcode : actuatorOffGcode);
-//            dwell();
-//        }
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        // if (actuator.getIndex() == 0) {
+        // sendCommand(on ? actuatorOnGcode : actuatorOffGcode);
+        // dwell();
+        // }
     }
-    
-    
-    
+
+
+
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
-    }
-    
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {}
+
 
     @Override
     public Location getLocation(ReferenceHeadMountable hm) {
         if (hm instanceof ReferenceNozzle) {
-        	ReferenceNozzle nozzle = (ReferenceNozzle) hm;
+            ReferenceNozzle nozzle = (ReferenceNozzle) hm;
             double z = Math.sin(Math.toRadians(this.zA)) * zCamRadius;
             if (((ReferenceNozzle) hm).getName().equals("N2")) {
                 z = -z;
             }
-            z += zCamWheelRadius + zGap;                
+            z += zCamWheelRadius + zGap;
             int tool = (nozzle == null || nozzle.getName().equals("N1")) ? 0 : 1;
-            return new Location(LengthUnit.Millimeters, x, y, z, tool == 0 ? c : c2).add(hm
-                    .getHeadOffsets());
+            return new Location(LengthUnit.Millimeters, x, y, z, tool == 0 ? c : c2)
+                    .add(hm.getHeadOffsets());
         }
         else {
-            return new Location(LengthUnit.Millimeters, x, y, zA, c).add(hm
-                    .getHeadOffsets());
+            return new Location(LengthUnit.Millimeters, x, y, zA, c).add(hm.getHeadOffsets());
         }
     }
 
@@ -147,24 +143,24 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
+
         ReferenceNozzle nozzle = null;
         if (hm instanceof ReferenceNozzle) {
             nozzle = (ReferenceNozzle) hm;
         }
-        
+
         /*
          * Only move Z if it's a Nozzle.
          */
         if (nozzle == null) {
             z = Double.NaN;
         }
-        
+
         StringBuffer sb = new StringBuffer();
         if (!Double.isNaN(x) && x != this.x) {
             sb.append(String.format(Locale.US, "X%2.2f ", x));
@@ -176,9 +172,9 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         }
         int tool = (nozzle == null || nozzle.getName().equals("N1")) ? 0 : 1;
         if (!Double.isNaN(c) && c != (tool == 0 ? this.c : this.c2)) {
-        	// If there is an E move we need to set the tool before
-        	// performing any commands otherwise we may move the wrong tool.
-        	sendCommand(String.format(Locale.US, "T%d", tool));
+            // If there is an E move we need to set the tool before
+            // performing any commands otherwise we may move the wrong tool.
+            sendCommand(String.format(Locale.US, "T%d", tool));
             if (sb.length() == 0) {
                 // If the move won't contain an X or Y component but will
                 // have an E component we need to send the E component as a
@@ -191,16 +187,16 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
                 sb.append(String.format(Locale.US, "E%2.2f ", c));
             }
             if (tool == 0) {
-            	this.c = c;
+                this.c = c;
             }
             else {
-            	this.c2 = c;
+                this.c2 = c;
             }
         }
-        
+
         if (!Double.isNaN(z)) {
             double a = Math.toDegrees(Math.asin((z - zCamWheelRadius - zGap) / zCamRadius));
-            logger.debug("nozzle {} {} {}", new Object[] { z, zCamRadius, a });
+            logger.debug("nozzle {} {} {}", new Object[] {z, zCamRadius, a});
             if (nozzle.getName().equals("N2")) {
                 a = -a;
             }
@@ -209,14 +205,14 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
                 this.zA = a;
             }
         }
-        
+
         if (sb.length() > 0) {
             sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute));
             sendCommand("G0 " + sb.toString());
             dwell();
         }
     }
-    
+
     @Override
     public void pick(ReferenceNozzle nozzle) throws Exception {
         if (((ReferenceNozzle) nozzle).getName().equals("N1")) {
@@ -256,24 +252,23 @@ public void place(ReferenceNozzle nozzle) throws Exception {
             n2Exhaust(false);
         }
     }
-    
-    public synchronized void connect()
-            throws Exception {
+
+    public synchronized void connect() throws Exception {
         super.connect();
-        
+
         /**
          * Connection process notes:
          * 
-         * On some platforms, as soon as we open the serial port it will reset
-         * the controller and we'll start getting some data. On others, it may
-         * already be running and we will get nothing on connect.
+         * On some platforms, as soon as we open the serial port it will reset the controller and
+         * we'll start getting some data. On others, it may already be running and we will get
+         * nothing on connect.
          */
 
         connected = false;
         List<String> responses;
         readerThread = new Thread(this);
         readerThread.start();
-            
+
         try {
             do {
                 // Consume any buffered incoming data, including startup messages
@@ -283,40 +278,40 @@ public synchronized void connect()
         catch (Exception e) {
             // ignore timeouts
         }
-            
-        
-    	// Send a request to force Smoothie to respond and clear any buffers.
+
+
+        // Send a request to force Smoothie to respond and clear any buffers.
         // On my machine, at least, this causes Smoothie to re-send it's
         // startup message and I can't figure out why, but this works
         // around it.
-    	responses = sendCommand("M114", 5000);
-    	// Continue to read responses until we get the one that is the
-    	// result of the M114 command. When we see that we're connected.
-    	long t = System.currentTimeMillis();
-    	while (System.currentTimeMillis() - t < 5000) {
+        responses = sendCommand("M114", 5000);
+        // Continue to read responses until we get the one that is the
+        // result of the M114 command. When we see that we're connected.
+        long t = System.currentTimeMillis();
+        while (System.currentTimeMillis() - t < 5000) {
             for (String response : responses) {
-            	if (response.contains("X:")) {
-            		connected = true;
-            		break;
-            	}
+                if (response.contains("X:")) {
+                    connected = true;
+                    break;
+                }
             }
             if (connected) {
-            	break;
+                break;
             }
             responses = sendCommand(null, 200);
-    	}
+        }
 
-        if (!connected)  {
-            throw new Exception(
-                String.format("Unable to receive connection response. Check your port and baud rate"));
+        if (!connected) {
+            throw new Exception(String.format(
+                    "Unable to receive connection response. Check your port and baud rate"));
         }
-        
+
         // We are connected to at least the minimum required version now
         // So perform some setup
-        
+
         // Turn off the stepper drivers
         setEnabled(false);
-        
+
         // Set mm coordinate mode
         sendCommand("G21");
         // Set absolute positioning mode
@@ -325,10 +320,10 @@ public synchronized void connect()
         sendCommand("M82");
         getCurrentPosition();
     }
-    
+
     protected void getCurrentPosition() throws Exception {
         List<String> responses;
-    	sendCommand("T0");
+        sendCommand("T0");
         responses = sendCommand("M114");
         for (String response : responses) {
             if (response.contains("X:")) {
@@ -349,7 +344,7 @@ else if (comp.startsWith("E:")) {
                 }
             }
         }
-    	sendCommand("T1");
+        sendCommand("T1");
         responses = sendCommand("M114");
         for (String response : responses) {
             if (response.contains("X:")) {
@@ -362,13 +357,13 @@ else if (comp.startsWith("E:")) {
             }
         }
         sendCommand("T0");
-        logger.debug("Current Position is {}, {}, {}, {}, {}", new Object[] { x, y, zA, c, c2 });
+        logger.debug("Current Position is {}, {}, {}, {}, {}", new Object[] {x, y, zA, c, c2});
     }
-    
+
     public synchronized void disconnect() {
         disconnectRequested = true;
         connected = false;
-        
+
         try {
             if (readerThread != null && readerThread.isAlive()) {
                 readerThread.join();
@@ -377,7 +372,7 @@ public synchronized void disconnect() {
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-        
+
         try {
             super.disconnect();
         }
@@ -390,10 +385,10 @@ public synchronized void disconnect() {
     protected List<String> sendCommand(String command) throws Exception {
         return sendCommand(command, 5000);
     }
-    
+
     protected List<String> sendCommand(String command, long timeout) throws Exception {
         List<String> responses = new ArrayList<>();
-        
+
         // Read any responses that might be queued up so that when we wait
         // for a response to a command we actually wait for the one we expect.
         responseQueue.drainTo(responses);
@@ -421,14 +416,14 @@ public synchronized void disconnect() {
         }
         // And if we got one, add it to the list of responses we'll return.
         responses.add(response);
-        
+
         // Read any additional responses that came in after the initial one.
         responseQueue.drainTo(responses);
 
         logger.debug("{} => {}", command, responses);
         return responses;
     }
-    
+
     public void run() {
         while (!disconnectRequested) {
             String line;
@@ -456,6 +451,7 @@ public void run() {
 
     /**
      * Block until all movement is complete.
+     * 
      * @throws Exception
      */
     protected void dwell() throws Exception {
@@ -470,7 +466,7 @@ protected void dwell() throws Exception {
         }
         return responses;
     }
-    
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName();
@@ -490,36 +486,34 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Wizard getConfigurationWizard() {
         return new OpenBuildsDriverWizard(this);
     }
-    
+
     private void n1Vacuum(boolean on) throws Exception {
         sendCommand(on ? "M800" : "M801");
     }
-    
+
     private void n1Exhaust(boolean on) throws Exception {
         sendCommand(on ? "M802" : "M803");
     }
-    
+
     private void n2Vacuum(boolean on) throws Exception {
         sendCommand(on ? "M804" : "M805");
     }
-    
+
     private void n2Exhaust(boolean on) throws Exception {
         sendCommand(on ? "M806" : "M807");
     }
-    
+
     private void pump(boolean on) throws Exception {
         sendCommand(on ? "M808" : "M809");
     }
-    
+
     private void led(boolean on) throws Exception {
         sendCommand(on ? "M810" : "M811");
     }
diff --git a/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriverWizard.java b/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriverWizard.java
index c3d66a8565..8b3e00c680 100755
--- a/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriverWizard.java
+++ b/src/main/java/org/openpnp/machine/openbuilds/OpenBuildsDriverWizard.java
@@ -4,7 +4,7 @@
 
 public class OpenBuildsDriverWizard extends AbstractSerialPortDriverConfigurationWizard {
     private final OpenBuildsDriver driver;
-    
+
     public OpenBuildsDriverWizard(OpenBuildsDriver driver) {
         super(driver);
         this.driver = driver;
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceActuator.java b/src/main/java/org/openpnp/machine/reference/ReferenceActuator.java
index cc8300c090..3d954ccd51 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceActuator.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceActuator.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference;
 
@@ -39,16 +37,15 @@
 import org.slf4j.LoggerFactory;
 
 public class ReferenceActuator extends AbstractActuator implements ReferenceHeadMountable {
-    protected final static Logger logger = LoggerFactory
-            .getLogger(ReferenceActuator.class);
-    
+    protected final static Logger logger = LoggerFactory.getLogger(ReferenceActuator.class);
+
     @Element
     private Location headOffsets;
-    
-	@Attribute
-	private int index;
-	
-    @Element(required=false)
+
+    @Attribute
+    private int index;
+
+    @Element(required = false)
     protected Length safeZ = new Length(0, LengthUnit.Millimeters);
 
     protected ReferenceMachine machine;
@@ -57,72 +54,71 @@
     public ReferenceActuator() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 machine = (ReferenceMachine) configuration.getMachine();
                 driver = machine.getDriver();
             }
         });
     }
-    
+
     @Override
     public void setHeadOffsets(Location headOffsets) {
         this.headOffsets = headOffsets;
     }
-    
+
     @Override
     public Location getHeadOffsets() {
         return headOffsets;
     }
 
-	public int getIndex() {
-		return index;
-	}
+    public int getIndex() {
+        return index;
+    }
+
+    @Override
+    public void actuate(boolean on) throws Exception {
+        logger.debug("{}.actuate({})", new Object[] {getName(), on});
+        driver.actuate(this, on);
+        machine.fireMachineHeadActivity(head);
+    }
 
-	@Override
-	public void actuate(boolean on) throws Exception {
-		logger.debug("{}.actuate({})", new Object[] { getName(), on } );
-		driver.actuate(this, on);
-		machine.fireMachineHeadActivity(head);
-	}
-	
-	@Override
+    @Override
     public Location getLocation() {
-	    return driver.getLocation(this);
+        return driver.getLocation(this);
     }
 
     @Override
     public void actuate(double value) throws Exception {
-		logger.debug("{}.actuate({})", new Object[] { getName(), value } );
-		driver.actuate(this, value);
+        logger.debug("{}.actuate({})", new Object[] {getName(), value});
+        driver.actuate(this, value);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
     public void moveTo(Location location, double speed) throws Exception {
-		logger.debug("{}.moveTo({}, {})", new Object[] { getName(), location, speed } );
-		driver.moveTo(this, location, speed);
+        logger.debug("{}.moveTo({}, {})", new Object[] {getName(), location, speed});
+        driver.moveTo(this, location, speed);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
     public void moveToSafeZ(double speed) throws Exception {
-        logger.debug("{}.moveToSafeZ({})", new Object[] { getName(), speed } );
+        logger.debug("{}.moveToSafeZ({})", new Object[] {getName(), speed});
         Length safeZ = this.safeZ.convertToUnits(getLocation().getUnits());
-        Location l = new Location(getLocation().getUnits(), Double.NaN,
-                Double.NaN, safeZ.getValue(), Double.NaN);
+        Location l = new Location(getLocation().getUnits(), Double.NaN, Double.NaN,
+                safeZ.getValue(), Double.NaN);
         driver.moveTo(this, l, speed);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
-	public Wizard getConfigurationWizard() {
-		return new ReferenceActuatorConfigurationWizard(this);
-	}
-    
-	@Override
+    public Wizard getConfigurationWizard() {
+        return new ReferenceActuatorConfigurationWizard(this);
+    }
+
+    @Override
     public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName() + " " + getName();
+        return getClass().getSimpleName() + " " + getName();
     }
 
     @Override
@@ -133,11 +129,9 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -145,15 +139,15 @@ public String getPropertySheetHolderTitle() {
     }
 
     @Override
-	public String toString() {
-		return getName();
-	}
+    public String toString() {
+        return getName();
+    }
 
-	public Length getSafeZ() {
-		return safeZ;
-	}
+    public Length getSafeZ() {
+        return safeZ;
+    }
 
-	public void setSafeZ(Length safeZ) {
-		this.safeZ = safeZ;
-	}
+    public void setSafeZ(Length safeZ) {
+        this.safeZ = safeZ;
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceCamera.java b/src/main/java/org/openpnp/machine/reference/ReferenceCamera.java
index 75652b68b6..7661ff2340 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceCamera.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceCamera.java
@@ -1,28 +1,24 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
 
-import java.awt.Graphics2D;
-import java.awt.geom.AffineTransform;
 import java.awt.image.BufferedImage;
 import java.io.IOException;
 
@@ -52,83 +48,81 @@
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
-    }    
+    }
+
+    protected final static Logger logger = LoggerFactory.getLogger(ReferenceCamera.class);
 
-    protected final static Logger logger = LoggerFactory
-            .getLogger(ReferenceCamera.class);
-    
-    @Element(required=false)
+    @Element(required = false)
     private Location headOffsets = new Location(LengthUnit.Millimeters);
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected double rotation = 0;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected boolean flipX = false;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected boolean flipY = false;
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected Length safeZ = new Length(0, LengthUnit.Millimeters);
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected int offsetX = 0;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected int offsetY = 0;
-    
-    @Element(required=false)
+
+    @Element(required = false)
     private LensCalibrationParams calibration = new LensCalibrationParams();
-    
+
     private boolean calibrating;
     private CalibrationCallback calibrationCallback;
     private int calibrationCountGoal = 25;
-    
+
     protected ReferenceMachine machine;
     protected ReferenceDriver driver;
-    
-    
+
+
     private LensCalibration lensCalibration;
-    
+
     public ReferenceCamera() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 machine = (ReferenceMachine) configuration.getMachine();
                 driver = machine.getDriver();
             }
         });
     }
-    
+
     @Override
     public Location getHeadOffsets() {
         return headOffsets;
     }
-   
+
     @Override
     public void setHeadOffsets(Location headOffsets) {
         this.headOffsets = headOffsets;
     }
-    
+
     @Override
     public void moveTo(Location location, double speed) throws Exception {
-        logger.debug("moveTo({}, {})", new Object[] { location, speed } );
+        logger.debug("moveTo({}, {})", new Object[] {location, speed});
         driver.moveTo(this, location, speed);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
     public void moveToSafeZ(double speed) throws Exception {
-        logger.debug("{}.moveToSafeZ({})", new Object[] { getName(), speed } );
+        logger.debug("{}.moveToSafeZ({})", new Object[] {getName(), speed});
         Length safeZ = this.safeZ.convertToUnits(getLocation().getUnits());
-        Location l = new Location(getLocation().getUnits(), Double.NaN,
-                Double.NaN, safeZ.getValue(), Double.NaN);
+        Location l = new Location(getLocation().getUnits(), Double.NaN, Double.NaN,
+                safeZ.getValue(), Double.NaN);
         driver.moveTo(this, l, speed);
         machine.fireMachineHeadActivity(head);
     }
-    
+
     public double getRotation() {
         return rotation;
     }
@@ -136,7 +130,7 @@ public double getRotation() {
     public void setRotation(double rotation) {
         this.rotation = rotation;
     }
-    
+
     public boolean isFlipX() {
         return flipX;
     }
@@ -152,30 +146,30 @@ public boolean isFlipY() {
     public void setFlipY(boolean flipY) {
         this.flipY = flipY;
     }
-    
+
     public int getOffsetX() {
-		return offsetX;
-	}
+        return offsetX;
+    }
+
+    public void setOffsetX(int offsetX) {
+        this.offsetX = offsetX;
+    }
 
-	public void setOffsetX(int offsetX) {
-		this.offsetX = offsetX;
-	}
+    public int getOffsetY() {
+        return offsetY;
+    }
 
-	public int getOffsetY() {
-		return offsetY;
-	}
+    public void setOffsetY(int offsetY) {
+        this.offsetY = offsetY;
+    }
 
-	public void setOffsetY(int offsetY) {
-		this.offsetY = offsetY;
-	}
+    protected BufferedImage transformImage(BufferedImage image) {
+        Mat mat = OpenCvUtils.toMat(image);
 
-	protected BufferedImage transformImage(BufferedImage image) {
-	    Mat mat = OpenCvUtils.toMat(image);
-	    
         mat = calibrate(mat);
-        
+
         mat = undistort(mat);
-        
+
         // apply affine transformations
         if (rotation != 0) {
             // TODO: Fix cropping of rotated image:
@@ -183,8 +177,9 @@ protected BufferedImage transformImage(BufferedImage image) {
             Point center = new Point(mat.width() / 2D, mat.height() / 2D);
             Mat mapMatrix = Imgproc.getRotationMatrix2D(center, rotation, 1.0);
             Imgproc.warpAffine(mat, mat, mapMatrix, mat.size(), Imgproc.INTER_LINEAR);
+            mapMatrix.release();
         }
-        
+
         if (offsetX != 0 || offsetY != 0) {
             Mat mapMatrix = new Mat(2, 3, CvType.CV_32F) {
                 {
@@ -193,6 +188,7 @@ protected BufferedImage transformImage(BufferedImage image) {
                 }
             };
             Imgproc.warpAffine(mat, mat, mapMatrix, mat.size(), Imgproc.INTER_LINEAR);
+            mapMatrix.release();
         }
 
         if (flipX || flipY) {
@@ -207,73 +203,69 @@ protected BufferedImage transformImage(BufferedImage image) {
             Core.flip(mat, dst, flipCode);
             mat = dst;
         }
-        
+
         image = OpenCvUtils.toBufferedImage(mat);
-        
+        mat.release();
         return image;
     }
-	
-	private Mat undistort(Mat mat) {
-	    if (!calibration.isEnabled()) {
-	        return mat;
-	    }
-        Mat dst = new Mat();
-        Imgproc.undistort(
-                mat, 
-                dst, 
-                calibration.getCameraMatrixMat(), 
+
+    private Mat undistort(Mat mat) {
+        if (!calibration.isEnabled()) {
+            return mat;
+        }
+        Mat dst = mat.clone();
+        Imgproc.undistort(mat, dst, calibration.getCameraMatrixMat(),
                 calibration.getDistortionCoefficientsMat());
+        mat.release();
         return dst;
-	}
-	
-	private Mat calibrate(Mat mat) {
-	    if (!calibrating) {
-	        return mat;
-	    }
-	    
-        int count = lensCalibration.getPatternFoundCount(); 
-	    
-	    Mat appliedMat = lensCalibration.apply(mat);
-	    if (appliedMat == null) {
-	        // nothing was found in the image
-	        return mat;
-	    }
-	    
-	    if (count != lensCalibration.getPatternFoundCount()) {
-	        // a new image was counted, so let the caller know
-	        if (lensCalibration.getPatternFoundCount() == calibrationCountGoal) {
-	            calibrationCallback.callback(lensCalibration.getPatternFoundCount(), calibrationCountGoal, true);
-	            lensCalibration.calibrate();
+    }
+
+    private Mat calibrate(Mat mat) {
+        if (!calibrating) {
+            return mat;
+        }
+
+        int count = lensCalibration.getPatternFoundCount();
+
+        Mat appliedMat = lensCalibration.apply(mat);
+        if (appliedMat == null) {
+            // nothing was found in the image
+            return mat;
+        }
+
+        if (count != lensCalibration.getPatternFoundCount()) {
+            // a new image was counted, so let the caller know
+            if (lensCalibration.getPatternFoundCount() == calibrationCountGoal) {
+                calibrationCallback.callback(lensCalibration.getPatternFoundCount(),
+                        calibrationCountGoal, true);
+                lensCalibration.calibrate();
                 calibration.setCameraMatrixMat(lensCalibration.getCameraMatrix());
-                calibration.setDistortionCoefficientsMat(lensCalibration.getDistortionCoefficients());
+                calibration
+                        .setDistortionCoefficientsMat(lensCalibration.getDistortionCoefficients());
                 calibration.setEnabled(true);
                 calibrating = false;
-	        }
-	        else {
-	            calibrationCallback.callback(lensCalibration.getPatternFoundCount(), calibrationCountGoal, false);
-	        }
-	    }
-	    
-	    return appliedMat;
-	}
-	
-	public void startCalibration(CalibrationCallback callback) {
-	    this.calibrationCallback = callback;
-	    calibration.setEnabled(false);
-	    lensCalibration = new LensCalibration(
-	            LensModel.Pinhole, 
-	            Pattern.AsymmetricCirclesGrid, 
-	            4, 
-	            11, 
-	            15,
-	            750);
-	    calibrating = true;
-	}
-	
-	public void cancelCalibration() {
-	    calibrating = false;
-	}
-	
+            }
+            else {
+                calibrationCallback.callback(lensCalibration.getPatternFoundCount(),
+                        calibrationCountGoal, false);
+            }
+        }
+
+        return appliedMat;
+    }
+
+    public void startCalibration(CalibrationCallback callback) {
+        this.calibrationCallback = callback;
+        calibration.setEnabled(false);
+        lensCalibration = new LensCalibration(LensModel.Pinhole, Pattern.AsymmetricCirclesGrid, 4,
+                11, 15, 750);
+        calibrating = true;
+    }
+
+    public void cancelCalibration() {
+        calibrating = false;
+    }
+
     public LensCalibrationParams getCalibration() {
         return calibration;
     }
@@ -288,41 +280,40 @@ public Location getLocation() {
         return driver.getLocation(this);
     }
 
-	public Length getSafeZ() {
-		return safeZ;
-	}
+    public Length getSafeZ() {
+        return safeZ;
+    }
 
-	public void setSafeZ(Length safeZ) {
-		this.safeZ = safeZ;
-	}
+    public void setSafeZ(Length safeZ) {
+        this.safeZ = safeZ;
+    }
 
     @Override
-    public void close() throws IOException {
-    }
-    
+    public void close() throws IOException {}
+
     public interface CalibrationCallback {
         public void callback(int progressCurrent, int progressMax, boolean complete);
     }
 
     public static class LensCalibrationParams {
-        @Attribute(required=false)
+        @Attribute(required = false)
         private boolean enabled = false;
-        
-        @Element(name="cameraMatrix", required=false)
+
+        @Element(name = "cameraMatrix", required = false)
         private double[] cameraMatrixArr = new double[9];
-        
-        @Element(name="distortionCoefficients", required=false)
+
+        @Element(name = "distortionCoefficients", required = false)
         private double[] distortionCoefficientsArr = new double[5];
-        
+
         private Mat cameraMatrix = new Mat(3, 3, CvType.CV_64FC1);
         private Mat distortionCoefficients = new Mat(5, 1, CvType.CV_64FC1);
-        
+
         @Commit
         private void commit() {
             cameraMatrix.put(0, 0, cameraMatrixArr);
             distortionCoefficients.put(0, 0, distortionCoefficientsArr);
         }
-        
+
         @Persist
         private void persist() {
             cameraMatrix.get(0, 0, cameraMatrixArr);
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceDriver.java b/src/main/java/org/openpnp/machine/reference/ReferenceDriver.java
index 8666a99332..839857d659 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
@@ -28,34 +26,30 @@
 import org.openpnp.spi.WizardConfigurable;
 
 /**
- * Defines the interface for a simple driver that the ReferenceMachine can
- * drive. All methods result in machine operations and all methods should block
- * until they are complete or throw an error.
+ * Defines the interface for a simple driver that the ReferenceMachine can drive. All methods result
+ * in machine operations and all methods should block until they are complete or throw an error.
  * 
- * This Driver interface is intended to model a machine with one or more Heads,
- * and each Head having one or more Nozzles and zero or more Cameras and
- * Actuators.
+ * This Driver interface is intended to model a machine with one or more Heads, and each Head having
+ * one or more Nozzles and zero or more Cameras and Actuators.
  * 
- * In OpenPnP, the Head does not move on it's own. It is moved by the moving of
- * attached objects: Nozzles, Cameras, Actuators. For this reason, all movements
- * on the driver are specified as movements by one of these objects. This allows
- * the driver to make decisions as to what axes should be moved to accomplish a
- * specific task.
+ * In OpenPnP, the Head does not move on it's own. It is moved by the moving of attached objects:
+ * Nozzles, Cameras, Actuators. For this reason, all movements on the driver are specified as
+ * movements by one of these objects. This allows the driver to make decisions as to what axes
+ * should be moved to accomplish a specific task.
  */
 public interface ReferenceDriver extends WizardConfigurable, PropertySheetHolder, Closeable {
     /**
-     * Performing the hardware homing operation for the given Head. When this
-     * call completes the Head should be at it's 0,0,0,0 position.
+     * Performing the hardware homing operation for the given Head. When this call completes the
+     * Head should be at it's 0,0,0,0 position.
      * 
      * @throws Exception
      */
     public void home(ReferenceHead head) throws Exception;
 
     /**
-     * Moves the specified HeadMountable to the given location at a speed
-     * defined by (maximum feed rate * speed) where speed is greater than 0 and
-     * typically less than or equal to 1. A speed of 0 means to move at the
-     * minimum possible speed.
+     * Moves the specified HeadMountable to the given location at a speed defined by (maximum feed
+     * rate * speed) where speed is greater than 0 and typically less than or equal to 1. A speed of
+     * 0 means to move at the minimum possible speed.
      * 
      * HeadMountable object types include Nozzle, Camera and Actuator.
      * 
@@ -64,21 +58,20 @@
      * @param speed
      * @throws Exception
      */
-    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-            throws Exception;
-    
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed) throws Exception;
+
     /**
-     * Returns a clone of the HeadMountable's current location. It's important
-     * that the returned object is a clone, since the caller may modify the
-     * returned Location.
+     * Returns a clone of the HeadMountable's current location. It's important that the returned
+     * object is a clone, since the caller may modify the returned Location.
+     * 
      * @param hm
      * @return
      */
     public Location getLocation(ReferenceHeadMountable hm);
 
     /**
-     * Causes the nozzle to apply vacuum and any other operation that it uses
-     * for picking up a part that it is resting on.
+     * Causes the nozzle to apply vacuum and any other operation that it uses for picking up a part
+     * that it is resting on.
      * 
      * @param nozzle
      * @throws Exception
@@ -86,9 +79,9 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
     public void pick(ReferenceNozzle nozzle) throws Exception;
 
     /**
-     * Causes the nozzle to release vacuum and any other operation that it uses
-     * for placing a part that it is currently holding. For instance, it might
-     * provide a brief puff of air to set the part.
+     * Causes the nozzle to release vacuum and any other operation that it uses for placing a part
+     * that it is currently holding. For instance, it might provide a brief puff of air to set the
+     * part.
      * 
      * @throws Exception
      */
@@ -119,6 +112,7 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
      * @throws Exception
      */
     public void setEnabled(boolean enabled) throws Exception;
-    
-    public void dispense(ReferencePasteDispenser dispenser, Location startLocation, Location endLocation, long dispenseTimeMilliseconds) throws Exception;
+
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception;
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceFeeder.java b/src/main/java/org/openpnp/machine/reference/ReferenceFeeder.java
index 480fdb6411..f83f01e31c 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceFeeder.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceFeeder.java
@@ -8,11 +8,11 @@
 public abstract class ReferenceFeeder extends AbstractFeeder {
     @Element
     protected Location location = new Location(LengthUnit.Millimeters);
-    
+
     public Location getLocation() {
         return location;
     }
-    
+
     public void setLocation(Location location) {
         this.location = location;
     }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceHead.java b/src/main/java/org/openpnp/machine/reference/ReferenceHead.java
index c27a36f984..03af95f9fa 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceHead.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceHead.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
@@ -28,7 +26,6 @@
 import org.openpnp.ConfigurationListener;
 import org.openpnp.gui.support.PropertySheetWizardAdapter;
 import org.openpnp.gui.support.Wizard;
-import org.openpnp.machine.reference.wizards.ReferenceHeadConfigurationWizard;
 import org.openpnp.model.Configuration;
 import org.openpnp.spi.PropertySheetHolder;
 import org.openpnp.spi.base.AbstractHead;
@@ -37,8 +34,7 @@
 import org.slf4j.LoggerFactory;
 
 public class ReferenceHead extends AbstractHead {
-    protected final static Logger logger = LoggerFactory
-            .getLogger(ReferenceHead.class);
+    protected final static Logger logger = LoggerFactory.getLogger(ReferenceHead.class);
 
     protected ReferenceMachine machine;
     protected ReferenceDriver driver;
@@ -46,8 +42,7 @@
     public ReferenceHead() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 machine = (ReferenceMachine) configuration.getMachine();
                 driver = machine.getDriver();
             }
@@ -56,21 +51,21 @@ public void configurationLoaded(Configuration configuration)
 
     @Override
     public void home() throws Exception {
-		logger.debug("{}.home()", getName());
+        logger.debug("{}.home()", getName());
         driver.home(this);
         machine.fireMachineHeadActivity(this);
     }
 
-	@Override
+    @Override
     public Wizard getConfigurationWizard() {
-	    // This Wizard is out of date and none of it currently works.
-//        return new ReferenceHeadConfigurationWizard(this);
-	    return null;
+        // This Wizard is out of date and none of it currently works.
+        // return new ReferenceHeadConfigurationWizard(this);
+        return null;
     }
-	
-	@Override
+
+    @Override
     public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName() + " " + getName();
+        return getClass().getSimpleName() + " " + getName();
     }
 
     @Override
@@ -80,16 +75,14 @@ public String getPropertySheetHolderTitle() {
         children.add(new SimplePropertySheetHolder("Cameras", getCameras()));
         children.add(new SimplePropertySheetHolder("Actuators", getActuators()));
         children.add(new SimplePropertySheetHolder("Paste Dispensers", getPasteDispensers()));
-        return children.toArray(new PropertySheetHolder[]{});
+        return children.toArray(new PropertySheetHolder[] {});
     }
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -97,13 +90,13 @@ public String getPropertySheetHolderTitle() {
     }
 
     @Override
-	public void moveToSafeZ(double speed) throws Exception {
-		logger.debug("{}.moveToSafeZ({})", getName(), speed);
-		super.moveToSafeZ(speed);
-	}
+    public void moveToSafeZ(double speed) throws Exception {
+        logger.debug("{}.moveToSafeZ({})", getName(), speed);
+        super.moveToSafeZ(speed);
+    }
 
-	@Override
-	public String toString() {
-		return getName();
-	}
+    @Override
+    public String toString() {
+        return getName();
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceHeadMountable.java b/src/main/java/org/openpnp/machine/reference/ReferenceHeadMountable.java
index 0ab3387ef0..ab856588ac 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceHeadMountable.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceHeadMountable.java
@@ -5,5 +5,6 @@
 
 public interface ReferenceHeadMountable extends HeadMountable {
     public Location getHeadOffsets();
+
     public void setHeadOffsets(Location headOffsets);
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceJobProcessor.java b/src/main/java/org/openpnp/machine/reference/ReferenceJobProcessor.java
index 790efeec37..efd45ba0bf 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceJobProcessor.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceJobProcessor.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
@@ -42,7 +40,6 @@
 import org.openpnp.spi.VisionProvider;
 import org.openpnp.spi.base.AbstractJobProcessor;
 import org.openpnp.util.Utils2D;
-import org.openpnp.vision.BottomVision;
 import org.openpnp.vision.FiducialLocator;
 import org.simpleframework.xml.Attribute;
 import org.simpleframework.xml.Element;
@@ -50,88 +47,71 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-// TODO: Rewrite this as a FSM where each place we would normally check if 
+// TODO: Rewrite this as a FSM where each place we would normally check if
 // job should continue is just a state.
-// TODO Safe Z should be a Job property, and the user should be able to set it during job setup to be as low as
+// TODO Safe Z should be a Job property, and the user should be able to set it during job setup to
+// be as low as
 // possible to make things faster.
 public class ReferenceJobProcessor extends AbstractJobProcessor {
-	private static final Logger logger = LoggerFactory.getLogger(ReferenceJobProcessor.class);
-	
+    private static final Logger logger = LoggerFactory.getLogger(ReferenceJobProcessor.class);
+
     /**
      * History:
      * 
-     * Note: Can't actually use the @Version annotation because of a bug
-     * in SimpleXML. See http://sourceforge.net/p/simple/mailman/message/27887562/
-     *  
-     * 1.0: Initial revision.
-     * 1.1: Added jobPlanner, which is moved here from AbstractMachine.
+     * Note: Can't actually use the @Version annotation because of a bug in SimpleXML. See
+     * http://sourceforge.net/p/simple/mailman/message/27887562/
+     * 
+     * 1.0: Initial revision. 1.1: Added jobPlanner, which is moved here from AbstractMachine.
      */
-	
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private boolean demoMode;
-    
-    @Element(required=false)
+
+    @Element(required = false)
     private JobPlanner jobPlanner;
-    
-    private BottomVision bottomVision = new BottomVision();
-    
-	public ReferenceJobProcessor() {
-	}
-	
+
+    public ReferenceJobProcessor() {}
+
     @SuppressWarnings("unused")
     @Commit
     private void commit() {
         if (jobPlanner == null) {
             jobPlanner = new SimpleJobPlanner();
         }
-    }	
-	
-	@Override
+    }
+
+    @Override
     public void run() {
-	    if (demoMode) {
-	        runDemo();
-	        return;
-	    }
-	    
-		state = JobState.Running;
-		fireJobStateChanged();
-		
-		Machine machine = Configuration.get().getMachine();
-		
-		preProcessJob(machine);
-		
-		for (Head head : machine.getHeads()) {
-			fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));		
-	
-			if (!shouldJobProcessingContinue()) {
-				return;
-			}
-	
-			try {
-				head.moveToSafeZ(1.0);
-			}
-			catch (Exception e) {
-				fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
-				return;
-			}
-		}
-		
-        fireDetailedStatusUpdated(String.format("Prepare bottom vision."));        
-        
-        if (!shouldJobProcessingContinue()) {
+        if (demoMode) {
+            runDemo();
             return;
         }
 
-        try {
-            bottomVision.preProcess(job);
-        }
-        catch (Exception e) {
-            fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
-            return;
+        state = JobState.Running;
+        fireJobStateChanged();
+
+        Machine machine = Configuration.get().getMachine();
+
+        preProcessJob(machine);
+
+        for (Head head : machine.getHeads()) {
+            fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));
+
+            if (!shouldJobProcessingContinue()) {
+                return;
+            }
+
+            try {
+                head.moveToSafeZ(1.0);
+            }
+            catch (Exception e) {
+                fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
+                return;
+            }
         }
-		
-        fireDetailedStatusUpdated(String.format("Check fiducials."));        
-        
+
+        fireDetailedStatusUpdated(String.format("Check fiducials."));
+
         if (!shouldJobProcessingContinue()) {
             return;
         }
@@ -143,112 +123,106 @@ public void run() {
             fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
             return;
         }
-		
-		Head head = machine.getHeads().get(0);
-		
-		jobPlanner.setJob(job);
+
+        Head head = machine.getHeads().get(0);
+
+        jobPlanner.setJob(job);
 
         Set<PlacementSolution> solutions;
-		while ((solutions = jobPlanner.getNextPlacementSolutions(head)) != null) {
-		    for (PlacementSolution solution : solutions) {
+        while ((solutions = jobPlanner.getNextPlacementSolutions(head)) != null) {
+            for (PlacementSolution solution : solutions) {
                 BoardLocation bl = solution.boardLocation;
                 Part part = solution.placement.getPart();
                 Feeder feeder = solution.feeder;
                 Placement placement = solution.placement;
                 Nozzle nozzle = solution.nozzle;
                 NozzleTip nozzleTip = solution.nozzleTip;
-                
+
                 firePartProcessingStarted(solution.boardLocation, solution.placement);
-                
+
                 if (!changeNozzleTip(nozzle, nozzleTip)) {
                     return;
                 }
-								
-				if (!nozzle.getNozzleTip().canHandle(part)) {
-                    fireJobEncounteredError(JobError.PickError, "Selected nozzle tip is not compatible with part");
+
+                if (!nozzle.getNozzleTip().canHandle(part)) {
+                    fireJobEncounteredError(JobError.PickError,
+                            "Selected nozzle tip is not compatible with part");
+                    return;
+                }
+
+                if (!pick(nozzle, feeder, bl, placement)) {
                     return;
-				}
-				
-				if (!pick(nozzle, feeder, bl, placement)) {
-				    return;
-				}
-			}
-		    
+                }
+            }
+
             // TODO: a lot of the event fires are broken
-		    for (PlacementSolution solution : solutions) {
+            for (PlacementSolution solution : solutions) {
                 Nozzle nozzle = solution.nozzle;
                 BoardLocation bl = solution.boardLocation;
                 Placement placement = solution.placement;
                 Part part = placement.getPart();
-                
-                fireDetailedStatusUpdated(String.format("Perform bottom vision"));      
-                
+
+                fireDetailedStatusUpdated(String.format("Perform bottom vision"));
+
                 if (!shouldJobProcessingContinue()) {
                     return;
                 }
-                
-                Location placementLocation = placement.getLocation();
 
-//                try {
-//                    bottomVision.findOffsets(part, nozzle);
-//                }
-//                catch (Exception e) {
-//                    e.printStackTrace();
-//                }
-                
-//                Location bottomVisionOffsets;
-//                try {
-//                    bottomVisionOffsets = performBottomVision(machine, part, nozzle);
-//                }
-//                catch (Exception e) {
-//                    fireJobEncounteredError(JobError.PartError, e.getMessage());
-//                    return;
-//                }
-//                if (bottomVisionOffsets != null) {
-//                    placementLocation = placementLocation.subtractWithRotation(bottomVisionOffsets);
-//                }
-                
-                placementLocation = 
-                        Utils2D.calculateBoardPlacementLocation(
-                        		bl, placementLocation);
+                Location bottomVisionOffsets;
+                try {
+                    bottomVisionOffsets = performBottomVision(machine, part, nozzle);
+                }
+                catch (Exception e) {
+                    fireJobEncounteredError(JobError.PartError, e.getMessage());
+                    return;
+                }
+
+                Location placementLocation = placement.getLocation();
+                if (bottomVisionOffsets != null) {
+                    placementLocation = placementLocation.subtractWithRotation(bottomVisionOffsets);
+                }
+                placementLocation = Utils2D.calculateBoardPlacementLocation(bl, placementLocation);
 
                 // Update the placementLocation with the proper Z value. This is
-                // the distance to the top of the board plus the height of 
+                // the distance to the top of the board plus the height of
                 // the part.
-                Location boardLocation = bl.getLocation().convertToUnits(placementLocation.getUnits());
-                double partHeight = part.getHeight().convertToUnits(placementLocation.getUnits()).getValue();
-                placementLocation = placementLocation.derive(null, null, boardLocation.getZ() + partHeight, null);
+                Location boardLocation =
+                        bl.getLocation().convertToUnits(placementLocation.getUnits());
+                double partHeight =
+                        part.getHeight().convertToUnits(placementLocation.getUnits()).getValue();
+                placementLocation = placementLocation.derive(null, null,
+                        boardLocation.getZ() + partHeight, null);
 
                 if (!place(nozzle, bl, placementLocation, placement)) {
                     return;
                 }
             }
-		}
-		
-		fireDetailedStatusUpdated("Job complete.");
-		
-		state = JobState.Stopped;
-		fireJobStateChanged();
-	}
-	
+        }
+
+        fireDetailedStatusUpdated("Job complete.");
+
+        state = JobState.Stopped;
+        fireJobStateChanged();
+    }
+
     // TODO: This needs to be it's own class and the job processor needs to
-	// be more abstract. Then we can have job processors that process
-	// job types like demo, pnp, solder, etc.
-	private void runDemo() {
+    // be more abstract. Then we can have job processors that process
+    // job types like demo, pnp, solder, etc.
+    private void runDemo() {
         state = JobState.Running;
         fireJobStateChanged();
-        
+
         Machine machine = Configuration.get().getMachine();
-    
+
         preProcessJob(machine);
-        
+
         for (Head head : machine.getHeads()) {
-            fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));        
-    
+            fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));
+
             if (!shouldJobProcessingContinue()) {
                 return;
             }
-    
+
             try {
                 head.moveToSafeZ(1.0);
             }
@@ -257,9 +231,9 @@ private void runDemo() {
                 return;
             }
         }
-        
-        fireDetailedStatusUpdated(String.format("Check fiducials."));        
-        
+
+        fireDetailedStatusUpdated(String.format("Check fiducials."));
+
         if (!shouldJobProcessingContinue()) {
             return;
         }
@@ -271,10 +245,10 @@ private void runDemo() {
             fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
             return;
         }
-        
+
         Head head;
         Camera camera;
-        
+
         try {
             head = machine.getDefaultHead();
             camera = head.getDefaultCamera();
@@ -283,18 +257,19 @@ private void runDemo() {
             fireJobEncounteredError(JobError.HeadError, e.getMessage());
             return;
         }
-        
+
         jobPlanner.setJob(job);
-                
+
         Set<PlacementSolution> solutions;
         while ((solutions = jobPlanner.getNextPlacementSolutions(head)) != null) {
             for (PlacementSolution solution : solutions) {
                 Feeder feeder = solution.feeder;
-                
+
                 firePartProcessingStarted(solution.boardLocation, solution.placement);
-                
+
                 try {
-                    fireDetailedStatusUpdated(String.format("Move to pick location, safe Z at (%s).", feeder.getPickLocation()));
+                    fireDetailedStatusUpdated(String.format(
+                            "Move to pick location, safe Z at (%s).", feeder.getPickLocation()));
                 }
                 catch (Exception e) {
                     fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
@@ -306,7 +281,8 @@ private void runDemo() {
                 }
 
                 try {
-                    camera.moveTo(feeder.getPickLocation().derive(null, null, Double.NaN, null), 1.0);
+                    camera.moveTo(feeder.getPickLocation().derive(null, null, Double.NaN, null),
+                            1.0);
                     Thread.sleep(750);
                 }
                 catch (Exception e) {
@@ -314,25 +290,25 @@ private void runDemo() {
                     return;
                 }
             }
-            
+
             // TODO: a lot of the event fires are broken
             for (PlacementSolution solution : solutions) {
                 BoardLocation bl = solution.boardLocation;
                 Placement placement = solution.placement;
 
                 Location placementLocation = placement.getLocation();
-                placementLocation = 
-                        Utils2D.calculateBoardPlacementLocation(
-                        		bl, placementLocation);
-                
-                fireDetailedStatusUpdated(String.format("Move to placement location, safe Z at (%s).", placementLocation));
+                placementLocation = Utils2D.calculateBoardPlacementLocation(bl, placementLocation);
+
+                fireDetailedStatusUpdated(String
+                        .format("Move to placement location, safe Z at (%s).", placementLocation));
 
                 if (!shouldJobProcessingContinue()) {
                     return;
                 }
 
                 try {
-                    camera.moveTo(placementLocation.derive(null, null, Double.NaN, null), placement.getPart().getSpeed());
+                    camera.moveTo(placementLocation.derive(null, null, Double.NaN, null),
+                            placement.getPart().getSpeed());
                     Thread.sleep(750);
                 }
                 catch (Exception e) {
@@ -341,13 +317,13 @@ private void runDemo() {
                 }
             }
         }
-        
+
         fireDetailedStatusUpdated("Job complete.");
-        
+
         state = JobState.Stopped;
         fireJobStateChanged();
     }
-    
+
     // TODO: Should not bail if there are no fids on the board. Figure out
     // the UI for that.
     protected void checkFiducials() throws Exception {
@@ -363,16 +339,46 @@ protected void checkFiducials() throws Exception {
             boardLocation.setLocation(location);
         }
     }
-	
-	protected boolean changeNozzleTip(Nozzle nozzle, NozzleTip nozzleTip) {
+
+    protected Location performBottomVision(Machine machine, Part part, Nozzle nozzle)
+            throws Exception {
+        // TODO: I think this stuff actually belongs in VisionProvider but
+        // I have not yet fully thought through the API.
+
+        // Find the first fixed camera
+        if (machine.getCameras().isEmpty()) {
+            // TODO: return null for now to indicate that no vision was
+            // calculated. In the future we may want this to be based on
+            // configuration.
+            return null;
+        }
+        Camera camera = machine.getCameras().get(0);
+
+        // Get it's vision provider
+        VisionProvider vp = camera.getVisionProvider();
+        if (vp == null) {
+            // TODO: return null for now to indicate that no vision was
+            // calculated. In the future we may want this to be based on
+            // configuration.
+            return null;
+        }
+
+        // Perform the operation. Note that similar to feeding and nozzle
+        // tip changing, it is up to the VisionProvider to move the camera
+        // and nozzle to where it needs to be.
+        return vp.getPartBottomOffsets(part, nozzle);
+    }
+
+    protected boolean changeNozzleTip(Nozzle nozzle, NozzleTip nozzleTip) {
         // NozzleTip Changer
         if (nozzle.getNozzleTip() != nozzleTip) {
-            fireDetailedStatusUpdated(String.format("Unload nozzle tip from nozzle %s.", nozzle.getName()));        
+            fireDetailedStatusUpdated(
+                    String.format("Unload nozzle tip from nozzle %s.", nozzle.getName()));
 
             if (!shouldJobProcessingContinue()) {
                 return false;
             }
-            
+
             try {
                 nozzle.unloadNozzleTip();
             }
@@ -380,13 +386,14 @@ protected boolean changeNozzleTip(Nozzle nozzle, NozzleTip nozzleTip) {
                 fireJobEncounteredError(JobError.PickError, e.getMessage());
                 return false;
             }
-            
-            fireDetailedStatusUpdated(String.format("Load nozzle tip %s into nozzle %s.", nozzleTip.getName(), nozzle.getName()));        
+
+            fireDetailedStatusUpdated(String.format("Load nozzle tip %s into nozzle %s.",
+                    nozzleTip.getName(), nozzle.getName()));
 
             if (!shouldJobProcessingContinue()) {
                 return false;
             }
-                                
+
             try {
                 nozzle.loadNozzleTip(nozzleTip);
             }
@@ -394,7 +401,7 @@ protected boolean changeNozzleTip(Nozzle nozzle, NozzleTip nozzleTip) {
                 fireJobEncounteredError(JobError.PickError, e.getMessage());
                 return false;
             }
-            
+
             if (nozzle.getNozzleTip() != nozzleTip) {
                 fireJobEncounteredError(JobError.PickError, "Failed to load correct nozzle tip");
                 return false;
@@ -402,10 +409,11 @@ protected boolean changeNozzleTip(Nozzle nozzle, NozzleTip nozzleTip) {
         }
         return true;
         // End NozzleTip Changer
-	}
-	
-	protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement placement) {
-        fireDetailedStatusUpdated(String.format("Move nozzle %s to Safe-Z at (%s).", nozzle.getName(), nozzle.getLocation()));        
+    }
+
+    protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement placement) {
+        fireDetailedStatusUpdated(String.format("Move nozzle %s to Safe-Z at (%s).",
+                nozzle.getName(), nozzle.getLocation()));
 
         if (!shouldJobProcessingContinue()) {
             return false;
@@ -419,18 +427,20 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
             return false;
         }
 
-        // TODO: Need to be able to see the thing that caused an error, but we also want to see what is about to happen when paused. Figure it out.
-        fireDetailedStatusUpdated(String.format("Request part feed from feeder %s.", feeder.getName()));
-        
+        // TODO: Need to be able to see the thing that caused an error, but we also want to see what
+        // is about to happen when paused. Figure it out.
+        fireDetailedStatusUpdated(
+                String.format("Request part feed from feeder %s.", feeder.getName()));
+
         if (!shouldJobProcessingContinue()) {
             return false;
         }
 
         // Request that the Feeder feeds the part
         while (true) {
-        	if (!shouldJobProcessingContinue()) {
-        		return false;
-        	}
+            if (!shouldJobProcessingContinue()) {
+                return false;
+            }
             try {
                 feeder.feed(nozzle);
                 break;
@@ -439,7 +449,7 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
                 fireJobEncounteredError(JobError.FeederError, e.getMessage());
             }
         }
-        
+
         // Now that the Feeder has done it's feed operation we can get
         // the pick location from it.
         Location pickLocation;
@@ -452,7 +462,7 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
         }
 
         fireDetailedStatusUpdated(String.format("Move to safe Z at (%s).", nozzle.getLocation()));
-        
+
         if (!shouldJobProcessingContinue()) {
             return false;
         }
@@ -465,12 +475,13 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
             return false;
         }
 
-        fireDetailedStatusUpdated(String.format("Move to pick location, safe Z at (%s).", pickLocation));
+        fireDetailedStatusUpdated(
+                String.format("Move to pick location, safe Z at (%s).", pickLocation));
 
         if (!shouldJobProcessingContinue()) {
             return false;
         }
-        
+
         // Move the Nozzle to the pick Location at safe Z
         try {
             nozzle.moveTo(pickLocation.derive(null, null, Double.NaN, null), 1.0);
@@ -486,7 +497,7 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
             return false;
         }
 
-        // Move the Nozzle to the pick Location 
+        // Move the Nozzle to the pick Location
         try {
             nozzle.moveTo(pickLocation, 1.0);
         }
@@ -500,12 +511,12 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
         if (!shouldJobProcessingContinue()) {
             return false;
         }
-        
+
         // Pick the part
         try {
             // TODO design a way for the head/feeder to indicate that the part
             // failed to pick, use the delegate to notify and potentially retry
-            // We now have the delegate for this, just need to use it and 
+            // We now have the delegate for this, just need to use it and
             // implement the logic for it's potential responses
             nozzle.pick();
         }
@@ -513,7 +524,7 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
             fireJobEncounteredError(JobError.PickError, e.getMessage());
             return false;
         }
-        
+
         firePartPicked(bl, placement);
 
         fireDetailedStatusUpdated(String.format("Move to safe Z at (%s).", nozzle.getLocation()));
@@ -529,12 +540,14 @@ protected boolean pick(Nozzle nozzle, Feeder feeder, BoardLocation bl, Placement
             fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
             return false;
         }
-        
+
         return true;
-	}
-	
-	protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocation, Placement placement) {
-        fireDetailedStatusUpdated(String.format("Move to placement location, safe Z at (%s).", placementLocation));
+    }
+
+    protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocation,
+            Placement placement) {
+        fireDetailedStatusUpdated(
+                String.format("Move to placement location, safe Z at (%s).", placementLocation));
 
         if (!shouldJobProcessingContinue()) {
             return false;
@@ -542,14 +555,16 @@ protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocat
 
         // Move the nozzle to the placement Location at safe Z
         try {
-            nozzle.moveTo(placementLocation.derive(null, null, Double.NaN, null), placement.getPart().getSpeed());
+            nozzle.moveTo(placementLocation.derive(null, null, Double.NaN, null),
+                    placement.getPart().getSpeed());
         }
         catch (Exception e) {
             fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
             return false;
         }
 
-        fireDetailedStatusUpdated(String.format("Move to placement location Z at (%s).", placementLocation));
+        fireDetailedStatusUpdated(
+                String.format("Move to placement location Z at (%s).", placementLocation));
 
         if (!shouldJobProcessingContinue()) {
             return false;
@@ -564,16 +579,15 @@ protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocat
             return false;
         }
 
-        fireDetailedStatusUpdated(String.format("Request part place. at (X %2.3f, Y %2.3f, Z %2.3f, C %2.3f).", 
-                placementLocation.getX(), 
-                placementLocation.getY(), 
-                placementLocation.getZ(), 
-                placementLocation.getRotation()));
+        fireDetailedStatusUpdated(
+                String.format("Request part place. at (X %2.3f, Y %2.3f, Z %2.3f, C %2.3f).",
+                        placementLocation.getX(), placementLocation.getY(),
+                        placementLocation.getZ(), placementLocation.getRotation()));
 
         if (!shouldJobProcessingContinue()) {
             return false;
         }
-        
+
         // Place the part
         try {
             nozzle.place();
@@ -582,16 +596,16 @@ protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocat
             fireJobEncounteredError(JobError.PlaceError, e.getMessage());
             return false;
         }
-        
+
         firePartPlaced(bl, placement);
-        
-        fireDetailedStatusUpdated(String.format("Move to safe Z at (%s).", nozzle.getLocation()));      
+
+        fireDetailedStatusUpdated(String.format("Move to safe Z at (%s).", nozzle.getLocation()));
 
         if (!shouldJobProcessingContinue()) {
             return false;
         }
 
-        // Return to Safe-Z above the board. 
+        // Return to Safe-Z above the board.
         try {
             nozzle.moveToSafeZ(1.0);
         }
@@ -599,36 +613,28 @@ protected boolean place(Nozzle nozzle, BoardLocation bl, Location placementLocat
             fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
             return false;
         }
-        
+
         firePartProcessingComplete(bl, placement);
-        
+
         return true;
-	}
-	
-	/*
-	 * Pre-process the Job. We will:
-	 * 	Look for setup errors.
-	 * 	Look for missing parts.
-	 * 	Look for missing feeders.
-	 * 	Look for feeders that cannot feed the number of parts that
-	 * 		will be needed.
-	 * 	Calculate the base Safe-Z for the job.
-	 * 	Calculate the number of parts that need to be placed.
-	 * 	Calculate the total distance that will need to be traveled.
-	 * 	Calculate the total time it should take to place the job.
-	 * 
-	 * Time calculation is tough unless we also ask the feeders to simulate
-	 * their work. Otherwise we can just calculate the total distance *
-	 * the feed rate to get close. This doesn't include acceleration and
-	 * such. 
-	 * 
-	 * The base Safe-Z is the maximum of:
-	 * 		Highest placement location.
-	 * 		Highest pick location.
-	 */
-	protected void preProcessJob(Machine machine) {
+    }
+
+    /*
+     * Pre-process the Job. We will: Look for setup errors. Look for missing parts. Look for missing
+     * feeders. Look for feeders that cannot feed the number of parts that will be needed. Calculate
+     * the base Safe-Z for the job. Calculate the number of parts that need to be placed. Calculate
+     * the total distance that will need to be traveled. Calculate the total time it should take to
+     * place the job.
+     * 
+     * Time calculation is tough unless we also ask the feeders to simulate their work. Otherwise we
+     * can just calculate the total distance * the feed rate to get close. This doesn't include
+     * acceleration and such.
+     * 
+     * The base Safe-Z is the maximum of: Highest placement location. Highest pick location.
+     */
+    protected void preProcessJob(Machine machine) {
         Head head = machine.getHeads().get(0);
-        
+
         jobPlanner.setJob(job);
 
         Set<PlacementSolution> solutions;
@@ -640,31 +646,36 @@ protected void preProcessJob(Machine machine) {
                 Placement placement = solution.placement;
                 Nozzle nozzle = solution.nozzle;
                 NozzleTip nozzleTip = solution.nozzleTip;
-	    
+
                 if (part == null) {
-                    fireJobEncounteredError(JobError.PartError, String.format("Part not found for Board %s, Placement %s", bl.getBoard().getName(), placement.getId()));
+                    fireJobEncounteredError(JobError.PartError,
+                            String.format("Part not found for Board %s, Placement %s",
+                                    bl.getBoard().getName(), placement.getId()));
                     return;
                 }
 
                 if (nozzle == null) {
-                    fireJobEncounteredError(JobError.HeadError, "No Nozzle available to service Placement " + placement);
+                    fireJobEncounteredError(JobError.HeadError,
+                            "No Nozzle available to service Placement " + placement);
                     return;
                 }
-        
+
                 if (feeder == null) {
-                    fireJobEncounteredError(JobError.FeederError, "No viable Feeders found for Part " + part.getId());
+                    fireJobEncounteredError(JobError.FeederError,
+                            "No viable Feeders found for Part " + part.getId());
                     return;
                 }
-        
+
                 if (nozzleTip == null) {
-                    fireJobEncounteredError(JobError.HeadError, "No viable NozzleTips found for Part / Feeder " + part.getId());
+                    fireJobEncounteredError(JobError.HeadError,
+                            "No viable NozzleTips found for Part / Feeder " + part.getId());
                     return;
                 }
-				
-			}
-		}
-	}
-	
+
+            }
+        }
+    }
+
     public boolean isDemoMode() {
         return demoMode;
     }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceMachine.java b/src/main/java/org/openpnp/machine/reference/ReferenceMachine.java
index a6e991a607..86464c35a9 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceMachine.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceMachine.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
@@ -34,16 +32,16 @@
 import org.openpnp.machine.reference.camera.LtiCivilCamera;
 import org.openpnp.machine.reference.camera.OpenCvCamera;
 import org.openpnp.machine.reference.camera.VfwCamera;
+import org.openpnp.machine.reference.camera.Webcams;
 import org.openpnp.machine.reference.driver.NullDriver;
-import org.openpnp.machine.reference.feeder.ReferenceStripFeeder;
 import org.openpnp.machine.reference.feeder.ReferenceDragFeeder;
+import org.openpnp.machine.reference.feeder.ReferenceStripFeeder;
 import org.openpnp.machine.reference.feeder.ReferenceTrayFeeder;
 import org.openpnp.machine.reference.feeder.ReferenceTubeFeeder;
 import org.openpnp.machine.reference.wizards.ReferenceMachineConfigurationWizard;
 import org.openpnp.spi.Camera;
 import org.openpnp.spi.Feeder;
 import org.openpnp.spi.Head;
-import org.openpnp.spi.JobProcessor;
 import org.openpnp.spi.PropertySheetHolder;
 import org.openpnp.spi.base.AbstractMachine;
 import org.openpnp.spi.base.SimplePropertySheetHolder;
@@ -52,67 +50,67 @@
 import org.slf4j.LoggerFactory;
 
 public class ReferenceMachine extends AbstractMachine {
-	private static Logger logger = LoggerFactory.getLogger(ReferenceMachine.class);
-
-	@Element(required=false)
-	private ReferenceDriver driver = new NullDriver();
-	
-	private boolean enabled;
-	
-	private List<Class<? extends Feeder>> registeredFeederClasses = new ArrayList<>();
-	
-	public ReferenceDriver getDriver() {
-		return driver;
-	}
-	
-	public void setDriver(ReferenceDriver driver) throws Exception {
-	    if (driver != this.driver) {
-	        setEnabled(false);
-	        close();
-	    }
-	    this.driver = driver;
-	}
-
-	@Override
-	public boolean isEnabled() {
-		return enabled;
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
-		logger.debug("setEnabled({})", enabled);
-		if (enabled) {
-			try {
-				driver.setEnabled(true);
-				this.enabled = true;
-			}
-			catch (Exception e) {
-				fireMachineEnableFailed(e.getMessage());
-				throw e;
-			}
-			fireMachineEnabled();
-		}
-		else {
-			try {
-				driver.setEnabled(false);
-				this.enabled = false;
-			}
-			catch (Exception e) {
-				fireMachineDisableFailed(e.getMessage());
-				throw e;
-			}
-			fireMachineDisabled("User requested stop.");
-		}
-	}
-
-	@Override
-	public Wizard getConfigurationWizard() {
-	    return new ReferenceMachineConfigurationWizard(this);
-	}
-	
-	@Override
+    private static Logger logger = LoggerFactory.getLogger(ReferenceMachine.class);
+
+    @Element(required = false)
+    private ReferenceDriver driver = new NullDriver();
+
+    private boolean enabled;
+
+    private List<Class<? extends Feeder>> registeredFeederClasses = new ArrayList<>();
+
+    public ReferenceDriver getDriver() {
+        return driver;
+    }
+
+    public void setDriver(ReferenceDriver driver) throws Exception {
+        if (driver != this.driver) {
+            setEnabled(false);
+            close();
+        }
+        this.driver = driver;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
+        logger.debug("setEnabled({})", enabled);
+        if (enabled) {
+            try {
+                driver.setEnabled(true);
+                this.enabled = true;
+            }
+            catch (Exception e) {
+                fireMachineEnableFailed(e.getMessage());
+                throw e;
+            }
+            fireMachineEnabled();
+        }
+        else {
+            try {
+                driver.setEnabled(false);
+                this.enabled = false;
+            }
+            catch (Exception e) {
+                fireMachineDisableFailed(e.getMessage());
+                throw e;
+            }
+            fireMachineDisabled("User requested stop.");
+        }
+    }
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new ReferenceMachineConfigurationWizard(this);
+    }
+
+    @Override
     public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName();
+        return getClass().getSimpleName();
     }
 
     @Override
@@ -122,11 +120,13 @@ public String getPropertySheetHolderTitle() {
         children.add(new SimplePropertySheetHolder("Heads", getHeads()));
         children.add(new SimplePropertySheetHolder("Cameras", getCameras()));
         children.add(new SimplePropertySheetHolder("Actuators", getActuators()));
-        children.add(new SimplePropertySheetHolder("Driver", Collections.singletonList(getDriver())));
-        children.add(new SimplePropertySheetHolder("Job Processors", new ArrayList<>(jobProcessors.values())));
-        return children.toArray(new PropertySheetHolder[]{});
+        children.add(
+                new SimplePropertySheetHolder("Driver", Collections.singletonList(getDriver())));
+        children.add(new SimplePropertySheetHolder("Job Processors",
+                new ArrayList<>(jobProcessors.values())));
+        return children.toArray(new PropertySheetHolder[] {});
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -135,42 +135,41 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     public void registerFeederClass(Class<? extends Feeder> cls) {
         registeredFeederClasses.add(cls);
     }
 
     @Override
-	public List<Class<? extends Feeder>> getCompatibleFeederClasses() {
-		List<Class<? extends Feeder>> l = new ArrayList<>();
+    public List<Class<? extends Feeder>> getCompatibleFeederClasses() {
+        List<Class<? extends Feeder>> l = new ArrayList<>();
         l.add(ReferenceStripFeeder.class);
         l.add(ReferenceTrayFeeder.class);
-		l.add(ReferenceDragFeeder.class);
-		l.add(ReferenceTubeFeeder.class);
-		l.addAll(registeredFeederClasses);
-		return l;
-	}
-
-	@Override
-	public List<Class<? extends Camera>>  getCompatibleCameraClasses() {
-		List<Class<? extends Camera>> l = new ArrayList<>();
-		l.add(LtiCivilCamera.class);
-		l.add(VfwCamera.class);
+        l.add(ReferenceDragFeeder.class);
+        l.add(ReferenceTubeFeeder.class);
+        l.addAll(registeredFeederClasses);
+        return l;
+    }
+
+    @Override
+    public List<Class<? extends Camera>> getCompatibleCameraClasses() {
+        List<Class<? extends Camera>> l = new ArrayList<>();
+        l.add(Webcams.class);
+        l.add(LtiCivilCamera.class);
+        l.add(VfwCamera.class);
         l.add(OpenCvCamera.class);
         l.add(ImageCamera.class);
-		return l;
-	}
-	
+        return l;
+    }
+
     @Override
-	public void home() throws Exception {
-		logger.debug("home");
-		super.home();
-	}
-    
+    public void home() throws Exception {
+        logger.debug("home");
+        super.home();
+    }
+
     @Override
     public void close() throws IOException {
         try {
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceNozzle.java b/src/main/java/org/openpnp/machine/reference/ReferenceNozzle.java
index bac6478ad7..9d46fb74fd 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceNozzle.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceNozzle.java
@@ -21,10 +21,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class ReferenceNozzle extends AbstractNozzle implements
-        ReferenceHeadMountable {
-    private final static Logger logger = LoggerFactory
-            .getLogger(ReferenceNozzle.class);
+public class ReferenceNozzle extends AbstractNozzle implements ReferenceHeadMountable {
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceNozzle.class);
 
     @Element
     private Location headOffsets;
@@ -34,25 +32,24 @@
 
     @Attribute(required = false)
     private int placeDwellMilliseconds;
-    
+
     @Attribute(required = false)
     private String currentNozzleTipId;
-    
+
     @Attribute(required = false)
     private boolean changerEnabled = false;
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected Length safeZ = new Length(0, LengthUnit.Millimeters);
-   
-    
+
+
     /**
-     * If limitRotation is enabled the nozzle will reverse directions when
-     * commanded to rotate past 180 degrees. So, 190 degrees becomes -170
-     * and -190 becomes 170.
+     * If limitRotation is enabled the nozzle will reverse directions when commanded to rotate past
+     * 180 degrees. So, 190 degrees becomes -170 and -190 becomes 170.
      */
     @Attribute(required = false)
     private boolean limitRotation = true;
-    
+
     protected NozzleTip nozzleTip;
 
     protected ReferenceMachine machine;
@@ -61,15 +58,14 @@
     public ReferenceNozzle() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 machine = (ReferenceMachine) configuration.getMachine();
                 driver = machine.getDriver();
                 nozzleTip = nozzleTips.get(currentNozzleTipId);
             }
         });
     }
-    
+
     public boolean isLimitRotation() {
         return limitRotation;
     }
@@ -98,7 +94,7 @@ public void setPlaceDwellMilliseconds(int placeDwellMilliseconds) {
     public Location getHeadOffsets() {
         return headOffsets;
     }
-    
+
     @Override
     public void setHeadOffsets(Location headOffsets) {
         this.headOffsets = headOffsets;
@@ -111,30 +107,31 @@ public NozzleTip getNozzleTip() {
 
     @Override
     public void pick() throws Exception {
-		logger.debug("{}.pick()", getName());
-		if (nozzleTip == null) {
-		    throw new Exception("Can't pick, no nozzle tip loaded");
-		}
-		driver.pick(this);
+        logger.debug("{}.pick()", getName());
+        if (nozzleTip == null) {
+            throw new Exception("Can't pick, no nozzle tip loaded");
+        }
+        driver.pick(this);
         machine.fireMachineHeadActivity(head);
         Thread.sleep(pickDwellMilliseconds);
     }
 
     @Override
     public void place() throws Exception {
-		logger.debug("{}.place()", getName());
+        logger.debug("{}.place()", getName());
         if (nozzleTip == null) {
             throw new Exception("Can't place, no nozzle tip loaded");
         }
-		driver.place(this);
+        driver.place(this);
         machine.fireMachineHeadActivity(head);
         Thread.sleep(placeDwellMilliseconds);
     }
 
     @Override
     public void moveTo(Location location, double speed) throws Exception {
-        logger.debug("{}.moveTo({}, {})", new Object[] { getName(), location, speed } );
-        if (limitRotation && !Double.isNaN(location.getRotation()) && Math.abs(location.getRotation()) > 180) {
+        logger.debug("{}.moveTo({}, {})", new Object[] {getName(), location, speed});
+        if (limitRotation && !Double.isNaN(location.getRotation())
+                && Math.abs(location.getRotation()) > 180) {
             if (location.getRotation() < 0) {
                 location = location.derive(null, null, null, location.getRotation() + 360);
             }
@@ -148,14 +145,14 @@ public void moveTo(Location location, double speed) throws Exception {
 
     @Override
     public void moveToSafeZ(double speed) throws Exception {
-        logger.debug("{}.moveToSafeZ({})", new Object[] { getName(), speed } );
+        logger.debug("{}.moveToSafeZ({})", new Object[] {getName(), speed});
         Length safeZ = this.safeZ.convertToUnits(getLocation().getUnits());
-        Location l = new Location(getLocation().getUnits(), Double.NaN,
-                Double.NaN, safeZ.getValue(), Double.NaN);
+        Location l = new Location(getLocation().getUnits(), Double.NaN, Double.NaN,
+                safeZ.getValue(), Double.NaN);
         driver.moveTo(this, l, speed);
         machine.fireMachineHeadActivity(head);
     }
-    
+
     @Override
     public void loadNozzleTip(NozzleTip nozzleTip) throws Exception {
         if (this.nozzleTip == nozzleTip) {
@@ -165,18 +162,23 @@ public void loadNozzleTip(NozzleTip nozzleTip) throws Exception {
             throw new Exception("Can't load nozzle tip, nozzle tip changer is not enabled.");
         }
         unloadNozzleTip();
-        logger.debug("{}.loadNozzleTip({}): Start", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): Start", new Object[] {getName(), nozzleTip.getName()});
         ReferenceNozzleTip nt = (ReferenceNozzleTip) nozzleTip;
-        logger.debug("{}.loadNozzleTip({}): moveToSafeZ", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): moveToSafeZ",
+                new Object[] {getName(), nozzleTip.getName()});
         moveToSafeZ(1.0);
-        logger.debug("{}.loadNozzleTip({}): moveTo Start Location", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): moveTo Start Location",
+                new Object[] {getName(), nozzleTip.getName()});
         moveTo(nt.getChangerStartLocation(), 1.0);
-        logger.debug("{}.loadNozzleTip({}): moveTo Mid Location", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): moveTo Mid Location",
+                new Object[] {getName(), nozzleTip.getName()});
         moveTo(nt.getChangerMidLocation(), 0.25);
-        logger.debug("{}.loadNozzleTip({}): moveTo End Location", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): moveTo End Location",
+                new Object[] {getName(), nozzleTip.getName()});
         moveTo(nt.getChangerEndLocation(), 1.0);
         moveToSafeZ(1.0);
-        logger.debug("{}.loadNozzleTip({}): Finished", new Object[]{getName(), nozzleTip.getName()});
+        logger.debug("{}.loadNozzleTip({}): Finished",
+                new Object[] {getName(), nozzleTip.getName()});
         this.nozzleTip = nozzleTip;
         currentNozzleTipId = nozzleTip.getId();
     }
@@ -189,18 +191,18 @@ public void unloadNozzleTip() throws Exception {
         if (!changerEnabled) {
             throw new Exception("Can't unload nozzle tip, nozzle tip changer is not enabled.");
         }
-        logger.debug("{}.unloadNozzleTip(): Start", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): Start", new Object[] {getName()});
         ReferenceNozzleTip nt = (ReferenceNozzleTip) nozzleTip;
-        logger.debug("{}.unloadNozzleTip(): moveToSafeZ", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): moveToSafeZ", new Object[] {getName()});
         moveToSafeZ(1.0);
-        logger.debug("{}.unloadNozzleTip(): moveTo End Location", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): moveTo End Location", new Object[] {getName()});
         moveTo(nt.getChangerEndLocation(), 1.0);
-        logger.debug("{}.unloadNozzleTip(): moveTo Mid Location", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): moveTo Mid Location", new Object[] {getName()});
         moveTo(nt.getChangerMidLocation(), 1.0);
-        logger.debug("{}.unloadNozzleTip(): moveTo Start Location", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): moveTo Start Location", new Object[] {getName()});
         moveTo(nt.getChangerStartLocation(), 0.25);
         moveToSafeZ(1.0);
-        logger.debug("{}.unloadNozzleTip(): Finished", new Object[]{getName()});
+        logger.debug("{}.unloadNozzleTip(): Finished", new Object[] {getName()});
         nozzleTip = null;
         currentNozzleTipId = null;
     }
@@ -209,7 +211,7 @@ public void unloadNozzleTip() throws Exception {
     public Location getLocation() {
         return driver.getLocation(this);
     }
-    
+
     public boolean isChangerEnabled() {
         return changerEnabled;
     }
@@ -222,26 +224,24 @@ public void setChangerEnabled(boolean changerEnabled) {
     public Wizard getConfigurationWizard() {
         return new ReferenceNozzleConfigurationWizard(this);
     }
-    
-	@Override
+
+    @Override
     public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName() + " " + getName();
+        return getClass().getSimpleName() + " " + getName();
     }
 
     @Override
     public PropertySheetHolder[] getChildPropertySheetHolders() {
         ArrayList<PropertySheetHolder> children = new ArrayList<>();
         children.add(new SimplePropertySheetHolder("Nozzle Tips", getNozzleTips()));
-        return children.toArray(new PropertySheetHolder[]{});
+        return children.toArray(new PropertySheetHolder[] {});
     }
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-        
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -249,15 +249,15 @@ public String getPropertySheetHolderTitle() {
     }
 
     @Override
-	public String toString() {
-		return getName();
-	}
-    
-	public Length getSafeZ() {
-		return safeZ;
-	}
-
-	public void setSafeZ(Length safeZ) {
-		this.safeZ = safeZ;
-	}
+    public String toString() {
+        return getName();
+    }
+
+    public Length getSafeZ() {
+        return safeZ;
+    }
+
+    public void setSafeZ(Length safeZ) {
+        this.safeZ = safeZ;
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceNozzleTip.java b/src/main/java/org/openpnp/machine/reference/ReferenceNozzleTip.java
index cd3383a869..c07bc69954 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceNozzleTip.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceNozzleTip.java
@@ -1,18 +1,14 @@
 package org.openpnp.machine.reference;
 
-import java.awt.Component;
 import java.awt.event.ActionEvent;
 import java.util.HashSet;
 import java.util.Set;
 
 import javax.swing.AbstractAction;
 import javax.swing.Action;
-import javax.swing.JComponent;
 
 import org.openpnp.ConfigurationListener;
-import org.openpnp.gui.MainFrame;
 import org.openpnp.gui.support.Icons;
-import org.openpnp.gui.support.MessageBoxes;
 import org.openpnp.gui.support.PropertySheetWizardAdapter;
 import org.openpnp.gui.support.Wizard;
 import org.openpnp.machine.reference.wizards.ReferenceNozzleTipConfigurationWizard;
@@ -33,15 +29,14 @@
 import org.slf4j.LoggerFactory;
 
 public class ReferenceNozzleTip extends AbstractNozzleTip {
-    private final static Logger logger = LoggerFactory
-            .getLogger(ReferenceNozzleTip.class);
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceNozzleTip.class);
 
     @ElementList(required = false, entry = "id")
     private Set<String> compatiblePackageIds = new HashSet<>();
-    
+
     @Attribute(required = false)
     private boolean allowIncompatiblePackages;
-    
+
     @Element(required = false)
     private Location changerStartLocation = new Location(LengthUnit.Millimeters);
     @Element(required = false)
@@ -50,12 +45,11 @@
     private Location changerEndLocation = new Location(LengthUnit.Millimeters);
 
     private Set<org.openpnp.model.Package> compatiblePackages = new HashSet<>();
-    
+
     public ReferenceNozzleTip() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 for (String id : compatiblePackageIds) {
                     org.openpnp.model.Package pkg = configuration.getPackage(id);
                     if (pkg == null) {
@@ -69,18 +63,17 @@ public void configurationLoaded(Configuration configuration)
 
     @Override
     public boolean canHandle(Part part) {
-        boolean result = allowIncompatiblePackages
-                || compatiblePackages.contains(part.getPackage());
-		logger.debug("{}.canHandle({}) => {}", new Object[]{getName(), part.getId(), result});
-		return result;
-	}
-    
-	public Set<org.openpnp.model.Package> getCompatiblePackages() {
+        boolean result =
+                allowIncompatiblePackages || compatiblePackages.contains(part.getPackage());
+        logger.debug("{}.canHandle({}) => {}", new Object[] {getName(), part.getId(), result});
+        return result;
+    }
+
+    public Set<org.openpnp.model.Package> getCompatiblePackages() {
         return new HashSet<>(compatiblePackages);
     }
 
-    public void setCompatiblePackages(
-            Set<org.openpnp.model.Package> compatiblePackages) {
+    public void setCompatiblePackages(Set<org.openpnp.model.Package> compatiblePackages) {
         this.compatiblePackages.clear();
         this.compatiblePackages.addAll(compatiblePackages);
         compatiblePackageIds.clear();
@@ -90,14 +83,14 @@ public void setCompatiblePackages(
     }
 
     @Override
-	public String toString() {
-		return getName();
-	}
+    public String toString() {
+        return getName();
+    }
 
-	@Override
-	public Wizard getConfigurationWizard() {
-	    return new ReferenceNozzleTipConfigurationWizard(this);
-	}
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new ReferenceNozzleTipConfigurationWizard(this);
+    }
 
     @Override
     public String getPropertySheetHolderTitle() {
@@ -109,20 +102,15 @@ public String getPropertySheetHolderTitle() {
         // TODO Auto-generated method stub
         return null;
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
-        return new Action[] {
-                unloadAction,
-                loadAction
-        };
+        return new Action[] {unloadAction, loadAction};
     }
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 
     public boolean isAllowIncompatiblePackages() {
@@ -156,7 +144,7 @@ public Location getChangerEndLocation() {
     public void setChangerEndLocation(Location changerEndLocation) {
         this.changerEndLocation = changerEndLocation;
     }
-    
+
     private Nozzle getParentNozzle() {
         for (Head head : Configuration.get().getMachine().getHeads()) {
             for (Nozzle nozzle : head.getNozzles()) {
@@ -169,36 +157,34 @@ private Nozzle getParentNozzle() {
         }
         return null;
     }
-    
+
     public Action loadAction = new AbstractAction("Load") {
         {
             putValue(SMALL_ICON, Icons.load);
             putValue(NAME, "Load");
-            putValue(SHORT_DESCRIPTION,
-                    "Load the currently selected nozzle tip.");
+            putValue(SHORT_DESCRIPTION, "Load the currently selected nozzle tip.");
         }
-        
+
         @Override
         public void actionPerformed(final ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 getParentNozzle().loadNozzleTip(ReferenceNozzleTip.this);
-        	});
+            });
         }
     };
-    
+
     public Action unloadAction = new AbstractAction("Unoad") {
         {
             putValue(SMALL_ICON, Icons.unload);
             putValue(NAME, "Unload");
-            putValue(SHORT_DESCRIPTION,
-                    "Unoad the currently loaded nozzle tip.");
+            putValue(SHORT_DESCRIPTION, "Unoad the currently loaded nozzle tip.");
         }
-        
+
         @Override
         public void actionPerformed(final ActionEvent arg0) {
-        	UiUtils.submitUiMachineTask(() -> {
+            UiUtils.submitUiMachineTask(() -> {
                 getParentNozzle().unloadNozzleTip();
-        	});
+            });
         }
     };
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferencePasteDispenser.java b/src/main/java/org/openpnp/machine/reference/ReferencePasteDispenser.java
index 0851749407..7b3e70cfac 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferencePasteDispenser.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferencePasteDispenser.java
@@ -12,84 +12,82 @@
 import org.openpnp.model.Location;
 import org.openpnp.spi.PropertySheetHolder;
 import org.openpnp.spi.base.AbstractPasteDispenser;
-import org.simpleframework.xml.Attribute;
 import org.simpleframework.xml.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class ReferencePasteDispenser extends AbstractPasteDispenser implements
-        ReferenceHeadMountable {
-    private final static Logger logger = LoggerFactory
-            .getLogger(ReferencePasteDispenser.class);
+public class ReferencePasteDispenser extends AbstractPasteDispenser
+        implements ReferenceHeadMountable {
+    private final static Logger logger = LoggerFactory.getLogger(ReferencePasteDispenser.class);
 
     @Element
     private Location headOffsets;
 
-    @Element(required=false)
+    @Element(required = false)
     protected Length safeZ = new Length(0, LengthUnit.Millimeters);
-   
+
     protected ReferenceMachine machine;
     protected ReferenceDriver driver;
 
     public ReferencePasteDispenser() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 machine = (ReferenceMachine) configuration.getMachine();
                 driver = machine.getDriver();
             }
         });
     }
-    
+
     @Override
     public Location getHeadOffsets() {
         return headOffsets;
     }
-    
+
     @Override
     public void setHeadOffsets(Location headOffsets) {
         this.headOffsets = headOffsets;
     }
 
     @Override
-    public void dispense(Location startLocation, Location endLocation, long dispenseTimeMilliseconds) throws Exception {
-		logger.debug("{}.dispense()", getName());
-		Thread.sleep(dispenseTimeMilliseconds);
-		driver.dispense(this, startLocation, endLocation, dispenseTimeMilliseconds);
+    public void dispense(Location startLocation, Location endLocation,
+            long dispenseTimeMilliseconds) throws Exception {
+        logger.debug("{}.dispense()", getName());
+        Thread.sleep(dispenseTimeMilliseconds);
+        driver.dispense(this, startLocation, endLocation, dispenseTimeMilliseconds);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
     public void moveTo(Location location, double speed) throws Exception {
-        logger.debug("{}.moveTo({}, {})", new Object[] { getName(), location, speed } );
+        logger.debug("{}.moveTo({}, {})", new Object[] {getName(), location, speed});
         driver.moveTo(this, location, speed);
         machine.fireMachineHeadActivity(head);
     }
 
     @Override
     public void moveToSafeZ(double speed) throws Exception {
-        logger.debug("{}.moveToSafeZ({})", new Object[] { getName(), speed } );
+        logger.debug("{}.moveToSafeZ({})", new Object[] {getName(), speed});
         Length safeZ = this.safeZ.convertToUnits(getLocation().getUnits());
-        Location l = new Location(getLocation().getUnits(), Double.NaN,
-                Double.NaN, safeZ.getValue(), Double.NaN);
+        Location l = new Location(getLocation().getUnits(), Double.NaN, Double.NaN,
+                safeZ.getValue(), Double.NaN);
         driver.moveTo(this, l, speed);
         machine.fireMachineHeadActivity(head);
     }
-    
+
     @Override
     public Location getLocation() {
         return driver.getLocation(this);
     }
-    
+
     @Override
     public Wizard getConfigurationWizard() {
         return new ReferencePasteDispenserConfigurationWizard(this);
     }
-    
-	@Override
+
+    @Override
     public String getPropertySheetHolderTitle() {
-	    return getClass().getSimpleName() + " " + getName();
+        return getClass().getSimpleName() + " " + getName();
     }
 
     @Override
@@ -99,11 +97,9 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-        
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -111,15 +107,15 @@ public String getPropertySheetHolderTitle() {
     }
 
     @Override
-	public String toString() {
-		return getName();
-	}
+    public String toString() {
+        return getName();
+    }
 
-	public Length getSafeZ() {
-		return safeZ;
-	}
+    public Length getSafeZ() {
+        return safeZ;
+    }
 
-	public void setSafeZ(Length safeZ) {
-		this.safeZ = safeZ;
-	}
+    public void setSafeZ(Length safeZ) {
+        this.safeZ = safeZ;
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/ReferenceSolderPasteJobProcessor.java b/src/main/java/org/openpnp/machine/reference/ReferenceSolderPasteJobProcessor.java
index 3e1f3f553c..b0cdf70274 100755
--- a/src/main/java/org/openpnp/machine/reference/ReferenceSolderPasteJobProcessor.java
+++ b/src/main/java/org/openpnp/machine/reference/ReferenceSolderPasteJobProcessor.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference;
@@ -37,63 +35,63 @@
 import org.slf4j.LoggerFactory;
 
 public class ReferenceSolderPasteJobProcessor extends AbstractJobProcessor {
-	private static final Logger logger = LoggerFactory.getLogger(ReferenceSolderPasteJobProcessor.class);
-	
-	@Attribute(required=false)
-	private String dummy;
-	
-	public ReferenceSolderPasteJobProcessor() {
-	}
-	
-	@Override
+    private static final Logger logger =
+            LoggerFactory.getLogger(ReferenceSolderPasteJobProcessor.class);
+
+    @Attribute(required = false)
+    private String dummy;
+
+    public ReferenceSolderPasteJobProcessor() {}
+
+    @Override
     public void run() {
-		state = JobState.Running;
-		fireJobStateChanged();
-		
-		Machine machine = Configuration.get().getMachine();
-		
-		for (Head head : machine.getHeads()) {
-			fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));		
-	
-			if (!shouldJobProcessingContinue()) {
-				return;
-			}
-	
-			try {
-				head.moveToSafeZ(1.0);
-			}
-			catch (Exception e) {
-				fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
-				return;
-			}
-		}
-		
-		Head head = machine.getHeads().get(0);
-		PasteDispenser dispenser = head.getPasteDispensers().get(0);
-
-		for (BoardLocation boardLocation : job.getBoardLocations()) {
-			if (!boardLocation.isEnabled()) {
-				continue;
-			}
-		    for (BoardPad pad : boardLocation.getBoard().getSolderPastePads()) {
-		        if (pad.getSide() != boardLocation.getSide()) {
-		            continue;
-		        }
-	            Location location = pad.getLocation();
-	            location = Utils2D.calculateBoardPlacementLocation(
-	            		boardLocation, location);
-
-	            fireDetailedStatusUpdated(String.format("Move to pad location, safe Z at (%s).", location));
-	            if (!shouldJobProcessingContinue()) {
-	                return;
-	            }
-	            try {
+        state = JobState.Running;
+        fireJobStateChanged();
+
+        Machine machine = Configuration.get().getMachine();
+
+        for (Head head : machine.getHeads()) {
+            fireDetailedStatusUpdated(String.format("Move head %s to Safe-Z.", head.getName()));
+
+            if (!shouldJobProcessingContinue()) {
+                return;
+            }
+
+            try {
+                head.moveToSafeZ(1.0);
+            }
+            catch (Exception e) {
+                fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
+                return;
+            }
+        }
+
+        Head head = machine.getHeads().get(0);
+        PasteDispenser dispenser = head.getPasteDispensers().get(0);
+
+        for (BoardLocation boardLocation : job.getBoardLocations()) {
+            if (!boardLocation.isEnabled()) {
+                continue;
+            }
+            for (BoardPad pad : boardLocation.getBoard().getSolderPastePads()) {
+                if (pad.getSide() != boardLocation.getSide()) {
+                    continue;
+                }
+                Location location = pad.getLocation();
+                location = Utils2D.calculateBoardPlacementLocation(boardLocation, location);
+
+                fireDetailedStatusUpdated(
+                        String.format("Move to pad location, safe Z at (%s).", location));
+                if (!shouldJobProcessingContinue()) {
+                    return;
+                }
+                try {
                     MovableUtils.moveToLocationAtSafeZ(dispenser, location, 1.0);
-	            }
-	            catch (Exception e) {
-	                fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
-	            }
-	            
+                }
+                catch (Exception e) {
+                    fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
+                }
+
                 fireDetailedStatusUpdated(String.format("Dispense.", location));
                 if (!shouldJobProcessingContinue()) {
                     return;
@@ -108,15 +106,15 @@ public void run() {
                 catch (Exception e) {
                     fireJobEncounteredError(JobError.MachineMovementError, e.getMessage());
                 }
-		    }
-		}
-		
-		fireDetailedStatusUpdated("Job complete.");
-		
-		state = JobState.Stopped;
-		fireJobStateChanged();
-	}
-	
+            }
+        }
+
+        fireDetailedStatusUpdated("Job complete.");
+
+        state = JobState.Stopped;
+        fireJobStateChanged();
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return null;
diff --git a/src/main/java/org/openpnp/machine/reference/camera/ImageCamera.java b/src/main/java/org/openpnp/machine/reference/camera/ImageCamera.java
index 586cf751f0..88a381de52 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/ImageCamera.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/ImageCamera.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.camera;
 
@@ -45,155 +43,143 @@
 import org.slf4j.LoggerFactory;
 
 public class ImageCamera extends ReferenceCamera implements Runnable {
-	private final static Logger logger = LoggerFactory.getLogger(ImageCamera.class);
-	
-	private PropertyChangeSupport pcs = new PropertyChangeSupport(this);
-	
-	@Attribute(required=false)
-	private int fps = 24;
-	
-	@Element
-	private String sourceUri = "classpath://samples/pnp-test/pnp-test.png";
-	
-	@Attribute(required=false)
-	private int width = 640;
-	
-	@Attribute(required=false)
-	private int height = 480;
-	    
-	private BufferedImage source;
-	
-	private Thread thread;
-	
-	public ImageCamera() {
-	    unitsPerPixel = new Location(LengthUnit.Inches, 0.04233, 0.04233, 0, 0);
-	}
-	
-	@SuppressWarnings("unused")
-	@Commit
-	private void commit() throws Exception {
-	    setSourceUri(sourceUri);
-	}
-	
-	@Override
-	public synchronized void startContinuousCapture(CameraListener listener, int maximumFps) {
-		start();
-		super.startContinuousCapture(listener, maximumFps);
-	}
-	
-	@Override
-	public synchronized void stopContinuousCapture(CameraListener listener) {
-		super.stopContinuousCapture(listener);
-		if (listeners.size() == 0) {
-			stop();
-		}
-	}
-	
-	private synchronized void stop() {
-		if (thread != null && thread.isAlive()) {
-			thread.interrupt();
-			try {
-				thread.join();
-			}
-			catch (Exception e) {
-				
-			}
-			thread = null;
-		}
-	}
-	
-	private synchronized void start() {
-		if (thread == null) {
-			thread = new Thread(this);
-			thread.start();
-		}
-	}
-
-	public String getSourceUri() {
-		return sourceUri;
-	}
-
-	public void setSourceUri(String sourceUri) throws Exception {
-		String oldValue = this.sourceUri;
-		this.sourceUri = sourceUri;
-		pcs.firePropertyChange("sourceUri", oldValue, sourceUri);
-		initialize();
-	}
-	
-	@Override
-	public synchronized BufferedImage capture() {
+    private final static Logger logger = LoggerFactory.getLogger(ImageCamera.class);
+
+    private PropertyChangeSupport pcs = new PropertyChangeSupport(this);
+
+    @Attribute(required = false)
+    private int fps = 24;
+
+    @Element
+    private String sourceUri = "classpath://samples/pnp-test/pnp-test.png";
+
+    @Attribute(required = false)
+    private int width = 640;
+
+    @Attribute(required = false)
+    private int height = 480;
+
+    private BufferedImage source;
+
+    private Thread thread;
+
+    public ImageCamera() {
+        unitsPerPixel = new Location(LengthUnit.Inches, 0.04233, 0.04233, 0, 0);
+    }
+
+    @SuppressWarnings("unused")
+    @Commit
+    private void commit() throws Exception {
+        setSourceUri(sourceUri);
+    }
+
+    @Override
+    public synchronized void startContinuousCapture(CameraListener listener, int maximumFps) {
+        start();
+        super.startContinuousCapture(listener, maximumFps);
+    }
+
+    @Override
+    public synchronized void stopContinuousCapture(CameraListener listener) {
+        super.stopContinuousCapture(listener);
+        if (listeners.size() == 0) {
+            stop();
+        }
+    }
+
+    private synchronized void stop() {
+        if (thread != null && thread.isAlive()) {
+            thread.interrupt();
+            try {
+                thread.join();
+            }
+            catch (Exception e) {
+
+            }
+            thread = null;
+        }
+    }
+
+    private synchronized void start() {
+        if (thread == null) {
+            thread = new Thread(this);
+            thread.start();
+        }
+    }
+
+    public String getSourceUri() {
+        return sourceUri;
+    }
+
+    public void setSourceUri(String sourceUri) throws Exception {
+        String oldValue = this.sourceUri;
+        this.sourceUri = sourceUri;
+        pcs.firePropertyChange("sourceUri", oldValue, sourceUri);
+        initialize();
+    }
+
+    @Override
+    public synchronized BufferedImage capture() {
         /*
-         * Create a buffer that we will render the center tile and it's
-         * surrounding tiles to. 
+         * Create a buffer that we will render the center tile and it's surrounding tiles to.
          */
-        BufferedImage frame = new BufferedImage(
-                width,
-                height,
-                BufferedImage.TYPE_INT_ARGB);
+        BufferedImage frame = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
 
         Graphics gFrame = frame.getGraphics();
-        
+
         Location location = getLocation();
         double locationX = location.getX();
         double locationY = location.getY();
 
         double pixelX = locationX / getUnitsPerPixel().getX();
         double pixelY = locationY / getUnitsPerPixel().getY();
-        
+
         int dx1 = (int) (pixelX - (width / 2));
         int dy1 = (int) (source.getHeight() - (pixelY + (height / 2)));
-        
-        gFrame.drawImage(
-                source, 
-                0, 
-                0, 
-                width - 1, 
-                height - 1, 
-                dx1, 
-                dy1, 
-                dx1 + width - 1, 
-                dy1 + height - 1, 
-                null);
-        
+
+        gFrame.drawImage(source, 0, 0, width - 1, height - 1, dx1, dy1, dx1 + width - 1,
+                dy1 + height - 1, null);
+
         gFrame.dispose();
-        
-	    return transformImage(frame);
-	}
-	
+
+        return transformImage(frame);
+    }
+
     private synchronized void initialize() throws Exception {
         stop();
 
         if (sourceUri.startsWith("classpath://")) {
-            source = ImageIO.read(getClass().getClassLoader().getResourceAsStream(sourceUri.substring("classpath://".length())));
+            source = ImageIO.read(getClass().getClassLoader()
+                    .getResourceAsStream(sourceUri.substring("classpath://".length())));
         }
         else {
             source = ImageIO.read(new URL(sourceUri));
         }
-        
+
         if (listeners.size() > 0) {
             start();
         }
     }
-	
-	
-	public void run() {
-		while (!Thread.interrupted()) {
-			BufferedImage frame = capture();
-			broadcastCapture(frame);
-			try {
-				Thread.sleep(1000 / fps);
-			}
-			catch (InterruptedException e) {
-				return;
-			}
-		}
-	}
-	
-	@Override
-	public Wizard getConfigurationWizard() {
-		return new ImageCameraConfigurationWizard(this);
-	}
-	
+
+
+    public void run() {
+        while (!Thread.interrupted()) {
+            BufferedImage frame = capture();
+            broadcastCapture(frame);
+            try {
+                Thread.sleep(1000 / fps);
+            }
+            catch (InterruptedException e) {
+                return;
+            }
+        }
+    }
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new ImageCameraConfigurationWizard(this);
+    }
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -209,10 +195,9 @@ public String getPropertySheetHolderTitle() {
     public PropertySheet[] getPropertySheets() {
         return new PropertySheet[] {
                 new PropertySheetWizardAdapter(new CameraConfigurationWizard(this)),
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+                new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-	
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
diff --git a/src/main/java/org/openpnp/machine/reference/camera/LtiCivilCamera.java b/src/main/java/org/openpnp/machine/reference/camera/LtiCivilCamera.java
index e548ceeda8..c4a13a81ca 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/LtiCivilCamera.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/LtiCivilCamera.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.camera;
@@ -51,114 +49,114 @@
 
 @Deprecated
 public class LtiCivilCamera extends ReferenceCamera implements CaptureObserver {
-	private CaptureSystemFactory captureSystemFactory;
-	private CaptureSystem captureSystem;
-	private CaptureStream captureStream;
-	private VideoFormat videoFormat;
-
-	@Attribute(required=false)
-	private String deviceId;
-	@Attribute(required=false)
-	private boolean forceGrayscale;
-	
-	private int width, height;
-	
-	private BufferedImage lastImage;
-	
-	private Object captureLock = new Object();
-	
-	public LtiCivilCamera() {
-		Configuration.get().addListener(new ConfigurationListener.Adapter() {
-            
+    private CaptureSystemFactory captureSystemFactory;
+    private CaptureSystem captureSystem;
+    private CaptureStream captureStream;
+    private VideoFormat videoFormat;
+
+    @Attribute(required = false)
+    private String deviceId;
+    @Attribute(required = false)
+    private boolean forceGrayscale;
+
+    private int width, height;
+
+    private BufferedImage lastImage;
+
+    private Object captureLock = new Object();
+
+    public LtiCivilCamera() {
+        Configuration.get().addListener(new ConfigurationListener.Adapter() {
+
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 captureSystemFactory = DefaultCaptureSystemFactorySingleton.instance();
                 captureSystem = captureSystemFactory.createCaptureSystem();
-                
+
                 if (deviceId != null && deviceId.trim().length() != 0) {
                     setDeviceId(deviceId);
                 }
             }
         });
-	}
-
-	public void setDeviceId(String deviceId) throws Exception {
-		if (captureStream != null) {
-			captureStream.stop();
-			captureStream.dispose();
-		}
-		captureStream = captureSystem.openCaptureDeviceStream(deviceId);
-		videoFormat = captureStream.getVideoFormat();
-		width = videoFormat.getWidth();
-		height = videoFormat.getHeight();
-		captureStream.setObserver(this);
-		captureStream.start();
-		this.deviceId = deviceId;
-	}
-	
-	public String getDeviceId() {
-		return deviceId;
-	}
-
-	public boolean isForceGrayscale() {
-		return forceGrayscale;
-	}
-
-	public void setForceGrayscale(boolean forceGrayscale) {
-		this.forceGrayscale = forceGrayscale;
-	}
-
-	public List<String> getDeviceIds() throws Exception {
-		ArrayList<String> deviceIds = new ArrayList<>();
-		for (CaptureDeviceInfo captureDeviceInfo : (List<CaptureDeviceInfo>) captureSystem.getCaptureDeviceInfoList()) {
-			deviceIds.add(captureDeviceInfo.getDeviceID());
-		}
-		return deviceIds;
-	}
-	
-	@Override
-	public void onError(CaptureStream captureStream, CaptureException captureException) {
-	}
-
-	@Override
-	public void onNewImage(CaptureStream captureStream, Image newImage) {
-		BufferedImage bImage = AWTImageConverter.toBufferedImage(newImage);
-		if (forceGrayscale) {
-			BufferedImage grayImage = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);
-			Graphics g = grayImage.getGraphics();
-			g.drawImage(bImage, 0, 0, null);  
-			g.dispose();
-			lastImage = grayImage;
-		}
-		else {
-		    lastImage = bImage;
-		}
-		lastImage = transformImage(lastImage);
+    }
+
+    public void setDeviceId(String deviceId) throws Exception {
+        if (captureStream != null) {
+            captureStream.stop();
+            captureStream.dispose();
+        }
+        captureStream = captureSystem.openCaptureDeviceStream(deviceId);
+        videoFormat = captureStream.getVideoFormat();
+        width = videoFormat.getWidth();
+        height = videoFormat.getHeight();
+        captureStream.setObserver(this);
+        captureStream.start();
+        this.deviceId = deviceId;
+    }
+
+    public String getDeviceId() {
+        return deviceId;
+    }
+
+    public boolean isForceGrayscale() {
+        return forceGrayscale;
+    }
+
+    public void setForceGrayscale(boolean forceGrayscale) {
+        this.forceGrayscale = forceGrayscale;
+    }
+
+    public List<String> getDeviceIds() throws Exception {
+        ArrayList<String> deviceIds = new ArrayList<>();
+        for (CaptureDeviceInfo captureDeviceInfo : (List<CaptureDeviceInfo>) captureSystem
+                .getCaptureDeviceInfoList()) {
+            deviceIds.add(captureDeviceInfo.getDeviceID());
+        }
+        return deviceIds;
+    }
+
+    @Override
+    public void onError(CaptureStream captureStream, CaptureException captureException) {}
+
+    @Override
+    public void onNewImage(CaptureStream captureStream, Image newImage) {
+        BufferedImage bImage = AWTImageConverter.toBufferedImage(newImage);
+        if (forceGrayscale) {
+            BufferedImage grayImage =
+                    new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);
+            Graphics g = grayImage.getGraphics();
+            g.drawImage(bImage, 0, 0, null);
+            g.dispose();
+            lastImage = grayImage;
+        }
+        else {
+            lastImage = bImage;
+        }
+        lastImage = transformImage(lastImage);
         broadcastCapture(lastImage);
-		synchronized (captureLock) {
-			captureLock.notify();
-		}
-	}
-
-	@Override
-	public BufferedImage capture() {
-		synchronized (captureLock) {
-			try {
-				captureLock.wait();
-				BufferedImage image = lastImage;
-				return image;
-			}
-			catch (Exception e) {
-				return null;
-			}
-		}
-	}
-
-	@Override
-	public Wizard getConfigurationWizard() {
-		return new LtiCivilCameraConfigurationWizard(this);
-	}
+        synchronized (captureLock) {
+            captureLock.notify();
+        }
+    }
+
+    @Override
+    public BufferedImage capture() {
+        synchronized (captureLock) {
+            try {
+                captureLock.wait();
+                BufferedImage image = lastImage;
+                return image;
+            }
+            catch (Exception e) {
+                return null;
+            }
+        }
+    }
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new LtiCivilCameraConfigurationWizard(this);
+    }
 
     @Override
     public String getPropertySheetHolderTitle() {
@@ -181,7 +179,6 @@ public String getPropertySheetHolderTitle() {
     public PropertySheet[] getPropertySheets() {
         return new PropertySheet[] {
                 new PropertySheetWizardAdapter(new CameraConfigurationWizard(this)),
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }    
+                new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/camera/OpenCvCamera.java b/src/main/java/org/openpnp/machine/reference/camera/OpenCvCamera.java
index 175bbe9435..48851c12f5 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/OpenCvCamera.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/OpenCvCamera.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.camera;
@@ -46,106 +44,105 @@
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
-    }    
-    
-	@Attribute(name="deviceIndex", required=true)
-	private int deviceIndex = 0;
-	
-	@Attribute(required=false)
-	private int preferredWidth;
-	@Attribute(required=false)
-	private int preferredHeight;
-	
-	private VideoCapture fg = new VideoCapture();
-	private Thread thread;
-	private boolean dirty = false;
-	
-	public OpenCvCamera() {
-	}
-	
-	@Override
-	public synchronized BufferedImage capture() {
-	    if (thread == null) {
-	        setDeviceIndex(deviceIndex);
-	    }
-		try {
-		    Mat mat = new Mat();
-		    if (!fg.read(mat)) {
-		        return null;
-		    }
-		    BufferedImage img = OpenCvUtils.toBufferedImage(mat);
-		    mat.release();
-		    return transformImage(img);
-		}
-		catch (Exception e) {
-			return null;
-		}
-	}
-	
-	@Override
+    }
+
+    @Attribute(name = "deviceIndex", required = true)
+    private int deviceIndex = 0;
+
+    @Attribute(required = false)
+    private int preferredWidth;
+    @Attribute(required = false)
+    private int preferredHeight;
+
+    private VideoCapture fg = new VideoCapture();
+    private Thread thread;
+    private boolean dirty = false;
+
+    public OpenCvCamera() {}
+
+    @Override
+    public synchronized BufferedImage capture() {
+        if (thread == null) {
+            setDeviceIndex(deviceIndex);
+        }
+        try {
+            Mat mat = new Mat();
+            if (!fg.read(mat)) {
+                return null;
+            }
+            BufferedImage img = OpenCvUtils.toBufferedImage(mat);
+            mat.release();
+            return transformImage(img);
+        }
+        catch (Exception e) {
+            return null;
+        }
+    }
+
+    @Override
     public synchronized void startContinuousCapture(CameraListener listener, int maximumFps) {
-	    if (thread == null) {
-	        setDeviceIndex(deviceIndex);
-	    }
+        if (thread == null) {
+            setDeviceIndex(deviceIndex);
+        }
         super.startContinuousCapture(listener, maximumFps);
     }
 
     public void run() {
-		while (!Thread.interrupted()) {
-			try {
-				BufferedImage image = capture();
-				if (image != null) {
-					broadcastCapture(image);
-				}
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-			try {
-				Thread.sleep(1000 / 24);
-			}
-			catch (InterruptedException e) {
-				break;
-			}
-		}
-	}
-	
-	public int getDeviceIndex() {
-		return deviceIndex;
-	}
-
-	public synchronized void setDeviceIndex(int deviceIndex) {
-		this.deviceIndex = deviceIndex;
-		if (thread != null) {
-			thread.interrupt();
-			try {
-				thread.join();
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-			thread = null;
-		}
-		try {
-		    setDirty(false);
-		    width = null;
-		    height = null;
-		    fg.open(deviceIndex);
+        while (!Thread.interrupted()) {
+            try {
+                BufferedImage image = capture();
+                if (image != null) {
+                    broadcastCapture(image);
+                }
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+            try {
+                Thread.sleep(1000 / 24);
+            }
+            catch (InterruptedException e) {
+                break;
+            }
+        }
+    }
+
+    public int getDeviceIndex() {
+        return deviceIndex;
+    }
+
+    public synchronized void setDeviceIndex(int deviceIndex) {
+        this.deviceIndex = deviceIndex;
+        if (thread != null) {
+            thread.interrupt();
+            try {
+                thread.join();
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+            thread = null;
+        }
+        try {
+            setDirty(false);
+            width = null;
+            height = null;
+            fg.open(deviceIndex);
             if (preferredWidth != 0) {
                 fg.set(Highgui.CV_CAP_PROP_FRAME_WIDTH, preferredWidth);
             }
             if (preferredHeight != 0) {
                 fg.set(Highgui.CV_CAP_PROP_FRAME_HEIGHT, preferredHeight);
             }
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			return;
-		}
-		thread = new Thread(this);
-		thread.start();
-	}
-	
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+            return;
+        }
+        thread = new Thread(this);
+        thread.start();
+    }
+
     public int getPreferredWidth() {
         return preferredWidth;
     }
@@ -163,7 +160,7 @@ public void setPreferredHeight(int preferredHeight) {
         this.preferredHeight = preferredHeight;
         setDirty(true);
     }
-    
+
     public boolean isDirty() {
         return dirty;
     }
@@ -173,10 +170,10 @@ public void setDirty(boolean dirty) {
     }
 
     @Override
-	public Wizard getConfigurationWizard() {
-		return new OpenCvCameraConfigurationWizard(this);
-	}
-    
+    public Wizard getConfigurationWizard() {
+        return new OpenCvCameraConfigurationWizard(this);
+    }
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -192,16 +189,15 @@ public String getPropertySheetHolderTitle() {
     public PropertySheet[] getPropertySheets() {
         return new PropertySheet[] {
                 new PropertySheetWizardAdapter(new CameraConfigurationWizard(this)),
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+                new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
     }
-    
+
     @Override
     public void close() throws IOException {
         super.close();
@@ -211,7 +207,7 @@ public void close() throws IOException {
                 thread.join();
             }
             catch (Exception e) {
-                
+
             }
         }
         if (fg.isOpened()) {
diff --git a/src/main/java/org/openpnp/machine/reference/camera/VfwCamera.java b/src/main/java/org/openpnp/machine/reference/camera/VfwCamera.java
index b047d9b70e..b362768e73 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/VfwCamera.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/VfwCamera.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.camera;
@@ -39,154 +37,153 @@
 import org.vonnieda.vfw.CaptureDevice;
 
 public class VfwCamera extends ReferenceCamera implements Runnable {
-	@Attribute(required=false)
-	private String driver;
-	@Attribute(required=false)
-	private boolean showVideoSourceDialog;
-	@Attribute(required=false)
-	private boolean showVideoFormatDialog;
-	@Attribute(required=false)
-	private boolean showVideoDisplayDialog;
-	
-	private CaptureDevice captureDevice;
-	private int width, height;
-	
-	private BufferedImage lastImage;
-	
-	private Object captureLock = new Object();
-	
-	private Thread captureThread;
-	
-	public VfwCamera() {
+    @Attribute(required = false)
+    private String driver;
+    @Attribute(required = false)
+    private boolean showVideoSourceDialog;
+    @Attribute(required = false)
+    private boolean showVideoFormatDialog;
+    @Attribute(required = false)
+    private boolean showVideoDisplayDialog;
+
+    private CaptureDevice captureDevice;
+    private int width, height;
+
+    private BufferedImage lastImage;
+
+    private Object captureLock = new Object();
+
+    private Thread captureThread;
+
+    public VfwCamera() {
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
-            
+
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 if (driver != null && driver.trim().length() != 0) {
                     setDriver(driver);
                 }
             }
         });
-	}
-	
-	public String getDriver() {
-		return driver;
-	}
-
-	public void setDriver(String driver) {
-		if (captureThread != null) {
-			captureThread.interrupt();
-			try {
-				captureThread.join();
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-		}
-		this.driver = driver;
-		captureThread = new Thread(this);
-		captureThread.start();
-	}
-
-	public boolean isShowVideoSourceDialog() {
-		return showVideoSourceDialog;
-	}
-
-	public void setShowVideoSourceDialog(boolean showVideoSourceDialog) {
-		this.showVideoSourceDialog = showVideoSourceDialog;
-	}
-
-	public boolean isShowVideoFormatDialog() {
-		return showVideoFormatDialog;
-	}
-
-	public void setShowVideoFormatDialog(boolean showVideoFormatDialog) {
-		this.showVideoFormatDialog = showVideoFormatDialog;
-	}
-
-	public boolean isShowVideoDisplayDialog() {
-		return showVideoDisplayDialog;
-	}
-
-	public void setShowVideoDisplayDialog(boolean showVideoDisplayDialog) {
-		this.showVideoDisplayDialog = showVideoDisplayDialog;
-	}
-	
-	public List<String> getDrivers() {
-		ArrayList<String> drivers = new ArrayList<>();
-		try {
-			for (String s : CaptureDevice.getCaptureDrivers()) {
-				drivers.add(s);
-			}
-		}
-		catch (UnsatisfiedLinkError e) {
-			
-		}
-		return drivers;
-	}
-
-	public void run() {
-		try {
-			captureDevice = CaptureDevice.getCaptureDevice(driver);
-		}
-		catch (Exception e) {
-			e.printStackTrace();
-			return;
-		}
-			
-		if (showVideoSourceDialog) {
-			captureDevice.showVideoSourceDialog();
-		}
-		
-		if (showVideoFormatDialog) {
-			captureDevice.showVideoFormatDialog();
-		}
-		
-		if (showVideoDisplayDialog) {
-			captureDevice.showVideoDisplayDialog();
-		}
-		
-		width = (int) captureDevice.getVideoDimensions().getWidth();
-		height = (int) captureDevice.getVideoDimensions().getHeight();
-		
-		while (!Thread.interrupted()) {
-			int[] captureData = captureDevice.captureFrame();
-			BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
-			image.setRGB(0, 0, width, height, captureData, 0, width);
-			lastImage = transformImage(image);
-			broadcastCapture(lastImage);
-			synchronized (captureLock) {
-				captureLock.notify();
-			}
-			try {
-				Thread.sleep(1000 / 30);
-			}
-			catch (Exception e) {
-			}
-		}
-	}
-	
-	@Override
-	public BufferedImage capture() {
-		synchronized (captureLock) {
-			try {
-				captureLock.wait();
-				BufferedImage image = lastImage;
-				return image;
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-				return null;
-			}
-		}
-	}
-	
-	@Override
-	public Wizard getConfigurationWizard() {
-		return new VfwCameraConfigurationWizard(this);
-	}
-	
+    }
+
+    public String getDriver() {
+        return driver;
+    }
+
+    public void setDriver(String driver) {
+        if (captureThread != null) {
+            captureThread.interrupt();
+            try {
+                captureThread.join();
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+        this.driver = driver;
+        captureThread = new Thread(this);
+        captureThread.start();
+    }
+
+    public boolean isShowVideoSourceDialog() {
+        return showVideoSourceDialog;
+    }
+
+    public void setShowVideoSourceDialog(boolean showVideoSourceDialog) {
+        this.showVideoSourceDialog = showVideoSourceDialog;
+    }
+
+    public boolean isShowVideoFormatDialog() {
+        return showVideoFormatDialog;
+    }
+
+    public void setShowVideoFormatDialog(boolean showVideoFormatDialog) {
+        this.showVideoFormatDialog = showVideoFormatDialog;
+    }
+
+    public boolean isShowVideoDisplayDialog() {
+        return showVideoDisplayDialog;
+    }
+
+    public void setShowVideoDisplayDialog(boolean showVideoDisplayDialog) {
+        this.showVideoDisplayDialog = showVideoDisplayDialog;
+    }
+
+    public List<String> getDrivers() {
+        ArrayList<String> drivers = new ArrayList<>();
+        try {
+            for (String s : CaptureDevice.getCaptureDrivers()) {
+                drivers.add(s);
+            }
+        }
+        catch (UnsatisfiedLinkError e) {
+
+        }
+        return drivers;
+    }
+
+    public void run() {
+        try {
+            captureDevice = CaptureDevice.getCaptureDevice(driver);
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+            return;
+        }
+
+        if (showVideoSourceDialog) {
+            captureDevice.showVideoSourceDialog();
+        }
+
+        if (showVideoFormatDialog) {
+            captureDevice.showVideoFormatDialog();
+        }
+
+        if (showVideoDisplayDialog) {
+            captureDevice.showVideoDisplayDialog();
+        }
+
+        width = (int) captureDevice.getVideoDimensions().getWidth();
+        height = (int) captureDevice.getVideoDimensions().getHeight();
+
+        while (!Thread.interrupted()) {
+            int[] captureData = captureDevice.captureFrame();
+            BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR);
+            image.setRGB(0, 0, width, height, captureData, 0, width);
+            lastImage = transformImage(image);
+            broadcastCapture(lastImage);
+            synchronized (captureLock) {
+                captureLock.notify();
+            }
+            try {
+                Thread.sleep(1000 / 30);
+            }
+            catch (Exception e) {
+            }
+        }
+    }
+
+    @Override
+    public BufferedImage capture() {
+        synchronized (captureLock) {
+            try {
+                captureLock.wait();
+                BufferedImage image = lastImage;
+                return image;
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+                return null;
+            }
+        }
+    }
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new VfwCameraConfigurationWizard(this);
+    }
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -208,7 +205,6 @@ public String getPropertySheetHolderTitle() {
     public PropertySheet[] getPropertySheets() {
         return new PropertySheet[] {
                 new PropertySheetWizardAdapter(new CameraConfigurationWizard(this)),
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }    
+                new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/camera/Webcams.java b/src/main/java/org/openpnp/machine/reference/camera/Webcams.java
new file mode 100755
index 0000000000..c4748f1a05
--- /dev/null
+++ b/src/main/java/org/openpnp/machine/reference/camera/Webcams.java
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
+
+package org.openpnp.machine.reference.camera;
+
+import java.awt.Dimension;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.swing.Action;
+
+import org.openpnp.CameraListener;
+import org.openpnp.gui.support.PropertySheetWizardAdapter;
+import org.openpnp.gui.support.Wizard;
+import org.openpnp.gui.wizards.CameraConfigurationWizard;
+import org.openpnp.machine.reference.ReferenceCamera;
+import org.openpnp.machine.reference.camera.wizards.WebcamConfigurationWizard;
+import org.openpnp.spi.PropertySheetHolder;
+import org.simpleframework.xml.Attribute;
+
+import com.github.sarxos.webcam.Webcam;
+import com.github.sarxos.webcam.WebcamImageTransformer;
+import com.github.sarxos.webcam.util.jh.JHGrayFilter;
+
+
+
+/**
+ * A Camera implementation based on the OpenCV FrameGrabbers.
+ */
+public class Webcams extends ReferenceCamera implements Runnable, WebcamImageTransformer {
+
+    @Attribute(required = false)
+    protected String deviceId = "###DEVICE###";
+
+    @Attribute(required = false)
+    private int preferredWidth = 0;
+    @Attribute(required = false)
+    private int preferredHeight = 0;
+
+    protected Webcam webcam;
+    private Thread thread;
+    private boolean forceGray;
+    private BufferedImage image;
+
+    private static final JHGrayFilter GRAY = new JHGrayFilter();
+
+
+    @Override
+    public BufferedImage transform(BufferedImage image) {
+        return GRAY.filter(image, null);
+    }
+
+    public Webcams() {
+
+    }
+
+    @Override
+    public synchronized BufferedImage capture() {
+        if (thread == null) {
+            setDeviceId(deviceId);
+        }
+        if (thread == null) {
+            return null;
+        }
+        try {
+            BufferedImage img = webcam.getImage();
+            return transformImage(img);
+        }
+        catch (Exception e) {
+            return null;
+        }
+    }
+
+    @Override
+    public synchronized void startContinuousCapture(CameraListener listener, int maximumFps) {
+        if (thread == null) {
+            setDeviceId(deviceId);
+        }
+        super.startContinuousCapture(listener, maximumFps);
+    }
+
+    private BufferedImage lastImage = null;
+    private BufferedImage redImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
+
+
+    public void run() {
+        while (!Thread.interrupted()) {
+            try {
+                BufferedImage image = capture();
+                if (image == null) {
+                    image = redImage;
+                }
+                broadcastCapture(image);
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+            try {
+                Thread.sleep(1000 / 30);
+            }
+            catch (InterruptedException e) {
+                break;
+            }
+        }
+    }
+
+    public String getDeviceId() {
+        return deviceId;
+    }
+
+    public synchronized void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+        if (thread != null) {
+            thread.interrupt();
+            try {
+                thread.join();
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+            thread = null;
+            webcam.close();
+        }
+        try {
+            webcam = null;
+            for (Webcam cam : Webcam.getWebcams()) {
+                if (cam.getName().equals(deviceId)) {
+                    webcam = cam;
+                }
+            }
+            if (webcam == null) {
+                return;
+            }
+            if (preferredWidth != 0 && preferredHeight != 0) {
+                webcam.setViewSize(new Dimension(preferredWidth, preferredHeight));
+            }
+            webcam.open();
+            if (forceGray) {
+                webcam.setImageTransformer(this);
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+            return;
+        }
+        thread = new Thread(this);
+        thread.start();
+    }
+
+    public void setForceGray(boolean val) {
+        forceGray = val;
+    }
+
+    public boolean isForceGray() {
+        return forceGray;
+    }
+
+    public int getPreferredWidth() {
+        return preferredWidth;
+    }
+
+    public void setPreferredWidth(int preferredWidth) {
+        this.preferredWidth = preferredWidth;
+    }
+
+    public int getPreferredHeight() {
+        return preferredHeight;
+    }
+
+    public void setPreferredHeight(int preferredHeight) {
+        this.preferredHeight = preferredHeight;
+    }
+
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new WebcamConfigurationWizard(this);
+    }
+
+    @Override
+    public String getPropertySheetHolderTitle() {
+        return getClass().getSimpleName() + " " + getName();
+    }
+
+    @Override
+    public PropertySheetHolder[] getChildPropertySheetHolders() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public PropertySheet[] getPropertySheets() {
+        return new PropertySheet[] {
+                new PropertySheetWizardAdapter(new CameraConfigurationWizard(this)),
+                new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
+
+
+    public List<String> getDeviceIds() throws Exception {
+        ArrayList<String> deviceIds = new ArrayList<>();
+        for (Webcam cam : Webcam.getWebcams()) {
+            deviceIds.add(cam.getName());
+        }
+        return deviceIds;
+    }
+
+
+    @Override
+    public Action[] getPropertySheetHolderActions() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    @Override
+    public void close() throws IOException {
+        super.close();
+        if (thread != null) {
+            thread.interrupt();
+            try {
+                thread.join();
+            }
+            catch (Exception e) {
+
+            }
+            webcam.close();
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/machine/reference/camera/wizards/ImageCameraConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/camera/wizards/ImageCameraConfigurationWizard.java
index 1c5fee0c0e..7eb4722ba4 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/wizards/ImageCameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/wizards/ImageCameraConfigurationWizard.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.camera.wizards;
 
@@ -48,69 +46,58 @@
 
 @SuppressWarnings("serial")
 public class ImageCameraConfigurationWizard extends ReferenceCameraConfigurationWizard {
-	private final ImageCamera camera;
-
-	private JPanel panelGeneral;
-	private JLabel lblSourceUrl;
-	private JTextField textFieldSourceUrl;
-	private JButton btnBrowse;
-
-	public ImageCameraConfigurationWizard(
-			ImageCamera camera) {
-	    super(camera);
-	    
-		this.camera = camera;
-
-		panelGeneral = new JPanel();
-		contentPanel.add(panelGeneral);
-		panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
-		panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        ColumnSpec.decode("default:grow"),
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,},
-		    new RowSpec[] {
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		lblSourceUrl = new JLabel("Source URL");
-		panelGeneral.add(lblSourceUrl, "2, 2, right, default");
-		
-		textFieldSourceUrl = new JTextField();
-		panelGeneral.add(textFieldSourceUrl, "4, 2, fill, default");
-		textFieldSourceUrl.setColumns(10);
-		
-		btnBrowse = new JButton(browseAction);
-		panelGeneral.add(btnBrowse, "6, 2");
-	}
-
-	@Override
-	public void createBindings() {
-	    super.createBindings();
-		addWrappedBinding(camera, "sourceUri", textFieldSourceUrl, "text");
-		ComponentDecorators.decorateWithAutoSelect(textFieldSourceUrl);
-	}
-	
+    private final ImageCamera camera;
+
+    private JPanel panelGeneral;
+    private JLabel lblSourceUrl;
+    private JTextField textFieldSourceUrl;
+    private JButton btnBrowse;
+
+    public ImageCameraConfigurationWizard(ImageCamera camera) {
+        super(camera);
+
+        this.camera = camera;
+
+        panelGeneral = new JPanel();
+        contentPanel.add(panelGeneral);
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        lblSourceUrl = new JLabel("Source URL");
+        panelGeneral.add(lblSourceUrl, "2, 2, right, default");
+
+        textFieldSourceUrl = new JTextField();
+        panelGeneral.add(textFieldSourceUrl, "4, 2, fill, default");
+        textFieldSourceUrl.setColumns(10);
+
+        btnBrowse = new JButton(browseAction);
+        panelGeneral.add(btnBrowse, "6, 2");
+    }
+
+    @Override
+    public void createBindings() {
+        super.createBindings();
+        addWrappedBinding(camera, "sourceUri", textFieldSourceUrl, "text");
+        ComponentDecorators.decorateWithAutoSelect(textFieldSourceUrl);
+    }
+
     private Action browseAction = new AbstractAction() {
         {
             putValue(NAME, "Browse");
             putValue(SHORT_DESCRIPTION, "Browse");
         }
-    
+
         public void actionPerformed(ActionEvent e) {
             FileDialog fileDialog = new FileDialog((Frame) getTopLevelAncestor());
             fileDialog.setFilenameFilter(new FilenameFilter() {
                 @Override
                 public boolean accept(File dir, String name) {
-                    String[] extensions = new String[] {
-                            ".png",
-                            ".jpg",
-                            ".gif",
-                            ".tif",
-                            ".tiff"
-                    };
+                    String[] extensions = new String[] {".png", ".jpg", ".gif", ".tif", ".tiff"};
                     for (String extension : extensions) {
                         if (name.toLowerCase().endsWith(extension)) {
                             return true;
@@ -127,4 +114,4 @@ public boolean accept(File dir, String name) {
             textFieldSourceUrl.setText(file.toURI().toString());
         }
     };
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/camera/wizards/LtiCivilCameraConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/camera/wizards/LtiCivilCameraConfigurationWizard.java
index fee2fa2ff1..2eaeff4bc1 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/wizards/LtiCivilCameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/wizards/LtiCivilCameraConfigurationWizard.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.camera.wizards;
 
@@ -39,57 +37,52 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 public class LtiCivilCameraConfigurationWizard extends ReferenceCameraConfigurationWizard {
-	private final LtiCivilCamera camera;
+    private final LtiCivilCamera camera;
 
-	private JPanel panelGeneral;
+    private JPanel panelGeneral;
     private JComboBox comboBoxDeviceId;
     private JCheckBox chckbxForceGrayscale;
 
-	public LtiCivilCameraConfigurationWizard(
-			LtiCivilCamera camera) {
-	    super(camera);
-	    
-		this.camera = camera;
+    public LtiCivilCameraConfigurationWizard(LtiCivilCamera camera) {
+        super(camera);
+
+        this.camera = camera;
+
+        panelGeneral = new JPanel();
+        contentPanel.add(panelGeneral);
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JLabel lblDeviceId = new JLabel("Device ID");
+        panelGeneral.add(lblDeviceId, "2, 2, right, default");
+
+        Object[] deviceIds = null;
+        try {
+            deviceIds = camera.getDeviceIds().toArray(new String[] {});
+        }
+        catch (Exception e) {
+            // TODO:
+        }
+        comboBoxDeviceId = new JComboBox(deviceIds);
+        panelGeneral.add(comboBoxDeviceId, "4, 2, left, default");
 
-		panelGeneral = new JPanel();
-		contentPanel.add(panelGeneral);
-		panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
-		panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		JLabel lblDeviceId = new JLabel("Device ID");
-		panelGeneral.add(lblDeviceId, "2, 2, right, default");
-		
-		Object[] deviceIds = null;
-		try {
-			deviceIds = camera.getDeviceIds().toArray(new String[] {});
-		}
-		catch (Exception e) {
-			// TODO:
-		}
-		comboBoxDeviceId = new JComboBox(deviceIds);
-		panelGeneral.add(comboBoxDeviceId, "4, 2, left, default");
-		
-		chckbxForceGrayscale = new JCheckBox("Force Grayscale?");
-		panelGeneral.add(chckbxForceGrayscale, "2, 4, 3, 1");
-	}
+        chckbxForceGrayscale = new JCheckBox("Force Grayscale?");
+        panelGeneral.add(chckbxForceGrayscale, "2, 4, 3, 1");
+    }
 
-	@Override
-	public void createBindings() {
-	    super.createBindings();
-		// The order of the properties is important. We want all the booleans
-		// to be set before we set the driver because setting the driver
-		// applies all the settings.
+    @Override
+    public void createBindings() {
+        super.createBindings();
+        // The order of the properties is important. We want all the booleans
+        // to be set before we set the driver because setting the driver
+        // applies all the settings.
         addWrappedBinding(camera, "forceGrayscale", chckbxForceGrayscale, "selected");
         addWrappedBinding(camera, "deviceId", comboBoxDeviceId, "selectedItem");
-	}
+    }
 
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/camera/wizards/OpenCvCameraConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/camera/wizards/OpenCvCameraConfigurationWizard.java
index c444147a58..59e8adf44d 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/wizards/OpenCvCameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/wizards/OpenCvCameraConfigurationWizard.java
@@ -1,29 +1,26 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.camera.wizards;
 
 import java.awt.Color;
 
-import javax.swing.JCheckBox;
 import javax.swing.JComboBox;
 import javax.swing.JLabel;
 import javax.swing.JPanel;
@@ -43,80 +40,73 @@
 
 @SuppressWarnings("serial")
 public class OpenCvCameraConfigurationWizard extends ReferenceCameraConfigurationWizard {
-	private final OpenCvCamera camera;
-
-	private JPanel panelGeneral;
-
-	public OpenCvCameraConfigurationWizard(
-			OpenCvCamera camera) {
-	    super(camera);
-	    
-		this.camera = camera;
-
-		panelGeneral = new JPanel();
-		contentPanel.add(panelGeneral);
-		panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
-		panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,
-		        FormSpecs.RELATED_GAP_COLSPEC,
-		        FormSpecs.DEFAULT_COLSPEC,},
-		    new RowSpec[] {
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,
-		        FormSpecs.RELATED_GAP_ROWSPEC,
-		        FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		JLabel lblDeviceId = new JLabel("Device Index");
-		panelGeneral.add(lblDeviceId, "2, 2, right, default");
-		
-		comboBoxDeviceIndex = new JComboBox();
-		for (int i = 0; i < 10; i++) {
-			comboBoxDeviceIndex.addItem(new Integer(i));
-		}
-		panelGeneral.add(comboBoxDeviceIndex, "4, 2, left, default");
-		
-		lblPreferredWidth = new JLabel("Preferred Width");
-		panelGeneral.add(lblPreferredWidth, "2, 6, right, default");
-		
-		textFieldPreferredWidth = new JTextField();
-		panelGeneral.add(textFieldPreferredWidth, "4, 6, fill, default");
-		textFieldPreferredWidth.setColumns(10);
-		
-		lbluseFor = new JLabel("(Use 0 for native resolution)");
-		panelGeneral.add(lbluseFor, "6, 6");
-		
-		lblPreferredHeight = new JLabel("Preferred Height");
-		panelGeneral.add(lblPreferredHeight, "2, 8, right, default");
-		
-		textFieldPreferredHeight = new JTextField();
-		panelGeneral.add(textFieldPreferredHeight, "4, 8, fill, default");
-		textFieldPreferredHeight.setColumns(10);
-		
-		lbluseFor_1 = new JLabel("(Use 0 for native resolution)");
-		panelGeneral.add(lbluseFor_1, "6, 8");
-	}
-
-	@Override
-	public void createBindings() {
-	    IntegerConverter intConverter = new IntegerConverter();
-	    super.createBindings();
+    private final OpenCvCamera camera;
+
+    private JPanel panelGeneral;
+
+    public OpenCvCameraConfigurationWizard(OpenCvCamera camera) {
+        super(camera);
+
+        this.camera = camera;
+
+        panelGeneral = new JPanel();
+        contentPanel.add(panelGeneral);
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JLabel lblDeviceId = new JLabel("Device Index");
+        panelGeneral.add(lblDeviceId, "2, 2, right, default");
+
+        comboBoxDeviceIndex = new JComboBox();
+        for (int i = 0; i < 10; i++) {
+            comboBoxDeviceIndex.addItem(new Integer(i));
+        }
+        panelGeneral.add(comboBoxDeviceIndex, "4, 2, left, default");
+
+        lblPreferredWidth = new JLabel("Preferred Width");
+        panelGeneral.add(lblPreferredWidth, "2, 6, right, default");
+
+        textFieldPreferredWidth = new JTextField();
+        panelGeneral.add(textFieldPreferredWidth, "4, 6, fill, default");
+        textFieldPreferredWidth.setColumns(10);
+
+        lbluseFor = new JLabel("(Use 0 for native resolution)");
+        panelGeneral.add(lbluseFor, "6, 6");
+
+        lblPreferredHeight = new JLabel("Preferred Height");
+        panelGeneral.add(lblPreferredHeight, "2, 8, right, default");
+
+        textFieldPreferredHeight = new JTextField();
+        panelGeneral.add(textFieldPreferredHeight, "4, 8, fill, default");
+        textFieldPreferredHeight.setColumns(10);
+
+        lbluseFor_1 = new JLabel("(Use 0 for native resolution)");
+        panelGeneral.add(lbluseFor_1, "6, 8");
+    }
+
+    @Override
+    public void createBindings() {
+        IntegerConverter intConverter = new IntegerConverter();
+        super.createBindings();
         addWrappedBinding(camera, "preferredWidth", textFieldPreferredWidth, "text", intConverter);
-        addWrappedBinding(camera, "preferredHeight", textFieldPreferredHeight, "text", intConverter);
-		// Should always be last so that it doesn't trigger multiple camera reloads.
+        addWrappedBinding(camera, "preferredHeight", textFieldPreferredHeight, "text",
+                intConverter);
+        // Should always be last so that it doesn't trigger multiple camera reloads.
         addWrappedBinding(camera, "deviceIndex", comboBoxDeviceIndex, "selectedItem");
-		
+
         ComponentDecorators.decorateWithAutoSelect(textFieldPreferredWidth);
         ComponentDecorators.decorateWithAutoSelect(textFieldPreferredHeight);
-	}
-	
-	@Override
+    }
+
+    @Override
     protected void saveToModel() {
         super.saveToModel();
         if (camera.isDirty()) {
@@ -125,10 +115,10 @@ protected void saveToModel() {
     }
 
     private JComboBox comboBoxDeviceIndex;
-	private JLabel lblPreferredWidth;
-	private JLabel lblPreferredHeight;
-	private JTextField textFieldPreferredWidth;
-	private JTextField textFieldPreferredHeight;
-	private JLabel lbluseFor;
-	private JLabel lbluseFor_1;
-}
\ No newline at end of file
+    private JLabel lblPreferredWidth;
+    private JLabel lblPreferredHeight;
+    private JTextField textFieldPreferredWidth;
+    private JTextField textFieldPreferredHeight;
+    private JLabel lbluseFor;
+    private JLabel lbluseFor_1;
+}
diff --git a/src/main/java/org/openpnp/machine/reference/camera/wizards/VfwCameraConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/camera/wizards/VfwCameraConfigurationWizard.java
index bd01471e34..5c19c1ef29 100755
--- a/src/main/java/org/openpnp/machine/reference/camera/wizards/VfwCameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/camera/wizards/VfwCameraConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.camera.wizards;
@@ -38,8 +36,7 @@
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
-public class VfwCameraConfigurationWizard extends
-        ReferenceCameraConfigurationWizard {
+public class VfwCameraConfigurationWizard extends ReferenceCameraConfigurationWizard {
     private final VfwCamera camera;
 
     private JPanel panelGeneral;
@@ -55,24 +52,15 @@ public VfwCameraConfigurationWizard(VfwCamera camera) {
 
         panelGeneral = new JPanel();
         contentPanel.add(panelGeneral);
-        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "General",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
-                new Color(0, 0, 0)));
-        panelGeneral
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"), }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblDeviceId = new JLabel("Driver");
         panelGeneral.add(lblDeviceId, "2, 2, right, default");
@@ -84,7 +72,7 @@ public VfwCameraConfigurationWizard(VfwCamera camera) {
         catch (Exception e) {
             // TODO:
         }
-        
+
         comboBoxDriver = new JComboBox(deviceIds);
         panelGeneral.add(comboBoxDriver, "4, 2, left, default");
 
@@ -109,4 +97,4 @@ public void createBindings() {
         addWrappedBinding(camera, "driver", comboBoxDriver, "selectedItem");
     }
 
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/camera/wizards/WebcamConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/camera/wizards/WebcamConfigurationWizard.java
new file mode 100755
index 0000000000..2bd1c2b895
--- /dev/null
+++ b/src/main/java/org/openpnp/machine/reference/camera/wizards/WebcamConfigurationWizard.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
+
+package org.openpnp.machine.reference.camera.wizards;
+
+import java.awt.Color;
+
+import javax.swing.JCheckBox;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.border.EtchedBorder;
+import javax.swing.border.TitledBorder;
+
+import org.openpnp.machine.reference.camera.Webcams;
+import org.openpnp.machine.reference.wizards.ReferenceCameraConfigurationWizard;
+
+import com.github.sarxos.webcam.WebcamDiscoveryEvent;
+import com.github.sarxos.webcam.WebcamDiscoveryListener;
+import com.jgoodies.forms.layout.ColumnSpec;
+import com.jgoodies.forms.layout.FormLayout;
+import com.jgoodies.forms.layout.FormSpecs;
+import com.jgoodies.forms.layout.RowSpec;
+
+
+
+public class WebcamConfigurationWizard extends ReferenceCameraConfigurationWizard
+        implements WebcamDiscoveryListener {
+    private final Webcams camera;
+
+    private JPanel panelGeneral;
+    private JComboBox comboBoxDeviceId;
+    private JCheckBox chckbxGray;
+
+    public WebcamConfigurationWizard(Webcams camera) {
+        super(camera);
+        this.camera = camera;
+
+        panelGeneral = new JPanel();
+        contentPanel.add(panelGeneral);
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "General", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JLabel lblDeviceId = new JLabel("Device ID");
+        panelGeneral.add(lblDeviceId, "2, 2, right, default");
+
+        Object[] deviceIds = null;
+        try {
+            deviceIds = camera.getDeviceIds().toArray(new String[] {});
+        }
+        catch (Exception e) {
+            // TODO:
+        }
+        comboBoxDeviceId = new JComboBox(deviceIds);
+        panelGeneral.add(comboBoxDeviceId, "4, 2, left, default");
+
+        chckbxGray = new JCheckBox("Force Grayscale?");
+        panelGeneral.add(chckbxGray, "2, 4, 3, 1");
+    }
+
+    @Override
+    public void createBindings() {
+        super.createBindings();
+        // The order of the properties is important. We want all the booleans
+        // to be set before we set the driver because setting the driver
+        // applies all the settings.
+        addWrappedBinding(camera, "forceGray", chckbxGray, "selected");
+        addWrappedBinding(camera, "deviceId", comboBoxDeviceId, "selectedItem");
+    }
+
+    private void updateList() {
+        comboBoxDeviceId.removeAllItems();
+        try {
+            int i = 0;
+            String id = null;
+            for (String s : camera.getDeviceIds().toArray(new String[] {})) {
+                comboBoxDeviceId.addItem(s);
+                if (s.equals(camera.getDeviceId())) {
+                    id = s;
+                }
+                i++;
+            }
+            if (id != null) {
+                comboBoxDeviceId.setSelectedItem(id);
+            }
+        }
+        catch (Exception e) {
+            ;
+        }
+        comboBoxDeviceId.repaint();
+        panelGeneral.revalidate(); // for JFrame up to Java7 is there only validate()
+        panelGeneral.repaint();
+    }
+
+
+    @Override
+    public void webcamFound(WebcamDiscoveryEvent event) {
+        if (camera.getDeviceId().equals(event.getWebcam().getName())) {
+            System.out.format("Webcam connected: %s \n", event.getWebcam().getName());
+        }
+        updateList();
+    }
+
+    @Override
+    public void webcamGone(WebcamDiscoveryEvent event) {
+        if (camera.getDeviceId().equals(event.getWebcam().getName())) {
+            System.out.format("Webcam disconnected: %s \n", event.getWebcam().getName());
+        }
+        updateList();
+    }
+
+}
diff --git a/src/main/java/org/openpnp/machine/reference/driver/AbstractSerialPortDriver.java b/src/main/java/org/openpnp/machine/reference/driver/AbstractSerialPortDriver.java
index 2749c19cb7..92f021cebe 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/AbstractSerialPortDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/AbstractSerialPortDriver.java
@@ -8,49 +8,45 @@
 
 import javax.swing.Icon;
 
-import jssc.SerialPort;
-import jssc.SerialPortException;
-import jssc.SerialPortList;
-import jssc.SerialPortTimeoutException;
-
 import org.openpnp.machine.reference.ReferenceDriver;
 import org.openpnp.machine.reference.ReferencePasteDispenser;
 import org.openpnp.model.Location;
 import org.simpleframework.xml.Attribute;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+
+import jssc.SerialPort;
+import jssc.SerialPortException;
+import jssc.SerialPortList;
+import jssc.SerialPortTimeoutException;
+
 /**
- * A base class for basic SerialPort based Drivers. Includes functions
- * for connecting, disconnecting, reading and sending lines. 
+ * A base class for basic SerialPort based Drivers. Includes functions for connecting,
+ * disconnecting, reading and sending lines.
  */
 public abstract class AbstractSerialPortDriver implements ReferenceDriver, Closeable {
     private static final Logger logger = LoggerFactory.getLogger(AbstractSerialPortDriver.class);
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String portName;
-    @Attribute(required=false)
+    @Attribute(required = false)
     protected int baud = 115200;
-    
+
     protected SerialPort serialPort;
     protected SerialInputStream input;
     protected OutputStream output;
-    
+
     protected synchronized void connect() throws Exception {
         disconnect();
         serialPort = new SerialPort(portName);
         serialPort.openPort();
-        serialPort.setParams(
-                baud, 
-                SerialPort.DATABITS_8, 
-                SerialPort.STOPBITS_1, 
-                SerialPort.PARITY_NONE, 
-                false, 
-                false);
+        serialPort.setParams(baud, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,
+                SerialPort.PARITY_NONE, false, false);
         input = new SerialInputStream(serialPort);
         input.setTimeout(500);
         output = new SerialOutputStream(serialPort);
     }
-    
+
     protected synchronized void disconnect() throws Exception {
         if (serialPort != null && serialPort.isOpened()) {
             serialPort.closePort();
@@ -59,11 +55,10 @@ protected synchronized void disconnect() throws Exception {
             serialPort = null;
         }
     }
-    
+
     @Override
-    public void dispense(ReferencePasteDispenser dispenser,
-            Location startLocation, Location endLocation,
-            long dispenseTimeMilliseconds) throws Exception {
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception {
         // Do nothing. This is just stubbed in so that it can be released
         // without breaking every driver in the wild.
     }
@@ -73,9 +68,8 @@ public void dispense(ReferencePasteDispenser dispenser,
     }
 
     /**
-     * Read a line from the serial port. Blocks for the default timeout. If
-     * the read times out a TimeoutException is thrown. Any other failure
-     * to read results in an IOExeption;
+     * Read a line from the serial port. Blocks for the default timeout. If the read times out a
+     * TimeoutException is thrown. Any other failure to read results in an IOExeption;
      * 
      * @return
      * @throws TimeoutException
@@ -116,7 +110,7 @@ public void close() throws IOException {
             throw new IOException(e);
         }
     }
-    
+
     public String getPortName() {
         return portName;
     }
@@ -140,64 +134,61 @@ public Icon getPropertySheetHolderIcon() {
     }
 
     /**
-     * SerialInputStream and SerialOutputStream are from the pull request
-     * referenced in:
+     * SerialInputStream and SerialOutputStream are from the pull request referenced in:
      * https://github.com/scream3r/java-simple-serial-connector/issues/17
      * 
      * If that pull request is ever merged we can update and remove these.
      */
-    
+
     /**
-     * Class that wraps a {@link SerialPort} to provide
-     * {@link InputStream} functionality.  This stream
-     * also provides support for performing blocking reads 
-     * with timeouts.
-     * <br>
-     * It is instantiated by passing the constructor a {@link SerialPort}
-     * instance.  Do not create multiple streams for the 
-     * same serial port unless you implement your own
-     * synchronization.
+     * Class that wraps a {@link SerialPort} to provide {@link InputStream} functionality. This
+     * stream also provides support for performing blocking reads with timeouts. <br>
+     * It is instantiated by passing the constructor a {@link SerialPort} instance. Do not create
+     * multiple streams for the same serial port unless you implement your own synchronization.
+     * 
      * @author Charles Hache <chalz@member.fsf.org>
      *
      */
     public class SerialInputStream extends InputStream {
-        
+
         private SerialPort serialPort;
         private int defaultTimeout = 0;
 
-        /** Instantiates a SerialInputStream for the given {@link SerialPort}
-         * Do not create multiple streams for the same serial port
-         * unless you implement your own synchronization.
+        /**
+         * Instantiates a SerialInputStream for the given {@link SerialPort} Do not create multiple
+         * streams for the same serial port unless you implement your own synchronization.
+         * 
          * @param sp The serial port to stream.
          */
         public SerialInputStream(SerialPort sp) {
             serialPort = sp;
         }
-        
-        /** Set the default timeout (ms) of this SerialInputStream.
-         * This affects subsequent calls to {@link #read()}, {@link #blockingRead(int[])}, 
-         * and {@link #blockingRead(int[], int, int)}
+
+        /**
+         * Set the default timeout (ms) of this SerialInputStream. This affects subsequent calls to
+         * {@link #read()}, {@link #blockingRead(int[])}, and {@link #blockingRead(int[], int, int)}
          * The default timeout can be 'unset' by setting it to 0.
+         * 
          * @param time The timeout in milliseconds.
          */
         public void setTimeout(int time) {
             defaultTimeout = time;
         }
 
-        /** Reads the next byte from the port.
-         * If the timeout of this stream has been set, then this method
-         * blocks until data is available or until the timeout has been hit.
-         * If the timeout is not set or has been set to 0, then this method
-         * blocks indefinitely.
+        /**
+         * Reads the next byte from the port. If the timeout of this stream has been set, then this
+         * method blocks until data is available or until the timeout has been hit. If the timeout
+         * is not set or has been set to 0, then this method blocks indefinitely.
          */
         @Override
         public int read() throws IOException {
             return read(defaultTimeout);
         }
-        
-        /** The same contract as {@link #read()}, except overrides
-         * this stream's default timeout with the given
-         * timeout in milliseconds.
+
+        /**
+         * The same contract as {@link #read()}, except overrides this stream's default timeout with
+         * the given timeout in milliseconds.
+         * 
          * @param timeout The timeout in milliseconds.
          * @return The read byte.
          * @throws IOException On serial port error or timeout
@@ -207,17 +198,21 @@ public int read(int timeout) throws IOException {
             try {
                 if (timeout > 0) {
                     buf = serialPort.readBytes(1, timeout);
-                } else {
+                }
+                else {
                     buf = serialPort.readBytes(1);
                 }
                 return buf[0];
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                 throw new IOException(e);
             }
         }
-        
-        /** Non-blocking read of up to buf.length bytes from the stream.
-         * This call behaves as read(buf, 0, buf.length) would.
+
+        /**
+         * Non-blocking read of up to buf.length bytes from the stream. This call behaves as
+         * read(buf, 0, buf.length) would.
+         * 
          * @param buf The buffer to fill.
          * @return The number of bytes read, which can be 0.
          * @throws IOException on error.
@@ -226,10 +221,11 @@ public int read(int timeout) throws IOException {
         public int read(byte[] buf) throws IOException {
             return read(buf, 0, buf.length);
         }
-        
-        /** Non-blocking read of up to length bytes from the stream.
-         * This method returns what is immediately available in the input
-         * buffer.
+
+        /**
+         * Non-blocking read of up to length bytes from the stream. This method returns what is
+         * immediately available in the input buffer.
+         * 
          * @param buf The buffer to fill.
          * @param offset The offset into the buffer to start copying data.
          * @param length The maximum number of bytes to read.
@@ -238,26 +234,29 @@ public int read(byte[] buf) throws IOException {
          */
         @Override
         public int read(byte[] buf, int offset, int length) throws IOException {
-            
+
             if (buf.length < offset + length)
                 length = buf.length - offset;
-            
+
             int available = this.available();
-            
+
             if (available > length)
                 available = length;
-            
+
             try {
                 byte[] readBuf = serialPort.readBytes(available);
                 System.arraycopy(readBuf, 0, buf, offset, length);
                 return readBuf.length;
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                 throw new IOException(e);
             }
         }
-        
-        /** Blocks until buf.length bytes are read, an error occurs, or the default timeout is hit (if specified).
-         * This behaves as blockingRead(buf, 0, buf.length) would.
+
+        /**
+         * Blocks until buf.length bytes are read, an error occurs, or the default timeout is hit
+         * (if specified). This behaves as blockingRead(buf, 0, buf.length) would.
+         * 
          * @param buf The buffer to fill with data.
          * @return The number of bytes read.
          * @throws IOException On error or timeout.
@@ -265,9 +264,11 @@ public int read(byte[] buf, int offset, int length) throws IOException {
         public int blockingRead(byte[] buf) throws IOException {
             return blockingRead(buf, 0, buf.length, defaultTimeout);
         }
-        
-        /** The same contract as {@link #blockingRead(byte[])} except
-         * overrides this stream's default timeout with the given one.
+
+        /**
+         * The same contract as {@link #blockingRead(byte[])} except overrides this stream's default
+         * timeout with the given one.
+         * 
          * @param buf The buffer to fill.
          * @param timeout The timeout in milliseconds.
          * @return The number of bytes read.
@@ -276,9 +277,12 @@ public int blockingRead(byte[] buf) throws IOException {
         public int blockingRead(byte[] buf, int timeout) throws IOException {
             return blockingRead(buf, 0, buf.length, timeout);
         }
-        /** Blocks until length bytes are read, an error occurs, or the default timeout is hit (if specified).
-         * Saves the data into the given buffer at the specified offset.
-         * If the stream's timeout is not set, behaves as {@link #read(byte[], int, int)} would.
+
+        /**
+         * Blocks until length bytes are read, an error occurs, or the default timeout is hit (if
+         * specified). Saves the data into the given buffer at the specified offset. If the stream's
+         * timeout is not set, behaves as {@link #read(byte[], int, int)} would.
+         * 
          * @param buf The buffer to fill.
          * @param offset The offset in buffer to save the data.
          * @param length The number of bytes to read.
@@ -288,9 +292,11 @@ public int blockingRead(byte[] buf, int timeout) throws IOException {
         public int blockingRead(byte[] buf, int offset, int length) throws IOException {
             return blockingRead(buf, offset, length, defaultTimeout);
         }
-        
-        /** The same contract as {@link #blockingRead(byte[], int, int)} except
-         * overrides this stream's default timeout with the given one.
+
+        /**
+         * The same contract as {@link #blockingRead(byte[], int, int)} except overrides this
+         * stream's default timeout with the given one.
+         * 
          * @param buf The buffer to fill.
          * @param offset Offset in the buffer to start saving data.
          * @param length The number of bytes to read.
@@ -298,56 +304,56 @@ public int blockingRead(byte[] buf, int offset, int length) throws IOException {
          * @return The number of bytes read.
          * @throws IOException On error or timeout.
          */
-        public int blockingRead(byte[] buf, int offset, int length, int timeout) throws IOException {
+        public int blockingRead(byte[] buf, int offset, int length, int timeout)
+                throws IOException {
             if (buf.length < offset + length)
                 throw new IOException("Not enough buffer space for serial data");
-            
+
             if (timeout < 1)
                 return read(buf, offset, length);
-            
+
             try {
                 byte[] readBuf = serialPort.readBytes(length, timeout);
                 System.arraycopy(readBuf, 0, buf, offset, length);
                 return readBuf.length;
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                 throw new IOException(e);
             }
         }
-        
+
         @Override
         public int available() throws IOException {
             int ret;
             try {
                 ret = serialPort.getInputBufferBytesCount();
-                if (ret >= 0) 
+                if (ret >= 0)
                     return ret;
                 throw new IOException("Error checking available bytes from the serial port.");
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                 throw new IOException("Error checking available bytes from the serial port.");
-            } 
+            }
         }
 
-    }    
-    
+    }
+
     /**
-     * Class that wraps a {@link SerialPort} to provide
-     * {@link OutputStream} functionality.
-     * <br>
-     * It is instantiated by passing the constructor a {@link SerialPort}
-     * instance.  Do not create multiple streams for the 
-     * same serial port unless you implement your own
-     * synchronization.
+     * Class that wraps a {@link SerialPort} to provide {@link OutputStream} functionality. <br>
+     * It is instantiated by passing the constructor a {@link SerialPort} instance. Do not create
+     * multiple streams for the same serial port unless you implement your own synchronization.
      * 
      * @author Charles Hache <chalz@member.fsf.org>
      *
      */
     public class SerialOutputStream extends OutputStream {
-        
+
         SerialPort serialPort;
 
-        /** Instantiates a SerialOutputStream for the given {@link SerialPort}
-         * Do not create multiple streams for the same serial port
-         * unless you implement your own synchronization.
+        /**
+         * Instantiates a SerialOutputStream for the given {@link SerialPort} Do not create multiple
+         * streams for the same serial port unless you implement your own synchronization.
+         * 
          * @param sp The serial port to stream.
          */
         public SerialOutputStream(SerialPort sp) {
@@ -358,27 +364,29 @@ public SerialOutputStream(SerialPort sp) {
         public void write(int b) throws IOException {
             try {
                 serialPort.writeInt(b);
-            } catch (SerialPortException e) {
+            }
+            catch (SerialPortException e) {
                 throw new IOException(e);
             }
         }
-        
+
         @Override
         public void write(byte[] b) throws IOException {
             write(b, 0, b.length);
-            
+
         }
-        
+
         @Override
         public void write(byte[] b, int off, int len) throws IOException {
             byte[] buffer = new byte[len];
             System.arraycopy(b, off, buffer, 0, len);
             try {
                 serialPort.writeBytes(buffer);
-            } catch (SerialPortException e) {
+            }
+            catch (SerialPortException e) {
                 throw new IOException(e);
             }
         }
-    }    
+    }
 }
 
diff --git a/src/main/java/org/openpnp/machine/reference/driver/GrblDriver.java b/src/main/java/org/openpnp/machine/reference/driver/GrblDriver.java
index b4e6c7d469..43081dfe3a 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/GrblDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/GrblDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -48,87 +46,83 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * TODO: Consider adding some type of heartbeat to the firmware.  
+ * TODO: Consider adding some type of heartbeat to the firmware.
  */
 public class GrblDriver extends AbstractSerialPortDriver implements Runnable {
-	private static final Logger logger = LoggerFactory.getLogger(GrblDriver.class);
-	private static final long minimumRequiredBuildNumber = 20140822;
-	
-	@Attribute(required=false)
-	private double feedRateMmPerMinute = 5000;
-	
-	
-	private double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-	private long connectedBuildNumber;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-	public GrblDriver() {
-	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, boolean on)
-			throws Exception {
-		if (actuator.getIndex() == 0) {
-			sendCommand(on ? "M8" : "M9");
-			dwell();
-		}
-	}
-	
-	
-	
-	@Override
-	public void home(ReferenceHead head) throws Exception {
-		sendCommand("G28");
-		x = y = z= c = 0;
-	}
-	
-	@Override
+    private static final Logger logger = LoggerFactory.getLogger(GrblDriver.class);
+    private static final long minimumRequiredBuildNumber = 20140822;
+
+    @Attribute(required = false)
+    private double feedRateMmPerMinute = 5000;
+
+
+    private double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    private long connectedBuildNumber;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    public GrblDriver() {}
+
+    @Override
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        if (actuator.getIndex() == 0) {
+            sendCommand(on ? "M8" : "M9");
+            dwell();
+        }
+    }
+
+
+
+    @Override
+    public void home(ReferenceHead head) throws Exception {
+        sendCommand("G28");
+        x = y = z = c = 0;
+    }
+
+    @Override
     public Location getLocation(ReferenceHeadMountable hm) {
-        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm
-                .getHeadOffsets());
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override
-	public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-			throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
-		StringBuffer sb = new StringBuffer();
-		if (!Double.isNaN(x) && x != this.x) {
-			sb.append(String.format(Locale.US, "X%2.2f ", x));
-		}
-		if (!Double.isNaN(y) && y != this.y) {
-			sb.append(String.format(Locale.US, "Y%2.2f ", y));
-		}
-		if (!Double.isNaN(z) && z != this.z) {
-			sb.append(String.format(Locale.US, "Z%2.2f ", z));
-		}
-		if (!Double.isNaN(c) && c != this.c) {
-			sb.append(String.format(Locale.US, "C%2.2f ", c));
-		}
-		if (sb.length() > 0) {
-			sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute));
-			sendCommand("G1 " + sb.toString());
-			dwell();
-		}
+
+        StringBuffer sb = new StringBuffer();
+        if (!Double.isNaN(x) && x != this.x) {
+            sb.append(String.format(Locale.US, "X%2.2f ", x));
+        }
+        if (!Double.isNaN(y) && y != this.y) {
+            sb.append(String.format(Locale.US, "Y%2.2f ", y));
+        }
+        if (!Double.isNaN(z) && z != this.z) {
+            sb.append(String.format(Locale.US, "Z%2.2f ", z));
+        }
+        if (!Double.isNaN(c) && c != this.c) {
+            sb.append(String.format(Locale.US, "C%2.2f ", c));
+        }
+        if (sb.length() > 0) {
+            sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute));
+            sendCommand("G1 " + sb.toString());
+            dwell();
+        }
         if (!Double.isNaN(x)) {
             this.x = x;
         }
@@ -141,187 +135,191 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         if (!Double.isNaN(c)) {
             this.c = c;
         }
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
-	    if (enabled && !connected) {
-	        connect();
-	    }
-	    if (connected) {
-	        if (enabled) {
-	            sendCommand("$X");
-	        }
-	    }
-	}
-
-	@Override
-	public void pick(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M4");
-		dwell();
-	}
-
-	@Override
-	public void place(ReferenceNozzle nozzle) throws Exception {
-		sendCommand("M5");
-		dwell();
-	}
-
-	public synchronized void connect()
-			throws Exception {
-	    super.connect();
-	    
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Grbl and we'll start getting some data. On others, Grbl may already
-		 * be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a change to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for Grbl to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-
-		processConnectionResponses(responses);
-
-		for (int i = 0; i < 5 && !connected; i++) {
-			responses = sendCommand("$I", 5000);
-			processConnectionResponses(responses);
-		}
-		
-		if (!connected)  {
-			throw new Exception(
-				String.format("Unable to receive connection response from Grbl. Check your port and baud rate, and that you are running at least build %d of Grbl", 
-						minimumRequiredBuildNumber));
-		}
-		
-		if (connectedBuildNumber < minimumRequiredBuildNumber) {
-			throw new Exception(String.format("This driver requires Grbl build %d or higher. You are running build %d", minimumRequiredBuildNumber, connectedBuildNumber));
-		}
-		
-		// We are connected to at least the minimum required version now
-		// So perform some setup
-		
-		// Turn off the stepper drivers
-		setEnabled(false);
-		
-		// Reset all axes to 0, in case the firmware was not reset on
-		// connect.
-		sendCommand("G92 X0 Y0 Z0 C0");
-	}
-	
-	private void processConnectionResponses(List<String> responses) {
-		for (String response : responses) {
-		    // Expect something like: [0.9g.20140905:]
-		    Matcher matcher = Pattern.compile("\\[(\\w*)\\.(\\w*)\\.(\\d{8})\\:\\]").matcher(response);
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
+        if (enabled && !connected) {
+            connect();
+        }
+        if (connected) {
+            if (enabled) {
+                sendCommand("$X");
+            }
+        }
+    }
+
+    @Override
+    public void pick(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M4");
+        dwell();
+    }
+
+    @Override
+    public void place(ReferenceNozzle nozzle) throws Exception {
+        sendCommand("M5");
+        dwell();
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Grbl and we'll start
+         * getting some data. On others, Grbl may already be running and we will get nothing on
+         * connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a change to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for Grbl to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        processConnectionResponses(responses);
+
+        for (int i = 0; i < 5 && !connected; i++) {
+            responses = sendCommand("$I", 5000);
+            processConnectionResponses(responses);
+        }
+
+        if (!connected) {
+            throw new Exception(String.format(
+                    "Unable to receive connection response from Grbl. Check your port and baud rate, and that you are running at least build %d of Grbl",
+                    minimumRequiredBuildNumber));
+        }
+
+        if (connectedBuildNumber < minimumRequiredBuildNumber) {
+            throw new Exception(String.format(
+                    "This driver requires Grbl build %d or higher. You are running build %d",
+                    minimumRequiredBuildNumber, connectedBuildNumber));
+        }
+
+        // We are connected to at least the minimum required version now
+        // So perform some setup
+
+        // Turn off the stepper drivers
+        setEnabled(false);
+
+        // Reset all axes to 0, in case the firmware was not reset on
+        // connect.
+        sendCommand("G92 X0 Y0 Z0 C0");
+    }
+
+    private void processConnectionResponses(List<String> responses) {
+        for (String response : responses) {
+            // Expect something like: [0.9g.20140905:]
+            Matcher matcher =
+                    Pattern.compile("\\[(\\w*)\\.(\\w*)\\.(\\d{8})\\:\\]").matcher(response);
             if (matcher.matches()) {
                 String majorVersion = matcher.group(1);
                 String minorVersion = matcher.group(2);
                 String buildNumber = matcher.group(3);
                 connectedBuildNumber = Long.parseLong(buildNumber);
                 connected = true;
-                logger.debug(String.format("Connected to Grbl Version %s.%s, build: %d", majorVersion, minorVersion, connectedBuildNumber));
-		    }
-		}
-	}
-
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
-		try {
-		    super.disconnect();
+                logger.debug(String.format("Connected to Grbl Version %s.%s, build: %d",
+                        majorVersion, minorVersion, connectedBuildNumber));
+            }
+        }
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
         }
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-		disconnectRequested = false;
-	}
-
-	private List<String> sendCommand(String command) throws Exception {
-		return sendCommand(command, -1);
-	}
-	
-	private List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("sendCommand({}, {})", command, timeout);
-				logger.debug(">> " + command);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	public void run() {
-		while (!disconnectRequested) {
-			String line;
-			try {
-			    line = readLine().trim();
-			}
-			catch (TimeoutException ex) {
-			    continue;
-			}
-			catch (IOException e) {
-			    logger.error("Read error", e);
-			    return;
-			}
-			line = line.trim();
-			logger.debug("<< " + line);
-			responseQueue.offer(line);
-			if (line.equals("ok") || line.startsWith("error: ")) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-
-	/**
-	 * Causes Grbl to block until all commands are complete.
-	 * @throws Exception
-	 */
-	private void dwell() throws Exception {
-		sendCommand("G4 P0");
-	}
-
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
+
+        try {
+            super.disconnect();
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+        disconnectRequested = false;
+    }
+
+    private List<String> sendCommand(String command) throws Exception {
+        return sendCommand(command, -1);
+    }
+
+    private List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("sendCommand({}, {})", command, timeout);
+                logger.debug(">> " + command);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    public void run() {
+        while (!disconnectRequested) {
+            String line;
+            try {
+                line = readLine().trim();
+            }
+            catch (TimeoutException ex) {
+                continue;
+            }
+            catch (IOException e) {
+                logger.error("Read error", e);
+                return;
+            }
+            line = line.trim();
+            logger.debug("<< " + line);
+            responseQueue.offer(line);
+            if (line.equals("ok") || line.startsWith("error: ")) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    /**
+     * Causes Grbl to block until all commands are complete.
+     * 
+     * @throws Exception
+     */
+    private void dwell() throws Exception {
+        sendCommand("G4 P0");
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return new AbstractSerialPortDriverConfigurationWizard(this);
@@ -346,8 +344,6 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }    
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/LinuxCNC.java b/src/main/java/org/openpnp/machine/reference/driver/LinuxCNC.java
index 634759ba79..82f435aaed 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/LinuxCNC.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/LinuxCNC.java
@@ -1,63 +1,54 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  *
- *  Ami: Driver for LinuxCNC.
- Created 28/09/2012. Setup in machine.xml
- * This is quick-n-dirty driver, it works but lots of setup gui are not done.
- * I'm relying on linuxCNC to do the hardware setup (homing etc) and just when it's
- * ready to run, then the OpenPNP can take over.
+ * Ami: Driver for LinuxCNC. Created 28/09/2012. Setup in machine.xml This is quick-n-dirty driver,
+ * it works but lots of setup gui are not done. I'm relying on linuxCNC to do the hardware setup
+ * (homing etc) and just when it's ready to run, then the OpenPNP can take over.
  */
 
 /*
- * Below is a slightly edited E-mail from Ami on the OpenPNP mail list dated
- * 27May2013 that describes how to bring up the LinuxCNC driver:
+ * Below is a slightly edited E-mail from Ami on the OpenPNP mail list dated 27May2013 that
+ * describes how to bring up the LinuxCNC driver:
  *
- * Step1: Run emc2 until it's configured well.
- * Step2. Put emc2 in MDI mode (F5) (it won't respond to external gcode
- *        if in jog mode)
- * Step3: Run the remote shell (emcrsh)
+ * Step1: Run emc2 until it's configured well. Step2. Put emc2 in MDI mode (F5) (it won't respond to
+ * external gcode if in jog mode) Step3: Run the remote shell (emcrsh)
  *
- *        You're using ubuntu 10.04, so I guess it's the older version called
- *        emc2. The newer version is called linuxcnc.
+ * You're using ubuntu 10.04, so I guess it's the older version called emc2. The newer version is
+ * called linuxcnc.
  *
- *        Open a terminal window,
- *        You must go to the folder where you have the config of your cnc,
- *        for example: /emc2/configs/mycnc/
- *        There must be a file named emc.nml overthere.
+ * Open a terminal window, You must go to the folder where you have the config of your cnc, for
+ * example: /emc2/configs/mycnc/ There must be a file named emc.nml overthere.
  *
- *        Then on the terminal window, type : emcrsh.
+ * Then on the terminal window, type : emcrsh.
  *
- *        This is the program that opens the port so we can control emc2
- *        from a distance.  (There is a way to do this automatically,
- *        in mycnc.ini file but for starting up it's better to do it manually)
+ * This is the program that opens the port so we can control emc2 from a distance. (There is a way
+ * to do this automatically, in mycnc.ini file but for starting up it's better to do it manually)
  *
- * Step4: in openpnp:  on machine.xml you must have something like this:
+ * Step4: in openpnp: on machine.xml you must have something like this:
  *
- *            <driver class="org.openpnp.machine.reference.driver.LinuxCNC" server-ip="192.168.1.6" port="5007"/>
+ * <driver class="org.openpnp.machine.reference.driver.LinuxCNC" server-ip="192.168.1.6"
+ * port="5007"/>
  *
- *        Port 5007 is the default used by linuxcnc.
- *        server-ip is the address of the machine where emc2 is running.
- *        It doesn't have to be on the same machine where openpnp runs.
+ * Port 5007 is the default used by linuxcnc. server-ip is the address of the machine where emc2 is
+ * running. It doesn't have to be on the same machine where openpnp runs.
  *
- * Step5: Run openpnp, it should connect to the emc2,
- *        in emcrsh window it sould show : "Connected to x"
+ * Step5: Run openpnp, it should connect to the emc2, in emcrsh window it sould show :
+ * "Connected to x"
  */
 
 package org.openpnp.machine.reference.driver;
@@ -98,15 +89,14 @@
  * TODO: Consider adding some type of heartbeat to the firmware.
  */
 public class LinuxCNC implements ReferenceDriver, Runnable {
-    private static final Logger logger = LoggerFactory
-            .getLogger(LinuxCNC.class);
+    private static final Logger logger = LoggerFactory.getLogger(LinuxCNC.class);
     private static final double minimumRequiredVersion = 0.81;
 
-    @Attribute(required=false)
+    @Attribute(required = false)
     private String serverIp = "127.0.0.1";
-    @Attribute(required=false)
+    @Attribute(required = false)
     private int port = 502;
-    @Attribute(required=false)
+    @Attribute(required = false)
     private double feedRateMmPerMinute;
 
     private double x, y, z, c;
@@ -124,10 +114,9 @@
 
     private static Scanner in;
     private static PrintWriter out;
-    
-    public LinuxCNC() {
-    }
-    
+
+    public LinuxCNC() {}
+
     @Override
     public void home(ReferenceHead head) throws Exception {
         sendCommand("set mdi G0 Z-20"); // SafeZ
@@ -139,17 +128,17 @@ public void home(ReferenceHead head) throws Exception {
 
 
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
+
         StringBuffer sb = new StringBuffer();
         if (!Double.isNaN(x) && x != this.x) {
             sb.append(String.format(Locale.US, "X%2.2f ", x));
@@ -186,8 +175,7 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
 
     @Override
     public Location getLocation(ReferenceHeadMountable hm) {
-        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm
-                .getHeadOffsets());
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
     }
 
 
@@ -209,8 +197,7 @@ public void place(ReferenceNozzle nozzle) throws Exception {
 
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         // if (index == 0) {
         // sendCommand(on ? "M8" : "M9");
         // dwell();
@@ -220,10 +207,9 @@ public void actuate(ReferenceActuator actuator, boolean on)
 
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override
@@ -236,8 +222,7 @@ public void setEnabled(boolean enabled) throws Exception {
         }
     }
 
-    public synchronized void connect(String serverIp, int port)
-            throws Exception {
+    public synchronized void connect(String serverIp, int port) throws Exception {
         // disconnect();
         logger.debug("connect({}, {})", serverIp, port);
         SocketAddress sa = new InetSocketAddress(serverIp, port);
@@ -265,16 +250,16 @@ public synchronized void connect(String serverIp, int port)
 
         responses.addAll(sendCommand("set estop off"));
         responses.addAll(sendCommand("set mode mdi"));
-        
+
         // set_wait done -- will respond after the commanded move is completed
-        // The default behavior is to respond when received which causes 
+        // The default behavior is to respond when received which causes
         // OpenPnP to spit out gcode full-bore.
         responses.addAll(sendCommand("set set_wait done"));
         responses.addAll(sendCommand("set echo off"));
         // verbose on -- all commands will be replied with ACK or NAK
         // This will be used later to determine the return status.
         responses.addAll(sendCommand("set verbose on"));
-        
+
         processConnectionResponses(responses);
 
         if (!connected) {
@@ -283,17 +268,15 @@ public synchronized void connect(String serverIp, int port)
         }
 
         if (!connected) {
-            throw new Exception(
-                    String.format(
-                            "Unable to receive connection response from LinuxCNC. Check your server ip and port in machine.xml and that you are running at least version %f of LinuxCNCrsh",
-                            minimumRequiredVersion));
+            throw new Exception(String.format(
+                    "Unable to receive connection response from LinuxCNC. Check your server ip and port in machine.xml and that you are running at least version %f of LinuxCNCrsh",
+                    minimumRequiredVersion));
         }
 
         if (connectedVersion < minimumRequiredVersion) {
-            throw new Exception(
-                    String.format(
-                            "This driver requires LinuxCNCrsh version %.2f or higher. You are running version %.2f",
-                            minimumRequiredVersion, connectedVersion));
+            throw new Exception(String.format(
+                    "This driver requires LinuxCNCrsh version %.2f or higher. You are running version %.2f",
+                    minimumRequiredVersion, connectedVersion));
         }
 
         // We are connected to at least the minimum required version now
@@ -302,8 +285,8 @@ public synchronized void connect(String serverIp, int port)
         // Turn off the stepper drivers
         setEnabled(false);
 
-	// Force into miillmeter mode:
-	sendCommand("set mdi G21");
+        // Force into miillmeter mode:
+        sendCommand("set mdi G21");
 
         // Reset all axes to 0, in case the firmware was not reset on
         // connect.
@@ -316,9 +299,8 @@ private void processConnectionResponses(List<String> responses) {
 
                 connectedVersion = 1.1;
                 connected = true;
-                logger.debug(String.format(
-                        "Connected to LinuxCNCrsh Version: %.2f",
-                        connectedVersion));
+                logger.debug(
+                        String.format("Connected to LinuxCNCrsh Version: %.2f", connectedVersion));
             }
         }
     }
@@ -347,8 +329,7 @@ public synchronized void disconnect() {
         return sendCommand(command, -1);
     }
 
-    private List<String> sendCommand(String command, long timeout)
-            throws Exception {
+    private List<String> sendCommand(String command, long timeout) throws Exception {
         synchronized (commandLock) {
             if (command != null) {
                 logger.debug("sendCommand({}, {})", command, timeout);
@@ -434,7 +415,7 @@ private int readChar() {
             return -1;
         }
     }
-    
+
     @Override
     public void close() throws IOException {
         try {
@@ -464,11 +445,9 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }    
-    
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -482,10 +461,9 @@ public Icon getPropertySheetHolderIcon() {
     }
 
     @Override
-    public void dispense(ReferencePasteDispenser dispenser,
-            Location startLocation, Location endLocation,
-            long dispenseTimeMilliseconds) throws Exception {
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception {
         // TODO Auto-generated method stub
-        
+
     }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/MarlinDriver.java b/src/main/java/org/openpnp/machine/reference/driver/MarlinDriver.java
index 13ec4bc1e7..80c68fe840 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/MarlinDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/MarlinDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -49,102 +47,98 @@
 import org.slf4j.LoggerFactory;
 
 public class MarlinDriver extends AbstractSerialPortDriver implements Runnable {
-	private static final Logger logger = LoggerFactory.getLogger(MarlinDriver.class);
-	private static final long minimumRequiredBuildNumber = 20140822;
-	
-	@Attribute(required=false)
-	protected double feedRateMmPerMinute = 5000;
-	
-    @Element(required=false)
+    private static final Logger logger = LoggerFactory.getLogger(MarlinDriver.class);
+    private static final long minimumRequiredBuildNumber = 20140822;
+
+    @Attribute(required = false)
+    protected double feedRateMmPerMinute = 5000;
+
+    @Element(required = false)
     protected String pickGcode = "M106 S255";
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected String placeGcode = "M107";
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected String actuatorOnGcode = "M8";
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected String actuatorOffGcode = "M9";
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected String enableGcode = "M17";
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected String disableGcode = "M18";
-    
-	
-	protected double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-	private long connectedBuildNumber;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-	public MarlinDriver() {
-	}
-	
-	@Override
-	public void actuate(ReferenceActuator actuator, boolean on)
-			throws Exception {
-		if (actuator.getIndex() == 0) {
-			sendCommand(on ? actuatorOnGcode : actuatorOffGcode);
-			dwell();
-		}
-	}
-	
-	
-	
-	@Override
-	public void home(ReferenceHead head) throws Exception {
-		sendCommand("G28");
-		getCurrentPosition();
-	}
-	
-	@Override
+
+
+    protected double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    private long connectedBuildNumber;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    public MarlinDriver() {}
+
+    @Override
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
+        if (actuator.getIndex() == 0) {
+            sendCommand(on ? actuatorOnGcode : actuatorOffGcode);
+            dwell();
+        }
+    }
+
+
+
+    @Override
+    public void home(ReferenceHead head) throws Exception {
+        sendCommand("G28");
+        getCurrentPosition();
+    }
+
+    @Override
     public Location getLocation(ReferenceHeadMountable hm) {
-        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm
-                .getHeadOffsets());
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override
-	public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
-			throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
-        
+
         double x = location.getX();
         double y = location.getY();
         double z = location.getZ();
         double c = location.getRotation();
-        
-		StringBuffer sb = new StringBuffer();
-		if (!Double.isNaN(x) && x != this.x) {
-			sb.append(String.format(Locale.US, "X%2.2f ", x));
-		}
-		if (!Double.isNaN(y) && y != this.y) {
-			sb.append(String.format(Locale.US, "Y%2.2f ", y));
-		}
-		if (!Double.isNaN(z) && z != this.z) {
-			sb.append(String.format(Locale.US, "Z%2.2f ", z));
-		}
-		if (!Double.isNaN(c) && c != this.c) {
-			sb.append(String.format(Locale.US, "E%2.2f ", c));
-		}
-		if (sb.length() > 0) {
-			sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute));
-			sendCommand("G1 " + sb.toString());
-			dwell();
-		}
+
+        StringBuffer sb = new StringBuffer();
+        if (!Double.isNaN(x) && x != this.x) {
+            sb.append(String.format(Locale.US, "X%2.2f ", x));
+        }
+        if (!Double.isNaN(y) && y != this.y) {
+            sb.append(String.format(Locale.US, "Y%2.2f ", y));
+        }
+        if (!Double.isNaN(z) && z != this.z) {
+            sb.append(String.format(Locale.US, "Z%2.2f ", z));
+        }
+        if (!Double.isNaN(c) && c != this.c) {
+            sb.append(String.format(Locale.US, "E%2.2f ", c));
+        }
+        if (sb.length() > 0) {
+            sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute));
+            sendCommand("G1 " + sb.toString());
+            dwell();
+        }
         if (!Double.isNaN(x)) {
             this.x = x;
         }
@@ -157,200 +151,202 @@ public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
         if (!Double.isNaN(c)) {
             this.c = c;
         }
-	}
-	
-	@Override
-	public void setEnabled(boolean enabled) throws Exception {
-	    if (enabled && !connected) {
-	        connect();
-	    }
-	    if (connected) {
-	        sendCommand(enabled ? enableGcode : disableGcode);
-	    }
-	}
-
-	@Override
-	public void pick(ReferenceNozzle nozzle) throws Exception {
-		sendCommand(pickGcode);
-		dwell();
-	}
-
-	@Override
-	public void place(ReferenceNozzle nozzle) throws Exception {
-		sendCommand(placeGcode);
-		dwell();
-	}
-
-	public synchronized void connect()
-			throws Exception {
-	    super.connect();
-	    
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Grbl and we'll start getting some data. On others, Grbl may already
-		 * be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a change to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for Grbl to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-
-		processConnectionResponses(responses);
-
-		for (int i = 0; i < 5 && !connected; i++) {
-			responses = sendCommand("M115", 5000);
-			processConnectionResponses(responses);
-		}
-		
-		if (!connected)  {
-			throw new Exception(
-				String.format("Unable to receive connection response from Grbl. Check your port and baud rate, and that you are running at least build %d of Grbl", 
-						minimumRequiredBuildNumber));
-		}
-		
-//		if (connectedBuildNumber < minimumRequiredBuildNumber) {
-//			throw new Error(String.format("This driver requires Grbl build %d or higher. You are running build %d", minimumRequiredBuildNumber, connectedBuildNumber));
-//		}
-		
-		// We are connected to at least the minimum required version now
-		// So perform some setup
-		
-		// Turn off the stepper drivers
-		setEnabled(false);
-		
-		sendCommand("G21");
-		sendCommand("G90");
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) throws Exception {
+        if (enabled && !connected) {
+            connect();
+        }
+        if (connected) {
+            sendCommand(enabled ? enableGcode : disableGcode);
+        }
+    }
+
+    @Override
+    public void pick(ReferenceNozzle nozzle) throws Exception {
+        sendCommand(pickGcode);
+        dwell();
+    }
+
+    @Override
+    public void place(ReferenceNozzle nozzle) throws Exception {
+        sendCommand(placeGcode);
+        dwell();
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Grbl and we'll start
+         * getting some data. On others, Grbl may already be running and we will get nothing on
+         * connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a change to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for Grbl to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        processConnectionResponses(responses);
+
+        for (int i = 0; i < 5 && !connected; i++) {
+            responses = sendCommand("M115", 5000);
+            processConnectionResponses(responses);
+        }
+
+        if (!connected) {
+            throw new Exception(String.format(
+                    "Unable to receive connection response from Grbl. Check your port and baud rate, and that you are running at least build %d of Grbl",
+                    minimumRequiredBuildNumber));
+        }
+
+        // if (connectedBuildNumber < minimumRequiredBuildNumber) {
+        // throw new Error(String.format("This driver requires Grbl build %d or higher. You are
+        // running build %d", minimumRequiredBuildNumber, connectedBuildNumber));
+        // }
+
+        // We are connected to at least the minimum required version now
+        // So perform some setup
+
+        // Turn off the stepper drivers
+        setEnabled(false);
+
+        sendCommand("G21");
+        sendCommand("G90");
         sendCommand("M82");
         sendCommand("M84 S0");
         getCurrentPosition();
-	}
-	
-	protected void getCurrentPosition() throws Exception {
-	    List<String> responses = sendCommand("M114");
-	    for (String response : responses) {
-	        if (response.startsWith("X:")) {
-	            String[] comps = response.split(" ");
+    }
+
+    protected void getCurrentPosition() throws Exception {
+        List<String> responses = sendCommand("M114");
+        for (String response : responses) {
+            if (response.startsWith("X:")) {
+                String[] comps = response.split(" ");
                 x = Double.parseDouble(comps[0].split(":")[1]);
                 y = Double.parseDouble(comps[1].split(":")[1]);
                 z = Double.parseDouble(comps[2].split(":")[1]);
                 c = Double.parseDouble(comps[3].split(":")[1]);
-	        }
-	    }
-	}
-	
-	private void processConnectionResponses(List<String> responses) {
-		for (String response : responses) {
-		    Matcher matcher = Pattern.compile(".*Marlin.*").matcher(response);
+            }
+        }
+    }
+
+    private void processConnectionResponses(List<String> responses) {
+        for (String response : responses) {
+            Matcher matcher = Pattern.compile(".*Marlin.*").matcher(response);
             if (matcher.matches()) {
-//                String majorVersion = matcher.group(1);
-//                String minorVersion = matcher.group(2);
-//                String buildNumber = matcher.group(3);
-//                connectedBuildNumber = Long.parseLong(buildNumber);
+                // String majorVersion = matcher.group(1);
+                // String minorVersion = matcher.group(2);
+                // String buildNumber = matcher.group(3);
+                // connectedBuildNumber = Long.parseLong(buildNumber);
                 connected = true;
-//                logger.debug(String.format("Connected to Grbl Version %s.%s, build: %d", majorVersion, minorVersion, connectedBuildNumber));
+                // logger.debug(String.format("Connected to Grbl Version %s.%s, build: %d",
+                // majorVersion, minorVersion, connectedBuildNumber));
                 logger.debug(String.format("Connected to Marlin"));
-		    }
-		}
-	}
-
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
-		try {
-		    super.disconnect();
+            }
+        }
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
         }
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-		disconnectRequested = false;
-	}
-
-	protected List<String> sendCommand(String command) throws Exception {
-		return sendCommand(command, -1);
-	}
-	
-	protected List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("sendCommand({}, {})", command, timeout);
-				logger.debug(">> " + command);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	public void run() {
-		while (!disconnectRequested) {
-			String line;
-			try {
-			    line = readLine().trim();
-			}
-			catch (TimeoutException ex) {
-			    continue;
-			}
-			catch (IOException e) {
-			    logger.error("Read error", e);
-			    return;
-			}
-			line = line.trim();
-			logger.debug("<< " + line);
-			responseQueue.offer(line);
-			if (line.equals("ok") || line.startsWith("error: ")) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-
-	/**
-	 * Causes Grbl to block until all commands are complete.
-	 * @throws Exception
-	 */
-	protected void dwell() throws Exception {
-		sendCommand("G4 P0");
-	}
-
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
+
+        try {
+            super.disconnect();
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+        disconnectRequested = false;
+    }
+
+    protected List<String> sendCommand(String command) throws Exception {
+        return sendCommand(command, -1);
+    }
+
+    protected List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("sendCommand({}, {})", command, timeout);
+                logger.debug(">> " + command);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    public void run() {
+        while (!disconnectRequested) {
+            String line;
+            try {
+                line = readLine().trim();
+            }
+            catch (TimeoutException ex) {
+                continue;
+            }
+            catch (IOException e) {
+                logger.error("Read error", e);
+                return;
+            }
+            line = line.trim();
+            logger.debug("<< " + line);
+            responseQueue.offer(line);
+            if (line.equals("ok") || line.startsWith("error: ")) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    /**
+     * Causes Grbl to block until all commands are complete.
+     * 
+     * @throws Exception
+     */
+    protected void dwell() throws Exception {
+        sendCommand("G4 P0");
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return new AbstractSerialPortDriverConfigurationWizard(this);
@@ -375,8 +371,6 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }    
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/NullDriver.java b/src/main/java/org/openpnp/machine/reference/driver/NullDriver.java
index baedf6e34d..655ffffe8b 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/NullDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/NullDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -46,24 +44,23 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * An example of the simplest possible driver that can support multiple heads.
- * This driver maintains a set of coordinates for each Head that it is asked to
- * handle and simply logs all commands sent to it.
+ * An example of the simplest possible driver that can support multiple heads. This driver maintains
+ * a set of coordinates for each Head that it is asked to handle and simply logs all commands sent
+ * to it.
  */
 public class NullDriver implements ReferenceDriver {
-    private final static Logger logger = LoggerFactory
-            .getLogger(NullDriver.class);
-    
+    private final static Logger logger = LoggerFactory.getLogger(NullDriver.class);
+
     @Attribute(required = false)
     private double feedRateMmPerMinute = 5000;
-    
+
     private HashMap<Head, Location> headLocations = new HashMap<>();
-    
+
     private boolean enabled;
 
     /**
-     * Gets the Location object being tracked for a specific Head. This is the
-     * absolute coordinates of a virtual Head on the machine.
+     * Gets the Location object being tracked for a specific Head. This is the absolute coordinates
+     * of a virtual Head on the machine.
      * 
      * @param head
      * @return
@@ -76,9 +73,9 @@ protected Location getHeadLocation(Head head) {
         }
         return l;
     }
-    
+
     protected void setHeadLocation(Head head, Location l) {
-        headLocations.put(head,  l);
+        headLocations.put(head, l);
     }
 
     @Override
@@ -89,10 +86,9 @@ public void home(ReferenceHead head) throws Exception {
     }
 
     /**
-     * Return the Location of a specific ReferenceHeadMountable on the machine.
-     * We get the coordinates for the Head the object is attached to, and then
-     * we add the offsets assigned to the object to make the coordinates correct
-     * for that object.
+     * Return the Location of a specific ReferenceHeadMountable on the machine. We get the
+     * coordinates for the Head the object is attached to, and then we add the offsets assigned to
+     * the object to make the coordinates correct for that object.
      */
     @Override
     public Location getLocation(ReferenceHeadMountable hm) {
@@ -100,17 +96,16 @@ public Location getLocation(ReferenceHeadMountable hm) {
     }
 
     /**
-     * Commands the driver to move the given ReferenceHeadMountable to the
-     * specified Location at the given speed. Please see the comments for this
-     * method in the code for some important considerations when writing your
-     * own driver.
+     * Commands the driver to move the given ReferenceHeadMountable to the specified Location at the
+     * given speed. Please see the comments for this method in the code for some important
+     * considerations when writing your own driver.
      */
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
-        logger.debug("moveTo({}, {}, {})", new Object[] { hm, location, speed });
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
+        logger.debug("moveTo({}, {}, {})", new Object[] {hm, location, speed});
         checkEnabled();
-        
+
         // Subtract the offsets from the incoming Location. This converts the
         // offset coordinates to driver / absolute coordinates.
         location = location.subtract(hm.getHeadOffsets());
@@ -121,28 +116,27 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
 
         // Get the current location of the Head that we'll move
         Location hl = getHeadLocation(hm.getHead());
-        
+
         if (feedRateMmPerMinute > 0) {
             simulateMovement(hm, location, hl, speed);
         }
-        
+
         // Now that movement is complete, update the stored Location to the new
         // Location, unless the incoming Location specified an axis with a value
         // of NaN. NaN is interpreted to mean "Don't move this axis" so we don't
         // update the value, either.
 
-        hl = hl.derive(
-                Double.isNaN(location.getX()) ? null : location.getX(),
+        hl = hl.derive(Double.isNaN(location.getX()) ? null : location.getX(),
                 Double.isNaN(location.getY()) ? null : location.getY(),
                 Double.isNaN(location.getZ()) ? null : location.getZ(),
                 Double.isNaN(location.getRotation()) ? null : location.getRotation());
 
         setHeadLocation(hm.getHead(), hl);
     }
-    
+
     /**
-     * Simulates true machine movement, which takes time, by tracing the
-     * required movement lines over a period of time based on the input speed.
+     * Simulates true machine movement, which takes time, by tracing the required movement lines
+     * over a period of time based on the input speed.
      * 
      * @param hm
      * @param location
@@ -150,8 +144,8 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
      * @param speed
      * @throws Exception
      */
-    protected void simulateMovement(ReferenceHeadMountable hm, Location location,
-            Location hl, double speed) throws Exception {
+    protected void simulateMovement(ReferenceHeadMountable hm, Location location, Location hl,
+            double speed) throws Exception {
         double x = hl.getX();
         double y = hl.getY();
         double z = hl.getZ();
@@ -164,8 +158,7 @@ protected void simulateMovement(ReferenceHeadMountable hm, Location location,
         double x2 = Double.isNaN(location.getX()) ? x : location.getX();
         double y2 = Double.isNaN(location.getY()) ? y : location.getY();
         double z2 = Double.isNaN(location.getZ()) ? z : location.getZ();
-        double c2 = Double.isNaN(location.getRotation()) ? c : location
-                .getRotation();
+        double c2 = Double.isNaN(location.getRotation()) ? c : location.getRotation();
 
         c2 = c2 % 360.0;
 
@@ -248,8 +241,7 @@ public void place(ReferenceNozzle nozzle) throws Exception {
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         logger.debug("actuate({}, {})", actuator, value);
         checkEnabled();
         if (feedRateMmPerMinute > 0) {
@@ -258,20 +250,19 @@ public void actuate(ReferenceActuator actuator, double value)
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         logger.debug("actuate({}, {})", actuator, on);
         checkEnabled();
         if (feedRateMmPerMinute > 0) {
             Thread.sleep(500);
         }
     }
-    
+
     @Override
-    public void dispense(ReferencePasteDispenser dispenser,
-            Location startLocation, Location endLocation,
-            long dispenseTimeMilliseconds) throws Exception {
-        logger.debug("dispense({}, {}, {}, {})", new Object[] { dispenser, startLocation, endLocation, dispenseTimeMilliseconds });
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception {
+        logger.debug("dispense({}, {}, {}, {})",
+                new Object[] {dispenser, startLocation, endLocation, dispenseTimeMilliseconds});
         checkEnabled();
         Thread.sleep(dispenseTimeMilliseconds);
     }
@@ -301,9 +292,7 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 
     @Override
@@ -323,18 +312,18 @@ private void checkEnabled() throws Exception {
             throw new Exception("Driver is not yet enabled!");
         }
     }
-    
+
     public double getFeedRateMmPerMinute() {
-		return feedRateMmPerMinute;
-	}
+        return feedRateMmPerMinute;
+    }
 
-	public void setFeedRateMmPerMinute(double feedRateMmPerMinute) {
-		this.feedRateMmPerMinute = feedRateMmPerMinute;
-	}
+    public void setFeedRateMmPerMinute(double feedRateMmPerMinute) {
+        this.feedRateMmPerMinute = feedRateMmPerMinute;
+    }
 
-	@Override
+    @Override
     public void close() throws IOException {
         // TODO Auto-generated method stub
-        
-    }  
+
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/SimulatorDriver.java b/src/main/java/org/openpnp/machine/reference/driver/SimulatorDriver.java
index 38d90dc498..4704eb9db7 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/SimulatorDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/SimulatorDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -48,27 +46,26 @@
 import org.slf4j.LoggerFactory;
 
 public class SimulatorDriver implements ReferenceDriver {
-    private final static Logger logger = LoggerFactory
-            .getLogger(SimulatorDriver.class);
-    
+    private final static Logger logger = LoggerFactory.getLogger(SimulatorDriver.class);
+
     @Attribute(required = false)
     private double feedRateMmPerMinute;
-    
+
     private HashMap<Head, Location> headLocations = new HashMap<>();
-    
+
     private boolean enabled;
-    
+
     private Socket socket;
     private DataInputStream in;
     private PrintStream out;
-    
+
     public SimulatorDriver() throws Exception {
         connect();
     }
 
     /**
-     * Gets the Location object being tracked for a specific Head. This is the
-     * absolute coordinates of a virtual Head on the machine.
+     * Gets the Location object being tracked for a specific Head. This is the absolute coordinates
+     * of a virtual Head on the machine.
      * 
      * @param head
      * @return
@@ -81,9 +78,9 @@ protected Location getHeadLocation(Head head) {
         }
         return l;
     }
-    
+
     protected void setHeadLocation(Head head, Location l) {
-        headLocations.put(head,  l);
+        headLocations.put(head, l);
     }
 
     @Override
@@ -95,10 +92,9 @@ public void home(ReferenceHead head) throws Exception {
     }
 
     /**
-     * Return the Location of a specific ReferenceHeadMountable on the machine.
-     * We get the coordinates for the Head the object is attached to, and then
-     * we add the offsets assigned to the object to make the coordinates correct
-     * for that object.
+     * Return the Location of a specific ReferenceHeadMountable on the machine. We get the
+     * coordinates for the Head the object is attached to, and then we add the offsets assigned to
+     * the object to make the coordinates correct for that object.
      */
     @Override
     public Location getLocation(ReferenceHeadMountable hm) {
@@ -106,17 +102,16 @@ public Location getLocation(ReferenceHeadMountable hm) {
     }
 
     /**
-     * Commands the driver to move the given ReferenceHeadMountable to the
-     * specified Location at the given speed. Please see the comments for this
-     * method in the code for some important considerations when writing your
-     * own driver.
+     * Commands the driver to move the given ReferenceHeadMountable to the specified Location at the
+     * given speed. Please see the comments for this method in the code for some important
+     * considerations when writing your own driver.
      */
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
-        logger.debug("moveTo({}, {}, {})", new Object[] { hm, location, speed });
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
+        logger.debug("moveTo({}, {}, {})", new Object[] {hm, location, speed});
         checkEnabled();
-        
+
         // Subtract the offsets from the incoming Location. This converts the
         // offset coordinates to driver / absolute coordinates.
         location = location.subtract(hm.getHeadOffsets());
@@ -127,7 +122,7 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
 
         // Get the current location of the Head that we'll move
         Location hl = getHeadLocation(hm.getHead());
-        
+
         String movable;
         if (hm.toString().equals("N1")) {
             movable = "Nozzle1";
@@ -144,16 +139,16 @@ else if (hm.toString().equals("A1")) {
         else {
             throw new Exception("Don't know what " + hm.toString() + " is.");
         }
-        
-        send(String.format(Locale.US,"m,%s,%f,%f,%f,%f", movable, location.getX(), location.getY(), location.getZ(), location.getRotation()));
-        
+
+        send(String.format(Locale.US, "m,%s,%f,%f,%f,%f", movable, location.getX(), location.getY(),
+                location.getZ(), location.getRotation()));
+
         // Now that movement is complete, update the stored Location to the new
         // Location, unless the incoming Location specified an axis with a value
         // of NaN. NaN is interpreted to mean "Don't move this axis" so we don't
         // update the value, either.
 
-        hl = hl.derive(
-                Double.isNaN(location.getX()) ? null : location.getX(),
+        hl = hl.derive(Double.isNaN(location.getX()) ? null : location.getX(),
                 Double.isNaN(location.getY()) ? null : location.getY(),
                 Double.isNaN(location.getZ()) ? null : location.getZ(),
                 Double.isNaN(location.getRotation()) ? null : location.getRotation());
@@ -180,8 +175,7 @@ public void place(ReferenceNozzle nozzle) throws Exception {
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         logger.debug("actuate({}, {})", actuator, value);
         checkEnabled();
         if (feedRateMmPerMinute > 0) {
@@ -190,20 +184,17 @@ public void actuate(ReferenceActuator actuator, double value)
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         logger.debug("actuate({}, {})", actuator, on);
         checkEnabled();
         if (feedRateMmPerMinute > 0) {
             Thread.sleep(500);
         }
     }
-    
+
     @Override
-    public void dispense(ReferencePasteDispenser dispenser,
-            Location startLocation, Location endLocation,
-            long dispenseTimeMilliseconds) throws Exception {
-    }
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception {}
 
     @Override
     public void setEnabled(boolean enabled) throws Exception {
@@ -216,7 +207,7 @@ private void checkEnabled() throws Exception {
             throw new Exception("Driver is not yet enabled!");
         }
     }
-    
+
     // TODO: This reconnect stuff totally doesn't work
     private void connect() {
         if (socket == null || !socket.isConnected()) {
@@ -234,7 +225,7 @@ private void connect() {
             }
         }
     }
-    
+
     private void send(String s) {
         try {
             connect();
@@ -249,7 +240,7 @@ private void send(String s) {
             e.printStackTrace();
         }
     }
-    
+
     @Override
     public Wizard getConfigurationWizard() {
         // TODO Auto-generated method stub
@@ -269,11 +260,9 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -289,6 +278,6 @@ public Icon getPropertySheetHolderIcon() {
     @Override
     public void close() throws IOException {
         // TODO Auto-generated method stub
-        
-    }  
+
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/SprinterDriver.java b/src/main/java/org/openpnp/machine/reference/driver/SprinterDriver.java
index a2d75268c7..c0ed9c4ff2 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/SprinterDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/SprinterDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -46,138 +44,145 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * TODO: Consider adding some type of heartbeat to the firmware.  
+ * TODO: Consider adding some type of heartbeat to the firmware.
  */
 
-//Implemented Codes
-//-------------------
-//G0  -> G1
-//G1  - Coordinated Movement X Y Z E
-//G2  - CW ARC
-//G3  - CCW ARC
-//G4  - Dwell S<seconds> or P<milliseconds>
-//G28 - Home all Axis
-//G90 - Use Absolute Coordinates
-//G91 - Use Relative Coordinates
-//G92 - Set current position to cordinates given
-
-//RepRap M Codes
-//M104 - Set extruder target temp
-//M105 - Read current temp
-//M106 - Fan on
-//M107 - Fan off
-//M109 - Wait for extruder current temp to reach target temp.
-//M114 - Display current position
-
-//Custom M Codes
-//M20  - List SD card
-//M21  - Init SD card
-//M22  - Release SD card
-//M23  - Select SD file (M23 filename.g)
-//M24  - Start/resume SD print
-//M25  - Pause SD print
-//M26  - Set SD position in bytes (M26 S12345)
-//M27  - Report SD print status
-//M28  - Start SD write (M28 filename.g)
-//M29  - Stop SD write
-// -  <filename> - Delete file on sd card
-//M42  - Set output on free pins, on a non pwm pin (over pin 13 on an arduino mega) use S255 to turn it on and S0 to turn it off. Use P to decide the pin (M42 P23 S255) would turn pin 23 on
-//M80  - Turn on Power Supply
-//M81  - Turn off Power Supply
-//M82  - Set E codes absolute (default)
-//M83  - Set E codes relative while in Absolute Coordinates (G90) mode
-//M84  - Disable steppers until next move, 
-//      or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
-//M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
-//M92  - Set axis_steps_per_unit - same syntax as G92
-//M93  - Send axis_steps_per_unit
-//M115	- Capabilities string
-//M119 - Show Endstopper State 
-//M140 - Set bed target temp
-//M190 - Wait for bed current temp to reach target temp.
-//M201 - Set maximum acceleration in units/s^2 for print moves (M201 X1000 Y1000)
-//M202 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
-//M203 - Set temperture monitor to Sx
-//M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2
-//M205 - advanced settings:  minimum travel speed S=while printing T=travel only,  X=maximum xy jerk, Z=maximum Z jerk
-//M206 - set additional homing offset
-
-//M220 - set speed factor override percentage S=factor in percent 
-//M221 - set extruder multiply factor S100 --> original Extrude Speed 
-
-//M301 - Set PID parameters P I and D
-//M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
-
-//M400 - Finish all moves
-
-//M500 - stores paramters in EEPROM
-//M501 - reads parameters from EEPROM (if you need to reset them after you changed them temporarily).
-//M502 - reverts to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.
-//M503 - Print settings
-
-//Debug feature / Testing the PID for Hotend
-//M601 - Show Temp jitter from Extruder (min / max value from Hotend Temperature while printing)
-//M602 - Reset Temp jitter from Extruder (min / max val) --> Don't use it while Printing
-//M603 - Show Free Ram
+// Implemented Codes
+// -------------------
+// G0 -> G1
+// G1 - Coordinated Movement X Y Z E
+// G2 - CW ARC
+// G3 - CCW ARC
+// G4 - Dwell S<seconds> or P<milliseconds>
+// G28 - Home all Axis
+// G90 - Use Absolute Coordinates
+// G91 - Use Relative Coordinates
+// G92 - Set current position to cordinates given
+
+// RepRap M Codes
+// M104 - Set extruder target temp
+// M105 - Read current temp
+// M106 - Fan on
+// M107 - Fan off
+// M109 - Wait for extruder current temp to reach target temp.
+// M114 - Display current position
+
+// Custom M Codes
+// M20 - List SD card
+// M21 - Init SD card
+// M22 - Release SD card
+// M23 - Select SD file (M23 filename.g)
+// M24 - Start/resume SD print
+// M25 - Pause SD print
+// M26 - Set SD position in bytes (M26 S12345)
+// M27 - Report SD print status
+// M28 - Start SD write (M28 filename.g)
+// M29 - Stop SD write
+// - <filename> - Delete file on sd card
+// M42 - Set output on free pins, on a non pwm pin (over pin 13 on an arduino mega) use S255 to turn
+// it on and S0 to turn it off. Use P to decide the pin (M42 P23 S255) would turn pin 23 on
+// M80 - Turn on Power Supply
+// M81 - Turn off Power Supply
+// M82 - Set E codes absolute (default)
+// M83 - Set E codes relative while in Absolute Coordinates (G90) mode
+// M84 - Disable steppers until next move,
+// or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled. S0
+// to disable the timeout.
+// M85 - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+// M92 - Set axis_steps_per_unit - same syntax as G92
+// M93 - Send axis_steps_per_unit
+// M115 - Capabilities string
+// M119 - Show Endstopper State
+// M140 - Set bed target temp
+// M190 - Wait for bed current temp to reach target temp.
+// M201 - Set maximum acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+// M202 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
+// M203 - Set temperture monitor to Sx
+// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in
+// mm/sec^2
+// M205 - advanced settings: minimum travel speed S=while printing T=travel only, X=maximum xy jerk,
+// Z=maximum Z jerk
+// M206 - set additional homing offset
+
+// M220 - set speed factor override percentage S=factor in percent
+// M221 - set extruder multiply factor S100 --> original Extrude Speed
+
+// M301 - Set PID parameters P I and D
+// M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature
+// = 150C)
+
+// M400 - Finish all moves
+
+// M500 - stores paramters in EEPROM
+// M501 - reads parameters from EEPROM (if you need to reset them after you changed them
+// temporarily).
+// M502 - reverts to the default "factory settings". You still need to store them in EEPROM
+// afterwards if you want to.
+// M503 - Print settings
+
+// Debug feature / Testing the PID for Hotend
+// M601 - Show Temp jitter from Extruder (min / max value from Hotend Temperature while printing)
+// M602 - Reset Temp jitter from Extruder (min / max val) --> Don't use it while Printing
+// M603 - Show Free Ram
 
 public class SprinterDriver extends AbstractSerialPortDriver implements Runnable {
 
-/*	@Attribute(required=false) 
-    private int vacpumpPin;
- 
-    @Attribute(required=false) 
-    private boolean invertVacpump;
-
-*/	
-	private static final Logger logger = LoggerFactory.getLogger(SprinterDriver.class);
-//	private static final double minimumRequiredVersion = 0.75;
-	
-	@Attribute(required=false)
-	private int vacuumPin = 31;
-	
-	@Attribute(required=false)
-	private boolean invertVacuum;
-	
-    @Attribute(required=false)
-	private int actuatorPin = 33;
-	
-	@Attribute(required=false)
-	private boolean invertActuator;
-	
-	@Attribute(required=false)
-	private boolean homeX;
-	
-	@Attribute(required=false)
-	private boolean homeY;
-	
-	@Attribute(required=false)
-	private boolean homeZ;
-	
-	@Attribute(required=false)
-	private boolean homeC;
-	
-	@Attribute(required=false)
+    /*
+     * @Attribute(required=false) private int vacpumpPin;
+     * 
+     * @Attribute(required=false) private boolean invertVacpump;
+     * 
+     */
+    private static final Logger logger = LoggerFactory.getLogger(SprinterDriver.class);
+    // private static final double minimumRequiredVersion = 0.75;
+
+    @Attribute(required = false)
+    private int vacuumPin = 31;
+
+    @Attribute(required = false)
+    private boolean invertVacuum;
+
+    @Attribute(required = false)
+    private int actuatorPin = 33;
+
+    @Attribute(required = false)
+    private boolean invertActuator;
+
+    @Attribute(required = false)
+    private boolean homeX;
+
+    @Attribute(required = false)
+    private boolean homeY;
+
+    @Attribute(required = false)
+    private boolean homeZ;
+
+    @Attribute(required = false)
+    private boolean homeC;
+
+    @Attribute(required = false)
     private double feedRateMmPerMinute = 5000;
-	
-	private double x, y, z, c;
-	private Thread readerThread;
-	private boolean disconnectRequested;
-	private Object commandLock = new Object();
-	private boolean connected;
-//	private double connectedVersion;
-	private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
-	
-	public SprinterDriver() {
-	}
-	
+
+    private double x, y, z, c;
+    private Thread readerThread;
+    private boolean disconnectRequested;
+    private Object commandLock = new Object();
+    private boolean connected;
+    // private double connectedVersion;
+    private Queue<String> responseQueue = new ConcurrentLinkedQueue<>();
+
+    public SprinterDriver() {}
+
     @Override
     public void home(ReferenceHead head) throws Exception {
         if (homeX || homeY || homeZ || homeC) {
-            sendCommand(String.format("G28 %s %s %s %s", homeX ? "X" : "", homeY ? "Y" : "", homeZ ? "Z" : "", homeC ? "E" : ""));
+            sendCommand(String.format("G28 %s %s %s %s", homeX ? "X" : "", homeY ? "Y" : "",
+                    homeZ ? "Z" : "", homeC ? "E" : ""));
             dwell();
         }
         else {
-            throw new Exception("No homing axes defined. See the homeX, homeY, homeZ and homeC parameters.");
+            throw new Exception(
+                    "No homing axes defined. See the homeX, homeY, homeZ and homeC parameters.");
         }
         // Reset all axes to 0. This is required so that the Head and Driver
         // stay in sync.
@@ -186,8 +191,8 @@ public void home(ReferenceHead head) throws Exception {
     }
 
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
@@ -211,8 +216,7 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
             sb.append(String.format(Locale.US, "E%2.4f ", c));
         }
         if (sb.length() > 0) {
-            sb.append(String.format(Locale.US, "F%2.4f ", feedRateMmPerMinute
-                    * speed));
+            sb.append(String.format(Locale.US, "F%2.4f ", feedRateMmPerMinute * speed));
             sendCommand("G1" + sb.toString());
             dwell();
         }
@@ -248,8 +252,7 @@ public void place(ReferenceNozzle nozzle) throws Exception {
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         if (actuator == null || actuator.getIndex() == 0) {
             sendCommand(String.format("M42 P%d S%d", actuatorPin, on ^ invertActuator ? 255 : 0));
             dwell();
@@ -257,14 +260,13 @@ public void actuate(ReferenceActuator actuator, boolean on)
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         // TODO Auto-generated method stub
-        
+
     }
 
     @Override
-	public void setEnabled(boolean enabled) throws Exception {
+    public void setEnabled(boolean enabled) throws Exception {
         if (enabled && !connected) {
             connect();
         }
@@ -273,87 +275,92 @@ public void setEnabled(boolean enabled) throws Exception {
             place(null);
             actuate(null, false);
         }
-	}
-
-	public synchronized void connect() throws Exception {
-		super.connect();
-
-		/**
-		 * Connection process notes:
-		 * 
-		 * On some platforms, as soon as we open the serial port it will reset
-		 * Sprinter and we'll start getting some data. On others, Sprinter may
-		 * already be running and we will get nothing on connect.
-		 */
-		
-		List<String> responses;
-		synchronized (commandLock) {
-			// Start the reader thread with the commandLock held. This will
-			// keep the thread from quickly parsing any responses messages
-			// and notifying before we get a chance to wait.
-			readerThread = new Thread(this);
-			readerThread.start();
-			// Wait up to 3 seconds for Sprinter to say Hi
-			// If we get anything at this point it will have been the settings
-			// dump that is sent after reset.
-			responses = sendCommand(null, 3000);
-		}
-
-		processConnectionResponses(responses);
-
-		for (int i = 0; i < 5 && !connected; i++) {
-			responses = sendCommand("M115", 5000);
-			processConnectionResponses(responses);
-		}
-		
-		if (!connected)  {
-			throw new Exception(
-//				String.format("Unable to receive connection response from Sprinter. Check your port and baud rate, and that you are running at least version %f of Sprinter", 
-//						minimumRequiredVersion));
-				String.format("Unable to receive connection response from Sprinter. Check your port and baud rate, and that you are running the latest version of Sprinter."));
-		}
-		
-		// TODO: Version Info
-//		if (connectedVersion < minimumRequiredVersion) {
-//			throw new Error(String.format("This driver requires Sprinter version %.2f or higher. You are running version %.2f", minimumRequiredVersion, connectedVersion));
-//		}
-		
-		// We are connected to at least the minimum required version now
-		// So perform some setup
-		
-		// Turn off the stepper drivers
-		setEnabled(false);
-		
-		// Reset all axes to 0, in case the firmware was not reset on
-		// connect.
-		sendCommand("G92 X0 Y0 Z0 E0");
-	}
-	
-	private void processConnectionResponses(List<String> responses) {
-		for (String response : responses) {
-			if (response.startsWith("FIRMWARE_NAME:") || response.equals("Sprinter")) {
-//				String[] versionComponents = response.split(" ");
-//				connectedVersion = Double.parseDouble(versionComponents[2]);
-				connected = true;
-//				logger.debug(String.format("Connected to Sprinter Version: %.2f", connectedVersion));
-				logger.debug(String.format("Connected to Sprinter."));
-			}
-		}
-	}
-
-	public synchronized void disconnect() {
-		disconnectRequested = true;
-		connected = false;
-		
-		try {
-			if (readerThread != null && readerThread.isAlive()) {
-				readerThread.join();
-			}
-		}
-		catch (Exception e) {
-			logger.error("disconnect()", e);
-		}
-		
+    }
+
+    public synchronized void connect() throws Exception {
+        super.connect();
+
+        /**
+         * Connection process notes:
+         * 
+         * On some platforms, as soon as we open the serial port it will reset Sprinter and we'll
+         * start getting some data. On others, Sprinter may already be running and we will get
+         * nothing on connect.
+         */
+
+        List<String> responses;
+        synchronized (commandLock) {
+            // Start the reader thread with the commandLock held. This will
+            // keep the thread from quickly parsing any responses messages
+            // and notifying before we get a chance to wait.
+            readerThread = new Thread(this);
+            readerThread.start();
+            // Wait up to 3 seconds for Sprinter to say Hi
+            // If we get anything at this point it will have been the settings
+            // dump that is sent after reset.
+            responses = sendCommand(null, 3000);
+        }
+
+        processConnectionResponses(responses);
+
+        for (int i = 0; i < 5 && !connected; i++) {
+            responses = sendCommand("M115", 5000);
+            processConnectionResponses(responses);
+        }
+
+        if (!connected) {
+            throw new Exception(
+                    // String.format("Unable to receive connection response from Sprinter. Check
+                    // your port and baud rate, and that you are running at least version %f of
+                    // Sprinter",
+                    // minimumRequiredVersion));
+                    String.format(
+                            "Unable to receive connection response from Sprinter. Check your port and baud rate, and that you are running the latest version of Sprinter."));
+        }
+
+        // TODO: Version Info
+        // if (connectedVersion < minimumRequiredVersion) {
+        // throw new Error(String.format("This driver requires Sprinter version %.2f or higher. You
+        // are running version %.2f", minimumRequiredVersion, connectedVersion));
+        // }
+
+        // We are connected to at least the minimum required version now
+        // So perform some setup
+
+        // Turn off the stepper drivers
+        setEnabled(false);
+
+        // Reset all axes to 0, in case the firmware was not reset on
+        // connect.
+        sendCommand("G92 X0 Y0 Z0 E0");
+    }
+
+    private void processConnectionResponses(List<String> responses) {
+        for (String response : responses) {
+            if (response.startsWith("FIRMWARE_NAME:") || response.equals("Sprinter")) {
+                // String[] versionComponents = response.split(" ");
+                // connectedVersion = Double.parseDouble(versionComponents[2]);
+                connected = true;
+                // logger.debug(String.format("Connected to Sprinter Version: %.2f",
+                // connectedVersion));
+                logger.debug(String.format("Connected to Sprinter."));
+            }
+        }
+    }
+
+    public synchronized void disconnect() {
+        disconnectRequested = true;
+        connected = false;
+
+        try {
+            if (readerThread != null && readerThread.isAlive()) {
+                readerThread.join();
+            }
+        }
+        catch (Exception e) {
+            logger.error("disconnect()", e);
+        }
+
         try {
             super.disconnect();
         }
@@ -361,34 +368,34 @@ public synchronized void disconnect() {
             logger.error("disconnect()", e);
         }
         disconnectRequested = false;
-	}
-
-	protected List<String> sendCommand(String command) throws Exception {
-		return sendCommand(command, -1);
-	}
-	
-	private List<String> sendCommand(String command, long timeout) throws Exception {
-		synchronized (commandLock) {
-			if (command != null) {
-				logger.debug("> " + command);
-				output.write(command.getBytes());
-				output.write("\n".getBytes());
-			}
-			long t = System.currentTimeMillis();
-			if (timeout == -1) {
-				commandLock.wait();
-			}
-			else {
-				commandLock.wait(timeout);
-			}
-			logger.debug("Waited {} ms for command to return.", (System.currentTimeMillis() - t));
-		}
-		List<String> responses = drainResponseQueue();
-		return responses;
-	}
-	
-	public void run() {
-		while (!disconnectRequested) {
+    }
+
+    protected List<String> sendCommand(String command) throws Exception {
+        return sendCommand(command, -1);
+    }
+
+    private List<String> sendCommand(String command, long timeout) throws Exception {
+        synchronized (commandLock) {
+            if (command != null) {
+                logger.debug("> " + command);
+                output.write(command.getBytes());
+                output.write("\n".getBytes());
+            }
+            long t = System.currentTimeMillis();
+            if (timeout == -1) {
+                commandLock.wait();
+            }
+            else {
+                commandLock.wait(timeout);
+            }
+            logger.debug("Waited {} ms for command to return.", (System.currentTimeMillis() - t));
+        }
+        List<String> responses = drainResponseQueue();
+        return responses;
+    }
+
+    public void run() {
+        while (!disconnectRequested) {
             String line;
             try {
                 line = readLine().trim();
@@ -401,37 +408,39 @@ public void run() {
                 return;
             }
             line = line.trim();
-			logger.debug("< " + line);
-			responseQueue.offer(line);
-			// We have a special case of accepting "start" when we are not
-			// connected because Sprinter does not send an "ok" when it starts
-			// up.
-			if (line.equals("ok") || line.startsWith("error: ") || (!connected && line.equals("start"))) {
-				// This is the end of processing for a command
-				synchronized (commandLock) {
-					commandLock.notify();
-				}
-			}
-		}
-	}
-
-	/**
-	 * Causes Sprinter to block until all commands are complete.
-	 * @throws Exception
-	 */
-	protected void dwell() throws Exception {
-		sendCommand("M400");
-	}
-
-	private List<String> drainResponseQueue() {
-		List<String> responses = new ArrayList<>();
-		String response;
-		while ((response = responseQueue.poll()) != null) {
-			responses.add(response);
-		}
-		return responses;
-	}
-	
+            logger.debug("< " + line);
+            responseQueue.offer(line);
+            // We have a special case of accepting "start" when we are not
+            // connected because Sprinter does not send an "ok" when it starts
+            // up.
+            if (line.equals("ok") || line.startsWith("error: ")
+                    || (!connected && line.equals("start"))) {
+                // This is the end of processing for a command
+                synchronized (commandLock) {
+                    commandLock.notify();
+                }
+            }
+        }
+    }
+
+    /**
+     * Causes Sprinter to block until all commands are complete.
+     * 
+     * @throws Exception
+     */
+    protected void dwell() throws Exception {
+        sendCommand("M400");
+    }
+
+    private List<String> drainResponseQueue() {
+        List<String> responses = new ArrayList<>();
+        String response;
+        while ((response = responseQueue.poll()) != null) {
+            responses.add(response);
+        }
+        return responses;
+    }
+
     @Override
     public Wizard getConfigurationWizard() {
         return new AbstractSerialPortDriverConfigurationWizard(this);
@@ -450,14 +459,12 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
-    }	
-    
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
+    }
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
-    }    
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/TinygDriver.java b/src/main/java/org/openpnp/machine/reference/driver/TinygDriver.java
index 0990740099..19aafa474b 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/TinygDriver.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/TinygDriver.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.driver;
@@ -47,15 +45,13 @@
 import com.google.gson.JsonSyntaxException;
 
 /**
- * TODO: Consider adding some type of heartbeat to the firmware.
- * TODO: The whole movement wait lock thing has to go. See if we can do a
- * P4 type command like the other drivers to wait for movement to complete.
- * Disabled axes don't send status reports, so movement wait lock never happens.
+ * TODO: Consider adding some type of heartbeat to the firmware. TODO: The whole movement wait lock
+ * thing has to go. See if we can do a P4 type command like the other drivers to wait for movement
+ * to complete. Disabled axes don't send status reports, so movement wait lock never happens.
  * Probably short moves also won't.
  */
 public class TinygDriver extends AbstractSerialPortDriver implements Runnable {
-    private static final Logger logger = LoggerFactory
-            .getLogger(TinygDriver.class);
+    private static final Logger logger = LoggerFactory.getLogger(TinygDriver.class);
     private static final double minimumRequiredVersion = 0.95;
 
     @Attribute(required = false)
@@ -73,8 +69,7 @@
     private double connectedVersion;
     private JsonParser parser = new JsonParser();
 
-    public TinygDriver() {
-    }
+    public TinygDriver() {}
 
     @Override
     public synchronized void connect() throws Exception {
@@ -89,6 +84,7 @@ public synchronized void connect() throws Exception {
                 // {"r":{"fv":0.950,"f":[1,0,10,2853]}}
                 connectedVersion = response.get("r").getAsJsonObject().get("fv").getAsDouble();
                 connected = true;
+                response = sendCommand("{\"qv\":0}", 500);
                 break;
             }
             catch (Exception e) {
@@ -97,21 +93,18 @@ public synchronized void connect() throws Exception {
         }
 
         if (!connected) {
-            throw new Exception(
-                    String.format(
-                            "Unable to receive connection response from TinyG. Check your port and baud rate, and that you are running at least version %f of TinyG",
-                            minimumRequiredVersion));
+            throw new Exception(String.format(
+                    "Unable to receive connection response from TinyG. Check your port and baud rate, and that you are running at least version %f of TinyG",
+                    minimumRequiredVersion));
         }
 
         if (connectedVersion < minimumRequiredVersion) {
-            throw new Exception(
-                    String.format(
-                            "This driver requires TinyG version %.2f or higher. You are running version %.2f",
-                            minimumRequiredVersion, connectedVersion));
+            throw new Exception(String.format(
+                    "This driver requires TinyG version %.2f or higher. You are running version %.2f",
+                    minimumRequiredVersion, connectedVersion));
         }
 
-        logger.debug(String.format("Connected to TinyG Version: %.2f",
-                connectedVersion));
+        logger.debug(String.format("Connected to TinyG Version: %.2f", connectedVersion));
 
         // We are connected to at least the minimum required version now
         // So perform some setup
@@ -124,7 +117,7 @@ public synchronized void connect() throws Exception {
 
         // Make sure we are in absolute mode
         sendCommand("G90");
-        
+
         // Reset all axes to 0, in case the firmware was not reset on
         // connect.
         sendCommand(String.format(Locale.US, "G92 X0 Y0 Z0 A0"));
@@ -140,15 +133,17 @@ public void setEnabled(boolean enabled) throws Exception {
 
     @Override
     public void home(ReferenceHead head) throws Exception {
-        // TODO: figure out how to home
-        // sendCommand("G28.2");
+        synchronized (movementWaitLock) {
+            JsonObject response = sendCommand("G28.2 X0 Y0 Z0 A0");
+            if (getResponseStatusCode(response) == 0) {
+                waitForMovementComplete();
+            }
+        }
 
         // TODO: This homeLocation really needs to be Head specific.
-        Location homeLocation = this.homeLocation
-                .convertToUnits(LengthUnit.Millimeters);
-        sendCommand(String.format(Locale.US, "G92 X%2.2f Y%2.2f Z%2.2f A%2.2f",
-                homeLocation.getX(), homeLocation.getY(), homeLocation.getZ(),
-                homeLocation.getRotation()));
+        Location homeLocation = this.homeLocation.convertToUnits(LengthUnit.Millimeters);
+        sendCommand(String.format(Locale.US, "G92 X%2.2f Y%2.2f Z%2.2f A%2.2f", homeLocation.getX(),
+                homeLocation.getY(), homeLocation.getZ(), homeLocation.getRotation()));
 
         x = homeLocation.getX();
         y = homeLocation.getY();
@@ -157,8 +152,8 @@ public void home(ReferenceHead head) throws Exception {
     }
 
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         location = location.subtract(hm.getHeadOffsets());
 
         location = location.convertToUnits(LengthUnit.Millimeters);
@@ -182,8 +177,7 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
             sb.append(String.format(Locale.US, "A%2.2f ", c));
         }
         if (sb.length() > 0) {
-            sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute
-                    * speed));
+            sb.append(String.format(Locale.US, "F%2.2f", feedRateMmPerMinute * speed));
             // TODO: Move this type of op into it's own method
             // sendCommandAndWaitForMovementComplete()
             synchronized (movementWaitLock) {
@@ -218,15 +212,13 @@ public void place(ReferenceNozzle nozzle) throws Exception {
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         // TODO Auto-generated method stub
 
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         if (actuator.getIndex() == 0) {
             sendCommand(on ? "M8" : "M9");
         }
@@ -234,8 +226,7 @@ public void actuate(ReferenceActuator actuator, boolean on)
 
     @Override
     public Location getLocation(ReferenceHeadMountable hm) {
-        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm
-                .getHeadOffsets());
+        return new Location(LengthUnit.Millimeters, x, y, z, c).add(hm.getHeadOffsets());
     }
 
     private int getResponseStatusCode(JsonObject o) {
@@ -254,7 +245,7 @@ public synchronized void disconnect() {
         catch (Exception e) {
             logger.error("disconnect()", e);
         }
-        
+
         try {
             super.disconnect();
         }
@@ -268,8 +259,7 @@ public JsonObject sendCommand(String command) throws Exception {
         return sendCommand(command, -1);
     }
 
-    public synchronized JsonObject sendCommand(String command, long timeout)
-            throws Exception {
+    public synchronized JsonObject sendCommand(String command, long timeout) throws Exception {
         JsonObject response;
         synchronized (commandLock) {
             lastResponse = null;
@@ -294,8 +284,7 @@ public synchronized JsonObject sendCommand(String command, long timeout)
         // job done for now. Later we should make it up to the sending command
         // to determine what to accept and what to fail.
         if (responseStatusCode != 0 && responseStatusCode != 60) {
-            throw new Exception("Command failed. Status code: "
-                    + responseStatusCode);
+            throw new Exception("Command failed. Status code: " + responseStatusCode);
         }
         return response;
     }
@@ -447,14 +436,12 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
-    }    
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/wizards/AbstractSerialPortDriverConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/driver/wizards/AbstractSerialPortDriverConfigurationWizard.java
index 8c44334cef..3504df3ca4 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/wizards/AbstractSerialPortDriverConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/wizards/AbstractSerialPortDriverConfigurationWizard.java
@@ -20,37 +20,32 @@
     private final AbstractSerialPortDriver driver;
     private JComboBox comboBoxPort;
     private JComboBox comboBoxBaud;
-    
+
     public AbstractSerialPortDriverConfigurationWizard(AbstractSerialPortDriver driver) {
         this.driver = driver;
-        
+
         contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
-        
+
         JPanel panel = new JPanel();
         contentPanel.add(panel);
-        panel.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panel.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblPortName = new JLabel("Port");
         panel.add(lblPortName, "2, 2, right, default");
-        
+
         comboBoxPort = new JComboBox();
         panel.add(comboBoxPort, "4, 2, fill, default");
-        
+
         JLabel lblBaudRate = new JLabel("Baud");
         panel.add(lblBaudRate, "2, 4, right, default");
-        
+
         comboBoxBaud = new JComboBox();
         panel.add(comboBoxBaud, "4, 4, fill, default");
-        
+
         comboBoxBaud.addItem(new Integer(110));
         comboBoxBaud.addItem(new Integer(300));
         comboBoxBaud.addItem(new Integer(600));
@@ -71,25 +66,23 @@ public AbstractSerialPortDriverConfigurationWizard(AbstractSerialPortDriver driv
         comboBoxBaud.addItem(new Integer(256000));
         comboBoxBaud.addItem(new Integer(460800));
         comboBoxBaud.addItem(new Integer(921600));
-        
+
         comboBoxPort.addPopupMenuListener(new PopupMenuListener() {
             @Override
             public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
                 refreshPortList();
             }
-            
+
             @Override
-            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
-            }
-            
+            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
+
             @Override
-            public void popupMenuCanceled(PopupMenuEvent e) {
-            }
+            public void popupMenuCanceled(PopupMenuEvent e) {}
         });
 
         refreshPortList();
     }
-    
+
     private void refreshPortList() {
         if (driver != null) {
             comboBoxPort.removeAllItems();
@@ -106,11 +99,11 @@ private void refreshPortList() {
             }
         }
     }
-    
+
     @Override
     public void createBindings() {
         IntegerConverter integerConverter = new IntegerConverter();
-        
+
         addWrappedBinding(driver, "portName", comboBoxPort, "selectedItem");
         addWrappedBinding(driver, "baud", comboBoxBaud, "selectedItem");
     }
diff --git a/src/main/java/org/openpnp/machine/reference/driver/wizards/TinygDriverConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/driver/wizards/TinygDriverConfigurationWizard.java
index d0d2abbdc7..9ddd9947b7 100755
--- a/src/main/java/org/openpnp/machine/reference/driver/wizards/TinygDriverConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/driver/wizards/TinygDriverConfigurationWizard.java
@@ -60,320 +60,304 @@
     private JCheckBox m2RevPol;
     private JCheckBox m3RevPol;
     private JCheckBox m4RevPol;
-    
+
     public TinygDriverConfigurationWizard(TinygDriver driver) {
         this.driver = driver;
-        
+
         contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
-        
+
         JPanel panelGeneral = new JPanel();
-        panelGeneral.setBorder(new TitledBorder(null, "General Settings", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelGeneral.setBorder(new TitledBorder(null, "General Settings", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelGeneral);
-        panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {},
-            new RowSpec[] {}));
-        
+        panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {}, new RowSpec[] {}));
+
         JPanel panelMotors = new JPanel();
-        panelMotors.setBorder(new TitledBorder(null, "Motors", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelMotors.setBorder(new TitledBorder(null, "Motors", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelMotors);
-        panelMotors.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelMotors
+                .setLayout(
+                        new FormLayout(
+                                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                                        FormSpecs.DEFAULT_COLSPEC, FormSpecs.RELATED_GAP_COLSPEC,
+                                        ColumnSpec.decode("default:grow"),
+                                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec
+                                                .decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                        new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel label = new JLabel("1");
         panelMotors.add(label, "4, 2");
-        
+
         JLabel label_1 = new JLabel("2");
         panelMotors.add(label_1, "6, 2");
-        
+
         JLabel label_2 = new JLabel("3");
         panelMotors.add(label_2, "8, 2");
-        
+
         JLabel label_3 = new JLabel("4");
         panelMotors.add(label_3, "10, 2");
-        
+
         JLabel lblAxis = new JLabel("Axis");
         panelMotors.add(lblAxis, "2, 4, right, default");
-        
+
         JSpinner m1Axis = new JSpinner();
         panelMotors.add(m1Axis, "4, 4");
-        
+
         JSpinner m2Axis = new JSpinner();
         panelMotors.add(m2Axis, "6, 4");
-        
+
         JSpinner m3Axis = new JSpinner();
         panelMotors.add(m3Axis, "8, 4");
-        
+
         JSpinner m4Axis = new JSpinner();
         panelMotors.add(m4Axis, "10, 4");
-        
+
         JLabel lblStepAngle = new JLabel("Step Angle");
         panelMotors.add(lblStepAngle, "2, 6, right, default");
-        
+
         m1StepAngle = new JTextField();
         m1StepAngle.setText("1.8");
         panelMotors.add(m1StepAngle, "4, 6");
         m1StepAngle.setColumns(10);
-        
+
         m2StepAngle = new JTextField();
         m2StepAngle.setText("1.8");
         panelMotors.add(m2StepAngle, "6, 6");
         m2StepAngle.setColumns(10);
-        
+
         m3StepAngle = new JTextField();
         m3StepAngle.setText("1.8");
         panelMotors.add(m3StepAngle, "8, 6");
         m3StepAngle.setColumns(10);
-        
+
         m4StepAngle = new JTextField();
         m4StepAngle.setText("1.8");
         panelMotors.add(m4StepAngle, "10, 6");
         m4StepAngle.setColumns(10);
-        
+
         JLabel lblTravelPerRev = new JLabel("Travel Per Rev.");
         panelMotors.add(lblTravelPerRev, "2, 8, right, default");
-        
+
         m1TravelPerRev = new JTextField();
         panelMotors.add(m1TravelPerRev, "4, 8, fill, default");
         m1TravelPerRev.setColumns(10);
-        
+
         m2TravelPerRev = new JTextField();
         panelMotors.add(m2TravelPerRev, "6, 8, fill, default");
         m2TravelPerRev.setColumns(10);
-        
+
         m3TravelPerRev = new JTextField();
         panelMotors.add(m3TravelPerRev, "8, 8, fill, default");
         m3TravelPerRev.setColumns(10);
-        
+
         m4TravelPerRev = new JTextField();
         panelMotors.add(m4TravelPerRev, "10, 8, fill, default");
         m4TravelPerRev.setColumns(10);
-        
+
         JLabel lblMicrosteps = new JLabel("Microsteps");
         panelMotors.add(lblMicrosteps, "2, 10, right, default");
-        
-        JSpinner m1Microsteps = new JSpinner(new SpinnerListModel(new Object[] { (Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8 }));
+
+        JSpinner m1Microsteps = new JSpinner(new SpinnerListModel(
+                new Object[] {(Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8}));
         panelMotors.add(m1Microsteps, "4, 10");
-        
-        JSpinner m2Microsteps = new JSpinner(new SpinnerListModel(new Object[] { (Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8 }));
+
+        JSpinner m2Microsteps = new JSpinner(new SpinnerListModel(
+                new Object[] {(Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8}));
         panelMotors.add(m2Microsteps, "6, 10");
-        
-        JSpinner m3Microsteps = new JSpinner(new SpinnerListModel(new Object[] { (Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8 }));
+
+        JSpinner m3Microsteps = new JSpinner(new SpinnerListModel(
+                new Object[] {(Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8}));
         panelMotors.add(m3Microsteps, "8, 10");
-        
-        JSpinner m4Microsteps = new JSpinner(new SpinnerListModel(new Object[] { (Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8 }));
+
+        JSpinner m4Microsteps = new JSpinner(new SpinnerListModel(
+                new Object[] {(Integer) 1, (Integer) 2, (Integer) 4, (Integer) 8}));
         panelMotors.add(m4Microsteps, "10, 10");
-        
+
         JLabel lblPolarity = new JLabel("Reverse Polarity");
         panelMotors.add(lblPolarity, "2, 12, right, default");
-        
+
         m1RevPol = new JCheckBox("");
         panelMotors.add(m1RevPol, "4, 12");
-        
+
         m2RevPol = new JCheckBox("");
         panelMotors.add(m2RevPol, "6, 12");
-        
+
         m3RevPol = new JCheckBox("");
         panelMotors.add(m3RevPol, "8, 12");
-        
+
         m4RevPol = new JCheckBox("");
         panelMotors.add(m4RevPol, "10, 12");
-        
+
         JLabel lblPowerManagement = new JLabel("Power Management");
         panelMotors.add(lblPowerManagement, "2, 14");
-        
+
         m1PowerMgmt = new JCheckBox("");
         panelMotors.add(m1PowerMgmt, "4, 14");
-        
+
         m2PowerMgmt = new JCheckBox("");
         panelMotors.add(m2PowerMgmt, "6, 14");
-        
+
         m3PowerMgmt = new JCheckBox("");
         panelMotors.add(m3PowerMgmt, "8, 14");
-        
+
         m4PowerMgmt = new JCheckBox("");
         panelMotors.add(m4PowerMgmt, "10, 14");
-        
+
         JPanel panelAxes = new JPanel();
-        panelAxes.setBorder(new TitledBorder(null, "Axes", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelAxes.setBorder(
+                new TitledBorder(null, "Axes", TitledBorder.LEADING, TitledBorder.TOP, null, null));
         contentPanel.add(panelAxes);
-        panelAxes.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelAxes.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblX = new JLabel("X");
         panelAxes.add(lblX, "4, 2");
-        
+
         JLabel lblY = new JLabel("Y");
         panelAxes.add(lblY, "6, 2");
-        
+
         JLabel lblZ = new JLabel("Z");
         panelAxes.add(lblZ, "8, 2");
-        
+
         JLabel lblA = new JLabel("A");
         panelAxes.add(lblA, "10, 2");
-        
+
         JLabel lblB = new JLabel("B");
         panelAxes.add(lblB, "12, 2");
-        
+
         JLabel lblC = new JLabel("C");
         panelAxes.add(lblC, "14, 2");
-        
+
         JLabel lblAxisMode = new JLabel("Axis Mode");
         panelAxes.add(lblAxisMode, "2, 4, right, default");
-        
+
         JComboBox xAxisMode = new JComboBox();
         panelAxes.add(xAxisMode, "4, 4, fill, default");
-        
+
         JComboBox yAxisMode = new JComboBox();
         panelAxes.add(yAxisMode, "6, 4, fill, default");
-        
+
         JComboBox comboBox_10 = new JComboBox();
         panelAxes.add(comboBox_10, "8, 4, fill, default");
-        
+
         JComboBox comboBox_11 = new JComboBox();
         panelAxes.add(comboBox_11, "10, 4, fill, default");
-        
+
         JComboBox comboBox_12 = new JComboBox();
         panelAxes.add(comboBox_12, "12, 4, fill, default");
-        
+
         JComboBox comboBox_13 = new JComboBox();
         panelAxes.add(comboBox_13, "14, 4, fill, default");
-        
+
         JLabel lblVelocityMax = new JLabel("Velocity Max.");
         panelAxes.add(lblVelocityMax, "2, 6, right, default");
-        
+
         xVelMax = new JTextField();
         panelAxes.add(xVelMax, "4, 6, fill, default");
         xVelMax.setColumns(10);
-        
+
         yVelMax = new JTextField();
         panelAxes.add(yVelMax, "6, 6, fill, default");
         yVelMax.setColumns(10);
-        
+
         textField_10 = new JTextField();
         panelAxes.add(textField_10, "8, 6, fill, default");
         textField_10.setColumns(10);
-        
+
         textField_11 = new JTextField();
         panelAxes.add(textField_11, "10, 6, fill, default");
         textField_11.setColumns(10);
-        
+
         textField_12 = new JTextField();
         panelAxes.add(textField_12, "12, 6, fill, default");
         textField_12.setColumns(10);
-        
+
         textField_13 = new JTextField();
         panelAxes.add(textField_13, "14, 6, fill, default");
         textField_13.setColumns(10);
-        
+
         JLabel lblFeedrateMax = new JLabel("Feedrate Max.");
         panelAxes.add(lblFeedrateMax, "2, 8, right, default");
-        
+
         xFeedMax = new JTextField();
         panelAxes.add(xFeedMax, "4, 8, fill, default");
         xFeedMax.setColumns(10);
-        
+
         yFeedMax = new JTextField();
         panelAxes.add(yFeedMax, "6, 8, fill, default");
         yFeedMax.setColumns(10);
-        
+
         textField_16 = new JTextField();
         panelAxes.add(textField_16, "8, 8, fill, default");
         textField_16.setColumns(10);
-        
+
         textField_17 = new JTextField();
         panelAxes.add(textField_17, "10, 8, fill, default");
         textField_17.setColumns(10);
-        
+
         textField_18 = new JTextField();
         panelAxes.add(textField_18, "12, 8, fill, default");
         textField_18.setColumns(10);
-        
+
         textField_19 = new JTextField();
         panelAxes.add(textField_19, "14, 8, fill, default");
         textField_19.setColumns(10);
-        
+
         JLabel lblJerkMax = new JLabel("Jerk Max.");
         panelAxes.add(lblJerkMax, "2, 10, right, default");
-        
+
         xJerkMax = new JTextField();
         panelAxes.add(xJerkMax, "4, 10, fill, default");
         xJerkMax.setColumns(10);
-        
+
         yJerkMax = new JTextField();
         panelAxes.add(yJerkMax, "6, 10, fill, default");
         yJerkMax.setColumns(10);
-        
+
         textField_22 = new JTextField();
         panelAxes.add(textField_22, "8, 10, fill, default");
         textField_22.setColumns(10);
-        
+
         textField_23 = new JTextField();
         panelAxes.add(textField_23, "10, 10, fill, default");
         textField_23.setColumns(10);
-        
+
         textField_24 = new JTextField();
         panelAxes.add(textField_24, "12, 10, fill, default");
         textField_24.setColumns(10);
-        
+
         textField_25 = new JTextField();
         panelAxes.add(textField_25, "14, 10, fill, default");
         textField_25.setColumns(10);
     }
-    
+
     @Override
     public void createBindings() {
-    	IntegerConverter integerConverter = new IntegerConverter();
+        IntegerConverter integerConverter = new IntegerConverter();
         DoubleConverter doubleConverter = new DoubleConverter("%f");
-        
+
         ConfigProxy configProxy = new ConfigProxy();
-        
+
         addWrappedBinding(configProxy, "stepAngleM1", m1StepAngle, "text", doubleConverter);
         addWrappedBinding(configProxy, "stepAngleM2", m2StepAngle, "text", doubleConverter);
         addWrappedBinding(configProxy, "stepAngleM3", m3StepAngle, "text", doubleConverter);
@@ -383,7 +367,7 @@ public void createBindings() {
         addWrappedBinding(configProxy, "travelPerRevM2", m2TravelPerRev, "text", doubleConverter);
         addWrappedBinding(configProxy, "travelPerRevM3", m3TravelPerRev, "text", doubleConverter);
         addWrappedBinding(configProxy, "travelPerRevM4", m4TravelPerRev, "text", doubleConverter);
-        
+
         addWrappedBinding(configProxy, "polarityReversedM1", m1RevPol, "selected");
         addWrappedBinding(configProxy, "polarityReversedM2", m2RevPol, "selected");
         addWrappedBinding(configProxy, "polarityReversedM3", m3RevPol, "selected");
@@ -393,13 +377,13 @@ public void createBindings() {
         addWrappedBinding(configProxy, "powerMgmtM2", m2PowerMgmt, "selected");
         addWrappedBinding(configProxy, "powerMgmtM3", m3PowerMgmt, "selected");
         addWrappedBinding(configProxy, "powerMgmtM4", m4PowerMgmt, "selected");
-        
+
         addWrappedBinding(configProxy, "velMaxX", xVelMax, "text", integerConverter);
         addWrappedBinding(configProxy, "velMaxY", yVelMax, "text", integerConverter);
-        
+
         addWrappedBinding(configProxy, "feedMaxX", xFeedMax, "text", integerConverter);
         addWrappedBinding(configProxy, "feedMaxY", yFeedMax, "text", integerConverter);
-        
+
         addWrappedBinding(configProxy, "jerkMaxX", xJerkMax, "text", integerConverter);
         addWrappedBinding(configProxy, "jerkMaxY", yJerkMax, "text", integerConverter);
 
@@ -412,258 +396,256 @@ public void createBindings() {
         ComponentDecorators.decorateWithAutoSelect(m2TravelPerRev);
         ComponentDecorators.decorateWithAutoSelect(m3TravelPerRev);
         ComponentDecorators.decorateWithAutoSelect(m4TravelPerRev);
-        
+
         ComponentDecorators.decorateWithAutoSelect(xVelMax);
         ComponentDecorators.decorateWithAutoSelect(yVelMax);
-        
+
         ComponentDecorators.decorateWithAutoSelect(xFeedMax);
         ComponentDecorators.decorateWithAutoSelect(yFeedMax);
-        
+
         ComponentDecorators.decorateWithAutoSelect(xJerkMax);
         ComponentDecorators.decorateWithAutoSelect(yJerkMax);
     }
-        
-    
+
+
     public class ConfigProxy {
-//                [1ma] m1 map to axis              0 [0=X,1=Y,2=Z...]
-//                [1sa] m1 step angle               1.800 deg
-//                [1tr] m1 travel per revolution    1.250 mm
-//                [1mi] m1 microsteps               8 [1,2,4,8]
-//                [1po] m1 polarity                 0 [0=normal,1=reverse]
-//                [1pm] m1 power management         1 [0=off,1=on]
-//                tinyg [mm] ok>
-        
-//                [xam] x axis mode                 1 [standard]
-//                [xvm] x velocity maximum       5000.000 mm/min
-//                [xfr] x feedrate maximum       5000.000 mm/min
-//                [xtm] x travel maximum          150.000 mm
-//                [xjm] x jerk maximum       20000000 mm/min^3
-//                [xjh] x jerk homing        20000000 mm/min^3
-//                [xjd] x junction deviation        0.0500 mm (larger is faster)
-//                [xsn] x switch min                1 [0=off,1=homing,2=limit,3=limit+homing]
-//                [xsx] x switch max                0 [0=off,1=homing,2=limit,3=limit+homing]
-//                [xsv] x search velocity         500.000 mm/min
-//                [xlv] x latch velocity          100.000 mm/min
-//                [xlb] x latch backoff             2.000 mm
-//                [xzb] x zero backoff              1.000 mm
-//                tinyg [mm] ok>         
-        
-        
+        // [1ma] m1 map to axis 0 [0=X,1=Y,2=Z...]
+        // [1sa] m1 step angle 1.800 deg
+        // [1tr] m1 travel per revolution 1.250 mm
+        // [1mi] m1 microsteps 8 [1,2,4,8]
+        // [1po] m1 polarity 0 [0=normal,1=reverse]
+        // [1pm] m1 power management 1 [0=off,1=on]
+        // tinyg [mm] ok>
+
+        // [xam] x axis mode 1 [standard]
+        // [xvm] x velocity maximum 5000.000 mm/min
+        // [xfr] x feedrate maximum 5000.000 mm/min
+        // [xtm] x travel maximum 150.000 mm
+        // [xjm] x jerk maximum 20000000 mm/min^3
+        // [xjh] x jerk homing 20000000 mm/min^3
+        // [xjd] x junction deviation 0.0500 mm (larger is faster)
+        // [xsn] x switch min 1 [0=off,1=homing,2=limit,3=limit+homing]
+        // [xsx] x switch max 0 [0=off,1=homing,2=limit,3=limit+homing]
+        // [xsv] x search velocity 500.000 mm/min
+        // [xlv] x latch velocity 100.000 mm/min
+        // [xlb] x latch backoff 2.000 mm
+        // [xzb] x zero backoff 1.000 mm
+        // tinyg [mm] ok>
+
+
         public double getStepAngleM1() throws Exception {
             return getConfigDouble("1sa");
         }
-        
+
         public void setStepAngleM1(double v) throws Exception {
             setConfigDouble("1sa", v);
         }
-        
+
         public double getStepAngleM2() throws Exception {
             return getConfigDouble("2sa");
         }
-        
+
         public void setStepAngleM2(double v) throws Exception {
             setConfigDouble("2sa", v);
         }
-        
+
         public double getStepAngleM3() throws Exception {
             return getConfigDouble("3sa");
         }
-        
+
         public void setStepAngleM3(double v) throws Exception {
             setConfigDouble("3sa", v);
         }
-        
+
         public double getStepAngleM4() throws Exception {
             return getConfigDouble("4sa");
         }
-        
+
         public void setStepAngleM4(double v) throws Exception {
             setConfigDouble("4sa", v);
         }
-        
 
-        
+
+
         public double getTravelPerRevM1() throws Exception {
             return getConfigDouble("1tr");
         }
-        
+
         public void setTravelPerRevM1(double v) throws Exception {
             setConfigDouble("1tr", v);
         }
-        
+
         public double getTravelPerRevM2() throws Exception {
             return getConfigDouble("2tr");
         }
-        
+
         public void setTravelPerRevM2(double v) throws Exception {
             setConfigDouble("2tr", v);
         }
-        
+
         public double getTravelPerRevM3() throws Exception {
             return getConfigDouble("3tr");
         }
-        
+
         public void setTravelPerRevM3(double v) throws Exception {
             setConfigDouble("3tr", v);
         }
-        
+
         public double getTravelPerRevM4() throws Exception {
             return getConfigDouble("4tr");
         }
-        
+
         public void setTravelPerRevM4(double v) throws Exception {
             setConfigDouble("4tr", v);
         }
-        
-        
-        
+
+
+
         public boolean getPolarityReversedM1() throws Exception {
             return getConfigBoolean("1po");
         }
-        
+
         public void setPolarityReversedM1(boolean v) throws Exception {
             setConfigBoolean("1po", v);
         }
-        
+
         public boolean getPolarityReversedM2() throws Exception {
             return getConfigBoolean("2po");
         }
-        
+
         public void setPolarityReversedM2(boolean v) throws Exception {
             setConfigBoolean("2po", v);
         }
-        
+
         public boolean getPolarityReversedM3() throws Exception {
             return getConfigBoolean("3po");
         }
-        
+
         public void setPolarityReversedM3(boolean v) throws Exception {
             setConfigBoolean("3po", v);
         }
-        
+
         public boolean getPolarityReversedM4() throws Exception {
             return getConfigBoolean("4po");
         }
-        
+
         public void setPolarityReversedM4(boolean v) throws Exception {
             setConfigBoolean("4po", v);
         }
-        
-        
-        
+
+
+
         public boolean getPowerMgmtM1() throws Exception {
             return getConfigBoolean("1pm");
         }
-        
+
         public void setPowerMgmtM1(boolean v) throws Exception {
             setConfigBoolean("1pm", v);
         }
-        
+
         public boolean getPowerMgmtM2() throws Exception {
             return getConfigBoolean("2pm");
         }
-        
+
         public void setPowerMgmtM2(boolean v) throws Exception {
             setConfigBoolean("2pm", v);
         }
-        
+
         public boolean getPowerMgmtM3() throws Exception {
             return getConfigBoolean("3pm");
         }
-        
+
         public void setPowerMgmtM3(boolean v) throws Exception {
             setConfigBoolean("3pm", v);
         }
-        
+
         public boolean getPowerMgmtM4() throws Exception {
             return getConfigBoolean("4pm");
         }
-        
+
         public void setPowerMgmtM4(boolean v) throws Exception {
             setConfigBoolean("4pm", v);
         }
-        
-        
-        
+
+
+
         public int getVelMaxX() throws Exception {
             return getConfigInt("xvm");
         }
-        
+
         public void setVelMaxX(int v) throws Exception {
             setConfigInt("xvm", v);
         }
-        
+
         public int getVelMaxY() throws Exception {
             return getConfigInt("yvm");
         }
-        
+
         public void setVelMaxY(int v) throws Exception {
             setConfigInt("yvm", v);
         }
-        
 
-        
+
+
         public int getFeedMaxX() throws Exception {
             return getConfigInt("xfr");
         }
-        
+
         public void setFeedMaxX(int v) throws Exception {
             setConfigInt("xfr", v);
         }
-        
+
         public int getFeedMaxY() throws Exception {
             return getConfigInt("yfr");
         }
-        
+
         public void setFeedMaxY(int v) throws Exception {
             setConfigInt("yfr", v);
         }
-        
 
-        
+
+
         public int getJerkMaxX() throws Exception {
             return getConfigInt("xjm");
         }
-        
+
         public void setJerkMaxX(int v) throws Exception {
             setConfigInt("xjm", v);
         }
-        
+
         public int getJerkMaxY() throws Exception {
             return getConfigInt("yjm");
         }
-        
+
         public void setJerkMaxY(int v) throws Exception {
             setConfigInt("yjm", v);
         }
-        
-        
-        
-        
-        
+
+
+
         // TODO: Check for response errors in these methods.
         private int getConfigInt(String name) throws Exception {
-            JsonObject o = driver.sendCommand(String.format(Locale.US,"{\"%s\":\"\"}", name));
+            JsonObject o = driver.sendCommand(String.format(Locale.US, "{\"%s\":\"\"}", name));
             return o.get(name).getAsInt();
         }
-        
+
         private void setConfigInt(String name, int v) throws Exception {
-            JsonObject o = driver.sendCommand(String.format(Locale.US,"{\"%s\":%d}", name, v));
+            JsonObject o = driver.sendCommand(String.format(Locale.US, "{\"%s\":%d}", name, v));
         }
-        
+
         private double getConfigDouble(String name) throws Exception {
-            JsonObject o = driver.sendCommand(String.format(Locale.US,"{\"%s\":\"\"}", name));
+            JsonObject o = driver.sendCommand(String.format(Locale.US, "{\"%s\":\"\"}", name));
             return o.get(name).getAsDouble();
         }
-        
+
         private void setConfigDouble(String name, double v) throws Exception {
-            JsonObject o = driver.sendCommand(String.format(Locale.US,"{\"%s\":%f}", name, v));
+            JsonObject o = driver.sendCommand(String.format(Locale.US, "{\"%s\":%f}", name, v));
         }
-        
+
         private boolean getConfigBoolean(String name) throws Exception {
             return getConfigInt(name) == 1;
         }
-        
+
         private void setConfigBoolean(String name, boolean v) throws Exception {
             setConfigInt(name, v ? 1 : 0);
         }
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceDragFeeder.java b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceDragFeeder.java
index decc5c5329..e3d53b0ebc 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceDragFeeder.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceDragFeeder.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder;
@@ -55,29 +53,23 @@
 /**
  * Vision System Description
  * 
- * The Vision Operation is defined as moving the Camera to the defined Pick
- * Location, performing a template match against the Template Image bound by
- * the Area of Interest and then storing the offsets from the Pick Location to
- * the matched image as Vision Offsets.
+ * The Vision Operation is defined as moving the Camera to the defined Pick Location, performing a
+ * template match against the Template Image bound by the Area of Interest and then storing the
+ * offsets from the Pick Location to the matched image as Vision Offsets.
  * 
- * The feed operation consists of:
- * 1. Apply the Vision Offsets to the Feed Start Location
- * and Feed End Location.
- * 2. Feed the tape with the modified Locations.
- * 3. Perform the Vision Operation.
- * 4. Apply the new Vision Offsets to the Pick Location and return the Pick
- * Location for Picking.
+ * The feed operation consists of: 1. Apply the Vision Offsets to the Feed Start Location and Feed
+ * End Location. 2. Feed the tape with the modified Locations. 3. Perform the Vision Operation. 4.
+ * Apply the new Vision Offsets to the Pick Location and return the Pick Location for Picking.
  * 
- * This leaves the head directly above the Pick Location, which means that
- * when the Feeder is then commanded to pick the Part it only needs to move
- * the distance of the Vision Offsets and do the pick. The Vision Offsets are
- * then used in the next feed operation to be sure to hit the tape at the
- * right position.
+ * This leaves the head directly above the Pick Location, which means that when the Feeder is then
+ * commanded to pick the Part it only needs to move the distance of the Vision Offsets and do the
+ * pick. The Vision Offsets are then used in the next feed operation to be sure to hit the tape at
+ * the right position.
  */
 public class ReferenceDragFeeder extends ReferenceFeeder {
-	private final static Logger logger = LoggerFactory.getLogger(ReferenceDragFeeder.class);
-	
-	private final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceDragFeeder.class);
+
+    private final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
 
     @Element
     protected Location feedStartLocation = new Location(LengthUnit.Millimeters);
@@ -90,268 +82,257 @@
     @Element(required = false)
     protected Vision vision = new Vision();
 
-    protected Location pickLocation;	
-
-	/*
-	 * visionOffset contains the difference between where the part was
-	 * expected to be and where it is. Subtracting these offsets from 
-	 * the pickLocation produces the correct pick location. Likewise,
-	 * subtracting the offsets from the feedStart and feedEndLocations 
-	 * should produce the correct feed locations.
-	 */
-	protected Location visionOffset;
-	
-	@Override
+    protected Location pickLocation;
+
+    /*
+     * visionOffset contains the difference between where the part was expected to be and where it
+     * is. Subtracting these offsets from the pickLocation produces the correct pick location.
+     * Likewise, subtracting the offsets from the feedStart and feedEndLocations should produce the
+     * correct feed locations.
+     */
+    protected Location visionOffset;
+
+    @Override
     public Location getPickLocation() throws Exception {
-	    if (pickLocation == null) {
-	        pickLocation = location;
-	    }
-	    return pickLocation;
+        if (pickLocation == null) {
+            pickLocation = location;
+        }
+        return pickLocation;
     }
 
     @Override
-	public void feed(Nozzle nozzle)
-			throws Exception {
-		logger.debug("feed({})", nozzle);
-		
-		if (actuatorName == null) {
-			throw new Exception("No actuator name set.");
-		}
-		
-		
-		Head head = nozzle.getHead();
-		
-		/*
-		 * TODO: We can optimize the feed process:
-		 * If we are already higher than the Z we will move to to index plus
-		 * the height of the tape, we don't need to Safe Z first.
-		 * There is also probably no reason to Safe Z after extracting the
-		 * pin since if the tool was going to hit it would have already hit.
-		 */
-
-		Actuator actuator = head.getActuatorByName(actuatorName);
-		
-		if (actuator == null) {
-			throw new Exception(String.format("No Actuator found with name %s on feed Head %s", actuatorName, head.getName()));
-		}
-		
-		head.moveToSafeZ(1.0);
-		
-		if (vision.isEnabled()) {
-			if (visionOffset == null) {
-				// This is the first feed with vision, or the offset has
-				// been invalidated for some reason. We need to get an offset,
-				// complete the feed operation and then get a new offset
-				// for the next operation. By front loading this we make sure
-				// that all future calls can go directly to the feed operation
-				// and skip checking the vision first.
-				logger.debug("First feed, running vision pre-flight.");
-				
-				visionOffset = getVisionOffsets(head, location);
-			}
-			logger.debug("visionOffsets " + visionOffset);
-		}
-
-		// Now we have visionOffsets (if we're using them) so we
-		// need to create a local, offset version of the feedStartLocation,
-		// feedEndLocation and pickLocation. pickLocation will be saved
-		// for the pick operation while feed start and end are used
-		// here and then discarded.
-		Location feedStartLocation = this.feedStartLocation;
-		Location feedEndLocation = this.feedEndLocation;
-		pickLocation = this.location;
-		if (visionOffset != null) {
+    public void feed(Nozzle nozzle) throws Exception {
+        logger.debug("feed({})", nozzle);
+
+        if (actuatorName == null) {
+            throw new Exception("No actuator name set.");
+        }
+
+
+        Head head = nozzle.getHead();
+
+        /*
+         * TODO: We can optimize the feed process: If we are already higher than the Z we will move
+         * to to index plus the height of the tape, we don't need to Safe Z first. There is also
+         * probably no reason to Safe Z after extracting the pin since if the tool was going to hit
+         * it would have already hit.
+         */
+
+        Actuator actuator = head.getActuatorByName(actuatorName);
+
+        if (actuator == null) {
+            throw new Exception(String.format("No Actuator found with name %s on feed Head %s",
+                    actuatorName, head.getName()));
+        }
+
+        head.moveToSafeZ(1.0);
+
+        if (vision.isEnabled()) {
+            if (visionOffset == null) {
+                // This is the first feed with vision, or the offset has
+                // been invalidated for some reason. We need to get an offset,
+                // complete the feed operation and then get a new offset
+                // for the next operation. By front loading this we make sure
+                // that all future calls can go directly to the feed operation
+                // and skip checking the vision first.
+                logger.debug("First feed, running vision pre-flight.");
+
+                visionOffset = getVisionOffsets(head, location);
+            }
+            logger.debug("visionOffsets " + visionOffset);
+        }
+
+        // Now we have visionOffsets (if we're using them) so we
+        // need to create a local, offset version of the feedStartLocation,
+        // feedEndLocation and pickLocation. pickLocation will be saved
+        // for the pick operation while feed start and end are used
+        // here and then discarded.
+        Location feedStartLocation = this.feedStartLocation;
+        Location feedEndLocation = this.feedEndLocation;
+        pickLocation = this.location;
+        if (visionOffset != null) {
             feedStartLocation = feedStartLocation.subtract(visionOffset);
             feedEndLocation = feedEndLocation.subtract(visionOffset);
             pickLocation = pickLocation.subtract(visionOffset);
-		}
-		
-		// Move the actuator to the feed start location.
-		actuator.moveTo(feedStartLocation.derive(null, null, Double.NaN, Double.NaN), 1.0);
-
-		// extend the pin
-		actuator.actuate(true);
-
-		// insert the pin
-		actuator.moveTo(feedStartLocation, 1.0);
-
-		// drag the tape
-		actuator.moveTo(feedEndLocation, feedSpeed);
-
-		head.moveToSafeZ(1.0);
-
-		// retract the pin
-		actuator.actuate(false);
-		
-		if (vision.isEnabled()) {
-			visionOffset = getVisionOffsets(head, location);
-			
-			logger.debug("final visionOffsets " + visionOffset);
-		}
-		
+        }
+
+        // Move the actuator to the feed start location.
+        actuator.moveTo(feedStartLocation.derive(null, null, Double.NaN, Double.NaN), 1.0);
+
+        // extend the pin
+        actuator.actuate(true);
+
+        // insert the pin
+        actuator.moveTo(feedStartLocation, 1.0);
+
+        // drag the tape
+        actuator.moveTo(feedEndLocation, feedSpeed);
+
+        head.moveToSafeZ(1.0);
+
+        // retract the pin
+        actuator.actuate(false);
+
+        if (vision.isEnabled()) {
+            visionOffset = getVisionOffsets(head, location);
+
+            logger.debug("final visionOffsets " + visionOffset);
+        }
+
         logger.debug("Modified pickLocation {}", pickLocation);
-	}
-	
-	// TODO: Throw an Exception if vision fails.
-	private Location getVisionOffsets(Head head, Location pickLocation) throws Exception {
-	    logger.debug("getVisionOffsets({}, {})", head.getName(), pickLocation);
-		// Find the Camera to be used for vision
-		// TODO: Consider caching this
-		Camera camera = null;
-		for (Camera c : head.getCameras()) {
-			if (c.getVisionProvider() != null) {
-				camera = c;
-			}
-		}
-		
-		if (camera == null) {
-			throw new Exception("No vision capable camera found on head.");
-		}
-		
-		head.moveToSafeZ(1.0);
-		
-		// Position the camera over the pick location.
-		logger.debug("Move camera to pick location.");
-		camera.moveTo(pickLocation, 1.0);
-		
-		// Move the camera to be in focus over the pick location.
-//		head.moveTo(head.getX(), head.getY(), z, head.getC());
-		
-		// Settle the camera
-		Thread.sleep(camera.getSettleTimeMs());
-		
-		VisionProvider visionProvider = camera.getVisionProvider();
-		
-		Rectangle aoi = getVision().getAreaOfInterest();
-		
-		// Perform the template match
-		logger.debug("Perform template match.");
-		Point[] matchingPoints = visionProvider.locateTemplateMatches(
-				aoi.getX(), 
-				aoi.getY(), 
-				aoi.getWidth(), 
-				aoi.getHeight(), 
-				0, 
-				0, 
-				vision.getTemplateImage());
-		
-		// Get the best match from the array
-		Point match = matchingPoints[0];
-		
-		// match now contains the position, in pixels, from the top left corner
-		// of the image to the top left corner of the match. We are interested in
-		// knowing how far from the center of the image the center of the match is.
-		BufferedImage image = camera.capture();
-		double imageWidth = image.getWidth();
-		double imageHeight = image.getHeight();
-		double templateWidth = vision.getTemplateImage().getWidth();
-		double templateHeight = vision.getTemplateImage().getHeight();
-		double matchX = match.x;
-		double matchY = match.y;
+    }
+
+    // TODO: Throw an Exception if vision fails.
+    private Location getVisionOffsets(Head head, Location pickLocation) throws Exception {
+        logger.debug("getVisionOffsets({}, {})", head.getName(), pickLocation);
+        // Find the Camera to be used for vision
+        // TODO: Consider caching this
+        Camera camera = null;
+        for (Camera c : head.getCameras()) {
+            if (c.getVisionProvider() != null) {
+                camera = c;
+            }
+        }
+
+        if (camera == null) {
+            throw new Exception("No vision capable camera found on head.");
+        }
+
+        head.moveToSafeZ(1.0);
+
+        // Position the camera over the pick location.
+        logger.debug("Move camera to pick location.");
+        camera.moveTo(pickLocation, 1.0);
+
+        // Move the camera to be in focus over the pick location.
+        // head.moveTo(head.getX(), head.getY(), z, head.getC());
+
+        // Settle the camera
+        Thread.sleep(camera.getSettleTimeMs());
+
+        VisionProvider visionProvider = camera.getVisionProvider();
+
+        Rectangle aoi = getVision().getAreaOfInterest();
+
+        // Perform the template match
+        logger.debug("Perform template match.");
+        Point[] matchingPoints = visionProvider.locateTemplateMatches(aoi.getX(), aoi.getY(),
+                aoi.getWidth(), aoi.getHeight(), 0, 0, vision.getTemplateImage());
+
+        // Get the best match from the array
+        Point match = matchingPoints[0];
+
+        // match now contains the position, in pixels, from the top left corner
+        // of the image to the top left corner of the match. We are interested in
+        // knowing how far from the center of the image the center of the match is.
+        BufferedImage image = camera.capture();
+        double imageWidth = image.getWidth();
+        double imageHeight = image.getHeight();
+        double templateWidth = vision.getTemplateImage().getWidth();
+        double templateHeight = vision.getTemplateImage().getHeight();
+        double matchX = match.x;
+        double matchY = match.y;
 
         logger.debug("matchX {}, matchY {}", matchX, matchY);
 
-		// Adjust the match x and y to be at the center of the match instead of
-		// the top left corner.
-		matchX += (templateWidth / 2);
-		matchY += (templateHeight / 2);
-		
+        // Adjust the match x and y to be at the center of the match instead of
+        // the top left corner.
+        matchX += (templateWidth / 2);
+        matchY += (templateHeight / 2);
+
         logger.debug("centered matchX {}, matchY {}", matchX, matchY);
 
-		// Calculate the difference between the center of the image to the
-		// center of the match.
-		double offsetX = (imageWidth / 2) - matchX;
-		double offsetY = (imageHeight / 2) - matchY;
+        // Calculate the difference between the center of the image to the
+        // center of the match.
+        double offsetX = (imageWidth / 2) - matchX;
+        double offsetY = (imageHeight / 2) - matchY;
 
         logger.debug("offsetX {}, offsetY {}", offsetX, offsetY);
-		
-		// Invert the Y offset because images count top to bottom and the Y
-		// axis of the machine counts bottom to top.
-		offsetY *= -1;
-		
+
+        // Invert the Y offset because images count top to bottom and the Y
+        // axis of the machine counts bottom to top.
+        offsetY *= -1;
+
         logger.debug("negated offsetX {}, offsetY {}", offsetX, offsetY);
-		
-		// And convert pixels to units
-		Location unitsPerPixel = camera.getUnitsPerPixel();
-		offsetX *= unitsPerPixel.getX();
-		offsetY *= unitsPerPixel.getY();
+
+        // And convert pixels to units
+        Location unitsPerPixel = camera.getUnitsPerPixel();
+        offsetX *= unitsPerPixel.getX();
+        offsetY *= unitsPerPixel.getY();
 
         logger.debug("final, in camera units offsetX {}, offsetY {}", offsetX, offsetY);
-		
+
         return new Location(unitsPerPixel.getUnits(), offsetX, offsetY, 0, 0);
-	}
+    }
+
+    @Override
+    public String toString() {
+        return String.format("ReferenceTapeFeeder id %s", id);
+    }
 
-	@Override
-	public String toString() {
-		return String.format("ReferenceTapeFeeder id %s", id);
-	}
-    
     public Location getFeedStartLocation() {
-		return feedStartLocation;
-	}
-
-	public void setFeedStartLocation(Location feedStartLocation) {
-		this.feedStartLocation = feedStartLocation;
-	}
-
-	public Location getFeedEndLocation() {
-		return feedEndLocation;
-	}
-
-	public void setFeedEndLocation(Location feedEndLocation) {
-		this.feedEndLocation = feedEndLocation;
-	}
-
-	public Double getFeedSpeed() {
-		return feedSpeed;
-	}
-
-	public void setFeedSpeed(Double feedSpeed) {
-		this.feedSpeed = feedSpeed;
-	}
-	
-	public String getActuatorName() {
-		return actuatorName;
-	}
-
-	public void setActuatorName(String actuatorName) {
-		String oldValue = this.actuatorName;
-		this.actuatorName = actuatorName;
-		propertyChangeSupport.firePropertyChange("actuatorName", oldValue, actuatorName);
-	}
-
-	public Vision getVision() {
-		return vision;
-	}
-
-	public void setVision(Vision vision) {
-		this.vision = vision;
-	}
-	
-	public void addPropertyChangeListener(PropertyChangeListener listener) {
-		propertyChangeSupport.addPropertyChangeListener(listener);
-	}
-
-	public void addPropertyChangeListener(String propertyName,
-			PropertyChangeListener listener) {
-		propertyChangeSupport.addPropertyChangeListener(propertyName, listener);
-	}
-
-	public void removePropertyChangeListener(PropertyChangeListener listener) {
-		propertyChangeSupport.removePropertyChangeListener(listener);
-	}
-
-	public void removePropertyChangeListener(String propertyName,
-			PropertyChangeListener listener) {
-		propertyChangeSupport.removePropertyChangeListener(propertyName,
-				listener);
-	}
+        return feedStartLocation;
+    }
+
+    public void setFeedStartLocation(Location feedStartLocation) {
+        this.feedStartLocation = feedStartLocation;
+    }
+
+    public Location getFeedEndLocation() {
+        return feedEndLocation;
+    }
+
+    public void setFeedEndLocation(Location feedEndLocation) {
+        this.feedEndLocation = feedEndLocation;
+    }
+
+    public Double getFeedSpeed() {
+        return feedSpeed;
+    }
+
+    public void setFeedSpeed(Double feedSpeed) {
+        this.feedSpeed = feedSpeed;
+    }
+
+    public String getActuatorName() {
+        return actuatorName;
+    }
+
+    public void setActuatorName(String actuatorName) {
+        String oldValue = this.actuatorName;
+        this.actuatorName = actuatorName;
+        propertyChangeSupport.firePropertyChange("actuatorName", oldValue, actuatorName);
+    }
+
+    public Vision getVision() {
+        return vision;
+    }
+
+    public void setVision(Vision vision) {
+        this.vision = vision;
+    }
+
+    public void addPropertyChangeListener(PropertyChangeListener listener) {
+        propertyChangeSupport.addPropertyChangeListener(listener);
+    }
+
+    public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+        propertyChangeSupport.addPropertyChangeListener(propertyName, listener);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener listener) {
+        propertyChangeSupport.removePropertyChangeListener(listener);
+    }
+
+    public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+        propertyChangeSupport.removePropertyChangeListener(propertyName, listener);
+    }
 
     @Override
     public Wizard getConfigurationWizard() {
         return new ReferenceDragFeederConfigurationWizard(this);
     }
-    
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -365,11 +346,9 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
@@ -377,91 +356,91 @@ public String getPropertySheetHolderTitle() {
     }
 
     public static class Vision {
-		@Attribute(required=false)
-		private boolean enabled;
-		@Attribute(required=false)
-		private String templateImageName;
-		@Element(required=false)
-		private Rectangle areaOfInterest = new Rectangle();
-		@Element(required=false)
-		private Location templateImageTopLeft = new Location(LengthUnit.Millimeters);
-		@Element(required=false)
-		private Location templateImageBottomRight = new Location(LengthUnit.Millimeters);
-		
-		private BufferedImage templateImage;
-		private boolean templateImageDirty;
-		
-		public Vision() {
-	        Configuration.get().addListener(new ConfigurationListener.Adapter() {
-	            @Override
-	            public void configurationComplete(Configuration configuration)
-	                    throws Exception {
-	                if (templateImageName != null) {
-	                    File file = configuration.getResourceFile(Vision.this.getClass(), templateImageName);
-	                    templateImage = ImageIO.read(file);
-	                }
-	            }
-	        });
-		}
-		
-		@SuppressWarnings("unused")
-		@Persist
-		private void persist() throws IOException {
-			if (templateImageDirty) {
-				File file = null;
-				if (templateImageName != null) {
-					file = Configuration.get().getResourceFile(this.getClass(), templateImageName);
-				}
-				else {
-					file = Configuration.get().createResourceFile(this.getClass(), "tmpl_", ".png");
-					templateImageName = file.getName();
-				}
-				ImageIO.write(templateImage, "png", file);
-				templateImageDirty = false;
-			}
-		}
-		
-		public boolean isEnabled() {
-			return enabled;
-		}
-
-		public void setEnabled(boolean enabled) {
-			this.enabled = enabled;
-		}
-		
-		public BufferedImage getTemplateImage() {
-			return templateImage;
-		}
-		
-		public void setTemplateImage(BufferedImage templateImage) {
-			if (templateImage != this.templateImage) {
-				this.templateImage = templateImage;
-				templateImageDirty = true;
-			}
-		}
-		
-		public Rectangle getAreaOfInterest() {
-			return areaOfInterest;
-		}
-
-		public void setAreaOfInterest(Rectangle areaOfInterest) {
-			this.areaOfInterest = areaOfInterest;
-		}
-
-		public Location getTemplateImageTopLeft() {
-			return templateImageTopLeft;
-		}
-
-		public void setTemplateImageTopLeft(Location templateImageTopLeft) {
-			this.templateImageTopLeft = templateImageTopLeft;
-		}
-
-		public Location getTemplateImageBottomRight() {
-			return templateImageBottomRight;
-		}
-
-		public void setTemplateImageBottomRight(Location templateImageBottomRight) {
-			this.templateImageBottomRight = templateImageBottomRight;
-		}
-	}
+        @Attribute(required = false)
+        private boolean enabled;
+        @Attribute(required = false)
+        private String templateImageName;
+        @Element(required = false)
+        private Rectangle areaOfInterest = new Rectangle();
+        @Element(required = false)
+        private Location templateImageTopLeft = new Location(LengthUnit.Millimeters);
+        @Element(required = false)
+        private Location templateImageBottomRight = new Location(LengthUnit.Millimeters);
+
+        private BufferedImage templateImage;
+        private boolean templateImageDirty;
+
+        public Vision() {
+            Configuration.get().addListener(new ConfigurationListener.Adapter() {
+                @Override
+                public void configurationComplete(Configuration configuration) throws Exception {
+                    if (templateImageName != null) {
+                        File file = configuration.getResourceFile(Vision.this.getClass(),
+                                templateImageName);
+                        templateImage = ImageIO.read(file);
+                    }
+                }
+            });
+        }
+
+        @SuppressWarnings("unused")
+        @Persist
+        private void persist() throws IOException {
+            if (templateImageDirty) {
+                File file = null;
+                if (templateImageName != null) {
+                    file = Configuration.get().getResourceFile(this.getClass(), templateImageName);
+                }
+                else {
+                    file = Configuration.get().createResourceFile(this.getClass(), "tmpl_", ".png");
+                    templateImageName = file.getName();
+                }
+                ImageIO.write(templateImage, "png", file);
+                templateImageDirty = false;
+            }
+        }
+
+        public boolean isEnabled() {
+            return enabled;
+        }
+
+        public void setEnabled(boolean enabled) {
+            this.enabled = enabled;
+        }
+
+        public BufferedImage getTemplateImage() {
+            return templateImage;
+        }
+
+        public void setTemplateImage(BufferedImage templateImage) {
+            if (templateImage != this.templateImage) {
+                this.templateImage = templateImage;
+                templateImageDirty = true;
+            }
+        }
+
+        public Rectangle getAreaOfInterest() {
+            return areaOfInterest;
+        }
+
+        public void setAreaOfInterest(Rectangle areaOfInterest) {
+            this.areaOfInterest = areaOfInterest;
+        }
+
+        public Location getTemplateImageTopLeft() {
+            return templateImageTopLeft;
+        }
+
+        public void setTemplateImageTopLeft(Location templateImageTopLeft) {
+            this.templateImageTopLeft = templateImageTopLeft;
+        }
+
+        public Location getTemplateImageBottomRight() {
+            return templateImageBottomRight;
+        }
+
+        public void setTemplateImageBottomRight(Location templateImageBottomRight) {
+            this.templateImageBottomRight = templateImageBottomRight;
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceStripFeeder.java b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceStripFeeder.java
index b59efe38bf..31c52b6d93 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceStripFeeder.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceStripFeeder.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder;
@@ -49,109 +47,101 @@
 
 
 /**
- * Implementation of Feeder that indexes through a strip of cut tape.
- * This is a specialization of the tray feeder that knows specifics
- * about tape so that vision capabilities can be added.
+ * Implementation of Feeder that indexes through a strip of cut tape. This is a specialization of
+ * the tray feeder that knows specifics about tape so that vision capabilities can be added.
  */
 
 /**
- * SMD tape standard info from http://www.liteplacer.com/setup-tape-positions-2/
- * holes 1.5mm
- * hole pitch 4mm
- * first part center to reference hole linear is 2mm
- * tape width is multiple of 4mm
- * part pitch is multiple of 4mm except for 0402 and smaller, where it is 2mm 
- * hole to part lateral is tape width / 2 - 0.5mm 
+ * SMD tape standard info from http://www.liteplacer.com/setup-tape-positions-2/ holes 1.5mm hole
+ * pitch 4mm first part center to reference hole linear is 2mm tape width is multiple of 4mm part
+ * pitch is multiple of 4mm except for 0402 and smaller, where it is 2mm hole to part lateral is
+ * tape width / 2 - 0.5mm
  */
 public class ReferenceStripFeeder extends ReferenceFeeder {
-	private final static Logger logger = LoggerFactory.getLogger(ReferenceStripFeeder.class);
-	
-	public enum TapeType {
-	    WhitePaper("White Paper"),
-	    BlackPlastic("Black Plastic"),
-	    ClearPlastic("Clear Plastic");
-	    
-	    private String name;
-	    
-	    TapeType(String name) {
-	        this.name = name;
-	    }
-	    
-	    public String toString() {
-	        return name;
-	    }
-	}
-	
-	@Element(required=false)
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceStripFeeder.class);
+
+    public enum TapeType {
+        WhitePaper("White Paper"), BlackPlastic("Black Plastic"), ClearPlastic("Clear Plastic");
+
+        private String name;
+
+        TapeType(String name) {
+            this.name = name;
+        }
+
+        public String toString() {
+            return name;
+        }
+    }
+
+    @Element(required = false)
     private Location referenceHoleLocation = new Location(LengthUnit.Millimeters);
 
-    @Element(required=false)
+    @Element(required = false)
     private Location lastHoleLocation = new Location(LengthUnit.Millimeters);
 
-    @Element(required=false)
+    @Element(required = false)
     private Length partPitch = new Length(4, LengthUnit.Millimeters);
-    
-    @Element(required=false)
+
+    @Element(required = false)
     private Length tapeWidth = new Length(8, LengthUnit.Millimeters);
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private TapeType tapeType = TapeType.WhitePaper;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private boolean visionEnabled = true;
 
     @Attribute
-	private int feedCount = 0;
-    
+    private int feedCount = 0;
+
     private Length holeDiameter = new Length(1.5, LengthUnit.Millimeters);
-    
+
     private Length holePitch = new Length(4, LengthUnit.Millimeters);
-    
+
     private Length referenceHoleToPartLinear = new Length(2, LengthUnit.Millimeters);
-    
+
     private Location visionOffsets;
     private Location visionLocation;
-    
-	public Length getHoleDiameterMin() {
-	    return getHoleDiameter().multiply(0.9);
-	}
 
-	public Length getHoleDiameterMax() {
-	    return getHoleDiameter().multiply(1.1);
-	}
+    public Length getHoleDiameterMin() {
+        return getHoleDiameter().multiply(0.9);
+    }
 
-	public Length getHolePitchMin() {
-		return getHolePitch().multiply(0.9);
-	}
+    public Length getHoleDiameterMax() {
+        return getHoleDiameter().multiply(1.1);
+    }
 
-	public Length getHoleDistanceMin() {
-		return getTapeWidth().multiply(0.25);
-	}
+    public Length getHolePitchMin() {
+        return getHolePitch().multiply(0.9);
+    }
 
-	public Length getHoleDistanceMax() {
-	    return getTapeWidth().multiply(1.5);
-	}
+    public Length getHoleDistanceMin() {
+        return getTapeWidth().multiply(0.25);
+    }
 
-	public Length getHoleLineDistanceMax() {
-	    return new Length(0.5, LengthUnit.Millimeters);
-	}
+    public Length getHoleDistanceMax() {
+        return getTapeWidth().multiply(1.5);
+    }
+
+    public Length getHoleLineDistanceMax() {
+        return new Length(0.5, LengthUnit.Millimeters);
+    }
 
     public int getHoleBlurKernelSize() {
-		return 9;
-	}
+        return 9;
+    }
 
-	@Override
+    @Override
     public Location getPickLocation() throws Exception {
-	    // Find the location of the part linearly along the tape
-		Location[] lineLocations = getIdealLineLocations();
-	    Location l = getPointAlongLine(
-	    		lineLocations[0], 
-	    		lineLocations[1], 
+        // Find the location of the part linearly along the tape
+        Location[] lineLocations = getIdealLineLocations();
+        Location l = getPointAlongLine(lineLocations[0], lineLocations[1],
                 new Length((feedCount - 1) * partPitch.getValue(), partPitch.getUnits()));
-	    // Create the offsets that are required to go from a reference hole
-	    // to the part in the tape
-	    Length x = getHoleToPartLateral().convertToUnits(l.getUnits());
-	    Length y = referenceHoleToPartLinear.convertToUnits(l.getUnits());
+        // Create the offsets that are required to go from a reference hole
+        // to the part in the tape
+        Length x = getHoleToPartLateral().convertToUnits(l.getUnits());
+        Length y = referenceHoleToPartLinear.convertToUnits(l.getUnits());
         Point p = new Point(x.getValue(), y.getValue());
         // Determine the angle that the tape is at
         double angle = getAngleFromPoint(lineLocations[0], lineLocations[1]);
@@ -165,102 +155,92 @@ public Location getPickLocation() throws Exception {
         l = l.derive(null, null, null, angle + getLocation().getRotation());
         // and if vision was performed, add the offsets
         if (visionEnabled && visionOffsets != null) {
-        	l = l.add(visionOffsets);
+            l = l.add(visionOffsets);
         }
         return l;
     }
-	
-	public Location[] getIdealLineLocations() {
-		if (visionLocation == null) {
-			return new Location[] { referenceHoleLocation, lastHoleLocation };
-		}
-		double d1 = referenceHoleLocation.getLinearLengthTo(lastHoleLocation).convertToUnits(LengthUnit.Millimeters).getValue();
-		double d2 = referenceHoleLocation.getLinearLengthTo(visionLocation).convertToUnits(LengthUnit.Millimeters).getValue();
-		if (d2 > d1) {
-			return new Location[] { referenceHoleLocation, visionLocation };
-		}
-		else {
-			return new Location[] { referenceHoleLocation, lastHoleLocation };
-		}
-	}
-	
-    public void feed(Nozzle nozzle)
-			throws Exception {
+
+    public Location[] getIdealLineLocations() {
+        if (visionLocation == null) {
+            return new Location[] {referenceHoleLocation, lastHoleLocation};
+        }
+        double d1 = referenceHoleLocation.getLinearLengthTo(lastHoleLocation)
+                .convertToUnits(LengthUnit.Millimeters).getValue();
+        double d2 = referenceHoleLocation.getLinearLengthTo(visionLocation)
+                .convertToUnits(LengthUnit.Millimeters).getValue();
+        if (d2 > d1) {
+            return new Location[] {referenceHoleLocation, visionLocation};
+        }
+        else {
+            return new Location[] {referenceHoleLocation, lastHoleLocation};
+        }
+    }
+
+    public void feed(Nozzle nozzle) throws Exception {
         setFeedCount(getFeedCount() + 1);
-        
+
         updateVisionOffsets(nozzle);
-	}
-    
+    }
+
     private void updateVisionOffsets(Nozzle nozzle) throws Exception {
-    	if (!visionEnabled) {
-    		return;
-    	}
+        if (!visionEnabled) {
+            return;
+        }
         // go to where we expect to find the next reference hole
         Camera camera = nozzle.getHead().getDefaultCamera();
-	    Location expectedLocation = null;
-	    Location[] lineLocations = getIdealLineLocations();
-	    
-	    if (partPitch.convertToUnits(LengthUnit.Millimeters).getValue() < 4) {
-	    	// For tapes with a part pitch < 4 we need to check each hole
-	    	// twice since there are two parts per reference hole.
-	    	// Note the use of holePitch here and partPitch in the
-	    	// alternate case below.
-	    	expectedLocation = getPointAlongLine(
-                    lineLocations[0], 
-                    lineLocations[1], 
+        Location expectedLocation = null;
+        Location[] lineLocations = getIdealLineLocations();
+
+        if (partPitch.convertToUnits(LengthUnit.Millimeters).getValue() < 4) {
+            // For tapes with a part pitch < 4 we need to check each hole
+            // twice since there are two parts per reference hole.
+            // Note the use of holePitch here and partPitch in the
+            // alternate case below.
+            expectedLocation = getPointAlongLine(lineLocations[0], lineLocations[1],
                     holePitch.multiply((feedCount - 1) / 2));
-	    }
-	    else {
-	    	// For tapes with a part pitch >= 4 there is always a reference
-	    	// hole 2mm from a part so we just multiply by the part pitch
-	    	// skipping over holes that are not reference holes.
-	    	expectedLocation = getPointAlongLine(
-	    			lineLocations[0], 
-	    			lineLocations[1], 
+        }
+        else {
+            // For tapes with a part pitch >= 4 there is always a reference
+            // hole 2mm from a part so we just multiply by the part pitch
+            // skipping over holes that are not reference holes.
+            expectedLocation = getPointAlongLine(lineLocations[0], lineLocations[1],
                     partPitch.multiply(feedCount - 1));
-	    }
-	    MovableUtils.moveToLocationAtSafeZ(camera, expectedLocation, 1.0);
-	    // and look for the hole
-	    Location actualLocation = findClosestHole(camera);
-	    if (actualLocation == null) {
-	    	throw new Exception("Feeder " + getName() + ": Unable to locate reference hole. End of strip?");
-	    }
-	    // make sure it's not too far away
-	    Length distance = actualLocation
-	    		.getLinearLengthTo(expectedLocation)
-	    		.convertToUnits(LengthUnit.Millimeters);
-	    if (distance.getValue() > 2) {
-	    	throw new Exception("Feeder " + getName() + ": Unable to locate reference hole. End of strip?");
-	    }
-	    visionOffsets = actualLocation
-	    		.subtract(expectedLocation)
-	    		.derive(null, null, 0d, 0d);
-	    visionLocation = actualLocation;
-    }
-    
+        }
+        MovableUtils.moveToLocationAtSafeZ(camera, expectedLocation, 1.0);
+        // and look for the hole
+        Location actualLocation = findClosestHole(camera);
+        if (actualLocation == null) {
+            throw new Exception(
+                    "Feeder " + getName() + ": Unable to locate reference hole. End of strip?");
+        }
+        // make sure it's not too far away
+        Length distance = actualLocation.getLinearLengthTo(expectedLocation)
+                .convertToUnits(LengthUnit.Millimeters);
+        if (distance.getValue() > 2) {
+            throw new Exception(
+                    "Feeder " + getName() + ": Unable to locate reference hole. End of strip?");
+        }
+        visionOffsets = actualLocation.subtract(expectedLocation).derive(null, null, 0d, 0d);
+        visionLocation = actualLocation;
+    }
+
     private Location findClosestHole(Camera camera) {
-	    List<Location> holeLocations = new ArrayList<>();
-	    new FluentCv()
-	    	.setCamera(camera)
-	    	.settleAndCapture()
-	    	.toGray()
-	    	.blurGaussian(getHoleBlurKernelSize())
-	    	.findCirclesHough(
-	    			getHoleDiameterMin(),
-	    			getHoleDiameterMax(), 
-	    			getHolePitchMin())
-	    	.convertCirclesToLocations(holeLocations);
-	    if (holeLocations.isEmpty()) {
-	    	return null;
-	    }
-	    return holeLocations.get(0);
-    }
-    
+        List<Location> holeLocations = new ArrayList<>();
+        new FluentCv().setCamera(camera).settleAndCapture().toGray()
+                .blurGaussian(getHoleBlurKernelSize())
+                .findCirclesHough(getHoleDiameterMin(), getHoleDiameterMax(), getHolePitchMin())
+                .convertCirclesToLocations(holeLocations);
+        if (holeLocations.isEmpty()) {
+            return null;
+        }
+        return holeLocations.get(0);
+    }
+
     private Length getHoleToPartLateral() {
         Length tapeWidth = this.tapeWidth.convertToUnits(LengthUnit.Millimeters);
         return new Length(tapeWidth.getValue() / 2 - 0.5, LengthUnit.Millimeters);
     }
-	
+
     static public Location getPointAlongLine(Location a, Location b, Length distance) {
         Point vab = b.subtract(a).getXyPoint();
         double lab = a.getLinearDistanceTo(b);
@@ -268,11 +248,10 @@ static public Location getPointAlongLine(Location a, Location b, Length distance
         vu = new Point(vu.x * distance.getValue(), vu.y * distance.getValue());
         return a.add(new Location(a.getUnits(), vu.x, vu.y, 0, 0));
     }
-  
+
     // Stolen from StackOverflow
-    static public double getAngleFromPoint(Location firstPoint,
-            Location secondPoint) {
-    	double angle = 0.0;
+    static public double getAngleFromPoint(Location firstPoint, Location secondPoint) {
+        double angle = 0.0;
         // above 0 to 180 degrees
         if ((secondPoint.getX() > firstPoint.getX())) {
             angle = (Math.atan2((secondPoint.getX() - firstPoint.getX()),
@@ -285,8 +264,8 @@ else if ((secondPoint.getX() <= firstPoint.getX())) {
         }
         return angle;
     }
-	
-	public TapeType getTapeType() {
+
+    public TapeType getTapeType() {
         return tapeType;
     }
 
@@ -354,7 +333,7 @@ public void setFeedCount(int feedCount) {
         this.visionOffsets = null;
         firePropertyChange("feedCount", oldValue, feedCount);
     }
-    
+
     public Length getReferenceHoleToPartLinear() {
         return referenceHoleToPartLinear;
     }
@@ -362,25 +341,25 @@ public Length getReferenceHoleToPartLinear() {
     public void setReferenceHoleToPartLinear(Length referenceHoleToPartLinear) {
         this.referenceHoleToPartLinear = referenceHoleToPartLinear;
     }
-    
+
     public boolean isVisionEnabled() {
-		return visionEnabled;
-	}
+        return visionEnabled;
+    }
 
-	public void setVisionEnabled(boolean visionEnabled) {
-		this.visionEnabled = visionEnabled;
-	}
+    public void setVisionEnabled(boolean visionEnabled) {
+        this.visionEnabled = visionEnabled;
+    }
 
-	@Override
-	public String toString() {
-		return getName();
-	}
+    @Override
+    public String toString() {
+        return getName();
+    }
 
     @Override
     public Wizard getConfigurationWizard() {
         return new ReferenceStripFeederConfigurationWizard(this);
     }
-    
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -394,31 +373,29 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
-    }  
+    }
 }
 
-// this code left here in case we want to use it in the future. it is for 
+// this code left here in case we want to use it in the future. it is for
 // calculating how many parts there are based on the first and last reference hole.
 //// figure out how many parts there should be by taking the delta
 //// between the two holes and dividing it by part pitch
-//double holeToHoleDistance = lastHoleLocation.getLinearDistanceTo(referenceHoleLocation);
+// double holeToHoleDistance = lastHoleLocation.getLinearDistanceTo(referenceHoleLocation);
 //// take the ceil of the distance to account for any minor offset from
 //// center of the hole
-//holeToHoleDistance = Math.ceil(holeToHoleDistance);
-//double partPitch = this.partPitch.convertToUnits(lastHoleLocation.getUnits()).getValue();
+// holeToHoleDistance = Math.ceil(holeToHoleDistance);
+// double partPitch = this.partPitch.convertToUnits(lastHoleLocation.getUnits()).getValue();
 //// And floor the part count because you can't have a partial part.
-//double partCount = Math.floor(holeToHoleDistance / partPitch);
+// double partCount = Math.floor(holeToHoleDistance / partPitch);
 //
-////if (feedCount > partCount) {
-////    throw new Exception(String.format("No more parts available in feeder %s", getName()));
-////}
+//// if (feedCount > partCount) {
+//// throw new Exception(String.format("No more parts available in feeder %s", getName()));
+//// }
 //
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTrayFeeder.java b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTrayFeeder.java
index d515b8e2ce..8dfb2aa572 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTrayFeeder.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTrayFeeder.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder;
@@ -40,42 +38,40 @@
 
 
 /**
- * Implementation of Feeder that indexes based on an offset. This allows a tray of
- * parts to be picked from without moving any tape. Can handle trays of
- * arbitrary X and Y count.
+ * Implementation of Feeder that indexes based on an offset. This allows a tray of parts to be
+ * picked from without moving any tape. Can handle trays of arbitrary X and Y count.
  */
 public class ReferenceTrayFeeder extends ReferenceFeeder {
-	private final static Logger logger = LoggerFactory.getLogger(ReferenceTrayFeeder.class);
-	
-	@Attribute
-	private int trayCountX = 1;
-	@Attribute
-	private int trayCountY = 1;
-	@Element
-	private Location offsets = new Location(LengthUnit.Millimeters);
-	@Attribute
-	private int feedCount = 0;
-	
-	private Location pickLocation;
-
-	@Override
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceTrayFeeder.class);
+
+    @Attribute
+    private int trayCountX = 1;
+    @Attribute
+    private int trayCountY = 1;
+    @Element
+    private Location offsets = new Location(LengthUnit.Millimeters);
+    @Attribute
+    private int feedCount = 0;
+
+    private Location pickLocation;
+
+    @Override
     public Location getPickLocation() throws Exception {
-	    if (pickLocation == null) {
-	        pickLocation = location;
-	    }
-		logger.debug("{}.getPickLocation => {}", getName(), pickLocation);
-		return pickLocation;
-    }
-
-    public void feed(Nozzle nozzle)
-			throws Exception {
-		logger.debug("{}.feed({})", getName(), nozzle);
-		int partX, partY;
-		
-		if (feedCount >= (trayCountX * trayCountY)) {
-		    throw new Exception(String.format("Tray empty on feeder %s.", getName()));
-		}
-        
+        if (pickLocation == null) {
+            pickLocation = location;
+        }
+        logger.debug("{}.getPickLocation => {}", getName(), pickLocation);
+        return pickLocation;
+    }
+
+    public void feed(Nozzle nozzle) throws Exception {
+        logger.debug("{}.feed({})", getName(), nozzle);
+        int partX, partY;
+
+        if (feedCount >= (trayCountX * trayCountY)) {
+            throw new Exception(String.format("Tray empty on feeder %s.", getName()));
+        }
+
         if (trayCountX >= trayCountY) {
             // X major axis.
             partX = feedCount / trayCountY;
@@ -86,62 +82,61 @@ public void feed(Nozzle nozzle)
             partX = feedCount % trayCountX;
             partY = feedCount / trayCountX;
         }
-        
+
         // Multiply the offsets by the X/Y part indexes to get the total offsets
         // and then add the pickLocation to offset the final value.
         // and then add them to the location to get the final pickLocation.
-        pickLocation = location.add(
-                offsets.multiply(partX, partY, 0.0, 0.0));
+        pickLocation = location.add(offsets.multiply(partX, partY, 0.0, 0.0));
+
+        logger.debug(String.format("Feeding part # %d, x %d, y %d, xPos %f, yPos %f, rPos %f",
+                feedCount, partX, partY, pickLocation.getX(), pickLocation.getY(),
+                pickLocation.getRotation()));
 
-        logger.debug(String.format(
-                "Feeding part # %d, x %d, y %d, xPos %f, yPos %f, rPos %f", feedCount,
-                partX, partY, pickLocation.getX(), pickLocation.getY(), pickLocation.getRotation()));
-        
         feedCount++;
-	}
+    }
 
-	public int getTrayCountX() {
-		return trayCountX;
-	}
+    public int getTrayCountX() {
+        return trayCountX;
+    }
 
-	public void setTrayCountX(int trayCountX) {
-		this.trayCountX = trayCountX;
-	}
+    public void setTrayCountX(int trayCountX) {
+        this.trayCountX = trayCountX;
+    }
 
-	public int getTrayCountY() {
-		return trayCountY;
-	}
+    public int getTrayCountY() {
+        return trayCountY;
+    }
 
-	public void setTrayCountY(int trayCountY) {
-		this.trayCountY = trayCountY;
-	}
+    public void setTrayCountY(int trayCountY) {
+        this.trayCountY = trayCountY;
+    }
 
-	public Location getOffsets() {
-		return offsets;
-	}
+    public Location getOffsets() {
+        return offsets;
+    }
 
-	public void setOffsets(Location offsets) {
-		this.offsets = offsets;
-	}
+    public void setOffsets(Location offsets) {
+        this.offsets = offsets;
+    }
 
-	public int getFeedCount() {
-		return feedCount;
-	}
+    public int getFeedCount() {
+        return feedCount;
+    }
 
-	public void setFeedCount(int feedCount) {
-		this.feedCount = feedCount;
-	}
+    public void setFeedCount(int feedCount) {
+        this.feedCount = feedCount;
+    }
 
-	@Override
-	public String toString() {
-		return getName();
-	}
+    @Override
+    public String toString() {
+        return getName();
+    }
 
     @Override
     public Wizard getConfigurationWizard() {
         return new ReferenceTrayFeederConfigurationWizard(this);
     }
-    
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -155,14 +150,12 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
 
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
-    }  
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTubeFeeder.java b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTubeFeeder.java
index d3cc15b7c1..aeed6bd96a 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTubeFeeder.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/ReferenceTubeFeeder.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder;
@@ -34,26 +32,25 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Implementation of Feeder that always picks from the same location. This
- * can be used with a gravity feed or vibratory tube feeder.
+ * Implementation of Feeder that always picks from the same location. This can be used with a
+ * gravity feed or vibratory tube feeder.
  */
 public class ReferenceTubeFeeder extends ReferenceFeeder {
-	private final static Logger logger = LoggerFactory.getLogger(ReferenceTubeFeeder.class);
-	
-	@Override
+    private final static Logger logger = LoggerFactory.getLogger(ReferenceTubeFeeder.class);
+
+    @Override
     public Location getPickLocation() throws Exception {
-	    return location;
+        return location;
     }
 
     @Override
-    public void feed(Nozzle nozzle) throws Exception {
+    public void feed(Nozzle nozzle) throws Exception {}
+
+    @Override
+    public Wizard getConfigurationWizard() {
+        return new ReferenceTubeFeederConfigurationWizard(this);
     }
 
-	@Override
-	public Wizard getConfigurationWizard() {
-		return new ReferenceTubeFeederConfigurationWizard(this);
-	}
-    
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName() + " " + getName();
@@ -67,14 +64,12 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
-    }      
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/wizards/AbstractReferenceFeederConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/feeder/wizards/AbstractReferenceFeederConfigurationWizard.java
index 3a9bd758e1..00143ab4df 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/wizards/AbstractReferenceFeederConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/wizards/AbstractReferenceFeederConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder.wizards;
@@ -52,8 +50,8 @@
 /**
  * TODO: This should become it's own property sheet which the feeders can include.
  */
-public abstract class AbstractReferenceFeederConfigurationWizard extends
-        AbstractConfigurationWizard {
+public abstract class AbstractReferenceFeederConfigurationWizard
+        extends AbstractConfigurationWizard {
     private final ReferenceFeeder feeder;
     private final boolean includePickLocation;
 
@@ -81,17 +79,13 @@ public AbstractReferenceFeederConfigurationWizard(ReferenceFeeder feeder,
         this.includePickLocation = includePickLocation;
 
         panelPart = new JPanel();
-        panelPart.setBorder(new TitledBorder(null, "Part",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelPart.setBorder(
+                new TitledBorder(null, "Part", TitledBorder.LEADING, TitledBorder.TOP, null, null));
         contentPanel.add(panelPart);
-        panelPart
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"), }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+        panelPart.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         comboBoxPart = new JComboBox();
         try {
@@ -106,26 +100,24 @@ public AbstractReferenceFeederConfigurationWizard(ReferenceFeeder feeder,
 
         if (includePickLocation) {
             panelLocation = new JPanel();
-            panelLocation.setBorder(new TitledBorder(new EtchedBorder(
-                    EtchedBorder.LOWERED, null, null), "Pick Location",
-                    TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0,
-                            0, 0)));
+            panelLocation.setBorder(new TitledBorder(
+                    new EtchedBorder(EtchedBorder.LOWERED, null, null), "Pick Location",
+                    TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
             contentPanel.add(panelLocation);
-            panelLocation.setLayout(new FormLayout(new ColumnSpec[] {
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("default:grow"),
-                    FormSpecs.RELATED_GAP_COLSPEC,
-                    ColumnSpec.decode("left:default:grow"), }, new RowSpec[] {
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC,
-                    FormSpecs.RELATED_GAP_ROWSPEC,
-                    FormSpecs.DEFAULT_ROWSPEC, }));
+            panelLocation
+                    .setLayout(new FormLayout(
+                            new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                                    ColumnSpec.decode("default:grow"),
+                                    FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec
+                                            .decode("default:grow"),
+                                    FormSpecs.RELATED_GAP_COLSPEC,
+                                    ColumnSpec.decode("default:grow"),
+                                    FormSpecs.RELATED_GAP_COLSPEC,
+                                    ColumnSpec.decode("default:grow"),
+                                    FormSpecs.RELATED_GAP_COLSPEC,
+                                    ColumnSpec.decode("left:default:grow"),},
+                            new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                    FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
             lblX_1 = new JLabel("X");
             panelLocation.add(lblX_1, "2, 2");
@@ -155,8 +147,8 @@ public AbstractReferenceFeederConfigurationWizard(ReferenceFeeder feeder,
             panelLocation.add(textFieldLocationC, "8, 4");
             textFieldLocationC.setColumns(8);
 
-            locationButtonsPanel = new LocationButtonsPanel(textFieldLocationX,
-                    textFieldLocationY, textFieldLocationZ, textFieldLocationC);
+            locationButtonsPanel = new LocationButtonsPanel(textFieldLocationX, textFieldLocationY,
+                    textFieldLocationZ, textFieldLocationC);
             panelLocation.add(locationButtonsPanel, "10, 4");
         }
     }
@@ -164,30 +156,22 @@ public AbstractReferenceFeederConfigurationWizard(ReferenceFeeder feeder,
     @Override
     public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
-        DoubleConverter doubleConverter = new DoubleConverter(Configuration
-                .get().getLengthDisplayFormat());
+        DoubleConverter doubleConverter =
+                new DoubleConverter(Configuration.get().getLengthDisplayFormat());
 
         addWrappedBinding(feeder, "part", comboBoxPart, "selectedItem");
 
         if (includePickLocation) {
             MutableLocationProxy location = new MutableLocationProxy();
-            bind(UpdateStrategy.READ_WRITE, feeder, "location", location,
-                    "location");
-            addWrappedBinding(location, "lengthX", textFieldLocationX, "text",
-                    lengthConverter);
-            addWrappedBinding(location, "lengthY", textFieldLocationY, "text",
-                    lengthConverter);
-            addWrappedBinding(location, "lengthZ", textFieldLocationZ, "text",
-                    lengthConverter);
-            addWrappedBinding(location, "rotation", textFieldLocationC, "text",
-                    doubleConverter);
-            ComponentDecorators
-                    .decorateWithAutoSelectAndLengthConversion(textFieldLocationX);
-            ComponentDecorators
-                    .decorateWithAutoSelectAndLengthConversion(textFieldLocationY);
-            ComponentDecorators
-                    .decorateWithAutoSelectAndLengthConversion(textFieldLocationZ);
+            bind(UpdateStrategy.READ_WRITE, feeder, "location", location, "location");
+            addWrappedBinding(location, "lengthX", textFieldLocationX, "text", lengthConverter);
+            addWrappedBinding(location, "lengthY", textFieldLocationY, "text", lengthConverter);
+            addWrappedBinding(location, "lengthZ", textFieldLocationZ, "text", lengthConverter);
+            addWrappedBinding(location, "rotation", textFieldLocationC, "text", doubleConverter);
+            ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationX);
+            ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationY);
+            ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationZ);
             ComponentDecorators.decorateWithAutoSelect(textFieldLocationC);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceDragFeederConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceDragFeederConfigurationWizard.java
index 343a1dca78..69a31acde5 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceDragFeederConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceDragFeederConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder.wizards;
@@ -69,8 +67,8 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 @SuppressWarnings("serial")
-public class ReferenceDragFeederConfigurationWizard extends
-        AbstractReferenceFeederConfigurationWizard {
+public class ReferenceDragFeederConfigurationWizard
+        extends AbstractReferenceFeederConfigurationWizard {
     private final ReferenceDragFeeder feeder;
 
     private JTextField textFieldFeedStartX;
@@ -116,19 +114,15 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
         panelFields.setLayout(new BoxLayout(panelFields, BoxLayout.Y_AXIS));
 
         panelGeneral = new JPanel();
-        panelGeneral.setBorder(new TitledBorder(null, "General Settings",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelGeneral.setBorder(new TitledBorder(null, "General Settings", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
 
         panelFields.add(panelGeneral);
         panelGeneral.setLayout(new FormLayout(
-                new ColumnSpec[] { FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblFeedRate = new JLabel("Feed Speed (0 - 1)");
         panelGeneral.add(lblFeedRate, "2, 2");
@@ -146,28 +140,18 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
 
         panelLocations = new JPanel();
         panelFields.add(panelLocations);
-        panelLocations.setBorder(new TitledBorder(null, "Locations",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
-        panelLocations
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("left:default:grow"), },
-                        new RowSpec[] { FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC,
-                                FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC,
-                                FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC,
-                                FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC, }));
+        panelLocations.setBorder(new TitledBorder(null, "Locations", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelLocations.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("left:default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblX = new JLabel("X");
         panelLocations.add(lblX, "4, 4");
@@ -193,9 +177,8 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
         panelLocations.add(textFieldFeedStartZ, "8, 6");
         textFieldFeedStartZ.setColumns(8);
 
-        locationButtonsPanelFeedStart = new LocationButtonsPanel(
-                textFieldFeedStartX, textFieldFeedStartY, textFieldFeedStartZ,
-                null);
+        locationButtonsPanelFeedStart = new LocationButtonsPanel(textFieldFeedStartX,
+                textFieldFeedStartY, textFieldFeedStartZ, null);
         panelLocations.add(locationButtonsPanelFeedStart, "10, 6");
 
         JLabel lblFeedEndLocation = new JLabel("Feed End Location");
@@ -213,19 +196,18 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
         panelLocations.add(textFieldFeedEndZ, "8, 8");
         textFieldFeedEndZ.setColumns(8);
 
-        locationButtonsPanelFeedEnd = new LocationButtonsPanel(
-                textFieldFeedEndX, textFieldFeedEndY, textFieldFeedEndZ, null);
+        locationButtonsPanelFeedEnd = new LocationButtonsPanel(textFieldFeedEndX, textFieldFeedEndY,
+                textFieldFeedEndZ, null);
         panelLocations.add(locationButtonsPanelFeedEnd, "10, 8");
-//
+        //
         panelVision = new JPanel();
-        panelVision.setBorder(new TitledBorder(null, "Vision",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelVision.setBorder(new TitledBorder(null, "Vision", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         panelFields.add(panelVision);
         panelVision.setLayout(new BoxLayout(panelVision, BoxLayout.Y_AXIS));
 
         panelVisionEnabled = new JPanel();
-        FlowLayout fl_panelVisionEnabled = (FlowLayout) panelVisionEnabled
-                .getLayout();
+        FlowLayout fl_panelVisionEnabled = (FlowLayout) panelVisionEnabled.getLayout();
         fl_panelVisionEnabled.setAlignment(FlowLayout.LEFT);
         panelVision.add(panelVisionEnabled);
 
@@ -237,19 +219,14 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
 
         panelVisionTemplateAndAoe = new JPanel();
         panelVision.add(panelVisionTemplateAndAoe);
-        panelVisionTemplateAndAoe
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.LABEL_COMPONENT_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+        panelVisionTemplateAndAoe.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.LABEL_COMPONENT_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         panelTemplate = new JPanel();
-        panelTemplate.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "Template Image",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
+        panelTemplate.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Template Image", TitledBorder.LEADING, TitledBorder.TOP, null,
                 new Color(0, 0, 0)));
         panelVisionTemplateAndAoe.add(panelTemplate, "2, 2, center, fill");
         panelTemplate.setLayout(new BoxLayout(panelTemplate, BoxLayout.Y_AXIS));
@@ -257,8 +234,7 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
         labelTemplateImage = new JLabel("");
         labelTemplateImage.setAlignmentX(Component.CENTER_ALIGNMENT);
         panelTemplate.add(labelTemplateImage);
-        labelTemplateImage.setBorder(new BevelBorder(BevelBorder.LOWERED, null,
-                null, null, null));
+        labelTemplateImage.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
         labelTemplateImage.setMinimumSize(new Dimension(150, 150));
         labelTemplateImage.setMaximumSize(new Dimension(150, 150));
         labelTemplateImage.setHorizontalAlignment(SwingConstants.CENTER);
@@ -272,31 +248,22 @@ public ReferenceDragFeederConfigurationWizard(ReferenceDragFeeder feeder) {
         panel.add(btnChangeTemplateImage);
         btnChangeTemplateImage.setAlignmentX(Component.CENTER_ALIGNMENT);
 
-        btnCancelChangeTemplateImage = new JButton(
-                cancelSelectTemplateImageAction);
+        btnCancelChangeTemplateImage = new JButton(cancelSelectTemplateImageAction);
         panel.add(btnCancelChangeTemplateImage);
 
         panelAoE = new JPanel();
-        panelAoE.setBorder(new TitledBorder(null, "Area of Interest",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelAoE.setBorder(new TitledBorder(null, "Area of Interest", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         panelVisionTemplateAndAoe.add(panelAoE, "4, 2, fill, fill");
         panelAoE.setLayout(new FormLayout(
-                new ColumnSpec[] { FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         lblX_1 = new JLabel("X");
         panelAoE.add(lblX_1, "2, 2");
@@ -345,90 +312,69 @@ public void createBindings() {
         super.createBindings();
         LengthConverter lengthConverter = new LengthConverter();
         IntegerConverter intConverter = new IntegerConverter();
-        DoubleConverter doubleConverter = new DoubleConverter(Configuration.get().getLengthDisplayFormat());
+        DoubleConverter doubleConverter =
+                new DoubleConverter(Configuration.get().getLengthDisplayFormat());
         BufferedImageIconConverter imageConverter = new BufferedImageIconConverter();
 
-        addWrappedBinding(feeder, "feedSpeed", textFieldFeedRate, "text",
-                doubleConverter);
+        addWrappedBinding(feeder, "feedSpeed", textFieldFeedRate, "text", doubleConverter);
         addWrappedBinding(feeder, "actuatorName", textFieldActuatorId, "text");
 
         MutableLocationProxy feedStartLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, feeder, "feedStartLocation",
-                feedStartLocation, "location");
-        addWrappedBinding(feedStartLocation, "lengthX", textFieldFeedStartX,
-                "text", lengthConverter);
-        addWrappedBinding(feedStartLocation, "lengthY", textFieldFeedStartY,
-                "text", lengthConverter);
-        addWrappedBinding(feedStartLocation, "lengthZ", textFieldFeedStartZ,
-                "text", lengthConverter);
+        bind(UpdateStrategy.READ_WRITE, feeder, "feedStartLocation", feedStartLocation, "location");
+        addWrappedBinding(feedStartLocation, "lengthX", textFieldFeedStartX, "text",
+                lengthConverter);
+        addWrappedBinding(feedStartLocation, "lengthY", textFieldFeedStartY, "text",
+                lengthConverter);
+        addWrappedBinding(feedStartLocation, "lengthZ", textFieldFeedStartZ, "text",
+                lengthConverter);
 
         MutableLocationProxy feedEndLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, feeder, "feedEndLocation",
-                feedEndLocation, "location");
-        addWrappedBinding(feedEndLocation, "lengthX", textFieldFeedEndX,
-                "text", lengthConverter);
-        addWrappedBinding(feedEndLocation, "lengthY", textFieldFeedEndY,
-                "text", lengthConverter);
-        addWrappedBinding(feedEndLocation, "lengthZ", textFieldFeedEndZ,
-                "text", lengthConverter);
-
-        addWrappedBinding(feeder, "vision.enabled", chckbxVisionEnabled,
-                "selected");
-        addWrappedBinding(feeder, "vision.templateImage", labelTemplateImage,
-                "icon", imageConverter);
-
-        addWrappedBinding(feeder, "vision.areaOfInterest.x", textFieldAoiX,
-                "text", intConverter);
-        addWrappedBinding(feeder, "vision.areaOfInterest.y", textFieldAoiY,
-                "text", intConverter);
-
-        addWrappedBinding(feeder, "vision.areaOfInterest.width",
-                textFieldAoiWidth, "text", intConverter);
-        addWrappedBinding(feeder, "vision.areaOfInterest.height",
-                textFieldAoiHeight, "text", intConverter);
-
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedRate);
+        bind(UpdateStrategy.READ_WRITE, feeder, "feedEndLocation", feedEndLocation, "location");
+        addWrappedBinding(feedEndLocation, "lengthX", textFieldFeedEndX, "text", lengthConverter);
+        addWrappedBinding(feedEndLocation, "lengthY", textFieldFeedEndY, "text", lengthConverter);
+        addWrappedBinding(feedEndLocation, "lengthZ", textFieldFeedEndZ, "text", lengthConverter);
+
+        addWrappedBinding(feeder, "vision.enabled", chckbxVisionEnabled, "selected");
+        addWrappedBinding(feeder, "vision.templateImage", labelTemplateImage, "icon",
+                imageConverter);
+
+        addWrappedBinding(feeder, "vision.areaOfInterest.x", textFieldAoiX, "text", intConverter);
+        addWrappedBinding(feeder, "vision.areaOfInterest.y", textFieldAoiY, "text", intConverter);
+
+        addWrappedBinding(feeder, "vision.areaOfInterest.width", textFieldAoiWidth, "text",
+                intConverter);
+        addWrappedBinding(feeder, "vision.areaOfInterest.height", textFieldAoiHeight, "text",
+                intConverter);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedRate);
         ComponentDecorators.decorateWithAutoSelect(textFieldActuatorId);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartZ);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndZ);
         ComponentDecorators.decorateWithAutoSelect(textFieldAoiX);
         ComponentDecorators.decorateWithAutoSelect(textFieldAoiY);
         ComponentDecorators.decorateWithAutoSelect(textFieldAoiWidth);
         ComponentDecorators.decorateWithAutoSelect(textFieldAoiHeight);
 
         BeanProperty actuatorIdProperty = BeanProperty.create("actuatorId");
-        Bindings.createAutoBinding(UpdateStrategy.READ, feeder,
-                actuatorIdProperty, locationButtonsPanelFeedStart,
-                actuatorIdProperty).bind();
-        Bindings.createAutoBinding(UpdateStrategy.READ, feeder,
-                actuatorIdProperty, locationButtonsPanelFeedEnd,
-                actuatorIdProperty).bind();
+        Bindings.createAutoBinding(UpdateStrategy.READ, feeder, actuatorIdProperty,
+                locationButtonsPanelFeedStart, actuatorIdProperty).bind();
+        Bindings.createAutoBinding(UpdateStrategy.READ, feeder, actuatorIdProperty,
+                locationButtonsPanelFeedEnd, actuatorIdProperty).bind();
     }
 
     @SuppressWarnings("serial")
     private Action selectTemplateImageAction = new AbstractAction("Select") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 cameraView.setSelectionEnabled(true);
                 // org.openpnp.model.Rectangle r =
                 // feeder.getVision().getTemplateImageCoordinates();
@@ -442,31 +388,24 @@ public void actionPerformed(ActionEvent arg0) {
                 }
                 btnChangeTemplateImage.setAction(confirmSelectTemplateImageAction);
                 cancelSelectTemplateImageAction.setEnabled(true);
-        	});
+            });
         }
     };
 
     @SuppressWarnings("serial")
-    private Action confirmSelectTemplateImageAction = new AbstractAction(
-            "Confirm") {
+    private Action confirmSelectTemplateImageAction = new AbstractAction("Confirm") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 BufferedImage image = cameraView.captureSelectionImage();
                 if (image == null) {
-                    MessageBoxes
-                            .errorBox(
-                                    ReferenceDragFeederConfigurationWizard.this,
-                                    "No Image Selected",
-                                    "Please select an area of the camera image using the mouse.");
+                    MessageBoxes.errorBox(ReferenceDragFeederConfigurationWizard.this,
+                            "No Image Selected",
+                            "Please select an area of the camera image using the mouse.");
                 }
                 else {
                     labelTemplateImage.setIcon(new ImageIcon(image));
@@ -474,28 +413,23 @@ public void actionPerformed(ActionEvent arg0) {
                 cameraView.setSelectionEnabled(false);
                 btnChangeTemplateImage.setAction(selectTemplateImageAction);
                 cancelSelectTemplateImageAction.setEnabled(false);
-        	});
+            });
         }
     };
 
     @SuppressWarnings("serial")
-    private Action cancelSelectTemplateImageAction = new AbstractAction(
-            "Cancel") {
+    private Action cancelSelectTemplateImageAction = new AbstractAction("Cancel") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 btnChangeTemplateImage.setAction(selectTemplateImageAction);
                 cancelSelectTemplateImageAction.setEnabled(false);
                 cameraView.setSelectionEnabled(false);
-        	});
+            });
         }
     };
 
@@ -503,29 +437,23 @@ public void actionPerformed(ActionEvent arg0) {
     private Action selectAoiAction = new AbstractAction("Select") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 btnChangeAoi.setAction(confirmSelectAoiAction);
                 cancelSelectAoiAction.setEnabled(true);
 
                 cameraView.setSelectionEnabled(true);
-                org.openpnp.model.Rectangle r = feeder.getVision()
-                        .getAreaOfInterest();
+                org.openpnp.model.Rectangle r = feeder.getVision().getAreaOfInterest();
                 if (r == null || r.getWidth() == 0 || r.getHeight() == 0) {
                     cameraView.setSelection(0, 0, 100, 100);
                 }
                 else {
-                    cameraView.setSelection(r.getX(), r.getY(), r.getWidth(),
-                            r.getHeight());
+                    cameraView.setSelection(r.getX(), r.getY(), r.getWidth(), r.getHeight());
                 }
-        	});
+            });
         }
     };
 
@@ -533,15 +461,11 @@ public void actionPerformed(ActionEvent arg0) {
     private Action confirmSelectAoiAction = new AbstractAction("Confirm") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 btnChangeAoi.setAction(selectAoiAction);
                 cancelSelectAoiAction.setEnabled(false);
 
@@ -551,13 +475,11 @@ public void actionPerformed(ActionEvent arg0) {
                     public void run() {
                         textFieldAoiX.setText(Integer.toString(rect.x));
                         textFieldAoiY.setText(Integer.toString(rect.y));
-                        textFieldAoiWidth.setText(Integer
-                                .toString(rect.width));
-                        textFieldAoiHeight.setText(Integer
-                                .toString(rect.height));
+                        textFieldAoiWidth.setText(Integer.toString(rect.width));
+                        textFieldAoiHeight.setText(Integer.toString(rect.height));
                     }
                 });
-        	});
+            });
         }
     };
 
@@ -565,21 +487,17 @@ public void run() {
     private Action cancelSelectAoiAction = new AbstractAction("Cancel") {
         @Override
         public void actionPerformed(ActionEvent arg0) {
-        	UiUtils.messageBoxOnException(() -> {
-            	Camera camera = MainFrame
-            			.machineControlsPanel
-            			.getSelectedTool()
-            			.getHead()
-            			.getDefaultCamera();
-                CameraView cameraView = MainFrame.cameraPanel
-                        .setSelectedCamera(camera);
-                
+            UiUtils.messageBoxOnException(() -> {
+                Camera camera = MainFrame.machineControlsPanel.getSelectedTool().getHead()
+                        .getDefaultCamera();
+                CameraView cameraView = MainFrame.cameraPanel.setSelectedCamera(camera);
+
                 btnChangeAoi.setAction(selectAoiAction);
                 cancelSelectAoiAction.setEnabled(false);
                 btnChangeAoi.setAction(selectAoiAction);
                 cancelSelectAoiAction.setEnabled(false);
                 cameraView.setSelectionEnabled(false);
-        	});
+            });
         }
     };
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceStripFeederConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceStripFeederConfigurationWizard.java
index dbc9a0e016..02352c9147 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceStripFeederConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceStripFeederConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder.wizards;
@@ -75,8 +73,7 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 @SuppressWarnings("serial")
-public class ReferenceStripFeederConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferenceStripFeederConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferenceStripFeeder feeder;
 
     private JPanel panelPart;
@@ -104,31 +101,25 @@
     private JLabel lblRotationInTape;
     private JTextField textFieldLocationRotation;
     private JButton btnAutoSetup;
-    
+
     private Location firstPartLocation;
     private Location secondPartLocation;
     private List<Location> part1HoleLocations;
     private Camera autoSetupCamera;
 
-    
+
     public ReferenceStripFeederConfigurationWizard(ReferenceStripFeeder feeder) {
         this.feeder = feeder;
-        
+
         panelPart = new JPanel();
-        panelPart.setBorder(new TitledBorder(null, "Part",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelPart.setBorder(
+                new TitledBorder(null, "Part", TitledBorder.LEADING, TitledBorder.TOP, null, null));
         contentPanel.add(panelPart);
-        panelPart
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
+        panelPart.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         comboBoxPart = new JComboBox();
         try {
@@ -140,43 +131,31 @@ public ReferenceStripFeederConfigurationWizard(ReferenceStripFeeder feeder) {
         }
         comboBoxPart.setRenderer(new IdentifiableListCellRenderer<Part>());
         panelPart.add(comboBoxPart, "2, 2, 3, 1, left, default");
-        
+
         lblRotationInTape = new JLabel("Rotation In Tape");
         panelPart.add(lblRotationInTape, "2, 4, left, default");
-        
+
         textFieldLocationRotation = new JTextField();
         panelPart.add(textFieldLocationRotation, "4, 4, fill, default");
         textFieldLocationRotation.setColumns(4);
 
         panelTapeSettings = new JPanel();
         contentPanel.add(panelTapeSettings);
-        panelTapeSettings.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "Tape Settings",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
-                new Color(0, 0, 0)));
-        panelTapeSettings.setLayout(new FormLayout(new ColumnSpec[] {
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,},
-        	new RowSpec[] {
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelTapeSettings.setBorder(new TitledBorder(
+                new EtchedBorder(EtchedBorder.LOWERED, null, null), "Tape Settings",
+                TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelTapeSettings.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         btnAutoSetup = new JButton(autoSetup);
         panelTapeSettings.add(btnAutoSetup, "2, 2, 11, 1");
 
@@ -185,65 +164,56 @@ public ReferenceStripFeederConfigurationWizard(ReferenceStripFeeder feeder) {
 
         comboBoxTapeType = new JComboBox(TapeType.values());
         panelTapeSettings.add(comboBoxTapeType, "4, 4, fill, default");
-        
-                JLabel lblTapeWidth = new JLabel("Tape Width");
-                panelTapeSettings.add(lblTapeWidth, "8, 4, right, default");
-        
-                textFieldTapeWidth = new JTextField();
-                panelTapeSettings.add(textFieldTapeWidth, "10, 4");
-                textFieldTapeWidth.setColumns(5);
-        
-                lblPartPitch = new JLabel("Part Pitch");
-                panelTapeSettings.add(lblPartPitch, "2, 6, right, default");
-        
-                textFieldPartPitch = new JTextField();
-                panelTapeSettings.add(textFieldPartPitch, "4, 6");
-                textFieldPartPitch.setColumns(5);
-        
-                lblFeedCount = new JLabel("Feed Count");
-                panelTapeSettings.add(lblFeedCount, "8, 6, right, default");
-        
-                textFieldFeedCount = new JTextField();
-                panelTapeSettings.add(textFieldFeedCount, "10, 6");
-                textFieldFeedCount.setColumns(10);
-        
-                btnResetFeedCount = new JButton(new AbstractAction("Reset") {
-                    @Override
-                    public void actionPerformed(ActionEvent e) {
-                        textFieldFeedCount.setText("0");
-                        applyAction.actionPerformed(e);
-                    }
-                });
-                panelTapeSettings.add(btnResetFeedCount, "12, 6");
-        
+
+        JLabel lblTapeWidth = new JLabel("Tape Width");
+        panelTapeSettings.add(lblTapeWidth, "8, 4, right, default");
+
+        textFieldTapeWidth = new JTextField();
+        panelTapeSettings.add(textFieldTapeWidth, "10, 4");
+        textFieldTapeWidth.setColumns(5);
+
+        lblPartPitch = new JLabel("Part Pitch");
+        panelTapeSettings.add(lblPartPitch, "2, 6, right, default");
+
+        textFieldPartPitch = new JTextField();
+        panelTapeSettings.add(textFieldPartPitch, "4, 6");
+        textFieldPartPitch.setColumns(5);
+
+        lblFeedCount = new JLabel("Feed Count");
+        panelTapeSettings.add(lblFeedCount, "8, 6, right, default");
+
+        textFieldFeedCount = new JTextField();
+        panelTapeSettings.add(textFieldFeedCount, "10, 6");
+        textFieldFeedCount.setColumns(10);
+
+        btnResetFeedCount = new JButton(new AbstractAction("Reset") {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                textFieldFeedCount.setText("0");
+                applyAction.actionPerformed(e);
+            }
+        });
+        panelTapeSettings.add(btnResetFeedCount, "12, 6");
+
         lblUseVision = new JLabel("Use Vision?");
         panelTapeSettings.add(lblUseVision, "2, 8");
-        
+
         chckbxUseVision = new JCheckBox("");
         panelTapeSettings.add(chckbxUseVision, "4, 8");
 
         panelLocations = new JPanel();
         contentPanel.add(panelLocations);
-        panelLocations.setBorder(new TitledBorder(null, "Locations",
-                TitledBorder.LEADING, TitledBorder.TOP, null, null));
-        panelLocations
-                .setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("left:default:grow"), },
-                        new RowSpec[] { FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC,
-                                FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC,
-                                FormSpecs.RELATED_GAP_ROWSPEC,
-                                FormSpecs.DEFAULT_ROWSPEC, }));
+        panelLocations.setBorder(new TitledBorder(null, "Locations", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelLocations.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("left:default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblX = new JLabel("X");
         panelLocations.add(lblX, "4, 2");
@@ -255,7 +225,8 @@ public void actionPerformed(ActionEvent e) {
         panelLocations.add(lblZ_1, "8, 2");
 
         JLabel lblFeedStartLocation = new JLabel("Reference Hole Location");
-        lblFeedStartLocation.setToolTipText("The location of the first tape hole past the first part in the direction of more parts.");
+        lblFeedStartLocation.setToolTipText(
+                "The location of the first tape hole past the first part in the direction of more parts.");
         panelLocations.add(lblFeedStartLocation, "2, 4, right, default");
 
         textFieldFeedStartX = new JTextField();
@@ -270,13 +241,13 @@ public void actionPerformed(ActionEvent e) {
         panelLocations.add(textFieldFeedStartZ, "8, 4");
         textFieldFeedStartZ.setColumns(8);
 
-        locationButtonsPanelFeedStart = new LocationButtonsPanel(
-                textFieldFeedStartX, textFieldFeedStartY, textFieldFeedStartZ,
-                null);
+        locationButtonsPanelFeedStart = new LocationButtonsPanel(textFieldFeedStartX,
+                textFieldFeedStartY, textFieldFeedStartZ, null);
         panelLocations.add(locationButtonsPanelFeedStart, "10, 4");
 
         JLabel lblFeedEndLocation = new JLabel("Next Hole Location");
-        lblFeedEndLocation.setToolTipText("The location of another hole after the reference hole. This can be any hole along the tape as long as it's past the reference hole.");
+        lblFeedEndLocation.setToolTipText(
+                "The location of another hole after the reference hole. This can be any hole along the tape as long as it's past the reference hole.");
         panelLocations.add(lblFeedEndLocation, "2, 6, right, default");
 
         textFieldFeedEndX = new JTextField();
@@ -291,8 +262,8 @@ public void actionPerformed(ActionEvent e) {
         panelLocations.add(textFieldFeedEndZ, "8, 6");
         textFieldFeedEndZ.setColumns(8);
 
-        locationButtonsPanelFeedEnd = new LocationButtonsPanel(
-                textFieldFeedEndX, textFieldFeedEndY, textFieldFeedEndZ, null);
+        locationButtonsPanelFeedEnd = new LocationButtonsPanel(textFieldFeedEndX, textFieldFeedEndY,
+                textFieldFeedEndZ, null);
         panelLocations.add(locationButtonsPanelFeedEnd, "10, 6");
     }
 
@@ -300,318 +271,257 @@ public void actionPerformed(ActionEvent e) {
     public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
         IntegerConverter intConverter = new IntegerConverter();
-        DoubleConverter doubleConverter = new DoubleConverter(Configuration
-                .get().getLengthDisplayFormat());
+        DoubleConverter doubleConverter =
+                new DoubleConverter(Configuration.get().getLengthDisplayFormat());
 
         MutableLocationProxy location = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, feeder, "location", location,
-                "location");
-        addWrappedBinding(location, "rotation", textFieldLocationRotation, "text",
-                doubleConverter);
+        bind(UpdateStrategy.READ_WRITE, feeder, "location", location, "location");
+        addWrappedBinding(location, "rotation", textFieldLocationRotation, "text", doubleConverter);
 
         addWrappedBinding(feeder, "part", comboBoxPart, "selectedItem");
         addWrappedBinding(feeder, "tapeType", comboBoxTapeType, "selectedItem");
 
-        addWrappedBinding(feeder, "tapeWidth", textFieldTapeWidth, "text",
-                lengthConverter);
-        addWrappedBinding(feeder, "partPitch", textFieldPartPitch, "text",
-                lengthConverter);
-        addWrappedBinding(feeder, "feedCount", textFieldFeedCount, "text",
-                intConverter);
+        addWrappedBinding(feeder, "tapeWidth", textFieldTapeWidth, "text", lengthConverter);
+        addWrappedBinding(feeder, "partPitch", textFieldPartPitch, "text", lengthConverter);
+        addWrappedBinding(feeder, "feedCount", textFieldFeedCount, "text", intConverter);
 
         MutableLocationProxy feedStartLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, feeder, "referenceHoleLocation",
-                feedStartLocation, "location");
-        addWrappedBinding(feedStartLocation, "lengthX", textFieldFeedStartX,
-                "text", lengthConverter);
-        addWrappedBinding(feedStartLocation, "lengthY", textFieldFeedStartY,
-                "text", lengthConverter);
-        addWrappedBinding(feedStartLocation, "lengthZ", textFieldFeedStartZ,
-                "text", lengthConverter);
+        bind(UpdateStrategy.READ_WRITE, feeder, "referenceHoleLocation", feedStartLocation,
+                "location");
+        addWrappedBinding(feedStartLocation, "lengthX", textFieldFeedStartX, "text",
+                lengthConverter);
+        addWrappedBinding(feedStartLocation, "lengthY", textFieldFeedStartY, "text",
+                lengthConverter);
+        addWrappedBinding(feedStartLocation, "lengthZ", textFieldFeedStartZ, "text",
+                lengthConverter);
 
         MutableLocationProxy feedEndLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, feeder, "lastHoleLocation",
-                feedEndLocation, "location");
-        addWrappedBinding(feedEndLocation, "lengthX", textFieldFeedEndX,
-                "text", lengthConverter);
-        addWrappedBinding(feedEndLocation, "lengthY", textFieldFeedEndY,
-                "text", lengthConverter);
-        addWrappedBinding(feedEndLocation, "lengthZ", textFieldFeedEndZ,
-                "text", lengthConverter);
-        
+        bind(UpdateStrategy.READ_WRITE, feeder, "lastHoleLocation", feedEndLocation, "location");
+        addWrappedBinding(feedEndLocation, "lengthX", textFieldFeedEndX, "text", lengthConverter);
+        addWrappedBinding(feedEndLocation, "lengthY", textFieldFeedEndY, "text", lengthConverter);
+        addWrappedBinding(feedEndLocation, "lengthZ", textFieldFeedEndZ, "text", lengthConverter);
+
         addWrappedBinding(feeder, "visionEnabled", chckbxUseVision, "selected");
 
         ComponentDecorators.decorateWithAutoSelect(textFieldLocationRotation);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldTapeWidth);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldPartPitch);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldTapeWidth);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldPartPitch);
         ComponentDecorators.decorateWithAutoSelect(textFieldFeedCount);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedStartZ);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldFeedEndZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedStartZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedEndZ);
     }
-    
+
     private Action autoSetup = new AbstractAction("Auto Setup") {
         @Override
         public void actionPerformed(ActionEvent e) {
-        	try {
-        		autoSetupCamera = Configuration
-            			.get()
-            			.getMachine()
-            			.getDefaultHead()
-            			.getDefaultCamera(); 
-        	}
-        	catch (Exception ex) {
-				MessageBoxes.errorBox(
-						getTopLevelAncestor(), 
-						"Auto Setup Failure",
-						ex);
-				return;
-        	}
-        	
-        	btnAutoSetup.setAction(autoSetupCancel);
-        	
-        	CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
-        	cameraView.addActionListener(autoSetupPart1Clicked);
-        	cameraView.setText("Click on the center of the first part in the tape.");
-        	cameraView.flash();
-        	
-        	final boolean showDetails = (e.getModifiers() & ActionEvent.ALT_MASK) != 0;
-        	
-        	cameraView.setCameraViewFilter(new CameraViewFilter() {
-				@Override
-				public BufferedImage filterCameraImage(Camera camera, BufferedImage image) {
-					return showHoles(camera, image, showDetails);
-				}
-			});
+            try {
+                autoSetupCamera =
+                        Configuration.get().getMachine().getDefaultHead().getDefaultCamera();
+            }
+            catch (Exception ex) {
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Auto Setup Failure", ex);
+                return;
+            }
+
+            btnAutoSetup.setAction(autoSetupCancel);
+
+            CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
+            cameraView.addActionListener(autoSetupPart1Clicked);
+            cameraView.setText("Click on the center of the first part in the tape.");
+            cameraView.flash();
+
+            final boolean showDetails = (e.getModifiers() & ActionEvent.ALT_MASK) != 0;
+
+            cameraView.setCameraViewFilter(new CameraViewFilter() {
+                @Override
+                public BufferedImage filterCameraImage(Camera camera, BufferedImage image) {
+                    return showHoles(camera, image, showDetails);
+                }
+            });
         }
     };
-    
+
     private Action autoSetupCancel = new AbstractAction("Cancel Auto Setup") {
         @Override
         public void actionPerformed(ActionEvent e) {
-        	btnAutoSetup.setAction(autoSetup);
-        	CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
-        	cameraView.setText(null);
-        	cameraView.setCameraViewFilter(null);
-        	cameraView.removeActionListener(autoSetupPart1Clicked);
-        	cameraView.removeActionListener(autoSetupPart2Clicked);
+            btnAutoSetup.setAction(autoSetup);
+            CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
+            cameraView.setText(null);
+            cameraView.setCameraViewFilter(null);
+            cameraView.removeActionListener(autoSetupPart1Clicked);
+            cameraView.removeActionListener(autoSetupPart2Clicked);
         }
     };
-    
+
     private CameraViewActionListener autoSetupPart1Clicked = new CameraViewActionListener() {
-		@Override
-		public void actionPerformed(final CameraViewActionEvent action) {
-			firstPartLocation = action.getLocation();
-        	final CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
-        	cameraView.removeActionListener(this);
-			Configuration.get().getMachine().submit(new Callable<Void>() {
-				public Void call() throws Exception {
-					cameraView.setText("Checking first part...");
-					autoSetupCamera.moveTo(action.getLocation(), 1.0);
-		        	part1HoleLocations = findHoles(autoSetupCamera);
-		            
-		            cameraView.setText("Now click on the center of the second part in the tape.");
-		            cameraView.flash();
-		            
-		            cameraView.addActionListener(autoSetupPart2Clicked);
-		        	return null;
-				}
-			}, new FutureCallback<Void>() {
-				@Override
-				public void onSuccess(Void result) {
-				}
-
-				@Override
-				public void onFailure(final Throwable t) {
-					SwingUtilities.invokeLater(new Runnable() {
-						public void run() {
-							autoSetupCancel.actionPerformed(null);
-							MessageBoxes.errorBox(
-									getTopLevelAncestor(), 
-									"Auto Setup Failure",
-									t);
-						}
-					});
-				}
-			});
-		}
-	};
-    
+        @Override
+        public void actionPerformed(final CameraViewActionEvent action) {
+            firstPartLocation = action.getLocation();
+            final CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
+            cameraView.removeActionListener(this);
+            Configuration.get().getMachine().submit(new Callable<Void>() {
+                public Void call() throws Exception {
+                    cameraView.setText("Checking first part...");
+                    autoSetupCamera.moveTo(action.getLocation(), 1.0);
+                    part1HoleLocations = findHoles(autoSetupCamera);
+
+                    cameraView.setText("Now click on the center of the second part in the tape.");
+                    cameraView.flash();
+
+                    cameraView.addActionListener(autoSetupPart2Clicked);
+                    return null;
+                }
+            }, new FutureCallback<Void>() {
+                @Override
+                public void onSuccess(Void result) {}
+
+                @Override
+                public void onFailure(final Throwable t) {
+                    SwingUtilities.invokeLater(new Runnable() {
+                        public void run() {
+                            autoSetupCancel.actionPerformed(null);
+                            MessageBoxes.errorBox(getTopLevelAncestor(), "Auto Setup Failure", t);
+                        }
+                    });
+                }
+            });
+        }
+    };
+
     private CameraViewActionListener autoSetupPart2Clicked = new CameraViewActionListener() {
-		@Override
-		public void actionPerformed(final CameraViewActionEvent action) {
-			secondPartLocation = action.getLocation();
-        	final CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
-        	cameraView.removeActionListener(this);
-			Configuration.get().getMachine().submit(new Callable<Void>() {
-				public Void call() throws Exception {
-					cameraView.setText("Checking second part...");
-					autoSetupCamera.moveTo(action.getLocation(), 1.0);
-		        	List<Location> part2HoleLocations = findHoles(autoSetupCamera);
-		            
-		        	List<Location> referenceHoles = deriveReferenceHoles(
-		        			part1HoleLocations, 
-		        			part2HoleLocations);
-		        	final Location referenceHole1 = referenceHoles.get(0);
-		        	final Location referenceHole2 = referenceHoles.get(1);
-		        	
-		        	feeder.setReferenceHoleLocation(referenceHole1);
-		        	feeder.setLastHoleLocation(referenceHole2);
-		        	
-		        	Length partPitch = firstPartLocation.getLinearLengthTo(secondPartLocation);
-		        	partPitch.setValue(2*(Math.round(partPitch.getValue()/2)));
-		        	
-		        	final Length partPitch_ = partPitch;
-		        	SwingUtilities.invokeLater(new Runnable() {
-		        		public void run() {
-				        	Helpers.copyLocationIntoTextFields(
-				        			referenceHole1, 
-				        			textFieldFeedStartX, 
-				        			textFieldFeedStartY, 
-				        			textFieldFeedStartZ);
-				        	Helpers.copyLocationIntoTextFields(
-				        			referenceHole2, 
-				        			textFieldFeedEndX, 
-				        			textFieldFeedEndY, 
-				        			textFieldFeedEndZ);
-				        	textFieldPartPitch.setText(partPitch_.getValue() + "");
-		        		}
-		        	});
-		        	
-		        	feeder.setFeedCount(1);
-		        	autoSetupCamera.moveTo(feeder.getPickLocation(), 1.0);
-		        	feeder.setFeedCount(0);
-		        	
-		        	cameraView.setText("Setup complete!");
-		        	Thread.sleep(1500);
-		        	cameraView.setText(null);
-		        	cameraView.setCameraViewFilter(null);
-		        	btnAutoSetup.setAction(autoSetup);
-
-		        	return null;
-				}
-			}, new FutureCallback<Void>() {
-				@Override
-				public void onSuccess(Void result) {
-				}
-
-				@Override
-				public void onFailure(final Throwable t) {
-					SwingUtilities.invokeLater(new Runnable() {
-						public void run() {
-							autoSetupCancel.actionPerformed(null);
-							MessageBoxes.errorBox(
-									getTopLevelAncestor(), 
-									"Auto Setup Failure",
-									t);
-						}
-					});
-				}
-			});
-		}
-	};
-	
-	private List<Location> findHoles(Camera camera) {
-	    List<Location> holeLocations = new ArrayList<>();
-		new FluentCv()
-			.setCamera(camera)
-			.settleAndCapture()
-			.toGray()
-			.blurGaussian(feeder.getHoleBlurKernelSize())
-			.findCirclesHough( 
-                feeder.getHoleDiameterMin(), 
-                feeder.getHoleDiameterMax(), 
-                feeder.getHolePitchMin())
-			.filterCirclesByDistance(
-					feeder.getHoleDistanceMin(), 
-					feeder.getHoleDistanceMax())
-			.filterCirclesToLine(feeder.getHoleLineDistanceMax())
-			.convertCirclesToLocations(holeLocations);
-	    return holeLocations;
-	}
-	
-	/**
-	 * Show candidate holes in the image. Red are any holes that are found. Blue
-	 * is holes that passed the distance check but failed the line check. Green
-	 * passed all checks and are good.
-	 * @param camera
-	 * @param image
-	 * @return
-	 */
-	private BufferedImage showHoles(Camera camera, BufferedImage image, boolean showDetails) {
-		if (showDetails) {
-			return new FluentCv()
-				.setCamera(camera)
-				.toMat(image, "original")
-				.toGray()
-				.blurGaussian(feeder.getHoleBlurKernelSize())
-				.findCirclesHough( 
-	                    feeder.getHoleDiameterMin(), 
-	                    feeder.getHoleDiameterMax(), 
-	                    feeder.getHolePitchMin(),
-	                    "houghUnfiltered")
-				.drawCircles("original", Color.red, "unfiltered")
-				.recall("houghUnfiltered")
-				.filterCirclesByDistance(
-						feeder.getHoleDistanceMin(), 
-						feeder.getHoleDistanceMax(), 
-						"houghDistanceFiltered")
-				.drawCircles("unfiltered", Color.blue, "distanceFiltered")
-				.recall("houghDistanceFiltered")
-				.filterCirclesToLine(feeder.getHoleLineDistanceMax())
-				.drawCircles("distanceFiltered", Color.green)
-				.toBufferedImage();
-		}
-		else {
-			return new FluentCv()
-				.setCamera(camera)
-				.toMat(image, "original")
-				.toGray()
-				.blurGaussian(feeder.getHoleBlurKernelSize())
-				.findCirclesHough( 
-	                    feeder.getHoleDiameterMin(), 
-	                    feeder.getHoleDiameterMax(), 
-	                    feeder.getHolePitchMin())
-				.filterCirclesByDistance(
-						feeder.getHoleDistanceMin(), 
-						feeder.getHoleDistanceMax())
-				.filterCirclesToLine(feeder.getHoleLineDistanceMax())
-				.drawCircles("original", Color.green)
-				.toBufferedImage();
-		}
-	}
-	
-	private List<Location> deriveReferenceHoles(List<Location> part1HoleLocations, List<Location> part2HoleLocations) {
-		// We are only interested in the pair of holes closest to each part
-		part1HoleLocations = part1HoleLocations.subList(0, Math.min(2,  part1HoleLocations.size()));
-		part2HoleLocations = part2HoleLocations.subList(0, Math.min(2,  part2HoleLocations.size()));
-		
-		// Part 1's reference hole is the one closest to either of part 2's holes.
-		Location part1ReferenceHole = VisionUtils.sortLocationsByDistance(
-				part2HoleLocations.get(0),
-				part1HoleLocations).get(0);
-		// Part 2's reference hole is the one farthest from part 1's reference hole.
-		Location part2ReferenceHole = Lists.reverse(VisionUtils.sortLocationsByDistance(
-				part1ReferenceHole,
-				part2HoleLocations)).get(0);
-		
-		List<Location> referenceHoles = new ArrayList<>();
-		referenceHoles.add(part1ReferenceHole);
-		referenceHoles.add(part2ReferenceHole);
-		return referenceHoles;
-	}
-	
+        @Override
+        public void actionPerformed(final CameraViewActionEvent action) {
+            secondPartLocation = action.getLocation();
+            final CameraView cameraView = MainFrame.cameraPanel.getCameraView(autoSetupCamera);
+            cameraView.removeActionListener(this);
+            Configuration.get().getMachine().submit(new Callable<Void>() {
+                public Void call() throws Exception {
+                    cameraView.setText("Checking second part...");
+                    autoSetupCamera.moveTo(action.getLocation(), 1.0);
+                    List<Location> part2HoleLocations = findHoles(autoSetupCamera);
+
+                    List<Location> referenceHoles =
+                            deriveReferenceHoles(part1HoleLocations, part2HoleLocations);
+                    final Location referenceHole1 = referenceHoles.get(0);
+                    final Location referenceHole2 = referenceHoles.get(1);
+
+                    feeder.setReferenceHoleLocation(referenceHole1);
+                    feeder.setLastHoleLocation(referenceHole2);
+
+                    Length partPitch = firstPartLocation.getLinearLengthTo(secondPartLocation);
+                    partPitch.setValue(2 * (Math.round(partPitch.getValue() / 2)));
+
+                    final Length partPitch_ = partPitch;
+                    SwingUtilities.invokeLater(new Runnable() {
+                        public void run() {
+                            Helpers.copyLocationIntoTextFields(referenceHole1, textFieldFeedStartX,
+                                    textFieldFeedStartY, textFieldFeedStartZ);
+                            Helpers.copyLocationIntoTextFields(referenceHole2, textFieldFeedEndX,
+                                    textFieldFeedEndY, textFieldFeedEndZ);
+                            textFieldPartPitch.setText(partPitch_.getValue() + "");
+                        }
+                    });
+
+                    feeder.setFeedCount(1);
+                    autoSetupCamera.moveTo(feeder.getPickLocation(), 1.0);
+                    feeder.setFeedCount(0);
+
+                    cameraView.setText("Setup complete!");
+                    Thread.sleep(1500);
+                    cameraView.setText(null);
+                    cameraView.setCameraViewFilter(null);
+                    btnAutoSetup.setAction(autoSetup);
+
+                    return null;
+                }
+            }, new FutureCallback<Void>() {
+                @Override
+                public void onSuccess(Void result) {}
+
+                @Override
+                public void onFailure(final Throwable t) {
+                    SwingUtilities.invokeLater(new Runnable() {
+                        public void run() {
+                            autoSetupCancel.actionPerformed(null);
+                            MessageBoxes.errorBox(getTopLevelAncestor(), "Auto Setup Failure", t);
+                        }
+                    });
+                }
+            });
+        }
+    };
+
+    private List<Location> findHoles(Camera camera) {
+        List<Location> holeLocations = new ArrayList<>();
+        new FluentCv().setCamera(camera).settleAndCapture().toGray()
+                .blurGaussian(feeder.getHoleBlurKernelSize())
+                .findCirclesHough(feeder.getHoleDiameterMin(), feeder.getHoleDiameterMax(),
+                        feeder.getHolePitchMin())
+                .filterCirclesByDistance(feeder.getHoleDistanceMin(), feeder.getHoleDistanceMax())
+                .filterCirclesToLine(feeder.getHoleLineDistanceMax())
+                .convertCirclesToLocations(holeLocations);
+        return holeLocations;
+    }
+
+    /**
+     * Show candidate holes in the image. Red are any holes that are found. Blue is holes that
+     * passed the distance check but failed the line check. Green passed all checks and are good.
+     * 
+     * @param camera
+     * @param image
+     * @return
+     */
+    private BufferedImage showHoles(Camera camera, BufferedImage image, boolean showDetails) {
+        if (showDetails) {
+            return new FluentCv().setCamera(camera).toMat(image, "original").toGray()
+                    .blurGaussian(feeder.getHoleBlurKernelSize())
+                    .findCirclesHough(feeder.getHoleDiameterMin(), feeder.getHoleDiameterMax(),
+                            feeder.getHolePitchMin(), "houghUnfiltered")
+                    .drawCircles("original", Color.red, "unfiltered").recall("houghUnfiltered")
+                    .filterCirclesByDistance(feeder.getHoleDistanceMin(),
+                            feeder.getHoleDistanceMax(), "houghDistanceFiltered")
+                    .drawCircles("unfiltered", Color.blue, "distanceFiltered")
+                    .recall("houghDistanceFiltered")
+                    .filterCirclesToLine(feeder.getHoleLineDistanceMax())
+                    .drawCircles("distanceFiltered", Color.green).toBufferedImage();
+        }
+        else {
+            return new FluentCv().setCamera(camera).toMat(image, "original").toGray()
+                    .blurGaussian(feeder.getHoleBlurKernelSize())
+                    .findCirclesHough(feeder.getHoleDiameterMin(), feeder.getHoleDiameterMax(),
+                            feeder.getHolePitchMin())
+                    .filterCirclesByDistance(feeder.getHoleDistanceMin(),
+                            feeder.getHoleDistanceMax())
+                    .filterCirclesToLine(feeder.getHoleLineDistanceMax())
+                    .drawCircles("original", Color.green).toBufferedImage();
+        }
+    }
+
+    private List<Location> deriveReferenceHoles(List<Location> part1HoleLocations,
+            List<Location> part2HoleLocations) {
+        // We are only interested in the pair of holes closest to each part
+        part1HoleLocations = part1HoleLocations.subList(0, Math.min(2, part1HoleLocations.size()));
+        part2HoleLocations = part2HoleLocations.subList(0, Math.min(2, part2HoleLocations.size()));
+
+        // Part 1's reference hole is the one closest to either of part 2's holes.
+        Location part1ReferenceHole = VisionUtils
+                .sortLocationsByDistance(part2HoleLocations.get(0), part1HoleLocations).get(0);
+        // Part 2's reference hole is the one farthest from part 1's reference hole.
+        Location part2ReferenceHole = Lists
+                .reverse(
+                        VisionUtils.sortLocationsByDistance(part1ReferenceHole, part2HoleLocations))
+                .get(0);
+
+        List<Location> referenceHoles = new ArrayList<>();
+        referenceHoles.add(part1ReferenceHole);
+        referenceHoles.add(part2ReferenceHole);
+        return referenceHoles;
+    }
+
     private JCheckBox chckbxUseVision;
     private JLabel lblUseVision;
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTrayFeederConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTrayFeederConfigurationWizard.java
index 366743c902..c805c37626 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTrayFeederConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTrayFeederConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder.wizards;
@@ -29,20 +27,18 @@
 import org.jdesktop.beansbinding.AutoBinding.UpdateStrategy;
 import org.openpnp.gui.components.ComponentDecorators;
 import org.openpnp.gui.support.IntegerConverter;
-import org.openpnp.gui.support.JBindings.WrappedBinding;
 import org.openpnp.gui.support.LengthConverter;
 import org.openpnp.gui.support.MessageBoxes;
 import org.openpnp.gui.support.MutableLocationProxy;
 import org.openpnp.machine.reference.feeder.ReferenceTrayFeeder;
-import org.openpnp.model.Length;
 
 import com.jgoodies.forms.layout.ColumnSpec;
 import com.jgoodies.forms.layout.FormLayout;
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
-public class ReferenceTrayFeederConfigurationWizard extends
-        AbstractReferenceFeederConfigurationWizard {
+public class ReferenceTrayFeederConfigurationWizard
+        extends AbstractReferenceFeederConfigurationWizard {
     private final ReferenceTrayFeeder feeder;
 
     private JTextField textFieldOffsetsX;
@@ -58,44 +54,25 @@ public ReferenceTrayFeederConfigurationWizard(ReferenceTrayFeeder feeder) {
         JPanel panelFields = new JPanel();
 
         panelFields.setLayout(new FormLayout(
-                new ColumnSpec[] { FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        ColumnSpec.decode("default:grow"),
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblX = new JLabel("X");
         panelFields.add(lblX, "4, 2");
@@ -144,40 +121,35 @@ public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
         IntegerConverter integerConverter = new IntegerConverter();
 
-        
+
         MutableLocationProxy offsets = new MutableLocationProxy();
         bind(UpdateStrategy.READ_WRITE, feeder, "offsets", offsets, "location");
-        addWrappedBinding(offsets, "lengthX", textFieldOffsetsX, "text",
-                lengthConverter);
-        addWrappedBinding(offsets, "lengthY", textFieldOffsetsY, "text",
-                lengthConverter);
+        addWrappedBinding(offsets, "lengthX", textFieldOffsetsX, "text", lengthConverter);
+        addWrappedBinding(offsets, "lengthY", textFieldOffsetsY, "text", lengthConverter);
 
-        addWrappedBinding(feeder, "trayCountX", textFieldTrayCountX, "text",
-                integerConverter);
-        addWrappedBinding(feeder, "trayCountY", textFieldTrayCountY, "text",
-                integerConverter);
+        addWrappedBinding(feeder, "trayCountX", textFieldTrayCountX, "text", integerConverter);
+        addWrappedBinding(feeder, "trayCountY", textFieldTrayCountY, "text", integerConverter);
 
-        addWrappedBinding(feeder, "feedCount", textFieldFeedCount, "text",
-                integerConverter);
+        addWrappedBinding(feeder, "feedCount", textFieldFeedCount, "text", integerConverter);
 
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldOffsetsX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(textFieldOffsetsY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldOffsetsX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldOffsetsY);
 
         ComponentDecorators.decorateWithAutoSelect(textFieldTrayCountX);
         ComponentDecorators.decorateWithAutoSelect(textFieldTrayCountY);
         ComponentDecorators.decorateWithAutoSelect(textFieldFeedCount);
     }
 
-	@Override
-	protected void saveToModel() {
-		super.saveToModel();
-		if (feeder.getOffsets().getX() == 0 && feeder.getTrayCountX() > 1) {
-			MessageBoxes.errorBox(this, "Error", "X offset must be greater than 0 if X tray count is greater than 1 or feed failure will occur.");
-		}
-		if (feeder.getOffsets().getY() == 0 && feeder.getTrayCountY() > 1) {
-			MessageBoxes.errorBox(this, "Error", "Y offset must be greater than 0 if Y tray count is greater than 1 or feed failure will occur.");
-		}
-	}
-}
\ No newline at end of file
+    @Override
+    protected void saveToModel() {
+        super.saveToModel();
+        if (feeder.getOffsets().getX() == 0 && feeder.getTrayCountX() > 1) {
+            MessageBoxes.errorBox(this, "Error",
+                    "X offset must be greater than 0 if X tray count is greater than 1 or feed failure will occur.");
+        }
+        if (feeder.getOffsets().getY() == 0 && feeder.getTrayCountY() > 1) {
+            MessageBoxes.errorBox(this, "Error",
+                    "Y offset must be greater than 0 if Y tray count is greater than 1 or feed failure will occur.");
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTubeFeederConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTubeFeederConfigurationWizard.java
index d41e96738f..960d52b98e 100755
--- a/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTubeFeederConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/feeder/wizards/ReferenceTubeFeederConfigurationWizard.java
@@ -1,34 +1,32 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.feeder.wizards;
 
 import org.openpnp.machine.reference.feeder.ReferenceTubeFeeder;
 
-public class ReferenceTubeFeederConfigurationWizard extends
-        AbstractReferenceFeederConfigurationWizard {
+public class ReferenceTubeFeederConfigurationWizard
+        extends AbstractReferenceFeederConfigurationWizard {
     private final ReferenceTubeFeeder feeder;
 
     public ReferenceTubeFeederConfigurationWizard(ReferenceTubeFeeder feeder) {
         super(feeder);
         this.feeder = feeder;
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/vision/OpenCvVisionProvider.java b/src/main/java/org/openpnp/machine/reference/vision/OpenCvVisionProvider.java
index 6096e68fb8..242add24ea 100755
--- a/src/main/java/org/openpnp/machine/reference/vision/OpenCvVisionProvider.java
+++ b/src/main/java/org/openpnp/machine/reference/vision/OpenCvVisionProvider.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.vision;
@@ -58,13 +56,12 @@
 import org.slf4j.LoggerFactory;
 
 public class OpenCvVisionProvider implements VisionProvider {
-    private final static Logger logger = LoggerFactory
-            .getLogger(OpenCvVisionProvider.class);
+    private final static Logger logger = LoggerFactory.getLogger(OpenCvVisionProvider.class);
 
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
-    }    
+    }
 
     // SimpleXML requires at least one attribute or element on a class before
     // it will recognize it.
@@ -88,111 +85,102 @@ protected Mat getCameraImage() {
         Mat image = OpenCvUtils.toMat(image_);
         return image;
     }
-    
+
     /**
-     * Attempt to find matches of the given template within the current camera
-     * frame. Matches are returned as TemplateMatch objects which contain
-     * a Location in Camera coordinates. The results are sorted best score
-     * to worst score.
+     * Attempt to find matches of the given template within the current camera frame. Matches are
+     * returned as TemplateMatch objects which contain a Location in Camera coordinates. The results
+     * are sorted best score to worst score.
+     * 
      * @param template
      * @return
      */
     public List<TemplateMatch> getTemplateMatches(BufferedImage template) {
         // TODO: ROI
         BufferedImage image = camera.capture();
-        
+
         // Convert the camera image and template image to the same type. This
         // is required by the cvMatchTemplate call.
-        template = ImageUtils.convertBufferedImage(template,BufferedImage.TYPE_BYTE_GRAY);   
+        template = ImageUtils.convertBufferedImage(template, BufferedImage.TYPE_BYTE_GRAY);
         image = ImageUtils.convertBufferedImage(image, BufferedImage.TYPE_BYTE_GRAY);
-        
+
         Mat templateMat = OpenCvUtils.toMat(template);
         Mat imageMat = OpenCvUtils.toMat(image);
         Mat resultMat = new Mat();
-        
+
         Imgproc.matchTemplate(imageMat, templateMat, resultMat, Imgproc.TM_CCOEFF_NORMED);
 
         Mat debugMat = null;
         if (logger.isDebugEnabled()) {
-            debugMat = imageMat.clone();        
+            debugMat = imageMat.clone();
         }
-        
+
         MinMaxLocResult mmr = Core.minMaxLoc(resultMat);
         double maxVal = mmr.maxVal;
-        
+
         // TODO: Externalize?
         double threshold = 0.7f;
         double corr = 0.85f;
 
         double rangeMin = Math.max(threshold, corr * maxVal);
         double rangeMax = maxVal;
-        
+
         List<TemplateMatch> matches = new ArrayList<>();
         for (Point point : matMaxima(resultMat, rangeMin, rangeMax)) {
             TemplateMatch match = new TemplateMatch();
             int x = point.x;
             int y = point.y;
             match.score = resultMat.get(y, x)[0] / maxVal;
-            
+
             if (logger.isDebugEnabled()) {
-                Core.rectangle(
-                        debugMat, 
-                        new org.opencv.core.Point(x, y), 
-                        new org.opencv.core.Point(x + templateMat.cols(), y + templateMat.rows()), 
-                        new Scalar(255));
-                Core.putText(
-                        debugMat, 
-                        "" + match.score, 
+                Core.rectangle(debugMat, new org.opencv.core.Point(x, y),
                         new org.opencv.core.Point(x + templateMat.cols(), y + templateMat.rows()),
-                        Core.FONT_HERSHEY_PLAIN,
-                        1.0,
                         new Scalar(255));
+                Core.putText(debugMat, "" + match.score,
+                        new org.opencv.core.Point(x + templateMat.cols(), y + templateMat.rows()),
+                        Core.FONT_HERSHEY_PLAIN, 1.0, new Scalar(255));
             }
-            
-            match.location = VisionUtils.getPixelLocation(
-                    camera, 
-                    x + (templateMat.cols() / 2), 
+
+            match.location = VisionUtils.getPixelLocation(camera, x + (templateMat.cols() / 2),
                     y + (templateMat.rows() / 2));
             matches.add(match);
         }
-        
+
         Collections.sort(matches, new Comparator<TemplateMatch>() {
             @Override
             public int compare(TemplateMatch o1, TemplateMatch o2) {
                 return ((Double) o2.score).compareTo(o1.score);
             }
         });
-        
-        saveDebugImage("template", templateMat);
-        saveDebugImage("camera", imageMat);
-        saveDebugImage("result", resultMat);
-        saveDebugImage("debug", debugMat);
-                
+
+        long t = System.currentTimeMillis();
+        saveDebugImage(t + "_0_template", templateMat);
+        saveDebugImage(t + "_1_camera", imageMat);
+        saveDebugImage(t + "_2_result", resultMat);
+        saveDebugImage(t + "_3_debug", debugMat);
+
         return matches;
     }
-    
+
     @Override
-    public Point[] locateTemplateMatches(int roiX, int roiY, int roiWidth,
-            int roiHeight, int coiX, int coiY, BufferedImage templateImage_)
-            throws Exception {
+    public Point[] locateTemplateMatches(int roiX, int roiY, int roiWidth, int roiHeight, int coiX,
+            int coiY, BufferedImage templateImage_) throws Exception {
         BufferedImage cameraImage_ = camera.capture();
-        
+
         // Convert the camera image and template image to the same type. This
         // is required by the cvMatchTemplate call.
-        templateImage_ = ImageUtils.convertBufferedImage(templateImage_,BufferedImage.TYPE_INT_ARGB);   
+        templateImage_ =
+                ImageUtils.convertBufferedImage(templateImage_, BufferedImage.TYPE_INT_ARGB);
         cameraImage_ = ImageUtils.convertBufferedImage(cameraImage_, BufferedImage.TYPE_INT_ARGB);
-        
+
         Mat templateImage = OpenCvUtils.toMat(templateImage_);
         Mat cameraImage = OpenCvUtils.toMat(cameraImage_);
         Mat roiImage = new Mat(cameraImage, new Rect(roiX, roiY, roiWidth, roiHeight));
-        
+
         // http://stackoverflow.com/questions/17001083/opencv-template-matching-example-in-android
-        Mat resultImage = new Mat(
-                roiImage.cols() - templateImage.cols() + 1, 
-                roiImage.rows() - templateImage.rows() + 1, 
-                CvType.CV_32FC1);
+        Mat resultImage = new Mat(roiImage.cols() - templateImage.cols() + 1,
+                roiImage.rows() - templateImage.rows() + 1, CvType.CV_32FC1);
         Imgproc.matchTemplate(roiImage, templateImage, resultImage, Imgproc.TM_CCOEFF);
-        
+
         MinMaxLocResult mmr = Core.minMaxLoc(resultImage);
 
         org.opencv.core.Point matchLoc = mmr.maxLoc;
@@ -200,20 +188,19 @@ public int compare(TemplateMatch o1, TemplateMatch o2) {
 
         // TODO: Figure out certainty and how to filter on it.
 
-        logger.debug(String.format(
-                "locateTemplateMatches certainty %f at %f, %f", matchValue,
+        logger.debug(String.format("locateTemplateMatches certainty %f at %f, %f", matchValue,
                 matchLoc.x, matchLoc.y));
         locateTemplateMatchesDebug(roiImage, templateImage, matchLoc);
 
-        return new Point[] { new Point(((int) matchLoc.x) + roiX, ((int) matchLoc.y) + roiY) };
+        return new Point[] {new Point(((int) matchLoc.x) + roiX, ((int) matchLoc.y) + roiY)};
     }
-    
+
     protected void saveDebugImage(String name, Mat mat) {
         if (logger.isDebugEnabled()) {
             try {
                 BufferedImage debugImage = OpenCvUtils.toBufferedImage(mat);
-                File file = Configuration.get().createResourceFile(
-                        OpenCvVisionProvider.class, name + "_", ".png");
+                File file = Configuration.get().createResourceFile(OpenCvVisionProvider.class,
+                        name + "_", ".png");
                 ImageIO.write(debugImage, "PNG", file);
             }
             catch (Exception e) {
@@ -222,15 +209,18 @@ protected void saveDebugImage(String name, Mat mat) {
         }
     }
 
-    private void locateTemplateMatchesDebug(Mat roiImage, Mat templateImage, org.opencv.core.Point matchLoc) {
+    private void locateTemplateMatchesDebug(Mat roiImage, Mat templateImage,
+            org.opencv.core.Point matchLoc) {
         if (logger.isDebugEnabled()) {
             try {
-                Core.rectangle(roiImage, matchLoc, new org.opencv.core.Point(matchLoc.x + templateImage.cols(),
-                        matchLoc.y + templateImage.rows()), new Scalar(0, 255, 0));                
-                
+                Core.rectangle(roiImage, matchLoc,
+                        new org.opencv.core.Point(matchLoc.x + templateImage.cols(),
+                                matchLoc.y + templateImage.rows()),
+                        new Scalar(0, 255, 0));
+
                 BufferedImage debugImage = OpenCvUtils.toBufferedImage(roiImage);
-                File file = Configuration.get().createResourceFile(
-                        OpenCvVisionProvider.class, "debug_", ".png");
+                File file = Configuration.get().createResourceFile(OpenCvVisionProvider.class,
+                        "debug_", ".png");
                 ImageIO.write(debugImage, "PNG", file);
                 logger.debug("Debug image filename {}", file);
             }
@@ -241,8 +231,7 @@ private void locateTemplateMatchesDebug(Mat roiImage, Mat templateImage, org.ope
     }
 
     @Override
-    public Location getPartBottomOffsets(Part part, Nozzle nozzle)
-            throws Exception {
+    public Location getPartBottomOffsets(Part part, Nozzle nozzle) throws Exception {
         if (camera.getLooking() != Looking.Up) {
             throw new Exception("Bottom vision only implemented for Up looking cameras");
         }
@@ -253,7 +242,7 @@ public Location getPartBottomOffsets(Part part, Nozzle nozzle)
         // Then move to the camera in X, Y at Safe-Z and rotate the
         // part to 0.
         nozzle.moveTo(camera.getLocation().derive(null, null, Double.NaN, 0.0), 1.0);
-        // Then lower the part to the Camera's focal point in Z. Maintain the 
+        // Then lower the part to the Camera's focal point in Z. Maintain the
         // part's rotation at 0.
         nozzle.moveTo(camera.getLocation().derive(null, null, null, Double.NaN), 1.0);
         // Grab an image.
@@ -261,26 +250,24 @@ public Location getPartBottomOffsets(Part part, Nozzle nozzle)
         // TODO: Do OpenCV magic
         // Return the offsets. Make sure to convert them to real units instead
         // of pixels. Use camera.getUnitsPerPixel().
-        
+
         Thread.sleep(1000);
 
         // rotate the nozzle to simulate the part being oriented
         nozzle.moveTo(nozzle.getLocation().derive(null, null, null, 45.0), 1.0);
-        
+
         Thread.sleep(1000);
-        
+
         // Return to Safe-Z just to be safe.
         nozzle.moveToSafeZ(1.0);
         return new Location(LengthUnit.Millimeters, 0, 0, 0, 0);
-    } 
-    
+    }
+
     enum MinMaxState {
-        BEFORE_INFLECTION,
-        AFTER_INFLECTION
+        BEFORE_INFLECTION, AFTER_INFLECTION
     }
-    
-    static List<Point> matMaxima(Mat mat, double rangeMin,
-            double rangeMax) {
+
+    static List<Point> matMaxima(Mat mat, double rangeMin, double rangeMax) {
         List<Point> locations = new ArrayList<>();
 
         int rEnd = mat.rows() - 1;
@@ -308,29 +295,25 @@ else if (curVal < val) {
                     if (state == MinMaxState.BEFORE_INFLECTION) {
                         if (rangeMin <= curVal && curVal <= rangeMax) { // ROW
                                                                         // MAXIMA
-                            if (0 < r
-                                    && (mat.get(r - 1, c - 1)[0] >= curVal || mat
-                                            .get(r - 1, c)[0] >= curVal)) {
+                            if (0 < r && (mat.get(r - 1, c - 1)[0] >= curVal
+                                    || mat.get(r - 1, c)[0] >= curVal)) {
                                 // cout << "reject:r-1 " << r << "," << c-1 <<
                                 // endl;
                                 // - x x
                                 // - - -
                                 // - - -
                             }
-                            else if (r < rEnd
-                                    && (mat.get(r + 1, c - 1)[0] > curVal || mat
-                                            .get(r + 1, c)[0] > curVal)) {
+                            else if (r < rEnd && (mat.get(r + 1, c - 1)[0] > curVal
+                                    || mat.get(r + 1, c)[0] > curVal)) {
                                 // cout << "reject:r+1 " << r << "," << c-1 <<
                                 // endl;
                                 // - - -
                                 // - - -
                                 // - x x
                             }
-                            else if (1 < c
-                                    && (0 < r
-                                            && mat.get(r - 1, c - 2)[0] >= curVal
-                                            || mat.get(r, c - 2)[0] > curVal || r < rEnd
-                                            && mat.get(r + 1, c - 2)[0] > curVal)) {
+                            else if (1 < c && (0 < r && mat.get(r - 1, c - 2)[0] >= curVal
+                                    || mat.get(r, c - 2)[0] > curVal
+                                    || r < rEnd && mat.get(r + 1, c - 2)[0] > curVal)) {
                                 // cout << "reject:c-2 " << r << "," << c-1 <<
                                 // endl;
                                 // x - -
@@ -354,18 +337,16 @@ else if (1 < c
             // PROCESS END OF ROW
             if (state == MinMaxState.BEFORE_INFLECTION) {
                 if (rangeMin <= curVal && curVal <= rangeMax) { // ROW MAXIMA
-                    if (0 < r
-                            && (mat.get(r - 1, cEnd - 1)[0] >= curVal || mat
-                                    .get(r - 1, cEnd)[0] >= curVal)) {
+                    if (0 < r && (mat.get(r - 1, cEnd - 1)[0] >= curVal
+                            || mat.get(r - 1, cEnd)[0] >= curVal)) {
                         // cout << "rejectEnd:r-1 " << r << "," << cEnd-1 <<
                         // endl;
                         // - x x
                         // - - -
                         // - - -
                     }
-                    else if (r < rEnd
-                            && (mat.get(r + 1, cEnd - 1)[0] > curVal || mat
-                                    .get(r + 1, cEnd)[0] > curVal)) {
+                    else if (r < rEnd && (mat.get(r + 1, cEnd - 1)[0] > curVal
+                            || mat.get(r + 1, cEnd)[0] > curVal)) {
                         // cout << "rejectEnd:r+1 " << r << "," << cEnd-1 <<
                         // endl;
                         // - - -
@@ -373,8 +354,8 @@ else if (r < rEnd
                         // - x x
                     }
                     else if (1 < r && mat.get(r - 1, cEnd - 2)[0] >= curVal
-                            || mat.get(r, cEnd - 2)[0] > curVal || r < rEnd
-                            && mat.get(r + 1, cEnd - 2)[0] > curVal) {
+                            || mat.get(r, cEnd - 2)[0] > curVal
+                            || r < rEnd && mat.get(r + 1, cEnd - 2)[0] > curVal) {
                         // cout << "rejectEnd:cEnd-2 " << r << "," << cEnd-1 <<
                         // endl;
                         // x - -
@@ -389,5 +370,5 @@ else if (1 < r && mat.get(r - 1, cEnd - 2)[0] >= curVal
         }
 
         return locations;
-    }        
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/vision/wizards/OpenCvVisionProviderConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/vision/wizards/OpenCvVisionProviderConfigurationWizard.java
index e73b73014f..e32524e08b 100755
--- a/src/main/java/org/openpnp/machine/reference/vision/wizards/OpenCvVisionProviderConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/vision/wizards/OpenCvVisionProviderConfigurationWizard.java
@@ -1,47 +1,44 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.vision.wizards;
 
+import javax.swing.JLabel;
 import javax.swing.JPanel;
 
 import org.openpnp.gui.support.AbstractConfigurationWizard;
 import org.openpnp.machine.reference.vision.OpenCvVisionProvider;
-import javax.swing.JLabel;
 
 @SuppressWarnings("serial")
 public class OpenCvVisionProviderConfigurationWizard extends AbstractConfigurationWizard {
-	private final OpenCvVisionProvider visionProvider;
-
-	private JPanel panelGeneral;
-
-	public OpenCvVisionProviderConfigurationWizard(
-			OpenCvVisionProvider visionProvider) {
-		this.visionProvider = visionProvider;
-		
-		JLabel lblOpencvvisionproviderconfigurationwizardPlaceholder = new JLabel("OpenCvVisionProviderConfigurationWizard Placeholder");
-		contentPanel.add(lblOpencvvisionproviderconfigurationwizardPlaceholder);
-	}
-
-	@Override
-	public void createBindings() {
-	}
-}
\ No newline at end of file
+    private final OpenCvVisionProvider visionProvider;
+
+    private JPanel panelGeneral;
+
+    public OpenCvVisionProviderConfigurationWizard(OpenCvVisionProvider visionProvider) {
+        this.visionProvider = visionProvider;
+
+        JLabel lblOpencvvisionproviderconfigurationwizardPlaceholder =
+                new JLabel("OpenCvVisionProviderConfigurationWizard Placeholder");
+        contentPanel.add(lblOpencvvisionproviderconfigurationwizardPlaceholder);
+    }
+
+    @Override
+    public void createBindings() {}
+}
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceActuatorConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceActuatorConfigurationWizard.java
index aad1270ccb..51a480ec4e 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceActuatorConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceActuatorConfigurationWizard.java
@@ -117,7 +117,7 @@ public ReferenceActuatorConfigurationWizard(ReferenceActuator actuator) {
     public void createBindings() {
         System.out.println(Configuration.get().getMachine().getActuators());
         System.out.println(Configuration.get().getMachine().getActuatorByName("AM1"));
-        
+
         LengthConverter lengthConverter = new LengthConverter();
 
         MutableLocationProxy headOffsets = new MutableLocationProxy();
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceCameraConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceCameraConfigurationWizard.java
index 82a04dd34c..7cc6a29303 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceCameraConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceCameraConfigurationWizard.java
@@ -8,7 +8,6 @@
 import javax.swing.JButton;
 import javax.swing.JCheckBox;
 import javax.swing.JLabel;
-import javax.swing.JOptionPane;
 import javax.swing.JPanel;
 import javax.swing.JTextField;
 import javax.swing.border.EtchedBorder;
@@ -33,10 +32,9 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 @SuppressWarnings("serial")
-public class ReferenceCameraConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferenceCameraConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferenceCamera referenceCamera;
-    
+
     private JTextField textFieldOffX;
     private JTextField textFieldOffY;
     private JTextField textFieldOffZ;
@@ -66,212 +64,181 @@
     private JPanel panelLensCalibration;
     private JLabel lblApplyCalibration;
     private JCheckBox calibrationEnabledChk;
-    
-    
+
+
     public ReferenceCameraConfigurationWizard(ReferenceCamera referenceCamera) {
         this.referenceCamera = referenceCamera;
-        
-                panelOffsets = new JPanel();
-                contentPanel.add(panelOffsets);
-                panelOffsets.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "Offsets", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
-                panelOffsets.setLayout(new FormLayout(new ColumnSpec[] {
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,},
-                    new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,}));
-                
-                        JLabel olblX = new JLabel("X");
-                        panelOffsets.add(olblX, "2, 2");
-                        
-                                JLabel olblY = new JLabel("Y");
-                                panelOffsets.add(olblY, "4, 2");
-                                
-                                        JLabel olblZ = new JLabel("Z");
-                                        panelOffsets.add(olblZ, "6, 2");
-                                        
-                                        
-                                        textFieldOffX = new JTextField();
-                                        panelOffsets.add(textFieldOffX, "2, 4");
-                                        textFieldOffX.setColumns(8);
-                                        
-                                                textFieldOffY = new JTextField();
-                                                panelOffsets.add(textFieldOffY, "4, 4");
-                                                textFieldOffY.setColumns(8);
-                                                
-                                                        textFieldOffZ = new JTextField();
-                                                        panelOffsets.add(textFieldOffZ, "6, 4");
-                                                        textFieldOffZ.setColumns(8);
-                                                        
-                                                        JPanel panelSafeZ = new JPanel();
-                                                        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-                                                        contentPanel.add(panelSafeZ);
-                                                        panelSafeZ.setLayout(new FormLayout(new ColumnSpec[] {
-                                                        		FormSpecs.RELATED_GAP_COLSPEC,
-                                                        		FormSpecs.DEFAULT_COLSPEC,
-                                                        		FormSpecs.RELATED_GAP_COLSPEC,
-                                                        		FormSpecs.DEFAULT_COLSPEC,},
-                                                        	new RowSpec[] {
-                                                        		FormSpecs.RELATED_GAP_ROWSPEC,
-                                                        		FormSpecs.DEFAULT_ROWSPEC,}));
-                                                        
-                                                        JLabel lblSafeZ = new JLabel("Safe Z");
-                                                        panelSafeZ.add(lblSafeZ, "2, 2, right, default");
-                                                        
-                                                        textFieldSafeZ = new JTextField();
-                                                        panelSafeZ.add(textFieldSafeZ, "4, 2, fill, default");
-                                                        textFieldSafeZ.setColumns(10);
-                                                        
-        
+
+        panelOffsets = new JPanel();
+        contentPanel.add(panelOffsets);
+        panelOffsets.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Offsets", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelOffsets.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JLabel olblX = new JLabel("X");
+        panelOffsets.add(olblX, "2, 2");
+
+        JLabel olblY = new JLabel("Y");
+        panelOffsets.add(olblY, "4, 2");
+
+        JLabel olblZ = new JLabel("Z");
+        panelOffsets.add(olblZ, "6, 2");
+
+
+        textFieldOffX = new JTextField();
+        panelOffsets.add(textFieldOffX, "2, 4");
+        textFieldOffX.setColumns(8);
+
+        textFieldOffY = new JTextField();
+        panelOffsets.add(textFieldOffY, "4, 4");
+        textFieldOffY.setColumns(8);
+
+        textFieldOffZ = new JTextField();
+        panelOffsets.add(textFieldOffZ, "6, 4");
+        textFieldOffZ.setColumns(8);
+
+        JPanel panelSafeZ = new JPanel();
+        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        contentPanel.add(panelSafeZ);
+        panelSafeZ.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        JLabel lblSafeZ = new JLabel("Safe Z");
+        panelSafeZ.add(lblSafeZ, "2, 2, right, default");
+
+        textFieldSafeZ = new JTextField();
+        panelSafeZ.add(textFieldSafeZ, "4, 2, fill, default");
+        textFieldSafeZ.setColumns(10);
+
+
         panelGeneral = new JPanel();
-        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "Transformation", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Transformation", TitledBorder.LEADING, TitledBorder.TOP, null,
+                new Color(0, 0, 0)));
         contentPanel.add(panelGeneral);
-        panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		ColumnSpec.decode("default:grow"),},
-        	new RowSpec[] {
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         lblRotation = new JLabel("Rotation");
         panelGeneral.add(lblRotation, "2, 2, right, default");
-        
+
         textFieldRotation = new JTextField();
         panelGeneral.add(textFieldRotation, "4, 2");
         textFieldRotation.setColumns(10);
-        
+
         lblOffsetX = new JLabel("Offset X");
         panelGeneral.add(lblOffsetX, "2, 4, right, default");
-        
+
         textFieldOffsetX = new JTextField();
         panelGeneral.add(textFieldOffsetX, "4, 4");
         textFieldOffsetX.setColumns(10);
-        
+
         lblOffsetY = new JLabel("Offset Y");
         panelGeneral.add(lblOffsetY, "2, 6, right, default");
-        
+
         textFieldOffsetY = new JTextField();
         panelGeneral.add(textFieldOffsetY, "4, 6");
         textFieldOffsetY.setColumns(10);
-        
+
         lblFlipX = new JLabel("Flip Vertical");
         panelGeneral.add(lblFlipX, "2, 8, right, default");
-        
+
         chckbxFlipX = new JCheckBox("");
         panelGeneral.add(chckbxFlipX, "4, 8");
-        
+
         lblFlipY = new JLabel("Flip Horizontal");
         panelGeneral.add(lblFlipY, "2, 10, right, default");
-        
+
         checkBoxFlipY = new JCheckBox("");
         panelGeneral.add(checkBoxFlipY, "4, 10");
-        
+
         panelLocation = new JPanel();
-        panelLocation.setBorder(new TitledBorder(null, "Location", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelLocation.setBorder(new TitledBorder(null, "Location", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelLocation);
-        panelLocation.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                RowSpec.decode("default:grow"),}));
-        
+        panelLocation.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, RowSpec.decode("default:grow"),}));
+
         lblX = new JLabel("X");
         panelLocation.add(lblX, "2, 2");
-        
+
         lblY = new JLabel("Y");
         panelLocation.add(lblY, "4, 2");
-        
+
         lblZ = new JLabel("Z");
         panelLocation.add(lblZ, "6, 2");
-        
+
         lblRotation_1 = new JLabel("Rotation");
         panelLocation.add(lblRotation_1, "8, 2");
-        
+
         textFieldLocationX = new JTextField();
         panelLocation.add(textFieldLocationX, "2, 4, fill, default");
         textFieldLocationX.setColumns(8);
-        
+
         textFieldLocationY = new JTextField();
         panelLocation.add(textFieldLocationY, "4, 4, fill, default");
         textFieldLocationY.setColumns(8);
-        
+
         textFieldLocationZ = new JTextField();
         panelLocation.add(textFieldLocationZ, "6, 4, fill, default");
         textFieldLocationZ.setColumns(8);
-        
+
         textFieldLocationRotation = new JTextField();
         panelLocation.add(textFieldLocationRotation, "8, 4, fill, default");
         textFieldLocationRotation.setColumns(8);
-        
+
         panelLensCalibration = new JPanel();
-        panelLensCalibration.setBorder(new TitledBorder(null, "Lens Calibration", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelLensCalibration.setBorder(new TitledBorder(null, "Lens Calibration",
+                TitledBorder.LEADING, TitledBorder.TOP, null, null));
         contentPanel.add(panelLensCalibration);
-        panelLensCalibration.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelLensCalibration.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         startLensCalibrationBtn = new JButton(startCalibration);
         panelLensCalibration.add(startLensCalibrationBtn, "2, 2, 3, 1");
-        
+
         lblApplyCalibration = new JLabel("Apply Calibration?");
         panelLensCalibration.add(lblApplyCalibration, "2, 4, right, default");
-        
+
         calibrationEnabledChk = new JCheckBox("");
         panelLensCalibration.add(calibrationEnabledChk, "4, 4");
-        
+
         try {
             // Causes WindowBuilder to fail, so just throw away the error.
             if (referenceCamera.getHead() == null) {
-                locationButtonsPanel = new LocationButtonsPanel(textFieldLocationX, textFieldLocationY, textFieldLocationZ, textFieldLocationRotation);
+                locationButtonsPanel = new LocationButtonsPanel(textFieldLocationX,
+                        textFieldLocationY, textFieldLocationZ, textFieldLocationRotation);
                 panelLocation.add(locationButtonsPanel, "10, 4, fill, fill");
                 panelOffsets.setVisible(false);
             }
@@ -280,29 +247,33 @@ public ReferenceCameraConfigurationWizard(ReferenceCamera referenceCamera) {
             }
         }
         catch (Exception e) {
-            
+
         }
     }
-    
+
     @Override
     public void createBindings() {
-    	IntegerConverter intConverter = new IntegerConverter();
-        DoubleConverter doubleConverter = new DoubleConverter(Configuration.get().getLengthDisplayFormat());
+        IntegerConverter intConverter = new IntegerConverter();
+        DoubleConverter doubleConverter =
+                new DoubleConverter(Configuration.get().getLengthDisplayFormat());
         LengthConverter lengthConverter = new LengthConverter();
 
         if (referenceCamera.getHead() == null) {
             // fixed camera
             MutableLocationProxy headOffsets = new MutableLocationProxy();
-            bind(UpdateStrategy.READ_WRITE, referenceCamera, "headOffsets", headOffsets, "location");
+            bind(UpdateStrategy.READ_WRITE, referenceCamera, "headOffsets", headOffsets,
+                    "location");
             addWrappedBinding(headOffsets, "lengthX", textFieldLocationX, "text", lengthConverter);
             addWrappedBinding(headOffsets, "lengthY", textFieldLocationY, "text", lengthConverter);
             addWrappedBinding(headOffsets, "lengthZ", textFieldLocationZ, "text", lengthConverter);
-            addWrappedBinding(headOffsets, "rotation", textFieldLocationRotation, "text", doubleConverter);
+            addWrappedBinding(headOffsets, "rotation", textFieldLocationRotation, "text",
+                    doubleConverter);
         }
         else {
             // moving camera
             MutableLocationProxy headOffsets = new MutableLocationProxy();
-            bind(UpdateStrategy.READ_WRITE, referenceCamera, "headOffsets", headOffsets, "location");
+            bind(UpdateStrategy.READ_WRITE, referenceCamera, "headOffsets", headOffsets,
+                    "location");
             addWrappedBinding(headOffsets, "lengthX", textFieldOffX, "text", lengthConverter);
             addWrappedBinding(headOffsets, "lengthY", textFieldOffY, "text", lengthConverter);
             addWrappedBinding(headOffsets, "lengthZ", textFieldOffZ, "text", lengthConverter);
@@ -314,60 +285,64 @@ public void createBindings() {
         addWrappedBinding(referenceCamera, "flipX", chckbxFlipX, "selected");
         addWrappedBinding(referenceCamera, "flipY", checkBoxFlipY, "selected");
         addWrappedBinding(referenceCamera, "safeZ", textFieldSafeZ, "text", lengthConverter);
-        
-        bind(UpdateStrategy.READ_WRITE, referenceCamera.getCalibration(), "enabled", calibrationEnabledChk, "selected");
-//        addWrappedBinding(referenceCamera.getCalibration(), "enabled", calibrationEnabledChk, "selected");
-        
+
+        bind(UpdateStrategy.READ_WRITE, referenceCamera.getCalibration(), "enabled",
+                calibrationEnabledChk, "selected");
+        // addWrappedBinding(referenceCamera.getCalibration(), "enabled", calibrationEnabledChk,
+        // "selected");
+
         ComponentDecorators.decorateWithAutoSelect(textFieldRotation);
         ComponentDecorators.decorateWithAutoSelect(textFieldOffsetX);
         ComponentDecorators.decorateWithAutoSelect(textFieldOffsetY);
-        
+
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldOffX);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldOffY);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldOffZ);
-        
+
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationX);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationY);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationZ);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldLocationRotation);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSafeZ);
     }
-    
+
     private Action startCalibration = new AbstractAction("Start Lens Calibration") {
         @Override
         public void actionPerformed(ActionEvent e) {
             MainFrame.cameraPanel.setSelectedCamera(referenceCamera);
-            
+
             startLensCalibrationBtn.setAction(cancelCalibration);
-            
+
             CameraView cameraView = MainFrame.cameraPanel.getCameraView(referenceCamera);
-            String message = 
-                    "Go to https://github.com/openpnp/openpnp/wiki/Camera-Lens-Calibration for detailed instructions.\n" +
-                    "When you have your calibration card ready, hold it in front of the camera so that the entire card is visible.\n" +
-                    "Each time the screen flashes an image is captured. After the flash you should move the card to a new orientation.";
+            String message =
+                    "Go to https://github.com/openpnp/openpnp/wiki/Camera-Lens-Calibration for detailed instructions.\n"
+                            + "When you have your calibration card ready, hold it in front of the camera so that the entire card is visible.\n"
+                            + "Each time the screen flashes an image is captured. After the flash you should move the card to a new orientation.";
             cameraView.setText(message);
             cameraView.flash();
-            
+
             referenceCamera.startCalibration((progressCurrent, progressMax, finished) -> {
                 if (finished) {
                     cameraView.setText(null);
                     startLensCalibrationBtn.setAction(startCalibration);
                 }
                 else {
-                    cameraView.setText(String.format("Captured %d of %d.\nMove the card to a new position and angle each time the screen flashes.", progressCurrent, progressMax));
+                    cameraView.setText(String.format(
+                            "Captured %d of %d.\nMove the card to a new position and angle each time the screen flashes.",
+                            progressCurrent, progressMax));
                 }
                 cameraView.flash();
             });
         }
     };
-    
+
     private Action cancelCalibration = new AbstractAction("Cancel Lens Calibration") {
         @Override
         public void actionPerformed(ActionEvent e) {
             startLensCalibrationBtn.setAction(startCalibration);
-            
+
             referenceCamera.cancelCalibration();
-            
+
             CameraView cameraView = MainFrame.cameraPanel.getCameraView(referenceCamera);
             cameraView.setText(null);
             cameraView.flash();
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceHeadConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceHeadConfigurationWizard.java
index 166224a697..ba065bfd63 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceHeadConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceHeadConfigurationWizard.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.machine.reference.wizards;
 
@@ -56,428 +54,427 @@
 
 @SuppressWarnings("serial")
 public class ReferenceHeadConfigurationWizard extends JPanel implements Wizard {
-	private final ReferenceHead head;
-	
-	private JCheckBox chckbxSoftLimitsEnabled;
-	private JTextField textFieldFeedRate;
-	private JTextField textFieldPickDwell;
-	private JTextField textFieldPlaceDwell;
-	private JLabel lblNewLabel;
-	private JLabel lblX;
-	private JLabel lblY;
-	private JLabel lblZ;
-	private JLabel lblC;
-	private JTextField textFieldSoftLimitsXMin;
-	private JTextField textFieldSoftLimitsXMax;
-	private JLabel lblMinimum;
-	private JLabel lblMacimum;
-	private JTextField textFieldSoftLimitsYMin;
-	private JTextField textFieldSoftLimitsYMax;
-	private JTextField textFieldSoftLimitsZMin;
-	private JTextField textFieldSoftLimitsZMax;
-	private JTextField textFieldSoftLimitsCMin;
-	private JTextField textFieldSoftLimitsCMax;
-	private JCheckBox chckbxVisionEnabled;
-	private JLabel lblHomingDotDiameter;
-	private JLabel lblNewLabel_1;
-	private JTextField textFieldHomingDotDiameter;
-	private JLabel lblX_1;
-	private JLabel lblY_1;
-	private JLabel lblZ_1;
-	private JTextField textFieldHomingDotX;
-	private JTextField textFieldHomingDotY;
-	private JTextField textFieldHomingDotZ;
-	private JButton btnSave;
-	private JButton btnCancel;
-	
-	private WizardContainer wizardContainer; 
-	private JPanel panelGeneral;
-	private JPanel panelSoftLimits;
-	private JPanel panelHoming;
-	private JPanel panelVision;
-	private JPanel panelActions;
-	private JLabel lblX_2;
-	private JLabel lblY_2;
-	private JLabel lblZ_2;
-	private JLabel lblC_1;
-	private JLabel lblHomeLocation;
-	private JTextField textFieldHomeLocationX;
-	private JTextField textFieldHomeLocationY;
-	private JTextField textFieldHomeLocationZ;
-	private JTextField textFieldHomeLocationC;
-	private JScrollPane scrollPane;
-	private JPanel panelMain;
-	
-	private List<WrappedBinding> wrappedBindings = new ArrayList<>();
-	
-	// TODO: Most of what this class did is deprecated and has been moved into
-	// Nozzles, Actuators and Cameras. We may still want to do softlimits, but
-	// these will likely move to the driver. Revisit this and see what is and
-	// isn't needed.
-	public ReferenceHeadConfigurationWizard(ReferenceHead head) {
-		this.head = head;
-		
-		setLayout(new BorderLayout(0, 0));
-		
-		panelMain = new JPanel();
-		
-		scrollPane = new JScrollPane(panelMain);
-		scrollPane.getVerticalScrollBar().setUnitIncrement(Configuration.get().getVerticalScrollUnitIncrement());
-		scrollPane.setBorder(null);
-		panelMain.setLayout(new BoxLayout(panelMain, BoxLayout.Y_AXIS));
-		
-		panelGeneral = new JPanel();
-		panelMain.add(panelGeneral);
-		panelGeneral.setBorder(new TitledBorder(null, "General", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		label = new JLabel("Safe-Z");
-		panelGeneral.add(label, "2, 2, right, default");
-		
-		textFieldSafeZ = new JTextField();
-		textFieldSafeZ.setColumns(8);
-		panelGeneral.add(textFieldSafeZ, "4, 2");
-		
-		JLabel lblFeedRate = new JLabel("Feed Rate (units/min)");
-		panelGeneral.add(lblFeedRate, "6, 2, right, default");
-		
-		textFieldFeedRate = new JTextField();
-		panelGeneral.add(textFieldFeedRate, "8, 2");
-		textFieldFeedRate.setColumns(8);
-		
-		lblNewLabel = new JLabel("Pick Dwell (ms)");
-		panelGeneral.add(lblNewLabel, "2, 4, right, default");
-		
-		textFieldPickDwell = new JTextField();
-		panelGeneral.add(textFieldPickDwell, "4, 4");
-		textFieldPickDwell.setColumns(8);
-		
-		JLabel lblPlaceDwell = new JLabel("Place Dwell (ms)");
-		panelGeneral.add(lblPlaceDwell, "6, 4, right, default");
-		
-		textFieldPlaceDwell = new JTextField();
-		panelGeneral.add(textFieldPlaceDwell, "8, 4");
-		textFieldPlaceDwell.setColumns(8);
-		
-		panelSoftLimits = new JPanel();
-		panelMain.add(panelSoftLimits);
-		panelSoftLimits.setBorder(new TitledBorder(null, "Soft Limits", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		panelSoftLimits.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		chckbxSoftLimitsEnabled = new JCheckBox("Soft Limits Enabled?");
-		panelSoftLimits.add(chckbxSoftLimitsEnabled, "2, 2, 5, 1");
-		
-		lblMinimum = new JLabel("Minimum");
-		panelSoftLimits.add(lblMinimum, "4, 4");
-		
-		lblMacimum = new JLabel("Maximum");
-		panelSoftLimits.add(lblMacimum, "6, 4");
-		
-		lblX = new JLabel("X");
-		panelSoftLimits.add(lblX, "2, 6, right, default");
-		
-		textFieldSoftLimitsXMin = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsXMin, "4, 6");
-		textFieldSoftLimitsXMin.setColumns(5);
-		
-		textFieldSoftLimitsXMax = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsXMax, "6, 6");
-		textFieldSoftLimitsXMax.setColumns(5);
-		
-		lblY = new JLabel("Y");
-		panelSoftLimits.add(lblY, "2, 8, right, default");
-		
-		textFieldSoftLimitsYMin = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsYMin, "4, 8");
-		textFieldSoftLimitsYMin.setColumns(5);
-		
-		textFieldSoftLimitsYMax = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsYMax, "6, 8");
-		textFieldSoftLimitsYMax.setColumns(5);
-		
-		lblZ = new JLabel("Z");
-		panelSoftLimits.add(lblZ, "2, 10, right, default");
-		
-		textFieldSoftLimitsZMin = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsZMin, "4, 10");
-		textFieldSoftLimitsZMin.setColumns(5);
-		
-		textFieldSoftLimitsZMax = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsZMax, "6, 10");
-		textFieldSoftLimitsZMax.setColumns(5);
-		
-		lblC = new JLabel("C");
-		panelSoftLimits.add(lblC, "2, 12, right, default");
-		
-		textFieldSoftLimitsCMin = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsCMin, "4, 12");
-		textFieldSoftLimitsCMin.setColumns(5);
-		
-		textFieldSoftLimitsCMax = new JTextField();
-		panelSoftLimits.add(textFieldSoftLimitsCMax, "6, 12");
-		textFieldSoftLimitsCMax.setColumns(5);
-		
-		panelHoming = new JPanel();
-		panelMain.add(panelHoming);
-		panelHoming.setBorder(new TitledBorder(null, "Homing", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		panelHoming.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		lblX_2 = new JLabel("X");
-		panelHoming.add(lblX_2, "4, 2, center, default");
-		
-		lblY_2 = new JLabel("Y");
-		panelHoming.add(lblY_2, "6, 2, center, default");
-		
-		lblZ_2 = new JLabel("Z");
-		panelHoming.add(lblZ_2, "8, 2, center, default");
-		
-		lblC_1 = new JLabel("C");
-		panelHoming.add(lblC_1, "10, 2, center, default");
-		
-		lblHomeLocation = new JLabel("Home Location");
-		lblHomeLocation.setToolTipText("Coordinates that will be applied when the machine is homed. This is position you want the DROs to show after homing.");
-		panelHoming.add(lblHomeLocation, "2, 4, right, default");
-		
-		textFieldHomeLocationX = new JTextField();
-		panelHoming.add(textFieldHomeLocationX, "4, 4, fill, default");
-		textFieldHomeLocationX.setColumns(5);
-		
-		textFieldHomeLocationY = new JTextField();
-		panelHoming.add(textFieldHomeLocationY, "6, 4, fill, default");
-		textFieldHomeLocationY.setColumns(5);
-		
-		textFieldHomeLocationZ = new JTextField();
-		panelHoming.add(textFieldHomeLocationZ, "8, 4, fill, default");
-		textFieldHomeLocationZ.setColumns(5);
-		
-		textFieldHomeLocationC = new JTextField();
-		panelHoming.add(textFieldHomeLocationC, "10, 4, fill, default");
-		textFieldHomeLocationC.setColumns(5);
-		
-		panelVision = new JPanel();
-		panelMain.add(panelVision);
-		panelVision.setBorder(new TitledBorder(null, "Vision", TitledBorder.LEADING, TitledBorder.TOP, null, null));
-		panelVision.setLayout(new FormLayout(new ColumnSpec[] {
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				FormSpecs.DEFAULT_COLSPEC,
-				FormSpecs.RELATED_GAP_COLSPEC,
-				ColumnSpec.decode("default:grow"),},
-			new RowSpec[] {
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,
-				FormSpecs.RELATED_GAP_ROWSPEC,
-				FormSpecs.DEFAULT_ROWSPEC,}));
-		
-		chckbxVisionEnabled = new JCheckBox("Vision Enabled?");
-		panelVision.add(chckbxVisionEnabled, "2, 2");
-		
-		lblX_1 = new JLabel("X");
-		panelVision.add(lblX_1, "4, 4, center, default");
-		
-		lblY_1 = new JLabel("Y");
-		panelVision.add(lblY_1, "6, 4, center, default");
-		
-		lblZ_1 = new JLabel("Z");
-		panelVision.add(lblZ_1, "8, 4, center, default");
-		
-		lblNewLabel_1 = new JLabel("Homing Dot Location");
-		lblNewLabel_1.setToolTipText("The location of the homing dot in relation to the Home Location. When Vision is used for homing, this will be applied to the DROs after Vision Homing completes.");
-		panelVision.add(lblNewLabel_1, "2, 6, right, default");
-		
-		textFieldHomingDotX = new JTextField();
-		panelVision.add(textFieldHomingDotX, "4, 6");
-		textFieldHomingDotX.setColumns(8);
-		
-		textFieldHomingDotY = new JTextField();
-		panelVision.add(textFieldHomingDotY, "6, 6");
-		textFieldHomingDotY.setColumns(8);
-		
-		textFieldHomingDotZ = new JTextField();
-		panelVision.add(textFieldHomingDotZ, "8, 6");
-		textFieldHomingDotZ.setColumns(8);
-		
-		lblHomingDotDiameter = new JLabel("Homing Dot Diameter (mm)");
-		panelVision.add(lblHomingDotDiameter, "2, 8, right, default");
-		
-		textFieldHomingDotDiameter = new JTextField();
-		panelVision.add(textFieldHomingDotDiameter, "4, 8");
-		textFieldHomingDotDiameter.setColumns(5);
-		add(scrollPane, BorderLayout.CENTER);
-		
-		panelActions = new JPanel();
-		FlowLayout fl_panelActions = (FlowLayout) panelActions.getLayout();
-		fl_panelActions.setAlignment(FlowLayout.RIGHT);
-		add(panelActions, BorderLayout.SOUTH);
-		
-		btnCancel = new JButton(cancelAction);
-		panelActions.add(btnCancel);
-		
-		btnSave = new JButton(saveAction);
-		panelActions.add(btnSave);
-		
-		createBindings();
-		loadFromModel();
-	}
-	
-	private void createBindings() {
-		LengthConverter lengthConverter = new LengthConverter();
-		DoubleConverter doubleConverter = new DoubleConverter(Configuration.get().getLengthDisplayFormat());
-		IntegerConverter integerConverter = new IntegerConverter();
-		ApplyResetBindingListener listener = new ApplyResetBindingListener(saveAction, cancelAction);
-//		wrappedBindings.add(JBindings.bind(head, "safeZ", textFieldSafeZ, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "feedRate", textFieldFeedRate, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "pickDwellMilliseconds", textFieldPickDwell, "text", integerConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "placeDwellMilliseconds", textFieldPlaceDwell, "text", integerConverter, listener));
-
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.enabled", chckbxSoftLimitsEnabled, "selected", listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthX", textFieldSoftLimitsXMin, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthX", textFieldSoftLimitsXMax, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthY", textFieldSoftLimitsYMin, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthY", textFieldSoftLimitsYMax, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthZ", textFieldSoftLimitsZMin, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthZ", textFieldSoftLimitsZMax, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.rotation", textFieldSoftLimitsCMin, "text", doubleConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.rotation", textFieldSoftLimitsCMax, "text", doubleConverter, listener));
-		
-//		wrappedBindings.add(JBindings.bind(head, "homing.location.lengthX", textFieldHomeLocationX, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.location.lengthY", textFieldHomeLocationY, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.location.lengthZ", textFieldHomeLocationZ, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.location.rotation", textFieldHomeLocationC, "text", doubleConverter, listener));
-//		
-//		wrappedBindings.add(JBindings.bind(head, "homing.vision.enabled", chckbxVisionEnabled, "selected", listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotDiameter", textFieldHomingDotDiameter, "text", doubleConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthX", textFieldHomingDotX, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthY", textFieldHomingDotY, "text", lengthConverter, listener));
-//		wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthZ", textFieldHomingDotZ, "text", lengthConverter, listener));
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSafeZ);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedRate);
-		ComponentDecorators.decorateWithAutoSelect(textFieldPickDwell);
-		ComponentDecorators.decorateWithAutoSelect(textFieldPlaceDwell);
-
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsXMin);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsXMax);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsYMin);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsYMax);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsZMin);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsZMax);
-		
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationX);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationY);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationZ);
-		
-		ComponentDecorators.decorateWithAutoSelect(textFieldHomingDotDiameter);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
-		ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
-	}
-	
-	private void loadFromModel() {
-		for (WrappedBinding wrappedBinding : wrappedBindings) {
-			wrappedBinding.reset();
-		}
-		saveAction.setEnabled(false);
-		cancelAction.setEnabled(false);
-	}
-	
-	private void saveToModel() {
-		for (WrappedBinding wrappedBinding : wrappedBindings) {
-			wrappedBinding.save();
-		}
-		saveAction.setEnabled(false);
-		cancelAction.setEnabled(false);
-	}
-	
-	@Override
-	public void setWizardContainer(WizardContainer wizardContainer) {
-		this.wizardContainer = wizardContainer;
-	}
-
-	@Override
-	public JPanel getWizardPanel() {
-		return this;
-	}
-
-	@Override
-	public String getWizardName() {
-		// TODO Auto-generated method stub
-		return null;
-	}
-	
-	private Action saveAction = new AbstractAction("Apply") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			saveToModel();
-			wizardContainer.wizardCompleted(ReferenceHeadConfigurationWizard.this);
-		}
-	};
-	
-	private Action cancelAction = new AbstractAction("Reset") {
-		@Override
-		public void actionPerformed(ActionEvent arg0) {
-			loadFromModel();
-		}
-	};
-	private JLabel label;
-	private JTextField textFieldSafeZ;
+    private final ReferenceHead head;
+
+    private JCheckBox chckbxSoftLimitsEnabled;
+    private JTextField textFieldFeedRate;
+    private JTextField textFieldPickDwell;
+    private JTextField textFieldPlaceDwell;
+    private JLabel lblNewLabel;
+    private JLabel lblX;
+    private JLabel lblY;
+    private JLabel lblZ;
+    private JLabel lblC;
+    private JTextField textFieldSoftLimitsXMin;
+    private JTextField textFieldSoftLimitsXMax;
+    private JLabel lblMinimum;
+    private JLabel lblMacimum;
+    private JTextField textFieldSoftLimitsYMin;
+    private JTextField textFieldSoftLimitsYMax;
+    private JTextField textFieldSoftLimitsZMin;
+    private JTextField textFieldSoftLimitsZMax;
+    private JTextField textFieldSoftLimitsCMin;
+    private JTextField textFieldSoftLimitsCMax;
+    private JCheckBox chckbxVisionEnabled;
+    private JLabel lblHomingDotDiameter;
+    private JLabel lblNewLabel_1;
+    private JTextField textFieldHomingDotDiameter;
+    private JLabel lblX_1;
+    private JLabel lblY_1;
+    private JLabel lblZ_1;
+    private JTextField textFieldHomingDotX;
+    private JTextField textFieldHomingDotY;
+    private JTextField textFieldHomingDotZ;
+    private JButton btnSave;
+    private JButton btnCancel;
+
+    private WizardContainer wizardContainer;
+    private JPanel panelGeneral;
+    private JPanel panelSoftLimits;
+    private JPanel panelHoming;
+    private JPanel panelVision;
+    private JPanel panelActions;
+    private JLabel lblX_2;
+    private JLabel lblY_2;
+    private JLabel lblZ_2;
+    private JLabel lblC_1;
+    private JLabel lblHomeLocation;
+    private JTextField textFieldHomeLocationX;
+    private JTextField textFieldHomeLocationY;
+    private JTextField textFieldHomeLocationZ;
+    private JTextField textFieldHomeLocationC;
+    private JScrollPane scrollPane;
+    private JPanel panelMain;
+
+    private List<WrappedBinding> wrappedBindings = new ArrayList<>();
+
+    // TODO: Most of what this class did is deprecated and has been moved into
+    // Nozzles, Actuators and Cameras. We may still want to do softlimits, but
+    // these will likely move to the driver. Revisit this and see what is and
+    // isn't needed.
+    public ReferenceHeadConfigurationWizard(ReferenceHead head) {
+        this.head = head;
+
+        setLayout(new BorderLayout(0, 0));
+
+        panelMain = new JPanel();
+
+        scrollPane = new JScrollPane(panelMain);
+        scrollPane.getVerticalScrollBar()
+                .setUnitIncrement(Configuration.get().getVerticalScrollUnitIncrement());
+        scrollPane.setBorder(null);
+        panelMain.setLayout(new BoxLayout(panelMain, BoxLayout.Y_AXIS));
+
+        panelGeneral = new JPanel();
+        panelMain.add(panelGeneral);
+        panelGeneral.setBorder(new TitledBorder(null, "General", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelGeneral.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        label = new JLabel("Safe-Z");
+        panelGeneral.add(label, "2, 2, right, default");
+
+        textFieldSafeZ = new JTextField();
+        textFieldSafeZ.setColumns(8);
+        panelGeneral.add(textFieldSafeZ, "4, 2");
+
+        JLabel lblFeedRate = new JLabel("Feed Rate (units/min)");
+        panelGeneral.add(lblFeedRate, "6, 2, right, default");
+
+        textFieldFeedRate = new JTextField();
+        panelGeneral.add(textFieldFeedRate, "8, 2");
+        textFieldFeedRate.setColumns(8);
+
+        lblNewLabel = new JLabel("Pick Dwell (ms)");
+        panelGeneral.add(lblNewLabel, "2, 4, right, default");
+
+        textFieldPickDwell = new JTextField();
+        panelGeneral.add(textFieldPickDwell, "4, 4");
+        textFieldPickDwell.setColumns(8);
+
+        JLabel lblPlaceDwell = new JLabel("Place Dwell (ms)");
+        panelGeneral.add(lblPlaceDwell, "6, 4, right, default");
+
+        textFieldPlaceDwell = new JTextField();
+        panelGeneral.add(textFieldPlaceDwell, "8, 4");
+        textFieldPlaceDwell.setColumns(8);
+
+        panelSoftLimits = new JPanel();
+        panelMain.add(panelSoftLimits);
+        panelSoftLimits.setBorder(new TitledBorder(null, "Soft Limits", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelSoftLimits.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        chckbxSoftLimitsEnabled = new JCheckBox("Soft Limits Enabled?");
+        panelSoftLimits.add(chckbxSoftLimitsEnabled, "2, 2, 5, 1");
+
+        lblMinimum = new JLabel("Minimum");
+        panelSoftLimits.add(lblMinimum, "4, 4");
+
+        lblMacimum = new JLabel("Maximum");
+        panelSoftLimits.add(lblMacimum, "6, 4");
+
+        lblX = new JLabel("X");
+        panelSoftLimits.add(lblX, "2, 6, right, default");
+
+        textFieldSoftLimitsXMin = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsXMin, "4, 6");
+        textFieldSoftLimitsXMin.setColumns(5);
+
+        textFieldSoftLimitsXMax = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsXMax, "6, 6");
+        textFieldSoftLimitsXMax.setColumns(5);
+
+        lblY = new JLabel("Y");
+        panelSoftLimits.add(lblY, "2, 8, right, default");
+
+        textFieldSoftLimitsYMin = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsYMin, "4, 8");
+        textFieldSoftLimitsYMin.setColumns(5);
+
+        textFieldSoftLimitsYMax = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsYMax, "6, 8");
+        textFieldSoftLimitsYMax.setColumns(5);
+
+        lblZ = new JLabel("Z");
+        panelSoftLimits.add(lblZ, "2, 10, right, default");
+
+        textFieldSoftLimitsZMin = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsZMin, "4, 10");
+        textFieldSoftLimitsZMin.setColumns(5);
+
+        textFieldSoftLimitsZMax = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsZMax, "6, 10");
+        textFieldSoftLimitsZMax.setColumns(5);
+
+        lblC = new JLabel("C");
+        panelSoftLimits.add(lblC, "2, 12, right, default");
+
+        textFieldSoftLimitsCMin = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsCMin, "4, 12");
+        textFieldSoftLimitsCMin.setColumns(5);
+
+        textFieldSoftLimitsCMax = new JTextField();
+        panelSoftLimits.add(textFieldSoftLimitsCMax, "6, 12");
+        textFieldSoftLimitsCMax.setColumns(5);
+
+        panelHoming = new JPanel();
+        panelMain.add(panelHoming);
+        panelHoming.setBorder(new TitledBorder(null, "Homing", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelHoming
+                .setLayout(
+                        new FormLayout(
+                                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                                        FormSpecs.DEFAULT_COLSPEC, FormSpecs.RELATED_GAP_COLSPEC,
+                                        ColumnSpec.decode("default:grow"),
+                                        FormSpecs.RELATED_GAP_COLSPEC,
+                                        ColumnSpec.decode("default:grow"),
+                                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec
+                                                .decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        lblX_2 = new JLabel("X");
+        panelHoming.add(lblX_2, "4, 2, center, default");
+
+        lblY_2 = new JLabel("Y");
+        panelHoming.add(lblY_2, "6, 2, center, default");
+
+        lblZ_2 = new JLabel("Z");
+        panelHoming.add(lblZ_2, "8, 2, center, default");
+
+        lblC_1 = new JLabel("C");
+        panelHoming.add(lblC_1, "10, 2, center, default");
+
+        lblHomeLocation = new JLabel("Home Location");
+        lblHomeLocation.setToolTipText(
+                "Coordinates that will be applied when the machine is homed. This is position you want the DROs to show after homing.");
+        panelHoming.add(lblHomeLocation, "2, 4, right, default");
+
+        textFieldHomeLocationX = new JTextField();
+        panelHoming.add(textFieldHomeLocationX, "4, 4, fill, default");
+        textFieldHomeLocationX.setColumns(5);
+
+        textFieldHomeLocationY = new JTextField();
+        panelHoming.add(textFieldHomeLocationY, "6, 4, fill, default");
+        textFieldHomeLocationY.setColumns(5);
+
+        textFieldHomeLocationZ = new JTextField();
+        panelHoming.add(textFieldHomeLocationZ, "8, 4, fill, default");
+        textFieldHomeLocationZ.setColumns(5);
+
+        textFieldHomeLocationC = new JTextField();
+        panelHoming.add(textFieldHomeLocationC, "10, 4, fill, default");
+        textFieldHomeLocationC.setColumns(5);
+
+        panelVision = new JPanel();
+        panelMain.add(panelVision);
+        panelVision.setBorder(new TitledBorder(null, "Vision", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
+        panelVision.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
+        chckbxVisionEnabled = new JCheckBox("Vision Enabled?");
+        panelVision.add(chckbxVisionEnabled, "2, 2");
+
+        lblX_1 = new JLabel("X");
+        panelVision.add(lblX_1, "4, 4, center, default");
+
+        lblY_1 = new JLabel("Y");
+        panelVision.add(lblY_1, "6, 4, center, default");
+
+        lblZ_1 = new JLabel("Z");
+        panelVision.add(lblZ_1, "8, 4, center, default");
+
+        lblNewLabel_1 = new JLabel("Homing Dot Location");
+        lblNewLabel_1.setToolTipText(
+                "The location of the homing dot in relation to the Home Location. When Vision is used for homing, this will be applied to the DROs after Vision Homing completes.");
+        panelVision.add(lblNewLabel_1, "2, 6, right, default");
+
+        textFieldHomingDotX = new JTextField();
+        panelVision.add(textFieldHomingDotX, "4, 6");
+        textFieldHomingDotX.setColumns(8);
+
+        textFieldHomingDotY = new JTextField();
+        panelVision.add(textFieldHomingDotY, "6, 6");
+        textFieldHomingDotY.setColumns(8);
+
+        textFieldHomingDotZ = new JTextField();
+        panelVision.add(textFieldHomingDotZ, "8, 6");
+        textFieldHomingDotZ.setColumns(8);
+
+        lblHomingDotDiameter = new JLabel("Homing Dot Diameter (mm)");
+        panelVision.add(lblHomingDotDiameter, "2, 8, right, default");
+
+        textFieldHomingDotDiameter = new JTextField();
+        panelVision.add(textFieldHomingDotDiameter, "4, 8");
+        textFieldHomingDotDiameter.setColumns(5);
+        add(scrollPane, BorderLayout.CENTER);
+
+        panelActions = new JPanel();
+        FlowLayout fl_panelActions = (FlowLayout) panelActions.getLayout();
+        fl_panelActions.setAlignment(FlowLayout.RIGHT);
+        add(panelActions, BorderLayout.SOUTH);
+
+        btnCancel = new JButton(cancelAction);
+        panelActions.add(btnCancel);
+
+        btnSave = new JButton(saveAction);
+        panelActions.add(btnSave);
+
+        createBindings();
+        loadFromModel();
+    }
+
+    private void createBindings() {
+        LengthConverter lengthConverter = new LengthConverter();
+        DoubleConverter doubleConverter =
+                new DoubleConverter(Configuration.get().getLengthDisplayFormat());
+        IntegerConverter integerConverter = new IntegerConverter();
+        ApplyResetBindingListener listener =
+                new ApplyResetBindingListener(saveAction, cancelAction);
+                // wrappedBindings.add(JBindings.bind(head, "safeZ", textFieldSafeZ, "text",
+                // lengthConverter, listener));
+                // wrappedBindings.add(JBindings.bind(head, "feedRate", textFieldFeedRate, "text",
+                // lengthConverter, listener));
+                // wrappedBindings.add(JBindings.bind(head, "pickDwellMilliseconds",
+                // textFieldPickDwell, "text", integerConverter, listener));
+                // wrappedBindings.add(JBindings.bind(head, "placeDwellMilliseconds",
+                // textFieldPlaceDwell, "text", integerConverter, listener));
+
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.enabled", chckbxSoftLimitsEnabled,
+        // "selected", listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthX",
+        // textFieldSoftLimitsXMin, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthX",
+        // textFieldSoftLimitsXMax, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthY",
+        // textFieldSoftLimitsYMin, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthY",
+        // textFieldSoftLimitsYMax, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.lengthZ",
+        // textFieldSoftLimitsZMin, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.lengthZ",
+        // textFieldSoftLimitsZMax, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.minimums.rotation",
+        // textFieldSoftLimitsCMin, "text", doubleConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "softLimits.maximums.rotation",
+        // textFieldSoftLimitsCMax, "text", doubleConverter, listener));
+
+        // wrappedBindings.add(JBindings.bind(head, "homing.location.lengthX",
+        // textFieldHomeLocationX, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.location.lengthY",
+        // textFieldHomeLocationY, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.location.lengthZ",
+        // textFieldHomeLocationZ, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.location.rotation",
+        // textFieldHomeLocationC, "text", doubleConverter, listener));
+        //
+        // wrappedBindings.add(JBindings.bind(head, "homing.vision.enabled", chckbxVisionEnabled,
+        // "selected", listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotDiameter",
+        // textFieldHomingDotDiameter, "text", doubleConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthX",
+        // textFieldHomingDotX, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthY",
+        // textFieldHomingDotY, "text", lengthConverter, listener));
+        // wrappedBindings.add(JBindings.bind(head, "homing.vision.homingDotLocation.lengthZ",
+        // textFieldHomingDotZ, "text", lengthConverter, listener));
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSafeZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldFeedRate);
+        ComponentDecorators.decorateWithAutoSelect(textFieldPickDwell);
+        ComponentDecorators.decorateWithAutoSelect(textFieldPlaceDwell);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsXMin);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsXMax);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsYMin);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsYMax);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsZMin);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSoftLimitsZMax);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomeLocationZ);
+
+        ComponentDecorators.decorateWithAutoSelect(textFieldHomingDotDiameter);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldHomingDotX);
+    }
+
+    private void loadFromModel() {
+        for (WrappedBinding wrappedBinding : wrappedBindings) {
+            wrappedBinding.reset();
+        }
+        saveAction.setEnabled(false);
+        cancelAction.setEnabled(false);
+    }
+
+    private void saveToModel() {
+        for (WrappedBinding wrappedBinding : wrappedBindings) {
+            wrappedBinding.save();
+        }
+        saveAction.setEnabled(false);
+        cancelAction.setEnabled(false);
+    }
+
+    @Override
+    public void setWizardContainer(WizardContainer wizardContainer) {
+        this.wizardContainer = wizardContainer;
+    }
+
+    @Override
+    public JPanel getWizardPanel() {
+        return this;
+    }
+
+    @Override
+    public String getWizardName() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    private Action saveAction = new AbstractAction("Apply") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            saveToModel();
+            wizardContainer.wizardCompleted(ReferenceHeadConfigurationWizard.this);
+        }
+    };
+
+    private Action cancelAction = new AbstractAction("Reset") {
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            loadFromModel();
+        }
+    };
+    private JLabel label;
+    private JTextField textFieldSafeZ;
 }
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceJobProcessorConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceJobProcessorConfigurationWizard.java
index 81aefb973f..32210b106c 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceJobProcessorConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceJobProcessorConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.wizards;
@@ -36,40 +34,36 @@
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
-public class ReferenceJobProcessorConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferenceJobProcessorConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferenceJobProcessor jobProcessor;
     private JPanel panelGeneral;
     private JCheckBox chckbxDemoMode;
 
     public ReferenceJobProcessorConfigurationWizard(ReferenceJobProcessor jobProcessor) {
         this.jobProcessor = jobProcessor;
-        
+
         panelGeneral = new JPanel();
-        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "Settings", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelGeneral.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Settings", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
         contentPanel.add(panelGeneral);
-        panelGeneral.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelGeneral
+                .setLayout(
+                        new FormLayout(
+                                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                                        FormSpecs.DEFAULT_COLSPEC, FormSpecs.RELATED_GAP_COLSPEC,
+                                        ColumnSpec.decode("default:grow"),
+                                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec
+                                                .decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                        new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         chckbxDemoMode = new JCheckBox("Demo Mode?");
         panelGeneral.add(chckbxDemoMode, "2, 2");
     }
 
     @Override
     public void createBindings() {
-        addWrappedBinding(jobProcessor, "demoMode", chckbxDemoMode,
-                "selected");
+        addWrappedBinding(jobProcessor, "demoMode", chckbxDemoMode, "selected");
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceMachineConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceMachineConfigurationWizard.java
index 248f6a0fa9..db658faa60 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceMachineConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceMachineConfigurationWizard.java
@@ -21,30 +21,25 @@
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
-public class ReferenceMachineConfigurationWizard extends
-        AbstractConfigurationWizard {
-    
+public class ReferenceMachineConfigurationWizard extends AbstractConfigurationWizard {
+
     final private ReferenceMachine machine;
     private JComboBox comboBoxDriver;
     private String driverClassName;
-    
+
     public ReferenceMachineConfigurationWizard(ReferenceMachine machine) {
         this.machine = machine;
-        contentPanel.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        contentPanel.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblDriver = new JLabel("Driver");
         contentPanel.add(lblDriver, "2, 2, right, default");
-        
+
         comboBoxDriver = new JComboBox();
         contentPanel.add(comboBoxDriver, "4, 2, fill, default");
-        
+
         comboBoxDriver.addItem(NullDriver.class.getCanonicalName());
         comboBoxDriver.addItem(GrblDriver.class.getCanonicalName());
         comboBoxDriver.addItem(LinuxCNC.class.getCanonicalName());
@@ -55,7 +50,7 @@ public ReferenceMachineConfigurationWizard(ReferenceMachine machine) {
         comboBoxDriver.addItem(OpenBuildsDriver.class.getCanonicalName());
         comboBoxDriver.addItem(org.firepick.driver.MarlinDriver.class.getCanonicalName());
         comboBoxDriver.addItem(org.firepick.driver.FireStepDriver.class.getCanonicalName());
-        
+
         this.driverClassName = machine.getDriver().getClass().getCanonicalName();
     }
 
@@ -63,23 +58,21 @@ public ReferenceMachineConfigurationWizard(ReferenceMachine machine) {
     public void createBindings() {
         addWrappedBinding(this, "driverClassName", comboBoxDriver, "selectedItem");
     }
-    
+
     @Override
     protected void saveToModel() {
         super.saveToModel();
-        MessageBoxes.errorBox(
-                getTopLevelAncestor(), 
-                "Restart Required", 
+        MessageBoxes.errorBox(getTopLevelAncestor(), "Restart Required",
                 "Please restart OpenPnP for the changes to take effect.");
     }
 
     public String getDriverClassName() {
         return driverClassName;
     }
-    
+
     public void setDriverClassName(String driverClassName) throws Exception {
         ReferenceDriver driver = (ReferenceDriver) Class.forName(driverClassName).newInstance();
         machine.setDriver(driver);
         this.driverClassName = driverClassName;
-    }    
+    }
 }
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleConfigurationWizard.java
index 9e9870691a..112dd403c2 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.wizards;
@@ -43,8 +41,7 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 @SuppressWarnings("serial")
-public class ReferenceNozzleConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferenceNozzleConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferenceNozzle nozzle;
 
     private JTextField locationX;
@@ -60,23 +57,15 @@ public ReferenceNozzleConfigurationWizard(ReferenceNozzle nozzle) {
         this.nozzle = nozzle;
 
         panelOffsets = new JPanel();
-        panelOffsets.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "Offsets",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
-                new Color(0, 0, 0)));
+        panelOffsets.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Offsets", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
         panelOffsets.setLayout(new FormLayout(
-                new ColumnSpec[] { FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblX = new JLabel("X");
         panelOffsets.add(lblX, "2, 2");
@@ -100,54 +89,48 @@ public ReferenceNozzleConfigurationWizard(ReferenceNozzle nozzle) {
         locationZ.setColumns(5);
 
         contentPanel.add(panelOffsets);
-        
+
         JPanel panelSafeZ = new JPanel();
-        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelSafeZ);
-        panelSafeZ.setLayout(new FormLayout(new ColumnSpec[] {
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,},
-        	new RowSpec[] {
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelSafeZ.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblSafeZ = new JLabel("Safe Z");
         panelSafeZ.add(lblSafeZ, "2, 2, right, default");
-        
+
         textFieldSafeZ = new JTextField();
         panelSafeZ.add(textFieldSafeZ, "4, 2, fill, default");
         textFieldSafeZ.setColumns(10);
-        
-        
+
+
         panelChanger = new JPanel();
-        panelChanger.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null), "Settings", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
+        panelChanger.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Settings", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
         contentPanel.add(panelChanger);
-        panelChanger.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelChanger
+                .setLayout(
+                        new FormLayout(
+                                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                                        FormSpecs.DEFAULT_COLSPEC, FormSpecs.RELATED_GAP_COLSPEC,
+                                        ColumnSpec.decode("default:grow"),
+                                        FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec
+                                                .decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),
+                                FormSpecs.RELATED_GAP_COLSPEC, ColumnSpec.decode("default:grow"),},
+                        new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                                FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         chckbxChangerEnabled = new JCheckBox("Changer Enabled?");
         panelChanger.add(chckbxChangerEnabled, "2, 2");
-        
+
         chckbxLimitRotationTo = new JCheckBox("Limit Rotation to 180º");
         panelChanger.add(chckbxLimitRotationTo, "2, 4");
-        
-        
+
+
     }
 
     @Override
@@ -155,27 +138,18 @@ public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
 
         MutableLocationProxy headOffsets = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, nozzle, "headOffsets", headOffsets,
-                "location");
-        addWrappedBinding(headOffsets, "lengthX", locationX, "text",
-                lengthConverter);
-        addWrappedBinding(headOffsets, "lengthY", locationY, "text",
-                lengthConverter);
-        addWrappedBinding(headOffsets, "lengthZ", locationZ, "text",
-                lengthConverter);
-        
-        addWrappedBinding(nozzle, "changerEnabled", chckbxChangerEnabled,
-                "selected");
-        addWrappedBinding(nozzle, "limitRotation", chckbxLimitRotationTo,
-                "selected");
+        bind(UpdateStrategy.READ_WRITE, nozzle, "headOffsets", headOffsets, "location");
+        addWrappedBinding(headOffsets, "lengthX", locationX, "text", lengthConverter);
+        addWrappedBinding(headOffsets, "lengthY", locationY, "text", lengthConverter);
+        addWrappedBinding(headOffsets, "lengthZ", locationZ, "text", lengthConverter);
+
+        addWrappedBinding(nozzle, "changerEnabled", chckbxChangerEnabled, "selected");
+        addWrappedBinding(nozzle, "limitRotation", chckbxLimitRotationTo, "selected");
         addWrappedBinding(nozzle, "safeZ", textFieldSafeZ, "text", lengthConverter);
 
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationZ);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSafeZ);
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleTipConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleTipConfigurationWizard.java
index 8d81509409..7def15c5f3 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleTipConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferenceNozzleTipConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.wizards;
@@ -51,8 +49,7 @@
 import com.jgoodies.forms.layout.FormSpecs;
 import com.jgoodies.forms.layout.RowSpec;
 
-public class ReferenceNozzleTipConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferenceNozzleTipConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferenceNozzleTip nozzleTip;
     private JPanel panelChanger;
     private JLabel lblX_1;
@@ -78,183 +75,166 @@
     private JScrollPane scrollPane;
     private JTable table;
     private PackagesTableModel tableModel;
-    
+
     private Set<org.openpnp.model.Package> compatiblePackages = new HashSet<>();
-    
+
     public ReferenceNozzleTipConfigurationWizard(ReferenceNozzleTip nozzleTip) {
         this.nozzleTip = nozzleTip;
-        
+
         panelPackageCompat = new JPanel();
-        panelPackageCompat.setBorder(new TitledBorder(null, "Package Compatibility", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelPackageCompat.setBorder(new TitledBorder(null, "Package Compatibility",
+                TitledBorder.LEADING, TitledBorder.TOP, null, null));
         contentPanel.add(panelPackageCompat);
-        panelPackageCompat.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                ColumnSpec.decode("default:grow"),},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                RowSpec.decode("max(100dlu;min)"),}));
-        
+        panelPackageCompat.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC,
+                        ColumnSpec.decode("default:grow"),},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, RowSpec.decode("max(100dlu;min)"),}));
+
         chckbxAllowIncompatiblePackages = new JCheckBox("Allow Incompatible Packages?");
         panelPackageCompat.add(chckbxAllowIncompatiblePackages, "2, 2");
-        
+
         scrollPane = new JScrollPane();
         panelPackageCompat.add(scrollPane, "2, 4, fill, default");
-        
+
         table = new AutoSelectTextTable(tableModel = new PackagesTableModel());
         scrollPane.setViewportView(table);
-        
+
         panelChanger = new JPanel();
-        panelChanger.setBorder(new TitledBorder(null, "Nozzle Tip Changer", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelChanger.setBorder(new TitledBorder(null, "Nozzle Tip Changer", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelChanger);
-        panelChanger.setLayout(new FormLayout(new ColumnSpec[] {
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,
-                FormSpecs.RELATED_GAP_COLSPEC,
-                FormSpecs.DEFAULT_COLSPEC,},
-            new RowSpec[] {
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,
-                FormSpecs.RELATED_GAP_ROWSPEC,
-                FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelChanger.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         lblX_1 = new JLabel("X");
         panelChanger.add(lblX_1, "4, 2");
-        
+
         lblY_1 = new JLabel("Y");
         panelChanger.add(lblY_1, "6, 2");
-        
+
         lblZ_1 = new JLabel("Z");
         panelChanger.add(lblZ_1, "8, 2");
-        
+
         lblStartLocation = new JLabel("Start Location");
         panelChanger.add(lblStartLocation, "2, 4, right, default");
-        
+
         textFieldChangerStartX = new JTextField();
         panelChanger.add(textFieldChangerStartX, "4, 4, fill, default");
         textFieldChangerStartX.setColumns(5);
-        
+
         textFieldChangerStartY = new JTextField();
         panelChanger.add(textFieldChangerStartY, "6, 4, fill, default");
         textFieldChangerStartY.setColumns(5);
-        
+
         textFieldChangerStartZ = new JTextField();
         panelChanger.add(textFieldChangerStartZ, "8, 4, fill, default");
         textFieldChangerStartZ.setColumns(5);
-        
-        changerStartLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerStartX, textFieldChangerStartY, textFieldChangerStartZ, (JTextField) null);
+
+        changerStartLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerStartX,
+                textFieldChangerStartY, textFieldChangerStartZ, (JTextField) null);
         changerStartLocationButtonsPanel.setShowPositionToolNoSafeZ(true);
         panelChanger.add(changerStartLocationButtonsPanel, "10, 4, fill, default");
-        
+
         lblMiddleLocation = new JLabel("Middle Location");
         panelChanger.add(lblMiddleLocation, "2, 6, right, default");
-        
+
         textFieldChangerMidX = new JTextField();
         panelChanger.add(textFieldChangerMidX, "4, 6, fill, default");
         textFieldChangerMidX.setColumns(5);
-        
+
         textFieldChangerMidY = new JTextField();
         panelChanger.add(textFieldChangerMidY, "6, 6, fill, default");
         textFieldChangerMidY.setColumns(5);
-        
+
         textFieldChangerMidZ = new JTextField();
         panelChanger.add(textFieldChangerMidZ, "8, 6, fill, default");
         textFieldChangerMidZ.setColumns(5);
-        
-        changerMidLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerMidX, textFieldChangerMidY, textFieldChangerMidZ, (JTextField) null);
+
+        changerMidLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerMidX,
+                textFieldChangerMidY, textFieldChangerMidZ, (JTextField) null);
         changerMidLocationButtonsPanel.setShowPositionToolNoSafeZ(true);
         panelChanger.add(changerMidLocationButtonsPanel, "10, 6, fill, default");
-        
+
         lblEndLocation = new JLabel("End Location");
         panelChanger.add(lblEndLocation, "2, 8, right, default");
-        
+
         textFieldChangerEndX = new JTextField();
         panelChanger.add(textFieldChangerEndX, "4, 8, fill, default");
         textFieldChangerEndX.setColumns(5);
-        
+
         textFieldChangerEndY = new JTextField();
         panelChanger.add(textFieldChangerEndY, "6, 8, fill, default");
         textFieldChangerEndY.setColumns(5);
-        
+
         textFieldChangerEndZ = new JTextField();
         panelChanger.add(textFieldChangerEndZ, "8, 8, fill, default");
         textFieldChangerEndZ.setColumns(5);
-        
-        changerEndLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerEndX, textFieldChangerEndY, textFieldChangerEndZ, (JTextField) null);
+
+        changerEndLocationButtonsPanel = new LocationButtonsPanel(textFieldChangerEndX,
+                textFieldChangerEndY, textFieldChangerEndZ, (JTextField) null);
         changerEndLocationButtonsPanel.setShowPositionToolNoSafeZ(true);
         panelChanger.add(changerEndLocationButtonsPanel, "10, 8, fill, default");
     }
-    
+
     @Override
     public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
 
-        addWrappedBinding(nozzleTip, "allowIncompatiblePackages",
-                chckbxAllowIncompatiblePackages, "selected");
+        addWrappedBinding(nozzleTip, "allowIncompatiblePackages", chckbxAllowIncompatiblePackages,
+                "selected");
 
         MutableLocationProxy changerStartLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerStartLocation",
-                changerStartLocation, "location");
-        addWrappedBinding(changerStartLocation, "lengthX",
-                textFieldChangerStartX, "text", lengthConverter);
-        addWrappedBinding(changerStartLocation, "lengthY",
-                textFieldChangerStartY, "text", lengthConverter);
-        addWrappedBinding(changerStartLocation, "lengthZ",
-                textFieldChangerStartZ, "text", lengthConverter);
+        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerStartLocation", changerStartLocation,
+                "location");
+        addWrappedBinding(changerStartLocation, "lengthX", textFieldChangerStartX, "text",
+                lengthConverter);
+        addWrappedBinding(changerStartLocation, "lengthY", textFieldChangerStartY, "text",
+                lengthConverter);
+        addWrappedBinding(changerStartLocation, "lengthZ", textFieldChangerStartZ, "text",
+                lengthConverter);
 
         MutableLocationProxy changerMidLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerMidLocation",
-                changerMidLocation, "location");
-        addWrappedBinding(changerMidLocation, "lengthX",
-                textFieldChangerMidX, "text", lengthConverter);
-        addWrappedBinding(changerMidLocation, "lengthY",
-                textFieldChangerMidY, "text", lengthConverter);
-        addWrappedBinding(changerMidLocation, "lengthZ",
-                textFieldChangerMidZ, "text", lengthConverter);
+        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerMidLocation", changerMidLocation,
+                "location");
+        addWrappedBinding(changerMidLocation, "lengthX", textFieldChangerMidX, "text",
+                lengthConverter);
+        addWrappedBinding(changerMidLocation, "lengthY", textFieldChangerMidY, "text",
+                lengthConverter);
+        addWrappedBinding(changerMidLocation, "lengthZ", textFieldChangerMidZ, "text",
+                lengthConverter);
 
         MutableLocationProxy changerEndLocation = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerEndLocation",
-                changerEndLocation, "location");
-        addWrappedBinding(changerEndLocation, "lengthX",
-                textFieldChangerEndX, "text", lengthConverter);
-        addWrappedBinding(changerEndLocation, "lengthY",
-                textFieldChangerEndY, "text", lengthConverter);
-        addWrappedBinding(changerEndLocation, "lengthZ",
-                textFieldChangerEndZ, "text", lengthConverter);
-
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerStartX);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerStartY);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerStartZ);
-
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerMidX);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerMidY);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerMidZ);
-
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerEndX);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerEndY);
-        ComponentDecorators
-            .decorateWithAutoSelectAndLengthConversion(textFieldChangerEndZ);
+        bind(UpdateStrategy.READ_WRITE, nozzleTip, "changerEndLocation", changerEndLocation,
+                "location");
+        addWrappedBinding(changerEndLocation, "lengthX", textFieldChangerEndX, "text",
+                lengthConverter);
+        addWrappedBinding(changerEndLocation, "lengthY", textFieldChangerEndY, "text",
+                lengthConverter);
+        addWrappedBinding(changerEndLocation, "lengthZ", textFieldChangerEndZ, "text",
+                lengthConverter);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerStartX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerStartY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerStartZ);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerMidX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerMidY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerMidZ);
+
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerEndX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerEndY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldChangerEndZ);
     }
-    
+
     @Override
     protected void loadFromModel() {
         compatiblePackages.clear();
@@ -270,7 +250,7 @@ protected void saveToModel() {
     }
 
     public class PackagesTableModel extends AbstractTableModel {
-        private String[] columnNames = new String[] { "Package Id", "Compatible?" };
+        private String[] columnNames = new String[] {"Package Id", "Compatible?"};
         private List<org.openpnp.model.Package> packages;
 
         public PackagesTableModel() {
@@ -298,16 +278,16 @@ public int getColumnCount() {
         public int getRowCount() {
             return (packages == null) ? 0 : packages.size();
         }
-        
+
         public org.openpnp.model.Package getPackage(int index) {
             return packages.get(index);
         }
-        
+
         @Override
         public boolean isCellEditable(int rowIndex, int columnIndex) {
             return columnIndex == 1;
         }
-        
+
         @Override
         public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
             try {
@@ -326,7 +306,7 @@ public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
                 // TODO: dialog, bad input
             }
         }
-        
+
         @Override
         public Class<?> getColumnClass(int columnIndex) {
             if (columnIndex == 1) {
@@ -337,13 +317,13 @@ public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
 
         public Object getValueAt(int row, int col) {
             switch (col) {
-            case 0:
-                return packages.get(row).getId();
-            case 1:
-                return compatiblePackages.contains(packages.get(row));
-            default:
-                return null;
+                case 0:
+                    return packages.get(row).getId();
+                case 1:
+                    return compatiblePackages.contains(packages.get(row));
+                default:
+                    return null;
             }
         }
-    }        
-}
\ No newline at end of file
+    }
+}
diff --git a/src/main/java/org/openpnp/machine/reference/wizards/ReferencePasteDispenserConfigurationWizard.java b/src/main/java/org/openpnp/machine/reference/wizards/ReferencePasteDispenserConfigurationWizard.java
index b5525e08d8..46d491538e 100755
--- a/src/main/java/org/openpnp/machine/reference/wizards/ReferencePasteDispenserConfigurationWizard.java
+++ b/src/main/java/org/openpnp/machine/reference/wizards/ReferencePasteDispenserConfigurationWizard.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.machine.reference.wizards;
@@ -42,8 +40,7 @@
 import com.jgoodies.forms.layout.RowSpec;
 
 @SuppressWarnings("serial")
-public class ReferencePasteDispenserConfigurationWizard extends
-        AbstractConfigurationWizard {
+public class ReferencePasteDispenserConfigurationWizard extends AbstractConfigurationWizard {
     private final ReferencePasteDispenser dispenser;
 
     private JTextField locationX;
@@ -57,23 +54,15 @@ public ReferencePasteDispenserConfigurationWizard(ReferencePasteDispenser dispen
 
         panelOffsets = new JPanel();
         contentPanel.add(panelOffsets);
-        panelOffsets.setBorder(new TitledBorder(new EtchedBorder(
-                EtchedBorder.LOWERED, null, null), "Offsets",
-                TitledBorder.LEADING, TitledBorder.TOP, null,
-                new Color(0, 0, 0)));
+        panelOffsets.setBorder(new TitledBorder(new EtchedBorder(EtchedBorder.LOWERED, null, null),
+                "Offsets", TitledBorder.LEADING, TitledBorder.TOP, null, new Color(0, 0, 0)));
         panelOffsets.setLayout(new FormLayout(
-                new ColumnSpec[] { FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC,
-                        FormSpecs.RELATED_GAP_COLSPEC,
-                        FormSpecs.DEFAULT_COLSPEC, }, new RowSpec[] {
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC,
-                        FormSpecs.RELATED_GAP_ROWSPEC,
-                        FormSpecs.DEFAULT_ROWSPEC, }));
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,
+                        FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
 
         JLabel lblX = new JLabel("X");
         panelOffsets.add(lblX, "2, 2");
@@ -97,26 +86,23 @@ public ReferencePasteDispenserConfigurationWizard(ReferencePasteDispenser dispen
         locationZ.setColumns(5);
 
         contentPanel.add(panelOffsets);
-        
+
         JPanel panelSafeZ = new JPanel();
-        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING, TitledBorder.TOP, null, null));
+        panelSafeZ.setBorder(new TitledBorder(null, "Safe Z", TitledBorder.LEADING,
+                TitledBorder.TOP, null, null));
         contentPanel.add(panelSafeZ);
-        panelSafeZ.setLayout(new FormLayout(new ColumnSpec[] {
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,
-        		FormSpecs.RELATED_GAP_COLSPEC,
-        		FormSpecs.DEFAULT_COLSPEC,},
-        	new RowSpec[] {
-        		FormSpecs.RELATED_GAP_ROWSPEC,
-        		FormSpecs.DEFAULT_ROWSPEC,}));
-        
+        panelSafeZ.setLayout(new FormLayout(
+                new ColumnSpec[] {FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,
+                        FormSpecs.RELATED_GAP_COLSPEC, FormSpecs.DEFAULT_COLSPEC,},
+                new RowSpec[] {FormSpecs.RELATED_GAP_ROWSPEC, FormSpecs.DEFAULT_ROWSPEC,}));
+
         JLabel lblSafeZ = new JLabel("Safe Z");
         panelSafeZ.add(lblSafeZ, "2, 2, right, default");
-        
+
         textFieldSafeZ = new JTextField();
         panelSafeZ.add(textFieldSafeZ, "4, 2, fill, default");
         textFieldSafeZ.setColumns(10);
-        
+
     }
 
     @Override
@@ -124,22 +110,15 @@ public void createBindings() {
         LengthConverter lengthConverter = new LengthConverter();
 
         MutableLocationProxy headOffsets = new MutableLocationProxy();
-        bind(UpdateStrategy.READ_WRITE, dispenser, "headOffsets", headOffsets,
-                "location");
-        addWrappedBinding(headOffsets, "lengthX", locationX, "text",
-                lengthConverter);
-        addWrappedBinding(headOffsets, "lengthY", locationY, "text",
-                lengthConverter);
-        addWrappedBinding(headOffsets, "lengthZ", locationZ, "text",
-                lengthConverter);
+        bind(UpdateStrategy.READ_WRITE, dispenser, "headOffsets", headOffsets, "location");
+        addWrappedBinding(headOffsets, "lengthX", locationX, "text", lengthConverter);
+        addWrappedBinding(headOffsets, "lengthY", locationY, "text", lengthConverter);
+        addWrappedBinding(headOffsets, "lengthZ", locationZ, "text", lengthConverter);
         addWrappedBinding(dispenser, "safeZ", textFieldSafeZ, "text", lengthConverter);
 
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationX);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationY);
-        ComponentDecorators
-                .decorateWithAutoSelectAndLengthConversion(locationZ);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationX);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationY);
+        ComponentDecorators.decorateWithAutoSelectAndLengthConversion(locationZ);
         ComponentDecorators.decorateWithAutoSelectAndLengthConversion(textFieldSafeZ);
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/model/AbstractModelObject.java b/src/main/java/org/openpnp/model/AbstractModelObject.java
index 905db0e052..300f6fd8a0 100755
--- a/src/main/java/org/openpnp/model/AbstractModelObject.java
+++ b/src/main/java/org/openpnp/model/AbstractModelObject.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
@@ -25,31 +23,25 @@
 import java.beans.PropertyChangeSupport;
 
 public abstract class AbstractModelObject {
-	protected final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(
-			this);
-
-	public void addPropertyChangeListener(PropertyChangeListener listener) {
-		propertyChangeSupport.addPropertyChangeListener(listener);
-	}
-
-	public void addPropertyChangeListener(String propertyName,
-			PropertyChangeListener listener) {
-		propertyChangeSupport.addPropertyChangeListener(propertyName, listener);
-	}
-
-	public void removePropertyChangeListener(PropertyChangeListener listener) {
-		propertyChangeSupport.removePropertyChangeListener(listener);
-	}
-
-	public void removePropertyChangeListener(String propertyName,
-			PropertyChangeListener listener) {
-		propertyChangeSupport.removePropertyChangeListener(propertyName,
-				listener);
-	}
-
-	protected void firePropertyChange(String propertyName, Object oldValue,
-			Object newValue) {
-		propertyChangeSupport.firePropertyChange(propertyName, oldValue,
-				newValue);
-	}
-}
\ No newline at end of file
+    protected final PropertyChangeSupport propertyChangeSupport = new PropertyChangeSupport(this);
+
+    public void addPropertyChangeListener(PropertyChangeListener listener) {
+        propertyChangeSupport.addPropertyChangeListener(listener);
+    }
+
+    public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+        propertyChangeSupport.addPropertyChangeListener(propertyName, listener);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener listener) {
+        propertyChangeSupport.removePropertyChangeListener(listener);
+    }
+
+    public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+        propertyChangeSupport.removePropertyChangeListener(propertyName, listener);
+    }
+
+    protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
+        propertyChangeSupport.firePropertyChange(propertyName, oldValue, newValue);
+    }
+}
diff --git a/src/main/java/org/openpnp/model/Board.java b/src/main/java/org/openpnp/model/Board.java
index 2420d007bd..f3e80e8508 100755
--- a/src/main/java/org/openpnp/model/Board.java
+++ b/src/main/java/org/openpnp/model/Board.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 
@@ -36,61 +34,60 @@
 import org.simpleframework.xml.core.Commit;
 
 /**
- * A Board describes the physical properties of a PCB and has a list of 
- * Placements that will be used to specify pick and place operations. 
+ * A Board describes the physical properties of a PCB and has a list of Placements that will be used
+ * to specify pick and place operations.
  */
-@Root(name="openpnp-board")
+@Root(name = "openpnp-board")
 public class Board extends AbstractModelObject implements PropertyChangeListener {
-	public enum Side {
-		Bottom,
-		Top
-	}
-	
-	@Attribute
-	private String name;
-	
-	@Element(required=false)
-	private Outline outline;
-
-	@Element(required=false)
+    public enum Side {
+        Bottom, Top
+    }
+
+    @Attribute
+    private String name;
+
+    @Element(required = false)
+    private Outline outline;
+
+    @Element(required = false)
     private Location dimensions = new Location(LengthUnit.Millimeters);
 
-	@ElementList(required=false)
-	private ArrayList<Fiducial> fiducials = new ArrayList<>();
-	
-	@ElementList
-	private ArrayList<Placement> placements = new ArrayList<>();
+    @ElementList(required = false)
+    private ArrayList<Fiducial> fiducials = new ArrayList<>();
 
-    @ElementList(required=false)
+    @ElementList
+    private ArrayList<Placement> placements = new ArrayList<>();
+
+    @ElementList(required = false)
     private ArrayList<BoardPad> solderPastePads = new ArrayList<>();
-    
-	private transient File file;
-	private transient boolean dirty;
-	
-	public Board() {
-		this(null);
-	}
-	
-	public Board(File file) {
-		setFile(file);
+
+    private transient File file;
+    private transient boolean dirty;
+
+    public Board() {
+        this(null);
+    }
+
+    public Board(File file) {
+        setFile(file);
         setOutline(new Outline());
-		addPropertyChangeListener(this);
-	}
-	
-	@SuppressWarnings("unused")
-	@Commit
-	private void commit() {
+        addPropertyChangeListener(this);
+    }
+
+    @SuppressWarnings("unused")
+    @Commit
+    private void commit() {
         for (Placement placement : placements) {
             placement.addPropertyChangeListener(this);
         }
         for (BoardPad pad : solderPastePads) {
             pad.addPropertyChangeListener(this);
         }
-	}
-	
-	public List<Fiducial> getFiducials() {
-		return Collections.unmodifiableList(fiducials);
-	}
+    }
+
+    public List<Fiducial> getFiducials() {
+        return Collections.unmodifiableList(fiducials);
+    }
 
     public Location getDimensions() {
         return dimensions;
@@ -101,59 +98,59 @@ public void setDimensions(Location location) {
         this.dimensions = location;
         firePropertyChange("dimensions", oldValue, location);
     }
-	
-	public void addFiducial(Fiducial fiducial) {
-		ArrayList<Fiducial> oldValue = fiducials;
-		fiducials = new ArrayList<>(fiducials);
-		fiducials.add(fiducial);
-		firePropertyChange("fiducials", oldValue, fiducials);
-	}
-	
-	public void removeFiducial(Fiducial fiducial) {
-		ArrayList<Fiducial> oldValue = fiducials;
-		fiducials = new ArrayList<>(fiducials);
-		fiducials.remove(fiducial);
-		firePropertyChange("fiducials", oldValue, fiducials);
-	}
-	
-	public List<Placement> getPlacements() {
-		return Collections.unmodifiableList(placements);
-	}
-	
-	public void addPlacement(Placement placement) {
-		Object oldValue = placements;
-		placements = new ArrayList<>(placements);
-		placements.add(placement);
-		firePropertyChange("placements", oldValue, placements);
-		if (placement != null) {
-			placement.addPropertyChangeListener(this); 
-		}
-	}
-	
-	public void removePlacement(Placement placement) {
-		Object oldValue = placements;
-		placements = new ArrayList<>(placements);
-		placements.remove(placement);
-		firePropertyChange("placements", oldValue, placements);
-		if (placement != null) {
-			placement.removePropertyChangeListener(this);
-		}
-	}
-	
+
+    public void addFiducial(Fiducial fiducial) {
+        ArrayList<Fiducial> oldValue = fiducials;
+        fiducials = new ArrayList<>(fiducials);
+        fiducials.add(fiducial);
+        firePropertyChange("fiducials", oldValue, fiducials);
+    }
+
+    public void removeFiducial(Fiducial fiducial) {
+        ArrayList<Fiducial> oldValue = fiducials;
+        fiducials = new ArrayList<>(fiducials);
+        fiducials.remove(fiducial);
+        firePropertyChange("fiducials", oldValue, fiducials);
+    }
+
+    public List<Placement> getPlacements() {
+        return Collections.unmodifiableList(placements);
+    }
+
+    public void addPlacement(Placement placement) {
+        Object oldValue = placements;
+        placements = new ArrayList<>(placements);
+        placements.add(placement);
+        firePropertyChange("placements", oldValue, placements);
+        if (placement != null) {
+            placement.addPropertyChangeListener(this);
+        }
+    }
+
+    public void removePlacement(Placement placement) {
+        Object oldValue = placements;
+        placements = new ArrayList<>(placements);
+        placements.remove(placement);
+        firePropertyChange("placements", oldValue, placements);
+        if (placement != null) {
+            placement.removePropertyChangeListener(this);
+        }
+    }
+
     public List<BoardPad> getSolderPastePads() {
         return Collections.unmodifiableList(solderPastePads);
     }
-    
+
     public void addSolderPastePad(BoardPad pad) {
         Object oldValue = solderPastePads;
         solderPastePads = new ArrayList<>(solderPastePads);
         solderPastePads.add(pad);
         firePropertyChange("solderPastePads", oldValue, solderPastePads);
         if (pad != null) {
-            pad.addPropertyChangeListener(this); 
+            pad.addPropertyChangeListener(this);
         }
     }
-    
+
     public void removeSolderPastePad(BoardPad pad) {
         Object oldValue = solderPastePads;
         solderPastePads = new ArrayList<>(solderPastePads);
@@ -163,51 +160,51 @@ public void removeSolderPastePad(BoardPad pad) {
             pad.removePropertyChangeListener(this);
         }
     }
-    
-	
-	public Outline getOutline() {
-		return outline;
-	}
-
-	public void setOutline(Outline outline) {
-		Outline oldValue = this.outline;
-		this.outline = outline;
-		firePropertyChange("outline", oldValue, outline);
-	}
-
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		Object oldValue = this.name;
-		this.name = name;
-		firePropertyChange("name", oldValue, name);
-	}
-	
-	public File getFile() {
-		return file;
-	}
-	
-	void setFile(File file) {
-		Object oldValue = this.file;
-		this.file = file;
-		firePropertyChange("file", oldValue, file);
-	}
-	
-	public boolean isDirty() {
-		return dirty;
-	}
-	
-	public void setDirty(boolean dirty) {
-		boolean oldValue = this.dirty;
-		this.dirty = dirty;
-		firePropertyChange("dirty", oldValue, dirty);
-	}
-	
-	public void propertyChange(PropertyChangeEvent evt) {
-		if (evt.getSource() != Board.this || !evt.getPropertyName().equals("dirty")) {
-			setDirty(true);
-		}
-	}
+
+
+    public Outline getOutline() {
+        return outline;
+    }
+
+    public void setOutline(Outline outline) {
+        Outline oldValue = this.outline;
+        this.outline = outline;
+        firePropertyChange("outline", oldValue, outline);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        Object oldValue = this.name;
+        this.name = name;
+        firePropertyChange("name", oldValue, name);
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    void setFile(File file) {
+        Object oldValue = this.file;
+        this.file = file;
+        firePropertyChange("file", oldValue, file);
+    }
+
+    public boolean isDirty() {
+        return dirty;
+    }
+
+    public void setDirty(boolean dirty) {
+        boolean oldValue = this.dirty;
+        this.dirty = dirty;
+        firePropertyChange("dirty", oldValue, dirty);
+    }
+
+    public void propertyChange(PropertyChangeEvent evt) {
+        if (evt.getSource() != Board.this || !evt.getPropertyName().equals("dirty")) {
+            setDirty(true);
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/model/BoardLocation.java b/src/main/java/org/openpnp/model/BoardLocation.java
index c58b1ff07d..0b15f1ab38 100755
--- a/src/main/java/org/openpnp/model/BoardLocation.java
+++ b/src/main/java/org/openpnp/model/BoardLocation.java
@@ -1,104 +1,100 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
 import org.openpnp.model.Board.Side;
-import org.openpnp.model.LengthUnit;
-import org.openpnp.model.Location;
 import org.simpleframework.xml.Attribute;
 import org.simpleframework.xml.Element;
 import org.simpleframework.xml.core.Commit;
 
 public class BoardLocation extends AbstractModelObject {
-	@Element
-	private Location location;
-	@Attribute
-	private Side side = Side.Top;
-	private Board board;
-	
-	@Attribute
-	private String boardFile;
-	
-	@Attribute(required=false)
-	private boolean checkFiducials;
-	
-	@Attribute(required=false)
-	private boolean enabled = true;
-	
-	BoardLocation() {
-		setLocation(new Location(LengthUnit.Millimeters));
-	}
-	
-	public BoardLocation(Board board) {
-		this();
-		setBoard(board);
-	}
-	
-	@SuppressWarnings("unused")
+    @Element
+    private Location location;
+    @Attribute
+    private Side side = Side.Top;
+    private Board board;
+
+    @Attribute
+    private String boardFile;
+
+    @Attribute(required = false)
+    private boolean checkFiducials;
+
+    @Attribute(required = false)
+    private boolean enabled = true;
+
+    BoardLocation() {
+        setLocation(new Location(LengthUnit.Millimeters));
+    }
+
+    public BoardLocation(Board board) {
+        this();
+        setBoard(board);
+    }
+
+    @SuppressWarnings("unused")
     @Commit
-	private void commit() {
-		setLocation(location);
-		setBoard(board);
-	}
-	
-	public Location getLocation() {
-		return location;
-	}
-
-	public void setLocation(Location location) {
-		Location oldValue = this.location;
-		this.location = location;
-		firePropertyChange("location", oldValue, location);
-	}
-
-	public Side getSide() {
-		return side;
-	}
-
-	public void setSide(Side side) {
-		Object oldValue = this.side;
-		this.side = side;
-		firePropertyChange("side", oldValue, side);
-	}
-	
-	public Board getBoard() {
-		return board;
-	}
-
-	public void setBoard(Board board) {
-		Board oldValue = this.board;
-		this.board = board;
-		firePropertyChange("board", oldValue, board);
-	}
-	
-	String getBoardFile() {
-		return boardFile;
-	}
-	
-	void setBoardFile(String boardFile) {
-		this.boardFile = boardFile;
-	}
-	
-	public boolean isCheckFiducials() {
+    private void commit() {
+        setLocation(location);
+        setBoard(board);
+    }
+
+    public Location getLocation() {
+        return location;
+    }
+
+    public void setLocation(Location location) {
+        Location oldValue = this.location;
+        this.location = location;
+        firePropertyChange("location", oldValue, location);
+    }
+
+    public Side getSide() {
+        return side;
+    }
+
+    public void setSide(Side side) {
+        Object oldValue = this.side;
+        this.side = side;
+        firePropertyChange("side", oldValue, side);
+    }
+
+    public Board getBoard() {
+        return board;
+    }
+
+    public void setBoard(Board board) {
+        Board oldValue = this.board;
+        this.board = board;
+        firePropertyChange("board", oldValue, board);
+    }
+
+    String getBoardFile() {
+        return boardFile;
+    }
+
+    void setBoardFile(String boardFile) {
+        this.boardFile = boardFile;
+    }
+
+    public boolean isCheckFiducials() {
         return checkFiducials;
     }
 
@@ -107,19 +103,19 @@ public void setCheckFiducials(boolean checkFiducials) {
         this.checkFiducials = checkFiducials;
         firePropertyChange("checkFiducials", oldValue, checkFiducials);
     }
-    
+
     public boolean isEnabled() {
-		return enabled;
-	}
+        return enabled;
+    }
 
-	public void setEnabled(boolean enabled) {
+    public void setEnabled(boolean enabled) {
         boolean oldValue = this.enabled;
         this.enabled = enabled;
         firePropertyChange("enabled", oldValue, enabled);
-	}
+    }
 
-	@Override
-	public String toString() {
-		return String.format("board (%s), location (%s), side (%s)", boardFile, location, side);
-	}
+    @Override
+    public String toString() {
+        return String.format("board (%s), location (%s), side (%s)", boardFile, location, side);
+    }
 }
diff --git a/src/main/java/org/openpnp/model/BoardPad.java b/src/main/java/org/openpnp/model/BoardPad.java
index 8eee03abdf..d777521772 100755
--- a/src/main/java/org/openpnp/model/BoardPad.java
+++ b/src/main/java/org/openpnp/model/BoardPad.java
@@ -6,34 +6,33 @@
 
 public class BoardPad extends AbstractModelObject {
     public enum Type {
-        Paste,
-        Ignore
+        Paste, Ignore
     }
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private Type type = Type.Paste;
 
     @Attribute
     protected Side side = Side.Top;
-    
+
     @Element
     protected Location location = new Location(LengthUnit.Millimeters);
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     @Element
     protected Pad pad;
-    
+
     public BoardPad() {
-        
+
     }
-    
+
     public BoardPad(Pad pad, Location location) {
         setPad(pad);
         setLocation(location);
     }
-    
+
     public Location getLocation() {
         return location;
     }
@@ -47,37 +46,37 @@ public void setLocation(Location location) {
     public Side getSide() {
         return side;
     }
-    
+
     public void setSide(Side side) {
         Object oldValue = this.side;
         this.side = side;
         firePropertyChange("side", oldValue, side);
     }
-    
+
     public Type getType() {
         return type;
     }
-    
+
     public void setType(Type type) {
         Object oldValue = this.type;
         this.type = type;
         firePropertyChange("type", oldValue, type);
     }
-    
+
     public String getName() {
         return name;
     }
-    
+
     public void setName(String name) {
         Object oldValue = this.name;
         this.name = name;
         firePropertyChange("name", oldValue, name);
     }
-    
+
     public Pad getPad() {
         return pad;
     }
-    
+
     public void setPad(Pad pad) {
         Object oldValue = pad;
         this.pad = pad;
diff --git a/src/main/java/org/openpnp/model/Configuration.java b/src/main/java/org/openpnp/model/Configuration.java
index 9908817c5b..47b48cf562 100755
--- a/src/main/java/org/openpnp/model/Configuration.java
+++ b/src/main/java/org/openpnp/model/Configuration.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -31,9 +29,6 @@
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
 import java.util.prefs.Preferences;
 
 import org.apache.commons.io.FileUtils;
@@ -53,212 +48,217 @@
 import org.slf4j.LoggerFactory;
 
 public class Configuration extends AbstractModelObject {
-	private static final Logger logger = LoggerFactory.getLogger(Configuration.class);
-	
-	private static Configuration instance;
-	
-	private static final String PREF_UNITS = "Configuration.units";
-	private static final String PREF_UNITS_DEF = "Millimeters";
-	
-	private static final String PREF_LENGTH_DISPLAY_FORMAT = "Configuration.lengthDisplayFormat";
-	private static final String PREF_LENGTH_DISPLAY_FORMAT_DEF = "%.3f";
-	
-	private static final String PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS = "Configuration.lengthDisplayFormatWithUnits";
-	private static final String PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF = "%.3f%s";
-	
-	private static final String PREF_VERTICAL_SCROLL_UNIT_INCREMENT = "Configuration.verticalScrollUnitIncrement";
-	private static final int PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF = 16;
-	
-	private LinkedHashMap<String, Package> packages = new LinkedHashMap<>();
-	private LinkedHashMap<String, Part> parts = new LinkedHashMap<>();
-	private Machine machine;
-	private LinkedHashMap<File, Board> boards = new LinkedHashMap<>();
-	private boolean loaded;
-	private Set<ConfigurationListener> listeners = Collections.synchronizedSet(new HashSet<>());
-	private File configurationDirectory;
-	private Preferences prefs;
-	
-	public static Configuration get() {
-		if (instance == null) {
-			throw new Error("Configuration instance not yet initialized.");
-		}
-		return instance;
-	}
-	
-	public static synchronized void initialize(File configurationDirectory) {
-		instance = new Configuration(configurationDirectory);
-		instance.setLengthDisplayFormatWithUnits(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF);
-	}
-	
-	private Configuration(File configurationDirectory) {
-		this.configurationDirectory = configurationDirectory;
-		this.prefs = Preferences.userNodeForPackage(Configuration.class);
-	}
-	
-	public File getConfigurationDirectory() {
-	    return configurationDirectory;
-	}
-	
-	public LengthUnit getSystemUnits() {
-		return LengthUnit.valueOf(prefs.get(PREF_UNITS, PREF_UNITS_DEF));
-	}
-	
-	public void setSystemUnits(LengthUnit lengthUnit) {
-		prefs.put(PREF_UNITS, lengthUnit.name());
-	}
-	
-	public String getLengthDisplayFormat() {
-		return prefs.get(PREF_LENGTH_DISPLAY_FORMAT, PREF_LENGTH_DISPLAY_FORMAT_DEF);
-	}
-	
-	public void setLengthDisplayFormat(String format) {
-		prefs.put(PREF_LENGTH_DISPLAY_FORMAT, format);
-	}
-	
-	public String getLengthDisplayFormatWithUnits() {
-		return prefs.get(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS, PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF);
-	}
-	
-	public void setLengthDisplayFormatWithUnits(String format) {
-		prefs.put(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS, format);
-	}
-	
-	public int getVerticalScrollUnitIncrement() {
-		return prefs.getInt(PREF_VERTICAL_SCROLL_UNIT_INCREMENT, PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF);
-	}
-	
-	public void setVerticalScrollUnitIncrement(int verticalScrollUnitIncrement) {
-		prefs.putInt(PREF_VERTICAL_SCROLL_UNIT_INCREMENT, PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF);
-	}
-	
-	/**
-	 * Gets a File reference for the resources directory belonging to the
-	 * given class. The directory is guaranteed to exist. 
-	 * @param forClass
-	 * @return
-	 * @throws IOException
-	 */
-	public File getResourceDirectory(Class forClass) throws IOException {
-		File directory = new File(configurationDirectory, forClass.getCanonicalName());
-		if (!directory.exists()) {
-			directory.mkdirs();
-		}
-		return directory;
-	}
-	
-	/**
-	 * Gets a File reference for the named file within the configuration
-	 * directory. forClass is used to uniquely identify the file and keep it
-	 * separate from other classes' files.
-	 * @param forClass
-	 * @param name
-	 * @return
-	 */
-	public File getResourceFile(Class forClass, String name) throws IOException {
-		return new File(getResourceDirectory(forClass), name);
-	}
-	
-	/**
-	 * Creates a new file with a unique name within the configuration
-	 * directory. forClass is used to uniquely identify the file within
-	 * the application and a unique name is generated within that namespace.
-	 * suffix is appended to the unique part of the filename. The result of
-	 * calling File.getName() on the returned file can be used to load the
-	 * same file in the future by calling getResourceFile().
-	 * This method uses File.createTemporaryFile() and so the rules for that
-	 * method must be followed when calling this one.
-	 * @param forClass
-	 * @param suffix
-	 * @return
-	 * @throws IOException
-	 */
-	public File createResourceFile(Class forClass, String prefix, String suffix) throws IOException {
-		File directory = new File(configurationDirectory, forClass.getCanonicalName());
-		if (!directory.exists()) {
-			directory.mkdirs();
-		}
-		File file = File.createTempFile(prefix, suffix, directory);
-		return file;
-	}
-	
-	public void addListener(ConfigurationListener listener) {
-		listeners.add(listener);
-		if (loaded) {
-		    try {
-		        listener.configurationLoaded(this);
-		        listener.configurationComplete(this);
-		    }
-		    catch (Exception e) {
-		        // TODO: Need to find a way to raise this to the GUI
-		        throw new Error(e);
-		    }
-		}
-	}
-	
-	public void removeListener(ConfigurationListener listener) {
-		listeners.remove(listener);
-	}
-	
-	public synchronized void load() throws Exception {
-		boolean forceSave = false;
-		boolean overrideUserConfig = Boolean.getBoolean("overrideUserConfig");
-		
-		try {
-			File file = new File(configurationDirectory, "packages.xml");
-			if (overrideUserConfig || !file.exists()) {
-				logger.info("No packages.xml found in configuration directory, loading defaults.");
-				file = File.createTempFile("packages", "xml");
-				FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/packages.xml"), file);
-				forceSave = true;
-			}
-			loadPackages(file);
-		}
-		catch (Exception e) {
-			String message = e.getMessage();
-			if (e.getCause() != null && e.getCause().getMessage() != null) {
-				message = e.getCause().getMessage();
-			}
-			throw new Exception("Error while reading packages.xml (" + message + ")", e);
-		}
-		
-		
-		try {
-			File file = new File(configurationDirectory, "parts.xml");
-			if (overrideUserConfig || !file.exists()) {
-				logger.info("No parts.xml found in configuration directory, loading defaults.");
-				file = File.createTempFile("parts", "xml");
-				FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/parts.xml"), file);
-				forceSave = true;
-			}
-			loadParts(file);
-		}
-		catch (Exception e) {
-			String message = e.getMessage();
-			if (e.getCause() != null && e.getCause().getMessage() != null) {
-				message = e.getCause().getMessage();
-			}
-			throw new Exception("Error while reading parts.xml (" + message + ")", e);
-		}
-		
-		
-		try {
-			File file = new File(configurationDirectory, "machine.xml");
-			if (overrideUserConfig || !file.exists()) {
-				logger.info("No machine.xml found in configuration directory, loading defaults.");
-				file = File.createTempFile("machine", "xml");
-				FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/machine.xml"), file);
-				forceSave = true;
-			}
-			loadMachine(file);
-		}
-		catch (Exception e) {
-			String message = e.getMessage();
-			if (e.getCause() != null && e.getCause().getMessage() != null) {
-				message = e.getCause().getMessage();
-			}
-			throw new Exception("Error while reading machine.xml (" + message + ")", e);
-		}
-		
+    private static final Logger logger = LoggerFactory.getLogger(Configuration.class);
+
+    private static Configuration instance;
+
+    private static final String PREF_UNITS = "Configuration.units";
+    private static final String PREF_UNITS_DEF = "Millimeters";
+
+    private static final String PREF_LENGTH_DISPLAY_FORMAT = "Configuration.lengthDisplayFormat";
+    private static final String PREF_LENGTH_DISPLAY_FORMAT_DEF = "%.3f";
+
+    private static final String PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS =
+            "Configuration.lengthDisplayFormatWithUnits";
+    private static final String PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF = "%.3f%s";
+
+    private static final String PREF_VERTICAL_SCROLL_UNIT_INCREMENT =
+            "Configuration.verticalScrollUnitIncrement";
+    private static final int PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF = 16;
+
+    private LinkedHashMap<String, Package> packages = new LinkedHashMap<>();
+    private LinkedHashMap<String, Part> parts = new LinkedHashMap<>();
+    private Machine machine;
+    private LinkedHashMap<File, Board> boards = new LinkedHashMap<>();
+    private boolean loaded;
+    private Set<ConfigurationListener> listeners = Collections.synchronizedSet(new HashSet<>());
+    private File configurationDirectory;
+    private Preferences prefs;
+
+    public static Configuration get() {
+        if (instance == null) {
+            throw new Error("Configuration instance not yet initialized.");
+        }
+        return instance;
+    }
+
+    public static synchronized void initialize(File configurationDirectory) {
+        instance = new Configuration(configurationDirectory);
+        instance.setLengthDisplayFormatWithUnits(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF);
+    }
+
+    private Configuration(File configurationDirectory) {
+        this.configurationDirectory = configurationDirectory;
+        this.prefs = Preferences.userNodeForPackage(Configuration.class);
+    }
+
+    public File getConfigurationDirectory() {
+        return configurationDirectory;
+    }
+
+    public LengthUnit getSystemUnits() {
+        return LengthUnit.valueOf(prefs.get(PREF_UNITS, PREF_UNITS_DEF));
+    }
+
+    public void setSystemUnits(LengthUnit lengthUnit) {
+        prefs.put(PREF_UNITS, lengthUnit.name());
+    }
+
+    public String getLengthDisplayFormat() {
+        return prefs.get(PREF_LENGTH_DISPLAY_FORMAT, PREF_LENGTH_DISPLAY_FORMAT_DEF);
+    }
+
+    public void setLengthDisplayFormat(String format) {
+        prefs.put(PREF_LENGTH_DISPLAY_FORMAT, format);
+    }
+
+    public String getLengthDisplayFormatWithUnits() {
+        return prefs.get(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS,
+                PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS_DEF);
+    }
+
+    public void setLengthDisplayFormatWithUnits(String format) {
+        prefs.put(PREF_LENGTH_DISPLAY_FORMAT_WITH_UNITS, format);
+    }
+
+    public int getVerticalScrollUnitIncrement() {
+        return prefs.getInt(PREF_VERTICAL_SCROLL_UNIT_INCREMENT,
+                PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF);
+    }
+
+    public void setVerticalScrollUnitIncrement(int verticalScrollUnitIncrement) {
+        prefs.putInt(PREF_VERTICAL_SCROLL_UNIT_INCREMENT, PREF_VERTICAL_SCROLL_UNIT_INCREMENT_DEF);
+    }
+
+    /**
+     * Gets a File reference for the resources directory belonging to the given class. The directory
+     * is guaranteed to exist.
+     * 
+     * @param forClass
+     * @return
+     * @throws IOException
+     */
+    public File getResourceDirectory(Class forClass) throws IOException {
+        File directory = new File(configurationDirectory, forClass.getCanonicalName());
+        if (!directory.exists()) {
+            directory.mkdirs();
+        }
+        return directory;
+    }
+
+    /**
+     * Gets a File reference for the named file within the configuration directory. forClass is used
+     * to uniquely identify the file and keep it separate from other classes' files.
+     * 
+     * @param forClass
+     * @param name
+     * @return
+     */
+    public File getResourceFile(Class forClass, String name) throws IOException {
+        return new File(getResourceDirectory(forClass), name);
+    }
+
+    /**
+     * Creates a new file with a unique name within the configuration directory. forClass is used to
+     * uniquely identify the file within the application and a unique name is generated within that
+     * namespace. suffix is appended to the unique part of the filename. The result of calling
+     * File.getName() on the returned file can be used to load the same file in the future by
+     * calling getResourceFile(). This method uses File.createTemporaryFile() and so the rules for
+     * that method must be followed when calling this one.
+     * 
+     * @param forClass
+     * @param suffix
+     * @return
+     * @throws IOException
+     */
+    public File createResourceFile(Class forClass, String prefix, String suffix)
+            throws IOException {
+        File directory = new File(configurationDirectory, forClass.getCanonicalName());
+        if (!directory.exists()) {
+            directory.mkdirs();
+        }
+        File file = File.createTempFile(prefix, suffix, directory);
+        return file;
+    }
+
+    public void addListener(ConfigurationListener listener) {
+        listeners.add(listener);
+        if (loaded) {
+            try {
+                listener.configurationLoaded(this);
+                listener.configurationComplete(this);
+            }
+            catch (Exception e) {
+                // TODO: Need to find a way to raise this to the GUI
+                throw new Error(e);
+            }
+        }
+    }
+
+    public void removeListener(ConfigurationListener listener) {
+        listeners.remove(listener);
+    }
+
+    public synchronized void load() throws Exception {
+        boolean forceSave = false;
+        boolean overrideUserConfig = Boolean.getBoolean("overrideUserConfig");
+
+        try {
+            File file = new File(configurationDirectory, "packages.xml");
+            if (overrideUserConfig || !file.exists()) {
+                logger.info("No packages.xml found in configuration directory, loading defaults.");
+                file = File.createTempFile("packages", "xml");
+                FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/packages.xml"), file);
+                forceSave = true;
+            }
+            loadPackages(file);
+        }
+        catch (Exception e) {
+            String message = e.getMessage();
+            if (e.getCause() != null && e.getCause().getMessage() != null) {
+                message = e.getCause().getMessage();
+            }
+            throw new Exception("Error while reading packages.xml (" + message + ")", e);
+        }
+
+
+        try {
+            File file = new File(configurationDirectory, "parts.xml");
+            if (overrideUserConfig || !file.exists()) {
+                logger.info("No parts.xml found in configuration directory, loading defaults.");
+                file = File.createTempFile("parts", "xml");
+                FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/parts.xml"), file);
+                forceSave = true;
+            }
+            loadParts(file);
+        }
+        catch (Exception e) {
+            String message = e.getMessage();
+            if (e.getCause() != null && e.getCause().getMessage() != null) {
+                message = e.getCause().getMessage();
+            }
+            throw new Exception("Error while reading parts.xml (" + message + ")", e);
+        }
+
+
+        try {
+            File file = new File(configurationDirectory, "machine.xml");
+            if (overrideUserConfig || !file.exists()) {
+                logger.info("No machine.xml found in configuration directory, loading defaults.");
+                file = File.createTempFile("machine", "xml");
+                FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/machine.xml"), file);
+                forceSave = true;
+            }
+            loadMachine(file);
+        }
+        catch (Exception e) {
+            String message = e.getMessage();
+            if (e.getCause() != null && e.getCause().getMessage() != null) {
+                message = e.getCause().getMessage();
+            }
+            throw new Exception("Error while reading machine.xml (" + message + ")", e);
+        }
+
         loaded = true;
 
         for (ConfigurationListener listener : listeners) {
@@ -266,266 +266,265 @@ public synchronized void load() throws Exception {
         }
 
         if (forceSave) {
-			logger.info("Defaults were loaded. Saving to configuration directory.");
-			configurationDirectory.mkdirs();
-			save();
-		}
-        
-		for (ConfigurationListener listener : listeners) {
+            logger.info("Defaults were loaded. Saving to configuration directory.");
+            configurationDirectory.mkdirs();
+            save();
+        }
+
+        for (ConfigurationListener listener : listeners) {
             listener.configurationComplete(this);
         }
-	}
-	
-	public synchronized void save() throws Exception {
-		try {
-			saveMachine(new File(configurationDirectory, "machine.xml"));
-		}
-		catch (Exception e) {
-			throw new Exception("Error while saving machine.xml (" + e.getMessage() + ")", e);
-		}
-		try {
-			savePackages(new File(configurationDirectory, "packages.xml"));
-		}
-		catch (Exception e) {
-			throw new Exception("Error while saving packages.xml (" + e.getMessage() + ")", e);
-		}
-		try {
-			saveParts(new File(configurationDirectory, "parts.xml"));
-		}
-		catch (Exception e) {
-			throw new Exception("Error while saving parts.xml (" + e.getMessage() + ")", e);
-		}
-	}
-	
-	public Package getPackage(String id) {
-		if (id == null) {
-			return null;
-		}
-		return packages.get(id.toUpperCase());
-	}
-	
-	public List<Package> getPackages() {
-		return Collections.unmodifiableList(new ArrayList<>(packages.values()));
-	}
-	
-	public void addPackage(Package pkg) {
-	    if (null == pkg.getId()) {
-	        throw new Error("Package with null Id cannot be added to Configuration.");
-	    }
-		packages.put(pkg.getId().toUpperCase(), pkg);
-		firePropertyChange("packages", null, packages);
-	}
-	
+    }
+
+    public synchronized void save() throws Exception {
+        try {
+            saveMachine(new File(configurationDirectory, "machine.xml"));
+        }
+        catch (Exception e) {
+            throw new Exception("Error while saving machine.xml (" + e.getMessage() + ")", e);
+        }
+        try {
+            savePackages(new File(configurationDirectory, "packages.xml"));
+        }
+        catch (Exception e) {
+            throw new Exception("Error while saving packages.xml (" + e.getMessage() + ")", e);
+        }
+        try {
+            saveParts(new File(configurationDirectory, "parts.xml"));
+        }
+        catch (Exception e) {
+            throw new Exception("Error while saving parts.xml (" + e.getMessage() + ")", e);
+        }
+    }
+
+    public Package getPackage(String id) {
+        if (id == null) {
+            return null;
+        }
+        return packages.get(id.toUpperCase());
+    }
+
+    public List<Package> getPackages() {
+        return Collections.unmodifiableList(new ArrayList<>(packages.values()));
+    }
+
+    public void addPackage(Package pkg) {
+        if (null == pkg.getId()) {
+            throw new Error("Package with null Id cannot be added to Configuration.");
+        }
+        packages.put(pkg.getId().toUpperCase(), pkg);
+        firePropertyChange("packages", null, packages);
+    }
+
     public void removePackage(Package pkg) {
         packages.remove(pkg.getId());
         firePropertyChange("packages", null, packages);
     }
-    
-	public Part getPart(String id) {
-		if (id == null) {
-			return null;
-		}
-		return parts.get(id.toUpperCase());
-	}
-	
-	public List<Part> getParts() {
-		return Collections.unmodifiableList(new ArrayList<>(parts.values()));
-	}
-	
-	public void addPart(Part part) {
-	    if (null == part.getId()) {
+
+    public Part getPart(String id) {
+        if (id == null) {
+            return null;
+        }
+        return parts.get(id.toUpperCase());
+    }
+
+    public List<Part> getParts() {
+        return Collections.unmodifiableList(new ArrayList<>(parts.values()));
+    }
+
+    public void addPart(Part part) {
+        if (null == part.getId()) {
             throw new Error("Part with null Id cannot be added to Configuration.");
-	    }
-		parts.put(part.getId().toUpperCase(), part);
-		firePropertyChange("parts", null, parts);
-	}
-	
-	public void removePart(Part part) {
-	    parts.remove(part.getId());
-	    firePropertyChange("parts", null, parts);
-	}
-	
-	public List<Board> getBoards() {
-		return Collections.unmodifiableList(new ArrayList<>(boards.values()));
-	}
-	
-	public Machine getMachine() {
-		return machine;
-	}
-	
-	public Board getBoard(File file) throws Exception {
-		if (!file.exists()) {
-			Board board = new Board(file);
-			board.setName(file.getName());
-			Serializer serializer = createSerializer();
-			serializer.write(board, file);
-		}
-		file = file.getCanonicalFile();
-		if (boards.containsKey(file)) {
-			return boards.get(file);
-		}
-		Board board = loadBoard(file);
-		boards.put(file, board);
-		firePropertyChange("boards", null, boards);
-		return board;
-	}
-	
-	private void loadMachine(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		MachineConfigurationHolder holder = serializer.read(MachineConfigurationHolder.class, file);
-		machine = holder.machine;
-	}
-	
-	private void saveMachine(File file) throws Exception {
-		MachineConfigurationHolder holder = new MachineConfigurationHolder();
-		holder.machine = machine;
-		Serializer serializer = createSerializer();
-		serializer.write(holder, new ByteArrayOutputStream());
-		serializer.write(holder, file);
-	}
-	
-	private void loadPackages(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		PackagesConfigurationHolder holder = serializer.read(PackagesConfigurationHolder.class, file);
-		for (Package pkg : holder.packages) {
-			addPackage(pkg);
-		}
-	}
-	
-	private void savePackages(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		PackagesConfigurationHolder holder = new PackagesConfigurationHolder();
-		holder.packages = new ArrayList<>(packages.values());
-		serializer.write(holder, new ByteArrayOutputStream());
-		serializer.write(holder, file);
-	}
-	
-	private void loadParts(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		PartsConfigurationHolder holder = serializer.read(PartsConfigurationHolder.class, file);
-		for (Part part : holder.parts) {
-			addPart(part);
-		}
-	}
-	
-	private void saveParts(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		PartsConfigurationHolder holder = new PartsConfigurationHolder();
-		holder.parts = new ArrayList<>(parts.values());
-		serializer.write(holder, new ByteArrayOutputStream());
-		serializer.write(holder, file);
-	}
-	
-	public Job loadJob(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		Job job = serializer.read(Job.class, file);
-		job.setFile(file);
-		
-		// Once the Job is loaded we need to resolve any Boards that it
-		// references.
-		for (BoardLocation boardLocation : job.getBoardLocations()) {
-			String boardFilename = boardLocation.getBoardFile();
-			// First see if we can find the board at the given filename
-			// If the filename is not absolute this will be relative
-			// to the working directory
-			File boardFile = new File(boardFilename);
-			if (!boardFile.exists()) {
-				// If that fails, see if we can find it relative to the
-				// directory the job was in
-				boardFile = new File(file.getParentFile(), boardFilename);
-			}
-			if (!boardFile.exists()) {
-				throw new Exception("Board file not found: " + boardFilename);
-			}
-			Board board = getBoard(boardFile);
-			boardLocation.setBoard(board);
-		}
-		
-		job.setDirty(false);
-		
-		return job;
-	}
-	
-	public void saveJob(Job job, File file) throws Exception {
-		Serializer serializer = createSerializer();
-		Set<Board> boards = new HashSet<>();
-		// Fix the paths to any boards in the Job
-		for (BoardLocation boardLocation : job.getBoardLocations()) {
-			Board board = boardLocation.getBoard();
-			boards.add(board);
-			try {
-				String relativePath = ResourceUtils.getRelativePath(
-						board.getFile().getAbsolutePath(), 
-						file.getAbsolutePath(), 
-						File.separator);
-				boardLocation.setBoardFile(relativePath);
-			}
-			catch (ResourceUtils.PathResolutionException ex) {
-				boardLocation.setBoardFile(board.getFile().getAbsolutePath());
-			}
-		}
-		// Save any boards in the job
-		for (Board board : boards) {
-		    saveBoard(board);
-		}
-		// Save the job
-		serializer.write(job, new ByteArrayOutputStream());
-		serializer.write(job, file);
-		job.setFile(file);
-		job.setDirty(false);
-	}
-	
-	public void saveBoard(Board board) throws Exception {
-		Serializer serializer = createSerializer();
-		serializer.write(board, new ByteArrayOutputStream());
-		serializer.write(board, board.getFile());
-		board.setDirty(false);
-	}
-	
-	private Board loadBoard(File file) throws Exception {
-		Serializer serializer = createSerializer();
-		Board board = serializer.read(Board.class, file);
-		board.setFile(file);
-		board.setDirty(false);
-		return board;
-	}
-	
-	public static Serializer createSerializer() {
-		Style style = new HyphenStyle();
-		Format format = new Format(style);
-		AnnotationStrategy strategy = new AnnotationStrategy();
-		Serializer serializer = new Persister(strategy, format);
-		return serializer;
-	}
-	
+        }
+        parts.put(part.getId().toUpperCase(), part);
+        firePropertyChange("parts", null, parts);
+    }
+
+    public void removePart(Part part) {
+        parts.remove(part.getId());
+        firePropertyChange("parts", null, parts);
+    }
+
+    public List<Board> getBoards() {
+        return Collections.unmodifiableList(new ArrayList<>(boards.values()));
+    }
+
+    public Machine getMachine() {
+        return machine;
+    }
+
+    public Board getBoard(File file) throws Exception {
+        if (!file.exists()) {
+            Board board = new Board(file);
+            board.setName(file.getName());
+            Serializer serializer = createSerializer();
+            serializer.write(board, file);
+        }
+        file = file.getCanonicalFile();
+        if (boards.containsKey(file)) {
+            return boards.get(file);
+        }
+        Board board = loadBoard(file);
+        boards.put(file, board);
+        firePropertyChange("boards", null, boards);
+        return board;
+    }
+
+    private void loadMachine(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        MachineConfigurationHolder holder = serializer.read(MachineConfigurationHolder.class, file);
+        machine = holder.machine;
+    }
+
+    private void saveMachine(File file) throws Exception {
+        MachineConfigurationHolder holder = new MachineConfigurationHolder();
+        holder.machine = machine;
+        Serializer serializer = createSerializer();
+        serializer.write(holder, new ByteArrayOutputStream());
+        serializer.write(holder, file);
+    }
+
+    private void loadPackages(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        PackagesConfigurationHolder holder =
+                serializer.read(PackagesConfigurationHolder.class, file);
+        for (Package pkg : holder.packages) {
+            addPackage(pkg);
+        }
+    }
+
+    private void savePackages(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        PackagesConfigurationHolder holder = new PackagesConfigurationHolder();
+        holder.packages = new ArrayList<>(packages.values());
+        serializer.write(holder, new ByteArrayOutputStream());
+        serializer.write(holder, file);
+    }
+
+    private void loadParts(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        PartsConfigurationHolder holder = serializer.read(PartsConfigurationHolder.class, file);
+        for (Part part : holder.parts) {
+            addPart(part);
+        }
+    }
+
+    private void saveParts(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        PartsConfigurationHolder holder = new PartsConfigurationHolder();
+        holder.parts = new ArrayList<>(parts.values());
+        serializer.write(holder, new ByteArrayOutputStream());
+        serializer.write(holder, file);
+    }
+
+    public Job loadJob(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        Job job = serializer.read(Job.class, file);
+        job.setFile(file);
+
+        // Once the Job is loaded we need to resolve any Boards that it
+        // references.
+        for (BoardLocation boardLocation : job.getBoardLocations()) {
+            String boardFilename = boardLocation.getBoardFile();
+            // First see if we can find the board at the given filename
+            // If the filename is not absolute this will be relative
+            // to the working directory
+            File boardFile = new File(boardFilename);
+            if (!boardFile.exists()) {
+                // If that fails, see if we can find it relative to the
+                // directory the job was in
+                boardFile = new File(file.getParentFile(), boardFilename);
+            }
+            if (!boardFile.exists()) {
+                throw new Exception("Board file not found: " + boardFilename);
+            }
+            Board board = getBoard(boardFile);
+            boardLocation.setBoard(board);
+        }
+
+        job.setDirty(false);
+
+        return job;
+    }
+
+    public void saveJob(Job job, File file) throws Exception {
+        Serializer serializer = createSerializer();
+        Set<Board> boards = new HashSet<>();
+        // Fix the paths to any boards in the Job
+        for (BoardLocation boardLocation : job.getBoardLocations()) {
+            Board board = boardLocation.getBoard();
+            boards.add(board);
+            try {
+                String relativePath = ResourceUtils.getRelativePath(
+                        board.getFile().getAbsolutePath(), file.getAbsolutePath(), File.separator);
+                boardLocation.setBoardFile(relativePath);
+            }
+            catch (ResourceUtils.PathResolutionException ex) {
+                boardLocation.setBoardFile(board.getFile().getAbsolutePath());
+            }
+        }
+        // Save any boards in the job
+        for (Board board : boards) {
+            saveBoard(board);
+        }
+        // Save the job
+        serializer.write(job, new ByteArrayOutputStream());
+        serializer.write(job, file);
+        job.setFile(file);
+        job.setDirty(false);
+    }
+
+    public void saveBoard(Board board) throws Exception {
+        Serializer serializer = createSerializer();
+        serializer.write(board, new ByteArrayOutputStream());
+        serializer.write(board, board.getFile());
+        board.setDirty(false);
+    }
+
+    private Board loadBoard(File file) throws Exception {
+        Serializer serializer = createSerializer();
+        Board board = serializer.read(Board.class, file);
+        board.setFile(file);
+        board.setDirty(false);
+        return board;
+    }
+
+    public static Serializer createSerializer() {
+        Style style = new HyphenStyle();
+        Format format = new Format(style);
+        AnnotationStrategy strategy = new AnnotationStrategy();
+        Serializer serializer = new Persister(strategy, format);
+        return serializer;
+    }
+
     public static String createId() {
         return UUID.randomUUID().toString();
-    }	
-	
-	/**
-	 * Used to provide a fixed root for the Machine when serializing. 
-	 */
-	@Root(name="openpnp-machine")
-	public static class MachineConfigurationHolder {
-		@Element
-		private Machine machine;
-	}
-	
-	/**
-	 * Used to provide a fixed root for the Packages when serializing. 
-	 */
-	@Root(name="openpnp-packages")
-	public static class PackagesConfigurationHolder {
-		@ElementList(inline=true, entry="package", required=false)
-		private ArrayList<Package> packages = new ArrayList<>();
-	}
-	
-	/**
-	 * Used to provide a fixed root for the Parts when serializing. 
-	 */
-	@Root(name="openpnp-parts")
-	public static class PartsConfigurationHolder {
-		@ElementList(inline=true, entry="part", required=false)
-		private ArrayList<Part> parts = new ArrayList<>();
-	}
+    }
+
+    /**
+     * Used to provide a fixed root for the Machine when serializing.
+     */
+    @Root(name = "openpnp-machine")
+    public static class MachineConfigurationHolder {
+        @Element
+        private Machine machine;
+    }
+
+    /**
+     * Used to provide a fixed root for the Packages when serializing.
+     */
+    @Root(name = "openpnp-packages")
+    public static class PackagesConfigurationHolder {
+        @ElementList(inline = true, entry = "package", required = false)
+        private ArrayList<Package> packages = new ArrayList<>();
+    }
+
+    /**
+     * Used to provide a fixed root for the Parts when serializing.
+     */
+    @Root(name = "openpnp-parts")
+    public static class PartsConfigurationHolder {
+        @ElementList(inline = true, entry = "part", required = false)
+        private ArrayList<Part> parts = new ArrayList<>();
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Fiducial.java b/src/main/java/org/openpnp/model/Fiducial.java
index 8320831a01..7aa42261eb 100755
--- a/src/main/java/org/openpnp/model/Fiducial.java
+++ b/src/main/java/org/openpnp/model/Fiducial.java
@@ -1,30 +1,28 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
 
 /**
- * A Fiducial is an identifying mark on a Board that can be used to identify the offset and rotation of the board
- * for placement operations.
+ * A Fiducial is an identifying mark on a Board that can be used to identify the offset and rotation
+ * of the board for placement operations.
  */
 public interface Fiducial {
-	Location getLocation();
+    Location getLocation();
 }
diff --git a/src/main/java/org/openpnp/model/Footprint.java b/src/main/java/org/openpnp/model/Footprint.java
index 2d12ee5aec..c6a0955d9b 100755
--- a/src/main/java/org/openpnp/model/Footprint.java
+++ b/src/main/java/org/openpnp/model/Footprint.java
@@ -1,22 +1,20 @@
 /*
-    Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
-    
-    This file is part of OpenPnP.
-    
-    OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
-    
-    For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -32,36 +30,36 @@
 import org.simpleframework.xml.ElementList;
 
 /**
- * A Footprint is a group of SMD pads along with length unit information.
- * Footprints can be rendered to a Shape for easy display using 2D primitives.
+ * A Footprint is a group of SMD pads along with length unit information. Footprints can be rendered
+ * to a Shape for easy display using 2D primitives.
  */
 public class Footprint {
     @Attribute
     private LengthUnit units = LengthUnit.Millimeters;
-    
-    @ElementList(inline=true, required=false)
+
+    @ElementList(inline = true, required = false)
     private ArrayList<Pad> pads = new ArrayList<>();
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private double bodyWidth;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     private double bodyHeight;
-    
+
     public Shape getShape() {
         Path2D.Double shape = new Path2D.Double();
         for (Pad pad : pads) {
             shape.append(pad.getShape(), false);
         }
-        
+
         Pad body = new Pad();
         body.setWidth(bodyWidth);
         body.setHeight(bodyHeight);
         shape.append(body.getShape(), false);
-        
+
         return shape;
     }
-    
+
     public LengthUnit getUnits() {
         return units;
     }
@@ -69,19 +67,19 @@ public LengthUnit getUnits() {
     public void setUnits(LengthUnit units) {
         this.units = units;
     }
-    
+
     public List<Pad> getPads() {
         return pads;
     }
-    
+
     public void removePad(Pad pad) {
         pads.remove(pad);
     }
-    
+
     public void addPad(Pad pad) {
         pads.add(pad);
     }
-    
+
     public double getBodyWidth() {
         return bodyWidth;
     }
@@ -103,97 +101,91 @@ public void setBodyHeight(double bodyHeight) {
     public static class Pad {
         @Attribute
         private String name;
-        
+
         @Attribute
         private double x;
-        
+
         @Attribute
         private double y;
-        
+
         @Attribute
         private double width;
-        
+
         @Attribute
         private double height;
-        
-        @Attribute(required=false)
+
+        @Attribute(required = false)
         private double rotation = 0;
-        
+
         /**
-         * Roundness as a percentage of the width and height. 0 is square,
-         * 100 is round.
+         * Roundness as a percentage of the width and height. 0 is square, 100 is round.
          */
-        @Attribute(required=false)
+        @Attribute(required = false)
         private double roundness = 0;
-        
+
         public String getName() {
             return name;
         }
-        
+
         public void setName(String name) {
             this.name = name;
         }
-        
+
         public double getX() {
             return x;
         }
-        
+
         public void setX(double x) {
             this.x = x;
         }
-        
+
         public double getY() {
             return y;
         }
-        
+
         public void setY(double y) {
             this.y = y;
         }
-        
+
         public double getWidth() {
             return width;
         }
-        
+
         public void setWidth(double width) {
             this.width = width;
         }
-        
+
         public double getHeight() {
             return height;
         }
-        
+
         public void setHeight(double height) {
             this.height = height;
         }
-        
+
         public double getRotation() {
             return rotation;
         }
-        
+
         public void setRotation(double rotation) {
             this.rotation = rotation;
         }
-        
+
         public double getRoundness() {
             return roundness;
         }
-        
+
         public void setRoundness(double roundness) {
             this.roundness = roundness;
         }
-        
+
         public Shape getShape() {
-            Shape shape = new RoundRectangle2D.Double(
-                    -width / 2,
-                    -height / 2,
-                    width,
-                    height,
-                    width / 100.0 * roundness,
-                    height / 100.0 * roundness);
+            Shape shape = new RoundRectangle2D.Double(-width / 2, -height / 2, width, height,
+                    width / 100.0 * roundness, height / 100.0 * roundness);
             AffineTransform tx = new AffineTransform();
             tx.translate(x, -y);
             tx.rotate(Math.toRadians(-rotation));
             return tx.createTransformedShape(shape);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/model/Identifiable.java b/src/main/java/org/openpnp/model/Identifiable.java
index 7b45181055..6943447a7a 100755
--- a/src/main/java/org/openpnp/model/Identifiable.java
+++ b/src/main/java/org/openpnp/model/Identifiable.java
@@ -1,26 +1,24 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
 public interface Identifiable {
-	public String getId();
+    public String getId();
 }
diff --git a/src/main/java/org/openpnp/model/Job.java b/src/main/java/org/openpnp/model/Job.java
index 3730ea5119..74f64237de 100755
--- a/src/main/java/org/openpnp/model/Job.java
+++ b/src/main/java/org/openpnp/model/Job.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -33,71 +31,71 @@
 import org.simpleframework.xml.core.Commit;
 
 /**
- * A Job specifies a list of one or more BoardLocations. 
+ * A Job specifies a list of one or more BoardLocations.
  */
-@Root(name="openpnp-job")
+@Root(name = "openpnp-job")
 public class Job extends AbstractModelObject implements PropertyChangeListener {
-	@ElementList
-	private ArrayList<BoardLocation> boardLocations = new ArrayList<>();
-	
-	private transient File file;
-	private transient boolean dirty;
-	
-	public Job() {
-		addPropertyChangeListener(this);
-	}
-	
-	@SuppressWarnings("unused")
+    @ElementList
+    private ArrayList<BoardLocation> boardLocations = new ArrayList<>();
+
+    private transient File file;
+    private transient boolean dirty;
+
+    public Job() {
+        addPropertyChangeListener(this);
+    }
+
+    @SuppressWarnings("unused")
     @Commit
-	private void commit() {
-		for (BoardLocation boardLocation : boardLocations) {
-			boardLocation.addPropertyChangeListener(this);
-		}
-	}
-	
-	public List<BoardLocation> getBoardLocations() {
-		return Collections.unmodifiableList(boardLocations);
-	}
+    private void commit() {
+        for (BoardLocation boardLocation : boardLocations) {
+            boardLocation.addPropertyChangeListener(this);
+        }
+    }
+
+    public List<BoardLocation> getBoardLocations() {
+        return Collections.unmodifiableList(boardLocations);
+    }
+
+    public void addBoardLocation(BoardLocation boardLocation) {
+        Object oldValue = boardLocations;
+        boardLocations = new ArrayList<>(boardLocations);
+        boardLocations.add(boardLocation);
+        firePropertyChange("boardLocations", oldValue, boardLocations);
+        boardLocation.addPropertyChangeListener(this);
+    }
+
+    public void removeBoardLocation(BoardLocation boardLocation) {
+        Object oldValue = boardLocations;
+        boardLocations = new ArrayList<>(boardLocations);
+        boardLocations.remove(boardLocation);
+        firePropertyChange("boardLocations", oldValue, boardLocations);
+        boardLocation.removePropertyChangeListener(this);
+    }
+
+    public File getFile() {
+        return file;
+    }
+
+    public void setFile(File file) {
+        Object oldValue = this.file;
+        this.file = file;
+        firePropertyChange("file", oldValue, file);
+    }
 
-	public void addBoardLocation(BoardLocation boardLocation) {
-		Object oldValue = boardLocations;
-		boardLocations = new ArrayList<>(boardLocations);
-		boardLocations.add(boardLocation);
-		firePropertyChange("boardLocations", oldValue, boardLocations);
-		boardLocation.addPropertyChangeListener(this);
-	}
-	
-	public void removeBoardLocation(BoardLocation boardLocation) {
-		Object oldValue = boardLocations;
-		boardLocations = new ArrayList<>(boardLocations);
-		boardLocations.remove(boardLocation);
-		firePropertyChange("boardLocations", oldValue, boardLocations);
-		boardLocation.removePropertyChangeListener(this);
-	}
+    public boolean isDirty() {
+        return dirty;
+    }
 
-	public File getFile() {
-		return file;
-	}
+    public void setDirty(boolean dirty) {
+        boolean oldValue = this.dirty;
+        this.dirty = dirty;
+        firePropertyChange("dirty", oldValue, dirty);
+    }
 
-	public void setFile(File file) {
-		Object oldValue = this.file;
-		this.file = file;
-		firePropertyChange("file", oldValue, file);
-	}
-	
-	public boolean isDirty() {
-		return dirty;
-	}
-	
-	public void setDirty(boolean dirty) {
-		boolean oldValue = this.dirty;
-		this.dirty = dirty;
-		firePropertyChange("dirty", oldValue, dirty);
-	}
-	
-	public void propertyChange(PropertyChangeEvent evt) {
-		if (evt.getSource() != Job.this || !evt.getPropertyName().equals("dirty")) {
-			setDirty(true);
-		}
-	}
+    public void propertyChange(PropertyChangeEvent evt) {
+        if (evt.getSource() != Job.this || !evt.getPropertyName().equals("dirty")) {
+            setDirty(true);
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Length.java b/src/main/java/org/openpnp/model/Length.java
index 5230fc4fbc..3510f1b5ee 100755
--- a/src/main/java/org/openpnp/model/Length.java
+++ b/src/main/java/org/openpnp/model/Length.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
@@ -28,278 +26,275 @@
 
 
 public class Length {
-	public enum Field {
-		X,
-		Y,
-		Z
-	}
-	
-	@Attribute
-	private double value;
-	@Attribute
-	private LengthUnit units;
-	
-	public Length() {
-		
-	}
-	
-	public Length(double value, LengthUnit units) {
-		this.value = value;
-		this.units = units;
-	}
-	
-	public Length add(Length length) {
-		length = length.convertToUnits(units);
-		return new Length(value + length.getValue(), units);
-	}
-	
-	public Length subtract(Length length) {
-		length = length.convertToUnits(units);
-		return new Length(value - length.getValue(), units);
-	}
-	
-	public Length multiply(Length length) {
-		length = length.convertToUnits(units);
-		return new Length(value * length.getValue(), units);
-	}
-	
-	public Length add(double d) {
-		return new Length(value + d, units);
-	}
-	
-	public Length subtract(double d) {
-		return new Length(value - d, units);
-	}
-	
-	public Length multiply(double d) {
-		return new Length(value * d, units);
-	}
-	
-	public double getValue() {
-		return value;
-	}
-	
- 	public void setValue(double value) {
-		this.value = value;
-	}
- 	
-	public LengthUnit getUnits() {
-		return units;
-	}
-	
-	public void setUnits(LengthUnit units) {
-		this.units = units;
-	}
-	
-	public Length convertToUnits(LengthUnit units) {
-		if (this.units == units) {
-			return this;
-		}
-		double mm = 0;
-		if (this.units == LengthUnit.Millimeters) {
-			mm = value;
-		}
-		else if (this.units == LengthUnit.Centimeters) {
-			mm = value * 10;
-		}
-		else if (this.units == LengthUnit.Meters) {
-			mm = value * 1000;
-		}
-		else if (this.units == LengthUnit.Inches) {
-			mm = value * 25.4;
-		}
-		else if (this.units == LengthUnit.Feet) {
-			mm = value * 25.4 * 12;
-		}
-		else {
-			throw new Error("convertLength() unrecognized units " + this.units);
-		}
-		
-		if (units == LengthUnit.Millimeters) {
-			return new Length(mm, units);
-		}
-		else if (units == LengthUnit.Centimeters) {
-			return new Length(mm / 10, units);
-		}
-		else if (units == LengthUnit.Meters) {
-			return new Length(mm / 1000, units);
-		}
-		else if (units == LengthUnit.Inches) {
-			return new Length(mm * (1 / 25.4), units);
-		}
-		else if (units == LengthUnit.Feet) {
-			return new Length(mm * (1 / 25.4) * 12, units);
-		}
-		else {
-			throw new Error("convertLength() unrecognized units " + units);
-		}
-		
-	}
-	
-	public static double convertToUnits(
-	        double value, 
-	        LengthUnit fromUnits, 
-	        LengthUnit toUnits) {
-	    return new Length(value, fromUnits).convertToUnits(toUnits).getValue();
-	}
-	
-	public static Length parse(String s) {
-		return parse(s, false);
-	}
-	
-	/**
-	 * Takes a value in the format of a double followed by any number of spaces
-	 * followed by the shortName of a LengthUnit value and returns the value
-	 * as a Length object. Returns null if the value could not be parsed.
-	 */
-	public static Length parse(String s, boolean requireUnits) {
-		if (s == null) {
-			return null;
-		}
-		
-		s = s.trim();
-		
-		Length length = new Length(0, null);
-		// find the index of the first character that is not a -, . or digit.
-		int startOfUnits = -1;
-		for (int i = 0; i < s.length(); i++) {
-			char ch = s.charAt(i);
-			if (ch != '-' && ch != '.' && !Character.isDigit(ch)) {
-				startOfUnits = i;
-				break;
-			}
-		}
-		
-		String valueString = null;
-		if (startOfUnits != -1) {
-			valueString = s.substring(0, startOfUnits);
-			String unitsString = s.substring(startOfUnits);
-			unitsString = unitsString.trim();
-			for (LengthUnit lengthUnit : LengthUnit.values()) {
-				if (lengthUnit.getShortName().equalsIgnoreCase(unitsString)) {
-					length.setUnits(lengthUnit);
-					break;
-				}
-			}
-		}
-		else {
-			valueString = s;
-		}
-		
-		if (requireUnits && length.getUnits() == null) {
-			return null;
-		}
-		
-		try {
-			double value = Double.parseDouble(valueString);
-			length.setValue(value);
-		}
-		catch (Exception e) {
-			return null;
-		}
-		
-		return length;
-	}
-	
-	@Override
-	public String toString() {
-		return String.format(Locale.US,"%2.3f%s", value, units.getShortName());
-	}
-	
-	/**
-	 * Performs the same function as toString() but allows the caller to specify
-	 * the format String that is used. The format String should contain %f and
-	 * %s in that order for value and units.getShortName().
-	 * @param fmt
-	 * @return
-	 */
-	public String toString(String fmt) {
-		if (fmt == null) {
-			return toString();
-		}
-		return String.format(Locale.US,fmt, value, units.getShortName());
-	}
-	
-	@Override
-	public int hashCode() {
-		final int prime = 31;
-		int result = 1;
-		result = prime * result + ((units == null) ? 0 : units.hashCode());
-		long temp;
-		temp = Double.doubleToLongBits(value);
-		result = prime * result + (int) (temp ^ (temp >>> 32));
-		return result;
-	}
-
-	@Override
-	public boolean equals(Object obj) {
-		if (this == obj)
-			return true;
-		if (obj == null)
-			return false;
-		if (getClass() != obj.getClass())
-			return false;
-		Length other = (Length) obj;
-		if (units != other.units)
-			return false;
-		if (Double.doubleToLongBits(value) != Double.doubleToLongBits(other.value))
-			return false;
-		return true;
-	}
-	
-	public static Location setLocationField(Configuration configuration, Location location, Length length, Field field, boolean defaultToOldUnits) {
-		Length oldLength = null;
-		if (field == Field.X) {
-			oldLength = location.getLengthX();
-		}
-		else if (field == Field.Y) {
-			oldLength = location.getLengthY();
-		}
-		else if (field == Field.Z) {
-			oldLength = location.getLengthZ();
-		}
-		if (length.getUnits() == null) {
-			if (defaultToOldUnits) {
-				length.setUnits(oldLength.getUnits());
-			}
-			if (length.getUnits() == null) {
-				length.setUnits(configuration.getSystemUnits());
-			}
-		}
-		if (location.getUnits() == null) {
-		    throw new Error("This can't happen!");
-		}
-		else {
-			location = location.convertToUnits(length.getUnits());
-		}
-		if (field == Field.X) {
-		    location = location.derive(length.getValue(), null, null,null);
-		}
-		else if (field == Field.Y) {
-            location = location.derive(null, length.getValue(), null,null);
-		}
-		else if (field == Field.Z) {
+    public enum Field {
+        X, Y, Z
+    }
+
+    @Attribute
+    private double value;
+    @Attribute
+    private LengthUnit units;
+
+    public Length() {
+
+    }
+
+    public Length(double value, LengthUnit units) {
+        this.value = value;
+        this.units = units;
+    }
+
+    public Length add(Length length) {
+        length = length.convertToUnits(units);
+        return new Length(value + length.getValue(), units);
+    }
+
+    public Length subtract(Length length) {
+        length = length.convertToUnits(units);
+        return new Length(value - length.getValue(), units);
+    }
+
+    public Length multiply(Length length) {
+        length = length.convertToUnits(units);
+        return new Length(value * length.getValue(), units);
+    }
+
+    public Length add(double d) {
+        return new Length(value + d, units);
+    }
+
+    public Length subtract(double d) {
+        return new Length(value - d, units);
+    }
+
+    public Length multiply(double d) {
+        return new Length(value * d, units);
+    }
+
+    public double getValue() {
+        return value;
+    }
+
+    public void setValue(double value) {
+        this.value = value;
+    }
+
+    public LengthUnit getUnits() {
+        return units;
+    }
+
+    public void setUnits(LengthUnit units) {
+        this.units = units;
+    }
+
+    public Length convertToUnits(LengthUnit units) {
+        if (this.units == units) {
+            return this;
+        }
+        double mm = 0;
+        if (this.units == LengthUnit.Millimeters) {
+            mm = value;
+        }
+        else if (this.units == LengthUnit.Centimeters) {
+            mm = value * 10;
+        }
+        else if (this.units == LengthUnit.Meters) {
+            mm = value * 1000;
+        }
+        else if (this.units == LengthUnit.Inches) {
+            mm = value * 25.4;
+        }
+        else if (this.units == LengthUnit.Feet) {
+            mm = value * 25.4 * 12;
+        }
+        else {
+            throw new Error("convertLength() unrecognized units " + this.units);
+        }
+
+        if (units == LengthUnit.Millimeters) {
+            return new Length(mm, units);
+        }
+        else if (units == LengthUnit.Centimeters) {
+            return new Length(mm / 10, units);
+        }
+        else if (units == LengthUnit.Meters) {
+            return new Length(mm / 1000, units);
+        }
+        else if (units == LengthUnit.Inches) {
+            return new Length(mm * (1 / 25.4), units);
+        }
+        else if (units == LengthUnit.Feet) {
+            return new Length(mm * (1 / 25.4) * 12, units);
+        }
+        else {
+            throw new Error("convertLength() unrecognized units " + units);
+        }
+
+    }
+
+    public static double convertToUnits(double value, LengthUnit fromUnits, LengthUnit toUnits) {
+        return new Length(value, fromUnits).convertToUnits(toUnits).getValue();
+    }
+
+    public static Length parse(String s) {
+        return parse(s, false);
+    }
+
+    /**
+     * Takes a value in the format of a double followed by any number of spaces followed by the
+     * shortName of a LengthUnit value and returns the value as a Length object. Returns null if the
+     * value could not be parsed.
+     */
+    public static Length parse(String s, boolean requireUnits) {
+        if (s == null) {
+            return null;
+        }
+
+        s = s.trim();
+
+        Length length = new Length(0, null);
+        // find the index of the first character that is not a -, . or digit.
+        int startOfUnits = -1;
+        for (int i = 0; i < s.length(); i++) {
+            char ch = s.charAt(i);
+            if (ch != '-' && ch != '.' && !Character.isDigit(ch)) {
+                startOfUnits = i;
+                break;
+            }
+        }
+
+        String valueString = null;
+        if (startOfUnits != -1) {
+            valueString = s.substring(0, startOfUnits);
+            String unitsString = s.substring(startOfUnits);
+            unitsString = unitsString.trim();
+            for (LengthUnit lengthUnit : LengthUnit.values()) {
+                if (lengthUnit.getShortName().equalsIgnoreCase(unitsString)) {
+                    length.setUnits(lengthUnit);
+                    break;
+                }
+            }
+        }
+        else {
+            valueString = s;
+        }
+
+        if (requireUnits && length.getUnits() == null) {
+            return null;
+        }
+
+        try {
+            double value = Double.parseDouble(valueString);
+            length.setValue(value);
+        }
+        catch (Exception e) {
+            return null;
+        }
+
+        return length;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%2.3f%s", value, units.getShortName());
+    }
+
+    /**
+     * Performs the same function as toString() but allows the caller to specify the format String
+     * that is used. The format String should contain %f and %s in that order for value and
+     * units.getShortName().
+     * 
+     * @param fmt
+     * @return
+     */
+    public String toString(String fmt) {
+        if (fmt == null) {
+            return toString();
+        }
+        return String.format(Locale.US, fmt, value, units.getShortName());
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((units == null) ? 0 : units.hashCode());
+        long temp;
+        temp = Double.doubleToLongBits(value);
+        result = prime * result + (int) (temp ^ (temp >>> 32));
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        Length other = (Length) obj;
+        if (units != other.units)
+            return false;
+        if (Double.doubleToLongBits(value) != Double.doubleToLongBits(other.value))
+            return false;
+        return true;
+    }
+
+    public static Location setLocationField(Configuration configuration, Location location,
+            Length length, Field field, boolean defaultToOldUnits) {
+        Length oldLength = null;
+        if (field == Field.X) {
+            oldLength = location.getLengthX();
+        }
+        else if (field == Field.Y) {
+            oldLength = location.getLengthY();
+        }
+        else if (field == Field.Z) {
+            oldLength = location.getLengthZ();
+        }
+        if (length.getUnits() == null) {
+            if (defaultToOldUnits) {
+                length.setUnits(oldLength.getUnits());
+            }
+            if (length.getUnits() == null) {
+                length.setUnits(configuration.getSystemUnits());
+            }
+        }
+        if (location.getUnits() == null) {
+            throw new Error("This can't happen!");
+        }
+        else {
+            location = location.convertToUnits(length.getUnits());
+        }
+        if (field == Field.X) {
+            location = location.derive(length.getValue(), null, null, null);
+        }
+        else if (field == Field.Y) {
+            location = location.derive(null, length.getValue(), null, null);
+        }
+        else if (field == Field.Z) {
             location = location.derive(null, null, length.getValue(), null);
-		}
-		return location;
-	}
-	
-	/**
-	 * Sets the specified field on the passed Location object. Enforces
-	 * application specific unit conversion. If the new Length value does not
-	 * have units set, this method will set the units of the Length to the
-	 * system default units. If the Location itself does not have units set,
-	 * the Location's units are set to the Length's units. Finally, if the
-	 * Location's units have changed, the entire Location is converted to the
-	 * new units and the new object is returned. 
-	 * @param configuration
-	 * @param location
-	 * @param length
-	 * @param field
-	 * @return
-	 */
-	public static Location setLocationField(Configuration configuration, Location location, Length length, Field field) {
-		return setLocationField(configuration, location, length, field, false);
-	}
-	
+        }
+        return location;
+    }
+
+    /**
+     * Sets the specified field on the passed Location object. Enforces application specific unit
+     * conversion. If the new Length value does not have units set, this method will set the units
+     * of the Length to the system default units. If the Location itself does not have units set,
+     * the Location's units are set to the Length's units. Finally, if the Location's units have
+     * changed, the entire Location is converted to the new units and the new object is returned.
+     * 
+     * @param configuration
+     * @param location
+     * @param length
+     * @param field
+     * @return
+     */
+    public static Location setLocationField(Configuration configuration, Location location,
+            Length length, Field field) {
+        return setLocationField(configuration, location, length, field, false);
+    }
+
 }
diff --git a/src/main/java/org/openpnp/model/LengthUnit.java b/src/main/java/org/openpnp/model/LengthUnit.java
index 6a08fe8a08..74dc432ce3 100755
--- a/src/main/java/org/openpnp/model/LengthUnit.java
+++ b/src/main/java/org/openpnp/model/LengthUnit.java
@@ -1,47 +1,42 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
 
 public enum LengthUnit {
-	Meters("m", "Meter"),
-	Centimeters("cm", "Centimeter"),
-	Millimeters("mm", "Millimeter"),
-	Feet("'", "Foot"),
-	Inches("\"", "Inch");
-	
-	private final String shortName;
-	
-	private final String singularName;
-	
-	private LengthUnit(String shortName, String singularName) {
-		this.shortName = shortName;
-		this.singularName = singularName;
-	}
-	
-	public String getShortName() {
-		return shortName;
-	}
+    Meters("m", "Meter"), Centimeters("cm", "Centimeter"), Millimeters("mm",
+            "Millimeter"), Feet("'", "Foot"), Inches("\"", "Inch");
+
+    private final String shortName;
+
+    private final String singularName;
+
+    private LengthUnit(String shortName, String singularName) {
+        this.shortName = shortName;
+        this.singularName = singularName;
+    }
+
+    public String getShortName() {
+        return shortName;
+    }
 
-	public String getSingularName() {
-		return singularName;
-	}
+    public String getSingularName() {
+        return singularName;
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Location.java b/src/main/java/org/openpnp/model/Location.java
index f2fc0698a6..d941b11811 100755
--- a/src/main/java/org/openpnp/model/Location.java
+++ b/src/main/java/org/openpnp/model/Location.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -26,289 +24,287 @@
 import org.simpleframework.xml.Attribute;
 
 /**
- * A Location is a an immutable 3D point in X, Y, Z space with a rotation
- * component. The rotation is applied about the Z axis.
+ * A Location is a an immutable 3D point in X, Y, Z space with a rotation component. The rotation is
+ * applied about the Z axis.
  */
 public class Location {
     /*
-     * The fields on this class would be final in a perfect world, but that
-     * doesn't work correctly with the XML serialization.
+     * The fields on this class would be final in a perfect world, but that doesn't work correctly
+     * with the XML serialization.
      */
-    
-	@Attribute
-	private LengthUnit units;
-	@Attribute(required=false)
-	private double x;
-	@Attribute(required=false)
-	private double y;
-	@Attribute(required=false)
-	private double z;
-	@Attribute(required=false)
-	private double rotation;
-	
-	/**
-	 * Only used by XML serialization.
-	 */
-	@SuppressWarnings("unused")
+
+    @Attribute
+    private LengthUnit units;
+    @Attribute(required = false)
+    private double x;
+    @Attribute(required = false)
+    private double y;
+    @Attribute(required = false)
+    private double z;
+    @Attribute(required = false)
+    private double rotation;
+
+    /**
+     * Only used by XML serialization.
+     */
+    @SuppressWarnings("unused")
     private Location() {
-	    this(null);
-	}
-	
-	public Location(LengthUnit units) {
-	    this(units, 0, 0, 0, 0);
-	}
-	
-	public Location(LengthUnit units, double x, double y, double z, double rotation) {
-	    this.units = units;
-	    this.x = x;
-	    this.y = y;
-	    this.z = z;
-	    this.rotation = rotation;
-	}
-	
-	public double getX() {
-		return x;
-	}
-	
-	public double getY() {
-		return y;
-	}
-	
-	public double getZ() {
-		return z;
-	}
-
-	public double getRotation() {
-		return rotation;
-	}
-
-	public LengthUnit getUnits() {
-		return units;
-	}
-
-	public Location convertToUnits(LengthUnit units) {
-		Location location = new Location(
-		        units,
-		        new Length(x, this.units).convertToUnits(units).getValue(),
-		        new Length(y, this.units).convertToUnits(units).getValue(),
-		        new Length(z, this.units).convertToUnits(units).getValue(),
-		        rotation);
-		return location;
-	}
-	
-	public Length getLinearLengthTo(Location location) {
-		double distance = getLinearDistanceTo(location);
-		return new Length(distance, getUnits());
-	}
-	
-	/**
-	 * Returns the distance between this Location and the specified Location
-	 * in the units of this Location.
-	 * @param location
-	 * @return
-	 */
-	public double getLinearDistanceTo(Location location) {
-	    location = location.convertToUnits(getUnits());
-		return getLinearDistanceTo(location.getX(), location.getY());
-	}
-
-	public double getLinearDistanceTo(double x, double y) {
-		return (Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2)));
-	}
-	
-	public double getXyzDistanceTo(Location location) {
-	    location = location.convertToUnits(getUnits());
-		return (Math.sqrt(Math.pow(this.x - location.getX(), 2) + Math.pow(this.y - location.getY(), 2) + Math.pow(this.z - location.getZ(), 2)) );
-	}
-	
-	public Length getLengthX() {
-		return new Length(x, units);
-	}
-	
-	public Length getLengthY() {
-		return new Length(y, units);
-	}
-	
-	public Length getLengthZ() {
-		return new Length(z, units);
-	}
-	
-	/**
-	 * Returns a new Location with the given Location's X, Y, and Z components
-	 * subtracted from this Location's X, Y, and Z components. Rotation is left
-	 * unchanged.
-	 * @param l
-	 * @return
-	 */
-	public Location subtract(Location l) {
-		l = l.convertToUnits(getUnits());
-		return new Location(l.getUnits(), x - l.getX(), y - l.getY(), z - l.getZ(), getRotation());
-	}
-	
-	/**
-	 * Same as {@link Location#subtract(Location)} but also subtracts rotation.
-	 * @param l
-	 * @return
-	 */
-	public Location subtractWithRotation(Location l) {
+        this(null);
+    }
+
+    public Location(LengthUnit units) {
+        this(units, 0, 0, 0, 0);
+    }
+
+    public Location(LengthUnit units, double x, double y, double z, double rotation) {
+        this.units = units;
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        this.rotation = rotation;
+    }
+
+    public double getX() {
+        return x;
+    }
+
+    public double getY() {
+        return y;
+    }
+
+    public double getZ() {
+        return z;
+    }
+
+    public double getRotation() {
+        return rotation;
+    }
+
+    public LengthUnit getUnits() {
+        return units;
+    }
+
+    public Location convertToUnits(LengthUnit units) {
+        Location location =
+                new Location(units, new Length(x, this.units).convertToUnits(units).getValue(),
+                        new Length(y, this.units).convertToUnits(units).getValue(),
+                        new Length(z, this.units).convertToUnits(units).getValue(), rotation);
+        return location;
+    }
+
+    public Length getLinearLengthTo(Location location) {
+        double distance = getLinearDistanceTo(location);
+        return new Length(distance, getUnits());
+    }
+
+    /**
+     * Returns the distance between this Location and the specified Location in the units of this
+     * Location.
+     * 
+     * @param location
+     * @return
+     */
+    public double getLinearDistanceTo(Location location) {
+        location = location.convertToUnits(getUnits());
+        return getLinearDistanceTo(location.getX(), location.getY());
+    }
+
+    public double getLinearDistanceTo(double x, double y) {
+        return (Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2)));
+    }
+
+    public double getXyzDistanceTo(Location location) {
+        location = location.convertToUnits(getUnits());
+        return (Math.sqrt(Math.pow(this.x - location.getX(), 2)
+                + Math.pow(this.y - location.getY(), 2) + Math.pow(this.z - location.getZ(), 2)));
+    }
+
+    public Length getLengthX() {
+        return new Length(x, units);
+    }
+
+    public Length getLengthY() {
+        return new Length(y, units);
+    }
+
+    public Length getLengthZ() {
+        return new Length(z, units);
+    }
+
+    /**
+     * Returns a new Location with the given Location's X, Y, and Z components subtracted from this
+     * Location's X, Y, and Z components. Rotation is left unchanged.
+     * 
+     * @param l
+     * @return
+     */
+    public Location subtract(Location l) {
         l = l.convertToUnits(getUnits());
-        return new Location(l.getUnits(), x - l.getX(), y - l.getY(), z - l.getZ(), rotation - l.getRotation());
-	}
-	
-	/**
-	 * Returns a new Location with the given Location's X, Y, and Z components
-	 * added to this Location's X, Y, and Z components. Rotation is left
-	 * unchanged.
-	 * @param l
-	 * @return
-	 */
-	public Location add(Location l) {
-		l = l.convertToUnits(getUnits());
-		return new Location(l.getUnits(), x + l.getX(), y + l.getY(), z + l.getZ(), rotation);
-	}
+        return new Location(l.getUnits(), x - l.getX(), y - l.getY(), z - l.getZ(), getRotation());
+    }
 
     /**
-     * Returns a new Location with the given Location's X, Y, and Z components
-     * added to this Location's X, Y, and Z components. Rotation is left
-     * unchanged.
+     * Same as {@link Location#subtract(Location)} but also subtracts rotation.
+     * 
+     * @param l
+     * @return
+     */
+    public Location subtractWithRotation(Location l) {
+        l = l.convertToUnits(getUnits());
+        return new Location(l.getUnits(), x - l.getX(), y - l.getY(), z - l.getZ(),
+                rotation - l.getRotation());
+    }
+
+    /**
+     * Returns a new Location with the given Location's X, Y, and Z components added to this
+     * Location's X, Y, and Z components. Rotation is left unchanged.
+     * 
+     * @param l
+     * @return
+     */
+    public Location add(Location l) {
+        l = l.convertToUnits(getUnits());
+        return new Location(l.getUnits(), x + l.getX(), y + l.getY(), z + l.getZ(), rotation);
+    }
+
+    /**
+     * Returns a new Location with the given Location's X, Y, and Z components added to this
+     * Location's X, Y, and Z components. Rotation is left unchanged.
+     * 
      * @param l
      * @return
      */
     public Location addWithRotation(Location l) {
         l = l.convertToUnits(getUnits());
-        return new Location(l.getUnits(), x + l.getX(), y + l.getY(), z + l.getZ(), rotation + l.getRotation());
+        return new Location(l.getUnits(), x + l.getX(), y + l.getY(), z + l.getZ(),
+                rotation + l.getRotation());
     }
-    
-	/**
-	 * Returns a new Location with the given Location's X, Y and Z components
-	 * multiplied by this Location's X, Y and Z components. Rotation is left
-	 * unchanged.
-	 * @param l
-	 * @return
-	 */
-	public Location multiply(Location l) {
-	    l = l.convertToUnits(getUnits());
+
+    /**
+     * Returns a new Location with the given Location's X, Y and Z components multiplied by this
+     * Location's X, Y and Z components. Rotation is left unchanged.
+     * 
+     * @param l
+     * @return
+     */
+    public Location multiply(Location l) {
+        l = l.convertToUnits(getUnits());
         return new Location(l.getUnits(), x * l.getX(), y * l.getY(), z * l.getZ(), getRotation());
-	}
-	
-	/**
-	 * Returns a new Location based on this Location with values multiplied by
-	 * the specified values. Units are the same as this Location.
-	 * @param x
-	 * @param y
-	 * @param z
-	 * @param rotation
-	 * @return
-	 */
-	public Location multiply(double x, double y, double z, double rotation) {
-        return new Location(getUnits(), x * getX(), y * getY(), z * getZ(), rotation * getRotation());
-	}
-	
-	/**
-	 * Returns a new Location with the same units as this one and with any of
-	 * fields specified as true inverted from the values of this one.
-	 * Specifically, if one of the x, y, z or rotation fields are specified
-	 * true in the method call, that field will be multipled by -1 in the
-	 * returned Location.
-	 * @param x
-	 * @param y
-	 * @param z
-	 * @param rotation
-	 * @return
-	 */
-	public Location invert(boolean x, boolean y, boolean z, boolean rotation) {
-	    return new Location(
-	            getUnits(),
-	            getX() * (x ? -1 : 1),
-	            getY() * (y ? -1 : 1),
-	            getZ() * (z ? -1 : 1),
-	            getRotation() * (rotation ? -1 : 1));
-	}
-	
-	/**
-	 * Returns a new Location with the same units as this one but with values
-	 * updated to the passed in values. A caveat is that if a specified value
-	 * is null, the new Location will contain the value from this object
-	 * instead of the new value.
-	 * 
-	 * This is intended as a utility method, useful for creating new Locations
-	 * based on existing ones with one or more values changed.
-	 * @param x
-	 * @param y
-	 * @param z
-	 * @param rotation
-	 * @return
-	 */
-	public Location derive(Double x, Double y, Double z, Double rotation) {
-	    return new Location(
-	            units,
-                x == null ? this.x : x,
-                y == null ? this.y : y,
-                z == null ? this.z : z,
-                rotation == null ? this.rotation : rotation
-	            );
-	}
-	
-	/**
-	 * Returns a new Location with this Location's X and Y rotated by angle.
-	 * Z and Rotation are unchanged.
-	 * @param angle
-	 * @return
-	 */
-	public Location rotateXy(double angle) {
-	    if(angle==0.0) { return this; } 
-	    while(angle<180.) { angle+=360; } 
-	    while(angle>180.) { angle-=360; } 
-	    angle = Math.toRadians(angle);
-        
-	    return new Location(
-	            getUnits(),
-	            getX() * Math.cos(angle) - getY() * Math.sin(angle),
-	            getX() * Math.sin(angle) + getY() * Math.cos(angle),
-	            getZ(),
-	            getRotation()
-	            );
-	}
-	
-	@Override
-	public String toString() {
-		return String.format(Locale.US,"(%f, %f, %f, %f %s)", x, y, z, rotation, units.getShortName());
-	}
-	
-	public Point getXyPoint() {
-	    return new Point(getX(), getY());
-	}
+    }
+
+    /**
+     * Returns a new Location based on this Location with values multiplied by the specified values.
+     * Units are the same as this Location.
+     * 
+     * @param x
+     * @param y
+     * @param z
+     * @param rotation
+     * @return
+     */
+    public Location multiply(double x, double y, double z, double rotation) {
+        return new Location(getUnits(), x * getX(), y * getY(), z * getZ(),
+                rotation * getRotation());
+    }
+
+    /**
+     * Returns a new Location with the same units as this one and with any of fields specified as
+     * true inverted from the values of this one. Specifically, if one of the x, y, z or rotation
+     * fields are specified true in the method call, that field will be multipled by -1 in the
+     * returned Location.
+     * 
+     * @param x
+     * @param y
+     * @param z
+     * @param rotation
+     * @return
+     */
+    public Location invert(boolean x, boolean y, boolean z, boolean rotation) {
+        return new Location(getUnits(), getX() * (x ? -1 : 1), getY() * (y ? -1 : 1),
+                getZ() * (z ? -1 : 1), getRotation() * (rotation ? -1 : 1));
+    }
+
+    /**
+     * Returns a new Location with the same units as this one but with values updated to the passed
+     * in values. A caveat is that if a specified value is null, the new Location will contain the
+     * value from this object instead of the new value.
+     * 
+     * This is intended as a utility method, useful for creating new Locations based on existing
+     * ones with one or more values changed.
+     * 
+     * @param x
+     * @param y
+     * @param z
+     * @param rotation
+     * @return
+     */
+    public Location derive(Double x, Double y, Double z, Double rotation) {
+        return new Location(units, x == null ? this.x : x, y == null ? this.y : y,
+                z == null ? this.z : z, rotation == null ? this.rotation : rotation);
+    }
+
+    /**
+     * Returns a new Location with this Location's X and Y rotated by angle. Z and Rotation are
+     * unchanged.
+     * 
+     * @param angle
+     * @return
+     */
+    public Location rotateXy(double angle) {
+        if (angle == 0.0) {
+            return this;
+        }
+        while (angle < 180.) {
+            angle += 360;
+        }
+        while (angle > 180.) {
+            angle -= 360;
+        }
+        angle = Math.toRadians(angle);
+
+        return new Location(getUnits(), getX() * Math.cos(angle) - getY() * Math.sin(angle),
+                getX() * Math.sin(angle) + getY() * Math.cos(angle), getZ(), getRotation());
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "(%f, %f, %f, %f %s)", x, y, z, rotation,
+                units.getShortName());
+    }
+
+    public Point getXyPoint() {
+        return new Point(getX(), getY());
+    }
 
     /**
-     * Performs a unit agnostic equality check. If the Object being
-     * tested is a Location in a different unit, it is first converted to
-     * the units of this Location and then each value field is compared.
+     * Performs a unit agnostic equality check. If the Object being tested is a Location in a
+     * different unit, it is first converted to the units of this Location and then each value field
+     * is compared.
      */
-	@Override
+    @Override
     public boolean equals(Object obj) {
         if (!(obj instanceof Location)) {
             return false;
         }
         Location that = (Location) obj;
         that = that.convertToUnits(this.units);
-        return this.units == that.units && this.x == that.x && 
-                this.y == that.y && this.z == that.z && 
-                this.rotation == that.rotation; 
+        return this.units == that.units && this.x == that.x && this.y == that.y && this.z == that.z
+                && this.rotation == that.rotation;
     }
 
-	@Override
-	public int hashCode() {
-		int result;
-		long temp;
-		result = this.units != null ? this.units.hashCode() : 0;
-		temp = Double.doubleToLongBits(this.x);
-		result = 31 * result + (int) (temp ^ temp >>> 32);
-		temp = Double.doubleToLongBits(this.y);
-		result = 31 * result + (int) (temp ^ temp >>> 32);
-		temp = Double.doubleToLongBits(this.z);
-		result = 31 * result + (int) (temp ^ temp >>> 32);
-		temp = Double.doubleToLongBits(this.rotation);
-		result = 31 * result + (int) (temp ^ temp >>> 32);
-		return result;
-	}
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        result = this.units != null ? this.units.hashCode() : 0;
+        temp = Double.doubleToLongBits(this.x);
+        result = 31 * result + (int) (temp ^ temp >>> 32);
+        temp = Double.doubleToLongBits(this.y);
+        result = 31 * result + (int) (temp ^ temp >>> 32);
+        temp = Double.doubleToLongBits(this.z);
+        result = 31 * result + (int) (temp ^ temp >>> 32);
+        temp = Double.doubleToLongBits(this.rotation);
+        result = 31 * result + (int) (temp ^ temp >>> 32);
+        return result;
+    }
 }
diff --git a/src/main/java/org/openpnp/model/MassUnit.java b/src/main/java/org/openpnp/model/MassUnit.java
index b9a2d3dc95..e1df848e0c 100755
--- a/src/main/java/org/openpnp/model/MassUnit.java
+++ b/src/main/java/org/openpnp/model/MassUnit.java
@@ -1,46 +1,41 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
 
 public enum MassUnit {
-	Grams("g", "Gram"),
-	Ounces("oz", "Ounce"),
-	Pounds("lb", "Pound"),
-	Kilograms("kg", "Kilogram");
-	
-	private final String shortName;
-	
-	private final String singularName;
-	
-	private MassUnit(String shortName, String singularName) {
-		this.shortName = shortName;
-		this.singularName = singularName;
-	}
-	
-	public String getShortName() {
-		return shortName;
-	}
+    Grams("g", "Gram"), Ounces("oz", "Ounce"), Pounds("lb", "Pound"), Kilograms("kg", "Kilogram");
+
+    private final String shortName;
+
+    private final String singularName;
+
+    private MassUnit(String shortName, String singularName) {
+        this.shortName = shortName;
+        this.singularName = singularName;
+    }
+
+    public String getShortName() {
+        return shortName;
+    }
 
-	public String getSingularName() {
-		return singularName;
-	}
+    public String getSingularName() {
+        return singularName;
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Named.java b/src/main/java/org/openpnp/model/Named.java
index 6552397e40..dee771af44 100755
--- a/src/main/java/org/openpnp/model/Named.java
+++ b/src/main/java/org/openpnp/model/Named.java
@@ -1,27 +1,26 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
 public interface Named {
-	public String getName();
-	public void setName(String name);
+    public String getName();
+
+    public void setName(String name);
 }
diff --git a/src/main/java/org/openpnp/model/Outline.java b/src/main/java/org/openpnp/model/Outline.java
index 63df41d59a..2d118c9413 100755
--- a/src/main/java/org/openpnp/model/Outline.java
+++ b/src/main/java/org/openpnp/model/Outline.java
@@ -12,15 +12,17 @@
 
 public class Outline {
     @ElementListUnion({
-        @ElementList(entry="ellipse", inline=true, required=false, type=Outline.Ellipse.class),
-        @ElementList(entry="line", inline=true, required=false, type=Outline.Line.class),
-        @ElementList(entry="circle", inline=true, required=false, type=Outline.Circle.class)
-    })
+            @ElementList(entry = "ellipse", inline = true, required = false,
+                    type = Outline.Ellipse.class),
+            @ElementList(entry = "line", inline = true, required = false,
+                    type = Outline.Line.class),
+            @ElementList(entry = "circle", inline = true, required = false,
+                    type = Outline.Circle.class)})
     private ArrayList<Outline.OutlineElement> elements = new ArrayList<>();
-    
+
     @Attribute
     private LengthUnit units = LengthUnit.Millimeters;
-    
+
     public Shape getShape() {
         if (elements.isEmpty()) {
             return null;
@@ -29,10 +31,10 @@ public Shape getShape() {
         for (Outline.OutlineElement element : elements) {
             shape.append(element.getShape(), false);
         }
-        
+
         return shape;
     }
-    
+
     public LengthUnit getUnits() {
         return units;
     }
@@ -44,67 +46,55 @@ public void setUnits(LengthUnit units) {
     public static interface OutlineElement {
         Shape getShape();
     }
-    
+
     public static class Line implements Outline.OutlineElement {
         @Attribute
         private double x1;
-        
+
         @Attribute
         private double y1;
-        
+
         @Attribute
         private double x2;
-        
+
         @Attribute
         private double y2;
-        
+
         public Shape getShape() {
-            return new Line2D.Double(
-                    x1,
-                    -y1,
-                    x2,
-                    -y2);
+            return new Line2D.Double(x1, -y1, x2, -y2);
         }
     }
-    
+
     public static class Ellipse implements Outline.OutlineElement {
         @Attribute
         private double x;
-        
+
         @Attribute
         private double y;
-        
+
         @Attribute
         private double width;
-        
+
         @Attribute
         private double height;
 
         public Shape getShape() {
-            return new Ellipse2D.Double(
-                    x - (width / 2), 
-                    y - (height / 2), 
-                    width, 
-                    height);
+            return new Ellipse2D.Double(x - (width / 2), y - (height / 2), width, height);
         }
     }
-    
+
     public static class Circle implements Outline.OutlineElement {
         @Attribute
         private double x;
-        
+
         @Attribute
         private double y;
-        
+
         @Attribute
         private double radius;
-        
+
         public Shape getShape() {
-            return new Ellipse2D.Double(
-                    x - radius, 
-                    y - radius, 
-                    radius * 2, 
-                    radius * 2);
+            return new Ellipse2D.Double(x - radius, y - radius, radius * 2, radius * 2);
         }
-    } 
-}
\ No newline at end of file
+    }
+}
diff --git a/src/main/java/org/openpnp/model/Package.java b/src/main/java/org/openpnp/model/Package.java
index 226a50e011..820f0ee649 100755
--- a/src/main/java/org/openpnp/model/Package.java
+++ b/src/main/java/org/openpnp/model/Package.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -27,14 +25,14 @@
 public class Package implements Identifiable {
     @Attribute
     private String id;
-    
+
     @Attribute(required = false)
     private String description;
-    
+
     @Element(required = false)
     private Outline outline;
-    
-    @Element(required=false)
+
+    @Element(required = false)
     private Footprint footprint;
 
     private Package() {
@@ -51,16 +49,17 @@ public Package(String id) {
     public String getId() {
         return id;
     }
-    
+
     /**
-     * Warning: This should never be called once the Package is added to
-     * the configuration. It should only be used when creating a new package.
+     * Warning: This should never be called once the Package is added to the configuration. It
+     * should only be used when creating a new package.
+     * 
      * @param id
      */
     public void setId(String id) {
         this.id = id;
     }
-    
+
     public String getDescription() {
         return description;
     }
@@ -76,7 +75,7 @@ public Outline getOutline() {
     public void setOutline(Outline outline) {
         this.outline = outline;
     }
-    
+
     public Footprint getFootprint() {
         return footprint;
     }
@@ -84,7 +83,7 @@ public Footprint getFootprint() {
     public void setFootprint(Footprint footprint) {
         this.footprint = footprint;
     }
-    
+
     @Override
     public String toString() {
         return String.format("id %s", id);
diff --git a/src/main/java/org/openpnp/model/Pad.java b/src/main/java/org/openpnp/model/Pad.java
index 0460cb811b..8ba451ee53 100755
--- a/src/main/java/org/openpnp/model/Pad.java
+++ b/src/main/java/org/openpnp/model/Pad.java
@@ -8,89 +8,90 @@
 
 public abstract class Pad extends AbstractModelObject {
     @Attribute
-    protected LengthUnit units = LengthUnit.Millimeters; 
-    
+    protected LengthUnit units = LengthUnit.Millimeters;
+
     public abstract Shape getShape();
+
     public abstract Pad convertToUnits(LengthUnit units);
-    
+
     public LengthUnit getUnits() {
         return units;
     }
-    
+
     public void setUnits(LengthUnit units) {
         Object oldValue = units;
         this.units = units;
         firePropertyChange("units", oldValue, units);
     }
-    
+
     // TODO: Line doesn't really work as a shape, so I am removing it
     // until we really have a need for it at which point it can be revisited.
-//    public static class Line extends Pad {
-//        @Attribute
-//        private double x1;
-//        
-//        @Attribute
-//        private double y1;
-//        
-//        @Attribute
-//        private double x2;
-//        
-//        @Attribute
-//        private double y2;
-//        
-//        public double getX1() {
-//            return x1;
-//        }
-//
-//        public void setX1(double x1) {
-//            double oldValue = this.x1;
-//            this.x1 = x1;
-//            firePropertyChange("x1", oldValue, x1);
-//        }
-//        
-//        public double getY1() {
-//            return y1;
-//        }
-//
-//        public void setY1(double y1) {
-//            double oldValue = this.y1;
-//            this.y1 = y1;
-//            firePropertyChange("y1", oldValue, y1);
-//        }
-//        
-//        public double getX2() {
-//            return x2;
-//        }
-//
-//        public void setX2(double x2) {
-//            double oldValue = this.x2;
-//            this.x2 = x2;
-//            firePropertyChange("x2", oldValue, x2);
-//        }
-//        
-//        public double getY2() {
-//            return y2;
-//        }
-//
-//        public void setY2(double y2) {
-//            double oldValue = this.y2;
-//            this.y2 = y2;
-//            firePropertyChange("y2", oldValue, y2);
-//        }
-//        
-//        public Shape getShape() {
-//            return new Line2D.Double(
-//                    x1,
-//                    y1,
-//                    x2,
-//                    y2);
-//        }
-//    }
-    
+    // public static class Line extends Pad {
+    // @Attribute
+    // private double x1;
+    //
+    // @Attribute
+    // private double y1;
+    //
+    // @Attribute
+    // private double x2;
+    //
+    // @Attribute
+    // private double y2;
+    //
+    // public double getX1() {
+    // return x1;
+    // }
+    //
+    // public void setX1(double x1) {
+    // double oldValue = this.x1;
+    // this.x1 = x1;
+    // firePropertyChange("x1", oldValue, x1);
+    // }
+    //
+    // public double getY1() {
+    // return y1;
+    // }
+    //
+    // public void setY1(double y1) {
+    // double oldValue = this.y1;
+    // this.y1 = y1;
+    // firePropertyChange("y1", oldValue, y1);
+    // }
+    //
+    // public double getX2() {
+    // return x2;
+    // }
+    //
+    // public void setX2(double x2) {
+    // double oldValue = this.x2;
+    // this.x2 = x2;
+    // firePropertyChange("x2", oldValue, x2);
+    // }
+    //
+    // public double getY2() {
+    // return y2;
+    // }
+    //
+    // public void setY2(double y2) {
+    // double oldValue = this.y2;
+    // this.y2 = y2;
+    // firePropertyChange("y2", oldValue, y2);
+    // }
+    //
+    // public Shape getShape() {
+    // return new Line2D.Double(
+    // x1,
+    // y1,
+    // x2,
+    // y2);
+    // }
+    // }
+
     public static class Ellipse extends Pad {
         @Attribute
         private double width;
-        
+
         @Attribute
         private double height;
 
@@ -115,11 +116,7 @@ public void setHeight(double height) {
         }
 
         public Shape getShape() {
-            return new Ellipse2D.Double(
-                    -width / 2, 
-                    -height / 2, 
-                    width, 
-                    height);
+            return new Ellipse2D.Double(-width / 2, -height / 2, width, height);
         }
 
         @Override
@@ -132,11 +129,11 @@ public Ellipse convertToUnits(LengthUnit units) {
         }
     }
 
-    
+
     public static class Circle extends Pad {
         @Attribute
         private double radius;
-        
+
         public double getRadius() {
             return radius;
         }
@@ -148,11 +145,7 @@ public void setRadius(double radius) {
         }
 
         public Shape getShape() {
-            return new Ellipse2D.Double(
-                    -radius, 
-                    -radius, 
-                    radius * 2, 
-                    radius * 2);
+            return new Ellipse2D.Double(-radius, -radius, radius * 2, radius * 2);
         }
 
         @Override
@@ -163,17 +156,17 @@ public Circle convertToUnits(LengthUnit units) {
             return that;
         }
     }
-    
+
     public static class RoundRectangle extends Pad {
         @Attribute
         private double width;
-        
+
         @Attribute
         private double height;
-        
-        @Attribute(required=false)
+
+        @Attribute(required = false)
         private double roundness;
-        
+
         public double getWidth() {
             return width;
         }
@@ -205,13 +198,8 @@ public void setRoundness(double roundness) {
         }
 
         public Shape getShape() {
-            return new RoundRectangle2D.Double(
-                    -width / 2,
-                    -height / 2,
-                    width,
-                    height,
-                    width / 1.0 * roundness,
-                    height / 1.0 * roundness);
+            return new RoundRectangle2D.Double(-width / 2, -height / 2, width, height,
+                    width / 1.0 * roundness, height / 1.0 * roundness);
         }
 
         @Override
@@ -223,5 +211,5 @@ public RoundRectangle convertToUnits(LengthUnit units) {
             // don't convert roundness because it's a percentage
             return that;
         }
-    }    
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Part.java b/src/main/java/org/openpnp/model/Part.java
index ff2cd235c8..f3774a4937 100755
--- a/src/main/java/org/openpnp/model/Part.java
+++ b/src/main/java/org/openpnp/model/Part.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -26,57 +24,56 @@
 import org.simpleframework.xml.core.Persist;
 
 /**
- * A Part is a single part that can be picked and placed. It has a graphical outline, is retrieved from one or more Feeders
- * and is placed at a Placement as part of a Job. Parts can be used across many boards and should generally represent
- * a single part in the real world.
+ * A Part is a single part that can be picked and placed. It has a graphical outline, is retrieved
+ * from one or more Feeders and is placed at a Placement as part of a Job. Parts can be used across
+ * many boards and should generally represent a single part in the real world.
  */
 public class Part extends AbstractModelObject implements Identifiable {
-	@Attribute
-	private String id;
-	@Attribute(required=false)
-	private String name;
-
-	@Attribute
-	private LengthUnit heightUnits = LengthUnit.Millimeters;
-	@Attribute
-	private double height;
-	
-	private Package packag;
-	
-	@Attribute
-	private String packageId;
-	
-	@Attribute(required=false)
-	private double speed = 1.0;
-	
-	
-	@SuppressWarnings("unused")
-	private Part() {
-		this(null);
-	}
-	
-	public Part(String id) {
-		this.id = id;
-		Configuration.get().addListener(new ConfigurationListener.Adapter() {
+    @Attribute
+    private String id;
+    @Attribute(required = false)
+    private String name;
+
+    @Attribute
+    private LengthUnit heightUnits = LengthUnit.Millimeters;
+    @Attribute
+    private double height;
+
+    private Package packag;
+
+    @Attribute
+    private String packageId;
+
+    @Attribute(required = false)
+    private double speed = 1.0;
+
+
+    @SuppressWarnings("unused")
+    private Part() {
+        this(null);
+    }
+
+    public Part(String id) {
+        this.id = id;
+        Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 if (getPackage() == null) {
                     setPackage(configuration.getPackage(packageId));
                 }
             }
-		});
-	}
-	
-	@Persist
-	private void persist() {
-		packageId = (packag == null ? null : packag.getId());
-	}
-
-	@Override
-	public String getId() {
-		return id;
-	}
+        });
+    }
+
+    @Persist
+    private void persist() {
+        packageId = (packag == null ? null : packag.getId());
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
 
     public String getName() {
         return name;
@@ -98,35 +95,36 @@ public void setSpeed(double speed) {
         firePropertyChange("speed", oldValue, speed);
     }
 
-	public Length getHeight() {
-		return new Length(height, heightUnits);
-	}
-	
-	public void setHeight(Length height) {
-		Object oldValue = getHeight();
-		if (height == null) {
-			this.height = 0;
-			this.heightUnits = null;
-		}
-		else {
-			this.height = height.getValue();
-			this.heightUnits = height.getUnits();
-		}
-		firePropertyChange("height", oldValue, getHeight());
-	}
-	
-	public Package getPackage() {
-		return packag;
-	}
-
-	public void setPackage(Package packag) {
-		Object oldValue = this.packag;
-		this.packag = packag;
-		firePropertyChange("package", oldValue, packag);
-	}
-
-	@Override
-	public String toString() {
-		return String.format("id %s, name %s, heightUnits %s, height %f, packageId (%s)", id, name, heightUnits, height, packageId);
-	}
+    public Length getHeight() {
+        return new Length(height, heightUnits);
+    }
+
+    public void setHeight(Length height) {
+        Object oldValue = getHeight();
+        if (height == null) {
+            this.height = 0;
+            this.heightUnits = null;
+        }
+        else {
+            this.height = height.getValue();
+            this.heightUnits = height.getUnits();
+        }
+        firePropertyChange("height", oldValue, getHeight());
+    }
+
+    public Package getPackage() {
+        return packag;
+    }
+
+    public void setPackage(Package packag) {
+        Object oldValue = this.packag;
+        this.packag = packag;
+        firePropertyChange("package", oldValue, packag);
+    }
+
+    @Override
+    public String toString() {
+        return String.format("id %s, name %s, heightUnits %s, height %f, packageId (%s)", id, name,
+                heightUnits, height, packageId);
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Placement.java b/src/main/java/org/openpnp/model/Placement.java
index a77d7befb9..df4c92247c 100755
--- a/src/main/java/org/openpnp/model/Placement.java
+++ b/src/main/java/org/openpnp/model/Placement.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -30,100 +28,97 @@
 
 
 /**
- * A Placement describes a location on a Board where a Part will be placed, 
- * along with information about how to place it. 
+ * A Placement describes a location on a Board where a Part will be placed, along with information
+ * about how to place it.
+ * 
  * @author jason
  */
 public class Placement extends AbstractModelObject implements Identifiable {
     public enum Type {
-        Place,
-        Fiducial,
-        Ignore
+        Place, Fiducial, Ignore
     }
-    
+
     /**
-     * History:
-     * 1.0: Initial revision.
-     * 1.1: Replaced Boolean place with Type type. Deprecated place.
+     * History: 1.0: Initial revision. 1.1: Replaced Boolean place with Type type. Deprecated place.
      */
-    @Version(revision=1.1)
+    @Version(revision = 1.1)
     private double version;
-    
-	@Attribute
-	private String id;
-	@Element
-	private Location location;
-	@Attribute
-	private Side side = Side.Top;
-	
-	@Attribute(required=false)
-	private String partId;
-	
-	@Deprecated
-	@Attribute(required=false)
-	private Boolean place;
-	
-	@Attribute
-	private Type type;
-	
-	private Part part;
-
-	@SuppressWarnings("unused")
-	private Placement() {
-		this(null);
-	}
-	
-	public Placement(String id) {
-		this.id = id;
-		this.type = Type.Place;
-		setLocation(new Location(LengthUnit.Millimeters));
-	}
-	
-	@SuppressWarnings("unused")
-	@Persist
-	private void persist() {
-		partId = (part == null ? null : part.getId());
-	}
-	
-	@SuppressWarnings("unused")
-	@Commit
-	private void commit() {
-		setLocation(location);
+
+    @Attribute
+    private String id;
+    @Element
+    private Location location;
+    @Attribute
+    private Side side = Side.Top;
+
+    @Attribute(required = false)
+    private String partId;
+
+    @Deprecated
+    @Attribute(required = false)
+    private Boolean place;
+
+    @Attribute
+    private Type type;
+
+    private Part part;
+
+    @SuppressWarnings("unused")
+    private Placement() {
+        this(null);
+    }
+
+    public Placement(String id) {
+        this.id = id;
+        this.type = Type.Place;
+        setLocation(new Location(LengthUnit.Millimeters));
+    }
+
+    @SuppressWarnings("unused")
+    @Persist
+    private void persist() {
+        partId = (part == null ? null : part.getId());
+    }
+
+    @SuppressWarnings("unused")
+    @Commit
+    private void commit() {
+        setLocation(location);
         if (getPart() == null) {
             setPart(Configuration.get().getPart(partId));
         }
-        
+
         if (version == 1.0) {
             if (place != null && !place) {
                 type = Type.Ignore;
             }
             place = null;
         }
-	}
-	
-	public Part getPart() {
-		return part;
-	}
-
-	public void setPart(Part part) {
-		Part oldValue = this.part;
-		this.part = part;
-		firePropertyChange("part", oldValue, part);
-	}
-
-	public String getId() {
-		return id;
-	}
-
-	public Location getLocation() {
-		return location;
-	}
-
-	public void setLocation(Location location) {
-		Location oldValue = this.location;
-		this.location = location;
-		firePropertyChange("location", oldValue, location);
-	}
+    }
+
+    public Part getPart() {
+        return part;
+    }
+
+    public void setPart(Part part) {
+        Part oldValue = this.part;
+        this.part = part;
+        firePropertyChange("part", oldValue, part);
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public Location getLocation() {
+        return location;
+    }
+
+    public void setLocation(Location location) {
+        Location oldValue = this.location;
+        this.location = location;
+        firePropertyChange("location", oldValue, location);
+    }
 
     public Side getSide() {
         return side;
@@ -134,7 +129,7 @@ public void setSide(Side side) {
         this.side = side;
         firePropertyChange("side", oldValue, side);
     }
-    
+
     public Type getType() {
         return type;
     }
@@ -144,9 +139,10 @@ public void setType(Type type) {
         this.type = type;
         firePropertyChange("type", oldValue, type);
     }
-    
+
     @Override
-	public String toString() {
-		return String.format("id %s, location %s, side %s, part %s, type %s", id, location, side, part, type);
-	}
+    public String toString() {
+        return String.format("id %s, location %s, side %s, part %s, type %s", id, location, side,
+                part, type);
+    }
 }
diff --git a/src/main/java/org/openpnp/model/Point.java b/src/main/java/org/openpnp/model/Point.java
index 0d9180b394..fc4f44baf7 100755
--- a/src/main/java/org/openpnp/model/Point.java
+++ b/src/main/java/org/openpnp/model/Point.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.model;
 
@@ -26,44 +24,44 @@
 import org.simpleframework.xml.Attribute;
 
 public class Point {
-	@Attribute
-	public double x;
-	@Attribute
-	public double y;
-	
-	public Point() {
-		
-	}
-	
-	public Point(double x, double y) {
-		this.x = x;
-		this.y = y;
-	}
+    @Attribute
+    public double x;
+    @Attribute
+    public double y;
+
+    public Point() {
+
+    }
+
+    public Point(double x, double y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    public double getX() {
+        return x;
+    }
+
+    public void setX(double x) {
+        this.x = x;
+    }
 
-	public double getX() {
-		return x;
-	}
+    public double getY() {
+        return y;
+    }
 
-	public void setX(double x) {
-		this.x = x;
-	}
+    public void setY(double y) {
+        this.y = y;
+    }
 
-	public double getY() {
-		return y;
-	}
+    public Point subtract(Point p) {
+        return new Point(x - p.x, y - p.y);
+    }
 
-	public void setY(double y) {
-		this.y = y;
-	}
-	
-	public Point subtract(Point p) {
-		return new Point(x - p.x, y - p.y);
-	}
-	
-	@Override
-	public String toString() {
-		return String.format(Locale.US,"%f, %f", x, y);
-	}
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%f, %f", x, y);
+    }
 
     @Override
     public int hashCode() {
@@ -97,4 +95,4 @@ public boolean equals(Object obj) {
         }
         return true;
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/model/Rectangle.java b/src/main/java/org/openpnp/model/Rectangle.java
index bb0daa9772..862c2b2e38 100755
--- a/src/main/java/org/openpnp/model/Rectangle.java
+++ b/src/main/java/org/openpnp/model/Rectangle.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.model;
@@ -25,55 +23,55 @@
 
 
 public class Rectangle {
-	@Attribute
-	private int x;
-	@Attribute
-	private int y;
-	@Attribute
-	private int width;
-	@Attribute
-	private int height;
-	
-	public Rectangle() {
-		
-	}
-	
-	public Rectangle(int x, int y, int width, int height) {
-		this.x = x;
-		this.y = y;
-		this.width = width;
-		this.height = height;
-	}
+    @Attribute
+    private int x;
+    @Attribute
+    private int y;
+    @Attribute
+    private int width;
+    @Attribute
+    private int height;
+
+    public Rectangle() {
+
+    }
+
+    public Rectangle(int x, int y, int width, int height) {
+        this.x = x;
+        this.y = y;
+        this.width = width;
+        this.height = height;
+    }
 
-	public int getX() {
-		return x;
-	}
+    public int getX() {
+        return x;
+    }
 
-	public void setX(int x) {
-		this.x = x;
-	}
+    public void setX(int x) {
+        this.x = x;
+    }
 
-	public int getY() {
-		return y;
-	}
+    public int getY() {
+        return y;
+    }
 
-	public void setY(int y) {
-		this.y = y;
-	}
+    public void setY(int y) {
+        this.y = y;
+    }
 
-	public int getWidth() {
-		return width;
-	}
+    public int getWidth() {
+        return width;
+    }
 
-	public void setWidth(int width) {
-		this.width = width;
-	}
+    public void setWidth(int width) {
+        this.width = width;
+    }
 
-	public int getHeight() {
-		return height;
-	}
+    public int getHeight() {
+        return height;
+    }
 
-	public void setHeight(int height) {
-		this.height = height;
-	}
+    public void setHeight(int height) {
+        this.height = height;
+    }
 }
diff --git a/src/main/java/org/openpnp/model/eagle/EagleLoader.java b/src/main/java/org/openpnp/model/eagle/EagleLoader.java
index 8761962345..0fd94ea95f 100755
--- a/src/main/java/org/openpnp/model/eagle/EagleLoader.java
+++ b/src/main/java/org/openpnp/model/eagle/EagleLoader.java
@@ -26,15 +26,17 @@
 import org.xml.sax.helpers.XMLReaderFactory;
 
 public class EagleLoader {
-	
+
     private static final String FEATURE_NAMESPACES = "http://xml.org/sax/features/namespaces";
-    private static final String FEATURE_NAMESPACE_PREFIXES = "http://xml.org/sax/features/namespace-prefixes";
-    public Layers		layers;
-    public Eagle		eagle; // TODO remove eagle as this is not strictly required as we peel out the underlying parts, this is the superset
-    public Board 		board;
-    public Library 		library;
-    public Schematic 	schematic;
-    
+    private static final String FEATURE_NAMESPACE_PREFIXES =
+            "http://xml.org/sax/features/namespace-prefixes";
+    public Layers layers;
+    public Eagle eagle; // TODO remove eagle as this is not strictly required as we peel out the
+                        // underlying parts, this is the superset
+    public Board board;
+    public Library library;
+    public Schematic schematic;
+
     public EagleLoader(File file) throws Exception {
         this(new FileInputStream(file));
     }
@@ -52,7 +54,8 @@ public EagleLoader(InputStream in) throws Exception {
         xmlreader.setEntityResolver(new EntityResolver() {
             public InputSource resolveEntity(String publicId, String systemId)
                     throws SAXException, IOException {
-                InputSource input = new InputSource(ClassLoader.getSystemResourceAsStream("eagle.dtd"));
+                InputSource input =
+                        new InputSource(ClassLoader.getSystemResourceAsStream("eagle.dtd"));
                 input.setPublicId(publicId);
                 input.setSystemId(systemId);
                 return input;
@@ -62,58 +65,63 @@ public InputSource resolveEntity(String publicId, String systemId)
         InputSource input = new InputSource(in);
         Source source = new SAXSource(xmlreader, input);
 
-        eagle = (Eagle) unmarshaller.unmarshal(source); // TODO change later to    Eagle eagle = (Eagle) unmarshaller.unmarshal(source);
-        Drawing 	drawing 	= (Drawing) 	eagle.getCompatibilityOrDrawing().get(0);
-        
-      //Now see what we have
+        eagle = (Eagle) unmarshaller.unmarshal(source); // TODO change later to Eagle eagle =
+                                                        // (Eagle) unmarshaller.unmarshal(source);
+        Drawing drawing = (Drawing) eagle.getCompatibilityOrDrawing().get(0);
+
+        // Now see what we have
         try {
-        	layers 		= (Layers) 		drawing.getLayers();
-        	// Now we need to extract the details
-		}
-		catch (Exception e) {
-			//There were no Layers in the input file
-		}
-        
-        //Now see what we have
+            layers = (Layers) drawing.getLayers();
+            // Now we need to extract the details
+        }
+        catch (Exception e) {
+            // There were no Layers in the input file
+        }
+
+        // Now see what we have
+        try {
+            board = (Board) drawing.getLibraryOrSchematicOrBoard().get(0);
+            // Now we need to extract the details
+        }
+        catch (Exception e) {
+            // There were no Boards in the input file
+        }
+
         try {
-        	board 		= (Board) 		drawing.getLibraryOrSchematicOrBoard().get(0);
-        	// Now we need to extract the details
-		}
-		catch (Exception e) {
-			//There were no Boards in the input file
-		}
+            schematic = (Schematic) drawing.getLibraryOrSchematicOrBoard().get(0);
+        }
+        catch (Exception e) {
+            // There were no Schematics in the input file
+        }
 
         try {
-        	schematic 	= (Schematic) 	drawing.getLibraryOrSchematicOrBoard().get(0);
-		}
-		catch (Exception e) {
-			//There were no Schematics in the input file
-		}
-
-        try { 	
-        	library 	= (Library) 	drawing.getLibraryOrSchematicOrBoard().get(0);
-        
-        	Packages packages = library.getPackages();
-        
-        	System.out.println("<openpnp-packages>");
-        
-        	for (Package pkg : packages.getPackage()) {
-        		System.out.println(String.format("<package id=\"%s\" name=\"%s\">", pkg.getName(), pkg.getName()));
-        		System.out.println(String.format("<footprint units=\"Millimeters\">"));
-        		for (Object o : pkg.getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd()) {
-        			if (o instanceof Smd) {
-        				Smd smd = (Smd) o;
-        				System.out.println(String.format("<pad x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\"/>", smd.getX(), smd.getY(), smd.getDx(), smd.getDy()));
-        			}
-        		}
-        		System.out.println(String.format("</footprint>"));
-        		System.out.println("</package>");
-        	}
-        
-        	System.out.println("</openpnp-packages>");
-		}
-		catch (Exception e) {
-			//There were no Libraries in the input file
-		}	
+            library = (Library) drawing.getLibraryOrSchematicOrBoard().get(0);
+
+            Packages packages = library.getPackages();
+
+            System.out.println("<openpnp-packages>");
+
+            for (Package pkg : packages.getPackage()) {
+                System.out.println(String.format("<package id=\"%s\" name=\"%s\">", pkg.getName(),
+                        pkg.getName()));
+                System.out.println(String.format("<footprint units=\"Millimeters\">"));
+                for (Object o : pkg
+                        .getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd()) {
+                    if (o instanceof Smd) {
+                        Smd smd = (Smd) o;
+                        System.out.println(
+                                String.format("<pad x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\"/>",
+                                        smd.getX(), smd.getY(), smd.getDx(), smd.getDy()));
+                    }
+                }
+                System.out.println(String.format("</footprint>"));
+                System.out.println("</package>");
+            }
+
+            System.out.println("</openpnp-packages>");
+        }
+        catch (Exception e) {
+            // There were no Libraries in the input file
+        }
     }
 }
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Approved.java b/src/main/java/org/openpnp/model/eagle/xml/Approved.java
index 5db4f1ac25..50c0c95004 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Approved.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Approved.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -32,10 +33,8 @@
     /**
      * Gets the value of the hash property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getHash() {
         return hash;
@@ -44,10 +43,8 @@ public String getHash() {
     /**
      * Sets the value of the hash property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setHash(String value) {
         this.hash = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Attribute.java b/src/main/java/org/openpnp/model/eagle/xml/Attribute.java
index 3687adf13b..ed8bae9f57 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Attribute.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Attribute.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -63,10 +64,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -75,10 +74,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -87,10 +84,8 @@ public void setName(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         return value;
@@ -99,10 +94,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
@@ -111,10 +104,8 @@ public void setValue(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -123,10 +114,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -135,10 +124,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -147,10 +134,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -159,10 +144,8 @@ public void setY(String value) {
     /**
      * Gets the value of the size property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSize() {
         return size;
@@ -171,10 +154,8 @@ public String getSize() {
     /**
      * Sets the value of the size property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSize(String value) {
         this.size = value;
@@ -183,10 +164,8 @@ public void setSize(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -195,10 +174,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -207,10 +184,8 @@ public void setLayer(String value) {
     /**
      * Gets the value of the font property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFont() {
         return font;
@@ -219,10 +194,8 @@ public String getFont() {
     /**
      * Sets the value of the font property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFont(String value) {
         this.font = value;
@@ -231,10 +204,8 @@ public void setFont(String value) {
     /**
      * Gets the value of the ratio property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRatio() {
         return ratio;
@@ -243,10 +214,8 @@ public String getRatio() {
     /**
      * Sets the value of the ratio property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRatio(String value) {
         this.ratio = value;
@@ -255,15 +224,14 @@ public void setRatio(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -271,10 +239,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -283,15 +249,14 @@ public void setRot(String value) {
     /**
      * Gets the value of the display property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDisplay() {
         if (display == null) {
             return "value";
-        } else {
+        }
+        else {
             return display;
         }
     }
@@ -299,10 +264,8 @@ public String getDisplay() {
     /**
      * Sets the value of the display property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDisplay(String value) {
         this.display = value;
@@ -311,15 +274,14 @@ public void setDisplay(String value) {
     /**
      * Gets the value of the constant property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getConstant() {
         if (constant == null) {
             return "no";
-        } else {
+        }
+        else {
             return constant;
         }
     }
@@ -327,10 +289,8 @@ public String getConstant() {
     /**
      * Sets the value of the constant property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setConstant(String value) {
         this.constant = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Attributes.java b/src/main/java/org/openpnp/model/eagle/xml/Attributes.java
index 20ce83cccf..6f8246cb2b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Attributes.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Attributes.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute"
-})
+@XmlType(name = "", propOrder = {"attribute"})
 @XmlRootElement(name = "attributes")
 public class Attributes {
 
@@ -32,21 +32,20 @@
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Autorouter.java b/src/main/java/org/openpnp/model/eagle/xml/Autorouter.java
index 26944184e9..5210fd8aa2 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Autorouter.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Autorouter.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "pass"
-})
+@XmlType(name = "", propOrder = {"pass"})
 @XmlRootElement(name = "autorouter")
 public class Autorouter {
 
@@ -32,21 +32,20 @@
      * Gets the value of the pass property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the pass property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the pass property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPass().add(newItem);
+     * getPass().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Pass }
+     * Objects of the following type(s) are allowed in the list {@link Pass }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Board.java b/src/main/java/org/openpnp/model/eagle/xml/Board.java
index 87d8fa4145..db59f51499 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Board.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Board.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -18,19 +19,8 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "plain",
-    "libraries",
-    "attributes",
-    "variantdefs",
-    "classes",
-    "designrules",
-    "autorouter",
-    "elements",
-    "signals",
-    "errors"
-})
+@XmlType(name = "", propOrder = {"description", "plain", "libraries", "attributes", "variantdefs",
+        "classes", "designrules", "autorouter", "elements", "signals", "errors"})
 @XmlRootElement(name = "board")
 public class Board {
 
@@ -49,10 +39,8 @@
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -61,10 +49,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -73,10 +59,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the plain property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Plain }
-     *     
+     * @return possible object is {@link Plain }
+     * 
      */
     public Plain getPlain() {
         return plain;
@@ -85,10 +69,8 @@ public Plain getPlain() {
     /**
      * Sets the value of the plain property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Plain }
-     *     
+     * @param value allowed object is {@link Plain }
+     * 
      */
     public void setPlain(Plain value) {
         this.plain = value;
@@ -97,10 +79,8 @@ public void setPlain(Plain value) {
     /**
      * Gets the value of the libraries property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Libraries }
-     *     
+     * @return possible object is {@link Libraries }
+     * 
      */
     public Libraries getLibraries() {
         return libraries;
@@ -109,10 +89,8 @@ public Libraries getLibraries() {
     /**
      * Sets the value of the libraries property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Libraries }
-     *     
+     * @param value allowed object is {@link Libraries }
+     * 
      */
     public void setLibraries(Libraries value) {
         this.libraries = value;
@@ -121,10 +99,8 @@ public void setLibraries(Libraries value) {
     /**
      * Gets the value of the attributes property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Attributes }
-     *     
+     * @return possible object is {@link Attributes }
+     * 
      */
     public Attributes getAttributes() {
         return attributes;
@@ -133,10 +109,8 @@ public Attributes getAttributes() {
     /**
      * Sets the value of the attributes property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Attributes }
-     *     
+     * @param value allowed object is {@link Attributes }
+     * 
      */
     public void setAttributes(Attributes value) {
         this.attributes = value;
@@ -145,10 +119,8 @@ public void setAttributes(Attributes value) {
     /**
      * Gets the value of the variantdefs property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Variantdefs }
-     *     
+     * @return possible object is {@link Variantdefs }
+     * 
      */
     public Variantdefs getVariantdefs() {
         return variantdefs;
@@ -157,10 +129,8 @@ public Variantdefs getVariantdefs() {
     /**
      * Sets the value of the variantdefs property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Variantdefs }
-     *     
+     * @param value allowed object is {@link Variantdefs }
+     * 
      */
     public void setVariantdefs(Variantdefs value) {
         this.variantdefs = value;
@@ -169,10 +139,8 @@ public void setVariantdefs(Variantdefs value) {
     /**
      * Gets the value of the classes property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Classes }
-     *     
+     * @return possible object is {@link Classes }
+     * 
      */
     public Classes getClasses() {
         return classes;
@@ -181,10 +149,8 @@ public Classes getClasses() {
     /**
      * Sets the value of the classes property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Classes }
-     *     
+     * @param value allowed object is {@link Classes }
+     * 
      */
     public void setClasses(Classes value) {
         this.classes = value;
@@ -193,10 +159,8 @@ public void setClasses(Classes value) {
     /**
      * Gets the value of the designrules property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Designrules }
-     *     
+     * @return possible object is {@link Designrules }
+     * 
      */
     public Designrules getDesignrules() {
         return designrules;
@@ -205,10 +169,8 @@ public Designrules getDesignrules() {
     /**
      * Sets the value of the designrules property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Designrules }
-     *     
+     * @param value allowed object is {@link Designrules }
+     * 
      */
     public void setDesignrules(Designrules value) {
         this.designrules = value;
@@ -217,10 +179,8 @@ public void setDesignrules(Designrules value) {
     /**
      * Gets the value of the autorouter property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Autorouter }
-     *     
+     * @return possible object is {@link Autorouter }
+     * 
      */
     public Autorouter getAutorouter() {
         return autorouter;
@@ -229,10 +189,8 @@ public Autorouter getAutorouter() {
     /**
      * Sets the value of the autorouter property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Autorouter }
-     *     
+     * @param value allowed object is {@link Autorouter }
+     * 
      */
     public void setAutorouter(Autorouter value) {
         this.autorouter = value;
@@ -241,10 +199,8 @@ public void setAutorouter(Autorouter value) {
     /**
      * Gets the value of the elements property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Elements }
-     *     
+     * @return possible object is {@link Elements }
+     * 
      */
     public Elements getElements() {
         return elements;
@@ -253,10 +209,8 @@ public Elements getElements() {
     /**
      * Sets the value of the elements property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Elements }
-     *     
+     * @param value allowed object is {@link Elements }
+     * 
      */
     public void setElements(Elements value) {
         this.elements = value;
@@ -265,10 +219,8 @@ public void setElements(Elements value) {
     /**
      * Gets the value of the signals property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Signals }
-     *     
+     * @return possible object is {@link Signals }
+     * 
      */
     public Signals getSignals() {
         return signals;
@@ -277,10 +229,8 @@ public Signals getSignals() {
     /**
      * Sets the value of the signals property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Signals }
-     *     
+     * @param value allowed object is {@link Signals }
+     * 
      */
     public void setSignals(Signals value) {
         this.signals = value;
@@ -289,10 +239,8 @@ public void setSignals(Signals value) {
     /**
      * Gets the value of the errors property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Errors }
-     *     
+     * @return possible object is {@link Errors }
+     * 
      */
     public Errors getErrors() {
         return errors;
@@ -301,10 +249,8 @@ public Errors getErrors() {
     /**
      * Sets the value of the errors property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Errors }
-     *     
+     * @param value allowed object is {@link Errors }
+     * 
      */
     public void setErrors(Errors value) {
         this.errors = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Bus.java b/src/main/java/org/openpnp/model/eagle/xml/Bus.java
index 1253eea835..b62afb257a 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Bus.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Bus.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,9 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "segment"
-})
+@XmlType(name = "", propOrder = {"segment"})
 @XmlRootElement(name = "bus")
 public class Bus {
 
@@ -37,10 +37,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -49,10 +47,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -62,21 +58,20 @@ public void setName(String value) {
      * Gets the value of the segment property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the segment property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the segment property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSegment().add(newItem);
+     * getSegment().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Segment }
+     * Objects of the following type(s) are allowed in the list {@link Segment }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Busses.java b/src/main/java/org/openpnp/model/eagle/xml/Busses.java
index 44628e0e87..228475e4b8 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Busses.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Busses.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "bus"
-})
+@XmlType(name = "", propOrder = {"bus"})
 @XmlRootElement(name = "busses")
 public class Busses {
 
@@ -32,21 +32,20 @@
      * Gets the value of the bus property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the bus property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the bus property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getBus().add(newItem);
+     * getBus().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Bus }
+     * Objects of the following type(s) are allowed in the list {@link Bus }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Circle.java b/src/main/java/org/openpnp/model/eagle/xml/Circle.java
index 928d01f708..7432f0b770 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Circle.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Circle.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -44,10 +45,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -56,10 +55,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -68,10 +65,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -80,10 +75,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -92,10 +85,8 @@ public void setY(String value) {
     /**
      * Gets the value of the radius property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRadius() {
         return radius;
@@ -104,10 +95,8 @@ public String getRadius() {
     /**
      * Sets the value of the radius property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRadius(String value) {
         this.radius = value;
@@ -116,10 +105,8 @@ public void setRadius(String value) {
     /**
      * Gets the value of the width property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getWidth() {
         return width;
@@ -128,10 +115,8 @@ public String getWidth() {
     /**
      * Sets the value of the width property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setWidth(String value) {
         this.width = value;
@@ -140,10 +125,8 @@ public void setWidth(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -152,10 +135,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Class.java b/src/main/java/org/openpnp/model/eagle/xml/Class.java
index 62c26ac90d..1ff0f0abbd 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Class.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Class.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,9 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "clearance"
-})
+@XmlType(name = "", propOrder = {"clearance"})
 @XmlRootElement(name = "class")
 public class Class {
 
@@ -46,10 +46,8 @@
     /**
      * Gets the value of the number property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getNumber() {
         return number;
@@ -58,10 +56,8 @@ public String getNumber() {
     /**
      * Sets the value of the number property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setNumber(String value) {
         this.number = value;
@@ -70,10 +66,8 @@ public void setNumber(String value) {
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -82,10 +76,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -94,15 +86,14 @@ public void setName(String value) {
     /**
      * Gets the value of the width property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getWidth() {
         if (width == null) {
             return "0";
-        } else {
+        }
+        else {
             return width;
         }
     }
@@ -110,10 +101,8 @@ public String getWidth() {
     /**
      * Sets the value of the width property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setWidth(String value) {
         this.width = value;
@@ -122,15 +111,14 @@ public void setWidth(String value) {
     /**
      * Gets the value of the drill property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDrill() {
         if (drill == null) {
             return "0";
-        } else {
+        }
+        else {
             return drill;
         }
     }
@@ -138,10 +126,8 @@ public String getDrill() {
     /**
      * Sets the value of the drill property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDrill(String value) {
         this.drill = value;
@@ -151,21 +137,20 @@ public void setDrill(String value) {
      * Gets the value of the clearance property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the clearance property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the clearance property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getClearance().add(newItem);
+     * getClearance().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Clearance }
+     * Objects of the following type(s) are allowed in the list {@link Clearance }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Classes.java b/src/main/java/org/openpnp/model/eagle/xml/Classes.java
index 902f632abd..f653c180e6 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Classes.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Classes.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
@@ -21,9 +23,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "clazz"
-})
+@XmlType(name = "", propOrder = {"clazz"})
 @XmlRootElement(name = "classes")
 public class Classes {
 
@@ -34,21 +34,20 @@
      * Gets the value of the clazz property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the clazz property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the clazz property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getClazz().add(newItem);
+     * getClazz().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Class }
+     * Objects of the following type(s) are allowed in the list {@link Class }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Clearance.java b/src/main/java/org/openpnp/model/eagle/xml/Clearance.java
index f61f2df99a..cee7285f8d 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Clearance.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Clearance.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -35,10 +36,8 @@
     /**
      * Gets the value of the clazz property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getClazz() {
         return clazz;
@@ -47,10 +46,8 @@ public String getClazz() {
     /**
      * Sets the value of the clazz property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setClazz(String value) {
         this.clazz = value;
@@ -59,15 +56,14 @@ public void setClazz(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         if (value == null) {
             return "0";
-        } else {
+        }
+        else {
             return value;
         }
     }
@@ -75,10 +71,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Compatibility.java b/src/main/java/org/openpnp/model/eagle/xml/Compatibility.java
index c17c7a2e9a..11547acbac 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Compatibility.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Compatibility.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "note"
-})
+@XmlType(name = "", propOrder = {"note"})
 @XmlRootElement(name = "compatibility")
 public class Compatibility {
 
@@ -32,21 +32,20 @@
      * Gets the value of the note property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the note property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the note property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getNote().add(newItem);
+     * getNote().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Note }
+     * Objects of the following type(s) are allowed in the list {@link Note }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Connect.java b/src/main/java/org/openpnp/model/eagle/xml/Connect.java
index fe83e5aba8..e18d42582e 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Connect.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Connect.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -42,10 +43,8 @@
     /**
      * Gets the value of the gate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getGate() {
         return gate;
@@ -54,10 +53,8 @@ public String getGate() {
     /**
      * Sets the value of the gate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setGate(String value) {
         this.gate = value;
@@ -66,10 +63,8 @@ public void setGate(String value) {
     /**
      * Gets the value of the pin property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPin() {
         return pin;
@@ -78,10 +73,8 @@ public String getPin() {
     /**
      * Sets the value of the pin property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPin(String value) {
         this.pin = value;
@@ -90,10 +83,8 @@ public void setPin(String value) {
     /**
      * Gets the value of the pad property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPad() {
         return pad;
@@ -102,10 +93,8 @@ public String getPad() {
     /**
      * Sets the value of the pad property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPad(String value) {
         this.pad = value;
@@ -114,15 +103,14 @@ public void setPad(String value) {
     /**
      * Gets the value of the route property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRoute() {
         if (route == null) {
             return "all";
-        } else {
+        }
+        else {
             return route;
         }
     }
@@ -130,10 +118,8 @@ public String getRoute() {
     /**
      * Sets the value of the route property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRoute(String value) {
         this.route = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Connects.java b/src/main/java/org/openpnp/model/eagle/xml/Connects.java
index 11ea05a0eb..35268785e1 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Connects.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Connects.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "connect"
-})
+@XmlType(name = "", propOrder = {"connect"})
 @XmlRootElement(name = "connects")
 public class Connects {
 
@@ -32,21 +32,20 @@
      * Gets the value of the connect property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the connect property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the connect property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getConnect().add(newItem);
+     * getConnect().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Connect }
+     * Objects of the following type(s) are allowed in the list {@link Connect }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Contactref.java b/src/main/java/org/openpnp/model/eagle/xml/Contactref.java
index 08dca6b1dd..1eef879b90 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Contactref.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Contactref.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -42,10 +43,8 @@
     /**
      * Gets the value of the element property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getElement() {
         return element;
@@ -54,10 +53,8 @@ public String getElement() {
     /**
      * Sets the value of the element property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setElement(String value) {
         this.element = value;
@@ -66,10 +63,8 @@ public void setElement(String value) {
     /**
      * Gets the value of the pad property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPad() {
         return pad;
@@ -78,10 +73,8 @@ public String getPad() {
     /**
      * Sets the value of the pad property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPad(String value) {
         this.pad = value;
@@ -90,15 +83,14 @@ public void setPad(String value) {
     /**
      * Gets the value of the route property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRoute() {
         if (route == null) {
             return "all";
-        } else {
+        }
+        else {
             return route;
         }
     }
@@ -106,10 +98,8 @@ public String getRoute() {
     /**
      * Sets the value of the route property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRoute(String value) {
         this.route = value;
@@ -118,15 +108,14 @@ public void setRoute(String value) {
     /**
      * Gets the value of the routetag property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRoutetag() {
         if (routetag == null) {
             return "";
-        } else {
+        }
+        else {
             return routetag;
         }
     }
@@ -134,10 +123,8 @@ public String getRoutetag() {
     /**
      * Sets the value of the routetag property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRoutetag(String value) {
         this.routetag = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Description.java b/src/main/java/org/openpnp/model/eagle/xml/Description.java
index ae16bef11e..e3ea2f95b8 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Description.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Description.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -22,9 +23,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "value"
-})
+@XmlType(name = "", propOrder = {"value"})
 @XmlRootElement(name = "description")
 public class Description {
 
@@ -37,15 +36,14 @@
     /**
      * Gets the value of the language property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLanguage() {
         if (language == null) {
             return "en";
-        } else {
+        }
+        else {
             return language;
         }
     }
@@ -53,10 +51,8 @@ public String getLanguage() {
     /**
      * Sets the value of the language property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLanguage(String value) {
         this.language = value;
@@ -65,10 +61,8 @@ public void setLanguage(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getvalue() {
         return value;
@@ -77,10 +71,8 @@ public String getvalue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setvalue(String value) {
         this.value = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Designrules.java b/src/main/java/org/openpnp/model/eagle/xml/Designrules.java
index 4fecfc7800..22a24a2c27 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Designrules.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Designrules.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,10 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "param"
-})
+@XmlType(name = "", propOrder = {"description", "param"})
 @XmlRootElement(name = "designrules")
 public class Designrules {
 
@@ -39,10 +38,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -51,10 +48,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -64,21 +59,20 @@ public void setName(String value) {
      * Gets the value of the description property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the description property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the description property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getDescription().add(newItem);
+     * getDescription().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Description }
+     * Objects of the following type(s) are allowed in the list {@link Description }
      * 
      * 
      */
@@ -93,21 +87,20 @@ public void setName(String value) {
      * Gets the value of the param property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the param property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the param property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getParam().add(newItem);
+     * getParam().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Param }
+     * Objects of the following type(s) are allowed in the list {@link Param }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Device.java b/src/main/java/org/openpnp/model/eagle/xml/Device.java
index 9c5a598fd0..917b416335 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Device.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Device.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -21,10 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "connects",
-    "technologies"
-})
+@XmlType(name = "", propOrder = {"connects", "technologies"})
 @XmlRootElement(name = "device")
 public class Device {
 
@@ -40,15 +38,14 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         if (name == null) {
             return "";
-        } else {
+        }
+        else {
             return name;
         }
     }
@@ -56,10 +53,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -68,10 +63,8 @@ public void setName(String value) {
     /**
      * Gets the value of the package property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPackage() {
         return _package;
@@ -80,10 +73,8 @@ public String getPackage() {
     /**
      * Sets the value of the package property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPackage(String value) {
         this._package = value;
@@ -92,10 +83,8 @@ public void setPackage(String value) {
     /**
      * Gets the value of the connects property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Connects }
-     *     
+     * @return possible object is {@link Connects }
+     * 
      */
     public Connects getConnects() {
         return connects;
@@ -104,10 +93,8 @@ public Connects getConnects() {
     /**
      * Sets the value of the connects property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Connects }
-     *     
+     * @param value allowed object is {@link Connects }
+     * 
      */
     public void setConnects(Connects value) {
         this.connects = value;
@@ -116,10 +103,8 @@ public void setConnects(Connects value) {
     /**
      * Gets the value of the technologies property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Technologies }
-     *     
+     * @return possible object is {@link Technologies }
+     * 
      */
     public Technologies getTechnologies() {
         return technologies;
@@ -128,10 +113,8 @@ public Technologies getTechnologies() {
     /**
      * Sets the value of the technologies property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Technologies }
-     *     
+     * @param value allowed object is {@link Technologies }
+     * 
      */
     public void setTechnologies(Technologies value) {
         this.technologies = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Devices.java b/src/main/java/org/openpnp/model/eagle/xml/Devices.java
index b0ac2e76cb..35a146fdc2 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Devices.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Devices.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "device"
-})
+@XmlType(name = "", propOrder = {"device"})
 @XmlRootElement(name = "devices")
 public class Devices {
 
@@ -32,21 +32,20 @@
      * Gets the value of the device property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the device property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the device property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getDevice().add(newItem);
+     * getDevice().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Device }
+     * Objects of the following type(s) are allowed in the list {@link Device }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Deviceset.java b/src/main/java/org/openpnp/model/eagle/xml/Deviceset.java
index fb5e3ddd9d..52cde5dc7a 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Deviceset.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Deviceset.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -23,11 +24,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "gates",
-    "devices"
-})
+@XmlType(name = "", propOrder = {"description", "gates", "devices"})
 @XmlRootElement(name = "deviceset")
 public class Deviceset {
 
@@ -49,10 +46,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -61,10 +56,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -73,15 +66,14 @@ public void setName(String value) {
     /**
      * Gets the value of the prefix property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPrefix() {
         if (prefix == null) {
             return "";
-        } else {
+        }
+        else {
             return prefix;
         }
     }
@@ -89,10 +81,8 @@ public String getPrefix() {
     /**
      * Sets the value of the prefix property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPrefix(String value) {
         this.prefix = value;
@@ -101,15 +91,14 @@ public void setPrefix(String value) {
     /**
      * Gets the value of the uservalue property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getUservalue() {
         if (uservalue == null) {
             return "no";
-        } else {
+        }
+        else {
             return uservalue;
         }
     }
@@ -117,10 +106,8 @@ public String getUservalue() {
     /**
      * Sets the value of the uservalue property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setUservalue(String value) {
         this.uservalue = value;
@@ -129,10 +116,8 @@ public void setUservalue(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -141,10 +126,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -153,10 +136,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the gates property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Gates }
-     *     
+     * @return possible object is {@link Gates }
+     * 
      */
     public Gates getGates() {
         return gates;
@@ -165,10 +146,8 @@ public Gates getGates() {
     /**
      * Sets the value of the gates property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Gates }
-     *     
+     * @param value allowed object is {@link Gates }
+     * 
      */
     public void setGates(Gates value) {
         this.gates = value;
@@ -177,10 +156,8 @@ public void setGates(Gates value) {
     /**
      * Gets the value of the devices property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Devices }
-     *     
+     * @return possible object is {@link Devices }
+     * 
      */
     public Devices getDevices() {
         return devices;
@@ -189,10 +166,8 @@ public Devices getDevices() {
     /**
      * Sets the value of the devices property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Devices }
-     *     
+     * @param value allowed object is {@link Devices }
+     * 
      */
     public void setDevices(Devices value) {
         this.devices = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Devicesets.java b/src/main/java/org/openpnp/model/eagle/xml/Devicesets.java
index 3f26dd6654..0cc3d87b60 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Devicesets.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Devicesets.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "deviceset"
-})
+@XmlType(name = "", propOrder = {"deviceset"})
 @XmlRootElement(name = "devicesets")
 public class Devicesets {
 
@@ -32,21 +32,20 @@
      * Gets the value of the deviceset property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the deviceset property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the deviceset property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getDeviceset().add(newItem);
+     * getDeviceset().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Deviceset }
+     * Objects of the following type(s) are allowed in the list {@link Deviceset }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Dimension.java b/src/main/java/org/openpnp/model/eagle/xml/Dimension.java
index f69b87cb72..238c4ed685 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Dimension.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Dimension.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -81,10 +82,8 @@
     /**
      * Gets the value of the x1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX1() {
         return x1;
@@ -93,10 +92,8 @@ public String getX1() {
     /**
      * Sets the value of the x1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX1(String value) {
         this.x1 = value;
@@ -105,10 +102,8 @@ public void setX1(String value) {
     /**
      * Gets the value of the y1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY1() {
         return y1;
@@ -117,10 +112,8 @@ public String getY1() {
     /**
      * Sets the value of the y1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY1(String value) {
         this.y1 = value;
@@ -129,10 +122,8 @@ public void setY1(String value) {
     /**
      * Gets the value of the x2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX2() {
         return x2;
@@ -141,10 +132,8 @@ public String getX2() {
     /**
      * Sets the value of the x2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX2(String value) {
         this.x2 = value;
@@ -153,10 +142,8 @@ public void setX2(String value) {
     /**
      * Gets the value of the y2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY2() {
         return y2;
@@ -165,10 +152,8 @@ public String getY2() {
     /**
      * Sets the value of the y2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY2(String value) {
         this.y2 = value;
@@ -177,10 +162,8 @@ public void setY2(String value) {
     /**
      * Gets the value of the x3 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX3() {
         return x3;
@@ -189,10 +172,8 @@ public String getX3() {
     /**
      * Sets the value of the x3 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX3(String value) {
         this.x3 = value;
@@ -201,10 +182,8 @@ public void setX3(String value) {
     /**
      * Gets the value of the y3 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY3() {
         return y3;
@@ -213,10 +192,8 @@ public String getY3() {
     /**
      * Sets the value of the y3 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY3(String value) {
         this.y3 = value;
@@ -225,10 +202,8 @@ public void setY3(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -237,10 +212,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -249,15 +222,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the dtype property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDtype() {
         if (dtype == null) {
             return "parallel";
-        } else {
+        }
+        else {
             return dtype;
         }
     }
@@ -265,10 +237,8 @@ public String getDtype() {
     /**
      * Sets the value of the dtype property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDtype(String value) {
         this.dtype = value;
@@ -277,10 +247,8 @@ public void setDtype(String value) {
     /**
      * Gets the value of the width property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getWidth() {
         return width;
@@ -289,10 +257,8 @@ public String getWidth() {
     /**
      * Sets the value of the width property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setWidth(String value) {
         this.width = value;
@@ -301,15 +267,14 @@ public void setWidth(String value) {
     /**
      * Gets the value of the extwidth property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getExtwidth() {
         if (extwidth == null) {
             return "0";
-        } else {
+        }
+        else {
             return extwidth;
         }
     }
@@ -317,10 +282,8 @@ public String getExtwidth() {
     /**
      * Sets the value of the extwidth property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setExtwidth(String value) {
         this.extwidth = value;
@@ -329,15 +292,14 @@ public void setExtwidth(String value) {
     /**
      * Gets the value of the extlength property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getExtlength() {
         if (extlength == null) {
             return "0";
-        } else {
+        }
+        else {
             return extlength;
         }
     }
@@ -345,10 +307,8 @@ public String getExtlength() {
     /**
      * Sets the value of the extlength property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setExtlength(String value) {
         this.extlength = value;
@@ -357,15 +317,14 @@ public void setExtlength(String value) {
     /**
      * Gets the value of the extoffset property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getExtoffset() {
         if (extoffset == null) {
             return "0";
-        } else {
+        }
+        else {
             return extoffset;
         }
     }
@@ -373,10 +332,8 @@ public String getExtoffset() {
     /**
      * Sets the value of the extoffset property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setExtoffset(String value) {
         this.extoffset = value;
@@ -385,10 +342,8 @@ public void setExtoffset(String value) {
     /**
      * Gets the value of the textsize property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getTextsize() {
         return textsize;
@@ -397,10 +352,8 @@ public String getTextsize() {
     /**
      * Sets the value of the textsize property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setTextsize(String value) {
         this.textsize = value;
@@ -409,15 +362,14 @@ public void setTextsize(String value) {
     /**
      * Gets the value of the textratio property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getTextratio() {
         if (textratio == null) {
             return "8";
-        } else {
+        }
+        else {
             return textratio;
         }
     }
@@ -425,10 +377,8 @@ public String getTextratio() {
     /**
      * Sets the value of the textratio property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setTextratio(String value) {
         this.textratio = value;
@@ -437,15 +387,14 @@ public void setTextratio(String value) {
     /**
      * Gets the value of the unit property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getUnit() {
         if (unit == null) {
             return "mm";
-        } else {
+        }
+        else {
             return unit;
         }
     }
@@ -453,10 +402,8 @@ public String getUnit() {
     /**
      * Sets the value of the unit property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setUnit(String value) {
         this.unit = value;
@@ -465,15 +412,14 @@ public void setUnit(String value) {
     /**
      * Gets the value of the precision property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPrecision() {
         if (precision == null) {
             return "2";
-        } else {
+        }
+        else {
             return precision;
         }
     }
@@ -481,10 +427,8 @@ public String getPrecision() {
     /**
      * Sets the value of the precision property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPrecision(String value) {
         this.precision = value;
@@ -493,15 +437,14 @@ public void setPrecision(String value) {
     /**
      * Gets the value of the visible property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVisible() {
         if (visible == null) {
             return "no";
-        } else {
+        }
+        else {
             return visible;
         }
     }
@@ -509,10 +452,8 @@ public String getVisible() {
     /**
      * Sets the value of the visible property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVisible(String value) {
         this.visible = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Drawing.java b/src/main/java/org/openpnp/model/eagle/xml/Drawing.java
index 342e5bb306..d93b7f3594 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Drawing.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Drawing.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
@@ -22,12 +24,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "settings",
-    "grid",
-    "layers",
-    "libraryOrSchematicOrBoard"
-})
+@XmlType(name = "", propOrder = {"settings", "grid", "layers", "libraryOrSchematicOrBoard"})
 @XmlRootElement(name = "drawing")
 public class Drawing {
 
@@ -35,20 +32,16 @@
     protected Grid grid;
     @XmlElement(required = true)
     protected Layers layers;
-    @XmlElements({
-        @XmlElement(name = "library", required = true, type = Library.class),
-        @XmlElement(name = "schematic", required = true, type = Schematic.class),
-        @XmlElement(name = "board", required = true, type = Board.class)
-    })
+    @XmlElements({@XmlElement(name = "library", required = true, type = Library.class),
+            @XmlElement(name = "schematic", required = true, type = Schematic.class),
+            @XmlElement(name = "board", required = true, type = Board.class)})
     protected List<Object> libraryOrSchematicOrBoard;
 
     /**
      * Gets the value of the settings property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Settings }
-     *     
+     * @return possible object is {@link Settings }
+     * 
      */
     public Settings getSettings() {
         return settings;
@@ -57,10 +50,8 @@ public Settings getSettings() {
     /**
      * Sets the value of the settings property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Settings }
-     *     
+     * @param value allowed object is {@link Settings }
+     * 
      */
     public void setSettings(Settings value) {
         this.settings = value;
@@ -69,10 +60,8 @@ public void setSettings(Settings value) {
     /**
      * Gets the value of the grid property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Grid }
-     *     
+     * @return possible object is {@link Grid }
+     * 
      */
     public Grid getGrid() {
         return grid;
@@ -81,10 +70,8 @@ public Grid getGrid() {
     /**
      * Sets the value of the grid property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Grid }
-     *     
+     * @param value allowed object is {@link Grid }
+     * 
      */
     public void setGrid(Grid value) {
         this.grid = value;
@@ -93,10 +80,8 @@ public void setGrid(Grid value) {
     /**
      * Gets the value of the layers property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Layers }
-     *     
+     * @return possible object is {@link Layers }
+     * 
      */
     public Layers getLayers() {
         return layers;
@@ -105,10 +90,8 @@ public Layers getLayers() {
     /**
      * Sets the value of the layers property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Layers }
-     *     
+     * @param value allowed object is {@link Layers }
+     * 
      */
     public void setLayers(Layers value) {
         this.layers = value;
@@ -118,22 +101,20 @@ public void setLayers(Layers value) {
      * Gets the value of the libraryOrSchematicOrBoard property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the libraryOrSchematicOrBoard property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the libraryOrSchematicOrBoard property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getLibraryOrSchematicOrBoard().add(newItem);
+     * getLibraryOrSchematicOrBoard().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Library }
-     * {@link Schematic }
+     * Objects of the following type(s) are allowed in the list {@link Library } {@link Schematic }
      * {@link Board }
      * 
      * 
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Eagle.java b/src/main/java/org/openpnp/model/eagle/xml/Eagle.java
index 755f6283b6..528e2a0175 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Eagle.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Eagle.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -25,28 +27,22 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "compatibilityOrDrawing"
-})
+@XmlType(name = "", propOrder = {"compatibilityOrDrawing"})
 @XmlRootElement(name = "eagle")
 public class Eagle {
 
     @XmlAttribute(name = "version", required = true)
     @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
     protected String version;
-    @XmlElements({
-        @XmlElement(name = "compatibility", type = Compatibility.class),
-        @XmlElement(name = "drawing", type = Drawing.class)
-    })
+    @XmlElements({@XmlElement(name = "compatibility", type = Compatibility.class),
+            @XmlElement(name = "drawing", type = Drawing.class)})
     protected List<Object> compatibilityOrDrawing;
 
     /**
      * Gets the value of the version property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVersion() {
         return version;
@@ -55,10 +51,8 @@ public String getVersion() {
     /**
      * Sets the value of the version property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVersion(String value) {
         this.version = value;
@@ -68,21 +62,20 @@ public void setVersion(String value) {
      * Gets the value of the compatibilityOrDrawing property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the compatibilityOrDrawing property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the compatibilityOrDrawing property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getCompatibilityOrDrawing().add(newItem);
+     * getCompatibilityOrDrawing().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Compatibility }
+     * Objects of the following type(s) are allowed in the list {@link Compatibility }
      * {@link Drawing }
      * 
      * 
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Element.java b/src/main/java/org/openpnp/model/eagle/xml/Element.java
index 0b7f8928d8..887b3fba66 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Element.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Element.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -24,10 +26,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute",
-    "variant"
-})
+@XmlType(name = "", propOrder = {"attribute", "variant"})
 @XmlRootElement(name = "element")
 public class Element {
 
@@ -67,10 +66,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -79,10 +76,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -91,10 +86,8 @@ public void setName(String value) {
     /**
      * Gets the value of the library property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLibrary() {
         return library;
@@ -103,10 +96,8 @@ public String getLibrary() {
     /**
      * Sets the value of the library property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLibrary(String value) {
         this.library = value;
@@ -115,10 +106,8 @@ public void setLibrary(String value) {
     /**
      * Gets the value of the package property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPackage() {
         return _package;
@@ -127,10 +116,8 @@ public String getPackage() {
     /**
      * Sets the value of the package property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPackage(String value) {
         this._package = value;
@@ -139,10 +126,8 @@ public void setPackage(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         return value;
@@ -151,10 +136,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
@@ -163,10 +146,8 @@ public void setValue(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -175,10 +156,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -187,10 +166,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -199,10 +176,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -211,15 +186,14 @@ public void setY(String value) {
     /**
      * Gets the value of the locked property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLocked() {
         if (locked == null) {
             return "no";
-        } else {
+        }
+        else {
             return locked;
         }
     }
@@ -227,10 +201,8 @@ public String getLocked() {
     /**
      * Sets the value of the locked property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLocked(String value) {
         this.locked = value;
@@ -239,15 +211,14 @@ public void setLocked(String value) {
     /**
      * Gets the value of the populate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPopulate() {
         if (populate == null) {
             return "yes";
-        } else {
+        }
+        else {
             return populate;
         }
     }
@@ -255,10 +226,8 @@ public String getPopulate() {
     /**
      * Sets the value of the populate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPopulate(String value) {
         this.populate = value;
@@ -267,15 +236,14 @@ public void setPopulate(String value) {
     /**
      * Gets the value of the smashed property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSmashed() {
         if (smashed == null) {
             return "no";
-        } else {
+        }
+        else {
             return smashed;
         }
     }
@@ -283,10 +251,8 @@ public String getSmashed() {
     /**
      * Sets the value of the smashed property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSmashed(String value) {
         this.smashed = value;
@@ -295,15 +261,14 @@ public void setSmashed(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -311,10 +276,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -324,21 +287,20 @@ public void setRot(String value) {
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
@@ -353,21 +315,20 @@ public void setRot(String value) {
      * Gets the value of the variant property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the variant property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the variant property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getVariant().add(newItem);
+     * getVariant().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Variant }
+     * Objects of the following type(s) are allowed in the list {@link Variant }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Elements.java b/src/main/java/org/openpnp/model/eagle/xml/Elements.java
index 37c28b2286..2827072531 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Elements.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Elements.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "element"
-})
+@XmlType(name = "", propOrder = {"element"})
 @XmlRootElement(name = "elements")
 public class Elements {
 
@@ -32,21 +32,20 @@
      * Gets the value of the element property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the element property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the element property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getElement().add(newItem);
+     * getElement().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Element }
+     * Objects of the following type(s) are allowed in the list {@link Element }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Errors.java b/src/main/java/org/openpnp/model/eagle/xml/Errors.java
index 54ebc4e116..56ac8f1749 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Errors.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Errors.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "approved"
-})
+@XmlType(name = "", propOrder = {"approved"})
 @XmlRootElement(name = "errors")
 public class Errors {
 
@@ -32,21 +32,20 @@
      * Gets the value of the approved property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the approved property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the approved property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getApproved().add(newItem);
+     * getApproved().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Approved }
+     * Objects of the following type(s) are allowed in the list {@link Approved }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Frame.java b/src/main/java/org/openpnp/model/eagle/xml/Frame.java
index e395fcd538..5671a9ed93 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Frame.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Frame.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -63,10 +64,8 @@
     /**
      * Gets the value of the x1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX1() {
         return x1;
@@ -75,10 +74,8 @@ public String getX1() {
     /**
      * Sets the value of the x1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX1(String value) {
         this.x1 = value;
@@ -87,10 +84,8 @@ public void setX1(String value) {
     /**
      * Gets the value of the y1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY1() {
         return y1;
@@ -99,10 +94,8 @@ public String getY1() {
     /**
      * Sets the value of the y1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY1(String value) {
         this.y1 = value;
@@ -111,10 +104,8 @@ public void setY1(String value) {
     /**
      * Gets the value of the x2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX2() {
         return x2;
@@ -123,10 +114,8 @@ public String getX2() {
     /**
      * Sets the value of the x2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX2(String value) {
         this.x2 = value;
@@ -135,10 +124,8 @@ public void setX2(String value) {
     /**
      * Gets the value of the y2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY2() {
         return y2;
@@ -147,10 +134,8 @@ public String getY2() {
     /**
      * Sets the value of the y2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY2(String value) {
         this.y2 = value;
@@ -159,10 +144,8 @@ public void setY2(String value) {
     /**
      * Gets the value of the columns property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getColumns() {
         return columns;
@@ -171,10 +154,8 @@ public String getColumns() {
     /**
      * Sets the value of the columns property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setColumns(String value) {
         this.columns = value;
@@ -183,10 +164,8 @@ public void setColumns(String value) {
     /**
      * Gets the value of the rows property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRows() {
         return rows;
@@ -195,10 +174,8 @@ public String getRows() {
     /**
      * Sets the value of the rows property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRows(String value) {
         this.rows = value;
@@ -207,10 +184,8 @@ public void setRows(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -219,10 +194,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -231,15 +204,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the borderLeft property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getBorderLeft() {
         if (borderLeft == null) {
             return "yes";
-        } else {
+        }
+        else {
             return borderLeft;
         }
     }
@@ -247,10 +219,8 @@ public String getBorderLeft() {
     /**
      * Sets the value of the borderLeft property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setBorderLeft(String value) {
         this.borderLeft = value;
@@ -259,15 +229,14 @@ public void setBorderLeft(String value) {
     /**
      * Gets the value of the borderTop property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getBorderTop() {
         if (borderTop == null) {
             return "yes";
-        } else {
+        }
+        else {
             return borderTop;
         }
     }
@@ -275,10 +244,8 @@ public String getBorderTop() {
     /**
      * Sets the value of the borderTop property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setBorderTop(String value) {
         this.borderTop = value;
@@ -287,15 +254,14 @@ public void setBorderTop(String value) {
     /**
      * Gets the value of the borderRight property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getBorderRight() {
         if (borderRight == null) {
             return "yes";
-        } else {
+        }
+        else {
             return borderRight;
         }
     }
@@ -303,10 +269,8 @@ public String getBorderRight() {
     /**
      * Sets the value of the borderRight property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setBorderRight(String value) {
         this.borderRight = value;
@@ -315,15 +279,14 @@ public void setBorderRight(String value) {
     /**
      * Gets the value of the borderBottom property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getBorderBottom() {
         if (borderBottom == null) {
             return "yes";
-        } else {
+        }
+        else {
             return borderBottom;
         }
     }
@@ -331,10 +294,8 @@ public String getBorderBottom() {
     /**
      * Sets the value of the borderBottom property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setBorderBottom(String value) {
         this.borderBottom = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Gate.java b/src/main/java/org/openpnp/model/eagle/xml/Gate.java
index 048e35b69d..818a3bfa6e 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Gate.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Gate.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -48,10 +49,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -60,10 +59,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -72,10 +69,8 @@ public void setName(String value) {
     /**
      * Gets the value of the symbol property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSymbol() {
         return symbol;
@@ -84,10 +79,8 @@ public String getSymbol() {
     /**
      * Sets the value of the symbol property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSymbol(String value) {
         this.symbol = value;
@@ -96,10 +89,8 @@ public void setSymbol(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -108,10 +99,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -120,10 +109,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -132,10 +119,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -144,15 +129,14 @@ public void setY(String value) {
     /**
      * Gets the value of the addlevel property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAddlevel() {
         if (addlevel == null) {
             return "next";
-        } else {
+        }
+        else {
             return addlevel;
         }
     }
@@ -160,10 +144,8 @@ public String getAddlevel() {
     /**
      * Sets the value of the addlevel property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAddlevel(String value) {
         this.addlevel = value;
@@ -172,15 +154,14 @@ public void setAddlevel(String value) {
     /**
      * Gets the value of the swaplevel property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSwaplevel() {
         if (swaplevel == null) {
             return "0";
-        } else {
+        }
+        else {
             return swaplevel;
         }
     }
@@ -188,10 +169,8 @@ public String getSwaplevel() {
     /**
      * Sets the value of the swaplevel property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSwaplevel(String value) {
         this.swaplevel = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Gates.java b/src/main/java/org/openpnp/model/eagle/xml/Gates.java
index 00bacbc8cd..22ca9bf463 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Gates.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Gates.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "gate"
-})
+@XmlType(name = "", propOrder = {"gate"})
 @XmlRootElement(name = "gates")
 public class Gates {
 
@@ -32,21 +32,20 @@
      * Gets the value of the gate property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the gate property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the gate property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getGate().add(newItem);
+     * getGate().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Gate }
+     * Objects of the following type(s) are allowed in the list {@link Gate }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Grid.java b/src/main/java/org/openpnp/model/eagle/xml/Grid.java
index 54d9e11702..ac5484bb83 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Grid.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Grid.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -57,10 +58,8 @@
     /**
      * Gets the value of the distance property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDistance() {
         return distance;
@@ -69,10 +68,8 @@ public String getDistance() {
     /**
      * Sets the value of the distance property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDistance(String value) {
         this.distance = value;
@@ -81,10 +78,8 @@ public void setDistance(String value) {
     /**
      * Gets the value of the unitdist property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getUnitdist() {
         return unitdist;
@@ -93,10 +88,8 @@ public String getUnitdist() {
     /**
      * Sets the value of the unitdist property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setUnitdist(String value) {
         this.unitdist = value;
@@ -105,10 +98,8 @@ public void setUnitdist(String value) {
     /**
      * Gets the value of the unit property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getUnit() {
         return unit;
@@ -117,10 +108,8 @@ public String getUnit() {
     /**
      * Sets the value of the unit property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setUnit(String value) {
         this.unit = value;
@@ -129,15 +118,14 @@ public void setUnit(String value) {
     /**
      * Gets the value of the style property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getStyle() {
         if (style == null) {
             return "lines";
-        } else {
+        }
+        else {
             return style;
         }
     }
@@ -145,10 +133,8 @@ public String getStyle() {
     /**
      * Sets the value of the style property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setStyle(String value) {
         this.style = value;
@@ -157,15 +143,14 @@ public void setStyle(String value) {
     /**
      * Gets the value of the multiple property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getMultiple() {
         if (multiple == null) {
             return "1";
-        } else {
+        }
+        else {
             return multiple;
         }
     }
@@ -173,10 +158,8 @@ public String getMultiple() {
     /**
      * Sets the value of the multiple property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setMultiple(String value) {
         this.multiple = value;
@@ -185,15 +168,14 @@ public void setMultiple(String value) {
     /**
      * Gets the value of the display property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDisplay() {
         if (display == null) {
             return "no";
-        } else {
+        }
+        else {
             return display;
         }
     }
@@ -201,10 +183,8 @@ public String getDisplay() {
     /**
      * Sets the value of the display property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDisplay(String value) {
         this.display = value;
@@ -213,10 +193,8 @@ public void setDisplay(String value) {
     /**
      * Gets the value of the altdistance property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAltdistance() {
         return altdistance;
@@ -225,10 +203,8 @@ public String getAltdistance() {
     /**
      * Sets the value of the altdistance property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAltdistance(String value) {
         this.altdistance = value;
@@ -237,10 +213,8 @@ public void setAltdistance(String value) {
     /**
      * Gets the value of the altunitdist property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAltunitdist() {
         return altunitdist;
@@ -249,10 +223,8 @@ public String getAltunitdist() {
     /**
      * Sets the value of the altunitdist property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAltunitdist(String value) {
         this.altunitdist = value;
@@ -261,10 +233,8 @@ public void setAltunitdist(String value) {
     /**
      * Gets the value of the altunit property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAltunit() {
         return altunit;
@@ -273,10 +243,8 @@ public String getAltunit() {
     /**
      * Sets the value of the altunit property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAltunit(String value) {
         this.altunit = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Hole.java b/src/main/java/org/openpnp/model/eagle/xml/Hole.java
index 6d2e55c1e4..5042ada691 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Hole.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Hole.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -38,10 +39,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -50,10 +49,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -62,10 +59,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -74,10 +69,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -86,10 +79,8 @@ public void setY(String value) {
     /**
      * Gets the value of the drill property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDrill() {
         return drill;
@@ -98,10 +89,8 @@ public String getDrill() {
     /**
      * Sets the value of the drill property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDrill(String value) {
         this.drill = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Instance.java b/src/main/java/org/openpnp/model/eagle/xml/Instance.java
index a04857dc29..9740ada839 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Instance.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Instance.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -24,9 +26,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute"
-})
+@XmlType(name = "", propOrder = {"attribute"})
 @XmlRootElement(name = "instance")
 public class Instance {
 
@@ -53,10 +53,8 @@
     /**
      * Gets the value of the part property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPart() {
         return part;
@@ -65,10 +63,8 @@ public String getPart() {
     /**
      * Sets the value of the part property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPart(String value) {
         this.part = value;
@@ -77,10 +73,8 @@ public void setPart(String value) {
     /**
      * Gets the value of the gate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getGate() {
         return gate;
@@ -89,10 +83,8 @@ public String getGate() {
     /**
      * Sets the value of the gate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setGate(String value) {
         this.gate = value;
@@ -101,10 +93,8 @@ public void setGate(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -113,10 +103,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -125,10 +113,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -137,10 +123,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -149,15 +133,14 @@ public void setY(String value) {
     /**
      * Gets the value of the smashed property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSmashed() {
         if (smashed == null) {
             return "no";
-        } else {
+        }
+        else {
             return smashed;
         }
     }
@@ -165,10 +148,8 @@ public String getSmashed() {
     /**
      * Sets the value of the smashed property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSmashed(String value) {
         this.smashed = value;
@@ -177,15 +158,14 @@ public void setSmashed(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -193,10 +173,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -206,21 +184,20 @@ public void setRot(String value) {
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Instances.java b/src/main/java/org/openpnp/model/eagle/xml/Instances.java
index 63dba1d1f4..9692282d34 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Instances.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Instances.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "instance"
-})
+@XmlType(name = "", propOrder = {"instance"})
 @XmlRootElement(name = "instances")
 public class Instances {
 
@@ -32,21 +32,20 @@
      * Gets the value of the instance property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the instance property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the instance property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getInstance().add(newItem);
+     * getInstance().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Instance }
+     * Objects of the following type(s) are allowed in the list {@link Instance }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Junction.java b/src/main/java/org/openpnp/model/eagle/xml/Junction.java
index 2d46407965..4873206be2 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Junction.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Junction.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -35,10 +36,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -47,10 +46,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -59,10 +56,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -71,10 +66,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Label.java b/src/main/java/org/openpnp/model/eagle/xml/Label.java
index b909be8f78..bee7b2093b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Label.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Label.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -54,10 +55,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -66,10 +65,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -78,10 +75,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -90,10 +85,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -102,10 +95,8 @@ public void setY(String value) {
     /**
      * Gets the value of the size property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSize() {
         return size;
@@ -114,10 +105,8 @@ public String getSize() {
     /**
      * Sets the value of the size property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSize(String value) {
         this.size = value;
@@ -126,10 +115,8 @@ public void setSize(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -138,10 +125,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -150,15 +135,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the font property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFont() {
         if (font == null) {
             return "proportional";
-        } else {
+        }
+        else {
             return font;
         }
     }
@@ -166,10 +150,8 @@ public String getFont() {
     /**
      * Sets the value of the font property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFont(String value) {
         this.font = value;
@@ -178,15 +160,14 @@ public void setFont(String value) {
     /**
      * Gets the value of the ratio property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRatio() {
         if (ratio == null) {
             return "8";
-        } else {
+        }
+        else {
             return ratio;
         }
     }
@@ -194,10 +175,8 @@ public String getRatio() {
     /**
      * Sets the value of the ratio property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRatio(String value) {
         this.ratio = value;
@@ -206,15 +185,14 @@ public void setRatio(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -222,10 +200,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -234,15 +210,14 @@ public void setRot(String value) {
     /**
      * Gets the value of the xref property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getXref() {
         if (xref == null) {
             return "no";
-        } else {
+        }
+        else {
             return xref;
         }
     }
@@ -250,10 +225,8 @@ public String getXref() {
     /**
      * Sets the value of the xref property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setXref(String value) {
         this.xref = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Layer.java b/src/main/java/org/openpnp/model/eagle/xml/Layer.java
index 8f5418f879..702742fa6e 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Layer.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Layer.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -48,10 +49,8 @@
     /**
      * Gets the value of the number property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getNumber() {
         return number;
@@ -60,10 +59,8 @@ public String getNumber() {
     /**
      * Sets the value of the number property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setNumber(String value) {
         this.number = value;
@@ -72,10 +69,8 @@ public void setNumber(String value) {
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -84,10 +79,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -96,10 +89,8 @@ public void setName(String value) {
     /**
      * Gets the value of the color property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getColor() {
         return color;
@@ -108,10 +99,8 @@ public String getColor() {
     /**
      * Sets the value of the color property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setColor(String value) {
         this.color = value;
@@ -120,10 +109,8 @@ public void setColor(String value) {
     /**
      * Gets the value of the fill property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFill() {
         return fill;
@@ -132,10 +119,8 @@ public String getFill() {
     /**
      * Sets the value of the fill property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFill(String value) {
         this.fill = value;
@@ -144,15 +129,14 @@ public void setFill(String value) {
     /**
      * Gets the value of the visible property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVisible() {
         if (visible == null) {
             return "yes";
-        } else {
+        }
+        else {
             return visible;
         }
     }
@@ -160,10 +144,8 @@ public String getVisible() {
     /**
      * Sets the value of the visible property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVisible(String value) {
         this.visible = value;
@@ -172,15 +154,14 @@ public void setVisible(String value) {
     /**
      * Gets the value of the active property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getActive() {
         if (active == null) {
             return "yes";
-        } else {
+        }
+        else {
             return active;
         }
     }
@@ -188,10 +169,8 @@ public String getActive() {
     /**
      * Sets the value of the active property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setActive(String value) {
         this.active = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Layers.java b/src/main/java/org/openpnp/model/eagle/xml/Layers.java
index 4691c10586..e1253be6a9 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Layers.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Layers.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "layer"
-})
+@XmlType(name = "", propOrder = {"layer"})
 @XmlRootElement(name = "layers")
 public class Layers {
 
@@ -32,21 +32,20 @@
      * Gets the value of the layer property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the layer property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the layer property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getLayer().add(newItem);
+     * getLayer().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Layer }
+     * Objects of the following type(s) are allowed in the list {@link Layer }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Libraries.java b/src/main/java/org/openpnp/model/eagle/xml/Libraries.java
index 59e4774f1a..2c027086d1 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Libraries.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Libraries.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "library"
-})
+@XmlType(name = "", propOrder = {"library"})
 @XmlRootElement(name = "libraries")
 public class Libraries {
 
@@ -32,21 +32,20 @@
      * Gets the value of the library property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the library property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the library property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getLibrary().add(newItem);
+     * getLibrary().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Library }
+     * Objects of the following type(s) are allowed in the list {@link Library }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Library.java b/src/main/java/org/openpnp/model/eagle/xml/Library.java
index 42f13b4035..ac5cae8955 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Library.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Library.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -21,12 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "packages",
-    "symbols",
-    "devicesets"
-})
+@XmlType(name = "", propOrder = {"description", "packages", "symbols", "devicesets"})
 @XmlRootElement(name = "library")
 public class Library {
 
@@ -41,10 +37,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -53,10 +47,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -65,10 +57,8 @@ public void setName(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -77,10 +67,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -89,10 +77,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the packages property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Packages }
-     *     
+     * @return possible object is {@link Packages }
+     * 
      */
     public Packages getPackages() {
         return packages;
@@ -101,10 +87,8 @@ public Packages getPackages() {
     /**
      * Sets the value of the packages property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Packages }
-     *     
+     * @param value allowed object is {@link Packages }
+     * 
      */
     public void setPackages(Packages value) {
         this.packages = value;
@@ -113,10 +97,8 @@ public void setPackages(Packages value) {
     /**
      * Gets the value of the symbols property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Symbols }
-     *     
+     * @return possible object is {@link Symbols }
+     * 
      */
     public Symbols getSymbols() {
         return symbols;
@@ -125,10 +107,8 @@ public Symbols getSymbols() {
     /**
      * Sets the value of the symbols property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Symbols }
-     *     
+     * @param value allowed object is {@link Symbols }
+     * 
      */
     public void setSymbols(Symbols value) {
         this.symbols = value;
@@ -137,10 +117,8 @@ public void setSymbols(Symbols value) {
     /**
      * Gets the value of the devicesets property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Devicesets }
-     *     
+     * @return possible object is {@link Devicesets }
+     * 
      */
     public Devicesets getDevicesets() {
         return devicesets;
@@ -149,10 +127,8 @@ public Devicesets getDevicesets() {
     /**
      * Sets the value of the devicesets property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Devicesets }
-     *     
+     * @param value allowed object is {@link Devicesets }
+     * 
      */
     public void setDevicesets(Devicesets value) {
         this.devicesets = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Module.java b/src/main/java/org/openpnp/model/eagle/xml/Module.java
index 7654b64265..d8798741a8 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Module.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Module.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -21,13 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "ports",
-    "variantdefs",
-    "parts",
-    "sheets"
-})
+@XmlType(name = "", propOrder = {"description", "ports", "variantdefs", "parts", "sheets"})
 @XmlRootElement(name = "module")
 public class Module {
 
@@ -52,10 +47,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -64,10 +57,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -76,15 +67,14 @@ public void setName(String value) {
     /**
      * Gets the value of the prefix property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPrefix() {
         if (prefix == null) {
             return "";
-        } else {
+        }
+        else {
             return prefix;
         }
     }
@@ -92,10 +82,8 @@ public String getPrefix() {
     /**
      * Sets the value of the prefix property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPrefix(String value) {
         this.prefix = value;
@@ -104,10 +92,8 @@ public void setPrefix(String value) {
     /**
      * Gets the value of the dx property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDx() {
         return dx;
@@ -116,10 +102,8 @@ public String getDx() {
     /**
      * Sets the value of the dx property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDx(String value) {
         this.dx = value;
@@ -128,10 +112,8 @@ public void setDx(String value) {
     /**
      * Gets the value of the dy property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDy() {
         return dy;
@@ -140,10 +122,8 @@ public String getDy() {
     /**
      * Sets the value of the dy property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDy(String value) {
         this.dy = value;
@@ -152,10 +132,8 @@ public void setDy(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -164,10 +142,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -176,10 +152,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the ports property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Ports }
-     *     
+     * @return possible object is {@link Ports }
+     * 
      */
     public Ports getPorts() {
         return ports;
@@ -188,10 +162,8 @@ public Ports getPorts() {
     /**
      * Sets the value of the ports property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Ports }
-     *     
+     * @param value allowed object is {@link Ports }
+     * 
      */
     public void setPorts(Ports value) {
         this.ports = value;
@@ -200,10 +172,8 @@ public void setPorts(Ports value) {
     /**
      * Gets the value of the variantdefs property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Variantdefs }
-     *     
+     * @return possible object is {@link Variantdefs }
+     * 
      */
     public Variantdefs getVariantdefs() {
         return variantdefs;
@@ -212,10 +182,8 @@ public Variantdefs getVariantdefs() {
     /**
      * Sets the value of the variantdefs property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Variantdefs }
-     *     
+     * @param value allowed object is {@link Variantdefs }
+     * 
      */
     public void setVariantdefs(Variantdefs value) {
         this.variantdefs = value;
@@ -224,10 +192,8 @@ public void setVariantdefs(Variantdefs value) {
     /**
      * Gets the value of the parts property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Parts }
-     *     
+     * @return possible object is {@link Parts }
+     * 
      */
     public Parts getParts() {
         return parts;
@@ -236,10 +202,8 @@ public Parts getParts() {
     /**
      * Sets the value of the parts property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Parts }
-     *     
+     * @param value allowed object is {@link Parts }
+     * 
      */
     public void setParts(Parts value) {
         this.parts = value;
@@ -248,10 +212,8 @@ public void setParts(Parts value) {
     /**
      * Gets the value of the sheets property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Sheets }
-     *     
+     * @return possible object is {@link Sheets }
+     * 
      */
     public Sheets getSheets() {
         return sheets;
@@ -260,10 +222,8 @@ public Sheets getSheets() {
     /**
      * Sets the value of the sheets property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Sheets }
-     *     
+     * @param value allowed object is {@link Sheets }
+     * 
      */
     public void setSheets(Sheets value) {
         this.sheets = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Moduleinst.java b/src/main/java/org/openpnp/model/eagle/xml/Moduleinst.java
index 30e7103a77..a10b592476 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Moduleinst.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Moduleinst.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -24,9 +26,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute"
-})
+@XmlType(name = "", propOrder = {"attribute"})
 @XmlRootElement(name = "moduleinst")
 public class Moduleinst {
 
@@ -59,10 +59,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -71,10 +69,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -83,10 +79,8 @@ public void setName(String value) {
     /**
      * Gets the value of the module property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getModule() {
         return module;
@@ -95,10 +89,8 @@ public String getModule() {
     /**
      * Sets the value of the module property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setModule(String value) {
         this.module = value;
@@ -107,15 +99,14 @@ public void setModule(String value) {
     /**
      * Gets the value of the modulevariant property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getModulevariant() {
         if (modulevariant == null) {
             return "";
-        } else {
+        }
+        else {
             return modulevariant;
         }
     }
@@ -123,10 +114,8 @@ public String getModulevariant() {
     /**
      * Sets the value of the modulevariant property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setModulevariant(String value) {
         this.modulevariant = value;
@@ -135,10 +124,8 @@ public void setModulevariant(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -147,10 +134,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -159,10 +144,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -171,10 +154,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -183,15 +164,14 @@ public void setY(String value) {
     /**
      * Gets the value of the offset property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getOffset() {
         if (offset == null) {
             return "0";
-        } else {
+        }
+        else {
             return offset;
         }
     }
@@ -199,10 +179,8 @@ public String getOffset() {
     /**
      * Sets the value of the offset property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setOffset(String value) {
         this.offset = value;
@@ -211,15 +189,14 @@ public void setOffset(String value) {
     /**
      * Gets the value of the smashed property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSmashed() {
         if (smashed == null) {
             return "no";
-        } else {
+        }
+        else {
             return smashed;
         }
     }
@@ -227,10 +204,8 @@ public String getSmashed() {
     /**
      * Sets the value of the smashed property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSmashed(String value) {
         this.smashed = value;
@@ -239,15 +214,14 @@ public void setSmashed(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -255,10 +229,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -268,21 +240,20 @@ public void setRot(String value) {
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Moduleinsts.java b/src/main/java/org/openpnp/model/eagle/xml/Moduleinsts.java
index 51bda1bce8..1982f08f05 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Moduleinsts.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Moduleinsts.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "moduleinst"
-})
+@XmlType(name = "", propOrder = {"moduleinst"})
 @XmlRootElement(name = "moduleinsts")
 public class Moduleinsts {
 
@@ -32,21 +32,20 @@
      * Gets the value of the moduleinst property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the moduleinst property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the moduleinst property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getModuleinst().add(newItem);
+     * getModuleinst().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Moduleinst }
+     * Objects of the following type(s) are allowed in the list {@link Moduleinst }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Modules.java b/src/main/java/org/openpnp/model/eagle/xml/Modules.java
index ba1d607319..bcf6652f30 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Modules.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Modules.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "module"
-})
+@XmlType(name = "", propOrder = {"module"})
 @XmlRootElement(name = "modules")
 public class Modules {
 
@@ -32,21 +32,20 @@
      * Gets the value of the module property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the module property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the module property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getModule().add(newItem);
+     * getModule().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Module }
+     * Objects of the following type(s) are allowed in the list {@link Module }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Net.java b/src/main/java/org/openpnp/model/eagle/xml/Net.java
index b0b18f5eb2..a0e8382ed1 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Net.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Net.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,9 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "segment"
-})
+@XmlType(name = "", propOrder = {"segment"})
 @XmlRootElement(name = "net")
 public class Net {
 
@@ -40,10 +40,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -52,10 +50,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -64,15 +60,14 @@ public void setName(String value) {
     /**
      * Gets the value of the clazz property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getClazz() {
         if (clazz == null) {
             return "0";
-        } else {
+        }
+        else {
             return clazz;
         }
     }
@@ -80,10 +75,8 @@ public String getClazz() {
     /**
      * Sets the value of the clazz property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setClazz(String value) {
         this.clazz = value;
@@ -93,21 +86,20 @@ public void setClazz(String value) {
      * Gets the value of the segment property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the segment property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the segment property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSegment().add(newItem);
+     * getSegment().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Segment }
+     * Objects of the following type(s) are allowed in the list {@link Segment }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Nets.java b/src/main/java/org/openpnp/model/eagle/xml/Nets.java
index 3d8e858697..bc9548e5af 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Nets.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Nets.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "net"
-})
+@XmlType(name = "", propOrder = {"net"})
 @XmlRootElement(name = "nets")
 public class Nets {
 
@@ -32,21 +32,20 @@
      * Gets the value of the net property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the net property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the net property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getNet().add(newItem);
+     * getNet().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Net }
+     * Objects of the following type(s) are allowed in the list {@link Net }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Note.java b/src/main/java/org/openpnp/model/eagle/xml/Note.java
index a2f4e813a0..816cea1d79 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Note.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Note.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -23,9 +24,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "value"
-})
+@XmlType(name = "", propOrder = {"value"})
 @XmlRootElement(name = "note")
 public class Note {
 
@@ -41,10 +40,8 @@
     /**
      * Gets the value of the version property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVersion() {
         return version;
@@ -53,10 +50,8 @@ public String getVersion() {
     /**
      * Sets the value of the version property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVersion(String value) {
         this.version = value;
@@ -65,10 +60,8 @@ public void setVersion(String value) {
     /**
      * Gets the value of the severity property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSeverity() {
         return severity;
@@ -77,10 +70,8 @@ public String getSeverity() {
     /**
      * Sets the value of the severity property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSeverity(String value) {
         this.severity = value;
@@ -89,10 +80,8 @@ public void setSeverity(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getvalue() {
         return value;
@@ -101,10 +90,8 @@ public String getvalue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setvalue(String value) {
         this.value = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/ObjectFactory.java b/src/main/java/org/openpnp/model/eagle/xml/ObjectFactory.java
index 3f1e7b12e7..82e7dd0eaa 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/ObjectFactory.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/ObjectFactory.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -12,17 +13,13 @@
 
 
 /**
- * This object contains factory methods for each 
- * Java content interface and Java element interface 
- * generated in the org.openpnp.model.eagle package. 
- * <p>An ObjectFactory allows you to programatically 
- * construct new instances of the Java representation 
- * for XML content. The Java representation of XML 
- * content can consist of schema derived interfaces 
- * and classes representing the binding of schema 
- * type definitions, element declarations and model 
- * groups.  Factory methods for each of these are 
- * provided in this class.
+ * This object contains factory methods for each Java content interface and Java element interface
+ * generated in the org.openpnp.model.eagle package.
+ * <p>
+ * An ObjectFactory allows you to programatically construct new instances of the Java representation
+ * for XML content. The Java representation of XML content can consist of schema derived interfaces
+ * and classes representing the binding of schema type definitions, element declarations and model
+ * groups. Factory methods for each of these are provided in this class.
  * 
  */
 @XmlRegistry
@@ -30,11 +27,11 @@
 
 
     /**
-     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: org.openpnp.model.eagle
+     * Create a new ObjectFactory that can be used to create new instances of schema derived classes
+     * for package: org.openpnp.model.eagle
      * 
      */
-    public ObjectFactory() {
-    }
+    public ObjectFactory() {}
 
     /**
      * Create an instance of {@link Busses }
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Package.java b/src/main/java/org/openpnp/model/eagle/xml/Package.java
index 94ee33c819..5dbbb862a3 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Package.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Package.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -25,10 +27,8 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd"
-})
+@XmlType(name = "", propOrder = {"description",
+        "polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd"})
 @XmlRootElement(name = "package")
 public class Package {
 
@@ -36,27 +36,23 @@
     @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
     protected String name;
     protected Description description;
-    @XmlElements({
-        @XmlElement(name = "polygon", type = Polygon.class),
-        @XmlElement(name = "wire", type = Wire.class),
-        @XmlElement(name = "text", type = Text.class),
-        @XmlElement(name = "dimension", type = Dimension.class),
-        @XmlElement(name = "circle", type = Circle.class),
-        @XmlElement(name = "rectangle", type = Rectangle.class),
-        @XmlElement(name = "frame", type = Frame.class),
-        @XmlElement(name = "hole", type = Hole.class),
-        @XmlElement(name = "pad", type = Pad.class),
-        @XmlElement(name = "smd", type = Smd.class)
-    })
+    @XmlElements({@XmlElement(name = "polygon", type = Polygon.class),
+            @XmlElement(name = "wire", type = Wire.class),
+            @XmlElement(name = "text", type = Text.class),
+            @XmlElement(name = "dimension", type = Dimension.class),
+            @XmlElement(name = "circle", type = Circle.class),
+            @XmlElement(name = "rectangle", type = Rectangle.class),
+            @XmlElement(name = "frame", type = Frame.class),
+            @XmlElement(name = "hole", type = Hole.class),
+            @XmlElement(name = "pad", type = Pad.class),
+            @XmlElement(name = "smd", type = Smd.class)})
     protected List<Object> polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd;
 
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -65,10 +61,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -77,10 +71,8 @@ public void setName(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -89,49 +81,42 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
     }
 
     /**
-     * Gets the value of the polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd property.
+     * Gets the value of the
+     * polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the
+     * polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd().add(newItem);
+     * getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Polygon }
-     * {@link Wire }
-     * {@link Text }
-     * {@link Dimension }
-     * {@link Circle }
-     * {@link Rectangle }
-     * {@link Frame }
-     * {@link Hole }
-     * {@link Pad }
-     * {@link Smd }
+     * Objects of the following type(s) are allowed in the list {@link Polygon } {@link Wire }
+     * {@link Text } {@link Dimension } {@link Circle } {@link Rectangle } {@link Frame }
+     * {@link Hole } {@link Pad } {@link Smd }
      * 
      * 
      */
     public List<Object> getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd() {
         if (polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd == null) {
-            polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd = new ArrayList<>();
+            polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd =
+                    new ArrayList<>();
         }
         return this.polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHoleOrPadOrSmd;
     }
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Packages.java b/src/main/java/org/openpnp/model/eagle/xml/Packages.java
index 71408f3146..9e023943a0 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Packages.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Packages.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
@@ -21,9 +23,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "_package"
-})
+@XmlType(name = "", propOrder = {"_package"})
 @XmlRootElement(name = "packages")
 public class Packages {
 
@@ -34,21 +34,20 @@
      * Gets the value of the package property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the package property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the package property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPackage().add(newItem);
+     * getPackage().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Package }
+     * Objects of the following type(s) are allowed in the list {@link Package }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Pad.java b/src/main/java/org/openpnp/model/eagle/xml/Pad.java
index 59d581087e..695c897d34 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Pad.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Pad.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -60,10 +61,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -72,10 +71,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -84,10 +81,8 @@ public void setName(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -96,10 +91,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -108,10 +101,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -120,10 +111,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -132,10 +121,8 @@ public void setY(String value) {
     /**
      * Gets the value of the drill property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDrill() {
         return drill;
@@ -144,10 +131,8 @@ public String getDrill() {
     /**
      * Sets the value of the drill property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDrill(String value) {
         this.drill = value;
@@ -156,15 +141,14 @@ public void setDrill(String value) {
     /**
      * Gets the value of the diameter property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDiameter() {
         if (diameter == null) {
             return "0";
-        } else {
+        }
+        else {
             return diameter;
         }
     }
@@ -172,10 +156,8 @@ public String getDiameter() {
     /**
      * Sets the value of the diameter property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDiameter(String value) {
         this.diameter = value;
@@ -184,15 +166,14 @@ public void setDiameter(String value) {
     /**
      * Gets the value of the shape property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getShape() {
         if (shape == null) {
             return "round";
-        } else {
+        }
+        else {
             return shape;
         }
     }
@@ -200,10 +181,8 @@ public String getShape() {
     /**
      * Sets the value of the shape property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setShape(String value) {
         this.shape = value;
@@ -212,15 +191,14 @@ public void setShape(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -228,10 +206,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -240,15 +216,14 @@ public void setRot(String value) {
     /**
      * Gets the value of the stop property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getStop() {
         if (stop == null) {
             return "yes";
-        } else {
+        }
+        else {
             return stop;
         }
     }
@@ -256,10 +231,8 @@ public String getStop() {
     /**
      * Sets the value of the stop property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setStop(String value) {
         this.stop = value;
@@ -268,15 +241,14 @@ public void setStop(String value) {
     /**
      * Gets the value of the thermals property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getThermals() {
         if (thermals == null) {
             return "yes";
-        } else {
+        }
+        else {
             return thermals;
         }
     }
@@ -284,10 +256,8 @@ public String getThermals() {
     /**
      * Sets the value of the thermals property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setThermals(String value) {
         this.thermals = value;
@@ -296,15 +266,14 @@ public void setThermals(String value) {
     /**
      * Gets the value of the first property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFirst() {
         if (first == null) {
             return "no";
-        } else {
+        }
+        else {
             return first;
         }
     }
@@ -312,10 +281,8 @@ public String getFirst() {
     /**
      * Sets the value of the first property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFirst(String value) {
         this.first = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Param.java b/src/main/java/org/openpnp/model/eagle/xml/Param.java
index 3352a6c639..6b6bf04c32 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Param.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Param.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -35,10 +36,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -47,10 +46,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -59,10 +56,8 @@ public void setName(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         return value;
@@ -71,10 +66,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Part.java b/src/main/java/org/openpnp/model/eagle/xml/Part.java
index b22d1c4549..331d9fe0aa 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Part.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Part.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,10 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute",
-    "variant"
-})
+@XmlType(name = "", propOrder = {"attribute", "variant"})
 @XmlRootElement(name = "part")
 public class Part {
 
@@ -54,10 +53,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -66,10 +63,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -78,10 +73,8 @@ public void setName(String value) {
     /**
      * Gets the value of the library property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLibrary() {
         return library;
@@ -90,10 +83,8 @@ public String getLibrary() {
     /**
      * Sets the value of the library property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLibrary(String value) {
         this.library = value;
@@ -102,10 +93,8 @@ public void setLibrary(String value) {
     /**
      * Gets the value of the deviceset property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDeviceset() {
         return deviceset;
@@ -114,10 +103,8 @@ public String getDeviceset() {
     /**
      * Sets the value of the deviceset property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDeviceset(String value) {
         this.deviceset = value;
@@ -126,10 +113,8 @@ public void setDeviceset(String value) {
     /**
      * Gets the value of the device property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDevice() {
         return device;
@@ -138,10 +123,8 @@ public String getDevice() {
     /**
      * Sets the value of the device property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDevice(String value) {
         this.device = value;
@@ -150,15 +133,14 @@ public void setDevice(String value) {
     /**
      * Gets the value of the technology property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getTechnology() {
         if (technology == null) {
             return "";
-        } else {
+        }
+        else {
             return technology;
         }
     }
@@ -166,10 +148,8 @@ public String getTechnology() {
     /**
      * Sets the value of the technology property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setTechnology(String value) {
         this.technology = value;
@@ -178,10 +158,8 @@ public void setTechnology(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         return value;
@@ -190,10 +168,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
@@ -203,21 +179,20 @@ public void setValue(String value) {
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
@@ -232,21 +207,20 @@ public void setValue(String value) {
      * Gets the value of the variant property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the variant property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the variant property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getVariant().add(newItem);
+     * getVariant().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Variant }
+     * Objects of the following type(s) are allowed in the list {@link Variant }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Parts.java b/src/main/java/org/openpnp/model/eagle/xml/Parts.java
index e9e730a0c0..e4d7c6abe9 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Parts.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Parts.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "part"
-})
+@XmlType(name = "", propOrder = {"part"})
 @XmlRootElement(name = "parts")
 public class Parts {
 
@@ -32,21 +32,20 @@
      * Gets the value of the part property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the part property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the part property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPart().add(newItem);
+     * getPart().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Part }
+     * Objects of the following type(s) are allowed in the list {@link Part }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Pass.java b/src/main/java/org/openpnp/model/eagle/xml/Pass.java
index e7d1790157..7a7b933025 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Pass.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Pass.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -24,9 +26,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "param"
-})
+@XmlType(name = "", propOrder = {"param"})
 @XmlRootElement(name = "pass")
 public class Pass {
 
@@ -44,10 +44,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -56,10 +54,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -68,10 +64,8 @@ public void setName(String value) {
     /**
      * Gets the value of the refer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRefer() {
         return refer;
@@ -80,10 +74,8 @@ public String getRefer() {
     /**
      * Sets the value of the refer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRefer(String value) {
         this.refer = value;
@@ -92,15 +84,14 @@ public void setRefer(String value) {
     /**
      * Gets the value of the active property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getActive() {
         if (active == null) {
             return "yes";
-        } else {
+        }
+        else {
             return active;
         }
     }
@@ -108,10 +99,8 @@ public String getActive() {
     /**
      * Sets the value of the active property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setActive(String value) {
         this.active = value;
@@ -121,21 +110,20 @@ public void setActive(String value) {
      * Gets the value of the param property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the param property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the param property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getParam().add(newItem);
+     * getParam().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Param }
+     * Objects of the following type(s) are allowed in the list {@link Param }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Pin.java b/src/main/java/org/openpnp/model/eagle/xml/Pin.java
index 6e9c733796..887d5868f1 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Pin.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Pin.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -57,10 +58,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -69,10 +68,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -81,10 +78,8 @@ public void setName(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -93,10 +88,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -105,10 +98,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -117,10 +108,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -129,15 +118,14 @@ public void setY(String value) {
     /**
      * Gets the value of the visible property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVisible() {
         if (visible == null) {
             return "both";
-        } else {
+        }
+        else {
             return visible;
         }
     }
@@ -145,10 +133,8 @@ public String getVisible() {
     /**
      * Sets the value of the visible property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVisible(String value) {
         this.visible = value;
@@ -157,15 +143,14 @@ public void setVisible(String value) {
     /**
      * Gets the value of the length property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLength() {
         if (length == null) {
             return "long";
-        } else {
+        }
+        else {
             return length;
         }
     }
@@ -173,10 +158,8 @@ public String getLength() {
     /**
      * Sets the value of the length property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLength(String value) {
         this.length = value;
@@ -185,15 +168,14 @@ public void setLength(String value) {
     /**
      * Gets the value of the direction property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDirection() {
         if (direction == null) {
             return "io";
-        } else {
+        }
+        else {
             return direction;
         }
     }
@@ -201,10 +183,8 @@ public String getDirection() {
     /**
      * Sets the value of the direction property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDirection(String value) {
         this.direction = value;
@@ -213,15 +193,14 @@ public void setDirection(String value) {
     /**
      * Gets the value of the function property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFunction() {
         if (function == null) {
             return "none";
-        } else {
+        }
+        else {
             return function;
         }
     }
@@ -229,10 +208,8 @@ public String getFunction() {
     /**
      * Sets the value of the function property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFunction(String value) {
         this.function = value;
@@ -241,15 +218,14 @@ public void setFunction(String value) {
     /**
      * Gets the value of the swaplevel property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSwaplevel() {
         if (swaplevel == null) {
             return "0";
-        } else {
+        }
+        else {
             return swaplevel;
         }
     }
@@ -257,10 +233,8 @@ public String getSwaplevel() {
     /**
      * Sets the value of the swaplevel property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSwaplevel(String value) {
         this.swaplevel = value;
@@ -269,15 +243,14 @@ public void setSwaplevel(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -285,10 +258,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Pinref.java b/src/main/java/org/openpnp/model/eagle/xml/Pinref.java
index 65922096c9..8769e9cb8b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Pinref.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Pinref.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -38,10 +39,8 @@
     /**
      * Gets the value of the part property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPart() {
         return part;
@@ -50,10 +49,8 @@ public String getPart() {
     /**
      * Sets the value of the part property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPart(String value) {
         this.part = value;
@@ -62,10 +59,8 @@ public void setPart(String value) {
     /**
      * Gets the value of the gate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getGate() {
         return gate;
@@ -74,10 +69,8 @@ public String getGate() {
     /**
      * Sets the value of the gate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setGate(String value) {
         this.gate = value;
@@ -86,10 +79,8 @@ public void setGate(String value) {
     /**
      * Gets the value of the pin property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPin() {
         return pin;
@@ -98,10 +89,8 @@ public String getPin() {
     /**
      * Sets the value of the pin property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPin(String value) {
         this.pin = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Plain.java b/src/main/java/org/openpnp/model/eagle/xml/Plain.java
index 1945eba1cd..abff789392 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Plain.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Plain.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
@@ -22,49 +24,41 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole"
-})
+@XmlType(name = "", propOrder = {"polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole"})
 @XmlRootElement(name = "plain")
 public class Plain {
 
-    @XmlElements({
-        @XmlElement(name = "polygon", type = Polygon.class),
-        @XmlElement(name = "wire", type = Wire.class),
-        @XmlElement(name = "text", type = Text.class),
-        @XmlElement(name = "dimension", type = Dimension.class),
-        @XmlElement(name = "circle", type = Circle.class),
-        @XmlElement(name = "rectangle", type = Rectangle.class),
-        @XmlElement(name = "frame", type = Frame.class),
-        @XmlElement(name = "hole", type = Hole.class)
-    })
+    @XmlElements({@XmlElement(name = "polygon", type = Polygon.class),
+            @XmlElement(name = "wire", type = Wire.class),
+            @XmlElement(name = "text", type = Text.class),
+            @XmlElement(name = "dimension", type = Dimension.class),
+            @XmlElement(name = "circle", type = Circle.class),
+            @XmlElement(name = "rectangle", type = Rectangle.class),
+            @XmlElement(name = "frame", type = Frame.class),
+            @XmlElement(name = "hole", type = Hole.class)})
     protected List<Object> polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole;
 
     /**
-     * Gets the value of the polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole property.
+     * Gets the value of the polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole
+     * property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the
+     * polygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole().add(newItem);
+     * getPolygonOrWireOrTextOrDimensionOrCircleOrRectangleOrFrameOrHole().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Polygon }
-     * {@link Wire }
-     * {@link Text }
-     * {@link Dimension }
-     * {@link Circle }
-     * {@link Rectangle }
-     * {@link Frame }
+     * Objects of the following type(s) are allowed in the list {@link Polygon } {@link Wire }
+     * {@link Text } {@link Dimension } {@link Circle } {@link Rectangle } {@link Frame }
      * {@link Hole }
      * 
      * 
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Polygon.java b/src/main/java/org/openpnp/model/eagle/xml/Polygon.java
index 60585b9458..28022ad02e 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Polygon.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Polygon.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -24,9 +26,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "vertex"
-})
+@XmlType(name = "", propOrder = {"vertex"})
 @XmlRootElement(name = "polygon")
 public class Polygon {
 
@@ -59,10 +59,8 @@
     /**
      * Gets the value of the width property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getWidth() {
         return width;
@@ -71,10 +69,8 @@ public String getWidth() {
     /**
      * Sets the value of the width property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setWidth(String value) {
         this.width = value;
@@ -83,10 +79,8 @@ public void setWidth(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -95,10 +89,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -107,10 +99,8 @@ public void setLayer(String value) {
     /**
      * Gets the value of the spacing property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSpacing() {
         return spacing;
@@ -119,10 +109,8 @@ public String getSpacing() {
     /**
      * Sets the value of the spacing property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSpacing(String value) {
         this.spacing = value;
@@ -131,15 +119,14 @@ public void setSpacing(String value) {
     /**
      * Gets the value of the pour property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPour() {
         if (pour == null) {
             return "solid";
-        } else {
+        }
+        else {
             return pour;
         }
     }
@@ -147,10 +134,8 @@ public String getPour() {
     /**
      * Sets the value of the pour property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPour(String value) {
         this.pour = value;
@@ -159,10 +144,8 @@ public void setPour(String value) {
     /**
      * Gets the value of the isolate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getIsolate() {
         return isolate;
@@ -171,10 +154,8 @@ public String getIsolate() {
     /**
      * Sets the value of the isolate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setIsolate(String value) {
         this.isolate = value;
@@ -183,15 +164,14 @@ public void setIsolate(String value) {
     /**
      * Gets the value of the orphans property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getOrphans() {
         if (orphans == null) {
             return "no";
-        } else {
+        }
+        else {
             return orphans;
         }
     }
@@ -199,10 +179,8 @@ public String getOrphans() {
     /**
      * Sets the value of the orphans property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setOrphans(String value) {
         this.orphans = value;
@@ -211,15 +189,14 @@ public void setOrphans(String value) {
     /**
      * Gets the value of the thermals property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getThermals() {
         if (thermals == null) {
             return "yes";
-        } else {
+        }
+        else {
             return thermals;
         }
     }
@@ -227,10 +204,8 @@ public String getThermals() {
     /**
      * Sets the value of the thermals property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setThermals(String value) {
         this.thermals = value;
@@ -239,15 +214,14 @@ public void setThermals(String value) {
     /**
      * Gets the value of the rank property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRank() {
         if (rank == null) {
             return "0";
-        } else {
+        }
+        else {
             return rank;
         }
     }
@@ -255,10 +229,8 @@ public String getRank() {
     /**
      * Sets the value of the rank property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRank(String value) {
         this.rank = value;
@@ -268,21 +240,20 @@ public void setRank(String value) {
      * Gets the value of the vertex property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the vertex property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the vertex property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getVertex().add(newItem);
+     * getVertex().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Vertex }
+     * Objects of the following type(s) are allowed in the list {@link Vertex }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Port.java b/src/main/java/org/openpnp/model/eagle/xml/Port.java
index ad5370861f..ab5d90c471 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Port.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Port.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -42,10 +43,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -54,10 +53,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -66,10 +63,8 @@ public void setName(String value) {
     /**
      * Gets the value of the side property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSide() {
         return side;
@@ -78,10 +73,8 @@ public String getSide() {
     /**
      * Sets the value of the side property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSide(String value) {
         this.side = value;
@@ -90,10 +83,8 @@ public void setSide(String value) {
     /**
      * Gets the value of the coord property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCoord() {
         return coord;
@@ -102,10 +93,8 @@ public String getCoord() {
     /**
      * Sets the value of the coord property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCoord(String value) {
         this.coord = value;
@@ -114,15 +103,14 @@ public void setCoord(String value) {
     /**
      * Gets the value of the direction property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDirection() {
         if (direction == null) {
             return "io";
-        } else {
+        }
+        else {
             return direction;
         }
     }
@@ -130,10 +118,8 @@ public String getDirection() {
     /**
      * Sets the value of the direction property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDirection(String value) {
         this.direction = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Portref.java b/src/main/java/org/openpnp/model/eagle/xml/Portref.java
index 6d1e0905d1..85fee1a5a0 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Portref.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Portref.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -35,10 +36,8 @@
     /**
      * Gets the value of the moduleinst property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getModuleinst() {
         return moduleinst;
@@ -47,10 +46,8 @@ public String getModuleinst() {
     /**
      * Sets the value of the moduleinst property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setModuleinst(String value) {
         this.moduleinst = value;
@@ -59,10 +56,8 @@ public void setModuleinst(String value) {
     /**
      * Gets the value of the port property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPort() {
         return port;
@@ -71,10 +66,8 @@ public String getPort() {
     /**
      * Sets the value of the port property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPort(String value) {
         this.port = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Ports.java b/src/main/java/org/openpnp/model/eagle/xml/Ports.java
index b975538628..7a52a6e077 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Ports.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Ports.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "port"
-})
+@XmlType(name = "", propOrder = {"port"})
 @XmlRootElement(name = "ports")
 public class Ports {
 
@@ -32,21 +32,20 @@
      * Gets the value of the port property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the port property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the port property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPort().add(newItem);
+     * getPort().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Port }
+     * Objects of the following type(s) are allowed in the list {@link Port }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Rectangle.java b/src/main/java/org/openpnp/model/eagle/xml/Rectangle.java
index 2494d0fa98..b29d6d3a7c 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Rectangle.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Rectangle.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -47,10 +48,8 @@
     /**
      * Gets the value of the x1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX1() {
         return x1;
@@ -59,10 +58,8 @@ public String getX1() {
     /**
      * Sets the value of the x1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX1(String value) {
         this.x1 = value;
@@ -71,10 +68,8 @@ public void setX1(String value) {
     /**
      * Gets the value of the y1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY1() {
         return y1;
@@ -83,10 +78,8 @@ public String getY1() {
     /**
      * Sets the value of the y1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY1(String value) {
         this.y1 = value;
@@ -95,10 +88,8 @@ public void setY1(String value) {
     /**
      * Gets the value of the x2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX2() {
         return x2;
@@ -107,10 +98,8 @@ public String getX2() {
     /**
      * Sets the value of the x2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX2(String value) {
         this.x2 = value;
@@ -119,10 +108,8 @@ public void setX2(String value) {
     /**
      * Gets the value of the y2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY2() {
         return y2;
@@ -131,10 +118,8 @@ public String getY2() {
     /**
      * Sets the value of the y2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY2(String value) {
         this.y2 = value;
@@ -143,10 +128,8 @@ public void setY2(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -155,10 +138,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -167,15 +148,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -183,10 +163,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Schematic.java b/src/main/java/org/openpnp/model/eagle/xml/Schematic.java
index c0535aa2f6..1236c373f6 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Schematic.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Schematic.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -21,17 +22,8 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "libraries",
-    "attributes",
-    "variantdefs",
-    "classes",
-    "modules",
-    "parts",
-    "sheets",
-    "errors"
-})
+@XmlType(name = "", propOrder = {"description", "libraries", "attributes", "variantdefs", "classes",
+        "modules", "parts", "sheets", "errors"})
 @XmlRootElement(name = "schematic")
 public class Schematic {
 
@@ -54,10 +46,8 @@
     /**
      * Gets the value of the xreflabel property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getXreflabel() {
         return xreflabel;
@@ -66,10 +56,8 @@ public String getXreflabel() {
     /**
      * Sets the value of the xreflabel property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setXreflabel(String value) {
         this.xreflabel = value;
@@ -78,10 +66,8 @@ public void setXreflabel(String value) {
     /**
      * Gets the value of the xrefpart property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getXrefpart() {
         return xrefpart;
@@ -90,10 +76,8 @@ public String getXrefpart() {
     /**
      * Sets the value of the xrefpart property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setXrefpart(String value) {
         this.xrefpart = value;
@@ -102,10 +86,8 @@ public void setXrefpart(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -114,10 +96,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -126,10 +106,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the libraries property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Libraries }
-     *     
+     * @return possible object is {@link Libraries }
+     * 
      */
     public Libraries getLibraries() {
         return libraries;
@@ -138,10 +116,8 @@ public Libraries getLibraries() {
     /**
      * Sets the value of the libraries property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Libraries }
-     *     
+     * @param value allowed object is {@link Libraries }
+     * 
      */
     public void setLibraries(Libraries value) {
         this.libraries = value;
@@ -150,10 +126,8 @@ public void setLibraries(Libraries value) {
     /**
      * Gets the value of the attributes property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Attributes }
-     *     
+     * @return possible object is {@link Attributes }
+     * 
      */
     public Attributes getAttributes() {
         return attributes;
@@ -162,10 +136,8 @@ public Attributes getAttributes() {
     /**
      * Sets the value of the attributes property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Attributes }
-     *     
+     * @param value allowed object is {@link Attributes }
+     * 
      */
     public void setAttributes(Attributes value) {
         this.attributes = value;
@@ -174,10 +146,8 @@ public void setAttributes(Attributes value) {
     /**
      * Gets the value of the variantdefs property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Variantdefs }
-     *     
+     * @return possible object is {@link Variantdefs }
+     * 
      */
     public Variantdefs getVariantdefs() {
         return variantdefs;
@@ -186,10 +156,8 @@ public Variantdefs getVariantdefs() {
     /**
      * Sets the value of the variantdefs property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Variantdefs }
-     *     
+     * @param value allowed object is {@link Variantdefs }
+     * 
      */
     public void setVariantdefs(Variantdefs value) {
         this.variantdefs = value;
@@ -198,10 +166,8 @@ public void setVariantdefs(Variantdefs value) {
     /**
      * Gets the value of the classes property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Classes }
-     *     
+     * @return possible object is {@link Classes }
+     * 
      */
     public Classes getClasses() {
         return classes;
@@ -210,10 +176,8 @@ public Classes getClasses() {
     /**
      * Sets the value of the classes property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Classes }
-     *     
+     * @param value allowed object is {@link Classes }
+     * 
      */
     public void setClasses(Classes value) {
         this.classes = value;
@@ -222,10 +186,8 @@ public void setClasses(Classes value) {
     /**
      * Gets the value of the modules property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Modules }
-     *     
+     * @return possible object is {@link Modules }
+     * 
      */
     public Modules getModules() {
         return modules;
@@ -234,10 +196,8 @@ public Modules getModules() {
     /**
      * Sets the value of the modules property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Modules }
-     *     
+     * @param value allowed object is {@link Modules }
+     * 
      */
     public void setModules(Modules value) {
         this.modules = value;
@@ -246,10 +206,8 @@ public void setModules(Modules value) {
     /**
      * Gets the value of the parts property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Parts }
-     *     
+     * @return possible object is {@link Parts }
+     * 
      */
     public Parts getParts() {
         return parts;
@@ -258,10 +216,8 @@ public Parts getParts() {
     /**
      * Sets the value of the parts property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Parts }
-     *     
+     * @param value allowed object is {@link Parts }
+     * 
      */
     public void setParts(Parts value) {
         this.parts = value;
@@ -270,10 +226,8 @@ public void setParts(Parts value) {
     /**
      * Gets the value of the sheets property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Sheets }
-     *     
+     * @return possible object is {@link Sheets }
+     * 
      */
     public Sheets getSheets() {
         return sheets;
@@ -282,10 +236,8 @@ public Sheets getSheets() {
     /**
      * Sets the value of the sheets property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Sheets }
-     *     
+     * @param value allowed object is {@link Sheets }
+     * 
      */
     public void setSheets(Sheets value) {
         this.sheets = value;
@@ -294,10 +246,8 @@ public void setSheets(Sheets value) {
     /**
      * Gets the value of the errors property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Errors }
-     *     
+     * @return possible object is {@link Errors }
+     * 
      */
     public Errors getErrors() {
         return errors;
@@ -306,10 +256,8 @@ public Errors getErrors() {
     /**
      * Sets the value of the errors property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Errors }
-     *     
+     * @param value allowed object is {@link Errors }
+     * 
      */
     public void setErrors(Errors value) {
         this.errors = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Segment.java b/src/main/java/org/openpnp/model/eagle/xml/Segment.java
index 401bd6ad8b..227cf0dc99 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Segment.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Segment.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlElement;
@@ -22,44 +24,37 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "pinrefOrPortrefOrWireOrJunctionOrLabel"
-})
+@XmlType(name = "", propOrder = {"pinrefOrPortrefOrWireOrJunctionOrLabel"})
 @XmlRootElement(name = "segment")
 public class Segment {
 
-    @XmlElements({
-        @XmlElement(name = "pinref", type = Pinref.class),
-        @XmlElement(name = "portref", type = Portref.class),
-        @XmlElement(name = "wire", type = Wire.class),
-        @XmlElement(name = "junction", type = Junction.class),
-        @XmlElement(name = "label", type = Label.class)
-    })
+    @XmlElements({@XmlElement(name = "pinref", type = Pinref.class),
+            @XmlElement(name = "portref", type = Portref.class),
+            @XmlElement(name = "wire", type = Wire.class),
+            @XmlElement(name = "junction", type = Junction.class),
+            @XmlElement(name = "label", type = Label.class)})
     protected List<Object> pinrefOrPortrefOrWireOrJunctionOrLabel;
 
     /**
      * Gets the value of the pinrefOrPortrefOrWireOrJunctionOrLabel property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the pinrefOrPortrefOrWireOrJunctionOrLabel property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the pinrefOrPortrefOrWireOrJunctionOrLabel
+     * property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPinrefOrPortrefOrWireOrJunctionOrLabel().add(newItem);
+     * getPinrefOrPortrefOrWireOrJunctionOrLabel().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Pinref }
-     * {@link Portref }
-     * {@link Wire }
-     * {@link Junction }
-     * {@link Label }
+     * Objects of the following type(s) are allowed in the list {@link Pinref } {@link Portref }
+     * {@link Wire } {@link Junction } {@link Label }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Setting.java b/src/main/java/org/openpnp/model/eagle/xml/Setting.java
index 6ec85527a7..382922a58f 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Setting.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Setting.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -35,10 +36,8 @@
     /**
      * Gets the value of the alwaysvectorfont property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAlwaysvectorfont() {
         return alwaysvectorfont;
@@ -47,10 +46,8 @@ public String getAlwaysvectorfont() {
     /**
      * Sets the value of the alwaysvectorfont property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAlwaysvectorfont(String value) {
         this.alwaysvectorfont = value;
@@ -59,15 +56,14 @@ public void setAlwaysvectorfont(String value) {
     /**
      * Gets the value of the verticaltext property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getVerticaltext() {
         if (verticaltext == null) {
             return "up";
-        } else {
+        }
+        else {
             return verticaltext;
         }
     }
@@ -75,10 +71,8 @@ public String getVerticaltext() {
     /**
      * Sets the value of the verticaltext property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setVerticaltext(String value) {
         this.verticaltext = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Settings.java b/src/main/java/org/openpnp/model/eagle/xml/Settings.java
index b26d4c651c..d400006acd 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Settings.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Settings.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "setting"
-})
+@XmlType(name = "", propOrder = {"setting"})
 @XmlRootElement(name = "settings")
 public class Settings {
 
@@ -32,21 +32,20 @@
      * Gets the value of the setting property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the setting property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the setting property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSetting().add(newItem);
+     * getSetting().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Setting }
+     * Objects of the following type(s) are allowed in the list {@link Setting }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Sheet.java b/src/main/java/org/openpnp/model/eagle/xml/Sheet.java
index 3311d95cd4..bf7b1f2f42 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Sheet.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Sheet.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -18,14 +19,8 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "plain",
-    "moduleinsts",
-    "instances",
-    "busses",
-    "nets"
-})
+@XmlType(name = "",
+        propOrder = {"description", "plain", "moduleinsts", "instances", "busses", "nets"})
 @XmlRootElement(name = "sheet")
 public class Sheet {
 
@@ -39,10 +34,8 @@
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -51,10 +44,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -63,10 +54,8 @@ public void setDescription(Description value) {
     /**
      * Gets the value of the plain property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Plain }
-     *     
+     * @return possible object is {@link Plain }
+     * 
      */
     public Plain getPlain() {
         return plain;
@@ -75,10 +64,8 @@ public Plain getPlain() {
     /**
      * Sets the value of the plain property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Plain }
-     *     
+     * @param value allowed object is {@link Plain }
+     * 
      */
     public void setPlain(Plain value) {
         this.plain = value;
@@ -87,10 +74,8 @@ public void setPlain(Plain value) {
     /**
      * Gets the value of the moduleinsts property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Moduleinsts }
-     *     
+     * @return possible object is {@link Moduleinsts }
+     * 
      */
     public Moduleinsts getModuleinsts() {
         return moduleinsts;
@@ -99,10 +84,8 @@ public Moduleinsts getModuleinsts() {
     /**
      * Sets the value of the moduleinsts property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Moduleinsts }
-     *     
+     * @param value allowed object is {@link Moduleinsts }
+     * 
      */
     public void setModuleinsts(Moduleinsts value) {
         this.moduleinsts = value;
@@ -111,10 +94,8 @@ public void setModuleinsts(Moduleinsts value) {
     /**
      * Gets the value of the instances property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Instances }
-     *     
+     * @return possible object is {@link Instances }
+     * 
      */
     public Instances getInstances() {
         return instances;
@@ -123,10 +104,8 @@ public Instances getInstances() {
     /**
      * Sets the value of the instances property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Instances }
-     *     
+     * @param value allowed object is {@link Instances }
+     * 
      */
     public void setInstances(Instances value) {
         this.instances = value;
@@ -135,10 +114,8 @@ public void setInstances(Instances value) {
     /**
      * Gets the value of the busses property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Busses }
-     *     
+     * @return possible object is {@link Busses }
+     * 
      */
     public Busses getBusses() {
         return busses;
@@ -147,10 +124,8 @@ public Busses getBusses() {
     /**
      * Sets the value of the busses property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Busses }
-     *     
+     * @param value allowed object is {@link Busses }
+     * 
      */
     public void setBusses(Busses value) {
         this.busses = value;
@@ -159,10 +134,8 @@ public void setBusses(Busses value) {
     /**
      * Gets the value of the nets property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Nets }
-     *     
+     * @return possible object is {@link Nets }
+     * 
      */
     public Nets getNets() {
         return nets;
@@ -171,10 +144,8 @@ public Nets getNets() {
     /**
      * Sets the value of the nets property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Nets }
-     *     
+     * @param value allowed object is {@link Nets }
+     * 
      */
     public void setNets(Nets value) {
         this.nets = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Sheets.java b/src/main/java/org/openpnp/model/eagle/xml/Sheets.java
index c133ee4f39..904943220c 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Sheets.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Sheets.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "sheet"
-})
+@XmlType(name = "", propOrder = {"sheet"})
 @XmlRootElement(name = "sheets")
 public class Sheets {
 
@@ -32,21 +32,20 @@
      * Gets the value of the sheet property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the sheet property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the sheet property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSheet().add(newItem);
+     * getSheet().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Sheet }
+     * Objects of the following type(s) are allowed in the list {@link Sheet }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Signal.java b/src/main/java/org/openpnp/model/eagle/xml/Signal.java
index c10902f161..5594fbbc5b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Signal.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Signal.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -26,9 +28,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "contactrefOrPolygonOrWireOrVia"
-})
+@XmlType(name = "", propOrder = {"contactrefOrPolygonOrWireOrVia"})
 @XmlRootElement(name = "signal")
 public class Signal {
 
@@ -41,21 +41,17 @@
     @XmlAttribute(name = "airwireshidden")
     @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
     protected String airwireshidden;
-    @XmlElements({
-        @XmlElement(name = "contactref", type = Contactref.class),
-        @XmlElement(name = "polygon", type = Polygon.class),
-        @XmlElement(name = "wire", type = Wire.class),
-        @XmlElement(name = "via", type = Via.class)
-    })
+    @XmlElements({@XmlElement(name = "contactref", type = Contactref.class),
+            @XmlElement(name = "polygon", type = Polygon.class),
+            @XmlElement(name = "wire", type = Wire.class),
+            @XmlElement(name = "via", type = Via.class)})
     protected List<Object> contactrefOrPolygonOrWireOrVia;
 
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -64,10 +60,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -76,15 +70,14 @@ public void setName(String value) {
     /**
      * Gets the value of the clazz property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getClazz() {
         if (clazz == null) {
             return "0";
-        } else {
+        }
+        else {
             return clazz;
         }
     }
@@ -92,10 +85,8 @@ public String getClazz() {
     /**
      * Sets the value of the clazz property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setClazz(String value) {
         this.clazz = value;
@@ -104,15 +95,14 @@ public void setClazz(String value) {
     /**
      * Gets the value of the airwireshidden property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAirwireshidden() {
         if (airwireshidden == null) {
             return "no";
-        } else {
+        }
+        else {
             return airwireshidden;
         }
     }
@@ -120,10 +110,8 @@ public String getAirwireshidden() {
     /**
      * Sets the value of the airwireshidden property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAirwireshidden(String value) {
         this.airwireshidden = value;
@@ -133,24 +121,21 @@ public void setAirwireshidden(String value) {
      * Gets the value of the contactrefOrPolygonOrWireOrVia property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the contactrefOrPolygonOrWireOrVia property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the contactrefOrPolygonOrWireOrVia property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getContactrefOrPolygonOrWireOrVia().add(newItem);
+     * getContactrefOrPolygonOrWireOrVia().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Contactref }
-     * {@link Polygon }
-     * {@link Wire }
-     * {@link Via }
+     * Objects of the following type(s) are allowed in the list {@link Contactref } {@link Polygon }
+     * {@link Wire } {@link Via }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Signals.java b/src/main/java/org/openpnp/model/eagle/xml/Signals.java
index 9005b345e5..ab147b5e2f 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Signals.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Signals.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "signal"
-})
+@XmlType(name = "", propOrder = {"signal"})
 @XmlRootElement(name = "signals")
 public class Signals {
 
@@ -32,21 +32,20 @@
      * Gets the value of the signal property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the signal property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the signal property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSignal().add(newItem);
+     * getSignal().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Signal }
+     * Objects of the following type(s) are allowed in the list {@link Signal }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Smd.java b/src/main/java/org/openpnp/model/eagle/xml/Smd.java
index 03f50cf6a0..8591e7434b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Smd.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Smd.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -63,10 +64,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -75,10 +74,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -87,10 +84,8 @@ public void setName(String value) {
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -99,10 +94,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -111,10 +104,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -123,10 +114,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -135,10 +124,8 @@ public void setY(String value) {
     /**
      * Gets the value of the dx property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDx() {
         return dx;
@@ -147,10 +134,8 @@ public String getDx() {
     /**
      * Sets the value of the dx property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDx(String value) {
         this.dx = value;
@@ -159,10 +144,8 @@ public void setDx(String value) {
     /**
      * Gets the value of the dy property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDy() {
         return dy;
@@ -171,10 +154,8 @@ public String getDy() {
     /**
      * Sets the value of the dy property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDy(String value) {
         this.dy = value;
@@ -183,10 +164,8 @@ public void setDy(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -195,10 +174,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -207,15 +184,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the roundness property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRoundness() {
         if (roundness == null) {
             return "0";
-        } else {
+        }
+        else {
             return roundness;
         }
     }
@@ -223,10 +199,8 @@ public String getRoundness() {
     /**
      * Sets the value of the roundness property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRoundness(String value) {
         this.roundness = value;
@@ -235,15 +209,14 @@ public void setRoundness(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -251,10 +224,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -263,15 +234,14 @@ public void setRot(String value) {
     /**
      * Gets the value of the stop property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getStop() {
         if (stop == null) {
             return "yes";
-        } else {
+        }
+        else {
             return stop;
         }
     }
@@ -279,10 +249,8 @@ public String getStop() {
     /**
      * Sets the value of the stop property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setStop(String value) {
         this.stop = value;
@@ -291,15 +259,14 @@ public void setStop(String value) {
     /**
      * Gets the value of the thermals property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getThermals() {
         if (thermals == null) {
             return "yes";
-        } else {
+        }
+        else {
             return thermals;
         }
     }
@@ -307,10 +274,8 @@ public String getThermals() {
     /**
      * Sets the value of the thermals property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setThermals(String value) {
         this.thermals = value;
@@ -319,15 +284,14 @@ public void setThermals(String value) {
     /**
      * Gets the value of the cream property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCream() {
         if (cream == null) {
             return "yes";
-        } else {
+        }
+        else {
             return cream;
         }
     }
@@ -335,10 +299,8 @@ public String getCream() {
     /**
      * Sets the value of the cream property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCream(String value) {
         this.cream = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Symbol.java b/src/main/java/org/openpnp/model/eagle/xml/Symbol.java
index dfdc3a0194..e845cc9f04 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Symbol.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Symbol.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -25,10 +27,8 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "description",
-    "polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame"
-})
+@XmlType(name = "", propOrder = {"description",
+        "polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame"})
 @XmlRootElement(name = "symbol")
 public class Symbol {
 
@@ -36,25 +36,21 @@
     @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
     protected String name;
     protected Description description;
-    @XmlElements({
-        @XmlElement(name = "polygon", type = Polygon.class),
-        @XmlElement(name = "wire", type = Wire.class),
-        @XmlElement(name = "text", type = Text.class),
-        @XmlElement(name = "dimension", type = Dimension.class),
-        @XmlElement(name = "pin", type = Pin.class),
-        @XmlElement(name = "circle", type = Circle.class),
-        @XmlElement(name = "rectangle", type = Rectangle.class),
-        @XmlElement(name = "frame", type = Frame.class)
-    })
+    @XmlElements({@XmlElement(name = "polygon", type = Polygon.class),
+            @XmlElement(name = "wire", type = Wire.class),
+            @XmlElement(name = "text", type = Text.class),
+            @XmlElement(name = "dimension", type = Dimension.class),
+            @XmlElement(name = "pin", type = Pin.class),
+            @XmlElement(name = "circle", type = Circle.class),
+            @XmlElement(name = "rectangle", type = Rectangle.class),
+            @XmlElement(name = "frame", type = Frame.class)})
     protected List<Object> polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame;
 
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -63,10 +59,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -75,10 +69,8 @@ public void setName(String value) {
     /**
      * Gets the value of the description property.
      * 
-     * @return
-     *     possible object is
-     *     {@link Description }
-     *     
+     * @return possible object is {@link Description }
+     * 
      */
     public Description getDescription() {
         return description;
@@ -87,10 +79,8 @@ public Description getDescription() {
     /**
      * Sets the value of the description property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link Description }
-     *     
+     * @param value allowed object is {@link Description }
+     * 
      */
     public void setDescription(Description value) {
         this.description = value;
@@ -100,28 +90,23 @@ public void setDescription(Description value) {
      * Gets the value of the polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the
+     * polygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getPolygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame().add(newItem);
+     * getPolygonOrWireOrTextOrDimensionOrPinOrCircleOrRectangleOrFrame().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Polygon }
-     * {@link Wire }
-     * {@link Text }
-     * {@link Dimension }
-     * {@link Pin }
-     * {@link Circle }
-     * {@link Rectangle }
-     * {@link Frame }
+     * Objects of the following type(s) are allowed in the list {@link Polygon } {@link Wire }
+     * {@link Text } {@link Dimension } {@link Pin } {@link Circle } {@link Rectangle } {@link Frame
+     * }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Symbols.java b/src/main/java/org/openpnp/model/eagle/xml/Symbols.java
index ef222b70d8..93f4fd033a 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Symbols.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Symbols.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "symbol"
-})
+@XmlType(name = "", propOrder = {"symbol"})
 @XmlRootElement(name = "symbols")
 public class Symbols {
 
@@ -32,21 +32,20 @@
      * Gets the value of the symbol property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the symbol property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the symbol property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getSymbol().add(newItem);
+     * getSymbol().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Symbol }
+     * Objects of the following type(s) are allowed in the list {@link Symbol }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Technologies.java b/src/main/java/org/openpnp/model/eagle/xml/Technologies.java
index 092cf0cd36..316a147b7b 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Technologies.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Technologies.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "technology"
-})
+@XmlType(name = "", propOrder = {"technology"})
 @XmlRootElement(name = "technologies")
 public class Technologies {
 
@@ -32,21 +32,20 @@
      * Gets the value of the technology property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the technology property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the technology property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getTechnology().add(newItem);
+     * getTechnology().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Technology }
+     * Objects of the following type(s) are allowed in the list {@link Technology }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Technology.java b/src/main/java/org/openpnp/model/eagle/xml/Technology.java
index 899ae92363..374df82ede 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Technology.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Technology.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlAttribute;
@@ -23,9 +25,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "attribute"
-})
+@XmlType(name = "", propOrder = {"attribute"})
 @XmlRootElement(name = "technology")
 public class Technology {
 
@@ -37,10 +37,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -49,10 +47,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -62,21 +58,20 @@ public void setName(String value) {
      * Gets the value of the attribute property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the attribute property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the attribute property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getAttribute().add(newItem);
+     * getAttribute().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Attribute }
+     * Objects of the following type(s) are allowed in the list {@link Attribute }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Text.java b/src/main/java/org/openpnp/model/eagle/xml/Text.java
index 340c36f784..3c15db1dff 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Text.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Text.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -23,9 +24,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "value"
-})
+@XmlType(name = "", propOrder = {"value"})
 @XmlRootElement(name = "text")
 public class Text {
 
@@ -62,10 +61,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -74,10 +71,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -86,10 +81,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -98,10 +91,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -110,10 +101,8 @@ public void setY(String value) {
     /**
      * Gets the value of the size property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getSize() {
         return size;
@@ -122,10 +111,8 @@ public String getSize() {
     /**
      * Sets the value of the size property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setSize(String value) {
         this.size = value;
@@ -134,10 +121,8 @@ public void setSize(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -146,10 +131,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -158,15 +141,14 @@ public void setLayer(String value) {
     /**
      * Gets the value of the font property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getFont() {
         if (font == null) {
             return "proportional";
-        } else {
+        }
+        else {
             return font;
         }
     }
@@ -174,10 +156,8 @@ public String getFont() {
     /**
      * Sets the value of the font property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setFont(String value) {
         this.font = value;
@@ -186,15 +166,14 @@ public void setFont(String value) {
     /**
      * Gets the value of the ratio property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRatio() {
         if (ratio == null) {
             return "8";
-        } else {
+        }
+        else {
             return ratio;
         }
     }
@@ -202,10 +181,8 @@ public String getRatio() {
     /**
      * Sets the value of the ratio property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRatio(String value) {
         this.ratio = value;
@@ -214,15 +191,14 @@ public void setRatio(String value) {
     /**
      * Gets the value of the rot property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getRot() {
         if (rot == null) {
             return "R0";
-        } else {
+        }
+        else {
             return rot;
         }
     }
@@ -230,10 +206,8 @@ public String getRot() {
     /**
      * Sets the value of the rot property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setRot(String value) {
         this.rot = value;
@@ -242,15 +216,14 @@ public void setRot(String value) {
     /**
      * Gets the value of the align property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAlign() {
         if (align == null) {
             return "bottom-left";
-        } else {
+        }
+        else {
             return align;
         }
     }
@@ -258,10 +231,8 @@ public String getAlign() {
     /**
      * Sets the value of the align property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAlign(String value) {
         this.align = value;
@@ -270,15 +241,14 @@ public void setAlign(String value) {
     /**
      * Gets the value of the distance property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDistance() {
         if (distance == null) {
             return "50";
-        } else {
+        }
+        else {
             return distance;
         }
     }
@@ -286,10 +256,8 @@ public String getDistance() {
     /**
      * Sets the value of the distance property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDistance(String value) {
         this.distance = value;
@@ -298,10 +266,8 @@ public void setDistance(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getvalue() {
         return value;
@@ -310,10 +276,8 @@ public String getvalue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setvalue(String value) {
         this.value = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Variant.java b/src/main/java/org/openpnp/model/eagle/xml/Variant.java
index 29f42ec924..cd40caef72 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Variant.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Variant.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -42,10 +43,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -54,10 +53,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -66,15 +63,14 @@ public void setName(String value) {
     /**
      * Gets the value of the populate property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getPopulate() {
         if (populate == null) {
             return "yes";
-        } else {
+        }
+        else {
             return populate;
         }
     }
@@ -82,10 +78,8 @@ public String getPopulate() {
     /**
      * Sets the value of the populate property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setPopulate(String value) {
         this.populate = value;
@@ -94,10 +88,8 @@ public void setPopulate(String value) {
     /**
      * Gets the value of the value property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getValue() {
         return value;
@@ -106,10 +98,8 @@ public String getValue() {
     /**
      * Sets the value of the value property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setValue(String value) {
         this.value = value;
@@ -118,10 +108,8 @@ public void setValue(String value) {
     /**
      * Gets the value of the technology property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getTechnology() {
         return technology;
@@ -130,10 +118,8 @@ public String getTechnology() {
     /**
      * Sets the value of the technology property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setTechnology(String value) {
         this.technology = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Variantdef.java b/src/main/java/org/openpnp/model/eagle/xml/Variantdef.java
index fe80424130..6734f12359 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Variantdef.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Variantdef.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -36,10 +37,8 @@
     /**
      * Gets the value of the name property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getName() {
         return name;
@@ -48,10 +47,8 @@ public String getName() {
     /**
      * Sets the value of the name property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setName(String value) {
         this.name = value;
@@ -60,15 +57,14 @@ public void setName(String value) {
     /**
      * Gets the value of the current property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCurrent() {
         if (current == null) {
             return "no";
-        } else {
+        }
+        else {
             return current;
         }
     }
@@ -76,10 +72,8 @@ public String getCurrent() {
     /**
      * Sets the value of the current property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCurrent(String value) {
         this.current = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Variantdefs.java b/src/main/java/org/openpnp/model/eagle/xml/Variantdefs.java
index c7fb5cb96a..45ac47369f 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Variantdefs.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Variantdefs.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -10,6 +11,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
@@ -20,9 +22,7 @@
  * 
  */
 @XmlAccessorType(XmlAccessType.FIELD)
-@XmlType(name = "", propOrder = {
-    "variantdef"
-})
+@XmlType(name = "", propOrder = {"variantdef"})
 @XmlRootElement(name = "variantdefs")
 public class Variantdefs {
 
@@ -32,21 +32,20 @@
      * Gets the value of the variantdef property.
      * 
      * <p>
-     * This accessor method returns a reference to the live list,
-     * not a snapshot. Therefore any modification you make to the
-     * returned list will be present inside the JAXB object.
-     * This is why there is not a <CODE>set</CODE> method for the variantdef property.
+     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
+     * modification you make to the returned list will be present inside the JAXB object. This is
+     * why there is not a <CODE>set</CODE> method for the variantdef property.
      * 
      * <p>
      * For example, to add a new item, do as follows:
+     * 
      * <pre>
-     *    getVariantdef().add(newItem);
+     * getVariantdef().add(newItem);
      * </pre>
      * 
      * 
      * <p>
-     * Objects of the following type(s) are allowed in the list
-     * {@link Variantdef }
+     * Objects of the following type(s) are allowed in the list {@link Variantdef }
      * 
      * 
      */
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Vertex.java b/src/main/java/org/openpnp/model/eagle/xml/Vertex.java
index 59878958b0..f1af31e031 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Vertex.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Vertex.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -38,10 +39,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -50,10 +49,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -62,10 +59,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -74,10 +69,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -86,15 +79,14 @@ public void setY(String value) {
     /**
      * Gets the value of the curve property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCurve() {
         if (curve == null) {
             return "0";
-        } else {
+        }
+        else {
             return curve;
         }
     }
@@ -102,10 +94,8 @@ public String getCurve() {
     /**
      * Sets the value of the curve property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCurve(String value) {
         this.curve = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Via.java b/src/main/java/org/openpnp/model/eagle/xml/Via.java
index bdd013a676..f0850b6026 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Via.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Via.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -51,10 +52,8 @@
     /**
      * Gets the value of the x property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX() {
         return x;
@@ -63,10 +62,8 @@ public String getX() {
     /**
      * Sets the value of the x property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX(String value) {
         this.x = value;
@@ -75,10 +72,8 @@ public void setX(String value) {
     /**
      * Gets the value of the y property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY() {
         return y;
@@ -87,10 +82,8 @@ public String getY() {
     /**
      * Sets the value of the y property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY(String value) {
         this.y = value;
@@ -99,10 +92,8 @@ public void setY(String value) {
     /**
      * Gets the value of the extent property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getExtent() {
         return extent;
@@ -111,10 +102,8 @@ public String getExtent() {
     /**
      * Sets the value of the extent property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setExtent(String value) {
         this.extent = value;
@@ -123,10 +112,8 @@ public void setExtent(String value) {
     /**
      * Gets the value of the drill property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDrill() {
         return drill;
@@ -135,10 +122,8 @@ public String getDrill() {
     /**
      * Sets the value of the drill property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDrill(String value) {
         this.drill = value;
@@ -147,15 +132,14 @@ public void setDrill(String value) {
     /**
      * Gets the value of the diameter property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getDiameter() {
         if (diameter == null) {
             return "0";
-        } else {
+        }
+        else {
             return diameter;
         }
     }
@@ -163,10 +147,8 @@ public String getDiameter() {
     /**
      * Sets the value of the diameter property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setDiameter(String value) {
         this.diameter = value;
@@ -175,15 +157,14 @@ public void setDiameter(String value) {
     /**
      * Gets the value of the shape property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getShape() {
         if (shape == null) {
             return "round";
-        } else {
+        }
+        else {
             return shape;
         }
     }
@@ -191,10 +172,8 @@ public String getShape() {
     /**
      * Sets the value of the shape property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setShape(String value) {
         this.shape = value;
@@ -203,15 +182,14 @@ public void setShape(String value) {
     /**
      * Gets the value of the alwaysstop property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getAlwaysstop() {
         if (alwaysstop == null) {
             return "no";
-        } else {
+        }
+        else {
             return alwaysstop;
         }
     }
@@ -219,10 +197,8 @@ public String getAlwaysstop() {
     /**
      * Sets the value of the alwaysstop property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setAlwaysstop(String value) {
         this.alwaysstop = value;
diff --git a/src/main/java/org/openpnp/model/eagle/xml/Wire.java b/src/main/java/org/openpnp/model/eagle/xml/Wire.java
index cba3f1a233..0c22a8ea39 100755
--- a/src/main/java/org/openpnp/model/eagle/xml/Wire.java
+++ b/src/main/java/org/openpnp/model/eagle/xml/Wire.java
@@ -1,8 +1,9 @@
 //
-// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
-// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
-// Any modifications to this file will be lost upon recompilation of the source schema. 
-// Generated on: 2014.10.23 at 08:50:01 AM PDT 
+// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
+// Implementation, v2.2.8-b130911.1802
+// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
+// Any modifications to this file will be lost upon recompilation of the source schema.
+// Generated on: 2014.10.23 at 08:50:01 AM PDT
 //
 
 
@@ -60,10 +61,8 @@
     /**
      * Gets the value of the x1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX1() {
         return x1;
@@ -72,10 +71,8 @@ public String getX1() {
     /**
      * Sets the value of the x1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX1(String value) {
         this.x1 = value;
@@ -84,10 +81,8 @@ public void setX1(String value) {
     /**
      * Gets the value of the y1 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY1() {
         return y1;
@@ -96,10 +91,8 @@ public String getY1() {
     /**
      * Sets the value of the y1 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY1(String value) {
         this.y1 = value;
@@ -108,10 +101,8 @@ public void setY1(String value) {
     /**
      * Gets the value of the x2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getX2() {
         return x2;
@@ -120,10 +111,8 @@ public String getX2() {
     /**
      * Sets the value of the x2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setX2(String value) {
         this.x2 = value;
@@ -132,10 +121,8 @@ public void setX2(String value) {
     /**
      * Gets the value of the y2 property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getY2() {
         return y2;
@@ -144,10 +131,8 @@ public String getY2() {
     /**
      * Sets the value of the y2 property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setY2(String value) {
         this.y2 = value;
@@ -156,10 +141,8 @@ public void setY2(String value) {
     /**
      * Gets the value of the width property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getWidth() {
         return width;
@@ -168,10 +151,8 @@ public String getWidth() {
     /**
      * Sets the value of the width property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setWidth(String value) {
         this.width = value;
@@ -180,10 +161,8 @@ public void setWidth(String value) {
     /**
      * Gets the value of the layer property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getLayer() {
         return layer;
@@ -192,10 +171,8 @@ public String getLayer() {
     /**
      * Sets the value of the layer property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setLayer(String value) {
         this.layer = value;
@@ -204,10 +181,8 @@ public void setLayer(String value) {
     /**
      * Gets the value of the extent property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getExtent() {
         return extent;
@@ -216,10 +191,8 @@ public String getExtent() {
     /**
      * Sets the value of the extent property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setExtent(String value) {
         this.extent = value;
@@ -228,15 +201,14 @@ public void setExtent(String value) {
     /**
      * Gets the value of the style property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getStyle() {
         if (style == null) {
             return "continuous";
-        } else {
+        }
+        else {
             return style;
         }
     }
@@ -244,10 +216,8 @@ public String getStyle() {
     /**
      * Sets the value of the style property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setStyle(String value) {
         this.style = value;
@@ -256,15 +226,14 @@ public void setStyle(String value) {
     /**
      * Gets the value of the curve property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCurve() {
         if (curve == null) {
             return "0";
-        } else {
+        }
+        else {
             return curve;
         }
     }
@@ -272,10 +241,8 @@ public String getCurve() {
     /**
      * Sets the value of the curve property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCurve(String value) {
         this.curve = value;
@@ -284,15 +251,14 @@ public void setCurve(String value) {
     /**
      * Gets the value of the cap property.
      * 
-     * @return
-     *     possible object is
-     *     {@link String }
-     *     
+     * @return possible object is {@link String }
+     * 
      */
     public String getCap() {
         if (cap == null) {
             return "round";
-        } else {
+        }
+        else {
             return cap;
         }
     }
@@ -300,10 +266,8 @@ public String getCap() {
     /**
      * Sets the value of the cap property.
      * 
-     * @param value
-     *     allowed object is
-     *     {@link String }
-     *     
+     * @param value allowed object is {@link String }
+     * 
      */
     public void setCap(String value) {
         this.cap = value;
diff --git a/src/main/java/org/openpnp/planner/AbstractJobPlanner.java b/src/main/java/org/openpnp/planner/AbstractJobPlanner.java
index cfe541c8f9..9b6b407659 100755
--- a/src/main/java/org/openpnp/planner/AbstractJobPlanner.java
+++ b/src/main/java/org/openpnp/planner/AbstractJobPlanner.java
@@ -5,7 +5,7 @@
 
 public abstract class AbstractJobPlanner implements JobPlanner {
     protected Job job;
-    
+
     @Override
     public void setJob(Job job) {
         this.job = job;
diff --git a/src/main/java/org/openpnp/planner/SimpleJobPlanner.java b/src/main/java/org/openpnp/planner/SimpleJobPlanner.java
index 47754ea55f..3fc08e533a 100755
--- a/src/main/java/org/openpnp/planner/SimpleJobPlanner.java
+++ b/src/main/java/org/openpnp/planner/SimpleJobPlanner.java
@@ -25,22 +25,22 @@
 
 public class SimpleJobPlanner extends AbstractJobPlanner {
     private final static Logger logger = LoggerFactory.getLogger(SimpleJobPlanner.class);
-    
+
     @SuppressWarnings("unused")
     @Attribute(required = false)
     private String placeHolder;
-    
+
     protected Set<PlacementSolution> solutions = new LinkedHashSet<>();
-    
+
     @Override
     public void setJob(Job job) {
         super.setJob(job);
         solutions.clear();
         for (BoardLocation boardLocation : job.getBoardLocations()) {
-        	if (!boardLocation.isEnabled()) {
-        		continue;
-        	}
-        	
+            if (!boardLocation.isEnabled()) {
+                continue;
+            }
+
             for (Placement placement : boardLocation.getBoard().getPlacements()) {
                 if (placement.getType() != Type.Place) {
                     continue;
@@ -49,25 +49,24 @@ public void setJob(Job job) {
                 if (placement.getSide() != boardLocation.getSide()) {
                     continue;
                 }
-                
-                solutions.add(new PlacementSolution(placement, boardLocation, null, null, null, null));
+
+                solutions.add(
+                        new PlacementSolution(placement, boardLocation, null, null, null, null));
             }
         }
-        
+
         logger.debug("Planned {} solutions", solutions.size());
     }
 
     /**
-     * For N nozzles, create a list of every possible remaining solutions
-     * along with a weight. Weight is a cost of 0 or more with things like
-     * a nozzle change increasing the weight.
-     * Once all solutions are identified. Sort each list by weight and take the
-     * N lowest weighted solutions that do not conflict with each other.
+     * For N nozzles, create a list of every possible remaining solutions along with a weight.
+     * Weight is a cost of 0 or more with things like a nozzle change increasing the weight. Once
+     * all solutions are identified. Sort each list by weight and take the N lowest weighted
+     * solutions that do not conflict with each other.
      *
-     * TODO: Is there a situation where the order in which we take the weighted
-     * solutions from their lists would cause successive nozzles to have to
-     * use less optimal solutions? I feel like this is a possible issue but
-     * I haven't been able to come up with an example case.
+     * TODO: Is there a situation where the order in which we take the weighted solutions from their
+     * lists would cause successive nozzles to have to use less optimal solutions? I feel like this
+     * is a possible issue but I haven't been able to come up with an example case.
      */
     @Override
     public synchronized Set<PlacementSolution> getNextPlacementSolutions(Head head) {
@@ -94,7 +93,7 @@ public void setJob(Job job) {
         }
         return results.size() > 0 ? results : null;
     }
-    
+
     protected List<WeightedPlacementSolution> getWeightedSolutions(Machine machine, Nozzle nozzle) {
         List<WeightedPlacementSolution> weightedSolutions = new ArrayList<>();
         for (PlacementSolution solution : solutions) {
@@ -107,12 +106,8 @@ public void setJob(Job job) {
             for (NozzleTip nozzleTip : compatibleNozzleTips) {
                 for (Feeder feeder : compatibleFeeders) {
                     WeightedPlacementSolution weightedSolution = new WeightedPlacementSolution(
-                            solution.placement,
-                            solution.boardLocation,
-                            nozzle.getHead(),
-                            nozzle,
-                            nozzleTip,
-                            feeder);
+                            solution.placement, solution.boardLocation, nozzle.getHead(), nozzle,
+                            nozzleTip, feeder);
                     weightedSolution.weight = 1;
                     weightedSolution.originalSolution = solution;
                     if (nozzle.getNozzleTip() != nozzleTip) {
@@ -125,7 +120,7 @@ public void setJob(Job job) {
         Collections.sort(weightedSolutions, weightComparator);
         return weightedSolutions;
     }
-    
+
     private static Set<NozzleTip> getCompatibleNozzleTips(Nozzle nozzle, Part part) {
         Set<NozzleTip> nozzleTips = new HashSet<>();
         for (NozzleTip nozzleTip : nozzle.getNozzleTips()) {
@@ -135,7 +130,7 @@ public void setJob(Job job) {
         }
         return nozzleTips;
     }
-    
+
     private static Set<Feeder> getCompatibleFeeders(Machine machine, Nozzle nozzle, Part part) {
         Set<Feeder> feeders = new HashSet<>();
         for (Feeder feeder : machine.getFeeders()) {
@@ -145,21 +140,21 @@ public void setJob(Job job) {
         }
         return feeders;
     }
-    
-    static Comparator<WeightedPlacementSolution> weightComparator = new Comparator<WeightedPlacementSolution>() {
-        @Override
-        public int compare(WeightedPlacementSolution o1, WeightedPlacementSolution o2) {
-            return Double.compare(o1.weight, o2.weight);
-        }
-    };
+
+    static Comparator<WeightedPlacementSolution> weightComparator =
+            new Comparator<WeightedPlacementSolution>() {
+                @Override
+                public int compare(WeightedPlacementSolution o1, WeightedPlacementSolution o2) {
+                    return Double.compare(o1.weight, o2.weight);
+                }
+            };
 
     static class WeightedPlacementSolution extends PlacementSolution {
         public double weight;
         public PlacementSolution originalSolution;
-        
-        public WeightedPlacementSolution(Placement placement,
-                BoardLocation boardLocation, Head head, Nozzle nozzle,
-                NozzleTip nozzleTip, Feeder feeder) {
+
+        public WeightedPlacementSolution(Placement placement, BoardLocation boardLocation,
+                Head head, Nozzle nozzle, NozzleTip nozzleTip, Feeder feeder) {
             super(placement, boardLocation, head, nozzle, nozzleTip, feeder);
         }
     }
diff --git a/src/main/java/org/openpnp/spi/Actuator.java b/src/main/java/org/openpnp/spi/Actuator.java
index 567a24d7cf..d641d6a386 100755
--- a/src/main/java/org/openpnp/spi/Actuator.java
+++ b/src/main/java/org/openpnp/spi/Actuator.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.spi;
 
@@ -25,24 +23,26 @@
 import org.openpnp.model.Named;
 
 /**
- * Defines a simple interface to some type of device that can be actuated
- * on the machine or on a head. This is a minimal interface and it is
- * expected that concrete implementations may have many other capabilities
- * exposed in their specific implementations. 
+ * Defines a simple interface to some type of device that can be actuated on the machine or on a
+ * head. This is a minimal interface and it is expected that concrete implementations may have many
+ * other capabilities exposed in their specific implementations.
  */
-public interface Actuator extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
-	/**
-	 * Turns the Actuator on or off.
-	 * @param on
-	 * @throws Exception
-	 */
-	public void actuate(boolean on) throws Exception;
-	
-	/**
-	 * Provides the actuator with a double value to which it can respond
-	 * in an implementation dependent manner.
-	 * @param value
-	 * @throws Exception
-	 */
-	public void actuate(double value) throws Exception;
+public interface Actuator
+        extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
+    /**
+     * Turns the Actuator on or off.
+     * 
+     * @param on
+     * @throws Exception
+     */
+    public void actuate(boolean on) throws Exception;
+
+    /**
+     * Provides the actuator with a double value to which it can respond in an implementation
+     * dependent manner.
+     * 
+     * @param value
+     * @throws Exception
+     */
+    public void actuate(double value) throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/Camera.java b/src/main/java/org/openpnp/spi/Camera.java
index 7f13284458..b79fe1b764 100755
--- a/src/main/java/org/openpnp/spi/Camera.java
+++ b/src/main/java/org/openpnp/spi/Camera.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
@@ -30,84 +28,94 @@
 import org.openpnp.model.Named;
 
 /**
- * Represents a Camera attached to the system and allows a caller to retrieve
- * images from it. 
+ * Represents a Camera attached to the system and allows a caller to retrieve images from it.
  */
-public interface Camera extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder, Closeable {
-	public enum Looking {
-		Down,
-		Up
-	}
-	
-	/**
-	 * Get the direction the Camera is looking. 
-	 * @return
-	 */
-	public Looking getLooking();
-	
-	public void setLooking(Looking looking);
-	
-	/**
-	 * The number of X and Y units per pixel this camera shows when in perfect focus.
-	 * Location isn't a great datatype for this, but it gets the job done.
-	 * @return
-	 */
-	public Location getUnitsPerPixel();
-	
-	public void setUnitsPerPixel(Location unitsPerPixel);
-	
-	/**
-	 * Immediately captures an image from the camera and returns it in it's native format.
-	 * @return
-	 */
-	public BufferedImage capture();
-	
-	/**
-	 * Same as capture(), but waits the settle time before capturing.
-	 * @return
-	 */
-	public BufferedImage settleAndCapture();
-	
-	/**
-	 * Registers a listener to receive continuous images from the camera at a rate less than
-	 * or equal to maximumFps images per second.
-	 * @param listener
-	 * @param maximumFps
-	 */
-	public void startContinuousCapture(CameraListener listener, int maximumFps);
-	
-	/**
-	 * Requests that the continuous capture be stopped for the previously registered listener. If the
-	 * Camera has other listeners they should still receive updates.
-	 * @param listener
-	 */
-	public void stopContinuousCapture(CameraListener listener);
-	
-	public void setVisionProvider(VisionProvider visionProvider);
-	
-	/**
-	 * Get the VisionProvider that is attached to this Camera, if any.
-	 * @return
-	 */
-	public VisionProvider getVisionProvider();
-	
-	/**
-	 * Get the width of images in pixels that will be returned from this Camera.
-	 * @return
-	 */
-	public int getWidth();
-	
-	/**
-	 * Get the height of images in pixels that will be returned from this Camera.
-	 * @return
-	 */
-	public int getHeight();
-	
-	/**
-	 * Get the time in milliseconds that the Camera should be allowed to settle before
-	 * images are captured for vision operations.
-	 * @return
-	 */
-	public long getSettleTimeMs();
-	public void setSettleTimeMs(long settleTimeMs);
+public interface Camera extends Identifiable, Named, HeadMountable, WizardConfigurable,
+        PropertySheetHolder, Closeable {
+    public enum Looking {
+        Down, Up
+    }
+
+    /**
+     * Get the direction the Camera is looking.
+     * 
+     * @return
+     */
+    public Looking getLooking();
+
+    public void setLooking(Looking looking);
+
+    /**
+     * The number of X and Y units per pixel this camera shows when in perfect focus. Location isn't
+     * a great datatype for this, but it gets the job done.
+     * 
+     * @return
+     */
+    public Location getUnitsPerPixel();
+
+    public void setUnitsPerPixel(Location unitsPerPixel);
+
+    /**
+     * Immediately captures an image from the camera and returns it in it's native format.
+     * 
+     * @return
+     */
+    public BufferedImage capture();
+
+    /**
+     * Same as capture(), but waits the settle time before capturing.
+     * 
+     * @return
+     */
+    public BufferedImage settleAndCapture();
+
+    /**
+     * Registers a listener to receive continuous images from the camera at a rate less than or
+     * equal to maximumFps images per second.
+     * 
+     * @param listener
+     * @param maximumFps
+     */
+    public void startContinuousCapture(CameraListener listener, int maximumFps);
+
+    /**
+     * Requests that the continuous capture be stopped for the previously registered listener. If
+     * the Camera has other listeners they should still receive updates.
+     * 
+     * @param listener
+     */
+    public void stopContinuousCapture(CameraListener listener);
+
+    public void setVisionProvider(VisionProvider visionProvider);
+
+    /**
+     * Get the VisionProvider that is attached to this Camera, if any.
+     * 
+     * @return
+     */
+    public VisionProvider getVisionProvider();
+
+    /**
+     * Get the width of images in pixels that will be returned from this Camera.
+     * 
+     * @return
+     */
+    public int getWidth();
+
+    /**
+     * Get the height of images in pixels that will be returned from this Camera.
+     * 
+     * @return
+     */
+    public int getHeight();
+
+    /**
+     * Get the time in milliseconds that the Camera should be allowed to settle before images are
+     * captured for vision operations.
+     * 
+     * @return
+     */
+    public long getSettleTimeMs();
+
+    public void setSettleTimeMs(long settleTimeMs);
 }
diff --git a/src/main/java/org/openpnp/spi/Feeder.java b/src/main/java/org/openpnp/spi/Feeder.java
index 62f81fc1e0..91388ceb77 100755
--- a/src/main/java/org/openpnp/spi/Feeder.java
+++ b/src/main/java/org/openpnp/spi/Feeder.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
@@ -29,48 +27,51 @@
 
 
 /**
- * A Feeder is an abstraction that represents any type of part source. 
- * It can be a tape and reel feeder, a tray handler, a single part in a 
- * specific location or anything else that can be used as a pick source.
+ * A Feeder is an abstraction that represents any type of part source. It can be a tape and reel
+ * feeder, a tray handler, a single part in a specific location or anything else that can be used as
+ * a pick source.
  */
 public interface Feeder extends Identifiable, Named, WizardConfigurable, PropertySheetHolder {
     /**
-     * Return true is the Feeder is currently enabled and can be considered
-     * in Job planning.
+     * Return true is the Feeder is currently enabled and can be considered in Job planning.
+     * 
+     * @return
+     */
+    public boolean isEnabled();
+
+    public void setEnabled(boolean enabled);
+
+    /**
+     * Get the Part that is loaded into this Feeder.
+     * 
+     * @return
+     */
+    public Part getPart();
+
+    /**
+     * Set the Part that is loaded into this Feeder.
+     */
+    public void setPart(Part part);
+
+    /**
+     * Gets the Location from which the currently available Part should be picked from. This value
+     * may not be valid until after a feed has been performed for Feeders who update the pick
+     * location.
+     * 
      * @return
      */
-	public boolean isEnabled();
-	
-	public void setEnabled(boolean enabled);
+    public Location getPickLocation() throws Exception;
 
-	/**
-	 * Get the Part that is loaded into this Feeder.
-	 * @return
-	 */
-	public Part getPart();
-	
-	/**
-	 * Set the Part that is loaded into this Feeder.
-	 */
-	public void setPart(Part part);
-	
-	/**
-	 * Gets the Location from which the currently available Part should be
-	 * picked from. This value may not be valid until after a feed has been
-	 * performed for Feeders who update the pick location.
-	 * @return
-	 */
-	public Location getPickLocation() throws Exception;
-	
-	/**
-	 * Commands the Feeder to do anything it needs to do to prepare the part
-	 * to be picked by the specified Nozzle. If the Feeder requires Head
-	 * interaction to feed it will perform those operations during this call.
-	 * @param nozzle The Nozzle to be used for picking after the feed is
-	 * completed. The Feeder may use this Nozzle to determine which Head,
-	 * and therefore which Actuators and Cameras it can use for assistance. 
-	 * @return The Location where the fed part can be picked from.
-	 * @throws Exception
-	 */
-	public void feed(Nozzle nozzle) throws Exception;
+    /**
+     * Commands the Feeder to do anything it needs to do to prepare the part to be picked by the
+     * specified Nozzle. If the Feeder requires Head interaction to feed it will perform those
+     * operations during this call.
+     * 
+     * @param nozzle The Nozzle to be used for picking after the feed is completed. The Feeder may
+     *        use this Nozzle to determine which Head, and therefore which Actuators and Cameras it
+     *        can use for assistance.
+     * @return The Location where the fed part can be picked from.
+     * @throws Exception
+     */
+    public void feed(Nozzle nozzle) throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/Head.java b/src/main/java/org/openpnp/spi/Head.java
index fd6d80874c..be2050ef37 100755
--- a/src/main/java/org/openpnp/spi/Head.java
+++ b/src/main/java/org/openpnp/spi/Head.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
@@ -28,74 +26,78 @@
 
 
 /**
- * A Head is a movable group of components attached to a Machine. Components
- * which can be attached consist of Nozzles, Actuators and Cameras. A Head
- * itself is not directly movable, but can be moved by moving any one of it's
- * components. When any attached component is moved in (at least) X or Y, it is
- * expected that all components attached to the Head also move in the same
- * axes.
+ * A Head is a movable group of components attached to a Machine. Components which can be attached
+ * consist of Nozzles, Actuators and Cameras. A Head itself is not directly movable, but can be
+ * moved by moving any one of it's components. When any attached component is moved in (at least) X
+ * or Y, it is expected that all components attached to the Head also move in the same axes.
  */
 public interface Head extends Identifiable, Named, WizardConfigurable, PropertySheetHolder {
     /**
      * Get a list of Nozzles that are attached to this head.
+     * 
      * @return
      */
     public List<Nozzle> getNozzles();
-    
+
     /**
      * Get the Nozzle attached to this Head that has the specified id.
+     * 
      * @param id
      * @return
      */
     public Nozzle getNozzle(String id);
-    
-	/**
-	 * Get a list of Actuators that are attached to this Head.
-	 * @return
-	 */
-	public List<Actuator> getActuators();
-	
-	/**
-	 * Get the Actuator attached to this Head that has the specified id.
-	 * @param id
-	 * @return
-	 */
-	public Actuator getActuator(String id);
-	
-	public Actuator getActuatorByName(String name);
-	
-	/**
-	 * Get a list of Cameras that are attached to this Head.
-	 * @return
-	 */
-	public List<Camera> getCameras();
-	
-	/**
-	 * Get the Camera attached to this Head that has the specified id.
-	 * @param id
-	 * @return
-	 */
-	public Camera getCamera(String id);
-	
+
+    /**
+     * Get a list of Actuators that are attached to this Head.
+     * 
+     * @return
+     */
+    public List<Actuator> getActuators();
+
+    /**
+     * Get the Actuator attached to this Head that has the specified id.
+     * 
+     * @param id
+     * @return
+     */
+    public Actuator getActuator(String id);
+
+    public Actuator getActuatorByName(String name);
+
+    /**
+     * Get a list of Cameras that are attached to this Head.
+     * 
+     * @return
+     */
+    public List<Camera> getCameras();
+
+    /**
+     * Get the Camera attached to this Head that has the specified id.
+     * 
+     * @param id
+     * @return
+     */
+    public Camera getCamera(String id);
+
     /**
-     * Directs the Head to move to it's home position and to move any
-     * attached devices to their home positions. 
+     * Directs the Head to move to it's home position and to move any attached devices to their home
+     * positions.
      */
     void home() throws Exception;
-    
+
     public void addCamera(Camera camera) throws Exception;
 
     public void removeCamera(Camera camera);
-    
+
     public void moveToSafeZ(double speed) throws Exception;
-    
+
     public List<PasteDispenser> getPasteDispensers();
-    
+
     public PasteDispenser getPasteDispenser(String id);
-    
+
     public Camera getDefaultCamera() throws Exception;
-    
+
     public Nozzle getDefaultNozzle() throws Exception;
-    
-    public PasteDispenser getDefaultPasteDispenser() throws Exception; 
+
+    public PasteDispenser getDefaultPasteDispenser() throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/HeadMountable.java b/src/main/java/org/openpnp/spi/HeadMountable.java
index b7bc39be12..2556d63fab 100755
--- a/src/main/java/org/openpnp/spi/HeadMountable.java
+++ b/src/main/java/org/openpnp/spi/HeadMountable.java
@@ -2,15 +2,16 @@
 
 public interface HeadMountable extends Movable {
     /**
-     * Gets the Head that this HeadMountable is attached to. If it is not
-     * attached to a Head this method returns null.
+     * Gets the Head that this HeadMountable is attached to. If it is not attached to a Head this
+     * method returns null.
+     * 
      * @return
      */
     Head getHead();
-    
+
     /**
-     * Set the Head that this HeadMountable is attached to. Called by the Head
-     * when the HeadMountable is added to it.
+     * Set the Head that this HeadMountable is attached to. Called by the Head when the
+     * HeadMountable is added to it.
      */
     void setHead(Head head);
 }
diff --git a/src/main/java/org/openpnp/spi/JobPlanner.java b/src/main/java/org/openpnp/spi/JobPlanner.java
index eb9985d8d5..3ab8ba8dd8 100755
--- a/src/main/java/org/openpnp/spi/JobPlanner.java
+++ b/src/main/java/org/openpnp/spi/JobPlanner.java
@@ -8,16 +8,14 @@
 
 
 /**
- * The JobPlanner is responsible for planning the order in which Placements
- * are processed and determining which Head/Nozzle/NozzleTip/Feeder combination
- * will be used for each Placement. It is called each time a Head is ready for
- * new work.
+ * The JobPlanner is responsible for planning the order in which Placements are processed and
+ * determining which Head/Nozzle/NozzleTip/Feeder combination will be used for each Placement. It is
+ * called each time a Head is ready for new work.
  */
 public interface JobPlanner {
     /**
-     * Represents one solution from the planner for a particular Placement.
-     * Includes the Head, Nozzle, NozzleTip and Feeder that should be used
-     * to service the Placement. 
+     * Represents one solution from the planner for a particular Placement. Includes the Head,
+     * Nozzle, NozzleTip and Feeder that should be used to service the Placement.
      */
     public static class PlacementSolution {
         public BoardLocation boardLocation;
@@ -26,8 +24,9 @@
         public Nozzle nozzle;
         public NozzleTip nozzleTip;
         public Feeder feeder;
-        
-        public PlacementSolution(Placement placement, BoardLocation boardLocation, Head head, Nozzle nozzle, NozzleTip nozzleTip, Feeder feeder) {
+
+        public PlacementSolution(Placement placement, BoardLocation boardLocation, Head head,
+                Nozzle nozzle, NozzleTip nozzleTip, Feeder feeder) {
             this.placement = placement;
             this.boardLocation = boardLocation;
             this.head = head;
@@ -36,21 +35,20 @@ public PlacementSolution(Placement placement, BoardLocation boardLocation, Head
             this.feeder = feeder;
         }
     }
-    
+
     public void setJob(Job job);
-    
+
     /**
-     * Gets a Set of the next available PlacementSolutions for the
-     * specified Head. The order in which Heads service Placements
-     * can not be reliably determined, so it is important that this
-     * method return PlacementSolutions for the specified Head using
-     * the state of the Job as it stands now.
+     * Gets a Set of the next available PlacementSolutions for the specified Head. The order in
+     * which Heads service Placements can not be reliably determined, so it is important that this
+     * method return PlacementSolutions for the specified Head using the state of the Job as it
+     * stands now.
+     * 
+     * This method must be thread safe as it may be called by multiple threads for different Heads
+     * simultaneously. This doesn't mean it necessarily needs to process concurrently - it can
+     * simply be synchronized although concurrent processing is an option for more advanced
+     * planners.
      * 
-     * This method must be thread safe as it may be called by multiple
-     * threads for different Heads simultaneously. This doesn't mean it
-     * necessarily needs to process concurrently - it can simply be
-     * synchronized although concurrent processing is an option for
-     * more advanced planners. 
      * @param head
      * @return
      */
diff --git a/src/main/java/org/openpnp/spi/JobProcessor.java b/src/main/java/org/openpnp/spi/JobProcessor.java
index f403f77ccc..ec3dfbf2d8 100755
--- a/src/main/java/org/openpnp/spi/JobProcessor.java
+++ b/src/main/java/org/openpnp/spi/JobProcessor.java
@@ -6,33 +6,21 @@
 
 public interface JobProcessor extends WizardConfigurable, PropertySheetHolder {
     public enum JobState {
-        Stopped,
-        Running,
-        Paused,
+        Stopped, Running, Paused,
     }
-    
+
     public enum JobError {
-        MachineHomingError,
-        MachineMovementError,
-        MachineRejectedJobError,
-        FeederError,
-        HeadError,
-        PickError,
-        PlaceError,
-        PartError
+        MachineHomingError, MachineMovementError, MachineRejectedJobError, FeederError, HeadError, PickError, PlaceError, PartError
     }
-    
+
     public enum PickRetryAction {
-        RetryWithFeed,
-        RetryWithoutFeed,
-        SkipAndContinue,
+        RetryWithFeed, RetryWithoutFeed, SkipAndContinue,
     }
-    
+
     public enum Type {
-        PickAndPlace,
-        SolderPaste
+        PickAndPlace, SolderPaste
     }
-    
+
     public abstract void setDelegate(JobProcessorDelegate delegate);
 
     public abstract void addListener(JobProcessorListener listener);
@@ -53,14 +41,14 @@
     public abstract void start() throws Exception;
 
     /**
-     * Pause a running Job. The Job will stop running at the next opportunity and retain
-     * it's state so that it can be resumed. 
+     * Pause a running Job. The Job will stop running at the next opportunity and retain it's state
+     * so that it can be resumed.
      */
     public abstract void pause();
 
     /**
-     * Advances the Job one step. If the Job is not currently started this will
-     * start the Job first.
+     * Advances the Job one step. If the Job is not currently started this will start the Job first.
+     * 
      * @throws Exception
      */
     public abstract void step() throws Exception;
@@ -71,11 +59,11 @@
     public abstract void resume();
 
     /**
-     * Stop a running Job. The Job will stop immediately and will reset to it's 
-     * freshly loaded state. All state about parts already placed will be lost.
+     * Stop a running Job. The Job will stop immediately and will reset to it's freshly loaded
+     * state. All state about parts already placed will be lost.
      */
     public abstract void stop();
 
     public abstract void run();
 
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/openpnp/spi/Locatable.java b/src/main/java/org/openpnp/spi/Locatable.java
index 878feb3e7b..37788aaaaf 100755
--- a/src/main/java/org/openpnp/spi/Locatable.java
+++ b/src/main/java/org/openpnp/spi/Locatable.java
@@ -3,10 +3,9 @@
 import org.openpnp.model.Location;
 
 /**
- * An object which has a Location in 4D space. The Location may be fixed or
- * Movable. The caller of this method becomes the owner of the returned
- * object and may modify the Location. The returned object should be a clone
- * or copy of the object if modification of it will adversely affect the
+ * An object which has a Location in 4D space. The Location may be fixed or Movable. The caller of
+ * this method becomes the owner of the returned object and may modify the Location. The returned
+ * object should be a clone or copy of the object if modification of it will adversely affect the
  * callee.
  */
 public interface Locatable {
diff --git a/src/main/java/org/openpnp/spi/Machine.java b/src/main/java/org/openpnp/spi/Machine.java
index 958eab7c03..a418dd3a20 100755
--- a/src/main/java/org/openpnp/spi/Machine.java
+++ b/src/main/java/org/openpnp/spi/Machine.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
@@ -25,7 +23,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
-import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 
 import com.google.common.util.concurrent.FutureCallback;
@@ -33,151 +30,144 @@
 
 
 /**
- * Machine represents the pick and place machine itself. It provides the information and interface needed to
- * cause the machine to do work. A Machine has one or more Heads.
- * Unless otherwise noted, the methods in this class block while performing their operations.
+ * Machine represents the pick and place machine itself. It provides the information and interface
+ * needed to cause the machine to do work. A Machine has one or more Heads. Unless otherwise noted,
+ * the methods in this class block while performing their operations.
  */
 public interface Machine extends WizardConfigurable, PropertySheetHolder, Closeable {
-	/**
-	 * Gets all active heads on the machine.
-	 * @return
-	 */
-	public List<Head> getHeads();
-	
-	public Head getHead(String id);
-	
-	/**
-	 * Gets a List of Feeders attached to the Machine.
-	 * @return
-	 */
-	public List<Feeder> getFeeders();
-	
-	public Feeder getFeeder(String id);
-	
-	
     /**
-     * Gets a List of Cameras attached to the Machine that are not attached
-     * to Heads.
+     * Gets all active heads on the machine.
+     * 
+     * @return
+     */
+    public List<Head> getHeads();
+
+    public Head getHead(String id);
+
+    /**
+     * Gets a List of Feeders attached to the Machine.
+     * 
+     * @return
+     */
+    public List<Feeder> getFeeders();
+
+    public Feeder getFeeder(String id);
+
+
+    /**
+     * Gets a List of Cameras attached to the Machine that are not attached to Heads.
+     * 
      * @return
      */
     public List<Camera> getCameras();
-    
+
     public Camera getCamera(String id);
-    
+
     /**
      * Get a list of Actuators that are attached to this Machine and not to a Head.
+     * 
      * @return
      */
     public List<Actuator> getActuators();
-    
+
     /**
      * Get the Actuator attached to this Machine and not to a Head that has the specified id.
+     * 
      * @param id
      * @return
      */
     public Actuator getActuator(String id);
-    
+
     public Actuator getActuatorByName(String name);
-    
-	/**
-	 * Commands all Heads to move to their home positions and reset their current positions
-	 * to 0,0,0,0. Depending on the head configuration of the machine the home positions may
-	 * not all be the same but the end result should be that any head commanded to move
-	 * to a certain position will end up in the same position.
-	 */
-	public void home() throws Exception;
-	
-	/**
-	 * Returns whether the Machine is currently ready for commands. 
-	 */
-	public boolean isEnabled();
-	
-	/**
-	 * Attempts to bring the Machine to a ready state or attempts to
-	 * immediately stop it depending on the value of enabled.
-	 * 
-	 * If true, this would include turning on motor drivers, turning on
-	 * compressors, resetting solenoids, etc. If the Machine is unable to
-	 * become ready for any reason it should throw an Exception explaining the
-	 * reason. This method should block until the Machine is ready.
-	 * 
-	 * After this method is called successfully, isEnabled() should return true unless the Machine
-	 * encounters some error.
-	 * 
-	 * If false, stops the machine and disables it as soon as possible. This
-	 * may include turning off power to motors and stopping compressors. It is
-	 * expected that the machine may need to be re-homed after this is called.
-	 *  
-	 * If the Machine cannot be stopped for any reason, this method may throw
-	 * an Exception explaining the reason but this should probably only happen
-	 * in very extreme cases. This method should effectively be considered a
-	 * software emergency stop. After this method returns, isEnabled() should
-	 * return false until setEnabled(true) is successfully called again.
-	 */
-	public void setEnabled(boolean enabled) throws Exception;
-	
-	public void addListener(MachineListener listener);
-	
-	public void removeListener(MachineListener listener);
-	
-	public List<Class<? extends Feeder>> getCompatibleFeederClasses();
-	
-	public List<Class<? extends Camera>> getCompatibleCameraClasses();
-	
-	public void addFeeder(Feeder feeder) throws Exception;
-	
-	public void removeFeeder(Feeder feeder);
-	
+
+    /**
+     * Commands all Heads to move to their home positions and reset their current positions to
+     * 0,0,0,0. Depending on the head configuration of the machine the home positions may not all be
+     * the same but the end result should be that any head commanded to move to a certain position
+     * will end up in the same position.
+     */
+    public void home() throws Exception;
+
+    /**
+     * Returns whether the Machine is currently ready for commands.
+     */
+    public boolean isEnabled();
+
+    /**
+     * Attempts to bring the Machine to a ready state or attempts to immediately stop it depending
+     * on the value of enabled.
+     * 
+     * If true, this would include turning on motor drivers, turning on compressors, resetting
+     * solenoids, etc. If the Machine is unable to become ready for any reason it should throw an
+     * Exception explaining the reason. This method should block until the Machine is ready.
+     * 
+     * After this method is called successfully, isEnabled() should return true unless the Machine
+     * encounters some error.
+     * 
+     * If false, stops the machine and disables it as soon as possible. This may include turning off
+     * power to motors and stopping compressors. It is expected that the machine may need to be
+     * re-homed after this is called.
+     * 
+     * If the Machine cannot be stopped for any reason, this method may throw an Exception
+     * explaining the reason but this should probably only happen in very extreme cases. This method
+     * should effectively be considered a software emergency stop. After this method returns,
+     * isEnabled() should return false until setEnabled(true) is successfully called again.
+     */
+    public void setEnabled(boolean enabled) throws Exception;
+
+    public void addListener(MachineListener listener);
+
+    public void removeListener(MachineListener listener);
+
+    public List<Class<? extends Feeder>> getCompatibleFeederClasses();
+
+    public List<Class<? extends Camera>> getCompatibleCameraClasses();
+
+    public void addFeeder(Feeder feeder) throws Exception;
+
+    public void removeFeeder(Feeder feeder);
+
     public void addCamera(Camera camera) throws Exception;
 
     public void removeCamera(Camera camera);
-    
-	public Map<JobProcessor.Type, JobProcessor> getJobProcessors();
-	
+
+    public Map<JobProcessor.Type, JobProcessor> getJobProcessors();
+
     public Future<Object> submit(Runnable runnable);
-    
+
     public <T> Future<T> submit(Callable<T> callable);
-    
-    public <T> Future<T> submit(
-            final Callable<T> callable, 
-            final FutureCallback<T> callback);
+
+    public <T> Future<T> submit(final Callable<T> callable, final FutureCallback<T> callback);
+
     /**
-     * Submit a task to be run with access to the Machine. This is the primary
-     * entry point into executing any blocking operation on the Machine. If
-     * you are doing anything that results in the Machine doing something
-     * it should happen here.
+     * Submit a task to be run with access to the Machine. This is the primary entry point into
+     * executing any blocking operation on the Machine. If you are doing anything that results in
+     * the Machine doing something it should happen here.
      * 
-     * Tasks can be cancelled and interrupted via the returned Future. Tasks
-     * which operate in a loop should check
-     * Thread.currentThread().isInterrupted().
+     * Tasks can be cancelled and interrupted via the returned Future. Tasks which operate in a loop
+     * should check Thread.currentThread().isInterrupted().
      * 
-     * When a task begins the MachineListeners are notified with
-     * machineBusy(true). When the task ends, if there are no more tasks
-     * to run then machineBusy(false) is called.
+     * When a task begins the MachineListeners are notified with machineBusy(true). When the task
+     * ends, if there are no more tasks to run then machineBusy(false) is called.
      * 
-     * TODO: When any task is running the driver for the machine is locked
-     * and any calls to the driver outside of the task will throw an Exception.
+     * TODO: When any task is running the driver for the machine is locked and any calls to the
+     * driver outside of the task will throw an Exception.
      * 
-     * If any tasks throws an Exception then all queued future tasks are
-     * cancelled.
+     * If any tasks throws an Exception then all queued future tasks are cancelled.
      * 
-     * If a task includes a callback the callback is executed before the next
-     * task begins.
+     * If a task includes a callback the callback is executed before the next task begins.
      * 
-     * TODO: By supplying a tag you can guarantee that there is only one
-     * of a certain type of task queued. Attempting to queue another task
-     * with the same tag will return null and the task will not be queued.
+     * TODO: By supplying a tag you can guarantee that there is only one of a certain type of task
+     * queued. Attempting to queue another task with the same tag will return null and the task will
+     * not be queued.
      * 
      * @param callable
      * @param callback
-     * @param ignoreEnabled True if the task should execute even if the 
-     * machine is not enabled. This is specifically for enabling the
-     * machine and should not typically be used elsewhere.
+     * @param ignoreEnabled True if the task should execute even if the machine is not enabled. This
+     *        is specifically for enabling the machine and should not typically be used elsewhere.
      */
-    public <T> Future<T> submit(
-            final Callable<T> callable, 
-            final FutureCallback<T> callback, 
+    public <T> Future<T> submit(final Callable<T> callable, final FutureCallback<T> callback,
             boolean ignoreEnabled);
-    
+
     public Head getDefaultHead() throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/MachineListener.java b/src/main/java/org/openpnp/spi/MachineListener.java
index 6f86d76fd4..e022fdbb99 100755
--- a/src/main/java/org/openpnp/spi/MachineListener.java
+++ b/src/main/java/org/openpnp/spi/MachineListener.java
@@ -1,68 +1,61 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
 
 /**
- * Provides a set of callbacks called by a Machine to notify listeners of 
- * asynchronous state changes in the Machine.
+ * Provides a set of callbacks called by a Machine to notify listeners of asynchronous state changes
+ * in the Machine.
+ * 
  * @author jason
  */
 public interface MachineListener {
-	void machineHeadActivity(Machine machine, Head head);
-	
-	void machineEnabled(Machine machine);
-	
-	void machineEnableFailed(Machine machine, String reason);
-	
-	void machineDisabled(Machine machine, String reason);
-	
-	void machineDisableFailed(Machine machine, String reason);
-	
-	void machineBusy(Machine machine, boolean busy);
-	
-	static public class Adapter implements MachineListener {
+    void machineHeadActivity(Machine machine, Head head);
+
+    void machineEnabled(Machine machine);
+
+    void machineEnableFailed(Machine machine, String reason);
+
+    void machineDisabled(Machine machine, String reason);
+
+    void machineDisableFailed(Machine machine, String reason);
+
+    void machineBusy(Machine machine, boolean busy);
+
+    static public class Adapter implements MachineListener {
+
+        @Override
+        public void machineHeadActivity(Machine machine, Head head) {}
 
-		@Override
-		public void machineHeadActivity(Machine machine, Head head) {
-		}
+        @Override
+        public void machineEnabled(Machine machine) {}
 
-		@Override
-		public void machineEnabled(Machine machine) {
-		}
+        @Override
+        public void machineEnableFailed(Machine machine, String reason) {}
 
-		@Override
-		public void machineEnableFailed(Machine machine, String reason) {
-		}
+        @Override
+        public void machineDisabled(Machine machine, String reason) {}
 
-		@Override
-		public void machineDisabled(Machine machine, String reason) {
-		}
+        @Override
+        public void machineDisableFailed(Machine machine, String reason) {}
 
-		@Override
-		public void machineDisableFailed(Machine machine, String reason) {
-		}
-		
-		@Override
-		public void machineBusy(Machine machine, boolean busy) {
-		}
-	}
+        @Override
+        public void machineBusy(Machine machine, boolean busy) {}
+    }
 }
diff --git a/src/main/java/org/openpnp/spi/Movable.java b/src/main/java/org/openpnp/spi/Movable.java
index 0b91e6d939..bd35750cc1 100755
--- a/src/main/java/org/openpnp/spi/Movable.java
+++ b/src/main/java/org/openpnp/spi/Movable.java
@@ -4,16 +4,16 @@
 
 public interface Movable extends Locatable {
     /**
-     * Move the object to the Location at the feedRate. 
+     * Move the object to the Location at the feedRate.
      * 
-     * @param location The Location to move to. If the movement should not
-     * include a particular axis, specify Double.NaN for that axis.
-     * @param speed Feed rate is specified as a percentage of maximum feed
-     * between 0 and 1. 1 specifies maximum feed rate as defined by the machine
-     * while 0 defines the absolute minimum feed rate while still moving.
+     * @param location The Location to move to. If the movement should not include a particular
+     *        axis, specify Double.NaN for that axis.
+     * @param speed Feed rate is specified as a percentage of maximum feed between 0 and 1. 1
+     *        specifies maximum feed rate as defined by the machine while 0 defines the absolute
+     *        minimum feed rate while still moving.
      * @throws Exception
      */
     public void moveTo(Location location, double speed) throws Exception;
-    
+
     public void moveToSafeZ(double speed) throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/Nozzle.java b/src/main/java/org/openpnp/spi/Nozzle.java
index 3bcf73f361..4a66b5376f 100755
--- a/src/main/java/org/openpnp/spi/Nozzle.java
+++ b/src/main/java/org/openpnp/spi/Nozzle.java
@@ -6,13 +6,13 @@
 import org.openpnp.model.Named;
 
 /**
- * A Nozzle is a tool capable of picking up parts and releasing them. It is
- * attached to a Head and may move entirely with the head or partially
- * independent of it. A Nozzle has a current NozzleTip that defines what types
- * of Packages it can handle and it may have the capability of changing it's
+ * A Nozzle is a tool capable of picking up parts and releasing them. It is attached to a Head and
+ * may move entirely with the head or partially independent of it. A Nozzle has a current NozzleTip
+ * that defines what types of Packages it can handle and it may have the capability of changing it's
  * NozzleTip.
  */
-public interface Nozzle extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
+public interface Nozzle
+        extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
     /**
      * Get the NozzleTip currently attached to the Nozzle.
      * 
@@ -21,58 +21,55 @@
     NozzleTip getNozzleTip();
 
     /**
-     * Commands the Nozzle to perform it's pick operation. Generally this just
-     * consists of turning on the vacuum. When this is called during job
-     * processing the processor will have already positioned the nozzle over the
-     * part to be picked and lowered it to the correct height. Some
-     * implementations may choose to do further work in pick(), such as firing
-     * air cylinders, monitoring pressure sensors, etc.
+     * Commands the Nozzle to perform it's pick operation. Generally this just consists of turning
+     * on the vacuum. When this is called during job processing the processor will have already
+     * positioned the nozzle over the part to be picked and lowered it to the correct height. Some
+     * implementations may choose to do further work in pick(), such as firing air cylinders,
+     * monitoring pressure sensors, etc.
      * 
      * @throws Exception
      */
     public void pick() throws Exception;
 
     /**
-     * Commands the Nozzle to perform it's place operation. Generally this just
-     * consists of releasing vacuum and may include a puff of air to set the
-     * Part. When this is called during job processing the processor will have
-     * already positioned the nozzle over the part to be placed and lowered it
-     * to the correct height.
+     * Commands the Nozzle to perform it's place operation. Generally this just consists of
+     * releasing vacuum and may include a puff of air to set the Part. When this is called during
+     * job processing the processor will have already positioned the nozzle over the part to be
+     * placed and lowered it to the correct height.
      * 
      * @throws Exception
      */
     public void place() throws Exception;
+
     /**
      * Get a list of the NozzleTips currently attached to the Nozzle.
      * 
      * @return
      */
-	public List<NozzleTip> getNozzleTips();
-	
-	/**
-	 * Changer interface:
-	 * 
-	 * Command the Nozzle to load the given NozzleTip as it's current
-	 * NozzleTip. If this returns without Exception then subsequently calling
-	 * getNozzleTip() should return the same NozzleTip as was passed to
-	 * this call.
-	 * 
-	 * If the specified NozzleTip is already loaded this method
-	 * should do nothing.
-	 * 
-	 * @param nozzleTip
-	 * @throws Exception
-	 */
-	public void loadNozzleTip(NozzleTip nozzleTip) throws Exception;
-	
-	/**
-	 * Changer interface:
-	 * 
-	 * Unload the current NozzleTip from the Nozzle, leaving it empty.
-	 * 
-	 * After this call getNozzleTip() should return null.
-	 *  
-	 * @throws Exception
-	 */
-	public void unloadNozzleTip() throws Exception;
+    public List<NozzleTip> getNozzleTips();
+
+    /**
+     * Changer interface:
+     * 
+     * Command the Nozzle to load the given NozzleTip as it's current NozzleTip. If this returns
+     * without Exception then subsequently calling getNozzleTip() should return the same NozzleTip
+     * as was passed to this call.
+     * 
+     * If the specified NozzleTip is already loaded this method should do nothing.
+     * 
+     * @param nozzleTip
+     * @throws Exception
+     */
+    public void loadNozzleTip(NozzleTip nozzleTip) throws Exception;
+
+    /**
+     * Changer interface:
+     * 
+     * Unload the current NozzleTip from the Nozzle, leaving it empty.
+     * 
+     * After this call getNozzleTip() should return null.
+     * 
+     * @throws Exception
+     */
+    public void unloadNozzleTip() throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/NozzleTip.java b/src/main/java/org/openpnp/spi/NozzleTip.java
index 7a50613fc4..db6abb56ac 100755
--- a/src/main/java/org/openpnp/spi/NozzleTip.java
+++ b/src/main/java/org/openpnp/spi/NozzleTip.java
@@ -5,7 +5,7 @@
 import org.openpnp.model.Part;
 
 /**
- * A NozzleTip is the physical interface between a Nozzle and a Part. 
+ * A NozzleTip is the physical interface between a Nozzle and a Part.
  */
 public interface NozzleTip extends Identifiable, Named, WizardConfigurable, PropertySheetHolder {
     public boolean canHandle(Part part);
diff --git a/src/main/java/org/openpnp/spi/PasteDispenser.java b/src/main/java/org/openpnp/spi/PasteDispenser.java
index 6afe68a701..425190c9fa 100755
--- a/src/main/java/org/openpnp/spi/PasteDispenser.java
+++ b/src/main/java/org/openpnp/spi/PasteDispenser.java
@@ -4,19 +4,20 @@
 import org.openpnp.model.Location;
 import org.openpnp.model.Named;
 
-public interface PasteDispenser extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
+public interface PasteDispenser
+        extends Identifiable, Named, HeadMountable, WizardConfigurable, PropertySheetHolder {
     /**
-     * Command the dispenser to dispense from the startLocation to the
-     * endLocation taking dispenseTimeMilliseconds milliseconds.
+     * Command the dispenser to dispense from the startLocation to the endLocation taking
+     * dispenseTimeMilliseconds milliseconds.
+     * 
+     * If the endLocation is null the dispenser should dispense at the startLocation. If both
+     * locations are null the dispenser will dispense at the current location.
      * 
-     * If the endLocation is null the dispenser should dispense at the
-     * startLocation. If both locations are null the dispenser will dispense
-     * at the current location.
-     *  
      * @param startLocation
      * @param endLocation
      * @param dispenseTimeMilliseconds
      * @throws Exception
      */
-    public void dispense(Location startLocation, Location endLocation, long dispenseTimeMilliseconds) throws Exception;
+    public void dispense(Location startLocation, Location endLocation,
+            long dispenseTimeMilliseconds) throws Exception;
 }
diff --git a/src/main/java/org/openpnp/spi/PropertySheetHolder.java b/src/main/java/org/openpnp/spi/PropertySheetHolder.java
index bf4b990c44..20ae2a102d 100755
--- a/src/main/java/org/openpnp/spi/PropertySheetHolder.java
+++ b/src/main/java/org/openpnp/spi/PropertySheetHolder.java
@@ -5,20 +5,24 @@
 import javax.swing.JPanel;
 
 /**
- * Provides an interface that allows a caller to build a tree of configurable
- * items each having one or more JPanel based property sheets for configuring
- * that item. By descending through the children with
- * getChildPropertySheetProviders() a tree can be built.
+ * Provides an interface that allows a caller to build a tree of configurable items each having one
+ * or more JPanel based property sheets for configuring that item. By descending through the
+ * children with getChildPropertySheetProviders() a tree can be built.
  */
 public interface PropertySheetHolder {
     public interface PropertySheet {
         String getPropertySheetTitle();
+
         JPanel getPropertySheetPanel();
     }
-    
+
     String getPropertySheetHolderTitle();
+
     PropertySheetHolder[] getChildPropertySheetHolders();
+
     PropertySheet[] getPropertySheets();
+
     Action[] getPropertySheetHolderActions();
+
     Icon getPropertySheetHolderIcon();
 }
diff --git a/src/main/java/org/openpnp/spi/VisionProvider.java b/src/main/java/org/openpnp/spi/VisionProvider.java
index 19d31d5bf0..a206b2bc3e 100755
--- a/src/main/java/org/openpnp/spi/VisionProvider.java
+++ b/src/main/java/org/openpnp/spi/VisionProvider.java
@@ -1,22 +1,20 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  */
 
 package org.openpnp.spi;
@@ -30,26 +28,26 @@
 import org.openpnp.model.Part;
 
 /**
- * Provides an interface for implementors of vision systems to implement. A
- * VisionProvider is attached to a Camera in configuration and can be commanded
- * by the system to perform a variety of vision tasks.
+ * Provides an interface for implementors of vision systems to implement. A VisionProvider is
+ * attached to a Camera in configuration and can be commanded by the system to perform a variety of
+ * vision tasks.
  */
 public interface VisionProvider {
     /**
-     * Sets the Camera that the VisionProvider should use for image capture.
-     * This is called during setup and will only be called once.
+     * Sets the Camera that the VisionProvider should use for image capture. This is called during
+     * setup and will only be called once.
      * 
      * @param camera
      */
     public void setCamera(Camera camera);
 
     public Wizard getConfigurationWizard();
-    
+
     public List<TemplateMatch> getTemplateMatches(BufferedImage template);
-    
+
     /**
-     * @deprecated This function's interface will change in the near future
-     * to return real units instead of pixels.
+     * @deprecated This function's interface will change in the near future to return real units
+     *             instead of pixels.
      * @param roiX
      * @param roiY
      * @param roiWidth
@@ -60,29 +58,27 @@
      * @return
      * @throws Exception
      */
-    public Point[] locateTemplateMatches(int roiX, int roiY, int roiWidth,
-            int roiHeight, int coiX, int coiY, BufferedImage templateImage)
-            throws Exception;
-    
+    public Point[] locateTemplateMatches(int roiX, int roiY, int roiWidth, int roiHeight, int coiX,
+            int coiY, BufferedImage templateImage) throws Exception;
+
     /**
-     * Given a Part and a Nozzle it is hanging off, find the Part's offsets
-     * from center. This method can be used for either Flying or Bottom vision
-     * depending on the orientation of the Camera this VisionProvider
-     * references. A fixed Camera (Camera.getHead() == null) will perform
-     * bottom vision while a Head mounted camera (Camera.getHead() != null)
-     * will perform flying vision. The two are effectively the same since
-     * both use an image of the bottom of the part.
+     * Given a Part and a Nozzle it is hanging off, find the Part's offsets from center. This method
+     * can be used for either Flying or Bottom vision depending on the orientation of the Camera
+     * this VisionProvider references. A fixed Camera (Camera.getHead() == null) will perform bottom
+     * vision while a Head mounted camera (Camera.getHead() != null) will perform flying vision. The
+     * two are effectively the same since both use an image of the bottom of the part.
+     * 
+     * This method is responsible for moving the Nozzle as needed, specifically it should center the
+     * Nozzle over the camera before taking a picture.
      * 
-     * This method is responsible for moving the Nozzle as needed, specifically
-     * it should center the Nozzle over the camera before taking a picture.
      * @return
      */
     public Location getPartBottomOffsets(Part part, Nozzle nozzle) throws Exception;
-    
+
     public static class TemplateMatch {
         public Location location;
         public double score;
-        
+
         @Override
         public String toString() {
             return location.toString() + " " + score;
diff --git a/src/main/java/org/openpnp/spi/WizardConfigurable.java b/src/main/java/org/openpnp/spi/WizardConfigurable.java
index f84d6f5310..f7556748a8 100755
--- a/src/main/java/org/openpnp/spi/WizardConfigurable.java
+++ b/src/main/java/org/openpnp/spi/WizardConfigurable.java
@@ -5,6 +5,7 @@
 public interface WizardConfigurable {
     /**
      * Gets a Wizard that can be used to configure this object.
+     * 
      * @return
      */
     Wizard getConfigurationWizard();
diff --git a/src/main/java/org/openpnp/spi/base/AbstractActuator.java b/src/main/java/org/openpnp/spi/base/AbstractActuator.java
index 5c5372c35e..c9b64450c5 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractActuator.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractActuator.java
@@ -10,17 +10,17 @@
 public abstract class AbstractActuator implements Actuator {
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     protected Head head;
-    
+
     public AbstractActuator() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
     }
-    
+
     @Override
     public String getId() {
         return id;
diff --git a/src/main/java/org/openpnp/spi/base/AbstractCamera.java b/src/main/java/org/openpnp/spi/base/AbstractCamera.java
index dcdb03d33c..3623b8ef9d 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractCamera.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractCamera.java
@@ -23,44 +23,43 @@
 public abstract class AbstractCamera implements Camera {
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     @Attribute
     protected Looking looking = Looking.Down;
-    
+
     @Element
     protected Location unitsPerPixel = new Location(LengthUnit.Millimeters);
-    
-    @Element(required=false)
+
+    @Element(required = false)
     protected VisionProvider visionProvider;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected long settleTimeMs = 250;
-    
+
     protected Set<ListenerEntry> listeners = Collections.synchronizedSet(new HashSet<>());
-    
+
     protected Head head;
-    
+
     protected Integer width;
-    
+
     protected Integer height;
-    
+
     public AbstractCamera() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 if (visionProvider != null) {
                     visionProvider.setCamera(AbstractCamera.this);
                 }
             }
         });
     }
-    
+
     @Override
     public String getId() {
         return id;
@@ -85,12 +84,12 @@ public Head getHead() {
     public void setHead(Head head) {
         this.head = head;
     }
-    
+
     @Override
     public Location getUnitsPerPixel() {
         return unitsPerPixel;
     }
-    
+
     @Override
     public void setUnitsPerPixel(Location unitsPerPixel) {
         this.unitsPerPixel = unitsPerPixel;
@@ -105,7 +104,7 @@ public void setLooking(Looking looking) {
     public Looking getLooking() {
         return looking;
     }
-    
+
     @Override
     public void startContinuousCapture(CameraListener listener, int maximumFps) {
         listeners.add(new ListenerEntry(listener, maximumFps));
@@ -115,7 +114,7 @@ public void startContinuousCapture(CameraListener listener, int maximumFps) {
     public void stopContinuousCapture(CameraListener listener) {
         listeners.remove(new ListenerEntry(listener, 0));
     }
-    
+
     @Override
     public void setVisionProvider(VisionProvider visionProvider) {
         this.visionProvider = visionProvider;
@@ -126,26 +125,27 @@ public void setVisionProvider(VisionProvider visionProvider) {
     public VisionProvider getVisionProvider() {
         return visionProvider;
     }
-    
+
     public BufferedImage settleAndCapture() {
-    	try {
-    		Thread.sleep(getSettleTimeMs());
-    	}
-    	catch (Exception e) {
-    		
-    	}
-    	return capture();
-    }
-    
+        try {
+            Thread.sleep(getSettleTimeMs());
+        }
+        catch (Exception e) {
+
+        }
+        return capture();
+    }
+
     protected void broadcastCapture(BufferedImage img) {
         for (ListenerEntry listener : new ArrayList<>(listeners)) {
-            if (listener.lastFrameSent < (System.currentTimeMillis() - (1000 / listener.maximumFps))) {
+            if (listener.lastFrameSent < (System.currentTimeMillis()
+                    - (1000 / listener.maximumFps))) {
                 listener.listener.frameReceived(img);
                 listener.lastFrameSent = System.currentTimeMillis();
             }
         }
     }
-    
+
     @Override
     public int getWidth() {
         if (width == null) {
@@ -165,16 +165,16 @@ public int getHeight() {
         }
         return height;
     }
-    
+
     public long getSettleTimeMs() {
-		return settleTimeMs;
-	}
-    
+        return settleTimeMs;
+    }
+
     public void setSettleTimeMs(long settleTimeMs) {
-    	this.settleTimeMs = settleTimeMs;
+        this.settleTimeMs = settleTimeMs;
     }
 
-	@Override
+    @Override
     public Icon getPropertySheetHolderIcon() {
         return Icons.captureCamera;
     }
diff --git a/src/main/java/org/openpnp/spi/base/AbstractFeeder.java b/src/main/java/org/openpnp/spi/base/AbstractFeeder.java
index bf4898f284..9083a8d846 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractFeeder.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractFeeder.java
@@ -14,29 +14,28 @@
     @Attribute
     protected String id;
 
-    @Attribute(required=false)
+    @Attribute(required = false)
     protected String name;
-    
+
     @Attribute
     protected boolean enabled;
-    
+
     @Attribute
     protected String partId;
-    
+
     protected Part part;
-    
+
     public AbstractFeeder() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
         Configuration.get().addListener(new ConfigurationListener.Adapter() {
             @Override
-            public void configurationLoaded(Configuration configuration)
-                    throws Exception {
+            public void configurationLoaded(Configuration configuration) throws Exception {
                 part = configuration.getPart(partId);
             }
         });
     }
-    
+
     @Override
     public String getId() {
         return id;
@@ -51,7 +50,7 @@ public boolean isEnabled() {
     public void setEnabled(boolean enabled) {
         this.enabled = enabled;
     }
-    
+
     @Override
     public void setPart(Part part) {
         this.part = part;
@@ -62,7 +61,7 @@ public void setPart(Part part) {
     public Part getPart() {
         return part;
     }
-    
+
     @Override
     public String getName() {
         return name;
@@ -76,5 +75,5 @@ public void setName(String name) {
     @Override
     public Icon getPropertySheetHolderIcon() {
         return Icons.editFeeder;
-    }  
+    }
 }
diff --git a/src/main/java/org/openpnp/spi/base/AbstractHead.java b/src/main/java/org/openpnp/spi/base/AbstractHead.java
index a9a97d0cae..84efab8f57 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractHead.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractHead.java
@@ -22,27 +22,27 @@
 
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Nozzle> nozzles = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Actuator> actuators = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Camera> cameras = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<PasteDispenser> pasteDispensers = new IdentifiableList<>();
-    
+
     public AbstractHead() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
     }
-    
+
     @SuppressWarnings("unused")
     @Commit
     private void commit() {
@@ -59,7 +59,7 @@ private void commit() {
             pasteDispenser.setHead(this);
         }
     }
-    
+
     @Override
     public String getId() {
         return id;
@@ -84,7 +84,7 @@ public Nozzle getNozzle(String id) {
     public Actuator getActuator(String id) {
         return actuators.get(id);
     }
-    
+
     @Override
     public Actuator getActuatorByName(String name) {
         for (Actuator actuator : actuators) {
@@ -114,7 +114,7 @@ public void addCamera(Camera camera) throws Exception {
     public void removeCamera(Camera camera) {
         cameras.remove(camera);
     }
-    
+
     @Override
     public void moveToSafeZ(double speed) throws Exception {
         for (Nozzle nozzle : nozzles) {
@@ -130,7 +130,7 @@ public void moveToSafeZ(double speed) throws Exception {
             dispenser.moveToSafeZ(speed);
         }
     }
-    
+
     @Override
     public String getName() {
         return name;
@@ -139,8 +139,8 @@ public String getName() {
     @Override
     public void setName(String name) {
         this.name = name;
-    }   
-    
+    }
+
     @Override
     public List<PasteDispenser> getPasteDispensers() {
         return Collections.unmodifiableList(pasteDispensers);
@@ -157,30 +157,30 @@ public Icon getPropertySheetHolderIcon() {
         return null;
     }
 
-	@Override
-	public Camera getDefaultCamera() throws Exception {
-		List<Camera> cameras = getCameras();
-		if (cameras == null || cameras.isEmpty()) {
-			throw new Exception("No default camera available on head " + getName());
-		}
-		return cameras.get(0);
-	}
-
-	@Override
-	public Nozzle getDefaultNozzle() throws Exception {
-		List<Nozzle> nozzles = getNozzles();
-		if (nozzles == null || nozzles.isEmpty()) {
-          throw new Exception("No default nozzle available on head " + getName());
-		}
-		return nozzles.get(0);
-	}
-
-	@Override
-	public PasteDispenser getDefaultPasteDispenser() throws Exception {
-		List<PasteDispenser> dispensers = getPasteDispensers();
-		if (dispensers == null || dispensers.isEmpty()) {
-          throw new Exception("No default paste dispenser available on head " + getName());
-		}
-		return dispensers.get(0);
-	}
+    @Override
+    public Camera getDefaultCamera() throws Exception {
+        List<Camera> cameras = getCameras();
+        if (cameras == null || cameras.isEmpty()) {
+            throw new Exception("No default camera available on head " + getName());
+        }
+        return cameras.get(0);
+    }
+
+    @Override
+    public Nozzle getDefaultNozzle() throws Exception {
+        List<Nozzle> nozzles = getNozzles();
+        if (nozzles == null || nozzles.isEmpty()) {
+            throw new Exception("No default nozzle available on head " + getName());
+        }
+        return nozzles.get(0);
+    }
+
+    @Override
+    public PasteDispenser getDefaultPasteDispenser() throws Exception {
+        List<PasteDispenser> dispensers = getPasteDispensers();
+        if (dispensers == null || dispensers.isEmpty()) {
+            throw new Exception("No default paste dispenser available on head " + getName());
+        }
+        return dispensers.get(0);
+    }
 }
diff --git a/src/main/java/org/openpnp/spi/base/AbstractJobProcessor.java b/src/main/java/org/openpnp/spi/base/AbstractJobProcessor.java
index 5dce31f53c..52e7f4657c 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractJobProcessor.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractJobProcessor.java
@@ -39,34 +39,34 @@ public void setDelegate(JobProcessorDelegate delegate) {
             this.delegate = delegate;
         }
     }
-    
+
     @Override
     public void addListener(JobProcessorListener listener) {
         listeners.add(listener);
     }
-    
+
     @Override
     public void removeListener(JobProcessorListener listener) {
         listeners.remove(listener);
     }
-    
+
     @Override
     public Job getJob() {
         return job;
     }
-    
+
     @Override
     public JobState getState() {
         return state;
     }
-    
+
     // TODO: Change this, and most of the other properties on here to bound
     // properties.
     @Override
     public void load(Job job) {
         stop();
         this.job = job;
-        
+
         fireJobLoaded();
     }
 
@@ -82,14 +82,14 @@ public void start() throws Exception {
         thread = new Thread(this);
         thread.start();
     }
-    
+
     @Override
     public void pause() {
         logger.debug("pause()");
         state = JobState.Paused;
         fireJobStateChanged();
     }
-    
+
     @Override
     public void step() throws Exception {
         logger.debug("step()");
@@ -102,7 +102,7 @@ public void step() throws Exception {
             resume();
         }
     }
-    
+
     @Override
     public void resume() {
         logger.debug("resume()");
@@ -112,7 +112,7 @@ public void resume() {
             runLock.notifyAll();
         }
     }
-    
+
     @Override
     public void stop() {
         logger.debug("stop()");
@@ -124,9 +124,8 @@ public void stop() {
     }
 
     /**
-     * Checks if the Job has been Paused or Stopped. If it has been Paused this method
-     * blocks until the Job is Resumed. If the Job has been Stopped it returns false and
-     * the loop should break.
+     * Checks if the Job has been Paused or Stopped. If it has been Paused this method blocks until
+     * the Job is Resumed. If the Job has been Stopped it returns false and the loop should break.
      */
     protected boolean shouldJobProcessingContinue() {
         if (pauseAtNextStep) {
@@ -153,64 +152,64 @@ else if (state == JobState.Paused) {
         }
         return true;
     }
-    
+
     protected void fireJobEncounteredError(JobError error, String description) {
         logger.debug("fireJobEncounteredError({}, {})", error, description);
         for (JobProcessorListener listener : listeners) {
             listener.jobEncounteredError(error, description);
         }
     }
-    
+
     private void fireJobLoaded() {
         logger.debug("fireJobLoaded()");
         for (JobProcessorListener listener : listeners) {
             listener.jobLoaded(job);
         }
     }
-    
+
     protected void fireJobStateChanged() {
         logger.debug("fireJobStateChanged({})", state);
         for (JobProcessorListener listener : listeners) {
             listener.jobStateChanged(state);
         }
     }
-    
+
     protected void firePartProcessingStarted(BoardLocation board, Placement placement) {
         logger.debug("firePartProcessingStarted({}, {})", board, placement);
         for (JobProcessorListener listener : listeners) {
             listener.partProcessingStarted(board, placement);
         }
     }
-    
+
     protected void firePartPicked(BoardLocation board, Placement placement) {
         logger.debug("firePartPicked({}, {})", board, placement);
         for (JobProcessorListener listener : listeners) {
             listener.partPicked(board, placement);
         }
     }
-    
+
     protected void firePartPlaced(BoardLocation board, Placement placement) {
         logger.debug("firePartPlaced({}, {})", board, placement);
         for (JobProcessorListener listener : listeners) {
             listener.partPlaced(board, placement);
         }
     }
-    
+
     protected void firePartProcessingComplete(BoardLocation board, Placement placement) {
         logger.debug("firePartProcessingComplete({}, {})", board, placement);
         for (JobProcessorListener listener : listeners) {
             listener.partProcessingCompleted(board, placement);
         }
     }
-    
+
     protected void fireDetailedStatusUpdated(String status) {
         logger.debug("fireDetailedStatusUpdated({})", status);
         for (JobProcessorListener listener : listeners) {
             listener.detailedStatusUpdated(status);
         }
     }
-    
-    
+
+
     @Override
     public String getPropertySheetHolderTitle() {
         return getClass().getSimpleName();
@@ -224,17 +223,15 @@ public String getPropertySheetHolderTitle() {
 
     @Override
     public PropertySheet[] getPropertySheets() {
-        return new PropertySheet[] {
-                new PropertySheetWizardAdapter(getConfigurationWizard())
-        };
+        return new PropertySheet[] {new PropertySheetWizardAdapter(getConfigurationWizard())};
     }
-    
+
     @Override
     public Action[] getPropertySheetHolderActions() {
         // TODO Auto-generated method stub
         return null;
     }
-    
+
     @Override
     public Icon getPropertySheetHolderIcon() {
         // TODO Auto-generated method stub
@@ -245,8 +242,7 @@ public Icon getPropertySheetHolderIcon() {
 
     class DefaultJobProcessorDelegate implements JobProcessorDelegate {
         @Override
-        public PickRetryAction partPickFailed(BoardLocation board, Part part,
-                Feeder feeder) {
+        public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder) {
             return PickRetryAction.SkipAndContinue;
         }
     }
diff --git a/src/main/java/org/openpnp/spi/base/AbstractMachine.java b/src/main/java/org/openpnp/spi/base/AbstractMachine.java
index 2af69b4c53..95fb5b7340 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractMachine.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractMachine.java
@@ -36,43 +36,43 @@
     /**
      * History:
      * 
-     * Note: Can't actually use the @Version annotation because of a bug
-     * in SimpleXML. See http://sourceforge.net/p/simple/mailman/message/27887562/
-     *  
-     * 1.0: Initial revision.
-     * 1.1: Added jobProcessors Map and deprecated JobProcesor and JobPlanner.
+     * Note: Can't actually use the @Version annotation because of a bug in SimpleXML. See
+     * http://sourceforge.net/p/simple/mailman/message/27887562/
+     * 
+     * 1.0: Initial revision. 1.1: Added jobProcessors Map and deprecated JobProcesor and
+     * JobPlanner.
      */
 
     @ElementList
     protected IdentifiableList<Head> heads = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Feeder> feeders = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Camera> cameras = new IdentifiableList<>();
-    
-    @ElementList(required=false)
+
+    @ElementList(required = false)
     protected IdentifiableList<Actuator> actuators = new IdentifiableList<>();
-    
+
     @Deprecated
-    @Element(required=false)
+    @Element(required = false)
     protected JobPlanner jobPlanner;
-    
+
     @Deprecated
-    @Element(required=false)
+    @Element(required = false)
     protected JobProcessor jobProcessor;
-    
-    @ElementMap(entry="jobProcessor", key="type", attribute=true, inline=false, required=false)
+
+    @ElementMap(entry = "jobProcessor", key = "type", attribute = true, inline = false,
+            required = false)
     protected Map<JobProcessor.Type, JobProcessor> jobProcessors = new HashMap<>();
-    
+
     protected Set<MachineListener> listeners = Collections.synchronizedSet(new HashSet<>());
-    
+
     protected ThreadPoolExecutor executor;
-    
-    protected AbstractMachine() {
-    }
-    
+
+    protected AbstractMachine() {}
+
     @SuppressWarnings("unused")
     @Commit
     private void commit() {
@@ -82,7 +82,7 @@ private void commit() {
             jobPlanner = null;
         }
     }
-    
+
     @Override
     public List<Head> getHeads() {
         return Collections.unmodifiableList(heads);
@@ -97,12 +97,12 @@ public Head getHead(String id) {
     public List<Feeder> getFeeders() {
         return Collections.unmodifiableList(feeders);
     }
-    
+
     @Override
     public Feeder getFeeder(String id) {
         return feeders.get(id);
     }
-    
+
     @Override
     public List<Camera> getCameras() {
         return Collections.unmodifiableList(cameras);
@@ -122,7 +122,7 @@ public Camera getCamera(String id) {
     public Actuator getActuator(String id) {
         return actuators.get(id);
     }
-    
+
     @Override
     public Actuator getActuatorByName(String name) {
         for (Actuator actuator : actuators) {
@@ -149,7 +149,7 @@ public void addListener(MachineListener listener) {
     public void removeListener(MachineListener listener) {
         listeners.remove(listener);
     }
-    
+
     @Override
     public void addFeeder(Feeder feeder) throws Exception {
         feeders.add(feeder);
@@ -169,7 +169,7 @@ public void addCamera(Camera camera) throws Exception {
     public void removeCamera(Camera camera) {
         cameras.remove(camera);
     }
-    
+
     @Override
     public Map<Type, JobProcessor> getJobProcessors() {
         return Collections.unmodifiableMap(jobProcessors);
@@ -180,25 +180,25 @@ public void fireMachineHeadActivity(Head head) {
             listener.machineHeadActivity(this, head);
         }
     }
-    
+
     public void fireMachineEnabled() {
         for (MachineListener listener : listeners) {
             listener.machineEnabled(this);
         }
     }
-    
+
     public void fireMachineEnableFailed(String reason) {
         for (MachineListener listener : listeners) {
             listener.machineEnableFailed(this, reason);
         }
     }
-    
+
     public void fireMachineDisabled(String reason) {
         for (MachineListener listener : listeners) {
             listener.machineDisabled(this, reason);
         }
     }
-    
+
     public void fireMachineDisableFailed(String reason) {
         for (MachineListener listener : listeners) {
             listener.machineDisableFailed(this, reason);
@@ -216,42 +216,39 @@ public Icon getPropertySheetHolderIcon() {
         // TODO Auto-generated method stub
         return null;
     }
-    
+
     @Override
     public Future<Object> submit(Runnable runnable) {
         return submit(Executors.callable(runnable));
     }
-    
+
     @Override
     public <T> Future<T> submit(Callable<T> callable) {
         return submit(callable, null);
     }
-    
+
     @Override
     public <T> Future<T> submit(final Callable<T> callable, final FutureCallback<T> callback) {
         return submit(callable, callback, false);
     }
-    
+
     @Override
-    public <T> Future<T> submit(final Callable<T> callable, final FutureCallback<T> callback, final boolean ignoreEnabled) {
-        synchronized(this) {
+    public <T> Future<T> submit(final Callable<T> callable, final FutureCallback<T> callback,
+            final boolean ignoreEnabled) {
+        synchronized (this) {
             if (executor == null || executor.isShutdown()) {
-                executor = new ThreadPoolExecutor(
-                        1, 
-                        1, 
-                        1,
-                        TimeUnit.SECONDS,
+                executor = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS,
                         new LinkedBlockingQueue<>());
             }
         }
-        
+
         Callable<T> wrapper = new Callable<T>() {
             public T call() throws Exception {
                 // TODO: lock driver
-                
+
                 // Notify listeners that the machine is now busy
                 fireMachineBusy(true);
-                
+
                 // Call the task, storing the result and exception if any
                 T result = null;
                 Exception exception = null;
@@ -264,7 +261,7 @@ public T call() throws Exception {
                 catch (Exception e) {
                     exception = e;
                 }
-                
+
                 // If a callback was supplied, call it with the results
                 if (callback != null) {
                     if (exception != null) {
@@ -274,20 +271,20 @@ public T call() throws Exception {
                         callback.onSuccess(result);
                     }
                 }
-                
+
                 // If there was an error cancel all pending tasks.
                 if (exception != null) {
                     executor.shutdownNow();
                 }
-                
+
                 // TODO: unlock driver
-  
+
                 // If no more tasks are scheduled notify listeners that
                 // the machine is no longer busy
                 if (executor.getQueue().isEmpty()) {
                     fireMachineBusy(false);
                 }
-                
+
                 // Finally, fulfill the Future by either throwing the
                 // exception or returning the result.
                 if (exception != null) {
@@ -296,16 +293,16 @@ public T call() throws Exception {
                 return result;
             }
         };
-        
-        return executor.submit(wrapper); 
+
+        return executor.submit(wrapper);
     }
 
-	@Override
-	public Head getDefaultHead() throws Exception {
-		List<Head> heads = getHeads();
-		if (heads == null || heads.isEmpty()) {
+    @Override
+    public Head getDefaultHead() throws Exception {
+        List<Head> heads = getHeads();
+        if (heads == null || heads.isEmpty()) {
             throw new Exception("No default head available.");
-		}
-		return heads.get(0);
-	}
+        }
+        return heads.get(0);
+    }
 }
diff --git a/src/main/java/org/openpnp/spi/base/AbstractNozzle.java b/src/main/java/org/openpnp/spi/base/AbstractNozzle.java
index e2ca59e6bf..a905d1147a 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractNozzle.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractNozzle.java
@@ -15,27 +15,27 @@
 import org.simpleframework.xml.ElementList;
 
 public abstract class AbstractNozzle implements Nozzle {
-    @ElementList(required=false)
-    	protected IdentifiableList<NozzleTip> nozzleTips = new IdentifiableList<>();
+    @ElementList(required = false)
+    protected IdentifiableList<NozzleTip> nozzleTips = new IdentifiableList<>();
 
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     protected Head head;
 
     public AbstractNozzle() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
     }
-    
+
     @Override
     public List<NozzleTip> getNozzleTips() {
         return Collections.unmodifiableList(nozzleTips);
     }
-	
+
     @Override
     public String getId() {
         return id;
diff --git a/src/main/java/org/openpnp/spi/base/AbstractNozzleTip.java b/src/main/java/org/openpnp/spi/base/AbstractNozzleTip.java
index cd32840f17..042191886c 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractNozzleTip.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractNozzleTip.java
@@ -9,15 +9,15 @@
 public abstract class AbstractNozzleTip implements NozzleTip {
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     public AbstractNozzleTip() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
     }
-    
+
     @Override
     public String getId() {
         return id;
diff --git a/src/main/java/org/openpnp/spi/base/AbstractPasteDispenser.java b/src/main/java/org/openpnp/spi/base/AbstractPasteDispenser.java
index 8776881759..38f7179a5c 100755
--- a/src/main/java/org/openpnp/spi/base/AbstractPasteDispenser.java
+++ b/src/main/java/org/openpnp/spi/base/AbstractPasteDispenser.java
@@ -10,17 +10,17 @@
 public abstract class AbstractPasteDispenser implements PasteDispenser {
     @Attribute
     protected String id;
-    
-    @Attribute(required=false)
+
+    @Attribute(required = false)
     protected String name;
-    
+
     protected Head head;
 
     public AbstractPasteDispenser() {
         this.id = Configuration.createId();
         this.name = getClass().getSimpleName();
     }
-    
+
     @Override
     public String getId() {
         return id;
diff --git a/src/main/java/org/openpnp/spi/base/SimplePropertySheetHolder.java b/src/main/java/org/openpnp/spi/base/SimplePropertySheetHolder.java
index edf743578d..26b3c04f1d 100755
--- a/src/main/java/org/openpnp/spi/base/SimplePropertySheetHolder.java
+++ b/src/main/java/org/openpnp/spi/base/SimplePropertySheetHolder.java
@@ -11,17 +11,18 @@
     protected String title;
     protected PropertySheetHolder[] children;
     protected Icon icon;
-    
+
     public SimplePropertySheetHolder(String title, List<? extends PropertySheetHolder> children) {
         this(title, children, null);
     }
-    
-    public SimplePropertySheetHolder(String title, List<? extends PropertySheetHolder> children, Icon icon) {
+
+    public SimplePropertySheetHolder(String title, List<? extends PropertySheetHolder> children,
+            Icon icon) {
         this.title = title;
-        this.children = children.toArray(new PropertySheetHolder[]{});
+        this.children = children.toArray(new PropertySheetHolder[] {});
         this.icon = icon;
     }
-    
+
     @Override
     public String getPropertySheetHolderTitle() {
         return title;
@@ -41,7 +42,7 @@ public String getPropertySheetHolderTitle() {
     public Action[] getPropertySheetHolderActions() {
         return null;
     }
-    
+
     @Override
     public Icon getPropertySheetHolderIcon() {
         return icon;
diff --git a/src/main/java/org/openpnp/util/HslColor.java b/src/main/java/org/openpnp/util/HslColor.java
index 37c784e8b6..ef9a9696dc 100755
--- a/src/main/java/org/openpnp/util/HslColor.java
+++ b/src/main/java/org/openpnp/util/HslColor.java
@@ -3,418 +3,378 @@
 import java.awt.Color;
 
 /**
- *  The HSLColor class provides methods to manipulate HSL (Hue, Saturation
- *  Luminance) values to create a corresponding Color object using the RGB
- *  ColorSpace.
+ * The HSLColor class provides methods to manipulate HSL (Hue, Saturation Luminance) values to
+ * create a corresponding Color object using the RGB ColorSpace.
  *
- *  The HUE is the color, the Saturation is the purity of the color (with
- *  respect to grey) and Luminance is the brightness of the color (with respect
- *  to black and white)
+ * The HUE is the color, the Saturation is the purity of the color (with respect to grey) and
+ * Luminance is the brightness of the color (with respect to black and white)
  *
- *  The Hue is specified as an angel between 0 - 360 degrees where red is 0,
- *  green is 120 and blue is 240. In between you have the colors of the rainbow.
- *  Saturation is specified as a percentage between 0 - 100 where 100 is fully
- *  saturated and 0 approaches gray. Luminance is specified as a percentage
- *  between 0 - 100 where 0 is black and 100 is white.
+ * The Hue is specified as an angel between 0 - 360 degrees where red is 0, green is 120 and blue is
+ * 240. In between you have the colors of the rainbow. Saturation is specified as a percentage
+ * between 0 - 100 where 100 is fully saturated and 0 approaches gray. Luminance is specified as a
+ * percentage between 0 - 100 where 0 is black and 100 is white.
  *
- *  In particular the HSL color space makes it easier change the Tone or Shade
- *  of a color by adjusting the luminance value.
+ * In particular the HSL color space makes it easier change the Tone or Shade of a color by
+ * adjusting the luminance value.
  */
-public class HslColor
-{
-	private Color rgb;
-	private float[] hsl;
-	private float alpha;
-
-	/**
-	 *  Create a HSLColor object using an RGB Color object.
-	 *
-	 *  @param rgb the RGB Color object
-	 */
-	public HslColor(Color rgb)
-	{
-		this.rgb = rgb;
-		hsl = fromRGB( rgb );
-		alpha = rgb.getAlpha() / 255.0f;
-	}
-
-	/**
-	 *  Create a HSLColor object using individual HSL values and a default
-	 * alpha value of 1.0.
-	 *
-	 *  @param h is the Hue value in degrees between 0 - 360
-	 *  @param s is the Saturation percentage between 0 - 100
-	 *  @param l is the Lumanance percentage between 0 - 100
-	 */
-	public HslColor(float h, float s, float l)
-	{
-		this(h, s, l, 1.0f);
-	}
-
-	/**
-	 *  Create a HSLColor object using individual HSL values.
-	 *
-	 *  @param h     the Hue value in degrees between 0 - 360
-	 *  @param s     the Saturation percentage between 0 - 100
-	 *  @param l     the Lumanance percentage between 0 - 100
-	 *  @param alpha the alpha value between 0 - 1
-	 */
-	public HslColor(float h, float s, float l, float alpha)
-	{
-		hsl = new float[] {h, s, l};
-		this.alpha = alpha;
-		rgb = toRGB(hsl, alpha);
-	}
-
-	/**
-	 *  Create a HSLColor object using an an array containing the
-	 *  individual HSL values and with a default alpha value of 1.
-	 *
-	 *  @param hsl  array containing HSL values
-	 */
-	public HslColor(float[] hsl)
-	{
-		this(hsl, 1.0f);
-	}
-
-	/**
-	 *  Create a HSLColor object using an an array containing the
-	 *  individual HSL values.
-	 *
-	 *  @param hsl  array containing HSL values
-	 *  @param alpha the alpha value between 0 - 1
-	 */
-	public HslColor(float[] hsl, float alpha)
-	{
-		this.hsl = hsl;
-		this.alpha = alpha;
-		rgb = toRGB(hsl, alpha);
-	}
-
-	/**
-	 *  Create a RGB Color object based on this HSLColor with a different
-	 *  Hue value. The degrees specified is an absolute value.
-	 *
-	 *  @param degrees - the Hue value between 0 - 360
-	 *  @return the RGB Color object
-	 */
-	public Color adjustHue(float degrees)
-	{
-		return toRGB(degrees, hsl[1], hsl[2], alpha);
-	}
-
-	/**
-	 *  Create a RGB Color object based on this HSLColor with a different
-	 *  Luminance value. The percent specified is an absolute value.
-	 *
-	 *  @param percent - the Luminance value between 0 - 100
-	 *  @return the RGB Color object
-	 */
-	public Color adjustLuminance(float percent)
-	{
-		return toRGB(hsl[0], hsl[1], percent, alpha);
-	}
-
-	/**
-	 *  Create a RGB Color object based on this HSLColor with a different
-	 *  Saturation value. The percent specified is an absolute value.
-	 *
-	 *  @param percent - the Saturation value between 0 - 100
-	 *  @return the RGB Color object
-	 */
-	public Color adjustSaturation(float percent)
-	{
-		return toRGB(hsl[0], percent, hsl[2], alpha);
-	}
-
-	/**
-	 *  Create a RGB Color object based on this HSLColor with a different
-	 *  Shade. Changing the shade will return a darker color. The percent
-	 *  specified is a relative value.
-	 *
-	 *  @param percent - the value between 0 - 100
-	 *  @return the RGB Color object
-	 */
-	public Color adjustShade(float percent)
-	{
-		float multiplier = (100.0f - percent) / 100.0f;
-		float l = Math.max(0.0f, hsl[2] * multiplier);
-
-		return toRGB(hsl[0], hsl[1], l, alpha);
-	}
-
-	/**
-	 *  Create a RGB Color object based on this HSLColor with a different
-	 *  Tone. Changing the tone will return a lighter color. The percent
-	 *  specified is a relative value.
-	 *
-	 *  @param percent - the value between 0 - 100
-	 *  @return the RGB Color object
-	 */
-	public Color adjustTone(float percent)
-	{
-		float multiplier = (100.0f + percent) / 100.0f;
-		float l = Math.min(100.0f, hsl[2] * multiplier);
-
-		return toRGB(hsl[0], hsl[1], l, alpha);
-	}
-
-	/**
-	 *  Get the Alpha value.
-	 *
-	 *  @return the Alpha value.
-	 */
-	public float getAlpha()
-	{
-		return alpha;
-	}
-
-	/**
-	 *  Create a RGB Color object that is the complementary color of this
-	 *  HSLColor. This is a convenience method. The complementary color is
-	 *  determined by adding 180 degrees to the Hue value.
-	 *  @return the RGB Color object
-	 */
-	public Color getComplementary()
-	{
-		float hue = (hsl[0] + 180.0f) % 360.0f;
-		return toRGB(hue, hsl[1], hsl[2]);
-	}
-
-	/**
-	 *  Get the Hue value.
-	 *
-	 *  @return the Hue value.
-	 */
-	public float getHue()
-	{
-		return hsl[0];
-	}
-
-	/**
-	 *  Get the HSL values.
-	 *
-	 *  @return the HSL values.
-	 */
-	public float[] getHSL()
-	{
-		return hsl;
-	}
-
-	/**
-	 *  Get the Luminance value.
-	 *
-	 *  @return the Luminance value.
-	 */
-	public float getLuminance()
-	{
-		return hsl[2];
-	}
-
-	/**
-	 *  Get the RGB Color object represented by this HDLColor.
-	 *
-	 *  @return the RGB Color object.
-	 */
-	public Color getRGB()
-	{
-		return rgb;
-	}
-
-	/**
-	 *  Get the Saturation value.
-	 *
-	 *  @return the Saturation value.
-	 */
-	public float getSaturation()
-	{
-		return hsl[1];
-	}
-
-	public String toString()
-	{
-		String toString =
-			"HSLColor[h=" + hsl[0] +
-			",s=" + hsl[1] +
-			",l=" + hsl[2] +
-			",alpha=" + alpha + "]";
-
-		return toString;
-	}
-
-	/**
-	 *  Convert a RGB Color to it corresponding HSL values.
-	 *
-	 *  @return an array containing the 3 HSL values.
-	 */
-	public static float[] fromRGB(Color color)
-	{
-		//  Get RGB values in the range 0 - 1
-
-		float[] rgb = color.getRGBColorComponents( null );
-		float r = rgb[0];
-		float g = rgb[1];
-		float b = rgb[2];
-
-		//	Minimum and Maximum RGB values are used in the HSL calculations
-
-		float min = Math.min(r, Math.min(g, b));
-		float max = Math.max(r, Math.max(g, b));
-
-		//  Calculate the Hue
-
-		float h = 0;
-
-		if (max == min)
-			h = 0;
-		else if (max == r)
-			h = ((60 * (g - b) / (max - min)) + 360) % 360;
-		else if (max == g)
-			h = (60 * (b - r) / (max - min)) + 120;
-		else if (max == b)
-			h = (60 * (r - g) / (max - min)) + 240;
-
-		//  Calculate the Luminance
-
-		float l = (max + min) / 2;
-
-		//  Calculate the Saturation
-
-		float s = 0;
-
-		if (max == min)
-			s = 0;
-		else if (l <= .5f)
-			s = (max - min) / (max + min);
-		else
-			s = (max - min) / (2 - max - min);
-
-		return new float[] {h, s * 100, l * 100};
-	}
-
-	/**
-	 *  Convert HSL values to a RGB Color with a default alpha value of 1.
-	 *  H (Hue) is specified as degrees in the range 0 - 360.
-	 *  S (Saturation) is specified as a percentage in the range 1 - 100.
-	 *  L (Lumanance) is specified as a percentage in the range 1 - 100.
-	 *
-	 *  @param hsl an array containing the 3 HSL values
-	 *
-	 *  @returns the RGB Color object
-	 */
-	public static Color toRGB(float[] hsl)
-	{
-		return toRGB(hsl, 1.0f);
-	}
-
-	/**
-	 *  Convert HSL values to a RGB Color.
-	 *  H (Hue) is specified as degrees in the range 0 - 360.
-	 *  S (Saturation) is specified as a percentage in the range 1 - 100.
-	 *  L (Lumanance) is specified as a percentage in the range 1 - 100.
-	 *
-	 *  @param hsl    an array containing the 3 HSL values
-	 *  @param alpha  the alpha value between 0 - 1
-	 *
-	 *  @returns the RGB Color object
-	 */
-	public static Color toRGB(float[] hsl, float alpha)
-	{
-		return toRGB(hsl[0], hsl[1], hsl[2], alpha);
-	}
-
-	/**
-	 *  Convert HSL values to a RGB Color with a default alpha value of 1.
-	 *
-	 *  @param h Hue is specified as degrees in the range 0 - 360.
-	 *  @param s Saturation is specified as a percentage in the range 1 - 100.
-	 *  @param l Lumanance is specified as a percentage in the range 1 - 100.
-	 *
-	 *  @returns the RGB Color object
-	 */
-	public static Color toRGB(float h, float s, float l)
-	{
-		return toRGB(h, s, l, 1.0f);
-	}
-
-	/**
-	 *  Convert HSL values to a RGB Color.
-	 *
-	 *  @param h Hue is specified as degrees in the range 0 - 360.
-	 *  @param s Saturation is specified as a percentage in the range 1 - 100.
-	 *  @param l Lumanance is specified as a percentage in the range 1 - 100.
-	 *  @param alpha  the alpha value between 0 - 1
-	 *
-	 *  @returns the RGB Color object
-	 */
-	public static Color toRGB(float h, float s, float l, float alpha)
-	{
-		if (s <0.0f || s > 100.0f)
-		{
-			String message = "Color parameter outside of expected range - Saturation";
-			throw new IllegalArgumentException( message );
-		}
-
-		if (l <0.0f || l > 100.0f)
-		{
-			String message = "Color parameter outside of expected range - Luminance";
-			throw new IllegalArgumentException( message );
-		}
-
-		if (alpha <0.0f || alpha > 1.0f)
-		{
-			String message = "Color parameter outside of expected range - Alpha";
-			throw new IllegalArgumentException( message );
-		}
-
-		//  Formula needs all values between 0 - 1.
-
-		h = h % 360.0f;
-		h /= 360f;
-		s /= 100f;
-		l /= 100f;
-
-		float q = 0;
-
-		if (l < 0.5)
-			q = l * (1 + s);
-		else
-			q = (l + s) - (s * l);
-
-		float p = 2 * l - q;
-
-		float r = Math.max(0, HueToRGB(p, q, h + (1.0f / 3.0f)));
-		float g = Math.max(0, HueToRGB(p, q, h));
-		float b = Math.max(0, HueToRGB(p, q, h - (1.0f / 3.0f)));
-
-		r = Math.min(r, 1.0f);
-		g = Math.min(g, 1.0f);
-		b = Math.min(b, 1.0f);
-
-		return new Color(r, g, b, alpha);
-	}
-
-	private static float HueToRGB(float p, float q, float h)
-	{
-		if (h < 0) h += 1;
-
-		if (h > 1 ) h -= 1;
-
-		if (6 * h < 1)
-		{
-			return p + ((q - p) * 6 * h);
-		}
-
-		if (2 * h < 1 )
-		{
-			return  q;
-		}
-
-		if (3 * h < 2)
-		{
-			return p + ( (q - p) * 6 * ((2.0f / 3.0f) - h) );
-		}
-
-   		return p;
-	}
+public class HslColor {
+    private Color rgb;
+    private float[] hsl;
+    private float alpha;
+
+    /**
+     * Create a HSLColor object using an RGB Color object.
+     *
+     * @param rgb the RGB Color object
+     */
+    public HslColor(Color rgb) {
+        this.rgb = rgb;
+        hsl = fromRGB(rgb);
+        alpha = rgb.getAlpha() / 255.0f;
+    }
+
+    /**
+     * Create a HSLColor object using individual HSL values and a default alpha value of 1.0.
+     *
+     * @param h is the Hue value in degrees between 0 - 360
+     * @param s is the Saturation percentage between 0 - 100
+     * @param l is the Lumanance percentage between 0 - 100
+     */
+    public HslColor(float h, float s, float l) {
+        this(h, s, l, 1.0f);
+    }
+
+    /**
+     * Create a HSLColor object using individual HSL values.
+     *
+     * @param h the Hue value in degrees between 0 - 360
+     * @param s the Saturation percentage between 0 - 100
+     * @param l the Lumanance percentage between 0 - 100
+     * @param alpha the alpha value between 0 - 1
+     */
+    public HslColor(float h, float s, float l, float alpha) {
+        hsl = new float[] {h, s, l};
+        this.alpha = alpha;
+        rgb = toRGB(hsl, alpha);
+    }
+
+    /**
+     * Create a HSLColor object using an an array containing the individual HSL values and with a
+     * default alpha value of 1.
+     *
+     * @param hsl array containing HSL values
+     */
+    public HslColor(float[] hsl) {
+        this(hsl, 1.0f);
+    }
+
+    /**
+     * Create a HSLColor object using an an array containing the individual HSL values.
+     *
+     * @param hsl array containing HSL values
+     * @param alpha the alpha value between 0 - 1
+     */
+    public HslColor(float[] hsl, float alpha) {
+        this.hsl = hsl;
+        this.alpha = alpha;
+        rgb = toRGB(hsl, alpha);
+    }
+
+    /**
+     * Create a RGB Color object based on this HSLColor with a different Hue value. The degrees
+     * specified is an absolute value.
+     *
+     * @param degrees - the Hue value between 0 - 360
+     * @return the RGB Color object
+     */
+    public Color adjustHue(float degrees) {
+        return toRGB(degrees, hsl[1], hsl[2], alpha);
+    }
+
+    /**
+     * Create a RGB Color object based on this HSLColor with a different Luminance value. The
+     * percent specified is an absolute value.
+     *
+     * @param percent - the Luminance value between 0 - 100
+     * @return the RGB Color object
+     */
+    public Color adjustLuminance(float percent) {
+        return toRGB(hsl[0], hsl[1], percent, alpha);
+    }
+
+    /**
+     * Create a RGB Color object based on this HSLColor with a different Saturation value. The
+     * percent specified is an absolute value.
+     *
+     * @param percent - the Saturation value between 0 - 100
+     * @return the RGB Color object
+     */
+    public Color adjustSaturation(float percent) {
+        return toRGB(hsl[0], percent, hsl[2], alpha);
+    }
+
+    /**
+     * Create a RGB Color object based on this HSLColor with a different Shade. Changing the shade
+     * will return a darker color. The percent specified is a relative value.
+     *
+     * @param percent - the value between 0 - 100
+     * @return the RGB Color object
+     */
+    public Color adjustShade(float percent) {
+        float multiplier = (100.0f - percent) / 100.0f;
+        float l = Math.max(0.0f, hsl[2] * multiplier);
+
+        return toRGB(hsl[0], hsl[1], l, alpha);
+    }
+
+    /**
+     * Create a RGB Color object based on this HSLColor with a different Tone. Changing the tone
+     * will return a lighter color. The percent specified is a relative value.
+     *
+     * @param percent - the value between 0 - 100
+     * @return the RGB Color object
+     */
+    public Color adjustTone(float percent) {
+        float multiplier = (100.0f + percent) / 100.0f;
+        float l = Math.min(100.0f, hsl[2] * multiplier);
+
+        return toRGB(hsl[0], hsl[1], l, alpha);
+    }
+
+    /**
+     * Get the Alpha value.
+     *
+     * @return the Alpha value.
+     */
+    public float getAlpha() {
+        return alpha;
+    }
+
+    /**
+     * Create a RGB Color object that is the complementary color of this HSLColor. This is a
+     * convenience method. The complementary color is determined by adding 180 degrees to the Hue
+     * value.
+     * 
+     * @return the RGB Color object
+     */
+    public Color getComplementary() {
+        float hue = (hsl[0] + 180.0f) % 360.0f;
+        return toRGB(hue, hsl[1], hsl[2]);
+    }
+
+    /**
+     * Get the Hue value.
+     *
+     * @return the Hue value.
+     */
+    public float getHue() {
+        return hsl[0];
+    }
+
+    /**
+     * Get the HSL values.
+     *
+     * @return the HSL values.
+     */
+    public float[] getHSL() {
+        return hsl;
+    }
+
+    /**
+     * Get the Luminance value.
+     *
+     * @return the Luminance value.
+     */
+    public float getLuminance() {
+        return hsl[2];
+    }
+
+    /**
+     * Get the RGB Color object represented by this HDLColor.
+     *
+     * @return the RGB Color object.
+     */
+    public Color getRGB() {
+        return rgb;
+    }
+
+    /**
+     * Get the Saturation value.
+     *
+     * @return the Saturation value.
+     */
+    public float getSaturation() {
+        return hsl[1];
+    }
+
+    public String toString() {
+        String toString =
+                "HSLColor[h=" + hsl[0] + ",s=" + hsl[1] + ",l=" + hsl[2] + ",alpha=" + alpha + "]";
+
+        return toString;
+    }
+
+    /**
+     * Convert a RGB Color to it corresponding HSL values.
+     *
+     * @return an array containing the 3 HSL values.
+     */
+    public static float[] fromRGB(Color color) {
+        // Get RGB values in the range 0 - 1
+
+        float[] rgb = color.getRGBColorComponents(null);
+        float r = rgb[0];
+        float g = rgb[1];
+        float b = rgb[2];
+
+        // Minimum and Maximum RGB values are used in the HSL calculations
+
+        float min = Math.min(r, Math.min(g, b));
+        float max = Math.max(r, Math.max(g, b));
+
+        // Calculate the Hue
+
+        float h = 0;
+
+        if (max == min)
+            h = 0;
+        else if (max == r)
+            h = ((60 * (g - b) / (max - min)) + 360) % 360;
+        else if (max == g)
+            h = (60 * (b - r) / (max - min)) + 120;
+        else if (max == b)
+            h = (60 * (r - g) / (max - min)) + 240;
+
+        // Calculate the Luminance
+
+        float l = (max + min) / 2;
+
+        // Calculate the Saturation
+
+        float s = 0;
+
+        if (max == min)
+            s = 0;
+        else if (l <= .5f)
+            s = (max - min) / (max + min);
+        else
+            s = (max - min) / (2 - max - min);
+
+        return new float[] {h, s * 100, l * 100};
+    }
+
+    /**
+     * Convert HSL values to a RGB Color with a default alpha value of 1. H (Hue) is specified as
+     * degrees in the range 0 - 360. S (Saturation) is specified as a percentage in the range 1 -
+     * 100. L (Lumanance) is specified as a percentage in the range 1 - 100.
+     *
+     * @param hsl an array containing the 3 HSL values
+     *
+     * @returns the RGB Color object
+     */
+    public static Color toRGB(float[] hsl) {
+        return toRGB(hsl, 1.0f);
+    }
+
+    /**
+     * Convert HSL values to a RGB Color. H (Hue) is specified as degrees in the range 0 - 360. S
+     * (Saturation) is specified as a percentage in the range 1 - 100. L (Lumanance) is specified as
+     * a percentage in the range 1 - 100.
+     *
+     * @param hsl an array containing the 3 HSL values
+     * @param alpha the alpha value between 0 - 1
+     *
+     * @returns the RGB Color object
+     */
+    public static Color toRGB(float[] hsl, float alpha) {
+        return toRGB(hsl[0], hsl[1], hsl[2], alpha);
+    }
+
+    /**
+     * Convert HSL values to a RGB Color with a default alpha value of 1.
+     *
+     * @param h Hue is specified as degrees in the range 0 - 360.
+     * @param s Saturation is specified as a percentage in the range 1 - 100.
+     * @param l Lumanance is specified as a percentage in the range 1 - 100.
+     *
+     * @returns the RGB Color object
+     */
+    public static Color toRGB(float h, float s, float l) {
+        return toRGB(h, s, l, 1.0f);
+    }
+
+    /**
+     * Convert HSL values to a RGB Color.
+     *
+     * @param h Hue is specified as degrees in the range 0 - 360.
+     * @param s Saturation is specified as a percentage in the range 1 - 100.
+     * @param l Lumanance is specified as a percentage in the range 1 - 100.
+     * @param alpha the alpha value between 0 - 1
+     *
+     * @returns the RGB Color object
+     */
+    public static Color toRGB(float h, float s, float l, float alpha) {
+        if (s < 0.0f || s > 100.0f) {
+            String message = "Color parameter outside of expected range - Saturation";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (l < 0.0f || l > 100.0f) {
+            String message = "Color parameter outside of expected range - Luminance";
+            throw new IllegalArgumentException(message);
+        }
+
+        if (alpha < 0.0f || alpha > 1.0f) {
+            String message = "Color parameter outside of expected range - Alpha";
+            throw new IllegalArgumentException(message);
+        }
+
+        // Formula needs all values between 0 - 1.
+
+        h = h % 360.0f;
+        h /= 360f;
+        s /= 100f;
+        l /= 100f;
+
+        float q = 0;
+
+        if (l < 0.5)
+            q = l * (1 + s);
+        else
+            q = (l + s) - (s * l);
+
+        float p = 2 * l - q;
+
+        float r = Math.max(0, HueToRGB(p, q, h + (1.0f / 3.0f)));
+        float g = Math.max(0, HueToRGB(p, q, h));
+        float b = Math.max(0, HueToRGB(p, q, h - (1.0f / 3.0f)));
+
+        r = Math.min(r, 1.0f);
+        g = Math.min(g, 1.0f);
+        b = Math.min(b, 1.0f);
+
+        return new Color(r, g, b, alpha);
+    }
+
+    private static float HueToRGB(float p, float q, float h) {
+        if (h < 0)
+            h += 1;
+
+        if (h > 1)
+            h -= 1;
+
+        if (6 * h < 1) {
+            return p + ((q - p) * 6 * h);
+        }
+
+        if (2 * h < 1) {
+            return q;
+        }
+
+        if (3 * h < 2) {
+            return p + ((q - p) * 6 * ((2.0f / 3.0f) - h));
+        }
+
+        return p;
+    }
 }
diff --git a/src/main/java/org/openpnp/util/IdentifiableList.java b/src/main/java/org/openpnp/util/IdentifiableList.java
index dd5261e4bf..5e7a21dabc 100755
--- a/src/main/java/org/openpnp/util/IdentifiableList.java
+++ b/src/main/java/org/openpnp/util/IdentifiableList.java
@@ -5,17 +5,17 @@
 import org.openpnp.model.Identifiable;
 
 /**
- * A List specifically for storing implementations of Identifiable. This
- * class adds a get(String) method for getting the Identifiable object with
- * the specified id from the list. Currently performs a simple search through
- * the list but is intended to be indexed eventually.
- * TODO: Perform indexing on insert and remove so that get(String) can perform
- * better. Consider what happens if an id changes out from under us.
+ * A List specifically for storing implementations of Identifiable. This class adds a get(String)
+ * method for getting the Identifiable object with the specified id from the list. Currently
+ * performs a simple search through the list but is intended to be indexed eventually. TODO: Perform
+ * indexing on insert and remove so that get(String) can perform better. Consider what happens if an
+ * id changes out from under us.
+ * 
  * @param <E>
  */
 public class IdentifiableList<E extends Identifiable> extends ArrayList<E> {
     private static final long serialVersionUID = -2350184908321182804L;
-    
+
     public E get(String id) {
         for (E e : this) {
             if (e.getId().equals(id)) {
diff --git a/src/main/java/org/openpnp/util/ImageUtils.java b/src/main/java/org/openpnp/util/ImageUtils.java
index 9b79df5d4e..f3ce918f07 100755
--- a/src/main/java/org/openpnp/util/ImageUtils.java
+++ b/src/main/java/org/openpnp/util/ImageUtils.java
@@ -6,9 +6,9 @@
 public class ImageUtils {
 
     /**
-     * Convert a BufferedImage from it's current type to a new, specified type
-     * by creating a new BufferedImage and drawing the source image onto it. If
-     * the image is already of the specified type it is returned unchanged.
+     * Convert a BufferedImage from it's current type to a new, specified type by creating a new
+     * BufferedImage and drawing the source image onto it. If the image is already of the specified
+     * type it is returned unchanged.
      * 
      * @param src
      * @param type
@@ -18,8 +18,7 @@ public static BufferedImage convertBufferedImage(BufferedImage src, int type) {
         if (src.getType() == type) {
             return src;
         }
-        BufferedImage img = new BufferedImage(src.getWidth(), src.getHeight(),
-                type);
+        BufferedImage img = new BufferedImage(src.getWidth(), src.getHeight(), type);
         Graphics2D g2d = img.createGraphics();
         g2d.drawImage(src, 0, 0, null);
         g2d.dispose();
diff --git a/src/main/java/org/openpnp/util/MovableUtils.java b/src/main/java/org/openpnp/util/MovableUtils.java
index cd195198f7..03489ef3a1 100755
--- a/src/main/java/org/openpnp/util/MovableUtils.java
+++ b/src/main/java/org/openpnp/util/MovableUtils.java
@@ -6,15 +6,17 @@
 
 public class MovableUtils {
     /**
-     * Moves the given HeadMountable to the specified Location by first
-     * commanding the head to safe-Z all of it's components, then moving
-     * the HeadMountable in X, Y and C, followed by moving in Z.
+     * Moves the given HeadMountable to the specified Location by first commanding the head to
+     * safe-Z all of it's components, then moving the HeadMountable in X, Y and C, followed by
+     * moving in Z.
+     * 
      * @param hm
      * @param location
      * @param speed
      * @throws Exception
      */
-    public static void moveToLocationAtSafeZ(HeadMountable hm, Location location, double speed) throws Exception {
+    public static void moveToLocationAtSafeZ(HeadMountable hm, Location location, double speed)
+            throws Exception {
         Head head = hm.getHead();
         head.moveToSafeZ(speed);
         hm.moveTo(location.derive(null, null, Double.NaN, null), speed);
diff --git a/src/main/java/org/openpnp/util/OpenCvUtils.java b/src/main/java/org/openpnp/util/OpenCvUtils.java
index d928d2cd3a..452f5347ef 100755
--- a/src/main/java/org/openpnp/util/OpenCvUtils.java
+++ b/src/main/java/org/openpnp/util/OpenCvUtils.java
@@ -29,9 +29,10 @@
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
     }
-    
+
     /**
      * TODO: This probably doesn't work right on submats. Need to test and fix.
+     * 
      * @param m
      * @return
      */
@@ -50,13 +51,14 @@ else if (m.type() == CvType.CV_32F) {
             m = tmp;
         }
         if (type == null) {
-            throw new Error(String.format("Unsupported Mat: type %d, channels %d, depth %d", m.type(), m.channels(), m.depth()));
+            throw new Error(String.format("Unsupported Mat: type %d, channels %d, depth %d",
+                    m.type(), m.channels(), m.depth()));
         }
         BufferedImage image = new BufferedImage(m.cols(), m.rows(), type);
         m.get(0, 0, ((DataBufferByte) image.getRaster().getDataBuffer()).getData());
         return image;
     }
-    
+
     public static Mat toMat(BufferedImage img) {
         Integer type = null;
         if (img.getType() == BufferedImage.TYPE_BYTE_GRAY) {
@@ -72,14 +74,15 @@ else if (img.getType() == BufferedImage.TYPE_3BYTE_BGR) {
         Mat mat = new Mat(img.getHeight(), img.getWidth(), type);
         mat.put(0, 0, ((DataBufferByte) img.getRaster().getDataBuffer()).getData());
         return mat;
-    }    
-    
+    }
+
     /**
-     * Finds circles of the given min and maxDiameter, no less than minDistance apart
-     * by capturing an image from the given Camera. Results are returned as a List of Location
-     * where X and Y represent the center of the circle, Z is that of the Camera and
-     * rotation is the diameter of the circle found. Results are returned sorted by distance
-     * from the Camera Location in ascending order.
+     * Finds circles of the given min and maxDiameter, no less than minDistance apart by capturing
+     * an image from the given Camera. Results are returned as a List of Location where X and Y
+     * represent the center of the circle, Z is that of the Camera and rotation is the diameter of
+     * the circle found. Results are returned sorted by distance from the Camera Location in
+     * ascending order.
+     * 
      * @param camera
      * @param minDiameter
      * @param maxDiameter
@@ -87,151 +90,134 @@ else if (img.getType() == BufferedImage.TYPE_3BYTE_BGR) {
      * @return
      * @throws Exception
      */
-    public static List<Location> houghCircles(
-    		Camera camera, 
-    		Length minDiameter, 
-    		Length maxDiameter, 
-    		Length minDistance) throws Exception {
-    	logger.debug("houghCircles({}, {}, {}, {})", new Object[] { camera.getName(), minDiameter, maxDiameter, minDistance });
-    	
-    	// convert inputs to the same units
-    	Location unitsPerPixel = camera.getUnitsPerPixel();
-    	minDiameter = minDiameter.convertToUnits(unitsPerPixel.getUnits());
-    	maxDiameter = maxDiameter.convertToUnits(unitsPerPixel.getUnits());
-    	minDistance = minDistance.convertToUnits(unitsPerPixel.getUnits());
-
-    	// we average the units per pixel because circles can't be ovals
-    	double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
-        
-    	// convert it all to pixels
-    	double minDiameterPixels = minDiameter.getValue() / avgUnitsPerPixel;
+    public static List<Location> houghCircles(Camera camera, Length minDiameter, Length maxDiameter,
+            Length minDistance) throws Exception {
+        logger.debug("houghCircles({}, {}, {}, {})",
+                new Object[] {camera.getName(), minDiameter, maxDiameter, minDistance});
+
+        // convert inputs to the same units
+        Location unitsPerPixel = camera.getUnitsPerPixel();
+        minDiameter = minDiameter.convertToUnits(unitsPerPixel.getUnits());
+        maxDiameter = maxDiameter.convertToUnits(unitsPerPixel.getUnits());
+        minDistance = minDistance.convertToUnits(unitsPerPixel.getUnits());
+
+        // we average the units per pixel because circles can't be ovals
+        double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
+
+        // convert it all to pixels
+        double minDiameterPixels = minDiameter.getValue() / avgUnitsPerPixel;
         double maxDiameterPixels = maxDiameter.getValue() / avgUnitsPerPixel;
         double minDistancePixels = minDistance.getValue() / avgUnitsPerPixel;
 
-        BufferedImage image = camera.capture(); 
+        BufferedImage image = camera.capture();
         Mat mat = toMat(image);
         Mat circles = houghCircles(mat, minDiameterPixels, maxDiameterPixels, minDistancePixels);
-        
-    	// convert the results into Locations
-    	List<Location> locations = new ArrayList<>();
-    	for (int i = 0; i < circles.cols(); i++) {
-    		double[] circle = circles.get(0, i);
-    		double x = circle[0];
-    		double y = circle[1];
-    		double radius = circle[2];
+
+        // convert the results into Locations
+        List<Location> locations = new ArrayList<>();
+        for (int i = 0; i < circles.cols(); i++) {
+            double[] circle = circles.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            double radius = circle[2];
             Location location = VisionUtils.getPixelLocation(camera, x, y);
             location = location.derive(null, null, null, radius * 2 * avgUnitsPerPixel);
-            locations.add(location); 
-    	}
-    	
-    	// sort by distance from center
-    	locations = VisionUtils.sortLocationsByDistance(camera.getLocation(), locations);
+            locations.add(location);
+        }
+
+        // sort by distance from center
+        locations = VisionUtils.sortLocationsByDistance(camera.getLocation(), locations);
         return locations;
     }
-    
-    public static Mat houghCircles(Mat mat, double minDiameter, double maxDiameter, double minDistance) {
-        logger.debug("houghCircles(Mat, {}, {}, {})", new Object[] { minDiameter, maxDiameter, minDistance });
-        
-    	saveDebugImage("houghCircles_in", mat);
-    	
-    	// save a copy of the image for debugging
-    	Mat debug = mat.clone();
-    	
-    	// hough requires grayscale images
-    	mat = toGray(mat);
-    	
-    	// and prefers a blurred image
-    	mat = gaussianBlur(mat, 9);
-    	
-    	// run the houghcircles algorithm
-    	Mat circles = new Mat();
-    	Imgproc.HoughCircles(
-    			mat, 
-    			circles, 
-    			Imgproc.CV_HOUGH_GRADIENT, 
-    			1, 
-    			minDistance,
-    			80, 
-    			10, 
-    			(int) (minDiameter / 2), 
-    			(int) (maxDiameter / 2));
-    	
-    	if (logger.isDebugEnabled()) {
-    		drawCircles(debug, circles);
-    		saveDebugImage("houghCircles_debug", debug);
-    	}
-    	
-    	saveDebugImage("houghCircles_out", mat);
-
-    	return circles;
+
+    public static Mat houghCircles(Mat mat, double minDiameter, double maxDiameter,
+            double minDistance) {
+        logger.debug("houghCircles(Mat, {}, {}, {})",
+                new Object[] {minDiameter, maxDiameter, minDistance});
+
+        saveDebugImage("houghCircles_in", mat);
+
+        // save a copy of the image for debugging
+        Mat debug = mat.clone();
+
+        // hough requires grayscale images
+        mat = toGray(mat);
+
+        // and prefers a blurred image
+        mat = gaussianBlur(mat, 9);
+
+        // run the houghcircles algorithm
+        Mat circles = new Mat();
+        Imgproc.HoughCircles(mat, circles, Imgproc.CV_HOUGH_GRADIENT, 1, minDistance, 80, 10,
+                (int) (minDiameter / 2), (int) (maxDiameter / 2));
+
+        if (logger.isDebugEnabled()) {
+            drawCircles(debug, circles);
+            saveDebugImage("houghCircles_debug", debug);
+        }
+
+        saveDebugImage("houghCircles_out", mat);
+
+        return circles;
     }
-    
+
     /**
-     * Convert the given Mat to grayscale. Conversion is done in place and if the
-     * Mat is already grayscale nothing is done.
+     * Convert the given Mat to grayscale. Conversion is done in place and if the Mat is already
+     * grayscale nothing is done.
+     * 
      * @param mat
      * @return
      */
     public static Mat toGray(Mat mat) {
-    	if (mat.channels() == 1) {
-    		return mat;
-    	}
-		Imgproc.cvtColor(mat, mat, Imgproc.COLOR_BGR2GRAY);
-		return mat;
+        if (mat.channels() == 1) {
+            return mat;
+        }
+        Imgproc.cvtColor(mat, mat, Imgproc.COLOR_BGR2GRAY);
+        return mat;
     }
-    
+
     /**
-     * Perform an in place gaussian blur on the given Mat with a kernel of size
-     * kernel x kernel. 
+     * Perform an in place gaussian blur on the given Mat with a kernel of size kernel x kernel.
+     * 
      * @param mat
      * @param kernel
      * @return
      */
     public static Mat gaussianBlur(Mat mat, int kernel) {
-    	Imgproc.GaussianBlur(mat, mat, new Size(kernel, kernel), 0);
-    	return mat;
+        Imgproc.GaussianBlur(mat, mat, new Size(kernel, kernel), 0);
+        return mat;
     }
-    
+
     public static Mat drawCircles(Mat mat, Mat circles) {
-    	for (int i = 0; i < circles.cols(); i++) {
-    		double[] circle = circles.get(0, i);
-    		double x = circle[0];
-    		double y = circle[1];
-    		double radius = circle[2];
-        	Core.circle(mat, new Point(x, y), (int) radius, new Scalar(0, 0, 255, 255), 2);
-        	Core.circle(mat, new Point(x, y), 1, new Scalar(0, 255, 0, 255), 2);
-    	}
-    	return mat;
+        for (int i = 0; i < circles.cols(); i++) {
+            double[] circle = circles.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            double radius = circle[2];
+            Core.circle(mat, new Point(x, y), (int) radius, new Scalar(0, 0, 255, 255), 2);
+            Core.circle(mat, new Point(x, y), 1, new Scalar(0, 255, 0, 255), 2);
+        }
+        return mat;
     }
-    
+
     public static Mat thresholdAdaptive(Mat mat, boolean invert) {
-    	Imgproc.adaptiveThreshold(
-    			mat, 
-    			mat, 
-    			255, 
-    			Imgproc.ADAPTIVE_THRESH_MEAN_C, 
-    			invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY, 
-    			3,
-    			5);
-    	return mat;
+        Imgproc.adaptiveThreshold(mat, mat, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C,
+                invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY, 3, 5);
+        return mat;
     }
-    
+
     public static Mat thresholdOtsu(Mat mat, boolean invert) {
-    	Imgproc.threshold(
-    			mat, 
-    			mat,
-    			0,
-    			255, 
-    			(invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY) | Imgproc.THRESH_OTSU);
-    	return mat;
+        Imgproc.threshold(mat, mat, 0, 255,
+                (invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY) | Imgproc.THRESH_OTSU);
+        return mat;
     }
-    
+
     public static void saveDebugImage(String name, Mat mat) {
         if (logger.isDebugEnabled()) {
             try {
                 BufferedImage debugImage = OpenCvUtils.toBufferedImage(mat);
-                File file = Configuration.get().createResourceFile(
-                        OpenCvUtils.class, name + "_", ".png");
+                File file = Configuration.get().createResourceFile(OpenCvUtils.class, name + "_",
+                        ".png");
                 ImageIO.write(debugImage, "PNG", file);
             }
             catch (Exception e) {
diff --git a/src/main/java/org/openpnp/util/ResourceUtils.java b/src/main/java/org/openpnp/util/ResourceUtils.java
index e2e9d17035..dafbdfa060 100755
--- a/src/main/java/org/openpnp/util/ResourceUtils.java
+++ b/src/main/java/org/openpnp/util/ResourceUtils.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.util;
 
@@ -29,13 +27,14 @@
 public class ResourceUtils {
 
     /**
-     * Get the relative path from one file to another, specifying the directory separator. 
-     * If one of the provided resources does not exist, it is assumed to be a file unless it ends with '/' or
+     * Get the relative path from one file to another, specifying the directory separator. If one of
+     * the provided resources does not exist, it is assumed to be a file unless it ends with '/' or
      * '\'.
      * 
      * @param target targetPath is calculated to this file
      * @param base basePath is calculated from this file
-     * @param separator directory separator. The platform default is not assumed so that we can test Unix behaviour when running on Windows (for example)
+     * @param separator directory separator. The platform default is not assumed so that we can test
+     *        Unix behaviour when running on Windows (for example)
      * @return
      */
     public static String getRelativePath(String targetPath, String basePath, String pathSeparator) {
@@ -49,12 +48,15 @@ public static String getRelativePath(String targetPath, String basePath, String
             normalizedTargetPath = FilenameUtils.separatorsToUnix(normalizedTargetPath);
             normalizedBasePath = FilenameUtils.separatorsToUnix(normalizedBasePath);
 
-        } else if (pathSeparator.equals("\\")) {
+        }
+        else if (pathSeparator.equals("\\")) {
             normalizedTargetPath = FilenameUtils.separatorsToWindows(normalizedTargetPath);
             normalizedBasePath = FilenameUtils.separatorsToWindows(normalizedBasePath);
 
-        } else {
-            throw new IllegalArgumentException("Unrecognised dir separator '" + pathSeparator + "'");
+        }
+        else {
+            throw new IllegalArgumentException(
+                    "Unrecognised dir separator '" + pathSeparator + "'");
         }
 
         String[] base = normalizedBasePath.split(Pattern.quote(pathSeparator));
@@ -75,19 +77,21 @@ public static String getRelativePath(String targetPath, String basePath, String
             // No single common path element. This most
             // likely indicates differing drive letters, like C: and D:.
             // These paths cannot be relativized.
-            throw new PathResolutionException("No common path element found for '" + normalizedTargetPath + "' and '" + normalizedBasePath
-                    + "'");
-        }   
+            throw new PathResolutionException("No common path element found for '"
+                    + normalizedTargetPath + "' and '" + normalizedBasePath + "'");
+        }
 
-        // The number of directories we have to backtrack depends on whether the base is a file or a dir
+        // The number of directories we have to backtrack depends on whether the base is a file or a
+        // dir
         // For example, the relative path from
         //
         // /foo/bar/baz/gg/ff to /foo/bar/baz
-        // 
+        //
         // ".." if ff is a file
         // "../.." if ff is a directory
         //
-        // The following is a heuristic to figure out if the base refers to a file or dir. It's not perfect, because
+        // The following is a heuristic to figure out if the base refers to a file or dir. It's not
+        // perfect, because
         // the resource referred to by this path may not actually exist, but it's the best I can do
         boolean baseIsFile = true;
 
@@ -96,7 +100,8 @@ public static String getRelativePath(String targetPath, String basePath, String
         if (baseResource.exists()) {
             baseIsFile = baseResource.isFile();
 
-        } else if (basePath.endsWith(pathSeparator)) {
+        }
+        else if (basePath.endsWith(pathSeparator)) {
             baseIsFile = false;
         }
 
@@ -118,5 +123,5 @@ public static String getRelativePath(String targetPath, String basePath, String
         PathResolutionException(String msg) {
             super(msg);
         }
-    }    
-}
\ No newline at end of file
+    }
+}
diff --git a/src/main/java/org/openpnp/util/UiUtils.java b/src/main/java/org/openpnp/util/UiUtils.java
index 10796d9df9..fc34e42ade 100755
--- a/src/main/java/org/openpnp/util/UiUtils.java
+++ b/src/main/java/org/openpnp/util/UiUtils.java
@@ -13,96 +13,91 @@
 import com.google.common.util.concurrent.FutureCallback;
 
 public class UiUtils {
-	/**
-	 * Functional interface for a Runnable that can throw an Exception
-	 * but returns no value. Splits the difference between Runnable and
-	 * Callable.
-	 */
-	public interface Thrunnable {
-		public void thrun() throws Exception;
-	}
-	
-	/**
-	 * Shortcut for submitMachineTask(Callable) which uses a Thrunnable instead.
-	 * This allows for simple tasks that may throw an Exception but return
-	 * nothing. 
-	 * @param thrunnable
-	 * @return
-	 */
-	public static Future<Void> submitUiMachineTask(
-    		final Thrunnable thrunnable) {
-		return submitUiMachineTask(() -> {
-			thrunnable.thrun();
-			return null;
-		});
-	}
-	
-	/**
-	 * Wrapper for submitMachineTask(Callable, Consumer, Consumer) which
-	 * ignores the return value in onSuccess and shows a MessageBox
-	 * when an Exception is thrown. Handy for simple tasks that don't care
-	 * about the return value but want to notify the user in case of failure.
-	 * Ideal for running Machine tasks from ActionListeners.
-	 * @param callable
-	 * @return
-	 */
-	public static <T> Future<T> submitUiMachineTask(
-    		final Callable<T> callable) {
-		return submitUiMachineTask(
-				callable, 
-				(result) -> {},
-				(t) -> {
-					MessageBoxes.errorBox(MainFrame.mainFrame, "Error", t);
-				});
-	}
-	
-	/**
-	 * Functional version of Machine.submit which guarantees that the the
-	 * onSuccess and onFailure handlers will be run on the Swing event thread.
-	 * @param callable
-	 * @param onSuccess
-	 * @param onFailure
-	 * @return
-	 */
-	public static <T> Future<T> submitUiMachineTask(
-    		final Callable<T> callable,
-    		final Consumer<T> onSuccess,
-    		final Consumer<Throwable> onFailure) {
-    	return Configuration.get().getMachine().submit(callable, new FutureCallback<T>() {
-			@Override
-			public void onSuccess(T result) {
-				try {
-					SwingUtilities.invokeAndWait(() -> onSuccess.accept(result));
-				}
-				catch (Exception e) {
-					e.printStackTrace();
-				}
-			}
+    /**
+     * Functional interface for a Runnable that can throw an Exception but returns no value. Splits
+     * the difference between Runnable and Callable.
+     */
+    public interface Thrunnable {
+        public void thrun() throws Exception;
+    }
+
+    /**
+     * Shortcut for submitMachineTask(Callable) which uses a Thrunnable instead. This allows for
+     * simple tasks that may throw an Exception but return nothing.
+     * 
+     * @param thrunnable
+     * @return
+     */
+    public static Future<Void> submitUiMachineTask(final Thrunnable thrunnable) {
+        return submitUiMachineTask(() -> {
+            thrunnable.thrun();
+            return null;
+        });
+    }
+
+    /**
+     * Wrapper for submitMachineTask(Callable, Consumer, Consumer) which ignores the return value in
+     * onSuccess and shows a MessageBox when an Exception is thrown. Handy for simple tasks that
+     * don't care about the return value but want to notify the user in case of failure. Ideal for
+     * running Machine tasks from ActionListeners.
+     * 
+     * @param callable
+     * @return
+     */
+    public static <T> Future<T> submitUiMachineTask(final Callable<T> callable) {
+        return submitUiMachineTask(callable, (result) -> {
+        } , (t) -> {
+            MessageBoxes.errorBox(MainFrame.mainFrame, "Error", t);
+        });
+    }
+
+    /**
+     * Functional version of Machine.submit which guarantees that the the onSuccess and onFailure
+     * handlers will be run on the Swing event thread.
+     * 
+     * @param callable
+     * @param onSuccess
+     * @param onFailure
+     * @return
+     */
+    public static <T> Future<T> submitUiMachineTask(final Callable<T> callable,
+            final Consumer<T> onSuccess, final Consumer<Throwable> onFailure) {
+        return Configuration.get().getMachine().submit(callable, new FutureCallback<T>() {
+            @Override
+            public void onSuccess(T result) {
+                try {
+                    SwingUtilities.invokeAndWait(() -> onSuccess.accept(result));
+                }
+                catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+
+            @Override
+            public void onFailure(Throwable t) {
+                try {
+                    SwingUtilities.invokeAndWait(() -> onFailure.accept(t));
+                }
+                catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+    }
 
-			@Override
-			public void onFailure(Throwable t) {
-				try {
-					SwingUtilities.invokeAndWait(() -> onFailure.accept(t));
-				}
-				catch (Exception e) {
-					e.printStackTrace();
-				}
-			}
-    	});
+    /**
+     * Functional wrapper for actions that may throw an Exception. Presents an error box to the user
+     * with the Exception contents if one is thrown. Basically saves like 5 lines of boilerplate in
+     * actions.
+     * 
+     * @param thrunnable
+     */
+    public static void messageBoxOnException(Thrunnable thrunnable) {
+        try {
+            thrunnable.thrun();
+        }
+        catch (Exception e) {
+            MessageBoxes.errorBox(MainFrame.mainFrame, "Error", e);
+        }
     }
-	
-	/**
-	 * Functional wrapper for actions that may throw an Exception. Presents
-	 * an error box to the user with the Exception contents if one is thrown.
-	 * Basically saves like 5 lines of boilerplate in actions.
-	 * @param thrunnable
-	 */
-	public static void messageBoxOnException(Thrunnable thrunnable) {
-		try {
-			thrunnable.thrun();
-		}
-		catch (Exception e) {
-			MessageBoxes.errorBox(MainFrame.mainFrame, "Error", e);
-		}
-	}
 }
diff --git a/src/main/java/org/openpnp/util/Utils2D.java b/src/main/java/org/openpnp/util/Utils2D.java
index d38c8a53ba..3bfdd66ad4 100755
--- a/src/main/java/org/openpnp/util/Utils2D.java
+++ b/src/main/java/org/openpnp/util/Utils2D.java
@@ -1,25 +1,22 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
  *
- * Changelog:
- * 03/10/2012 Ami: Add rotate using center point
+ * Changelog: 03/10/2012 Ami: Add rotate using center point
  */
 
 package org.openpnp.util;
@@ -31,114 +28,116 @@
 
 
 public class Utils2D {
-	public static Point rotateTranslateScalePoint(Point point, double c, double x, double y, double scaleX, double scaleY) {
-		point = rotatePoint(point, c);
-		point = translatePoint(point, x, y);
-		point = scalePoint(point, scaleX, scaleY);
-		return point;
-	}
-	
-	public static Point rotateTranslateCenterPoint(Point point, double c, double x, double y, Point center) {
-		point = translatePoint(point, center.getX() * -1, center.getY() * -1);
-		point = rotatePoint(point, c);
-		point = translatePoint(point,center.getX(), center.getY());
-		point = translatePoint(point, x, y);
-	
-		return point;
-	}
-	
-	public static Point translatePoint(Point point, double x, double y) {
-		return new Point(point.getX() + x, point.getY() + y);
-	}
-	
-	/**
-	 * Rotation is counter-clockwise for positive angles.
-	 * @param point
-	 * @param c
-	 * @return
-	 */
-	public static Point rotatePoint(Point point, double c) {
-		double x = point.getX();
-		double y = point.getY();
-		
-		// convert degrees to radians
-		c = Math.toRadians(c);
-		
-		// rotate the points
-		double xn = x * Math.cos(c) - y * Math.sin(c);
-		double yn = x * Math.sin(c) + y * Math.cos(c);
-		
-		x = xn;
-		y = yn;
-		
-		return new Point(x, y);
-	}
-	
-	public static Point scalePoint(Point point, double scaleX, double scaleY) {
-		return new Point(point.getX() * scaleX, point.getY() * scaleY);
-	}
-	
-	public static Location calculateBoardPlacementLocation(BoardLocation bl, Location placementLocation) {
-		return calculateBoardPlacementLocation(
-				bl.getLocation(),
-				bl.getSide(),
-				bl.getBoard().getDimensions().getX(),
-				placementLocation);
-	}
-	
-	public static Location calculateBoardPlacementLocation(Location boardLocation, Side side, double offset, Location placementLocation) {
+    public static Point rotateTranslateScalePoint(Point point, double c, double x, double y,
+            double scaleX, double scaleY) {
+        point = rotatePoint(point, c);
+        point = translatePoint(point, x, y);
+        point = scalePoint(point, scaleX, scaleY);
+        return point;
+    }
+
+    public static Point rotateTranslateCenterPoint(Point point, double c, double x, double y,
+            Point center) {
+        point = translatePoint(point, center.getX() * -1, center.getY() * -1);
+        point = rotatePoint(point, c);
+        point = translatePoint(point, center.getX(), center.getY());
+        point = translatePoint(point, x, y);
+
+        return point;
+    }
+
+    public static Point translatePoint(Point point, double x, double y) {
+        return new Point(point.getX() + x, point.getY() + y);
+    }
+
+    /**
+     * Rotation is counter-clockwise for positive angles.
+     * 
+     * @param point
+     * @param c
+     * @return
+     */
+    public static Point rotatePoint(Point point, double c) {
+        double x = point.getX();
+        double y = point.getY();
+
+        // convert degrees to radians
+        c = Math.toRadians(c);
+
+        // rotate the points
+        double xn = x * Math.cos(c) - y * Math.sin(c);
+        double yn = x * Math.sin(c) + y * Math.cos(c);
+
+        x = xn;
+        y = yn;
+
+        return new Point(x, y);
+    }
+
+    public static Point scalePoint(Point point, double scaleX, double scaleY) {
+        return new Point(point.getX() * scaleX, point.getY() * scaleY);
+    }
+
+    public static Location calculateBoardPlacementLocation(BoardLocation bl,
+            Location placementLocation) {
+        return calculateBoardPlacementLocation(bl.getLocation(), bl.getSide(),
+                bl.getBoard().getDimensions().getX(), placementLocation);
+    }
+
+    public static Location calculateBoardPlacementLocation(Location boardLocation, Side side,
+            double offset, Location placementLocation) {
         // We will work in the units of the placementLocation, so convert
         // anything that isn't in those units to it.
         boardLocation = boardLocation.convertToUnits(placementLocation.getUnits());
-        
+
         // If we are placing the bottom of the board we need to invert
         // the placement location.
         if (side == Side.Bottom) {
             placementLocation = placementLocation.invert(true, false, false, false)
-            		.add(new Location(placementLocation.getUnits(), offset, 0.0, 0.0, 0.0));
+                    .add(new Location(placementLocation.getUnits(), offset, 0.0, 0.0, 0.0));
         }
 
         // Rotate and translate the point into the same coordinate space
         // as the board
-        placementLocation = placementLocation.rotateXy(boardLocation.getRotation()).addWithRotation(boardLocation);
+        placementLocation = placementLocation.rotateXy(boardLocation.getRotation())
+                .addWithRotation(boardLocation);
         return placementLocation;
-	}
-
-
-	public static Location calculateBoardPlacementLocationInverse(BoardLocation boardLocation, Location placementLocation) {
-		return calculateBoardPlacementLocationInverse(
-				boardLocation.getLocation(), 
-				boardLocation.getSide(),
-				boardLocation.getBoard().getDimensions().getX(),
-				placementLocation); 
-	}
-	
-	public static Location calculateBoardPlacementLocationInverse(Location boardLocation, Side side, double offset, Location placementLocation) {
-		// inverse steps of calculateBoardPlacementLocation
+    }
+
+
+    public static Location calculateBoardPlacementLocationInverse(BoardLocation boardLocation,
+            Location placementLocation) {
+        return calculateBoardPlacementLocationInverse(boardLocation.getLocation(),
+                boardLocation.getSide(), boardLocation.getBoard().getDimensions().getX(),
+                placementLocation);
+    }
+
+    public static Location calculateBoardPlacementLocationInverse(Location boardLocation, Side side,
+            double offset, Location placementLocation) {
+        // inverse steps of calculateBoardPlacementLocation
         boardLocation = boardLocation.convertToUnits(placementLocation.getUnits());
-        placementLocation = placementLocation.subtractWithRotation(boardLocation).rotateXy(-boardLocation.getRotation());
-        if (side==Side.Bottom)  {
+        placementLocation = placementLocation.subtractWithRotation(boardLocation)
+                .rotateXy(-boardLocation.getRotation());
+        if (side == Side.Bottom) {
             placementLocation = placementLocation.invert(true, false, false, false)
-            		.add(new Location(placementLocation.getUnits(), offset, 0.0, 0.0, 0.0));
+                    .add(new Location(placementLocation.getUnits(), offset, 0.0, 0.0, 0.0));
         }
         return placementLocation;
-	}
-	
-   /**
-     * Given two "ideal" unrotated and unoffset Locations and two matching
-     * "actual" Locations that have been offset and rotated, calculate the
-     * angle of rotation and offset between them.
+    }
+
+    /**
+     * Given two "ideal" unrotated and unoffset Locations and two matching "actual" Locations that
+     * have been offset and rotated, calculate the angle of rotation and offset between them.
+     * 
+     * Angle is the difference between the angles between the two ideal Locations and the two actual
+     * Locations.
      * 
-     * Angle is the difference between the angles between the two ideal
-     * Locations and the two actual Locations.
+     * Offset is the difference between one of the ideal Locations having been rotated by Angle and
+     * the matching actual Location.
      * 
-     * Offset is the difference between one of the ideal Locations having been
-     * rotated by Angle and the matching actual Location.
-     *  
-     * @deprecated (2016/01/30) Please see calculateAngleAndOffset2.
-     * This function is no longer used in the core codebase, but it's being
-     * left here in case other users have incorporated it into their changes.
-     * It may be removed in the future.
+     * @deprecated (2016/01/30) Please see calculateAngleAndOffset2. This function is no longer used
+     *             in the core codebase, but it's being left here in case other users have
+     *             incorporated it into their changes. It may be removed in the future.
      * 
      * @param idealA
      * @param idealB
@@ -146,42 +145,45 @@ public static Location calculateBoardPlacementLocationInverse(Location boardLoca
      * @param actualB
      * @return
      */
-    public static Location calculateAngleAndOffset(Location idealA, Location idealB, Location actualA, Location actualB) {
+    public static Location calculateAngleAndOffset(Location idealA, Location idealB,
+            Location actualA, Location actualB) {
         idealB = idealB.convertToUnits(idealA.getUnits());
         actualA = actualA.convertToUnits(idealA.getUnits());
         actualB = actualB.convertToUnits(idealA.getUnits());
 
-        double angle = Math.toDegrees(Math.atan2(actualA.getY() - actualB.getY(), actualA.getX() - actualB.getX())
-                - Math.atan2(idealA.getY() - idealB.getY(), idealA.getX() - idealB.getX()));
-        
+        double angle = Math.toDegrees(
+                Math.atan2(actualA.getY() - actualB.getY(), actualA.getX() - actualB.getX())
+                        - Math.atan2(idealA.getY() - idealB.getY(), idealA.getX() - idealB.getX()));
+
         Location idealARotated = idealA.rotateXy(angle);
-        
+
         Location offset = actualA.subtract(idealARotated);
-        while(angle<-180.) { angle+=360; }
-        while(angle> 180.) { angle-=360; }
-        
+        while (angle < -180.) {
+            angle += 360;
+        }
+        while (angle > 180.) {
+            angle -= 360;
+        }
+
         return new Location(idealA.getUnits(), offset.getX(), offset.getY(), 0, angle);
     }
-    
+
     /**
-     * Given two "ideal" Locations and two matching "actual" Locations
-     * calculate the difference in rotation and offset between them.
+     * Given two "ideal" Locations and two matching "actual" Locations calculate the difference in
+     * rotation and offset between them.
      * 
-     * Angle is the difference in angle between the line through the two
-     * ideal Locations and the line through the two actual locations.
+     * Angle is the difference in angle between the line through the two ideal Locations and the
+     * line through the two actual locations.
      * 
-     * Offset is the difference in position of the first ideal and first
-     * actual Location.
+     * Offset is the difference in position of the first ideal and first actual Location.
      * 
-     * This function differs from calculateAngleAndOffset in that it expects
-     * the ideal and actual locations to be close to each other, and instead
-     * of returning the total offset and angle this function only returns
-     * the difference between the ideal and actual.
+     * This function differs from calculateAngleAndOffset in that it expects the ideal and actual
+     * locations to be close to each other, and instead of returning the total offset and angle this
+     * function only returns the difference between the ideal and actual.
      * 
-     * This function is intended to be used with the fiducial checker and
-     * has been tested with it. The function above used to be used for the
-     * fidicual checker but did not handle bottom coordinates correctly
-     * and it's still not clear why.
+     * This function is intended to be used with the fiducial checker and has been tested with it.
+     * The function above used to be used for the fidicual checker but did not handle bottom
+     * coordinates correctly and it's still not clear why.
      * 
      * @param idealA
      * @param idealB
@@ -189,18 +191,21 @@ public static Location calculateAngleAndOffset(Location idealA, Location idealB,
      * @param actualB
      * @return
      */
-    public static Location calculateAngleAndOffset2(Location idealA, Location idealB, Location actualA, Location actualB) {
+    public static Location calculateAngleAndOffset2(Location idealA, Location idealB,
+            Location actualA, Location actualB) {
         idealB = idealB.convertToUnits(idealA.getUnits());
         actualA = actualA.convertToUnits(idealA.getUnits());
         actualB = actualB.convertToUnits(idealA.getUnits());
-        
-        double idealAngle = Math.toDegrees(Math.atan2(idealB.getY() - idealA.getY(), idealB.getX() - idealA.getX())); 
-        double actualAngle = Math.toDegrees(Math.atan2(actualB.getY() - actualA.getY(), actualB.getX() - actualA.getX()));
-        
+
+        double idealAngle = Math.toDegrees(
+                Math.atan2(idealB.getY() - idealA.getY(), idealB.getX() - idealA.getX()));
+        double actualAngle = Math.toDegrees(
+                Math.atan2(actualB.getY() - actualA.getY(), actualB.getX() - actualA.getX()));
+
         double angle = actualAngle - idealAngle;
-        
+
         Location offset = actualA.subtract(idealA);
-        
+
         return new Location(idealA.getUnits(), offset.getX(), offset.getY(), 0, angle);
     }
 }
diff --git a/src/main/java/org/openpnp/util/VisionUtils.java b/src/main/java/org/openpnp/util/VisionUtils.java
index f69c16ce4f..3c31e51701 100755
--- a/src/main/java/org/openpnp/util/VisionUtils.java
+++ b/src/main/java/org/openpnp/util/VisionUtils.java
@@ -10,19 +10,18 @@
 
 public class VisionUtils {
     /**
-     * Given pixel coordinates within the frame of the Camera's image, get
-     * the offsets from Camera center to the coordinates in Camera space
-     * and units. The resulting value is the distance the Camera
-     * can be moved to be centered over the pixel coordinates.
+     * Given pixel coordinates within the frame of the Camera's image, get the offsets from Camera
+     * center to the coordinates in Camera space and units. The resulting value is the distance the
+     * Camera can be moved to be centered over the pixel coordinates.
      * 
-     * Example: If the x, y coordinates describe a position above and to the
-     * left of the center of the camera the offsets will be -,+.
-     *  
-     * If the coordinates position are below and to the right of center the
-     * offsets will be +, -.
+     * Example: If the x, y coordinates describe a position above and to the left of the center of
+     * the camera the offsets will be -,+.
+     * 
+     * If the coordinates position are below and to the right of center the offsets will be +, -.
+     * 
+     * Calling camera.getLocation().add(getPixelCenterOffsets(...) will give you the location of x,
+     * y with respect to the center of the camera.
      * 
-     * Calling camera.getLocation().add(getPixelCenterOffsets(...) will give
-     * you the location of x, y with respect to the center of the camera. 
      * @param camera
      * @param x
      * @param y
@@ -44,12 +43,13 @@ public static Location getPixelCenterOffsets(Camera camera, double x, double y)
 
         return new Location(camera.getUnitsPerPixel().getUnits(), offsetX, offsetY, 0, 0);
     }
-    
+
     /**
-     * Get the Location of a set of pixel coordinates referenced to the center
-     * of the given camera. This is a helper method that simply adds the
-     * offsets from {@link VisionUtils#getPixelCenterOffsets(Camera, double, double)}
-     * to the Camera's current location.
+     * Get the Location of a set of pixel coordinates referenced to the center of the given camera.
+     * This is a helper method that simply adds the offsets from
+     * {@link VisionUtils#getPixelCenterOffsets(Camera, double, double)} to the Camera's current
+     * location.
+     * 
      * @param camera
      * @param x
      * @param y
@@ -58,28 +58,29 @@ public static Location getPixelCenterOffsets(Camera camera, double x, double y)
     public static Location getPixelLocation(Camera camera, double x, double y) {
         return camera.getLocation().add(getPixelCenterOffsets(camera, x, y));
     }
-    
-    public static List<Location> sortLocationsByDistance(final Location origin, List<Location> locations) {
-    	// sort the results by distance from center ascending
+
+    public static List<Location> sortLocationsByDistance(final Location origin,
+            List<Location> locations) {
+        // sort the results by distance from center ascending
         Collections.sort(locations, new Comparator<Location>() {
             public int compare(Location o1, Location o2) {
-                Double o1d = origin.getLinearDistanceTo(o1); 
+                Double o1d = origin.getLinearDistanceTo(o1);
                 Double o2d = origin.getLinearDistanceTo(o2);
                 return o1d.compareTo(o2d);
             }
         });
         return locations;
     }
-    
+
     public static double toPixels(Length length, Camera camera) {
-    	// convert inputs to the same units
-    	Location unitsPerPixel = camera.getUnitsPerPixel();
-    	length = length.convertToUnits(unitsPerPixel.getUnits());
+        // convert inputs to the same units
+        Location unitsPerPixel = camera.getUnitsPerPixel();
+        length = length.convertToUnits(unitsPerPixel.getUnits());
+
+        // we average the units per pixel because circles can't be ovals
+        double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
 
-    	// we average the units per pixel because circles can't be ovals
-    	double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
-    	
-    	// convert it all to pixels
-    	return length.getValue() / avgUnitsPerPixel;
+        // convert it all to pixels
+        return length.getValue() / avgUnitsPerPixel;
     }
 }
diff --git a/src/main/java/org/openpnp/util/XmlSerialize.java b/src/main/java/org/openpnp/util/XmlSerialize.java
index 0622a866ba..3ff84132f1 100755
--- a/src/main/java/org/openpnp/util/XmlSerialize.java
+++ b/src/main/java/org/openpnp/util/XmlSerialize.java
@@ -1,23 +1,21 @@
 /*
- 	Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
-*/
+ * Copyright (C) 2011 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ */
 
 package org.openpnp.util;
 
@@ -27,16 +25,16 @@
 import java.io.ByteArrayOutputStream;
 
 public class XmlSerialize {
-	public static String serialize(Object o) {
-		ByteArrayOutputStream bOut = new ByteArrayOutputStream();
-		XMLEncoder xmlEncoder = new XMLEncoder(bOut);
-		xmlEncoder.writeObject(o);
-		xmlEncoder.close();
-		return bOut.toString();
-	}
-	
-	public static Object deserialize(String s) {
-		XMLDecoder xmlDecoder = new XMLDecoder(new ByteArrayInputStream(s.getBytes()));
-		return xmlDecoder.readObject();
-	}
+    public static String serialize(Object o) {
+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();
+        XMLEncoder xmlEncoder = new XMLEncoder(bOut);
+        xmlEncoder.writeObject(o);
+        xmlEncoder.close();
+        return bOut.toString();
+    }
+
+    public static Object deserialize(String s) {
+        XMLDecoder xmlDecoder = new XMLDecoder(new ByteArrayInputStream(s.getBytes()));
+        return xmlDecoder.readObject();
+    }
 }
diff --git a/src/main/java/org/openpnp/vision/BottomVision.java b/src/main/java/org/openpnp/vision/BottomVision.java
index 0eb2a76e87..802b9d5ac1 100755
--- a/src/main/java/org/openpnp/vision/BottomVision.java
+++ b/src/main/java/org/openpnp/vision/BottomVision.java
@@ -27,7 +27,7 @@
 
 public class BottomVision {
     private static final Logger logger = LoggerFactory.getLogger(BottomVision.class);
-    
+
     private Map<Length, BufferedImage> backgroundImages = new HashMap<>();
 
     // TODO: Note that we're using the default nozzle here, but that won't work
@@ -35,118 +35,103 @@
     // nozzles and then use the right one for the background.
     public void preProcess(Job job) throws Exception {
         backgroundImages.clear();
-        
+
         Camera camera = getBottomVisionCamera();
         for (Head head : Configuration.get().getMachine().getHeads()) {
             head.moveToSafeZ(1.0);
             for (Nozzle nozzle : head.getNozzles()) {
                 MovableUtils.moveToLocationAtSafeZ(nozzle, camera.getLocation(), 1.0);
                 for (int i = 0; i < 360; i += 30) {
-                    Location location = camera.getLocation().addWithRotation(new Location(LengthUnit.Millimeters, 0, 0, 0, i));
+                    Location location = camera.getLocation()
+                            .addWithRotation(new Location(LengthUnit.Millimeters, 0, 0, 0, i));
                     nozzle.moveTo(location, 1.0);
                     BufferedImage image = camera.settleAndCapture();
                 }
                 nozzle.moveToSafeZ(1.0);
             }
         }
-        
-//        Nozzle nozzle = Configuration.get().getMachine().getDefaultHead().getDefaultNozzle();
-//        Camera camera = getBottomVisionCamera();
-//        
-//        // figure out all the unique part heights we need to deal with
-//        Set<Length> heights = new HashSet<Length>();
-//        for (BoardLocation boardLocation : job.getBoardLocations()) {
-//            Board board = boardLocation.getBoard();
-//            for (Placement placement : board.getPlacements()) {
-//                if (placement.getType() != Placement.Type.Place || placement.getSide() != boardLocation.getSide()) {
-//                    continue;
-//                }
-//                Part part = placement.getPart();
-//                heights.add(part.getHeight());
-//            }
-//        }
-//        
-//        // and get a list of nozzles that we'll need to image
-//        Set<Nozzle> nozzles = new HashSet<Nozzle>();
-//        
-//        logger.debug("Capturing backgrounds for heights: {}", heights);
-//        MovableUtils.moveToLocationAtSafeZ(nozzle, camera.getLocation(), 1.0);
-//        for (Length height : heights) {
-//            Location heightLocation = new Location(height.getUnits(), 0, 0, height.getValue(), 0);
-//            Location location = camera.getLocation().add(heightLocation);
-//            nozzle.moveTo(location, 1.0);
-//            backgroundImages.put(height, camera.settleAndCapture());
-//        }
-//        nozzle.moveToSafeZ(1.0);
+
+        // Nozzle nozzle = Configuration.get().getMachine().getDefaultHead().getDefaultNozzle();
+        // Camera camera = getBottomVisionCamera();
+        //
+        // // figure out all the unique part heights we need to deal with
+        // Set<Length> heights = new HashSet<Length>();
+        // for (BoardLocation boardLocation : job.getBoardLocations()) {
+        // Board board = boardLocation.getBoard();
+        // for (Placement placement : board.getPlacements()) {
+        // if (placement.getType() != Placement.Type.Place || placement.getSide() !=
+        // boardLocation.getSide()) {
+        // continue;
+        // }
+        // Part part = placement.getPart();
+        // heights.add(part.getHeight());
+        // }
+        // }
+        //
+        // // and get a list of nozzles that we'll need to image
+        // Set<Nozzle> nozzles = new HashSet<Nozzle>();
+        //
+        // logger.debug("Capturing backgrounds for heights: {}", heights);
+        // MovableUtils.moveToLocationAtSafeZ(nozzle, camera.getLocation(), 1.0);
+        // for (Length height : heights) {
+        // Location heightLocation = new Location(height.getUnits(), 0, 0, height.getValue(), 0);
+        // Location location = camera.getLocation().add(heightLocation);
+        // nozzle.moveTo(location, 1.0);
+        // backgroundImages.put(height, camera.settleAndCapture());
+        // }
+        // nozzle.moveToSafeZ(1.0);
     }
-    
-    public Location findOffsets(Part part, Nozzle nozzle)
-            throws Exception {
+
+    public Location findOffsets(Part part, Nozzle nozzle) throws Exception {
         Camera camera = getBottomVisionCamera();
-        
+
         // Create a location that is the Camera's X, Y, it's Z + part height
         // and a rotation of 0.
         Location startLocation = camera.getLocation();
         Length partHeight = part.getHeight();
-        Location partHeightLocation = new Location(partHeight.getUnits(), 0, 0, partHeight.getValue(), 0);
-        startLocation = startLocation
-                .add(partHeightLocation)
-                .derive(null, null, null, 0d);
+        Location partHeightLocation =
+                new Location(partHeight.getUnits(), 0, 0, partHeight.getValue(), 0);
+        startLocation = startLocation.add(partHeightLocation).derive(null, null, null, 0d);
 
         MovableUtils.moveToLocationAtSafeZ(nozzle, startLocation, 1.0);
-        
+
         BufferedImage backgroundImage = backgroundImages.get(part.getHeight());
-        
+
         File debugDir = new File("/Users/jason/Desktop/debug/" + System.currentTimeMillis());
         debugDir.mkdirs();
-        
+
         for (int i = 0; i < 6; i++) {
             File backgroundFile = new File(debugDir, i + "_background.png");
             File foregroundFile = new File(debugDir, i + "_foreground.png");
             File absDiffFile = new File(debugDir, i + "_asdiff.png");
             File processedFile = new File(debugDir, i + "_processed.png");
-            
+
             List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
             List<RotatedRect> rects = new ArrayList<RotatedRect>();
-            BufferedImage filteredImage = new FluentCv()
-                .setCamera(camera)
-                
-                .toMat(backgroundImage)
-                .write(backgroundFile)
-                .toGray()
-                .blurGaussian(3, "background")
-                
-                .settleAndCapture("original")
-                .write(foregroundFile)
-                .toGray()
-                .blurGaussian(3)
-                
-                .absDiff("background")
-                .write(absDiffFile)
-                
-                .blurGaussian(13)
-                .findEdgesRobertsCross()
-                .threshold(30)
-                .findContours(contours)
-                .recall("original")
-                .drawContours(contours, null, 1)
-                .getContourMaxRects(contours, rects)
-                .drawRects(rects, null, 2)
-                .write(processedFile)
-                .toBufferedImage();
-            
+            BufferedImage filteredImage = new FluentCv().setCamera(camera)
+
+                    .toMat(backgroundImage).write(backgroundFile).toGray()
+                    .blurGaussian(3, "background")
+
+                    .settleAndCapture("original").write(foregroundFile).toGray().blurGaussian(3)
+
+                    .absDiff("background").write(absDiffFile)
+
+                    .blurGaussian(13).findEdgesRobertsCross().threshold(30).findContours(contours)
+                    .recall("original").drawContours(contours, null, 1)
+                    .getContourMaxRects(contours, rects).drawRects(rects, null, 2)
+                    .write(processedFile).toBufferedImage();
+
             CameraView cameraView = MainFrame.mainFrame.cameraPanel.getCameraView(camera);
             cameraView.showFilteredImage(filteredImage, 3000);
-            
+
             RotatedRect rect = rects.get(0);
             System.out.println(rect);
-                    
+
             // Create the offsets object. This is the physical distance from
             // the center of the camera to the located part.
-            Location offsets = VisionUtils.getPixelCenterOffsets(
-                    camera,
-                    rect.center.x, 
-                    rect.center.y);
+            Location offsets =
+                    VisionUtils.getPixelCenterOffsets(camera, rect.center.x, rect.center.y);
 
             // We assume that the part is never picked more than 45º rotated
             // so if OpenCV tells us it's rotated more than 45º we correct
@@ -164,19 +149,17 @@ public Location findOffsets(Part part, Nozzle nozzle)
             // Set the angle on the offsets.
             offsets = offsets.derive(null, null, null, angle);
             System.out.println("offsets " + offsets);
-            
+
             // Move the nozzle so that the part is oriented correctly over the
             // camera.
-            Location location = nozzle
-                    .getLocation()
-                    .subtractWithRotation(offsets);
+            Location location = nozzle.getLocation().subtractWithRotation(offsets);
             nozzle.moveTo(location, 1.0);
         }
-        
+
         nozzle.moveToSafeZ(1.0);
         return new Location(LengthUnit.Millimeters, 0, 0, 0, 0);
-    } 
-    
+    }
+
     private Camera getBottomVisionCamera() throws Exception {
         for (Camera camera : Configuration.get().getMachine().getCameras()) {
             if (camera.getLooking() == Camera.Looking.Up) {
diff --git a/src/main/java/org/openpnp/vision/FiducialLocator.java b/src/main/java/org/openpnp/vision/FiducialLocator.java
index c816220f86..04d28cd2cd 100755
--- a/src/main/java/org/openpnp/vision/FiducialLocator.java
+++ b/src/main/java/org/openpnp/vision/FiducialLocator.java
@@ -32,36 +32,34 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Implements an algorithm for finding a set of fiducials on a board and
- * returning the correct orientation for the board. 
+ * Implements an algorithm for finding a set of fiducials on a board and returning the correct
+ * orientation for the board.
  */
 public class FiducialLocator {
-    private static final Logger logger = LoggerFactory
-            .getLogger(FiducialLocator.class);
-    
+    private static final Logger logger = LoggerFactory.getLogger(FiducialLocator.class);
+
     public FiducialLocator() {
-        
+
     }
-    
+
     public static Location locateBoard(BoardLocation boardLocation) throws Exception {
         // Find the fids in the board
         IdentifiableList<Placement> fiducials = getFiducials(boardLocation);
-        
+
         if (fiducials.size() < 2) {
-            throw new Exception(
-                String.format(
+            throw new Exception(String.format(
                     "The board side contains only %d placements marked as fiducials, but at least 2 are required.",
-                    fiducials.size())); 
+                    fiducials.size()));
         }
-        
+
         // Find the two that are most distant from each other
         List<Placement> mostDistant = getMostDistantPlacements(fiducials);
-        
+
         Placement placementA = mostDistant.get(0);
         Placement placementB = mostDistant.get(1);
 
         logger.debug("Chose {} and {}", placementA.getId(), placementB.getId());
-        
+
         // Run the fiducial check on each and get their actual locations
         Location actualLocationA = getFiducialLocation(boardLocation, placementA);
         if (actualLocationA == null) {
@@ -71,99 +69,97 @@ public static Location locateBoard(BoardLocation boardLocation) throws Exception
         if (actualLocationB == null) {
             throw new Exception("Unable to locate second fiducial.");
         }
-        
+
         // Calculate the linear distance between the ideal points and the
         // located points. If they differ by more than a few percent we
         // probably made a mistake.
-        double fidDistance = Math.abs(placementA.getLocation().getLinearDistanceTo(placementB.getLocation()));
+        double fidDistance =
+                Math.abs(placementA.getLocation().getLinearDistanceTo(placementB.getLocation()));
         double visionDistance = Math.abs(actualLocationA.getLinearDistanceTo(actualLocationB));
         if (Math.abs(fidDistance - visionDistance) > fidDistance * 0.01) {
             throw new Exception("Located fiducials are more than 1% away from expected.");
         }
-                
+
         // Calculate the angle and offset from the results
-        Location idealLocationA = Utils2D.calculateBoardPlacementLocation(boardLocation, placementA.getLocation());
-        Location idealLocationB = Utils2D.calculateBoardPlacementLocation(boardLocation, placementB.getLocation());
-        Location location = Utils2D.calculateAngleAndOffset2(
-                idealLocationA, 
-                idealLocationB, 
-                actualLocationA,
-                actualLocationB);
-        
+        Location idealLocationA =
+                Utils2D.calculateBoardPlacementLocation(boardLocation, placementA.getLocation());
+        Location idealLocationB =
+                Utils2D.calculateBoardPlacementLocation(boardLocation, placementB.getLocation());
+        Location location = Utils2D.calculateAngleAndOffset2(idealLocationA, idealLocationB,
+                actualLocationA, actualLocationB);
+
         location = boardLocation.getLocation().addWithRotation(location);
-        location = location.derive(
-                null, 
-                null, 
-                boardLocation.getLocation().convertToUnits(location.getUnits()).getZ(), 
-                null);
+        location = location.derive(null, null,
+                boardLocation.getLocation().convertToUnits(location.getUnits()).getZ(), null);
 
         return location;
     }
-    
-    public static Location getFiducialLocation(Footprint footprint, Camera camera) throws Exception {
+
+    public static Location getFiducialLocation(Footprint footprint, Camera camera)
+            throws Exception {
         // Create the template
         BufferedImage template = createTemplate(camera.getUnitsPerPixel(), footprint);
-        
+
         // Wait for camera to settle
         Thread.sleep(camera.getSettleTimeMs());
         // Perform vision operation
         return getBestTemplateMatch(camera, template);
     }
-    
+
     /**
-     * Given a placement containing a fiducial, attempt to find the fiducial
-     * using the vision system. The function first moves the camera to the
-     * ideal location of the fiducial based on the board location. It then
-     * performs a template match against a template generated from the
-     * fiducial's footprint. These steps are performed thrice to "home in"
-     * on the fiducial. Finally, the location is returned. If the fiducial
-     * was not able to be located with any degree of certainty the function
-     * returns null.
+     * Given a placement containing a fiducial, attempt to find the fiducial using the vision
+     * system. The function first moves the camera to the ideal location of the fiducial based on
+     * the board location. It then performs a template match against a template generated from the
+     * fiducial's footprint. These steps are performed thrice to "home in" on the fiducial. Finally,
+     * the location is returned. If the fiducial was not able to be located with any degree of
+     * certainty the function returns null.
+     * 
      * @param fid
      * @return
      * @throws Exception
      */
-    private static Location getFiducialLocation(BoardLocation boardLocation, Placement fid) throws Exception {
-        Camera camera = Configuration
-            .get()
-            .getMachine()
-            .getDefaultHead()
-            .getDefaultCamera();
-        
+    private static Location getFiducialLocation(BoardLocation boardLocation, Placement fid)
+            throws Exception {
+        Camera camera = Configuration.get().getMachine().getDefaultHead().getDefaultCamera();
+
         logger.debug("Locating {}", fid.getId());
-        
+
         Part part = fid.getPart();
         if (part == null) {
-        	throw new Exception(String.format("Fiducial %s does not have a valid part assigned.", fid.getId()));
+            throw new Exception(
+                    String.format("Fiducial %s does not have a valid part assigned.", fid.getId()));
         }
-        
+
         org.openpnp.model.Package pkg = part.getPackage();
         if (pkg == null) {
-        	throw new Exception(String.format("Part %s does not have a valid package assigned.", 
-        			part.getId()));
+            throw new Exception(
+                    String.format("Part %s does not have a valid package assigned.", part.getId()));
         }
-        
-        Footprint footprint = pkg.getFootprint(); 
+
+        Footprint footprint = pkg.getFootprint();
         if (footprint == null) {
-        	throw new Exception(String.format("Package %s does not have a valid footprint. See https://github.com/openpnp/openpnp/wiki/Fiducials", 
-        			pkg.getId()));
+            throw new Exception(String.format(
+                    "Package %s does not have a valid footprint. See https://github.com/openpnp/openpnp/wiki/Fiducials",
+                    pkg.getId()));
         }
-        
+
         if (footprint.getShape() == null) {
-        	throw new Exception(String.format("Package %s has an invalid or empty footprint.  See https://github.com/openpnp/openpnp/wiki/Fiducials",
-        			pkg.getId()));
+            throw new Exception(String.format(
+                    "Package %s has an invalid or empty footprint.  See https://github.com/openpnp/openpnp/wiki/Fiducials",
+                    pkg.getId()));
         }
-        
+
         // Create the template
-        BufferedImage template = createTemplate(camera.getUnitsPerPixel(), fid.getPart().getPackage().getFootprint());
-        
+        BufferedImage template = createTemplate(camera.getUnitsPerPixel(),
+                fid.getPart().getPackage().getFootprint());
+
         // Move to where we expect to find the fid
-        Location location = Utils2D.calculateBoardPlacementLocation(
-        		boardLocation, fid.getLocation());
+        Location location =
+                Utils2D.calculateBoardPlacementLocation(boardLocation, fid.getLocation());
         logger.debug("Looking for {} at {}", fid.getId(), location);
         MovableUtils.moveToLocationAtSafeZ(camera, location, 1.0);
 
-        
+
         for (int i = 0; i < 3; i++) {
             // Wait for camera to settle
             Thread.sleep(camera.getSettleTimeMs());
@@ -177,46 +173,50 @@ private static Location getFiducialLocation(BoardLocation boardLocation, Placeme
             // Move to where we actually found the fid
             camera.moveTo(location, 1.0);
         }
-        
+
         return location;
     }
-    
-    private static Location getBestTemplateMatch(final Camera camera, BufferedImage template) throws Exception {
+
+    private static Location getBestTemplateMatch(final Camera camera, BufferedImage template)
+            throws Exception {
         VisionProvider visionProvider = camera.getVisionProvider();
-        
+
         List<TemplateMatch> matches = visionProvider.getTemplateMatches(template);
-        
+
         if (matches.isEmpty()) {
             return null;
         }
-        
+
         // getTemplateMatches returns results in order of score, but we're
         // more interested in the result closest to the expected location
         Collections.sort(matches, new Comparator<TemplateMatch>() {
             @Override
             public int compare(TemplateMatch o1, TemplateMatch o2) {
-                double d1 = o1.location.getLinearDistanceTo(camera.getLocation()); 
-                double d2 = o2.location.getLinearDistanceTo(camera.getLocation()); 
+                double d1 = o1.location.getLinearDistanceTo(camera.getLocation());
+                double d2 = o2.location.getLinearDistanceTo(camera.getLocation());
                 return Double.compare(d1, d2);
             }
         });
 
         return matches.get(0).location;
     }
-    
+
     /**
-     * Create a template image based on a Placement's footprint. The image
-     * will be scaled to match the dimensions of the current camera.
+     * Create a template image based on a Placement's footprint. The image will be scaled to match
+     * the dimensions of the current camera.
+     * 
      * @param fid
      * @return
      */
-    private static BufferedImage createTemplate(Location unitsPerPixel, Footprint footprint) throws Exception {
+    private static BufferedImage createTemplate(Location unitsPerPixel, Footprint footprint)
+            throws Exception {
         Shape shape = footprint.getShape();
-        
+
         if (shape == null) {
-        	throw new Exception("Invalid footprint found, unable to create template for fiducial match.");
+            throw new Exception(
+                    "Invalid footprint found, unable to create template for fiducial match.");
         }
-        
+
         // Determine the scaling factor to go from Outline units to
         // Camera units.
         Length l = new Length(1, footprint.getUnits());
@@ -225,40 +225,40 @@ private static BufferedImage createTemplate(Location unitsPerPixel, Footprint fo
 
         // Create a transform to scale the Shape by
         AffineTransform tx = new AffineTransform();
-        
+
         // First we scale by units to convert the units and then we scale
         // by the camera X and Y units per pixels to get pixel locations.
         tx.scale(unitScale, unitScale);
         tx.scale(1.0 / unitsPerPixel.getX(), 1.0 / unitsPerPixel.getY());
-        
+
         // Transform the Shape and draw it out.
         shape = tx.createTransformedShape(shape);
-        
+
         Rectangle2D bounds = shape.getBounds2D();
-        
+
         // Make the image 50% bigger than the shape. This gives better
         // recognition performance because it allows some border around the edges.
         double width = bounds.getWidth() * 1.5;
         double height = bounds.getHeight() * 1.5;
-        BufferedImage template = new BufferedImage((int) width, (int) height, BufferedImage.TYPE_INT_ARGB);
+        BufferedImage template =
+                new BufferedImage((int) width, (int) height, BufferedImage.TYPE_INT_ARGB);
         Graphics2D g2d = (Graphics2D) template.getGraphics();
-        
+
         g2d.setStroke(new BasicStroke(1f));
-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
-                RenderingHints.VALUE_ANTIALIAS_ON);
+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
         g2d.setColor(Color.white);
         // center the drawing
         g2d.translate(width / 2, height / 2);
         g2d.fill(shape);
-        
+
         g2d.dispose();
-        
+
         return template;
     }
 
     /**
-     * Given a List of Placements, find the two that are the most distant from
-     * each other.
+     * Given a List of Placements, find the two that are the most distant from each other.
+     * 
      * @param fiducials
      * @return
      */
@@ -286,7 +286,7 @@ private static BufferedImage createTemplate(Location unitsPerPixel, Footprint fo
         results.add(maxB);
         return results;
     }
-    
+
     private static IdentifiableList<Placement> getFiducials(BoardLocation boardLocation) {
         Board board = boardLocation.getBoard();
         IdentifiableList<Placement> fiducials = new IdentifiableList<>();
diff --git a/src/main/java/org/openpnp/vision/FluentCv.java b/src/main/java/org/openpnp/vision/FluentCv.java
index a01873728d..45f8adba3c 100755
--- a/src/main/java/org/openpnp/vision/FluentCv.java
+++ b/src/main/java/org/openpnp/vision/FluentCv.java
@@ -1,55 +1,47 @@
 /*
- 	Copyright (C) 2015 Jason von Nieda <jason@vonnieda.org>
- 	
- 	This file is part of OpenPnP.
- 	
- 	You may use this file under either the GPLv3 License or the MIT
- 	License at your preference. Functions in OpenPnP that this
- 	file rely on are also available under these terms. See the two
- 	licenses below.
- 	
-	GPLv3 License Terms
-	-------------------
-	
-	OpenPnP is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    OpenPnP is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with OpenPnP.  If not, see <http://www.gnu.org/licenses/>.
- 	
- 	For more information about OpenPnP visit http://openpnp.org
- 	
- 	
- 	MIT License Terms
- 	-----------------
- 	
- 	The MIT License (MIT)
-
-	Permission is hereby granted, free of charge, to any person obtaining a copy
-	of this software and associated documentation files (the "Software"), to deal
-	in the Software without restriction, including without limitation the rights
-	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-	copies of the Software, and to permit persons to whom the Software is
-	furnished to do so, subject to the following conditions:
-	
-	The above copyright notice and this permission notice shall be included in
-	all copies or substantial portions of the Software.
-	
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-	THE SOFTWARE.
-*/
+ * Copyright (C) 2015 Jason von Nieda <jason@vonnieda.org>
+ * 
+ * This file is part of OpenPnP.
+ * 
+ * You may use this file under either the GPLv3 License or the MIT License at your preference.
+ * Functions in OpenPnP that this file rely on are also available under these terms. See the two
+ * licenses below.
+ * 
+ * GPLv3 License Terms -------------------
+ * 
+ * OpenPnP is free software: you can redistribute it and/or modify it under the terms of the GNU
+ * General Public License as published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ * 
+ * OpenPnP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
+ * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License along with OpenPnP. If not, see
+ * <http://www.gnu.org/licenses/>.
+ * 
+ * For more information about OpenPnP visit http://openpnp.org
+ * 
+ * 
+ * MIT License Terms -----------------
+ * 
+ * The MIT License (MIT)
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+ * associated documentation files (the "Software"), to deal in the Software without restriction,
+ * including without limitation the rights to use, copy, modify, merge, publish, distribute,
+ * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+ * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
 
 package org.openpnp.vision;
 
@@ -64,7 +56,6 @@ of this software and associated documentation files (the "Software"), to deal
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Set;
 
 import javax.imageio.ImageIO;
 
@@ -86,66 +77,56 @@ of this software and associated documentation files (the "Software"), to deal
 import org.openpnp.util.VisionUtils;
 
 /**
- * A fluent API for some of the most commonly used OpenCV primitives.
- * Successive operations modify a running Mat. By specifying a tag on
- * an operation the result of the operation will be stored and can be
- * recalled back into the current Mat.
+ * A fluent API for some of the most commonly used OpenCV primitives. Successive operations modify a
+ * running Mat. By specifying a tag on an operation the result of the operation will be stored and
+ * can be recalled back into the current Mat.
  * 
- * Heavily influenced by FireSight by Karl Lew
- * https://github.com/firepick1/FireSight
+ * Heavily influenced by FireSight by Karl Lew https://github.com/firepick1/FireSight
  * 
- * In the spirit of FireSight, this code is licensed differently from the
- * rest of OpenPnP. Please see the license header above.
+ * In the spirit of FireSight, this code is licensed differently from the rest of OpenPnP. Please
+ * see the license header above.
  * 
- * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
- * This API is still under heavy development and is likely to change
- * significantly in the near future.  
- *  
- * TODO: Rethink operations that return or process data points versus
- * images. Perhaps these should require a tag to work with and
- * leave the image unchanged.
+ * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING This API is still under heavy
+ * development and is likely to change significantly in the near future.
  * 
- * There is a bit of a divergence right now between how things like
- * contours and rotated rects are handled versus circles. Circles
- * already have a Mat representation that we can kind of coerce along
- * the pipeline where contours do not (List<MatOfPoint>). We need to
- * pick one of the methods and stick with it, doing translation where
- * needed.
+ * TODO: Rethink operations that return or process data points versus images. Perhaps these should
+ * require a tag to work with and leave the image unchanged.
  * 
- * Keeping things in Mat does give the benefit of not moving too much
- * memory between OpenCv and Java. 
+ * There is a bit of a divergence right now between how things like contours and rotated rects are
+ * handled versus circles. Circles already have a Mat representation that we can kind of coerce
+ * along the pipeline where contours do not (List<MatOfPoint>). We need to pick one of the methods
+ * and stick with it, doing translation where needed.
+ * 
+ * Keeping things in Mat does give the benefit of not moving too much memory between OpenCv and
+ * Java.
  */
 public class FluentCv {
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
     }
-    
+
     public enum ColorCode {
-    	Bgr2Gray(Imgproc.COLOR_BGR2GRAY),
-    	Rgb2Gray(Imgproc.COLOR_RGB2GRAY),
-    	Gray2Bgr(Imgproc.COLOR_GRAY2BGR),
-    	Gray2Rgb(Imgproc.COLOR_GRAY2RGB),
-    	Bgr2Hls(Imgproc.COLOR_BGR2HLS),
-    	Hls2Bgr(Imgproc.COLOR_HLS2BGR),
-    	;
-    	
-    	private int code;
-    	
-    	ColorCode(int code) {
-    		this.code = code;
-    	}
-    	
-    	public int getCode() {
-    		return code;
-    	}
+        Bgr2Gray(Imgproc.COLOR_BGR2GRAY), Rgb2Gray(Imgproc.COLOR_RGB2GRAY), Gray2Bgr(
+                Imgproc.COLOR_GRAY2BGR), Gray2Rgb(Imgproc.COLOR_GRAY2RGB), Bgr2Hls(
+                        Imgproc.COLOR_BGR2HLS), Hls2Bgr(Imgproc.COLOR_HLS2BGR),;
+
+        private int code;
+
+        ColorCode(int code) {
+            this.code = code;
+        }
+
+        public int getCode() {
+            return code;
+        }
     }
 
     private LinkedHashMap<String, Mat> stored = new LinkedHashMap<>();
-	private Mat mat = new Mat();
-	private Camera camera;
-	
-	public FluentCv toMat(BufferedImage img, String... tag) {
+    private Mat mat = new Mat();
+    private Camera camera;
+
+    public FluentCv toMat(BufferedImage img, String... tag) {
         Integer type = null;
         if (img.getType() == BufferedImage.TYPE_BYTE_GRAY) {
             type = CvType.CV_8UC1;
@@ -159,215 +140,178 @@ else if (img.getType() == BufferedImage.TYPE_3BYTE_BGR) {
         }
         Mat mat = new Mat(img.getHeight(), img.getWidth(), type);
         mat.put(0, 0, ((DataBufferByte) img.getRaster().getDataBuffer()).getData());
-		return store(mat, tag);
-	}
-	
-	public FluentCv toGray(String...tag) {
-		return convertColor(ColorCode.Bgr2Gray, tag);
-	}
-	
-	public FluentCv toColor(String... tag) {
-		return convertColor(ColorCode.Gray2Bgr, tag);
-	}
-	
-	public FluentCv convertColor(ColorCode code, String... tag) {
-		return convertColor(code.getCode(), tag);
-	}
-	
-	public FluentCv convertColor(int code, String... tag) {
-		Imgproc.cvtColor(mat, mat, code);
-		return store(mat, tag);
-	}
-	
-	/**
-	 * Apply a threshold to the Mat. If the threshold value is 0 then the Otsu
-	 * flag will be added and the threshold value ignored. Otsu performs
-	 * automatic determination of the threshold value by sampling the
-	 * image.
-	 * @param threshold
-	 * @param tag
-	 * @return
-	 */
-	public FluentCv threshold(double threshold, String... tag) {
-		return threshold(threshold, false, tag);
-	}
-	
-	public FluentCv threshold(double threshold, boolean invert, String... tag) {
-		int type = invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY;
-		if (threshold == 0) {
-			type |= Imgproc.THRESH_OTSU;
-		}
-    	Imgproc.threshold(
-    			mat, 
-    			mat,
-    			threshold,
-    			255, 
-    			type);
-		return store(mat, tag);
-	}
-
-	public FluentCv thresholdAdaptive(String...tag) {
-		return thresholdAdaptive(false, tag);
-	}	
-	
-	public FluentCv thresholdAdaptive(boolean invert, String...tag) {
-    	Imgproc.adaptiveThreshold(
-    			mat, 
-    			mat, 
-    			255, 
-    			Imgproc.ADAPTIVE_THRESH_MEAN_C, 
-    			invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY, 
-    			3,
-    			5);
-		return store(mat, tag);
-	}
-	
-	public FluentCv blurGaussian(int kernelSize, String... tag) {
-    	Imgproc.GaussianBlur(mat, mat, new Size(kernelSize, kernelSize), 0);
-		return store(mat, tag);
-	}
-	
-	public FluentCv blurMedian(int kernelSize, String... tag) {
-    	Imgproc.medianBlur(mat, mat, kernelSize);
-		return store(mat, tag);
-	}
-	
-	public FluentCv findCirclesHough( 
-    		Length minDiameter, 
-    		Length maxDiameter, 
-    		Length minDistance,
-    		String... tag) {
-		checkCamera();
-        return findCirclesHough(
-        		(int) VisionUtils.toPixels(minDiameter, camera), 
-        		(int) VisionUtils.toPixels(maxDiameter, camera), 
-        		(int) VisionUtils.toPixels(minDistance, camera),
-        		tag);
-	}
-	
-	public FluentCv findCirclesHough(int minDiameter, int maxDiameter, int minDistance, String... tag) {
-    	Mat circles = new Mat();
-    	Imgproc.HoughCircles(
-    			mat, 
-    			circles, 
-    			Imgproc.CV_HOUGH_GRADIENT, 
-    			1, 
-    			minDistance,
-    			80, 
-    			10, 
-    			minDiameter / 2, 
-    			maxDiameter / 2);
-		store(circles, tag);
-		return this;
-	}
-	
-	public FluentCv convertCirclesToPoints(List<Point> points) {
-    	for (int i = 0; i < mat.cols(); i++) {
-    		double[] circle = mat.get(0, i);
-    		double x = circle[0];
-    		double y = circle[1];
-    		points.add(new Point(x, y));
-    	}
-    	return this;
-	}
-	
-	public FluentCv convertCirclesToLocations(List<Location> locations) {
-		checkCamera();
-    	Location unitsPerPixel = camera
-    			.getUnitsPerPixel()
-    			.convertToUnits(camera.getLocation().getUnits());
-    	double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
-
-    	for (int i = 0; i < mat.cols(); i++) {
-    		double[] circle = mat.get(0, i);
-    		double x = circle[0];
-    		double y = circle[1];
-    		double radius = circle[2];
+        return store(mat, tag);
+    }
+
+    public FluentCv toGray(String... tag) {
+        return convertColor(ColorCode.Bgr2Gray, tag);
+    }
+
+    public FluentCv toColor(String... tag) {
+        return convertColor(ColorCode.Gray2Bgr, tag);
+    }
+
+    public FluentCv convertColor(ColorCode code, String... tag) {
+        return convertColor(code.getCode(), tag);
+    }
+
+    public FluentCv convertColor(int code, String... tag) {
+        Imgproc.cvtColor(mat, mat, code);
+        return store(mat, tag);
+    }
+
+    /**
+     * Apply a threshold to the Mat. If the threshold value is 0 then the Otsu flag will be added
+     * and the threshold value ignored. Otsu performs automatic determination of the threshold value
+     * by sampling the image.
+     * 
+     * @param threshold
+     * @param tag
+     * @return
+     */
+    public FluentCv threshold(double threshold, String... tag) {
+        return threshold(threshold, false, tag);
+    }
+
+    public FluentCv threshold(double threshold, boolean invert, String... tag) {
+        int type = invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY;
+        if (threshold == 0) {
+            type |= Imgproc.THRESH_OTSU;
+        }
+        Imgproc.threshold(mat, mat, threshold, 255, type);
+        return store(mat, tag);
+    }
+
+    public FluentCv thresholdAdaptive(String... tag) {
+        return thresholdAdaptive(false, tag);
+    }
+
+    public FluentCv thresholdAdaptive(boolean invert, String... tag) {
+        Imgproc.adaptiveThreshold(mat, mat, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C,
+                invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY, 3, 5);
+        return store(mat, tag);
+    }
+
+    public FluentCv blurGaussian(int kernelSize, String... tag) {
+        Imgproc.GaussianBlur(mat, mat, new Size(kernelSize, kernelSize), 0);
+        return store(mat, tag);
+    }
+
+    public FluentCv blurMedian(int kernelSize, String... tag) {
+        Imgproc.medianBlur(mat, mat, kernelSize);
+        return store(mat, tag);
+    }
+
+    public FluentCv findCirclesHough(Length minDiameter, Length maxDiameter, Length minDistance,
+            String... tag) {
+        checkCamera();
+        return findCirclesHough((int) VisionUtils.toPixels(minDiameter, camera),
+                (int) VisionUtils.toPixels(maxDiameter, camera),
+                (int) VisionUtils.toPixels(minDistance, camera), tag);
+    }
+
+    public FluentCv findCirclesHough(int minDiameter, int maxDiameter, int minDistance,
+            String... tag) {
+        Mat circles = new Mat();
+        Imgproc.HoughCircles(mat, circles, Imgproc.CV_HOUGH_GRADIENT, 1, minDistance, 80, 10,
+                minDiameter / 2, maxDiameter / 2);
+        store(circles, tag);
+        return this;
+    }
+
+    public FluentCv convertCirclesToPoints(List<Point> points) {
+        for (int i = 0; i < mat.cols(); i++) {
+            double[] circle = mat.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            points.add(new Point(x, y));
+        }
+        return this;
+    }
+
+    public FluentCv convertCirclesToLocations(List<Location> locations) {
+        checkCamera();
+        Location unitsPerPixel =
+                camera.getUnitsPerPixel().convertToUnits(camera.getLocation().getUnits());
+        double avgUnitsPerPixel = (unitsPerPixel.getX() + unitsPerPixel.getY()) / 2;
+
+        for (int i = 0; i < mat.cols(); i++) {
+            double[] circle = mat.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            double radius = circle[2];
             Location location = VisionUtils.getPixelLocation(camera, x, y);
             location = location.derive(null, null, null, radius * 2 * avgUnitsPerPixel);
-            locations.add(location); 
-    	}
-    	
-    	VisionUtils.sortLocationsByDistance(camera.getLocation(), locations);
-		return this;
-	}
-	
-	/**
-	 * Draw circles from the current Mat contained onto the Mat specified
-	 * in baseTag using the specified color, optionally storing the results in
-	 * tag. The current Mat is replaced with the Mat from baseTag with the
-	 * circles drawn on top of it.
-	 * @param baseTag
-	 * @param color
-	 * @param tag
-	 * @return
-	 */
-	public FluentCv drawCircles(
-			String baseTag, 
-			Color color, 
-			String... tag) {
-		Color centerColor = new HslColor(color).getComplementary();
-		Mat mat = get(baseTag);
-		if (mat == null) {
-			mat = new Mat();
-		}
-    	for (int i = 0; i < this.mat.cols(); i++) {
-    		double[] circle = this.mat.get(0, i);
-    		double x = circle[0];
-    		double y = circle[1];
-    		double radius = circle[2];
-        	Core.circle(
-        			mat, 
-        			new Point(x, y), 
-        			(int) radius, 
-        			colorToScalar(color), 
-        			2);
-        	Core.circle(
-        			mat, 
-        			new Point(x, y), 
-        			1, 
-        			colorToScalar(centerColor), 
-        			2);
-    	}
-		return store(mat, tag);
-	}
-	
-	/**
-	 * Draw circles from the current Mat contained onto the Mat specified
-	 * in baseTag using the color red, optionally storing the results in
-	 * tag. The current Mat is replaced with the Mat from baseTag with the
-	 * circles drawn on top of it.
-	 * @param baseTag
-	 * @param tag
-	 * @return
-	 */
-	public FluentCv drawCircles(String baseTag, String... tag) {
-		return drawCircles(baseTag, Color.red, tag);
-	}
-	
-	public FluentCv recall(String tag) {
-		mat = get(tag);
-		return this;
-	}
-	
-	public FluentCv store(String tag) {
-		return store(mat, tag);
-	}
-	
-	public List<String> getStoredTags() {
-		return new ArrayList<>(stored.keySet());
-	}
-	
-	public FluentCv write(File file) throws Exception {
-		ImageIO.write(toBufferedImage(), "PNG", file);
-		return this;
-	}
-	
-	public FluentCv read(File file, String... tag) throws Exception {
-		 return toMat(ImageIO.read(file), tag);
-	}
-	
-	public BufferedImage toBufferedImage() {
+            locations.add(location);
+        }
+
+        VisionUtils.sortLocationsByDistance(camera.getLocation(), locations);
+        return this;
+    }
+
+    /**
+     * Draw circles from the current Mat contained onto the Mat specified in baseTag using the
+     * specified color, optionally storing the results in tag. The current Mat is replaced with the
+     * Mat from baseTag with the circles drawn on top of it.
+     * 
+     * @param baseTag
+     * @param color
+     * @param tag
+     * @return
+     */
+    public FluentCv drawCircles(String baseTag, Color color, String... tag) {
+        Color centerColor = new HslColor(color).getComplementary();
+        Mat mat = get(baseTag);
+        if (mat == null) {
+            mat = new Mat();
+        }
+        for (int i = 0; i < this.mat.cols(); i++) {
+            double[] circle = this.mat.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            double radius = circle[2];
+            Core.circle(mat, new Point(x, y), (int) radius, colorToScalar(color), 2);
+            Core.circle(mat, new Point(x, y), 1, colorToScalar(centerColor), 2);
+        }
+        return store(mat, tag);
+    }
+
+    /**
+     * Draw circles from the current Mat contained onto the Mat specified in baseTag using the color
+     * red, optionally storing the results in tag. The current Mat is replaced with the Mat from
+     * baseTag with the circles drawn on top of it.
+     * 
+     * @param baseTag
+     * @param tag
+     * @return
+     */
+    public FluentCv drawCircles(String baseTag, String... tag) {
+        return drawCircles(baseTag, Color.red, tag);
+    }
+
+    public FluentCv recall(String tag) {
+        mat = get(tag);
+        return this;
+    }
+
+    public FluentCv store(String tag) {
+        return store(mat, tag);
+    }
+
+    public List<String> getStoredTags() {
+        return new ArrayList<>(stored.keySet());
+    }
+
+    public FluentCv write(File file) throws Exception {
+        ImageIO.write(toBufferedImage(), "PNG", file);
+        return this;
+    }
+
+    public FluentCv read(File file, String... tag) throws Exception {
+        return toMat(ImageIO.read(file), tag);
+    }
+
+    public BufferedImage toBufferedImage() {
         Integer type = null;
         if (mat.type() == CvType.CV_8UC1) {
             type = BufferedImage.TYPE_BYTE_GRAY;
@@ -382,412 +326,435 @@ else if (mat.type() == CvType.CV_32F) {
             mat = tmp;
         }
         if (type == null) {
-            throw new Error(String.format("Unsupported Mat: type %d, channels %d, depth %d", 
-            		mat.type(), 
-            		mat.channels(), 
-            		mat.depth()));
+            throw new Error(String.format("Unsupported Mat: type %d, channels %d, depth %d",
+                    mat.type(), mat.channels(), mat.depth()));
         }
         BufferedImage image = new BufferedImage(mat.cols(), mat.rows(), type);
         mat.get(0, 0, ((DataBufferByte) image.getRaster().getDataBuffer()).getData());
         return image;
-	}
-
-	public FluentCv settleAndCapture(String... tag) {
-		checkCamera();
-		return toMat(camera.settleAndCapture(), tag);
-	}
-	
-	/**
-	 * Set a Camera that can be used for calculations that require a Camera
-	 * Location or units per pixel.
-	 * @param camera
-	 * @return
-	 */
-	public FluentCv setCamera(Camera camera) {
-		this.camera = camera;
-		return this;
-	}
-	
-	public FluentCv filterCirclesByDistance(
-			Length minDistance,
-			Length maxDistance,
-			String... tag
-			) {
-		
-		double minDistancePx = VisionUtils.toPixels(minDistance, camera);
-		double maxDistancePx = VisionUtils.toPixels(maxDistance, camera);
-		return filterCirclesByDistance(
-				camera.getWidth() / 2, 
-				camera.getHeight() / 2, 
-				minDistancePx, 
-				maxDistancePx, 
-				tag); 
-	}
-	
-	public FluentCv filterCirclesByDistance(
-			double originX,
-			double originY,
-			double minDistance,
-			double maxDistance,
-			String...tag
-			) {
-		List<float[]> results = new ArrayList<>();
-    	for (int i = 0; i < this.mat.cols(); i++) {
-    		float[] circle = new float[3];
-    		this.mat.get(0, i, circle);
-    		float x = circle[0];
-    		float y = circle[1];
-    		float radius = circle[2];
-    		double distance = Math.sqrt(Math.pow(x - originX, 2) + Math.pow(y - originY, 2));
-    		if (distance >= minDistance && distance <= maxDistance) {
-    			results.add(new float[] { x, y, radius });
-    		}
-    	}
-    	// It really seems like there must be a better way to do this, but after hours
-    	// and hours of trying I can't find one. How the hell do you append an element
-    	// of 3 channels to a Mat?!
-		Mat r = new Mat(1, results.size(), CvType.CV_32FC3);
-		for (int i = 0; i < results.size(); i++) {
-			r.put(0, i, results.get(i));
-		}
-		return store(r, tag);
-	}
-	
-	public FluentCv filterCirclesToLine(Length maxDistance, String... tag) {
-		return filterCirclesToLine(VisionUtils.toPixels(maxDistance, camera), tag);
-	}
-	
-	/**
-	 * Filter circles as returned from e.g. houghCircles to only those that are within
-	 * maxDistance of the best fitting line.
-	 * @param tag
-	 * @return
-	 */
-	public FluentCv filterCirclesToLine(double maxDistance, String... tag) {
-		if (this.mat.cols() < 2) {
-			return store(this.mat, tag);
-		}
-		
-    	List<Point> points = new ArrayList<>();
-    	// collect the circles into a list of points
-    	for (int i = 0; i < this.mat.cols(); i++) {
-    		float[] circle = new float[3];
-    		this.mat.get(0, i, circle);
-    		float x = circle[0];
-    		float y = circle[1];
-    		points.add(new Point(x, y));
-    	}
-    	
-		Point[] line = Ransac.ransac(points, 100, maxDistance);
-    	Point a = line[0];
-    	Point b = line[1];
-		
-    	// filter the points by distance from the resulting line
-		List<float[]> results = new ArrayList<>();
-		for (int i = 0; i < this.mat.cols(); i++) {
-    		float[] circle = new float[3];
-    		this.mat.get(0, i, circle);
-    		Point p = new Point(circle[0], circle[1]);
-    		if (pointToLineDistance(a, b, p) <= maxDistance) {
-    			results.add(circle);
-    		}
-    	}
-		
-    	// It really seems like there must be a better way to do this, but after hours
-    	// and hours of trying I can't find one. How the hell do you append an element
-    	// of 3 channels to a Mat?!
-		Mat r = new Mat(1, results.size(), CvType.CV_32FC3);
-		for (int i = 0; i < results.size(); i++) {
-			r.put(0, i, results.get(i));
-		}
-		return store(r, tag);
-	}
-	
-	public Mat mat() {
-		return mat.clone();
-	}
-	
-	public FluentCv mat(Mat mat, String... tag) {
-		return store(mat, tag);
-	}
-	
-	/**
-	 * Calculate the absolute difference between the previously
-	 * stored Mat called source1 and the current Mat.
-	 * @param source1
-	 * @param tag
-	 */
-	public FluentCv absDiff(String source1, String... tag) {
-		Core.absdiff(get(source1), mat, mat);
-		return store(mat, tag);
-	}
-	
-	public FluentCv findEdgesCanny(double threshold1, double threshold2, String... tag) {
-		Imgproc.Canny(mat, mat, threshold1, threshold2);
-		return store(mat, tag);
-	}
-	
-	public FluentCv findEdgesRobertsCross(String... tag) {
-		// Java interpretation of
-		// https://www.scss.tcd.ie/publications/book-supplements/A-Practical-Introduction-to-Computer-Vision-with-OpenCV/Code/Edges.cpp
-		// Note: Java API does not have abs. This appears to be doing the
-		// same thing effectively, but I am not sure it's 100% the same
-		// as Cri's version.
-		Mat kernel = Mat.eye(new Size(2, 2), CvType.CV_32FC1);
-		kernel.put(0, 0, 
-				0, 1, 
-				-1, 0);
-		Mat roberts1 = new Mat();
-		Imgproc.filter2D(mat, roberts1, CvType.CV_32FC1, kernel);
-		Core.convertScaleAbs(roberts1, roberts1);
-		
-		kernel.put(0, 0, 
-				1, 0,
-				0, -1);
-		Mat roberts2 = new Mat();
-		Imgproc.filter2D(mat, roberts2, CvType.CV_32FC1, kernel);
-		Core.convertScaleAbs(roberts2, roberts2);
-		
-		Mat roberts = new Mat();
-		Core.add(roberts1, roberts2, roberts);
-		
-		return store(roberts, tag);
-		
-//		// Java interpretation of Cri S's C version.
-//		// This is very slow, my fault, not his. Probably due to all the
-//		// array accesses.
-//		int ptr1[] = { 0, 0, 0, 0 };
-//		int indexx[] = { 0, 1, 1, 0 };
-//		int indexy[] = { 0, 0, 1, 1 };
-//		for (int y = 0; y < mat.rows() - 1; y++) {
-//			for (int x = 0; x < mat.cols() - 1; x++) {
-//				int temp = 0, temp1 = 0;
-//				for (int i = 0; i < 4; i++) {
-//					ptr1[i] = (int) mat.get(y + indexy[i], x + indexx[i])[0]; //  // ptr1[i] = *(ptr + (y + indexy[i]) * gray->widthStep + x + indexx[i]);
-//				}
-//				temp = Math.abs(ptr1[0] - ptr1[2]);
-//				temp1 = Math.abs(ptr1[1] - ptr1[3]);
-//				temp = (temp > temp1 ? temp : temp1);
-//				temp = (int) Math.sqrt((float) (temp * temp) + (float) (temp1 * temp1));
-//				mat.put(y, x, temp); // *(ptr + y * gray->widthStep + x) = temp;
-//			}
-//		}
-//		return store(mat, tag);
-	}
-	
-	public FluentCv findContours(List<MatOfPoint> contours, String... tag) {
-		Mat hierarchy = new Mat();
-		Imgproc.findContours(mat, contours, hierarchy, Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_NONE);
-		return store(mat, tag);
-	}
-	
-	public FluentCv drawContours(List<MatOfPoint> contours, Color color, int thickness, String... tag) {
-		if (color == null) {
-			for (int i = 0; i < contours.size(); i++) {
-				Imgproc.drawContours(mat, contours, i, colorToScalar(indexedColor(i)), thickness);
-			}
-		}
-		else {
-			Imgproc.drawContours(mat, contours, -1, colorToScalar(color), thickness);
-		}
-		return store(mat, tag);
-	}
-	
-	public FluentCv filterContoursByArea(List<MatOfPoint> contours, double areaMin, double areaMax) {
-		for (Iterator<MatOfPoint> i = contours.iterator(); i.hasNext(); ) {
-			MatOfPoint contour = i.next();
-			double area = Imgproc.contourArea(contour);
-			if (area < areaMin || area > areaMax) {
-				i.remove();
-			}
-		}
-		return this;
-	}
-	
-	public FluentCv drawRects(List<RotatedRect> rects, Color color, int thickness, String... tag) {
-		for (int i = 0; i < rects.size(); i++) {
-			RotatedRect rect = rects.get(i);
-			if (color == null) {
-				drawRotatedRect(mat, rect, indexedColor(i), thickness);
-			}
-			else {
-				drawRotatedRect(mat, rect, color, thickness);
-			}
-		}
-		return store(mat, tag);
-	}
-	
-	public FluentCv getContourRects(List<MatOfPoint> contours, List<RotatedRect> rects) {
-		for (int i = 0; i < contours.size(); i++) {
-			MatOfPoint2f contour_ = new MatOfPoint2f();
-		    contours.get(i).convertTo(contour_, CvType.CV_32FC2);
-			if (contour_.empty()) {
-				continue;
-			}
-			RotatedRect rect = Imgproc.minAreaRect(contour_);
-			rects.add(rect);
-		}
-		return this;
-	}
-	
-	public FluentCv getContourMaxRects(List<MatOfPoint> contours, List<RotatedRect> rect) {
-		List<Point> contoursCombined = new ArrayList<>();
-		for (MatOfPoint mp : contours) {
-			List<Point> points = new ArrayList<>();
-			Converters.Mat_to_vector_Point(mp, points);
-			for (Point point : points) {
-				contoursCombined.add(point);
-			}
-		}
-		contours.clear();
-		MatOfPoint points = new MatOfPoint();
-		points.fromList(contoursCombined);
-		
-		return getContourRects(Collections.singletonList(points), rect);
-	}
-	
-	public FluentCv filterRectsByArea(List<RotatedRect> rects, double areaMin, double areaMax) {
-		for (Iterator<RotatedRect> i = rects.iterator(); i.hasNext(); ) {
-			RotatedRect rect = i.next();
-			double area = rect.size.width * rect.size.height;
-			if (area < areaMin || area > areaMax) {
-				i.remove();
-			}
-		}
-		return this;
-	}
-	
-	private void checkCamera() {
-		if (camera == null) {
-			throw new Error("Call setCamera(Camera) before calling methods that rely on units per pixel.");
-		}
-	}
-	
-	private FluentCv store(Mat mat, String... tag) {
-		this.mat = mat;
-		if (tag != null && tag.length > 0) {
-			// Clone so that future writes to the pipeline Mat
-			// don't overwrite our stored one.
-			stored.put(tag[0], this.mat.clone());
-		}
-		return this;
-	}
-	
-	public FluentCv floodFill(Point seedPoint, Color color, String... tag) {
-		Mat mask = new Mat();
-		Imgproc.floodFill(mat, mask, seedPoint, colorToScalar(color));
-		return store(mat, tag);
-	}
-	
-	private Mat get(String tag) {
-		Mat mat = stored.get(tag);
-		if (mat == null) {
-			return null;
-		}
-		// Clone so that future writes to the pipeline Mat
-		// don't overwrite our stored one.
-		return mat.clone();
-	}
-	
-	public static Scalar colorToScalar(Color color) {
-		return new Scalar(
-				color.getBlue(), 
-				color.getGreen(), 
-				color.getRed(), 
-				255);
-	}
-	
-	/**
-	 * Return a Color from an imaginary list of colors starting at index 0
-	 * and extending on to Integer.MAX_VALUE. Can be used to pick a different
-	 * color for each object in a list. Colors are not guaranteed to be unique
-	 * but successive colors will be significantly different from each other.
-	 * @param i
-	 * @return
-	 */
-	public static Color indexedColor(int i) {
-		float h = (i * 59) % 360;
-		float s = Math.max((i * i) % 100, 80);
-		float l = Math.max((i * i) % 100, 50);
-		Color color = new HslColor(h, s, l).getRGB();
-		return color;
-	}
-	
+    }
+
+    public FluentCv settleAndCapture(String... tag) {
+        checkCamera();
+        return toMat(camera.settleAndCapture(), tag);
+    }
+
+    /**
+     * Set a Camera that can be used for calculations that require a Camera Location or units per
+     * pixel.
+     * 
+     * @param camera
+     * @return
+     */
+    public FluentCv setCamera(Camera camera) {
+        this.camera = camera;
+        return this;
+    }
+
+    public FluentCv filterCirclesByDistance(Length minDistance, Length maxDistance, String... tag) {
+
+        double minDistancePx = VisionUtils.toPixels(minDistance, camera);
+        double maxDistancePx = VisionUtils.toPixels(maxDistance, camera);
+        return filterCirclesByDistance(camera.getWidth() / 2, camera.getHeight() / 2, minDistancePx,
+                maxDistancePx, tag);
+    }
+
+    public FluentCv filterCirclesByDistance(double originX, double originY, double minDistance,
+            double maxDistance, String... tag) {
+        List<float[]> results = new ArrayList<>();
+        for (int i = 0; i < this.mat.cols(); i++) {
+            float[] circle = new float[3];
+            this.mat.get(0, i, circle);
+            float x = circle[0];
+            float y = circle[1];
+            float radius = circle[2];
+            double distance = Math.sqrt(Math.pow(x - originX, 2) + Math.pow(y - originY, 2));
+            if (distance >= minDistance && distance <= maxDistance) {
+                results.add(new float[] {x, y, radius});
+            }
+        }
+        // It really seems like there must be a better way to do this, but after hours
+        // and hours of trying I can't find one. How the hell do you append an element
+        // of 3 channels to a Mat?!
+        Mat r = new Mat(1, results.size(), CvType.CV_32FC3);
+        for (int i = 0; i < results.size(); i++) {
+            r.put(0, i, results.get(i));
+        }
+        return store(r, tag);
+    }
+
+    public FluentCv filterCirclesToLine(Length maxDistance, String... tag) {
+        return filterCirclesToLine(VisionUtils.toPixels(maxDistance, camera), tag);
+    }
+
+    /**
+     * Filter circles as returned from e.g. houghCircles to only those that are within maxDistance
+     * of the best fitting line.
+     * 
+     * @param tag
+     * @return
+     */
+    public FluentCv filterCirclesToLine(double maxDistance, String... tag) {
+        if (this.mat.cols() < 2) {
+            return store(this.mat, tag);
+        }
+
+        List<Point> points = new ArrayList<>();
+        // collect the circles into a list of points
+        for (int i = 0; i < this.mat.cols(); i++) {
+            float[] circle = new float[3];
+            this.mat.get(0, i, circle);
+            float x = circle[0];
+            float y = circle[1];
+            points.add(new Point(x, y));
+        }
+
+        Point[] line = Ransac.ransac(points, 100, maxDistance);
+        Point a = line[0];
+        Point b = line[1];
+
+        // filter the points by distance from the resulting line
+        List<float[]> results = new ArrayList<>();
+        for (int i = 0; i < this.mat.cols(); i++) {
+            float[] circle = new float[3];
+            this.mat.get(0, i, circle);
+            Point p = new Point(circle[0], circle[1]);
+            if (pointToLineDistance(a, b, p) <= maxDistance) {
+                results.add(circle);
+            }
+        }
+
+        // It really seems like there must be a better way to do this, but after hours
+        // and hours of trying I can't find one. How the hell do you append an element
+        // of 3 channels to a Mat?!
+        Mat r = new Mat(1, results.size(), CvType.CV_32FC3);
+        for (int i = 0; i < results.size(); i++) {
+            r.put(0, i, results.get(i));
+        }
+        return store(r, tag);
+    }
+
+    public Mat mat() {
+        return mat.clone();
+    }
+
+    public FluentCv mat(Mat mat, String... tag) {
+        return store(mat, tag);
+    }
+
+    /**
+     * Calculate the absolute difference between the previously stored Mat called source1 and the
+     * current Mat.
+     * 
+     * @param source1
+     * @param tag
+     */
+    public FluentCv absDiff(String source1, String... tag) {
+        Core.absdiff(get(source1), mat, mat);
+        return store(mat, tag);
+    }
+
+    public FluentCv findEdgesCanny(double threshold1, double threshold2, String... tag) {
+        Imgproc.Canny(mat, mat, threshold1, threshold2);
+        return store(mat, tag);
+    }
+
+    public FluentCv findEdgesRobertsCross(String... tag) {
+        // Java interpretation of
+        // https://www.scss.tcd.ie/publications/book-supplements/A-Practical-Introduction-to-Computer-Vision-with-OpenCV/Code/Edges.cpp
+        // Note: Java API does not have abs. This appears to be doing the
+        // same thing effectively, but I am not sure it's 100% the same
+        // as Cri's version.
+        Mat kernel = Mat.eye(new Size(2, 2), CvType.CV_32FC1);
+        kernel.put(0, 0, 0, 1, -1, 0);
+        Mat roberts1 = new Mat();
+        Imgproc.filter2D(mat, roberts1, CvType.CV_32FC1, kernel);
+        Core.convertScaleAbs(roberts1, roberts1);
+
+        kernel.put(0, 0, 1, 0, 0, -1);
+        Mat roberts2 = new Mat();
+        Imgproc.filter2D(mat, roberts2, CvType.CV_32FC1, kernel);
+        Core.convertScaleAbs(roberts2, roberts2);
+
+        Mat roberts = new Mat();
+        Core.add(roberts1, roberts2, roberts);
+
+        return store(roberts, tag);
+
+        // // Java interpretation of Cri S's C version.
+        // // This is very slow, my fault, not his. Probably due to all the
+        // // array accesses.
+        // int ptr1[] = { 0, 0, 0, 0 };
+        // int indexx[] = { 0, 1, 1, 0 };
+        // int indexy[] = { 0, 0, 1, 1 };
+        // for (int y = 0; y < mat.rows() - 1; y++) {
+        // for (int x = 0; x < mat.cols() - 1; x++) {
+        // int temp = 0, temp1 = 0;
+        // for (int i = 0; i < 4; i++) {
+        // ptr1[i] = (int) mat.get(y + indexy[i], x + indexx[i])[0]; // // ptr1[i] = *(ptr + (y +
+        // indexy[i]) * gray->widthStep + x + indexx[i]);
+        // }
+        // temp = Math.abs(ptr1[0] - ptr1[2]);
+        // temp1 = Math.abs(ptr1[1] - ptr1[3]);
+        // temp = (temp > temp1 ? temp : temp1);
+        // temp = (int) Math.sqrt((float) (temp * temp) + (float) (temp1 * temp1));
+        // mat.put(y, x, temp); // *(ptr + y * gray->widthStep + x) = temp;
+        // }
+        // }
+        // return store(mat, tag);
+    }
+
+    public FluentCv findContours(List<MatOfPoint> contours, String... tag) {
+        Mat hierarchy = new Mat();
+        Imgproc.findContours(mat, contours, hierarchy, Imgproc.RETR_LIST,
+                Imgproc.CHAIN_APPROX_NONE);
+        return store(mat, tag);
+    }
+
+    public FluentCv drawContours(List<MatOfPoint> contours, Color color, int thickness,
+            String... tag) {
+        if (color == null) {
+            for (int i = 0; i < contours.size(); i++) {
+                Imgproc.drawContours(mat, contours, i, colorToScalar(indexedColor(i)), thickness);
+            }
+        }
+        else {
+            Imgproc.drawContours(mat, contours, -1, colorToScalar(color), thickness);
+        }
+        return store(mat, tag);
+    }
+
+    public FluentCv filterContoursByArea(List<MatOfPoint> contours, double areaMin,
+            double areaMax) {
+        for (Iterator<MatOfPoint> i = contours.iterator(); i.hasNext();) {
+            MatOfPoint contour = i.next();
+            double area = Imgproc.contourArea(contour);
+            if (area < areaMin || area > areaMax) {
+                i.remove();
+            }
+        }
+        return this;
+    }
+
+    public FluentCv drawRects(List<RotatedRect> rects, Color color, int thickness, String... tag) {
+        for (int i = 0; i < rects.size(); i++) {
+            RotatedRect rect = rects.get(i);
+            if (color == null) {
+                drawRotatedRect(mat, rect, indexedColor(i), thickness);
+            }
+            else {
+                drawRotatedRect(mat, rect, color, thickness);
+            }
+        }
+        return store(mat, tag);
+    }
+
+    public FluentCv getContourRects(List<MatOfPoint> contours, List<RotatedRect> rects) {
+        for (int i = 0; i < contours.size(); i++) {
+            MatOfPoint2f contour_ = new MatOfPoint2f();
+            contours.get(i).convertTo(contour_, CvType.CV_32FC2);
+            if (contour_.empty()) {
+                continue;
+            }
+            RotatedRect rect = Imgproc.minAreaRect(contour_);
+            rects.add(rect);
+        }
+        return this;
+    }
+
+    public FluentCv getContourMaxRects(List<MatOfPoint> contours, List<RotatedRect> rect) {
+        List<Point> contoursCombined = new ArrayList<>();
+        for (MatOfPoint mp : contours) {
+            List<Point> points = new ArrayList<>();
+            Converters.Mat_to_vector_Point(mp, points);
+            for (Point point : points) {
+                contoursCombined.add(point);
+            }
+        }
+        contours.clear();
+        MatOfPoint points = new MatOfPoint();
+        points.fromList(contoursCombined);
+
+        return getContourRects(Collections.singletonList(points), rect);
+    }
+
+    public FluentCv filterRectsByArea(List<RotatedRect> rects, double areaMin, double areaMax) {
+        for (Iterator<RotatedRect> i = rects.iterator(); i.hasNext();) {
+            RotatedRect rect = i.next();
+            double area = rect.size.width * rect.size.height;
+            if (area < areaMin || area > areaMax) {
+                i.remove();
+            }
+        }
+        return this;
+    }
+
+    private void checkCamera() {
+        if (camera == null) {
+            throw new Error(
+                    "Call setCamera(Camera) before calling methods that rely on units per pixel.");
+        }
+    }
+
+    private FluentCv store(Mat mat, String... tag) {
+        this.mat = mat;
+        if (tag != null && tag.length > 0) {
+            // Clone so that future writes to the pipeline Mat
+            // don't overwrite our stored one.
+            mat = stored.get(tag[0]);
+            if (mat != null) {
+                mat.release();
+            }
+            stored.put(tag[0], this.mat.clone());
+        }
+        return this;
+    }
+
+    public FluentCv floodFill(Point seedPoint, Color color, String... tag) {
+        Mat mask = new Mat();
+        Imgproc.floodFill(mat, mask, seedPoint, colorToScalar(color));
+        return store(mat, tag);
+    }
+
+    private Mat get(String tag) {
+        Mat mat = stored.get(tag);
+        if (mat == null) {
+            return null;
+        }
+        // Clone so that future writes to the pipeline Mat
+        // don't overwrite our stored one.
+        return mat.clone();
+    }
+
+    public static Scalar colorToScalar(Color color) {
+        return new Scalar(color.getBlue(), color.getGreen(), color.getRed(), 255);
+    }
+
+    /**
+     * Return a Color from an imaginary list of colors starting at index 0 and extending on to
+     * Integer.MAX_VALUE. Can be used to pick a different color for each object in a list. Colors
+     * are not guaranteed to be unique but successive colors will be significantly different from
+     * each other.
+     * 
+     * @param i
+     * @return
+     */
+    public static Color indexedColor(int i) {
+        float h = (i * 59) % 360;
+        float s = Math.max((i * i) % 100, 80);
+        float l = Math.max((i * i) % 100, 50);
+        Color color = new HslColor(h, s, l).getRGB();
+        return color;
+    }
+
     public static BufferedImage convertBufferedImage(BufferedImage src, int type) {
         if (src.getType() == type) {
             return src;
         }
-        BufferedImage img = new BufferedImage(src.getWidth(), src.getHeight(),
-                type);
+        BufferedImage img = new BufferedImage(src.getWidth(), src.getHeight(), type);
         Graphics2D g2d = img.createGraphics();
         g2d.drawImage(src, 0, 0, null);
         g2d.dispose();
         return img;
     }
-    
-	// From http://www.ahristov.com/tutorial/geometry-games/point-line-distance.html
+
+    // From http://www.ahristov.com/tutorial/geometry-games/point-line-distance.html
     public static double pointToLineDistance(Point A, Point B, Point P) {
-		double normalLength = Math.sqrt((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));
-		return Math.abs((P.x - A.x) * (B.y - A.y) - (P.y - A.y) * (B.x - A.x)) / normalLength;
-	}
-	
-	/**
-	 * Draw the infinite line defined by the two points to the extents
-	 * of the image instead of just between the two points.
-	 * From: http://stackoverflow.com/questions/13160722/how-to-draw-line-not-line-segment-opencv-2-4-2
-	 * @param img
-	 * @param p1
-	 * @param p2
-	 * @param color
-	 */
-	public static void infiniteLine(Mat img, Point p1, Point p2, Color color) {
-		Point p = new Point(), q = new Point();
-		// Check if the line is a vertical line because vertical lines don't
-		// have slope
-		if (p1.x != p2.x) {
-			p.x = 0;
-			q.x = img.cols();
-			// Slope equation (y1 - y2) / (x1 - x2)
-			float m = (float) ((p1.y - p2.y) / (p1.x - p2.x));
-			// Line equation: y = mx + b
-			float b = (float) (p1.y - (m * p1.x));
-			p.y = m * p.x + b;
-			q.y = m * q.x + b;
-		} else {
-			p.x = q.x = p2.x;
-			p.y = 0;
-			q.y = img.rows();
-		}
-		Core.line(img, p, q, colorToScalar(color));
-	}
-	
-	public static void drawRotatedRect(Mat mat, RotatedRect rect, Color color, int thickness) {
-		// From: http://stackoverflow.com/questions/23327502/opencv-how-to-draw-minarearect-in-java
-		Point points[] = new Point[4];
-	    rect.points(points);
-	    Scalar color_ = colorToScalar(color);
-	    for(int j = 0; j < 4; ++j) {
-	        Core.line(mat, points[j], points[(j + 1) % 4], color_, thickness);
-	    }		
-	}
-	
-	// From: http://docs.opencv.org/doc/tutorials/highgui/video-input-psnr-ssim/video-input-psnr-ssim.html#image-similarity-psnr-and-ssim
-	public static double calculatePsnr(Mat I1, Mat I2) {
-		Mat s1 = new Mat();
-		Core.absdiff(I1, I2, s1); // |I1 - I2|
-		s1.convertTo(s1, CvType.CV_32F); // cannot make a square on 8 bits
-		s1 = s1.mul(s1); // |I1 - I2|^2
-
-		Scalar s = Core.sumElems(s1); // sum elements per channel
-
-		double sse = s.val[0] + s.val[1] + s.val[2]; // sum channels
-
-		if (sse <= 1e-10) // for small values return zero
-			return 0;
-		else {
-			double mse = sse / (double) (I1.channels() * I1.total());
-			double psnr = 10.0 * Math.log10((255 * 255) / mse);
-			return psnr;
-		}
-	}
+        double normalLength = Math.sqrt((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y));
+        return Math.abs((P.x - A.x) * (B.y - A.y) - (P.y - A.y) * (B.x - A.x)) / normalLength;
+    }
+
+    /**
+     * Draw the infinite line defined by the two points to the extents of the image instead of just
+     * between the two points. From:
+     * http://stackoverflow.com/questions/13160722/how-to-draw-line-not-line-segment-opencv-2-4-2
+     * 
+     * @param img
+     * @param p1
+     * @param p2
+     * @param color
+     */
+    public static void infiniteLine(Mat img, Point p1, Point p2, Color color) {
+        Point p = new Point(), q = new Point();
+        // Check if the line is a vertical line because vertical lines don't
+        // have slope
+        if (p1.x != p2.x) {
+            p.x = 0;
+            q.x = img.cols();
+            // Slope equation (y1 - y2) / (x1 - x2)
+            float m = (float) ((p1.y - p2.y) / (p1.x - p2.x));
+            // Line equation: y = mx + b
+            float b = (float) (p1.y - (m * p1.x));
+            p.y = m * p.x + b;
+            q.y = m * q.x + b;
+        }
+        else {
+            p.x = q.x = p2.x;
+            p.y = 0;
+            q.y = img.rows();
+        }
+        Core.line(img, p, q, colorToScalar(color));
+    }
+
+    // From: http://stackoverflow.com/questions/23327502/opencv-how-to-draw-minarearect-in-java
+    public static void drawRotatedRect(Mat mat, RotatedRect rect, Color color, int thickness) {
+        Point points[] = new Point[4];
+        rect.points(points);
+        Scalar color_ = colorToScalar(color);
+        for (int j = 0; j < 4; ++j) {
+            Core.line(mat, points[j], points[(j + 1) % 4], color_, thickness);
+        }
+    }
+
+    // From:
+    // http://docs.opencv.org/doc/tutorials/highgui/video-input-psnr-ssim/video-input-psnr-ssim.html#image-similarity-psnr-and-ssim
+    public static double calculatePsnr(Mat I1, Mat I2) {
+        Mat s1 = new Mat();
+        Core.absdiff(I1, I2, s1); // |I1 - I2|
+        s1.convertTo(s1, CvType.CV_32F); // cannot make a square on 8 bits
+        s1 = s1.mul(s1); // |I1 - I2|^2
+
+        Scalar s = Core.sumElems(s1); // sum elements per channel
+
+        double sse = s.val[0] + s.val[1] + s.val[2]; // sum channels
+
+        if (sse <= 1e-10) // for small values return zero
+            return 0;
+        else {
+            double mse = sse / (double) (I1.channels() * I1.total());
+            double psnr = 10.0 * Math.log10((255 * 255) / mse);
+            return psnr;
+        }
+    }
+
+    /**
+     * From FireSight: https://github.com/firepick1/FireSight/wiki/op-Sharpness
+     * 
+     * @param image
+     * @return
+     */
+    public static double calculateSharpnessGRAS(Mat image) {
+        int sum = 0;
+        Mat matGray = new Mat();
+
+        if (image.channels() == 1) {
+            matGray = image;
+        }
+        else {
+            Imgproc.cvtColor(image, matGray, Imgproc.COLOR_BGR2GRAY);
+        }
+
+        byte[] b1 = new byte[1];
+        byte[] b2 = new byte[1];
+        for (int r = 0; r < matGray.rows(); r++) {
+            for (int c = 0; c < matGray.cols() - 1; c++) {
+                matGray.get(r, c, b1);
+                matGray.get(r, c + 1, b2);
+                int df = (int) b1[0] - (int) b2[0];
+                sum += df * df;
+            }
+        }
+
+        return ((double) sum / matGray.rows() / (matGray.cols() - 1));
+    }
 }
diff --git a/src/main/java/org/openpnp/vision/LensCalibration.java b/src/main/java/org/openpnp/vision/LensCalibration.java
index 551b3bc92c..82d1cb379a 100755
--- a/src/main/java/org/openpnp/vision/LensCalibration.java
+++ b/src/main/java/org/openpnp/vision/LensCalibration.java
@@ -20,19 +20,19 @@
  * Performs OpenCV based lens calibration based on the techniques described in:
  * http://opencv-java-tutorials.readthedocs.org/en/latest/09-camera-calibration.html
  * http://docs.opencv.org/2.4/doc/tutorials/calib3d/camera_calibration/camera_calibration.html
- * https://github.com/Itseez/opencv/blob/master/samples/cpp/tutorial_code/calib3d/camera_calibration/camera_calibration.cpp
+ * https://github.com/Itseez/opencv/blob/master/samples/cpp/tutorial_code/calib3d/camera_calibration
+ * /camera_calibration.cpp
  * 
- * FishEye model code is included but unfinished. This code cannot be finished
- * until we are using OpenCV 3.
+ * FishEye model code is included but unfinished. This code cannot be finished until we are using
+ * OpenCV 3.
  */
 public class LensCalibration {
-    protected final static Logger logger = LoggerFactory
-            .getLogger(LensCalibration.class);    
-    
+    protected final static Logger logger = LoggerFactory.getLogger(LensCalibration.class);
+
     static {
         nu.pattern.OpenCV.loadShared();
         System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
-    }    
+    }
 
     public enum Pattern {
         Chessboard, CirclesGrid, AsymmetricCirclesGrid
@@ -48,21 +48,16 @@
     final private double objectSize;
     final private MatOfPoint3f objectPoints;
     final private long applyDelayMs;
- 
+
     private List<Mat> imagePointsList = new ArrayList<>();
     private List<Mat> objectPointsList = new ArrayList<>();
     private Size imageSize;
     private Mat cameraMatrix;
     private Mat distortionCoefficients;
     private long lastApplyMs;
-    
-    public LensCalibration(
-            LensModel lensModel, 
-            Pattern pattern, 
-            int patternWidth,
-            int patternHeight, 
-            double objectSize,
-            long applyDelayMs) {
+
+    public LensCalibration(LensModel lensModel, Pattern pattern, int patternWidth,
+            int patternHeight, double objectSize, long applyDelayMs) {
         if (lensModel == LensModel.Fisheye) {
             throw new Error(lensModel + " LensModel not yet supported. OpenCV 3+ needed.");
         }
@@ -75,23 +70,19 @@ public LensCalibration(
         // and then add it to the list with each processed image.
         objectPoints = calculateObjectPoints();
     }
-    
+
     public Mat apply(Mat mat) {
         if (imageSize == null) {
             imageSize = mat.size();
         }
-        
+
         MatOfPoint2f imagePoints = findImagePoints(mat);
         if (imagePoints == null) {
             return null;
         }
-        
-        Calib3d.drawChessboardCorners(
-                mat, 
-                patternSize, 
-                imagePoints, 
-                true);
-        
+
+        Calib3d.drawChessboardCorners(mat, patternSize, imagePoints, true);
+
         if (System.currentTimeMillis() - lastApplyMs > applyDelayMs) {
             objectPointsList.add(objectPoints);
             imagePointsList.add(imagePoints);
@@ -100,70 +91,65 @@ public Mat apply(Mat mat) {
 
         return mat;
     }
-    
+
     public boolean calibrate() {
         Mat cameraMatrix;
         Mat distortionCoefficients;
-        
+
         cameraMatrix = Mat.eye(3, 3, CvType.CV_64F);
 
         if (lensModel == LensModel.Fisheye) {
             distortionCoefficients = Mat.zeros(4, 1, CvType.CV_64F);
-        } 
+        }
         else {
             distortionCoefficients = Mat.zeros(8, 1, CvType.CV_64F);
         }
-        
+
         List<Mat> rvecs = new ArrayList<>();
         List<Mat> tvecs = new ArrayList<>();
-        
+
         double rms;
 
         if (lensModel == LensModel.Fisheye) {
             // TODO:
             throw new Error(lensModel + " LensModel not yet supported. OpenCV 3+ needed.");
-//            Mat _rvecs, _tvecs;
-//            rms = fisheye::calibrate(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, _rvecs,
-//                                     _tvecs, s.flag);
-//
-//            rvecs.reserve(_rvecs.rows);
-//            tvecs.reserve(_tvecs.rows);
-//            for(int i = 0; i < int(objectPoints.size()); i++){
-//                rvecs.push_back(_rvecs.row(i));
-//                tvecs.push_back(_tvecs.row(i));
-//            }
-        } 
+            // Mat _rvecs, _tvecs;
+            // rms = fisheye::calibrate(objectPoints, imagePoints, imageSize, cameraMatrix,
+            // distCoeffs, _rvecs,
+            // _tvecs, s.flag);
+            //
+            // rvecs.reserve(_rvecs.rows);
+            // tvecs.reserve(_tvecs.rows);
+            // for(int i = 0; i < int(objectPoints.size()); i++){
+            // rvecs.push_back(_rvecs.row(i));
+            // tvecs.push_back(_tvecs.row(i));
+            // }
+        }
         else {
-            rms = Calib3d.calibrateCamera(
-                    objectPointsList, 
-                    imagePointsList, 
-                    imageSize, 
-                    cameraMatrix, 
-                    distortionCoefficients, 
-                    rvecs, 
-                    tvecs);
+            rms = Calib3d.calibrateCamera(objectPointsList, imagePointsList, imageSize,
+                    cameraMatrix, distortionCoefficients, rvecs, tvecs);
         }
-        
+
         boolean ok = Core.checkRange(cameraMatrix) && Core.checkRange(distortionCoefficients);
-        
+
         logger.info("calibrate() ok {}, rms {}", ok, rms);
 
         if (ok) {
             this.cameraMatrix = cameraMatrix;
             this.distortionCoefficients = distortionCoefficients;
         }
-        
+
         return ok;
     }
-    
+
     public int getPatternFoundCount() {
         return imagePointsList.size();
     }
-    
+
     public boolean isCalibrated() {
         return cameraMatrix != null && distortionCoefficients != null;
     }
-    
+
     public Mat getCameraMatrix() {
         return cameraMatrix;
     }
@@ -175,52 +161,53 @@ public Mat getDistortionCoefficients() {
     private MatOfPoint2f findImagePoints(Mat mat) {
         MatOfPoint2f imagePoints = new MatOfPoint2f();
         boolean found = false;
-        switch(pattern) {
+        switch (pattern) {
             case Chessboard:
-                int chessBoardFlags = Calib3d.CALIB_CB_ADAPTIVE_THRESH | Calib3d.CALIB_CB_NORMALIZE_IMAGE;
+                int chessBoardFlags =
+                        Calib3d.CALIB_CB_ADAPTIVE_THRESH | Calib3d.CALIB_CB_NORMALIZE_IMAGE;
                 if (lensModel != LensModel.Fisheye) {
                     // fast check erroneously fails with high distortions like fisheye
                     chessBoardFlags |= Calib3d.CALIB_CB_FAST_CHECK;
-                }                
-                found = Calib3d.findChessboardCorners(mat, patternSize, imagePoints, chessBoardFlags);
+                }
+                found = Calib3d.findChessboardCorners(mat, patternSize, imagePoints,
+                        chessBoardFlags);
                 if (found) {
                     // improve the found corners' coordinate accuracy for chessboard
                     Mat matGray = new Mat();
                     Imgproc.cvtColor(mat, matGray, Imgproc.COLOR_BGR2GRAY);
-                    Imgproc.cornerSubPix(
-                            matGray, 
-                            imagePoints, 
-                            new Size(11, 11),
-                            new Size(-1, -1), 
-                            new TermCriteria(TermCriteria.EPS + TermCriteria.COUNT, 30, 0.1 ));
+                    Imgproc.cornerSubPix(matGray, imagePoints, new Size(11, 11), new Size(-1, -1),
+                            new TermCriteria(TermCriteria.EPS + TermCriteria.COUNT, 30, 0.1));
                 }
                 break;
             case CirclesGrid:
                 found = Calib3d.findCirclesGridDefault(mat, patternSize, imagePoints);
                 break;
             case AsymmetricCirclesGrid:
-                found = Calib3d.findCirclesGridDefault(mat, patternSize, imagePoints, Calib3d.CALIB_CB_ASYMMETRIC_GRID );
+                found = Calib3d.findCirclesGridDefault(mat, patternSize, imagePoints,
+                        Calib3d.CALIB_CB_ASYMMETRIC_GRID);
                 break;
         }
         return found ? imagePoints : null;
     }
-    
+
     private MatOfPoint3f calculateObjectPoints() {
         MatOfPoint3f obj = new MatOfPoint3f();
-        
+
         switch (pattern) {
             case Chessboard:
             case CirclesGrid:
                 for (int i = 0; i < patternSize.height; ++i) {
                     for (int j = 0; j < patternSize.width; ++j) {
-                        obj.push_back(new MatOfPoint3f(new Point3(j * objectSize, i * objectSize, 0)));
+                        obj.push_back(
+                                new MatOfPoint3f(new Point3(j * objectSize, i * objectSize, 0)));
                     }
                 }
                 break;
             case AsymmetricCirclesGrid:
-                for( int i = 0; i < patternSize.height; i++) {
-                    for( int j = 0; j < patternSize.width; j++) {
-                        obj.push_back(new MatOfPoint3f(new Point3((2 * j + i % 2) * objectSize, i * objectSize, 0)));
+                for (int i = 0; i < patternSize.height; i++) {
+                    for (int j = 0; j < patternSize.width; j++) {
+                        obj.push_back(new MatOfPoint3f(
+                                new Point3((2 * j + i % 2) * objectSize, i * objectSize, 0)));
                     }
                 }
                 break;
diff --git a/src/main/java/org/openpnp/vision/Ransac.java b/src/main/java/org/openpnp/vision/Ransac.java
index 7f9fe0ba81..f37131fa45 100755
--- a/src/main/java/org/openpnp/vision/Ransac.java
+++ b/src/main/java/org/openpnp/vision/Ransac.java
@@ -11,114 +11,117 @@
 import org.opencv.core.Point;
 
 public class Ransac {
-	/*
-	 * http://users.utcluj.ro/~igiosan/Resources/PRS/L1/lab_01e.pdf
-	 * http://cs.gmu.edu/~kosecka/cs682/lect-fitting.pdf
-	 * http://introcs.cs.princeton.edu/java/36inheritance/LeastSquares.java.html
-	 */
-	public static Point[] ransac(List<Point> points, int maxIterations, double threshold) {
-		Point bestA = null, bestB = null;
-		int bestInliers = 0;
-		for (int i = 0; i < maxIterations; i++) {
-			// take a random sample of two points
-			Collections.shuffle(points);
-			Point a = points.get(0);
-			Point b = points.get(1);
-			// find the inliers
-			int inliers = 0;
-			for (Point p : points) {
-				double distance = FluentCv.pointToLineDistance(a, b, p);
-				if (distance <= threshold) {
-					inliers++;
-				}
-			}
-			if (inliers > bestInliers) {
-				bestA = a;
-				bestB = b;
-				bestInliers = inliers;
-			}
-		}
-		return new Point[] { bestA, bestB };
-	}
-	
-	// TODO: This currently seems to give much worse results than ransac. Figure out why.
-	public static List<RansacLine> multiRansac(List<Point> points, int maxIterations, double threshold) {
-		Random random = new Random();
-		Set<RansacLine> lines = new HashSet<>();
-		for (int i = 0; i < maxIterations; i++) {
-			// take a random sample of two points
-			Point a = points.get(random.nextInt(points.size()));
-			Point b = points.get(random.nextInt(points.size()));
-			RansacLine line = new RansacLine(a, b, 0);
-			// if we have already processed this pair, skip it
-			if (lines.contains(line)) {
-				continue;
-			}
-			// add the result
-			lines.add(line);
-			// find the inliers
-			for (Point p : points) {
-				double distance = FluentCv.pointToLineDistance(a, b, p);
-				if (distance <= threshold) {
-					line.inliers++;
-				}
-			}
-		}
-		List<RansacLine> results = new ArrayList<>(lines);
-		Collections.sort(results, new Comparator<RansacLine>() {
-			@Override
-			public int compare(RansacLine o1, RansacLine o2) {
-				return o2.inliers - o1.inliers;
-			}
-		});
-		return results;
-	}
-	
-	public static class RansacLine {
-		public Point a;
-		public Point b;
-		public transient int inliers;
-		
-		public RansacLine(Point a, Point b, int inliers) {
-			this.a = a;
-			this.b = b;
-			this.inliers = inliers;
-		}
+    /*
+     * http://users.utcluj.ro/~igiosan/Resources/PRS/L1/lab_01e.pdf
+     * http://cs.gmu.edu/~kosecka/cs682/lect-fitting.pdf
+     * http://introcs.cs.princeton.edu/java/36inheritance/LeastSquares.java.html
+     */
+    public static Point[] ransac(List<Point> points, int maxIterations, double threshold) {
+        Point bestA = null, bestB = null;
+        int bestInliers = 0;
+        for (int i = 0; i < maxIterations; i++) {
+            // take a random sample of two points
+            Collections.shuffle(points);
+            Point a = points.get(0);
+            Point b = points.get(1);
+            // find the inliers
+            int inliers = 0;
+            for (Point p : points) {
+                double distance = FluentCv.pointToLineDistance(a, b, p);
+                if (distance <= threshold) {
+                    inliers++;
+                }
+            }
+            if (inliers > bestInliers) {
+                bestA = a;
+                bestB = b;
+                bestInliers = inliers;
+            }
+        }
+        return new Point[] {bestA, bestB};
+    }
 
-		@Override
-		public int hashCode() {
-			final int prime = 31;
-			int result = 1;
-			result = prime * result + ((a == null) ? 0 : a.hashCode());
-			result = prime * result + ((b == null) ? 0 : b.hashCode());
-			return result;
-		}
+    // TODO: This currently seems to give much worse results than ransac. Figure out why.
+    public static List<RansacLine> multiRansac(List<Point> points, int maxIterations,
+            double threshold) {
+        Random random = new Random();
+        Set<RansacLine> lines = new HashSet<>();
+        for (int i = 0; i < maxIterations; i++) {
+            // take a random sample of two points
+            Point a = points.get(random.nextInt(points.size()));
+            Point b = points.get(random.nextInt(points.size()));
+            RansacLine line = new RansacLine(a, b, 0);
+            // if we have already processed this pair, skip it
+            if (lines.contains(line)) {
+                continue;
+            }
+            // add the result
+            lines.add(line);
+            // find the inliers
+            for (Point p : points) {
+                double distance = FluentCv.pointToLineDistance(a, b, p);
+                if (distance <= threshold) {
+                    line.inliers++;
+                }
+            }
+        }
+        List<RansacLine> results = new ArrayList<>(lines);
+        Collections.sort(results, new Comparator<RansacLine>() {
+            @Override
+            public int compare(RansacLine o1, RansacLine o2) {
+                return o2.inliers - o1.inliers;
+            }
+        });
+        return results;
+    }
 
-		@Override
-		public boolean equals(Object obj) {
-			if (this == obj)
-				return true;
-			if (obj == null)
-				return false;
-			if (getClass() != obj.getClass())
-				return false;
-			RansacLine other = (RansacLine) obj;
-			if (a == null) {
-				if (other.a != null)
-					return false;
-			} else if (!a.equals(other.a))
-				return false;
-			if (b == null) {
-				if (other.b != null)
-					return false;
-			} else if (!b.equals(other.b))
-				return false;
-			return true;
-		}
+    public static class RansacLine {
+        public Point a;
+        public Point b;
+        public transient int inliers;
 
-		@Override
-		public String toString() {
-			return "RansacLine [a=" + a + ", b=" + b + ", inliers=" + inliers + "]";
-		}
-	}
+        public RansacLine(Point a, Point b, int inliers) {
+            this.a = a;
+            this.b = b;
+            this.inliers = inliers;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((a == null) ? 0 : a.hashCode());
+            result = prime * result + ((b == null) ? 0 : b.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj)
+                return true;
+            if (obj == null)
+                return false;
+            if (getClass() != obj.getClass())
+                return false;
+            RansacLine other = (RansacLine) obj;
+            if (a == null) {
+                if (other.a != null)
+                    return false;
+            }
+            else if (!a.equals(other.a))
+                return false;
+            if (b == null) {
+                if (other.b != null)
+                    return false;
+            }
+            else if (!b.equals(other.b))
+                return false;
+            return true;
+        }
+
+        @Override
+        public String toString() {
+            return "RansacLine [a=" + a + ", b=" + b + ", inliers=" + inliers + "]";
+        }
+    }
 }
diff --git a/src/main/java/org/openpnp/vision/pipeline/CvPipeline.java b/src/main/java/org/openpnp/vision/pipeline/CvPipeline.java
new file mode 100755
index 0000000000..7b10968ee1
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/CvPipeline.java
@@ -0,0 +1,263 @@
+package org.openpnp.vision.pipeline;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.opencv.core.Mat;
+import org.openpnp.model.Configuration;
+import org.openpnp.spi.Camera;
+import org.openpnp.vision.pipeline.CvStage.Result;
+import org.simpleframework.xml.ElementList;
+import org.simpleframework.xml.Root;
+import org.simpleframework.xml.Serializer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A CvPipeline performs computer vision operations on a working image by processing in series a
+ * list of CvStage instances. Each CvStage instance can modify the working image and return a new
+ * image along with data extracted from the image. After processing the image callers can get access
+ * to the images and models from each stage.
+ * 
+ * CvPipeline is serializable using toXmlString and fromXmlString. This makes it easy to export
+ * pipelines and exchange them with others.
+ * 
+ * This work takes inspiration from several existing projects:
+ * 
+ * FireSight by Karl Lew and Šimon Fojtů: https://github.com/firepick1/FireSight
+ * 
+ * RoboRealm: http://www.roborealm.com/
+ * 
+ * TODO: Add measuring to image window.
+ * 
+ * TODO: Add info showing pixel coordinates when mouse is in image window.
+ */
+@Root
+public class CvPipeline {
+    static {
+        nu.pattern.OpenCV.loadShared();
+        System.loadLibrary(org.opencv.core.Core.NATIVE_LIBRARY_NAME);
+    }
+
+    private final static Logger logger = LoggerFactory.getLogger(CvPipeline.class);
+
+    @ElementList
+    private ArrayList<CvStage> stages = new ArrayList<>();
+
+    private Map<CvStage, Result> results = new HashMap<CvStage, Result>();
+
+    private Mat workingImage;
+
+    private Camera camera;
+
+    /**
+     * Add the given CvStage to the end of the pipeline using the given name. If name is null a
+     * unique one will be generated and set on the stage.
+     * 
+     * @param name
+     * @param stage
+     */
+    public void add(String name, CvStage stage) {
+        if (name == null) {
+            name = generateUniqueName();
+        }
+        stage.setName(name);
+        stages.add(stage);
+    }
+
+    /**
+     * Add the given CvStage to the end of the pipeline. If the stage does not have a name a unique
+     * one will be generated and set on the stage.
+     * 
+     * @param stage
+     */
+    public void add(CvStage stage) {
+        add(stage.getName(), stage);
+    }
+
+    public void insert(String name, CvStage stage, int index) {
+        if (name == null) {
+            name = generateUniqueName();
+        }
+        stage.setName(name);
+        stages.add(index, stage);
+    }
+
+    public void insert(CvStage stage, int index) {
+        insert(stage.getName(), stage, index);
+    }
+
+    public void remove(String name) {
+        remove(getStage(name));
+    }
+
+    public void remove(CvStage stage) {
+        stages.remove(stage);
+    }
+
+    public List<CvStage> getStages() {
+        return Collections.unmodifiableList(stages);
+    }
+
+    public CvStage getStage(String name) {
+        if (name == null) {
+            return null;
+        }
+        for (CvStage stage : stages) {
+            if (stage.getName().equals(name)) {
+                return stage;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Get the Result returned by the CvStage with the given name. May return null if the stage did
+     * not return a result.
+     * 
+     * @param name
+     * @return
+     */
+    public Result getResult(String name) {
+        if (name == null) {
+            return null;
+        }
+        return getResult(getStage(name));
+    }
+
+    /**
+     * Get the Result returned by give CvStage. May return null if the stage did not return a
+     * result.
+     * 
+     * @param stage
+     * @return
+     */
+    public Result getResult(CvStage stage) {
+        if (stage == null) {
+            return null;
+        }
+        return results.get(stage);
+    }
+
+    /**
+     * Get the current working image. Primarily intended to be called from CvStage implementations.
+     * 
+     * @return
+     */
+    public Mat getWorkingImage() {
+        return workingImage;
+    }
+
+    public void setCamera(Camera camera) {
+        this.camera = camera;
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    public void process() {
+        release();
+        for (CvStage stage : stages) {
+            // Process and time the stage and get the result.
+            long processingTimeNs = System.nanoTime();
+            Result result = null;
+            try {
+                result = stage.process(this);
+            }
+            catch (Exception e) {
+                result = new Result(null, e);
+            }
+            processingTimeNs = System.nanoTime() - processingTimeNs;
+
+            Mat image = null;
+            Object model = null;
+            if (result != null) {
+                image = result.image;
+                model = result.model;
+            }
+
+            // If the result image is null and there is a working image, replace the result image
+            // replace the result image with a clone of the working image.
+            if (image == null) {
+                if (workingImage != null) {
+                    image = workingImage.clone();
+                }
+            }
+            // If the result image is not null:
+            // Release the working image if the result image is different.
+            // Replace the working image with the result image.
+            // Clone the result image for storage.
+            else {
+                if (workingImage != null && workingImage != image) {
+                    workingImage.release();
+                }
+                workingImage = image;
+                image = image.clone();
+            }
+
+            results.put(stage, new Result(image, model, processingTimeNs));
+        }
+    }
+
+    /**
+     * Release any temporary resources associated with the processing of the pipeline. Should be
+     * called when the pipeline is no longer needed. This is primarily to release retained native
+     * resources from OpenCV.
+     */
+    public void release() {
+        if (workingImage != null) {
+            workingImage.release();
+        }
+        for (Result result : results.values()) {
+            if (result.image != null) {
+                result.image.release();
+            }
+        }
+        results.clear();
+    }
+
+    /**
+     * Convert the pipeline to an XML string that can be read back in with #fromXmlString.
+     * 
+     * @return
+     * @throws Exception
+     */
+    public String toXmlString() throws Exception {
+        Serializer ser = Configuration.createSerializer();
+        StringWriter sw = new StringWriter();
+        ser.write(this, sw);
+        return sw.toString();
+    }
+
+    /**
+     * Parse the pipeline in the given String and replace the current pipeline with the results.
+     * 
+     * @param s
+     * @throws Exception
+     */
+    public void fromXmlString(String s) throws Exception {
+        release();
+        Serializer ser = Configuration.createSerializer();
+        StringReader sr = new StringReader(s);
+        CvPipeline pipeline = ser.read(CvPipeline.class, sr);
+        stages.clear();
+        for (CvStage stage : pipeline.getStages()) {
+            add(stage);
+        }
+    }
+
+    private String generateUniqueName() {
+        for (int i = 0;; i++) {
+            String name = "" + i;
+            if (getStage(name) == null) {
+                return name;
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/CvStage.java b/src/main/java/org/openpnp/vision/pipeline/CvStage.java
new file mode 100755
index 0000000000..1de183e0c8
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/CvStage.java
@@ -0,0 +1,100 @@
+package org.openpnp.vision.pipeline;
+
+import org.opencv.core.Mat;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Base class for a stage in a CvPipeline. A CvStage has a unique name within a pipeline and is able
+ * to perform computer vision operations reuslting in either a modified working image or a new image
+ * and optional model data extracted from the image.
+ */
+public abstract class CvStage {
+    @Attribute
+    private String name;
+
+    /**
+     * Perform an operation in a pipeline. Typical implementations will call
+     * CvPipeline#getWorkingImage(), perform some type of operation on the image and will return a
+     * Result containing a modified image and model data about features found in the image.
+     *
+     * If the stage only modifies the working image, it is sufficient to just return null, and this
+     * will typically be the most common case.
+     * 
+     * @param pipeline
+     * @return Null or a Result object containing an optional image and optional model. If the
+     *         return value is null the pipeline will store a copy of the working image as the
+     *         result for this stage. Otherwise it will set the working image to the result image
+     *         and store the result image.
+     * @throws Exception
+     */
+    public abstract Result process(CvPipeline pipeline) throws Exception;
+
+    public String getName() {
+        return name;
+    }
+
+    public CvStage setName(String name) {
+        this.name = name;
+        return this;
+    }
+
+    public static class Result {
+        final public Mat image;
+        final public Object model;
+        final public long processingTimeNs;
+
+        public Result(Mat image, Object model, long processingTimeNs) {
+            this.image = image;
+            this.model = model;
+            this.processingTimeNs = processingTimeNs;
+        }
+
+        public Result(Mat image, Object model) {
+            this(image, model, 0);
+        }
+
+        public Result(Mat image) {
+            this(image, null, 0);
+        }
+
+        public static class Circle {
+            public double x;
+            public double y;
+            public double diameter;
+
+            public Circle(double x, double y, double diameter) {
+                this.x = x;
+                this.y = y;
+                this.diameter = diameter;
+            }
+
+            @Override
+            public String toString() {
+                return "Circle [x=" + x + ", y=" + y + ", diameter=" + diameter + "]";
+            }
+        }
+
+        public static class TemplateMatch {
+            public double x;
+            public double y;
+            public double width;
+            public double height;
+            public double score;
+
+            public TemplateMatch(double x, double y, double width, double height,
+                    double score) {
+                this.x = x;
+                this.y = y;
+                this.width = width;
+                this.height = height;
+                this.score = score;
+            }
+
+            @Override
+            public String toString() {
+                return "TemplateMatch [x=" + x + ", y=" + y + ", width=" + width
+                        + ", height=" + height + ", score=" + score + "]";
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/BlurGaussian.java b/src/main/java/org/openpnp/vision/pipeline/stages/BlurGaussian.java
new file mode 100755
index 0000000000..1126f38094
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/BlurGaussian.java
@@ -0,0 +1,31 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.opencv.core.Mat;
+import org.opencv.core.Size;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Performs Gaussian blurring on the working image, updating it in place.
+ */
+public class BlurGaussian extends CvStage {
+    @Attribute
+    private int kernelSize = 3;
+
+    public int getKernelSize() {
+        return kernelSize;
+    }
+
+    public void setKernelSize(int kernelSize) {
+        this.kernelSize = kernelSize;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Mat mat = pipeline.getWorkingImage();
+        Imgproc.GaussianBlur(mat, mat, new Size(kernelSize, kernelSize), 0);
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ConvertColor.java b/src/main/java/org/openpnp/vision/pipeline/stages/ConvertColor.java
new file mode 100755
index 0000000000..c1feec14b6
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ConvertColor.java
@@ -0,0 +1,31 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.opencv.core.Mat;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.FluentCv;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Converts the color of the current working image to the specified conversion.
+ */
+public class ConvertColor extends CvStage {
+    @Attribute
+    private FluentCv.ColorCode conversion = FluentCv.ColorCode.Bgr2Gray;
+
+    public FluentCv.ColorCode getConversion() {
+        return conversion;
+    }
+
+    public void setConversion(FluentCv.ColorCode conversion) {
+        this.conversion = conversion;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Mat mat = pipeline.getWorkingImage();
+        Imgproc.cvtColor(mat, mat, conversion.getCode());
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/DetectCirclesHough.java b/src/main/java/org/openpnp/vision/pipeline/stages/DetectCirclesHough.java
new file mode 100755
index 0000000000..cec19a4df7
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/DetectCirclesHough.java
@@ -0,0 +1,115 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.opencv.core.Mat;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Finds circles in the working image and stores the results as a List<Circle> on the model. 
+ */
+public class DetectCirclesHough extends CvStage {
+    @Attribute
+    private int minDistance = 10;
+
+    @Attribute
+    private int minDiameter = 10;
+
+    @Attribute
+    private int maxDiameter = 100;
+
+    /**
+     * Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 ,
+     * the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
+     * half as big width and height.
+     */
+    @Attribute
+    private double dp = 1;
+
+    /**
+     * First method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the higher threshold of
+     * the two passed to the Canny() edge detector (the lower one is twice smaller).
+     */
+    @Attribute
+    private double param1 = 80;
+
+    /**
+     * Second method-specific parameter. In case of CV_HOUGH_GRADIENT , it is the accumulator
+     * threshold for the circle centers at the detection stage. The smaller it is, the more false
+     * circles may be detected. Circles, corresponding to the larger accumulator values, will be
+     * returned first.
+     */
+    @Attribute
+    private double param2 = 10;
+
+    public int getMinDistance() {
+        return minDistance;
+    }
+
+    public void setMinDistance(int minDistance) {
+        this.minDistance = minDistance;
+    }
+
+    public int getMinDiameter() {
+        return minDiameter;
+    }
+
+    public void setMinDiameter(int minDiameter) {
+        this.minDiameter = minDiameter;
+    }
+
+    public int getMaxDiameter() {
+        return maxDiameter;
+    }
+
+    public void setMaxDiameter(int maxDiameter) {
+        this.maxDiameter = maxDiameter;
+    }
+
+    public double getDp() {
+        return dp;
+    }
+
+    public void setDp(double dp) {
+        this.dp = dp;
+    }
+
+    public double getParam1() {
+        return param1;
+    }
+
+    public void setParam1(double param1) {
+        this.param1 = param1;
+    }
+
+    public double getParam2() {
+        return param2;
+    }
+
+    public void setParam2(double param2) {
+        this.param2 = param2;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Mat mat = pipeline.getWorkingImage();
+        Mat output = new Mat();
+        Imgproc.HoughCircles(mat, output, Imgproc.CV_HOUGH_GRADIENT, dp, minDistance, param1,
+                param2, minDiameter / 2, maxDiameter / 2);
+        List<Result.Circle> circles = new ArrayList<>();
+        for (int i = 0; i < output.cols(); i++) {
+            double[] circle = output.get(0, i);
+            double x = circle[0];
+            double y = circle[1];
+            double radius = circle[2];
+            circles.add(new Result.Circle(x, y, radius * 2.0));
+        }
+        output.release();
+
+        return new Result(null, circles);
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/DetectEdgesCanny.java b/src/main/java/org/openpnp/vision/pipeline/stages/DetectEdgesCanny.java
new file mode 100755
index 0000000000..98d06262fa
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/DetectEdgesCanny.java
@@ -0,0 +1,41 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.opencv.core.Mat;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Performs Canny edge detection on the working image, updating it with the results.
+ */
+public class DetectEdgesCanny extends CvStage {
+    @Attribute
+    double threshold1 = 40;
+
+    @Attribute
+    double threshold2 = 180;
+
+    public double getThreshold1() {
+        return threshold1;
+    }
+
+    public void setThreshold1(double threshold1) {
+        this.threshold1 = threshold1;
+    }
+
+    public double getThreshold2() {
+        return threshold2;
+    }
+
+    public void setThreshold2(double threshold2) {
+        this.threshold2 = threshold2;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Mat mat = pipeline.getWorkingImage();
+        Imgproc.Canny(mat, mat, threshold1, threshold2);
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/DrawCircles.java b/src/main/java/org/openpnp/vision/pipeline/stages/DrawCircles.java
new file mode 100755
index 0000000000..1c0a8a990a
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/DrawCircles.java
@@ -0,0 +1,79 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.awt.Color;
+import java.util.List;
+
+import org.opencv.core.Core;
+import org.opencv.core.Mat;
+import org.opencv.core.Point;
+import org.openpnp.util.HslColor;
+import org.openpnp.vision.FluentCv;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.stages.convert.ColorConverter;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Element;
+import org.simpleframework.xml.convert.Convert;
+
+/**
+ * Draws circles from a List<Circle> onto the working image. 
+ */
+public class DrawCircles extends CvStage {
+    @Element(required = false)
+    @Convert(ColorConverter.class)
+    private Color color = null;
+
+    @Element(required = false)
+    @Convert(ColorConverter.class)
+    private Color centerColor = null;
+
+    @Attribute(required = false)
+    private String circlesStageName = null;
+
+    public Color getColor() {
+        return color;
+    }
+
+    public void setColor(Color color) {
+        this.color = color;
+    }
+    
+    public Color getCenterColor() {
+        return centerColor;
+    }
+
+    public void setCenterColor(Color centerColor) {
+        this.centerColor = centerColor;
+    }
+
+    public String getCirclesStageName() {
+        return circlesStageName;
+    }
+
+    public void setCirclesStageName(String modelStageName) {
+        this.circlesStageName = modelStageName;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (circlesStageName == null) {
+            return null;
+        }
+        Result result = pipeline.getResult(circlesStageName);
+        if (result == null || result.model == null) {
+            return null;
+        }
+        Mat mat = pipeline.getWorkingImage();
+        List<Result.Circle> circles = (List<Result.Circle>) result.model;
+        for (int i = 0; i < circles.size(); i++) {
+            Result.Circle circle = circles.get(i);
+            Color color = this.color == null ? FluentCv.indexedColor(i) : this.color;
+            Color centerColor = this.centerColor == null ? new HslColor(color).getComplementary() : this.centerColor;
+            Core.circle(mat, new Point(circle.x, circle.y), (int) (circle.diameter / 2),
+                    FluentCv.colorToScalar(color), 2);
+            Core.circle(mat, new Point(circle.x, circle.y), 1, FluentCv.colorToScalar(centerColor),
+                    2);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/DrawKeyPoints.java b/src/main/java/org/openpnp/vision/pipeline/stages/DrawKeyPoints.java
new file mode 100755
index 0000000000..d71220758e
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/DrawKeyPoints.java
@@ -0,0 +1,65 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.awt.Color;
+import java.util.List;
+
+import org.opencv.core.Mat;
+import org.opencv.core.MatOfKeyPoint;
+import org.opencv.features2d.Features2d;
+import org.opencv.features2d.KeyPoint;
+import org.openpnp.vision.FluentCv;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.stages.convert.ColorConverter;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Element;
+import org.simpleframework.xml.convert.Convert;
+
+/**
+ * Draws KeyPoints contained in a List<KeyPoint> by referencing a previous stage's model data. 
+ */
+public class DrawKeyPoints extends CvStage {
+    @Element(required = false)
+    @Convert(ColorConverter.class)
+    private Color color = null;
+
+    @Attribute(required = false)
+    private String keyPointsStageName = null;
+
+    public Color getColor() {
+        return color;
+    }
+
+    public void setColor(Color color) {
+        this.color = color;
+    }
+    
+    public String getKeyPointsStageName() {
+        return keyPointsStageName;
+    }
+
+    public void setKeyPointsStageName(String keyPointsStageName) {
+        this.keyPointsStageName = keyPointsStageName;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (keyPointsStageName == null) {
+            return null;
+        }
+        Result result = pipeline.getResult(keyPointsStageName);
+        if (result == null || result.model == null) {
+            return null;
+        }
+        Mat mat = pipeline.getWorkingImage();
+        List<KeyPoint> keyPoints = (List<KeyPoint>) result.model;
+        MatOfKeyPoint matOfKeyPoints = new MatOfKeyPoint(keyPoints.toArray(new KeyPoint[] {}));
+        if (color == null) {
+            Features2d.drawKeypoints(mat, matOfKeyPoints, mat);
+        }
+        else {
+            Features2d.drawKeypoints(mat, matOfKeyPoints, mat, FluentCv.colorToScalar(color), 0);
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/DrawTemplateMatches.java b/src/main/java/org/openpnp/vision/pipeline/stages/DrawTemplateMatches.java
new file mode 100755
index 0000000000..1e8f2465b4
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/DrawTemplateMatches.java
@@ -0,0 +1,74 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.awt.Color;
+import java.util.List;
+
+import org.opencv.core.Core;
+import org.opencv.core.Mat;
+import org.opencv.core.Scalar;
+import org.openpnp.vision.FluentCv;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.CvStage.Result.TemplateMatch;
+import org.openpnp.vision.pipeline.stages.convert.ColorConverter;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Element;
+import org.simpleframework.xml.convert.Convert;
+
+/**
+ * Draws TemplatesMatches contained in a List<TemplateMatch> by referencing a previous stage's model data.
+ */
+public class DrawTemplateMatches extends CvStage {
+    @Element(required = false)
+    @Convert(ColorConverter.class)
+    private Color color = null;
+
+    @Attribute(required = false)
+    private String templateMatchesStageName = null;
+
+    public Color getColor() {
+        return color;
+    }
+
+    public void setColor(Color color) {
+        this.color = color;
+    }
+
+    public String getTemplateMatchesStageName() {
+        return templateMatchesStageName;
+    }
+
+    public void setTemplateMatchesStageName(String templateMatchesStageName) {
+        this.templateMatchesStageName = templateMatchesStageName;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (templateMatchesStageName == null) {
+            return null;
+        }
+        Result result = pipeline.getResult(templateMatchesStageName);
+        if (result == null || result.model == null) {
+            return null;
+        }
+        Mat mat = pipeline.getWorkingImage();
+
+        List<TemplateMatch> matches = (List<TemplateMatch>) result.model;
+        for (int i = 0; i < matches.size(); i++) {
+            TemplateMatch match = matches.get(i);
+            double x = match.x;
+            double y = match.y;
+            double score = match.score;
+            double width = match.width;
+            double height = match.height;
+            Color color_ = this.color == null ? FluentCv.indexedColor(i) : this.color;
+            Scalar color = FluentCv.colorToScalar(color_);
+            Core.rectangle(mat, new org.opencv.core.Point(x, y),
+                    new org.opencv.core.Point(x + width, y + height), color);
+            Core.putText(mat, "" + score, new org.opencv.core.Point(x + width, y + height),
+                    Core.FONT_HERSHEY_PLAIN, 1.0, color);
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/GenerateImage.java b/src/main/java/org/openpnp/vision/pipeline/stages/GenerateImage.java
new file mode 100755
index 0000000000..0d95e4d457
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/GenerateImage.java
@@ -0,0 +1,40 @@
+//package org.openpnp.vision.pipeline.stages;
+//
+//import java.awt.image.BufferedImage;
+//
+//import org.openpnp.spi.Camera;
+//import org.openpnp.util.OpenCvUtils;
+//import org.openpnp.vision.pipeline.CvPipeline;
+//import org.openpnp.vision.pipeline.CvStage;
+//import org.simpleframework.xml.Attribute;
+//
+///**
+// * Generate an image from a variety of native types. Uses reflection to determine the type of
+// * the input and attempts to generate an image from it based on the provided parameters. 
+// */
+//public class GenerateImage extends CvStage {
+//    @Attribute
+//    private String modelStageName;
+//    
+//    @Override
+//    public Result process(CvPipeline pipeline) throws Exception {
+//        if (modelStageName == null) {
+//            throw new Exception("modelStageName is required.");
+//        }
+//        
+//        
+//        
+//        Camera camera = pipeline.getCamera();
+//        if (camera == null) {
+//            throw new Exception("No Camera set on pipeline.");
+//        }
+////        BufferedImage image;
+////        if (settleFirst) {
+////            image = camera.settleAndCapture();
+////        }
+////        else {
+////            image = camera.capture();
+////        }
+//        return new Result(OpenCvUtils.toMat(image));
+//    }
+//}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ImageCapture.java b/src/main/java/org/openpnp/vision/pipeline/stages/ImageCapture.java
new file mode 100755
index 0000000000..26e84f1afd
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ImageCapture.java
@@ -0,0 +1,38 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.awt.image.BufferedImage;
+
+import org.openpnp.spi.Camera;
+import org.openpnp.util.OpenCvUtils;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+public class ImageCapture extends CvStage {
+    @Attribute
+    private boolean settleFirst;
+    
+    public boolean isSettleFirst() {
+        return settleFirst;
+    }
+
+    public void setSettleFirst(boolean settleFirst) {
+        this.settleFirst = settleFirst;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Camera camera = pipeline.getCamera();
+        if (camera == null) {
+            throw new Exception("No Camera set on pipeline.");
+        }
+        BufferedImage image;
+        if (settleFirst) {
+            image = camera.settleAndCapture();
+        }
+        else {
+            image = camera.capture();
+        }
+        return new Result(OpenCvUtils.toMat(image));
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ImageRead.java b/src/main/java/org/openpnp/vision/pipeline/stages/ImageRead.java
new file mode 100755
index 0000000000..d9298ea4d3
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ImageRead.java
@@ -0,0 +1,29 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.io.File;
+
+import org.opencv.highgui.Highgui;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Replace the working image with the image loaded from a given path.
+ */
+public class ImageRead extends CvStage {
+    @Attribute
+    private File file = new File("");
+
+    public File getFile() {
+        return file;
+    }
+
+    public void setFile(File file) {
+        this.file = file;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        return new Result(Highgui.imread(file.getAbsolutePath()));
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ImageRecall.java b/src/main/java/org/openpnp/vision/pipeline/stages/ImageRecall.java
new file mode 100755
index 0000000000..a526570505
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ImageRecall.java
@@ -0,0 +1,30 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+public class ImageRecall extends CvStage {
+    @Attribute(required = false)
+    private String imageStageName = null;
+
+    public String getImageStageName() {
+        return imageStageName;
+    }
+
+    public void setImageStageName(String imageStageName) {
+        this.imageStageName = imageStageName;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (imageStageName == null) {
+            return null;
+        }
+        Result result = pipeline.getResult(imageStageName);
+        if (result == null || result.image == null) {
+            return null;
+        }
+        return new Result(result.image.clone());
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ImageWrite.java b/src/main/java/org/openpnp/vision/pipeline/stages/ImageWrite.java
new file mode 100755
index 0000000000..4e2c82f6c4
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ImageWrite.java
@@ -0,0 +1,31 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.io.File;
+
+import org.opencv.highgui.Highgui;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * Save the working image to the specified path. The format is chosen based on the filename's
+ * extension.
+ */
+public class ImageWrite extends CvStage {
+    @Attribute
+    private File file = new File("");
+
+    public File getFile() {
+        return file;
+    }
+
+    public void setFile(File file) {
+        this.file = file;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Highgui.imwrite(file.getAbsolutePath(), pipeline.getWorkingImage());
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/MatchTemplate.java b/src/main/java/org/openpnp/vision/pipeline/stages/MatchTemplate.java
new file mode 100755
index 0000000000..ce61544321
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/MatchTemplate.java
@@ -0,0 +1,218 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.awt.Point;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+import org.opencv.core.Core;
+import org.opencv.core.Core.MinMaxLocResult;
+import org.opencv.core.Mat;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.CvStage.Result.TemplateMatch;
+import org.simpleframework.xml.Attribute;
+
+/**
+ * OpenCV based image template matching with local maxima detection improvements from FireSight:
+ * https://github.com/firepick1/FireSight. Scans the working image for matches of a template image
+ * and returns a list of matches.
+ */
+public class MatchTemplate extends CvStage {
+    /**
+     * Name of a prior stage to load the template image from.
+     */
+    @Attribute
+    private String templateStageName;
+
+    /**
+     * If maxVal is below this value, then no matches will be reported. Default is 0.7.
+     */
+    @Attribute
+    private double threshold = 0.7f;
+
+    /**
+     * Normalized recognition threshold in the interval [0,1]. Used to determine best match of
+     * candidates. For CV_TM_CCOEFF, CV_TM_CCOEFF_NORMED, CV_TM_CCORR, and CV_TM_CCORR_NORMED
+     * methods, this is a minimum threshold for positive recognition; for all other methods, it is a
+     * maximum threshold. Default is 0.85.
+     */
+    @Attribute
+    private double corr = 0.85f;
+
+    public String getTemplateStageName() {
+        return templateStageName;
+    }
+
+    public void setTemplateStageName(String templateStageName) {
+        this.templateStageName = templateStageName;
+    }
+
+    public double getThreshold() {
+        return threshold;
+    }
+
+    public void setThreshold(double threshold) {
+        this.threshold = threshold;
+    }
+
+    public double getCorr() {
+        return corr;
+    }
+
+    public void setCorr(double corr) {
+        this.corr = corr;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (templateStageName == null) {
+            return null;
+        }
+
+        Mat mat = pipeline.getWorkingImage();
+        Mat template = pipeline.getResult(templateStageName).image;
+        Mat result = new Mat();
+
+        // TODO: externalize type
+        Imgproc.matchTemplate(mat, template, result, Imgproc.TM_CCOEFF_NORMED);
+
+        MinMaxLocResult mmr = Core.minMaxLoc(result);
+        double maxVal = mmr.maxVal;
+
+        double rangeMin = Math.max(threshold, corr * maxVal);
+        double rangeMax = maxVal;
+
+
+        List<TemplateMatch> matches = new ArrayList<>();
+        for (Point point : matMaxima(result, rangeMin, rangeMax)) {
+            int x = point.x;
+            int y = point.y;
+            TemplateMatch match = new TemplateMatch(x, y, template.cols(), template.rows(),
+                    result.get(y, x)[0] / maxVal);
+            matches.add(match);
+        }
+
+        Collections.sort(matches, new Comparator<TemplateMatch>() {
+            @Override
+            public int compare(TemplateMatch o1, TemplateMatch o2) {
+                return ((Double) o2.score).compareTo(o1.score);
+            }
+        });
+
+
+        return new Result(result, matches);
+    }
+
+    enum MinMaxState {
+        BEFORE_INFLECTION, AFTER_INFLECTION
+    }
+
+    static List<Point> matMaxima(Mat mat, double rangeMin, double rangeMax) {
+        List<Point> locations = new ArrayList<>();
+
+        int rEnd = mat.rows() - 1;
+        int cEnd = mat.cols() - 1;
+
+        // CHECK EACH ROW MAXIMA FOR LOCAL 2D MAXIMA
+        for (int r = 0; r <= rEnd; r++) {
+            MinMaxState state = MinMaxState.BEFORE_INFLECTION;
+            double curVal = mat.get(r, 0)[0];
+            for (int c = 1; c <= cEnd; c++) {
+                double val = mat.get(r, c)[0];
+
+                if (val == curVal) {
+                    continue;
+                }
+                else if (curVal < val) {
+                    if (state == MinMaxState.BEFORE_INFLECTION) {
+                        // n/a
+                    }
+                    else {
+                        state = MinMaxState.BEFORE_INFLECTION;
+                    }
+                }
+                else { // curVal > val
+                    if (state == MinMaxState.BEFORE_INFLECTION) {
+                        if (rangeMin <= curVal && curVal <= rangeMax) { // ROW
+                                                                        // MAXIMA
+                            if (0 < r && (mat.get(r - 1, c - 1)[0] >= curVal
+                                    || mat.get(r - 1, c)[0] >= curVal)) {
+                                // cout << "reject:r-1 " << r << "," << c-1 <<
+                                // endl;
+                                // - x x
+                                // - - -
+                                // - - -
+                            }
+                            else if (r < rEnd && (mat.get(r + 1, c - 1)[0] > curVal
+                                    || mat.get(r + 1, c)[0] > curVal)) {
+                                // cout << "reject:r+1 " << r << "," << c-1 <<
+                                // endl;
+                                // - - -
+                                // - - -
+                                // - x x
+                            }
+                            else if (1 < c && (0 < r && mat.get(r - 1, c - 2)[0] >= curVal
+                                    || mat.get(r, c - 2)[0] > curVal
+                                    || r < rEnd && mat.get(r + 1, c - 2)[0] > curVal)) {
+                                // cout << "reject:c-2 " << r << "," << c-1 <<
+                                // endl;
+                                // x - -
+                                // x - -
+                                // x - -
+                            }
+                            else {
+                                locations.add(new Point(c - 1, r));
+                            }
+                        }
+                        state = MinMaxState.AFTER_INFLECTION;
+                    }
+                    else {
+                        // n/a
+                    }
+                }
+
+                curVal = val;
+            }
+
+            // PROCESS END OF ROW
+            if (state == MinMaxState.BEFORE_INFLECTION) {
+                if (rangeMin <= curVal && curVal <= rangeMax) { // ROW MAXIMA
+                    if (0 < r && (mat.get(r - 1, cEnd - 1)[0] >= curVal
+                            || mat.get(r - 1, cEnd)[0] >= curVal)) {
+                        // cout << "rejectEnd:r-1 " << r << "," << cEnd-1 <<
+                        // endl;
+                        // - x x
+                        // - - -
+                        // - - -
+                    }
+                    else if (r < rEnd && (mat.get(r + 1, cEnd - 1)[0] > curVal
+                            || mat.get(r + 1, cEnd)[0] > curVal)) {
+                        // cout << "rejectEnd:r+1 " << r << "," << cEnd-1 <<
+                        // endl;
+                        // - - -
+                        // - - -
+                        // - x x
+                    }
+                    else if (1 < r && mat.get(r - 1, cEnd - 2)[0] >= curVal
+                            || mat.get(r, cEnd - 2)[0] > curVal
+                            || r < rEnd && mat.get(r + 1, cEnd - 2)[0] > curVal) {
+                        // cout << "rejectEnd:cEnd-2 " << r << "," << cEnd-1 <<
+                        // endl;
+                        // x - -
+                        // x - -
+                        // x - -
+                    }
+                    else {
+                        locations.add(new Point(cEnd, r));
+                    }
+                }
+            }
+        }
+
+        return locations;
+    }
+
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/ReadModelProperty.java b/src/main/java/org/openpnp/vision/pipeline/stages/ReadModelProperty.java
new file mode 100755
index 0000000000..1b35182db3
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/ReadModelProperty.java
@@ -0,0 +1,56 @@
+package org.openpnp.vision.pipeline.stages;
+
+import java.lang.reflect.Method;
+
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+import com.l2fprod.common.beans.BeanUtils;
+
+/**
+ * Get an object from a previous stage's model by querying the named property. The resulting
+ * object is stored as this stage's model. 
+ */
+public class ReadModelProperty extends CvStage {
+    @Attribute
+    private String modelStageName;
+    
+    @Attribute
+    private String propertyName;
+    
+    public String getModelStageName() {
+        return modelStageName;
+    }
+
+    public void setModelStageName(String modelStageName) {
+        this.modelStageName = modelStageName;
+    }
+
+    public String getPropertyName() {
+        return propertyName;
+    }
+
+    public void setPropertyName(String propertyName) {
+        this.propertyName = propertyName;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        if (modelStageName == null) {
+            throw new Exception("modelStageName is required.");
+        }
+        
+        if (propertyName == null) {
+            throw new Exception("propertyName is required.");
+        }
+        
+        Result result = pipeline.getResult(modelStageName);
+        Object model = result.model;
+
+        Method method = BeanUtils.getReadMethod(model.getClass(), propertyName);
+        Object value = method.invoke(model);
+        
+        return new Result(null, value);
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/SetModel.java b/src/main/java/org/openpnp/vision/pipeline/stages/SetModel.java
new file mode 100755
index 0000000000..9ff65cd057
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/SetModel.java
@@ -0,0 +1,21 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+
+/**
+ * Programmatic stage which simply sets it's model to the object passed in on the constructor. This
+ * is used for setting up pipelines before they are edited by the user. 
+ */
+public class SetModel extends CvStage {
+    private Object model;
+    
+    public SetModel(Object model) {
+        this.model = model;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        return new Result(null, model);
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/Threshold.java b/src/main/java/org/openpnp/vision/pipeline/stages/Threshold.java
new file mode 100755
index 0000000000..a817a28da5
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/Threshold.java
@@ -0,0 +1,51 @@
+package org.openpnp.vision.pipeline.stages;
+
+import org.opencv.core.Mat;
+import org.opencv.imgproc.Imgproc;
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.simpleframework.xml.Attribute;
+
+public class Threshold extends CvStage {
+    @Attribute
+    private int threshold = 100;
+
+    @Attribute
+    private boolean auto = false;
+
+    @Attribute
+    private boolean invert = false;
+
+    public int getThreshold() {
+        return threshold;
+    }
+
+    public void setThreshold(int threshold) {
+        this.threshold = threshold;
+    }
+
+    public boolean isAuto() {
+        return auto;
+    }
+
+    public void setAuto(boolean auto) {
+        this.auto = auto;
+    }
+
+    public boolean isInvert() {
+        return invert;
+    }
+
+    public void setInvert(boolean invert) {
+        this.invert = invert;
+    }
+
+    @Override
+    public Result process(CvPipeline pipeline) throws Exception {
+        Mat mat = pipeline.getWorkingImage();
+        int type = invert ? Imgproc.THRESH_BINARY_INV : Imgproc.THRESH_BINARY;
+        type |= auto ? Imgproc.THRESH_OTSU : 0;
+        Imgproc.threshold(mat, mat, threshold, 255, type);
+        return null;
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/stages/convert/ColorConverter.java b/src/main/java/org/openpnp/vision/pipeline/stages/convert/ColorConverter.java
new file mode 100755
index 0000000000..62732e0cd6
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/stages/convert/ColorConverter.java
@@ -0,0 +1,27 @@
+package org.openpnp.vision.pipeline.stages.convert;
+
+import java.awt.Color;
+
+import org.simpleframework.xml.convert.Converter;
+import org.simpleframework.xml.stream.InputNode;
+import org.simpleframework.xml.stream.OutputNode;
+
+public class ColorConverter implements Converter<Color> {
+
+    @Override
+    public Color read(InputNode node) throws Exception {
+        int r = Integer.parseInt(node.getAttribute("r").getValue());
+        int g = Integer.parseInt(node.getAttribute("g").getValue());
+        int b = Integer.parseInt(node.getAttribute("b").getValue());
+        int a = Integer.parseInt(node.getAttribute("a").getValue());
+        return new Color(r, g, b, a);
+    }
+
+    @Override
+    public void write(OutputNode node, Color value) throws Exception {
+        node.setAttribute("r", "" + value.getRed());
+        node.setAttribute("g", "" + value.getGreen());
+        node.setAttribute("b", "" + value.getBlue());
+        node.setAttribute("a", "" + value.getAlpha());
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/CvPipelineEditor.java b/src/main/java/org/openpnp/vision/pipeline/ui/CvPipelineEditor.java
new file mode 100755
index 0000000000..d254ea2edc
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/CvPipelineEditor.java
@@ -0,0 +1,136 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.awt.BorderLayout;
+import java.awt.Point;
+import java.awt.event.HierarchyEvent;
+import java.awt.event.HierarchyListener;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+import javax.swing.JFrame;
+import javax.swing.JPanel;
+import javax.swing.JSplitPane;
+import javax.swing.UIManager;
+
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.stages.BlurGaussian;
+import org.openpnp.vision.pipeline.stages.ConvertColor;
+import org.openpnp.vision.pipeline.stages.DetectCirclesHough;
+import org.openpnp.vision.pipeline.stages.DetectEdgesCanny;
+import org.openpnp.vision.pipeline.stages.DrawCircles;
+import org.openpnp.vision.pipeline.stages.DrawKeyPoints;
+import org.openpnp.vision.pipeline.stages.DrawTemplateMatches;
+import org.openpnp.vision.pipeline.stages.ImageCapture;
+import org.openpnp.vision.pipeline.stages.ImageRead;
+import org.openpnp.vision.pipeline.stages.ImageRecall;
+import org.openpnp.vision.pipeline.stages.ImageWrite;
+import org.openpnp.vision.pipeline.stages.MatchTemplate;
+import org.openpnp.vision.pipeline.stages.ReadModelProperty;
+import org.openpnp.vision.pipeline.stages.SetModel;
+import org.openpnp.vision.pipeline.stages.Threshold;
+
+/**
+ * A JPanel based component for editing a CvPipeline. Allows the user to add and remove stages,
+ * modify properties of each stage, see the image and model results from each stage and export and
+ * import the pipeline from the clipboard.
+ * 
+ * The static method #registerStageClass can be used to register a CvStage implementation with this
+ * component, allowing the user to select the implementation from the list when creating a new
+ * stage.
+ * 
+ * The core CvStage classes are automatically registered during startup.
+ */
+@SuppressWarnings("serial")
+public class CvPipelineEditor extends JPanel {
+    static {
+        stageClasses = new HashSet<>();
+        registerStageClass(BlurGaussian.class);
+        registerStageClass(ConvertColor.class);
+        registerStageClass(DetectCirclesHough.class);
+        registerStageClass(DetectEdgesCanny.class);
+        registerStageClass(DrawCircles.class);
+        registerStageClass(DrawKeyPoints.class);
+        registerStageClass(DrawTemplateMatches.class);
+        registerStageClass(ImageCapture.class);
+        registerStageClass(ImageRead.class);
+        registerStageClass(ImageRecall.class);
+        registerStageClass(ImageWrite.class);
+        registerStageClass(MatchTemplate.class);
+        registerStageClass(ReadModelProperty.class);
+        registerStageClass(Threshold.class);
+    }
+
+    private final static Set<Class<? extends CvStage>> stageClasses;
+
+    private final CvPipeline pipeline;
+    private PipelinePanel pipelinePanel;
+    private ResultsPanel resultsPanel;
+
+    public CvPipelineEditor(CvPipeline pipeline) {
+        this.pipeline = pipeline;
+
+        setLayout(new BorderLayout(0, 0));
+
+        JSplitPane inputAndOutputSplitPane = new JSplitPane();
+        inputAndOutputSplitPane.setContinuousLayout(true);
+        add(inputAndOutputSplitPane, BorderLayout.CENTER);
+
+        pipelinePanel = new PipelinePanel(this);
+        inputAndOutputSplitPane.setLeftComponent(pipelinePanel);
+        resultsPanel = new ResultsPanel(this);
+        inputAndOutputSplitPane.setRightComponent(resultsPanel);
+
+        addHierarchyListener(new HierarchyListener() {
+            @Override
+            public void hierarchyChanged(HierarchyEvent e) {
+                inputAndOutputSplitPane.setDividerLocation(0.25);
+            }
+        });
+
+        process();
+    }
+
+    public CvPipeline getPipeline() {
+        return pipeline;
+    }
+
+    public void process() {
+        getPipeline().process();
+        resultsPanel.refresh();
+    }
+
+    public void stageSelected(CvStage stage) {
+        resultsPanel.setSelectedStage(stage);
+    }
+
+    public static Set<Class<? extends CvStage>> getStageClasses() {
+        return Collections.unmodifiableSet(stageClasses);
+    }
+
+    public static void registerStageClass(Class<? extends CvStage> cls) {
+        stageClasses.add(cls);
+    }
+
+    public static void main(String[] args) throws Exception {
+        // http://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/07-NativePlatformIntegration/NativePlatformIntegration.html#//apple_ref/doc/uid/TP40001909-212952-TPXREF134
+        System.setProperty("apple.laf.useScreenMenuBar", "true");
+        try {
+            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        }
+        catch (Exception e) {
+            throw new Error(e);
+        }
+
+        CvPipeline pipeline = new CvPipeline();
+        pipeline.add(new SetModel(new Point(10, 20)));
+
+        JFrame frame = new JFrame("CvPipelineEditor");
+        frame.setSize(1024, 768);
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.getContentPane().setLayout(new BorderLayout());
+        frame.getContentPane().add(new CvPipelineEditor(pipeline));
+        frame.setVisible(true);
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/MatView.java b/src/main/java/org/openpnp/vision/pipeline/ui/MatView.java
new file mode 100755
index 0000000000..bc4d46e96e
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/MatView.java
@@ -0,0 +1,77 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Insets;
+import java.awt.image.BufferedImage;
+
+import javax.swing.JComponent;
+
+import org.opencv.core.Mat;
+import org.openpnp.util.OpenCvUtils;
+
+public class MatView extends JComponent {
+    private BufferedImage image;
+
+    public MatView() {
+        setBackground(Color.black);
+    }
+
+    public void setMat(Mat mat) {
+        if (mat == null || mat.empty()) {
+            image = null;
+        }
+        else {
+            image = OpenCvUtils.toBufferedImage(mat);
+        }
+        repaint();
+    }
+
+    @Override
+    protected void paintComponent(Graphics g) {
+        super.paintComponent(g);
+        if (image == null) {
+            return;
+        }
+
+        Insets ins = getInsets();
+        double sourceWidth = image.getWidth();
+        double sourceHeight = image.getHeight();
+        double destWidth = getWidth() - ins.left - ins.right;
+        double destHeight = getHeight() - ins.top - ins.bottom;
+
+        /**
+         * We want to fit both axes in the given destWidth and destHeight while maintaining the
+         * aspect ratio. If the frame is smaller in either or both axes than the original will need
+         * to be scaled to fill the space as completely as possible while still maintaining the
+         * aspect ratio. 1. Determine the source size of the image: sourceWidth, sourceHeight. 2.
+         * Determine the max size each axis can be: destWidth, destHeight. 3. Calculate how much
+         * each axis needs to be scaled to fit. 4. Use the larger of the two and scale the opposite
+         * axis by the aspect ratio + the scaling ratio.
+         */
+
+        double widthRatio = sourceWidth / destWidth;
+        double heightRatio = sourceHeight / destHeight;
+
+        double scaledHeight, scaledWidth;
+
+        if (heightRatio > widthRatio) {
+            double aspectRatio = sourceWidth / sourceHeight;
+            scaledHeight = destHeight;
+            scaledWidth = (scaledHeight * aspectRatio);
+        }
+        else {
+            double aspectRatio = sourceHeight / sourceWidth;
+            scaledWidth = destWidth;
+            scaledHeight = (scaledWidth * aspectRatio);
+        }
+
+        int imageX = (int) (ins.left + (destWidth / 2) - (scaledWidth / 2));
+        int imageY = (int) (ins.top + (destHeight / 2) - (scaledHeight / 2));
+
+        Graphics2D g2d = (Graphics2D) g;
+
+        g2d.drawImage(image, imageX, imageY, (int) scaledWidth, (int) scaledHeight, null);
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/PipelinePanel.java b/src/main/java/org/openpnp/vision/pipeline/ui/PipelinePanel.java
new file mode 100755
index 0000000000..7d72705924
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/PipelinePanel.java
@@ -0,0 +1,273 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.awt.BorderLayout;
+import java.awt.Toolkit;
+import java.awt.datatransfer.Clipboard;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.StringSelection;
+import java.awt.event.ActionEvent;
+import java.awt.event.HierarchyEvent;
+import java.awt.event.HierarchyListener;
+import java.beans.Introspector;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+
+import javax.swing.AbstractAction;
+import javax.swing.Action;
+import javax.swing.DropMode;
+import javax.swing.JButton;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTable;
+import javax.swing.JToolBar;
+import javax.swing.ListSelectionModel;
+import javax.swing.event.ListSelectionEvent;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+
+import org.openpnp.gui.components.ClassSelectionDialog;
+import org.openpnp.gui.support.Helpers;
+import org.openpnp.gui.support.Icons;
+import org.openpnp.gui.support.MessageBoxes;
+import org.openpnp.vision.pipeline.CvStage;
+
+import com.l2fprod.common.propertysheet.Property;
+import com.l2fprod.common.propertysheet.PropertySheetPanel;
+
+public class PipelinePanel extends JPanel {
+    private final CvPipelineEditor editor;
+
+    private JTable stagesTable;
+    private StagesTableModel stagesTableModel;
+    private PropertySheetPanel propertySheetPanel;
+
+    public PipelinePanel(CvPipelineEditor editor) {
+        this.editor = editor;
+
+        propertySheetPanel = new PropertySheetPanel();
+
+        setLayout(new BorderLayout(0, 0));
+
+        JSplitPane splitPane = new JSplitPane();
+        add(splitPane, BorderLayout.CENTER);
+        splitPane.setContinuousLayout(true);
+        splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
+
+        JToolBar toolbar = new JToolBar();
+        add(toolbar, BorderLayout.NORTH);
+
+        JButton refreshButton = new JButton(refreshAction);
+        refreshButton.setHideActionText(true);
+        toolbar.add(refreshButton);
+
+        JButton btnAdd = new JButton(newStageAction);
+        btnAdd.setHideActionText(true);
+        toolbar.add(btnAdd);
+
+        JButton btnRemove = new JButton(deleteStageAction);
+        btnRemove.setHideActionText(true);
+        toolbar.add(btnRemove);
+
+        toolbar.addSeparator();
+
+        JButton copyButton = new JButton(copyAction);
+        copyButton.setHideActionText(true);
+        toolbar.add(copyButton);
+
+        JButton pasteButton = new JButton(pasteAction);
+        pasteButton.setHideActionText(true);
+        toolbar.add(pasteButton);
+
+        stagesTable = new JTable(stagesTableModel = new StagesTableModel(editor.getPipeline()));
+        stagesTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+        stagesTable.setDragEnabled(true);
+        stagesTable.setDropMode(DropMode.INSERT_ROWS);
+        stagesTable.setTransferHandler(new TableRowTransferHandler(stagesTable));
+
+        JScrollPane scrollPane = new JScrollPane(stagesTable);
+
+        splitPane.setRightComponent(propertySheetPanel);
+        splitPane.setLeftComponent(scrollPane);
+
+        stagesTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
+            @Override
+            public void valueChanged(ListSelectionEvent e) {
+                if (e.getValueIsAdjusting()) {
+                    return;
+                }
+                CvStage stage = getSelectedStage();
+                editor.stageSelected(stage);
+                if (stage == null) {
+                    propertySheetPanel.setProperties(new Property[] {});
+                }
+                else {
+                    try {
+                        propertySheetPanel.setBeanInfo(
+                                Introspector.getBeanInfo(stage.getClass(), CvStage.class));
+                        propertySheetPanel.readFromObject(stage);
+                    }
+                    catch (Exception ex) {
+                        ex.printStackTrace();
+                    }
+                }
+            }
+        });
+
+        stagesTable.getModel().addTableModelListener(new TableModelListener() {
+            @Override
+            public void tableChanged(TableModelEvent e) {
+                editor.process();
+            }
+        });
+
+        addHierarchyListener(new HierarchyListener() {
+            @Override
+            public void hierarchyChanged(HierarchyEvent e) {
+                splitPane.setDividerLocation(0.5);
+            }
+        });
+
+        propertySheetPanel.getTable().addPropertyChangeListener(new PropertyChangeListener() {
+            @Override
+            public void propertyChange(PropertyChangeEvent e) {
+                if ("tableCellEditor".equals(e.getPropertyName())) {
+                    if (!propertySheetPanel.getTable().isEditing()) {
+                        // editing has ended for a cell, save the values
+                        propertySheetPanel.writeToObject(getSelectedStage());
+                        editor.process();
+                    }
+                }
+            }
+        });
+    }
+
+    public CvStage getSelectedStage() {
+        int index = stagesTable.getSelectedRow();
+        if (index == -1) {
+            return null;
+        }
+        else {
+            index = stagesTable.convertRowIndexToModel(index);
+            return stagesTableModel.getStage(index);
+        }
+    }
+
+    public Action newStageAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.add);
+            putValue(NAME, "New Stage...");
+            putValue(SHORT_DESCRIPTION, "Create a new stage.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            List<Class<? extends CvStage>> stageClasses = new ArrayList<>(editor.getStageClasses());
+            stageClasses.sort(new Comparator<Class<? extends CvStage>>() {
+                @Override
+                public int compare(Class<? extends CvStage> o1, Class<? extends CvStage> o2) {
+                    return o1.getSimpleName().toLowerCase()
+                            .compareTo(o2.getSimpleName().toLowerCase());
+                }
+            });
+            ClassSelectionDialog<CvStage> dialog = new ClassSelectionDialog<>(
+                    JOptionPane.getFrameForComponent(PipelinePanel.this), "New Stage",
+                    "Please select a stage implemention from the list below.", stageClasses);
+            dialog.setVisible(true);
+            Class<? extends CvStage> stageClass = dialog.getSelectedClass();
+            if (stageClass == null) {
+                return;
+            }
+            try {
+                CvStage stage = stageClass.newInstance();
+                editor.getPipeline().add(stage);
+                stagesTableModel.refresh();
+                Helpers.selectLastTableRow(stagesTable);
+                editor.process();
+            }
+            catch (Exception e) {
+                MessageBoxes.errorBox(JOptionPane.getFrameForComponent(PipelinePanel.this), "Error",
+                        e);
+            }
+        }
+    };
+
+    public Action deleteStageAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.delete);
+            putValue(NAME, "Delete Stage...");
+            putValue(SHORT_DESCRIPTION, "Delete the selected stage.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            CvStage stage = getSelectedStage();
+            editor.getPipeline().remove(stage);
+            stagesTableModel.refresh();
+            editor.process();
+        }
+    };
+
+    public final Action copyAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.copy);
+            putValue(NAME, "Copy Pipeline to Clipboard");
+            putValue(SHORT_DESCRIPTION, "Copy the pipeline to the clipboard in text format.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            try {
+                StringSelection stringSelection =
+                        new StringSelection(editor.getPipeline().toXmlString());
+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
+                clipboard.setContents(stringSelection, null);
+            }
+            catch (Exception e) {
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Copy Failed", e);
+            }
+        }
+    };
+
+    public final Action pasteAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.paste);
+            putValue(NAME, "Create Pipeline from Clipboard");
+            putValue(SHORT_DESCRIPTION,
+                    "Create a new pipeline from a definition on the clipboard.");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            try {
+                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
+                String s = (String) clipboard.getData(DataFlavor.stringFlavor);
+                editor.getPipeline().fromXmlString(s);
+                stagesTableModel.refresh();
+                Helpers.selectLastTableRow(stagesTable);
+                editor.process();
+            }
+            catch (Exception e) {
+                MessageBoxes.errorBox(getTopLevelAncestor(), "Paste Failed", e);
+            }
+        }
+    };
+
+    public final Action refreshAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.refresh);
+            putValue(NAME, "");
+            putValue(SHORT_DESCRIPTION, "");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            editor.process();
+        }
+    };
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/Reorderable.java b/src/main/java/org/openpnp/vision/pipeline/ui/Reorderable.java
new file mode 100755
index 0000000000..82fa1323bb
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/Reorderable.java
@@ -0,0 +1,8 @@
+package org.openpnp.vision.pipeline.ui;
+
+/**
+ * From: http://stackoverflow.com/questions/638807/how-do-i-drag-and-drop-a-row-in-a-jtable
+ */
+public interface Reorderable {
+    public void reorder(int fromIndex, int toIndex);
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/ResultsPanel.java b/src/main/java/org/openpnp/vision/pipeline/ui/ResultsPanel.java
new file mode 100755
index 0000000000..0e6960fbde
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/ResultsPanel.java
@@ -0,0 +1,220 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.awt.BorderLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.HierarchyEvent;
+import java.awt.event.HierarchyListener;
+import java.util.List;
+
+import javax.swing.AbstractAction;
+import javax.swing.Action;
+import javax.swing.JButton;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTextPane;
+import javax.swing.JToolBar;
+import javax.swing.SwingConstants;
+
+import org.opencv.core.Mat;
+import org.openpnp.gui.support.Icons;
+import org.openpnp.vision.pipeline.CvStage;
+import org.openpnp.vision.pipeline.CvStage.Result;
+
+public class ResultsPanel extends JPanel {
+    private final CvPipelineEditor editor;
+
+    private CvStage selectedStage;
+
+    public ResultsPanel(CvPipelineEditor editor) {
+        this.editor = editor;
+
+        JSplitPane splitPane = new JSplitPane();
+        splitPane.setContinuousLayout(true);
+        splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
+
+        setLayout(new BorderLayout(0, 0));
+
+        JPanel headerPanel = new JPanel();
+        add(headerPanel, BorderLayout.NORTH);
+        headerPanel.setLayout(new BorderLayout(0, 0));
+
+        resultStageNameLabel = new JLabel("New label");
+        headerPanel.add(resultStageNameLabel, BorderLayout.NORTH);
+        resultStageNameLabel.setHorizontalAlignment(SwingConstants.CENTER);
+
+        JPanel panel = new JPanel();
+        headerPanel.add(panel, BorderLayout.SOUTH);
+
+        JToolBar toolBar = new JToolBar();
+        panel.add(toolBar);
+
+        JButton firstResultButton = new JButton(firstResultAction);
+        firstResultButton.setHideActionText(true);
+        toolBar.add(firstResultButton);
+
+        JButton previousResultButton = new JButton(previousResultAction);
+        previousResultButton.setHideActionText(true);
+        toolBar.add(previousResultButton);
+
+        JButton nextResultButton = new JButton(nextResultAction);
+        toolBar.add(nextResultButton);
+
+        JButton lastResultButton = new JButton(lastResultAction);
+        lastResultButton.setHideActionText(true);
+        toolBar.add(lastResultButton);
+
+        matView = new MatView();
+
+        JPanel modelPanel = new JPanel();
+        modelPanel.setLayout(new BorderLayout(0, 0));
+
+        modelTextPane = new JTextPane();
+        modelPanel.add(new JScrollPane(modelTextPane));
+
+        add(splitPane, BorderLayout.CENTER);
+
+        splitPane.setLeftComponent(matView);
+        splitPane.setRightComponent(modelPanel);
+        splitPane.setDividerLocation(200);
+
+        addHierarchyListener(new HierarchyListener() {
+            @Override
+            public void hierarchyChanged(HierarchyEvent e) {
+                splitPane.setDividerLocation(0.8);
+            }
+        });
+    }
+
+    public void refresh() {
+        List<CvStage> stages = editor.getPipeline().getStages();
+        // If there are no stages we can't have anything selected, so clear it.
+        if (stages.isEmpty()) {
+            selectedStage = null;
+        }
+        // Otherwise if nothing is selected or if the previously selected stage is no longer in the
+        // pipeline replace the selection with the first stage.
+        else if (selectedStage == null || !stages.contains(selectedStage)) {
+            selectedStage = stages.get(0);
+        }
+        updateAllEverything();
+    }
+
+    public void setSelectedStage(CvStage stage) {
+        this.selectedStage = stage;
+        updateAllEverything();
+    }
+
+    private void updateAllEverything() {
+        List<CvStage> stages = editor.getPipeline().getStages();
+
+        Result result = null;
+        Mat image = null;
+        Object model = null;
+        if (selectedStage != null) {
+            result = editor.getPipeline().getResult(selectedStage);
+            if (result != null) {
+                image = result.image;
+                model = result.model;
+            }
+        }
+
+        if (model instanceof List) {
+            String s = "";
+            for (Object o : ((List) model)) {
+                if (o != null) {
+                    s += o.toString();
+                }
+                s += "\n";
+            }
+            modelTextPane.setText(s);
+        }
+        else {
+            modelTextPane.setText(model == null ? "" : model.toString());
+        }
+        matView.setMat(image);
+        resultStageNameLabel.setText(result == null || selectedStage == null ? ""
+                : (selectedStage.getName() + " (" + (result.processingTimeNs / 1000000.0)
+                        + " ms)"));
+
+        if (selectedStage == null) {
+            firstResultAction.setEnabled(false);
+            previousResultAction.setEnabled(false);
+            nextResultAction.setEnabled(false);
+            lastResultAction.setEnabled(false);
+        }
+        else {
+            int index = stages.indexOf(selectedStage);
+            firstResultAction.setEnabled(index > 0);
+            previousResultAction.setEnabled(index > 0);
+            nextResultAction.setEnabled(index < stages.size() - 1);
+            lastResultAction.setEnabled(index < stages.size() - 1);
+        }
+    }
+
+    public final Action firstResultAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.navigateFirst);
+            putValue(NAME, "");
+            putValue(SHORT_DESCRIPTION, "");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            List<CvStage> stages = editor.getPipeline().getStages();
+            selectedStage = stages.get(0);
+            updateAllEverything();
+        }
+    };
+
+    public final Action previousResultAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.navigatePrevious);
+            putValue(NAME, "");
+            putValue(SHORT_DESCRIPTION, "");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            List<CvStage> stages = editor.getPipeline().getStages();
+            int index = stages.indexOf(selectedStage);
+            selectedStage = stages.get(index - 1);
+            updateAllEverything();
+        }
+    };
+
+    public final Action nextResultAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.navigateNext);
+            putValue(NAME, "");
+            putValue(SHORT_DESCRIPTION, "");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            List<CvStage> stages = editor.getPipeline().getStages();
+            int index = stages.indexOf(selectedStage);
+            selectedStage = stages.get(index + 1);
+            updateAllEverything();
+        }
+    };
+
+    public final Action lastResultAction = new AbstractAction() {
+        {
+            putValue(SMALL_ICON, Icons.navigateLast);
+            putValue(NAME, "");
+            putValue(SHORT_DESCRIPTION, "");
+        }
+
+        @Override
+        public void actionPerformed(ActionEvent arg0) {
+            List<CvStage> stages = editor.getPipeline().getStages();
+            selectedStage = stages.get(stages.size() - 1);
+            updateAllEverything();
+        }
+    };
+    private JTextPane modelTextPane;
+    private JLabel resultStageNameLabel;
+    private MatView matView;
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/StagesTableModel.java b/src/main/java/org/openpnp/vision/pipeline/ui/StagesTableModel.java
new file mode 100755
index 0000000000..4d9e7d2659
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/StagesTableModel.java
@@ -0,0 +1,85 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.util.List;
+
+import javax.swing.table.AbstractTableModel;
+
+import org.openpnp.vision.pipeline.CvPipeline;
+import org.openpnp.vision.pipeline.CvStage;
+
+@SuppressWarnings("serial")
+public class StagesTableModel extends AbstractTableModel implements Reorderable {
+    private static String[] columnNames = {"Name", "Stage"};
+
+    private static Class<?>[] columnClasses = {String.class, String.class};
+
+    private final List<CvStage> stages;
+    private final CvPipeline pipeline;
+
+    public StagesTableModel(CvPipeline pipeline) {
+        this.pipeline = pipeline;
+        this.stages = pipeline.getStages();
+    }
+
+    public void refresh() {
+        fireTableDataChanged();
+    }
+
+    @Override
+    public void reorder(int fromIndex, int toIndex) {
+        CvStage stage = getStage(fromIndex);
+        pipeline.remove(stage);
+        if (fromIndex < toIndex) {
+            toIndex--;
+        }
+        pipeline.insert(stage, toIndex);
+        refresh();
+    }
+
+    public CvStage getStage(int rowIndex) {
+        return stages.get(rowIndex);
+    }
+
+    @Override
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        return columnIndex == 0;
+    }
+
+    @Override
+    public Object getValueAt(int rowIndex, int columnIndex) {
+        CvStage stage = getStage(rowIndex);
+        switch (columnIndex) {
+            case 0:
+                return stage.getName();
+            case 1:
+                return stage.getClass().getSimpleName();
+        }
+        return null;
+    }
+
+    @Override
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        CvStage stage = getStage(rowIndex);
+        stage.setName(aValue.toString());
+    }
+
+    @Override
+    public int getRowCount() {
+        return stages.size();
+    }
+
+    @Override
+    public int getColumnCount() {
+        return columnNames.length;
+    }
+
+    @Override
+    public String getColumnName(int column) {
+        return columnNames[column];
+    }
+
+    @Override
+    public Class<?> getColumnClass(int columnIndex) {
+        return columnClasses[columnIndex];
+    }
+}
diff --git a/src/main/java/org/openpnp/vision/pipeline/ui/TableRowTransferHandler.java b/src/main/java/org/openpnp/vision/pipeline/ui/TableRowTransferHandler.java
new file mode 100755
index 0000000000..2367bf7c62
--- /dev/null
+++ b/src/main/java/org/openpnp/vision/pipeline/ui/TableRowTransferHandler.java
@@ -0,0 +1,80 @@
+package org.openpnp.vision.pipeline.ui;
+
+import java.awt.Cursor;
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.Transferable;
+import java.awt.dnd.DragSource;
+
+import javax.activation.ActivationDataFlavor;
+import javax.activation.DataHandler;
+import javax.swing.JComponent;
+import javax.swing.JTable;
+import javax.swing.TransferHandler;
+
+/**
+ * Handles drag & drop row reordering
+ * 
+ * From: http://stackoverflow.com/questions/638807/how-do-i-drag-and-drop-a-row-in-a-jtable
+ */
+public class TableRowTransferHandler extends TransferHandler {
+    private final DataFlavor localObjectFlavor = new ActivationDataFlavor(Integer.class,
+            "application/x-java-Integer;class=java.lang.Integer", "Integer Row Index");
+    private JTable table = null;
+
+    public TableRowTransferHandler(JTable table) {
+        this.table = table;
+    }
+
+    @Override
+    protected Transferable createTransferable(JComponent c) {
+        assert (c == table);
+        return new DataHandler(new Integer(table.getSelectedRow()),
+                localObjectFlavor.getMimeType());
+    }
+
+    @Override
+    public boolean canImport(TransferHandler.TransferSupport info) {
+        boolean b = info.getComponent() == table && info.isDrop()
+                && info.isDataFlavorSupported(localObjectFlavor);
+        table.setCursor(b ? DragSource.DefaultMoveDrop : DragSource.DefaultMoveNoDrop);
+        return b;
+    }
+
+    @Override
+    public int getSourceActions(JComponent c) {
+        return TransferHandler.COPY_OR_MOVE;
+    }
+
+    @Override
+    public boolean importData(TransferHandler.TransferSupport info) {
+        JTable target = (JTable) info.getComponent();
+        JTable.DropLocation dl = (JTable.DropLocation) info.getDropLocation();
+        int index = dl.getRow();
+        int max = table.getModel().getRowCount();
+        if (index < 0 || index > max)
+            index = max;
+        target.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
+        try {
+            Integer rowFrom = (Integer) info.getTransferable().getTransferData(localObjectFlavor);
+            if (rowFrom != -1 && rowFrom != index) {
+                ((Reorderable) table.getModel()).reorder(rowFrom, index);
+                if (index > rowFrom)
+                    index--;
+                target.getSelectionModel().addSelectionInterval(index, index);
+                return true;
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+        return false;
+    }
+
+    @Override
+    protected void exportDone(JComponent c, Transferable t, int act) {
+        if ((act == TransferHandler.MOVE) || (act == TransferHandler.NONE)) {
+            table.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
+        }
+    }
+
+}
diff --git a/src/main/resources/config/machine.xml b/src/main/resources/config/machine.xml
index 65b17c8415..e08f1ff697 100755
--- a/src/main/resources/config/machine.xml
+++ b/src/main/resources/config/machine.xml
@@ -27,12 +27,6 @@
                   <head-offsets units="Millimeters" x="0.0" y="0.0" z="0.0" rotation="0.0"/>
                   <source-uri>classpath://samples/pnp-test/pnp-test.png</source-uri>
                </camera>
-               <camera class="org.openpnp.machine.reference.camera.ImageCamera" id="d66asdf53-05e1-4629-baae-b614c5ed8320" name="Wide" looking="Down" rotation="0.0" fps="24" width="5000" height="4000">
-                  <units-per-pixel units="Millimeters" x="0.04233" y="0.04233" z="0.0" rotation="0.0"/>
-                  <vision-provider class="org.openpnp.machine.reference.vision.OpenCvVisionProvider"/>
-                  <head-offsets units="Millimeters" x="0.0" y="0.0" z="0.0" rotation="0.0"/>
-                  <source-uri>classpath://samples/pnp-test/pnp-test.png</source-uri>
-               </camera>
             </cameras>
             <paste-dispensers>
                <paste-dispenser class="org.openpnp.machine.reference.ReferencePasteDispenser" id="53050ccf-59a0-4d9f-a8d3-6216f5412e4e" name="D1">
diff --git a/src/main/resources/icons/ic_chevron_left_black_18px.svg b/src/main/resources/icons/ic_chevron_left_black_18px.svg
new file mode 100755
index 0000000000..29d9673273
--- /dev/null
+++ b/src/main/resources/icons/ic_chevron_left_black_18px.svg
@@ -0,0 +1,4 @@
+<svg fill="#000000" height="18" viewBox="0 0 24 24" width="18" xmlns="http://www.w3.org/2000/svg">
+    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
+    <path d="M0 0h24v24H0z" fill="none"/>
+</svg>
\ No newline at end of file
diff --git a/src/main/resources/icons/ic_chevron_right_black_18px.svg b/src/main/resources/icons/ic_chevron_right_black_18px.svg
new file mode 100755
index 0000000000..6ac718a386
--- /dev/null
+++ b/src/main/resources/icons/ic_chevron_right_black_18px.svg
@@ -0,0 +1,4 @@
+<svg fill="#000000" height="18" viewBox="0 0 24 24" width="18" xmlns="http://www.w3.org/2000/svg">
+    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
+    <path d="M0 0h24v24H0z" fill="none"/>
+</svg>
\ No newline at end of file
diff --git a/src/main/resources/icons/ic_first_page_black_18px.svg b/src/main/resources/icons/ic_first_page_black_18px.svg
new file mode 100755
index 0000000000..5656c13b67
--- /dev/null
+++ b/src/main/resources/icons/ic_first_page_black_18px.svg
@@ -0,0 +1,4 @@
+<svg fill="#000000" height="18" viewBox="0 0 24 24" width="18" xmlns="http://www.w3.org/2000/svg">
+    <path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>
+    <path d="M24 24H0V0h24v24z" fill="none"/>
+</svg>
\ No newline at end of file
diff --git a/src/main/resources/icons/ic_last_page_black_18px.svg b/src/main/resources/icons/ic_last_page_black_18px.svg
new file mode 100755
index 0000000000..0b41589f70
--- /dev/null
+++ b/src/main/resources/icons/ic_last_page_black_18px.svg
@@ -0,0 +1,4 @@
+<svg fill="#000000" height="18" viewBox="0 0 24 24" width="18" xmlns="http://www.w3.org/2000/svg">
+    <path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>
+    <path d="M0 0h24v24H0V0z" fill="none"/>
+</svg>
\ No newline at end of file
diff --git a/src/test/java/BasicJobTest.java b/src/test/java/BasicJobTest.java
index f6b6e4f410..5ecc0a3df3 100755
--- a/src/test/java/BasicJobTest.java
+++ b/src/test/java/BasicJobTest.java
@@ -36,18 +36,16 @@
 import com.google.common.io.Files;
 
 public class BasicJobTest {
-    private final static Logger logger = LoggerFactory
-            .getLogger(TestDriver.class);
+    private final static Logger logger = LoggerFactory.getLogger(TestDriver.class);
 
     /**
-     * Creates a basic job in memory and attempts to run it. The Driver is
-     * monitored to make sure it performs a pre-defined set of expected moves.
-     * This test is intended to test the primary motions and operation of the
-     * entire system, including feeding, picking, placing and basic job
+     * Creates a basic job in memory and attempts to run it. The Driver is monitored to make sure it
+     * performs a pre-defined set of expected moves. This test is intended to test the primary
+     * motions and operation of the entire system, including feeding, picking, placing and basic job
      * processing.
      * 
-     * TODO: Don't ignore additional movements after the expected movements
-     * complete. This should cause the test to fail and it does not currently.
+     * TODO: Don't ignore additional movements after the expected movements complete. This should
+     * cause the test to fail and it does not currently.
      * 
      * @throws Exception
      */
@@ -56,18 +54,15 @@ public void testSimpleJob() throws Exception {
         File workingDirectory = Files.createTempDir();
         workingDirectory = new File(workingDirectory, ".openpnp");
         System.out.println("Configuration directory: " + workingDirectory);
-        
+
         // Copy the required configuration files over to the new configuration
         // directory.
-        FileUtils.copyURLToFile(
-        		ClassLoader.getSystemResource("config/BasicJobTest/machine.xml"),
-        		new File(workingDirectory, "machine.xml"));
-        FileUtils.copyURLToFile(
-        		ClassLoader.getSystemResource("config/BasicJobTest/packages.xml"),
-        		new File(workingDirectory, "packages.xml"));
-        FileUtils.copyURLToFile(
-        		ClassLoader.getSystemResource("config/BasicJobTest/parts.xml"),
-        		new File(workingDirectory, "parts.xml"));
+        FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/BasicJobTest/machine.xml"),
+                new File(workingDirectory, "machine.xml"));
+        FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/BasicJobTest/packages.xml"),
+                new File(workingDirectory, "packages.xml"));
+        FileUtils.copyURLToFile(ClassLoader.getSystemResource("config/BasicJobTest/parts.xml"),
+                new File(workingDirectory, "parts.xml"));
 
         Configuration.initialize(workingDirectory);
         Configuration.get().load();
@@ -90,22 +85,30 @@ public void testSimpleJob() throws Exception {
         Nozzle n1 = h1.getNozzle("N1");
         Nozzle n2 = h1.getNozzle("N2");
 
-        delegate.expectMove("Move N1 to F1", n1, new Location(LengthUnit.Millimeters, -10, 0, 0, 0), 1.0);
+        delegate.expectMove("Move N1 to F1", n1, new Location(LengthUnit.Millimeters, -10, 0, 0, 0),
+                1.0);
         delegate.expectPick(n1);
-        
-        delegate.expectMove("Move N2 to F1", n2, new Location(LengthUnit.Millimeters, -20, 0, 0, 0), 1.0);
+
+        delegate.expectMove("Move N2 to F1", n2, new Location(LengthUnit.Millimeters, -20, 0, 0, 0),
+                1.0);
         delegate.expectPick(n2);
-        
-        delegate.expectMove("Move N1 to R1, Safe-Z", n1, new Location(LengthUnit.Millimeters, 0, 10, 0, 45), 1.0);
-        delegate.expectMove("Move N1 to R1, Z", n1, new Location(LengthUnit.Millimeters, 0, 10, 0.825500, 45), 1.0);
+
+        delegate.expectMove("Move N1 to R1, Safe-Z", n1,
+                new Location(LengthUnit.Millimeters, 0, 10, 0, 45), 1.0);
+        delegate.expectMove("Move N1 to R1, Z", n1,
+                new Location(LengthUnit.Millimeters, 0, 10, 0.825500, 45), 1.0);
         delegate.expectPlace(n1);
-        delegate.expectMove("Move N1 to R1, Safe-Z", n1, new Location(LengthUnit.Millimeters, 0, 10, 0, 45), 1.0);
-        
-        delegate.expectMove("Move N2 to R2, Safe-Z", n2, new Location(LengthUnit.Millimeters, 00, 20, 0, 90), 1.0);
-        delegate.expectMove("Move N2 to R2, Z", n2, new Location(LengthUnit.Millimeters, 00, 20, 0.825500, 90), 1.0);
+        delegate.expectMove("Move N1 to R1, Safe-Z", n1,
+                new Location(LengthUnit.Millimeters, 0, 10, 0, 45), 1.0);
+
+        delegate.expectMove("Move N2 to R2, Safe-Z", n2,
+                new Location(LengthUnit.Millimeters, 00, 20, 0, 90), 1.0);
+        delegate.expectMove("Move N2 to R2, Z", n2,
+                new Location(LengthUnit.Millimeters, 00, 20, 0.825500, 90), 1.0);
         delegate.expectPlace(n2);
-        delegate.expectMove("Move N2 to R2, Safe-Z", n2, new Location(LengthUnit.Millimeters, 00, 20, 0, 90), 1.0);
-        
+        delegate.expectMove("Move N2 to R2, Safe-Z", n2,
+                new Location(LengthUnit.Millimeters, 00, 20, 0, 90), 1.0);
+
         jobProcessor.load(job);
         machine.setEnabled(true);
         synchronized (notifier) {
@@ -123,14 +126,11 @@ private Job createSimpleJob() {
         Board board = new Board();
         board.setName("test");
 
-        board.addPlacement(createPlacement("R1", "R-0805-10K", 10, 10, 0, 45,
-                Side.Top));
-        board.addPlacement(createPlacement("R2", "R-0805-10K", 20, 20, 0, 90,
-                Side.Top));
+        board.addPlacement(createPlacement("R1", "R-0805-10K", 10, 10, 0, 45, Side.Top));
+        board.addPlacement(createPlacement("R2", "R-0805-10K", 20, 20, 0, 90, Side.Top));
 
         BoardLocation boardLocation = new BoardLocation(board);
-        boardLocation.setLocation(new Location(LengthUnit.Millimeters, 0, 0, 0,
-                0));
+        boardLocation.setLocation(new Location(LengthUnit.Millimeters, 0, 0, 0, 0));
         boardLocation.setSide(Side.Top);
 
         job.addBoardLocation(boardLocation);
@@ -138,21 +138,18 @@ private Job createSimpleJob() {
         return job;
     }
 
-    public static Placement createPlacement(String id, String partId, double x,
-            double y, double z, double rotation, Side side) {
+    public static Placement createPlacement(String id, String partId, double x, double y, double z,
+            double rotation, Side side) {
         Placement placement = new Placement(id);
         placement.setPart(Configuration.get().getPart(partId));
-        placement.setLocation(new Location(LengthUnit.Millimeters, x, y, z,
-                rotation));
+        placement.setLocation(new Location(LengthUnit.Millimeters, x, y, z, rotation));
         placement.setSide(side);
         return placement;
     }
 
-    public static class BasicJobTestJobProcessorDelegate implements
-            JobProcessorDelegate {
+    public static class BasicJobTestJobProcessorDelegate implements JobProcessorDelegate {
         @Override
-        public PickRetryAction partPickFailed(BoardLocation board, Part part,
-                Feeder feeder) {
+        public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder) {
             return null;
         }
     }
@@ -165,8 +162,7 @@ public BasicJobTestProcessorListener(TestCompleteNotifier notifier) {
         }
 
         @Override
-        public void jobLoaded(Job job) {
-        }
+        public void jobLoaded(Job job) {}
 
         @Override
         public void jobStateChanged(JobState state) {
@@ -187,38 +183,33 @@ public void jobEncounteredError(JobError error, String description) {
         }
 
         @Override
-        public void partProcessingStarted(BoardLocation board,
-                Placement placement) {
+        public void partProcessingStarted(BoardLocation board, Placement placement) {
             logger.info("Start " + placement.getId());
         }
 
         @Override
-        public void partPicked(BoardLocation board, Placement placement) {
-        }
+        public void partPicked(BoardLocation board, Placement placement) {}
 
         @Override
-        public void partPlaced(BoardLocation board, Placement placement) {
-        }
+        public void partPlaced(BoardLocation board, Placement placement) {}
 
         @Override
-        public void partProcessingCompleted(BoardLocation board,
-                Placement placement) {
+        public void partProcessingCompleted(BoardLocation board, Placement placement) {
             logger.info("Finish " + placement.getId());
         }
 
         @Override
-        public void detailedStatusUpdated(String status) {
-        }
+        public void detailedStatusUpdated(String status) {}
     }
 
     /**
-     * TODO: Allow passing of null for the expect methods to ignore a particular
-     * field.
+     * TODO: Allow passing of null for the expect methods to ignore a particular field.
      */
     public static class BasicJobTestDriverDelegate extends TestDriverDelegate {
         private Queue<ExpectedOp> expectedOps = new LinkedList<>();
 
-        public void expectMove(String description, HeadMountable hm, Location location, double speed) {
+        public void expectMove(String description, HeadMountable hm, Location location,
+                double speed) {
             ExpectedMove o = new ExpectedMove(description, hm, location, speed);
             expectedOps.add(o);
         }
@@ -236,8 +227,8 @@ public void expectedActuate() {
         }
 
         @Override
-        public void moveTo(ReferenceHeadMountable hm, Location location,
-                double speed) throws Exception {
+        public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+                throws Exception {
             if (expectedOps.isEmpty()) {
                 throw new Exception("Unexpected Move " + location + ".");
             }
@@ -245,15 +236,13 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
                 ExpectedOp op = expectedOps.remove();
 
                 if (!(op instanceof ExpectedMove)) {
-                    throw new Exception("Unexpected Move " + location
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Move " + location + ". Expected " + op);
                 }
 
                 ExpectedMove move = (ExpectedMove) op;
 
                 if (!move.location.equals(location) || hm != move.headMountable) {
-                    throw new Exception("Unexpected Move " + location
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Move " + location + ". Expected " + op);
                 }
             }
         }
@@ -266,15 +255,13 @@ public void pick(ReferenceNozzle nozzle) throws Exception {
             else {
                 ExpectedOp op = expectedOps.remove();
                 if (!(op instanceof ExpectedPick)) {
-                    throw new Exception("Unexpected Pick " + nozzle
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Pick " + nozzle + ". Expected " + op);
                 }
 
                 ExpectedPick pick = (ExpectedPick) op;
 
                 if (pick.nozzle != nozzle) {
-                    throw new Exception("Unexpected Pick " + nozzle
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Pick " + nozzle + ". Expected " + op);
                 }
             }
         }
@@ -287,29 +274,25 @@ public void place(ReferenceNozzle nozzle) throws Exception {
             else {
                 ExpectedOp op = expectedOps.remove();
                 if (!(op instanceof ExpectedPlace)) {
-                    throw new Exception("Unexpected Place " + nozzle
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Place " + nozzle + ". Expected " + op);
                 }
 
                 ExpectedPlace place = (ExpectedPlace) op;
 
                 if (place.nozzle != nozzle) {
-                    throw new Exception("Unexpected Place " + nozzle
-                            + ". Expected " + op);
+                    throw new Exception("Unexpected Place " + nozzle + ". Expected " + op);
                 }
             }
         }
 
         @Override
-        public void actuate(ReferenceActuator actuator, boolean on)
-                throws Exception {
+        public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
             // TODO Auto-generated method stub
             super.actuate(actuator, on);
         }
 
         @Override
-        public void actuate(ReferenceActuator actuator, double value)
-                throws Exception {
+        public void actuate(ReferenceActuator actuator, double value) throws Exception {
             // TODO Auto-generated method stub
             super.actuate(actuator, value);
         }
@@ -366,7 +349,7 @@ public ExpectedMove(String description, HeadMountable headMountable, Location lo
 
             @Override
             public String toString() {
-                return "Move (" + description + ") "+ headMountable + " " + location.toString();
+                return "Move (" + description + ") " + headMountable + " " + location.toString();
             }
         }
     }
diff --git a/src/test/java/EagleLoaderTest.java b/src/test/java/EagleLoaderTest.java
index 61ef844218..8b68f24490 100755
--- a/src/test/java/EagleLoaderTest.java
+++ b/src/test/java/EagleLoaderTest.java
@@ -12,21 +12,17 @@
 public class EagleLoaderTest {
     @Test
     public void testLoadBoard() throws Exception {
-        EagleLoader loader = 
-                new EagleLoader(
-                        ClassLoader.getSystemResourceAsStream(
-                                "samples/eagle/eagle.brd"));
+        EagleLoader loader =
+                new EagleLoader(ClassLoader.getSystemResourceAsStream("samples/eagle/eagle.brd"));
         Board board = loader.board;
         Element r1 = board.getElements().getElement().get(0);
         Assert.assertEquals(r1.getName(), "R1");
     }
-    
+
     @Test
     public void testLoadSchematic() throws Exception {
-        EagleLoader loader = 
-                new EagleLoader(
-                        ClassLoader.getSystemResourceAsStream(
-                                "samples/eagle/eagle.sch"));
+        EagleLoader loader =
+                new EagleLoader(ClassLoader.getSystemResourceAsStream("samples/eagle/eagle.sch"));
         Schematic sch = loader.schematic;
         Instance r1 = sch.getSheets().getSheet().get(0).getInstances().getInstance().get(0);
         Assert.assertEquals(r1.getPart(), "R1");
diff --git a/src/test/java/OpenCvTest.java b/src/test/java/OpenCvTest.java
index 71ee3b97e8..2658f320cc 100755
--- a/src/test/java/OpenCvTest.java
+++ b/src/test/java/OpenCvTest.java
@@ -4,13 +4,13 @@
 import org.openpnp.vision.FluentCv;
 
 public class OpenCvTest {
-	/**
-	 * Just tests to make sure OpenCV is working. This is primarily to catch
-	 * any issues on non-Mac platform builds.
-	 */
-	@Test
-	public void openCvWorks() throws Exception {
-		BufferedImage img = new BufferedImage(640, 480, BufferedImage.TYPE_3BYTE_BGR);
-		new FluentCv().toMat(img).toGray();
-	}
+    /**
+     * Just tests to make sure OpenCV is working. This is primarily to catch any issues on non-Mac
+     * platform builds.
+     */
+    @Test
+    public void openCvWorks() throws Exception {
+        BufferedImage img = new BufferedImage(640, 480, BufferedImage.TYPE_3BYTE_BGR);
+        new FluentCv().toMat(img).toGray();
+    }
 }
diff --git a/src/test/java/SampleJobTest.java b/src/test/java/SampleJobTest.java
index 75b91bb2ea..43b13f2dae 100755
--- a/src/test/java/SampleJobTest.java
+++ b/src/test/java/SampleJobTest.java
@@ -28,17 +28,15 @@
 import com.google.common.io.Files;
 
 public class SampleJobTest {
-    private final static Logger logger = LoggerFactory
-            .getLogger(TestDriver.class);
+    private final static Logger logger = LoggerFactory.getLogger(TestDriver.class);
 
     /**
-     * Loads the pnp-test job that is included in the samples and attempts
-     * to run it within a test harness. The job is expected to complete
-     * successfully without throwing any exceptions.
+     * Loads the pnp-test job that is included in the samples and attempts to run it within a test
+     * harness. The job is expected to complete successfully without throwing any exceptions.
      * 
-     * This test is intended to exercise the basic job processing functions,
-     * image processing, vision, feeder handling and fiducial handling. It's
-     * intended to act as a smoke test for large changes.
+     * This test is intended to exercise the basic job processing functions, image processing,
+     * vision, feeder handling and fiducial handling. It's intended to act as a smoke test for large
+     * changes.
      */
     @Test
     public void testSampleJob() throws Exception {
@@ -53,13 +51,13 @@ public void testSampleJob() throws Exception {
 
         NullDriver driver = (NullDriver) machine.getDriver();
         driver.setFeedRateMmPerMinute(0);
-        
-        Camera camera =  machine.getDefaultHead().getDefaultCamera();
-//        File videoFile = new File("target");
-//        videoFile = new File(videoFile, "SampleJobTest.mp4");
-//        MpegEncodingCameraListener encoder = new MpegEncodingCameraListener(videoFile);
-//        camera.startContinuousCapture(encoder, 25);
-        
+
+        Camera camera = machine.getDefaultHead().getDefaultCamera();
+        // File videoFile = new File("target");
+        // videoFile = new File(videoFile, "SampleJobTest.mp4");
+        // MpegEncodingCameraListener encoder = new MpegEncodingCameraListener(videoFile);
+        // camera.startContinuousCapture(encoder, 25);
+
         TestCompleteNotifier notifier = new TestCompleteNotifier();
 
         JobProcessor jobProcessor = machine.getJobProcessors().get(JobProcessor.Type.PickAndPlace);
@@ -77,18 +75,16 @@ public void testSampleJob() throws Exception {
             jobProcessor.start();
             notifier.wait();
         }
-//        camera.stopContinuousCapture(encoder);
-//        encoder.finish();
+        // camera.stopContinuousCapture(encoder);
+        // encoder.finish();
         if (notifier.failed) {
             throw notifier.exception;
         }
     }
 
-    public static class SampleJobTestJobProcessorDelegate implements
-            JobProcessorDelegate {
+    public static class SampleJobTestJobProcessorDelegate implements JobProcessorDelegate {
         @Override
-        public PickRetryAction partPickFailed(BoardLocation board, Part part,
-                Feeder feeder) {
+        public PickRetryAction partPickFailed(BoardLocation board, Part part, Feeder feeder) {
             return null;
         }
     }
@@ -101,8 +97,7 @@ public SampleJobTestProcessorListener(TestCompleteNotifier notifier) {
         }
 
         @Override
-        public void jobLoaded(Job job) {
-        }
+        public void jobLoaded(Job job) {}
 
         @Override
         public void jobStateChanged(JobState state) {
@@ -123,64 +118,59 @@ public void jobEncounteredError(JobError error, String description) {
         }
 
         @Override
-        public void partProcessingStarted(BoardLocation board,
-                Placement placement) {
+        public void partProcessingStarted(BoardLocation board, Placement placement) {
             logger.info("Start " + placement.getId());
         }
 
         @Override
-        public void partPicked(BoardLocation board, Placement placement) {
-        }
+        public void partPicked(BoardLocation board, Placement placement) {}
 
         @Override
-        public void partPlaced(BoardLocation board, Placement placement) {
-        }
+        public void partPlaced(BoardLocation board, Placement placement) {}
 
         @Override
-        public void partProcessingCompleted(BoardLocation board,
-                Placement placement) {
+        public void partProcessingCompleted(BoardLocation board, Placement placement) {
             logger.info("Finish " + placement.getId());
         }
 
         @Override
-        public void detailedStatusUpdated(String status) {
-        }
+        public void detailedStatusUpdated(String status) {}
     }
-    
+
     public static class TestCompleteNotifier {
         public boolean failed;
         public Exception exception;
     }
-    
+
     public static class MpegEncodingCameraListener implements CameraListener {
-    	private SequenceEncoder enc;
-    	private boolean finished = false;
-    	
-    	public MpegEncodingCameraListener(File file) throws Exception {
+        private SequenceEncoder enc;
+        private boolean finished = false;
+
+        public MpegEncodingCameraListener(File file) throws Exception {
             enc = new SequenceEncoder(file);
-    	}
-    	
-		@Override
-		public synchronized void frameReceived(BufferedImage img) {
-			if (finished) {
-				return;
-			}
-			try {
-				Graphics g =  img.getGraphics();
-				g.setColor(Color.white);
-				g.drawLine(0, img.getHeight() / 2, img.getWidth(), img.getHeight() / 2);
-				g.drawLine(img.getWidth() / 2, 0, img.getWidth() / 2, img.getHeight());
-				g.dispose();
-	    		enc.encodeImage(img);
-			}
-			catch (Exception e) {
-				e.printStackTrace();
-			}
-		}
-		
-		public synchronized void finish() throws Exception {
-			finished = true;
-			enc.finish();
-		}
+        }
+
+        @Override
+        public synchronized void frameReceived(BufferedImage img) {
+            if (finished) {
+                return;
+            }
+            try {
+                Graphics g = img.getGraphics();
+                g.setColor(Color.white);
+                g.drawLine(0, img.getHeight() / 2, img.getWidth(), img.getHeight() / 2);
+                g.drawLine(img.getWidth() / 2, 0, img.getWidth() / 2, img.getHeight());
+                g.dispose();
+                enc.encodeImage(img);
+            }
+            catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        public synchronized void finish() throws Exception {
+            finished = true;
+            enc.finish();
+        }
     }
 }
diff --git a/src/test/java/Utils2DTest.java b/src/test/java/Utils2DTest.java
index 59c9f7385b..f44225e765 100755
--- a/src/test/java/Utils2DTest.java
+++ b/src/test/java/Utils2DTest.java
@@ -1,7 +1,7 @@
 import org.junit.Test;
+import org.openpnp.model.Board.Side;
 import org.openpnp.model.LengthUnit;
 import org.openpnp.model.Location;
-import org.openpnp.model.Board.Side;
 import org.openpnp.util.Utils2D;
 
 public class Utils2DTest {
@@ -95,7 +95,8 @@ public static void within(String name, double value, double target, double plusM
             throws Exception {
         if (value > target + plusMinus) {
             throw new Exception(name + " " + value + " is greater than " + (target + plusMinus));
-        } else if (value < target - plusMinus) {
+        }
+        else if (value < target - plusMinus) {
             throw new Exception(name + " " + value + " is less than " + (target - plusMinus));
         }
     }
diff --git a/src/test/java/VisionUtilsTest.java b/src/test/java/VisionUtilsTest.java
index 85f2f658bf..9653bdd0da 100755
--- a/src/test/java/VisionUtilsTest.java
+++ b/src/test/java/VisionUtilsTest.java
@@ -47,19 +47,19 @@ public Head getHead() {
         @Override
         public void setHead(Head head) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void moveTo(Location location, double speed) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void moveToSafeZ(double speed) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -106,7 +106,7 @@ public String getName() {
         @Override
         public void setName(String name) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -118,7 +118,7 @@ public Looking getLooking() {
         @Override
         public void setLooking(Looking looking) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -129,7 +129,7 @@ public Location getUnitsPerPixel() {
         @Override
         public void setUnitsPerPixel(Location unitsPerPixel) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -139,22 +139,21 @@ public BufferedImage capture() {
         }
 
         @Override
-        public void startContinuousCapture(CameraListener listener,
-                int maximumFps) {
+        public void startContinuousCapture(CameraListener listener, int maximumFps) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void stopContinuousCapture(CameraListener listener) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void setVisionProvider(VisionProvider visionProvider) {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -182,25 +181,25 @@ public Icon getPropertySheetHolderIcon() {
         @Override
         public void close() throws IOException {
             // TODO Auto-generated method stub
-            
+
         }
 
-		@Override
-		public BufferedImage settleAndCapture() {
-			// TODO Auto-generated method stub
-			return null;
-		}
+        @Override
+        public BufferedImage settleAndCapture() {
+            // TODO Auto-generated method stub
+            return null;
+        }
+
+        @Override
+        public long getSettleTimeMs() {
+            // TODO Auto-generated method stub
+            return 0;
+        }
 
-		@Override
-		public long getSettleTimeMs() {
-			// TODO Auto-generated method stub
-			return 0;
-		}
+        @Override
+        public void setSettleTimeMs(long settleTimeMs) {
+            // TODO Auto-generated method stub
 
-		@Override
-		public void setSettleTimeMs(long settleTimeMs) {
-			// TODO Auto-generated method stub
-			
-		}
+        }
     }
 }
diff --git a/src/test/java/org/openpnp/machine/reference/driver/test/TestDriver.java b/src/test/java/org/openpnp/machine/reference/driver/test/TestDriver.java
index a2b02eb5e4..8f2771eb68 100755
--- a/src/test/java/org/openpnp/machine/reference/driver/test/TestDriver.java
+++ b/src/test/java/org/openpnp/machine/reference/driver/test/TestDriver.java
@@ -20,20 +20,19 @@
 import org.slf4j.LoggerFactory;
 
 public class TestDriver implements ReferenceDriver {
-    private final static Logger logger = LoggerFactory
-            .getLogger(TestDriver.class);
-    
-    @Attribute(required=false)
+    private final static Logger logger = LoggerFactory.getLogger(TestDriver.class);
+
+    @Attribute(required = false)
     private String dummy;
-    
+
     private Location location = new Location(LengthUnit.Millimeters, 0, 0, 0, 0);
-    
+
     private ReferenceDriver delegate = new TestDriverDelegate();
-    
+
     public void setDelegate(ReferenceDriver delegate) {
         this.delegate = delegate;
     }
-    
+
     @Override
     public Wizard getConfigurationWizard() {
         return null;
@@ -47,8 +46,8 @@ public void home(ReferenceHead head) throws Exception {
     }
 
     @Override
-    public void moveTo(ReferenceHeadMountable hm, Location location,
-            double speed) throws Exception {
+    public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+            throws Exception {
         // Subtract the offsets from the incoming Location. This converts the
         // offset coordinates to driver / absolute coordinates.
         location = location.subtract(hm.getHeadOffsets());
@@ -59,18 +58,17 @@ public void moveTo(ReferenceHeadMountable hm, Location location,
 
         // Get the current location of the Head that we'll move
         Location hl = this.location;
-        
-        hl = hl.derive(
-                Double.isNaN(location.getX()) ? null : location.getX(),
+
+        hl = hl.derive(Double.isNaN(location.getX()) ? null : location.getX(),
                 Double.isNaN(location.getY()) ? null : location.getY(),
                 Double.isNaN(location.getZ()) ? null : location.getZ(),
                 Double.isNaN(location.getRotation()) ? null : location.getRotation());
 
         if (!this.location.equals(hl)) {
             this.location = hl;
-            
-            logger.debug("moveTo({}, {}, {})", new Object[] { hm, this.location, speed });
-            
+
+            logger.debug("moveTo({}, {}, {})", new Object[] {hm, this.location, speed});
+
             delegate.moveTo(hm, this.location, speed);
         }
     }
@@ -93,31 +91,27 @@ public void place(ReferenceNozzle nozzle) throws Exception {
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, boolean on)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
         logger.debug("actuate({}, {})", actuator, on);
         delegate.actuate(actuator, on);
     }
 
     @Override
-    public void actuate(ReferenceActuator actuator, double value)
-            throws Exception {
+    public void actuate(ReferenceActuator actuator, double value) throws Exception {
         logger.debug("actuate({}, {})", actuator, value);
         delegate.actuate(actuator, value);
     }
-    
+
     @Override
-    public void dispense(ReferencePasteDispenser dispenser,
-            Location startLocation, Location endLocation,
-            long dispenseTimeMilliseconds) throws Exception {
-    }
+    public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+            Location endLocation, long dispenseTimeMilliseconds) throws Exception {}
 
     @Override
     public void setEnabled(boolean enabled) throws Exception {
         logger.debug("setEnabled({})", enabled);
         delegate.setEnabled(enabled);
     }
-    
+
     public static class TestDriverDelegate implements ReferenceDriver {
 
         @Override
@@ -129,14 +123,14 @@ public Wizard getConfigurationWizard() {
         @Override
         public void home(ReferenceHead head) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
-        public void moveTo(ReferenceHeadMountable hm, Location location,
-                double speed) throws Exception {
+        public void moveTo(ReferenceHeadMountable hm, Location location, double speed)
+                throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -148,41 +142,38 @@ public Location getLocation(ReferenceHeadMountable hm) {
         @Override
         public void pick(ReferenceNozzle nozzle) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void place(ReferenceNozzle nozzle) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
-        public void actuate(ReferenceActuator actuator, boolean on)
-                throws Exception {
+        public void actuate(ReferenceActuator actuator, boolean on) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
-        public void actuate(ReferenceActuator actuator, double value)
-                throws Exception {
+        public void actuate(ReferenceActuator actuator, double value) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
-        
+
         @Override
-        public void dispense(ReferencePasteDispenser dispenser,
-                Location startLocation, Location endLocation,
-                long dispenseTimeMilliseconds) throws Exception {
+        public void dispense(ReferencePasteDispenser dispenser, Location startLocation,
+                Location endLocation, long dispenseTimeMilliseconds) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
         public void setEnabled(boolean enabled) throws Exception {
             // TODO Auto-generated method stub
-            
+
         }
 
         @Override
@@ -214,11 +205,11 @@ public Icon getPropertySheetHolderIcon() {
             // TODO Auto-generated method stub
             return null;
         }
-        
+
         @Override
         public void close() throws IOException {
             // TODO Auto-generated method stub
-            
+
         }
     }
 
@@ -251,10 +242,10 @@ public Icon getPropertySheetHolderIcon() {
         // TODO Auto-generated method stub
         return null;
     }
-    
+
     @Override
     public void close() throws IOException {
         // TODO Auto-generated method stub
-        
+
     }
 }
