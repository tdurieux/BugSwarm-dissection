diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java b/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
index 172695aa84..5b902de569 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java
@@ -12,6 +12,7 @@
 import net.bytebuddy.dynamic.ClassFileLocator;
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.dynamic.loading.ClassInjector;
+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;
 import net.bytebuddy.dynamic.scaffold.InstrumentedType;
 import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
@@ -19,6 +20,7 @@
 import net.bytebuddy.implementation.ExceptionMethod;
 import net.bytebuddy.implementation.Implementation;
 import net.bytebuddy.implementation.LoadedTypeInitializer;
+import net.bytebuddy.implementation.MethodCall;
 import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
 import net.bytebuddy.implementation.bytecode.*;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
@@ -35,6 +37,8 @@
 import net.bytebuddy.matcher.ElementMatcher;
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.utility.JavaConstant;
+import net.bytebuddy.utility.JavaModule;
+import net.bytebuddy.utility.JavaType;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
@@ -45,6 +49,7 @@
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
 import java.lang.instrument.UnmodifiableClassException;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.security.AccessControlContext;
@@ -263,6 +268,41 @@
      */
     Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
 
+    /**
+     * <p>
+     * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
+     * If several matchers positively match a type only the latest registered matcher is considered for transformation.
+     * </p>
+     * <p>
+     * If this matcher is chained with additional subsequent matchers, this matcher is always executed first whereas the following matchers are
+     * executed in the order of their execution. If any matcher indicates that a type is to be matched, none of the following matchers is still queried.
+     * </p>
+     * <p>
+     * <b>Note</b>: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
+     * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it
+     * is also recommended, to exclude class loaders such as for example the bootstrap class loader.
+     * </p>
+     *
+     * @param typeMatcher        An {@link net.bytebuddy.matcher.ElementMatcher} that is applied on the type being
+     *                           loaded that decides if the entailed
+     *                           {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should be applied for
+     *                           that type.
+     * @param classLoaderMatcher An {@link net.bytebuddy.matcher.ElementMatcher} that is applied to the
+     *                           {@link java.lang.ClassLoader} that is loading the type being loaded. This matcher
+     *                           is always applied second where the type matcher is not applied in case that this
+     *                           matcher does not indicate a match.
+     * @param moduleMatcher      An {@link net.bytebuddy.matcher.ElementMatcher} that is applied to the {@link JavaModule}
+     *                           of the type being loaded. This matcher is always applied first where the class loader and
+     *                           type matchers are not applied in case that this matcher does not indicate a match. On a JVM
+     *                           that does not support the Java modules system, this matcher is not applied.
+     * @return A definable that represents this agent builder which allows for the definition of one or several
+     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s to be applied when both the given
+     * {@code typeMatcher} and {@code classLoaderMatcher} indicate a match.
+     */
+    Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher,
+                               ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                               ElementMatcher<? super JavaModule> moduleMatcher);
+
     /**
      * <p>
      * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
@@ -335,6 +375,35 @@
      */
     Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
 
+    /**
+     * <p>
+     * Excludes any type that is matched by the provided matcher and is loaded by a class loader matching the second matcher.
+     * By default, Byte Buddy does not instrument synthetic types or types that are loaded by the bootstrap class loader.
+     * </p>
+     * <p>
+     * When ignoring a type, any subsequently chained matcher is applied after this matcher in the order of their registration. Also, if
+     * any matcher indicates that a type is to be ignored, none of the following chained matchers is executed.
+     * </p>
+     * <p>
+     * <b>Note</b>: For performance reasons, it is recommended to always include a matcher that excludes as many namespaces
+     * as possible. Byte Buddy can determine a type's name without parsing its class file and can therefore discard such
+     * types with minimal overhead. When a different property of a type - such as for example its modifiers or its annotations
+     * is accessed - Byte Buddy parses the class file lazily in order to allow for such a matching. Therefore, any exclusion
+     * of a name should always be done as a first step and even if it does not influence the selection of what types are
+     * matched. Without changing this property, the class file of every type is being parsed!
+     * </p>
+     *
+     * @param typeMatcher        A matcher that identifies types that should not be instrumented.
+     * @param classLoaderMatcher A matcher that identifies a class loader that identifies classes that should not be instrumented.
+     * @param moduleMatcher      A matcher that identifies a module that identifies classes that should not be instrumented. On a JVM
+     *                           that does not support the Java modules system, this matcher is not applied.
+     * @return A new instance of this agent builder that ignores all types that are matched by the provided matcher.
+     * All previous matchers for ignored types are discarded.
+     */
+    Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher,
+                   ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                   ElementMatcher<? super JavaModule> moduleMatcher);
+
     /**
      * <p>
      * Excludes any type that is matched by the raw matcher provided to this method. By default, Byte Buddy does not
@@ -410,6 +479,18 @@
          */
         T and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
 
+        /**
+         * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched.
+         *
+         * @param typeMatcher        A matcher for the type being matched.
+         * @param classLoaderMatcher A matcher for the type's class loader.
+         * @param moduleMatcher      A matcher for the type's module. On a JVM that does not support modules, the Java module is represented by {@code null}.
+         * @return A chained matcher.
+         */
+        T and(ElementMatcher<? super TypeDescription> typeMatcher,
+              ElementMatcher<? super ClassLoader> classLoaderMatcher,
+              ElementMatcher<? super JavaModule> moduleMatcher);
+
         /**
          * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched.
          *
@@ -436,6 +517,18 @@
          */
         T or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher);
 
+        /**
+         * Defines a matching that is positive if the previous matcher or the supplied matcher are matched.
+         *
+         * @param typeMatcher        A matcher for the type being matched.
+         * @param classLoaderMatcher A matcher for the type's class loader.
+         * @param moduleMatcher      A matcher for the type's module. On a JVM that does not support modules, the Java module is represented by {@code null}.
+         * @return A chained matcher.
+         */
+        T or(ElementMatcher<? super TypeDescription> typeMatcher,
+             ElementMatcher<? super ClassLoader> classLoaderMatcher,
+             ElementMatcher<? super JavaModule> moduleMatcher);
+
         /**
          * Defines a matching that is positive if the previous matcher or the supplied matcher are matched.
          *
@@ -458,7 +551,14 @@ public S and(ElementMatcher<? super TypeDescription> typeMatcher) {
 
             @Override
             public S and(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
-                return and(new RawMatcher.ForElementMatcherPair(typeMatcher, classLoaderMatcher));
+                return and(typeMatcher, classLoaderMatcher, any());
+            }
+
+            @Override
+            public S and(ElementMatcher<? super TypeDescription> typeMatcher,
+                         ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                         ElementMatcher<? super JavaModule> moduleMatcher) {
+                return and(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));
             }
 
             @Override
@@ -468,7 +568,14 @@ public S or(ElementMatcher<? super TypeDescription> typeMatcher) {
 
             @Override
             public S or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
-                return or(new RawMatcher.ForElementMatcherPair(typeMatcher, classLoaderMatcher));
+                return or(typeMatcher, classLoaderMatcher, any());
+            }
+
+            @Override
+            public S or(ElementMatcher<? super TypeDescription> typeMatcher,
+                        ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                        ElementMatcher<? super JavaModule> moduleMatcher) {
+                return or(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));
             }
         }
     }
@@ -542,6 +649,7 @@ public S or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<
          * @param typeDescription     A description of the type to be instrumented.
          * @param classLoader         The class loader of the instrumented type. Might be {@code null} if this class
          *                            loader represents the bootstrap class loader.
+         * @param module              The transformed type's module or {@code null} if the current VM does not support modules.
          * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransformation
          *                            is applied.
          * @param protectionDomain    The protection domain of the type being transformed.
@@ -550,6 +658,7 @@ public S or(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<
          */
         boolean matches(TypeDescription typeDescription,
                         ClassLoader classLoader,
+                        JavaModule module,
                         Class<?> classBeingRedefined,
                         ProtectionDomain protectionDomain);
 
@@ -580,8 +689,13 @@ protected Conjunction(RawMatcher left, RawMatcher right) {
             }
 
             @Override
-            public boolean matches(TypeDescription typeDescription, ClassLoader classLoader, Class<?> classBeingRedefined, ProtectionDomain protectionDomain) {
-                return left.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain) && right.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain);
+            public boolean matches(TypeDescription typeDescription,
+                                   ClassLoader classLoader,
+                                   JavaModule module,
+                                   Class<?> classBeingRedefined,
+                                   ProtectionDomain protectionDomain) {
+                return left.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)
+                        && right.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
             }
 
             @Override
@@ -635,8 +749,13 @@ protected Disjunction(RawMatcher left, RawMatcher right) {
             }
 
             @Override
-            public boolean matches(TypeDescription typeDescription, ClassLoader classLoader, Class<?> classBeingRedefined, ProtectionDomain protectionDomain) {
-                return left.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain) || right.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain);
+            public boolean matches(TypeDescription typeDescription,
+                                   ClassLoader classLoader,
+                                   JavaModule module,
+                                   Class<?> classBeingRedefined,
+                                   ProtectionDomain protectionDomain) {
+                return left.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)
+                        || right.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);
             }
 
             @Override
@@ -668,7 +787,7 @@ public String toString() {
          * and its {@link java.lang.ClassLoader} against two suitable matchers in order to determine if the matched
          * type should be instrumented.
          */
-        class ForElementMatcherPair implements RawMatcher {
+        class ForElementMatchers implements RawMatcher {
 
             /**
              * The type matcher to apply to a {@link TypeDescription}.
@@ -676,52 +795,73 @@ public String toString() {
             private final ElementMatcher<? super TypeDescription> typeMatcher;
 
             /**
-             * The class loader to apply to a {@link java.lang.ClassLoader}.
+             * The class loader matcher to apply to a {@link java.lang.ClassLoader}.
              */
             private final ElementMatcher<? super ClassLoader> classLoaderMatcher;
 
+            /**
+             * A module matcher to apply to a {@code java.lang.reflect.Module}.
+             */
+            private final ElementMatcher<? super JavaModule> moduleMatcher;
+
             /**
              * Creates a new {@link net.bytebuddy.agent.builder.AgentBuilder.RawMatcher} that only matches the
              * supplied {@link TypeDescription} and its {@link java.lang.ClassLoader} against two matcher in order
              * to decided if an instrumentation should be conducted.
              *
-             * @param typeMatcher        The type matcher to apply to a
-             *                           {@link TypeDescription}.
-             * @param classLoaderMatcher The class loader to apply to a {@link java.lang.ClassLoader}.
+             * @param typeMatcher        The type matcher to apply to a {@link TypeDescription}.
+             * @param classLoaderMatcher The class loader matcher to apply to a {@link java.lang.ClassLoader}.
+             * @param moduleMatcher      A module matcher to apply to a {@code java.lang.reflect.Module}.
              */
-            public ForElementMatcherPair(ElementMatcher<? super TypeDescription> typeMatcher,
-                                         ElementMatcher<? super ClassLoader> classLoaderMatcher) {
+            public ForElementMatchers(ElementMatcher<? super TypeDescription> typeMatcher,
+                                      ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                                      ElementMatcher<? super JavaModule> moduleMatcher) {
                 this.typeMatcher = typeMatcher;
                 this.classLoaderMatcher = classLoaderMatcher;
+                this.moduleMatcher = moduleMatcher;
             }
 
             @Override
             public boolean matches(TypeDescription typeDescription,
                                    ClassLoader classLoader,
+                                   JavaModule module,
                                    Class<?> classBeingRedefined,
                                    ProtectionDomain protectionDomain) {
-                return classLoaderMatcher.matches(classLoader) && typeMatcher.matches(typeDescription);
+                return moduleMatcher.matches(module) && classLoaderMatcher.matches(classLoader) && typeMatcher.matches(typeDescription);
+            }
+
+            /**
+             * Represents this matcher in a disjunction together with the supplied matcher.
+             *
+             * @param other The other matcher to combine with this matcher in a disjunction.
+             * @return A disjunction matching this matcher or the other matcher.
+             */
+            protected RawMatcher or(RawMatcher other) {
+                return new Conjunction(this, other);
             }
 
             @Override
             public boolean equals(Object other) {
                 return this == other || !(other == null || getClass() != other.getClass())
-                        && classLoaderMatcher.equals(((ForElementMatcherPair) other).classLoaderMatcher)
-                        && typeMatcher.equals(((ForElementMatcherPair) other).typeMatcher);
+                        && classLoaderMatcher.equals(((ForElementMatchers) other).classLoaderMatcher)
+                        && moduleMatcher.equals(((ForElementMatchers) other).moduleMatcher)
+                        && typeMatcher.equals(((ForElementMatchers) other).typeMatcher);
             }
 
             @Override
             public int hashCode() {
                 int result = typeMatcher.hashCode();
                 result = 31 * result + classLoaderMatcher.hashCode();
+                result = 31 * result + moduleMatcher.hashCode();
                 return result;
             }
 
             @Override
             public String toString() {
-                return "AgentBuilder.RawMatcher.ForElementMatcherPair{" +
+                return "AgentBuilder.RawMatcher.ForElementMatchers{" +
                         "typeMatcher=" + typeMatcher +
                         ", classLoaderMatcher=" + classLoaderMatcher +
+                        ", moduleMatcher=" + moduleMatcher +
                         '}';
             }
         }
@@ -1152,34 +1292,38 @@ public ClassLoader run() {
          *
          * @param typeDescription The type that is being transformed.
          * @param classLoader     The class loader which is loading this type.
+         * @param module          The transformed type's module or {@code null} if the current VM does not support modules.
          * @param dynamicType     The dynamic type that was created.
          */
-        void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, DynamicType dynamicType);
+        void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType);
 
         /**
          * Invoked when a type is not transformed but ignored.
          *
          * @param typeDescription The type being ignored for transformation.
          * @param classLoader     The class loader which is loading this type.
+         * @param module          The ignored type's module or {@code null} if the current VM does not support modules.
          */
-        void onIgnored(TypeDescription typeDescription, ClassLoader classLoader);
+        void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module);
 
         /**
          * Invoked when an error has occurred during transformation.
          *
          * @param typeName    The type name of the instrumented type.
          * @param classLoader The class loader which is loading this type.
+         * @param module      The instrumented type's module or {@code null} if the current VM does not support modules.
          * @param throwable   The occurred error.
          */
-        void onError(String typeName, ClassLoader classLoader, Throwable throwable);
+        void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable);
 
         /**
          * Invoked after a class was attempted to be loaded, independently of its treatment.
          *
          * @param typeName    The binary name of the instrumented type.
          * @param classLoader The class loader which is loading this type.
+         * @param module      The instrumented type's module or {@code null} if the current VM does not support modules.
          */
-        void onComplete(String typeName, ClassLoader classLoader);
+        void onComplete(String typeName, ClassLoader classLoader, JavaModule module);
 
         /**
          * A no-op implementation of a {@link net.bytebuddy.agent.builder.AgentBuilder.Listener}.
@@ -1192,22 +1336,22 @@ public ClassLoader run() {
             INSTANCE;
 
             @Override
-            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, DynamicType dynamicType) {
+            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType) {
                 /* do nothing */
             }
 
             @Override
-            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader) {
+            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
                 /* do nothing */
             }
 
             @Override
-            public void onError(String typeName, ClassLoader classLoader, Throwable throwable) {
+            public void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable) {
                 /* do nothing */
             }
 
             @Override
-            public void onComplete(String typeName, ClassLoader classLoader) {
+            public void onComplete(String typeName, ClassLoader classLoader, JavaModule module) {
                 /* do nothing */
             }
 
@@ -1223,22 +1367,22 @@ public String toString() {
         abstract class Adapter implements Listener {
 
             @Override
-            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, DynamicType dynamicType) {
+            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType) {
                 /* do nothing */
             }
 
             @Override
-            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader) {
+            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
                 /* do nothing */
             }
 
             @Override
-            public void onError(String typeName, ClassLoader classLoader, Throwable throwable) {
+            public void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable) {
                 /* do nothing */
             }
 
             @Override
-            public void onComplete(String typeName, ClassLoader classLoader) {
+            public void onComplete(String typeName, ClassLoader classLoader, JavaModule module) {
                 /* do nothing */
             }
         }
@@ -1287,24 +1431,24 @@ public static Listener toSystemError() {
             }
 
             @Override
-            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, DynamicType dynamicType) {
-                printStream.println(PREFIX + " TRANSFORM " + typeDescription.getName());
+            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType) {
+                printStream.println(PREFIX + " TRANSFORM " + typeDescription.getName() + "[" + classLoader + ", " + module + "]");
             }
 
             @Override
-            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader) {
-                printStream.println(PREFIX + " IGNORE " + typeDescription.getName());
+            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
+                printStream.println(PREFIX + " IGNORE " + typeDescription.getName() + "[" + classLoader + ", " + module + "]");
             }
 
             @Override
-            public void onError(String typeName, ClassLoader classLoader, Throwable throwable) {
-                printStream.println(PREFIX + " ERROR " + typeName);
+            public void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable) {
+                printStream.println(PREFIX + " ERROR " + typeName + "[" + classLoader + ", " + module + "]");
                 throwable.printStackTrace(printStream);
             }
 
             @Override
-            public void onComplete(String typeName, ClassLoader classLoader) {
-                printStream.println(PREFIX + " COMPLETE " + typeName);
+            public void onComplete(String typeName, ClassLoader classLoader, JavaModule module) {
+                printStream.println(PREFIX + " COMPLETE " + typeName + "[" + classLoader + ", " + module + "]");
             }
 
             @Override
@@ -1355,30 +1499,30 @@ public Compound(List<? extends Listener> listeners) {
             }
 
             @Override
-            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, DynamicType dynamicType) {
+            public void onTransformation(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module, DynamicType dynamicType) {
                 for (Listener listener : listeners) {
-                    listener.onTransformation(typeDescription, classLoader, dynamicType);
+                    listener.onTransformation(typeDescription, classLoader, module, dynamicType);
                 }
             }
 
             @Override
-            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader) {
+            public void onIgnored(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
                 for (Listener listener : listeners) {
-                    listener.onIgnored(typeDescription, classLoader);
+                    listener.onIgnored(typeDescription, classLoader, module);
                 }
             }
 
             @Override
-            public void onError(String typeName, ClassLoader classLoader, Throwable throwable) {
+            public void onError(String typeName, ClassLoader classLoader, JavaModule module, Throwable throwable) {
                 for (Listener listener : listeners) {
-                    listener.onError(typeName, classLoader, throwable);
+                    listener.onError(typeName, classLoader, module, throwable);
                 }
             }
 
             @Override
-            public void onComplete(String typeName, ClassLoader classLoader) {
+            public void onComplete(String typeName, ClassLoader classLoader, JavaModule module) {
                 for (Listener listener : listeners) {
-                    listener.onComplete(typeName, classLoader);
+                    listener.onComplete(typeName, classLoader, module);
                 }
             }
 
@@ -2268,6 +2412,7 @@ protected ForRedefinition(Default.Transformation transformation) {
                 public boolean consider(Class<?> type, RawMatcher ignoredTypeMatcher) {
                     return transformation.resolve(new TypeDescription.ForLoadedType(type),
                             type.getClassLoader(),
+                            JavaModule.ofType(type),
                             type,
                             type.getProtectionDomain(),
                             ignoredTypeMatcher).getSort().isAlive() && entries.add(new Entry(type));
@@ -2278,13 +2423,14 @@ public void apply(Instrumentation instrumentation, TypeLocator typeLocator, List
                     List<ClassDefinition> classDefinitions = new ArrayList<ClassDefinition>(entries.size());
                     for (Entry entry : entries) {
                         TypeDescription typeDescription = new TypeDescription.ForLoadedType(entry.getType());
+                        JavaModule module = JavaModule.ofType(entry.getType());
                         try {
                             classDefinitions.add(entry.resolve(ClassFileLocator.ForClassLoader.of(entry.getType().getClassLoader())));
                         } catch (Throwable throwable) {
                             try {
-                                listener.onError(typeDescription.getName(), entry.getType().getClassLoader(), throwable);
+                                listener.onError(typeDescription.getName(), entry.getType().getClassLoader(), module, throwable);
                             } finally {
-                                listener.onComplete(typeDescription.getName(), entry.getType().getClassLoader());
+                                listener.onComplete(typeDescription.getName(), entry.getType().getClassLoader(), module);
                             }
                         }
                     }
@@ -2391,6 +2537,7 @@ protected ForRetransformation(Default.Transformation transformation) {
                 public boolean consider(Class<?> type, RawMatcher ignoredTypeMatcher) {
                     return transformation.resolve(new TypeDescription.ForLoadedType(type),
                             type.getClassLoader(),
+                            JavaModule.ofType(type),
                             type,
                             type.getProtectionDomain(),
                             ignoredTypeMatcher).getSort().isAlive() && types.add(type);
@@ -2424,7 +2571,7 @@ public String toString() {
          * Classes representing lambda expressions that are created by Byte Buddy are fully compatible to those created by
          * the JVM and can be serialized or deserialized to one another. The classes do however show a few differences:
          * <ul>
-         * <li>Byte Buddy's classes are public with a public constructor. Doing so, it is not necessary to instantiate a
+         * <li>Byte Buddy's classes are public with a public executing transformer. Doing so, it is not necessary to instantiate a
          * non-capturing lambda expression by reflection. This is done because Byte Buddy is not necessarily capable
          * of using reflection due to an active security manager.</li>
          * <li>Byte Buddy's classes are not marked as synthetic as an agent builder does not instrument synthetic classes
@@ -2694,7 +2841,7 @@ public String toString() {
             }
 
             /**
-             * Implements a lambda class's constructor.
+             * Implements a lambda class's executing transformer.
              */
             @SuppressFBWarnings(value = "SE_BAD_FIELD", justification = "An enumeration does not serialize fields")
             protected enum ConstructorImplementation implements Implementation {
@@ -2705,12 +2852,12 @@ public String toString() {
                 INSTANCE;
 
                 /**
-                 * A reference to the {@link Object} class's default constructor.
+                 * A reference to the {@link Object} class's default executing transformer.
                  */
                 private final MethodDescription.InDefinedShape objectConstructor;
 
                 /**
-                 * Creates a new constructor implementation.
+                 * Creates a new executing transformer implementation.
                  */
                 ConstructorImplementation() {
                     objectConstructor = TypeDescription.OBJECT.getDeclaredMethods().filter(isConstructor()).getOnly();
@@ -2732,7 +2879,7 @@ public String toString() {
                 }
 
                 /**
-                 * An appender to implement the constructor.
+                 * An appender to implement the executing transformer.
                  */
                 protected static class Appender implements ByteCodeAppender {
 
@@ -3879,7 +4026,7 @@ public Default(ByteBuddy byteBuddy) {
                     RedefinitionStrategy.DISABLED,
                     BootstrapInjectionStrategy.Disabled.INSTANCE,
                     LambdaInstrumentationStrategy.DISABLED,
-                    new RawMatcher.Disjunction(new RawMatcher.ForElementMatcherPair(any(), isBootstrapClassLoader()), new RawMatcher.ForElementMatcherPair(isSynthetic(), any())),
+                    new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader(), any()).or(new RawMatcher.ForElementMatchers(isSynthetic(), any(), any())),
                     Transformation.Ignored.INSTANCE);
         }
 
@@ -4130,17 +4277,31 @@ public AgentBuilder disableBootstrapInjection() {
 
         @Override
         public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
-            return type(new RawMatcher.ForElementMatcherPair(typeMatcher, classLoaderMatcher));
+            return type(typeMatcher, classLoaderMatcher, any());
+        }
+
+        @Override
+        public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher,
+                                          ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                                          ElementMatcher<? super JavaModule> moduleMatcher) {
+            return type(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));
+        }
+
+        @Override
+        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher) {
+            return ignore(typeMatcher, any());
         }
 
         @Override
-        public Ignored ignore(ElementMatcher<? super TypeDescription> ignoredTypes) {
-            return ignore(ignoredTypes, any());
+        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher, ElementMatcher<? super ClassLoader> classLoaderMatcher) {
+            return ignore(typeMatcher, classLoaderMatcher, any());
         }
 
         @Override
-        public Ignored ignore(ElementMatcher<? super TypeDescription> ignoredTypes, ElementMatcher<? super ClassLoader> ignoredClassLoaders) {
-            return ignore(new RawMatcher.ForElementMatcherPair(ignoredTypes, ignoredClassLoaders));
+        public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher,
+                              ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                              ElementMatcher<? super JavaModule> moduleMatcher) {
+            return ignore(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));
         }
 
         @Override
@@ -4166,7 +4327,7 @@ public AgentBuilder disableClassFormatChanges() {
 
         @Override
         public ClassFileTransformer makeRaw() {
-            return new ExecutingTransformer(byteBuddy,
+            return ExecutingTransformer.FACTORY.make(byteBuddy,
                     typeLocator,
                     typeStrategy,
                     listener,
@@ -4190,13 +4351,14 @@ public ClassFileTransformer installOn(Instrumentation instrumentation) {
                 RedefinitionStrategy.Collector collector = redefinitionStrategy.makeCollector(transformation);
                 for (Class<?> type : instrumentation.getAllLoadedClasses()) {
                     TypeDescription typeDescription = new TypeDescription.ForLoadedType(type);
+                    JavaModule module = JavaModule.ofType(type);
                     try {
                         if (!instrumentation.isModifiableClass(type) || !collector.consider(type, ignoredTypeMatcher)) {
                             try {
                                 try {
-                                    listener.onIgnored(typeDescription, type.getClassLoader());
+                                    listener.onIgnored(typeDescription, type.getClassLoader(), module);
                                 } finally {
-                                    listener.onComplete(typeDescription.getName(), type.getClassLoader());
+                                    listener.onComplete(typeDescription.getName(), type.getClassLoader(), module);
                                 }
                             } catch (Throwable ignored) {
                                 // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
@@ -4205,9 +4367,9 @@ public ClassFileTransformer installOn(Instrumentation instrumentation) {
                     } catch (Throwable throwable) {
                         try {
                             try {
-                                listener.onError(typeDescription.getName(), type.getClassLoader(), throwable);
+                                listener.onError(typeDescription.getName(), type.getClassLoader(), module, throwable);
                             } finally {
-                                listener.onComplete(typeDescription.getName(), type.getClassLoader());
+                                listener.onComplete(typeDescription.getName(), type.getClassLoader(), module);
                             }
                         } catch (Throwable ignored) {
                             // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
@@ -4524,6 +4686,7 @@ public String toString() {
              *
              * @param typeDescription     A description of the type that is to be transformed.
              * @param classLoader         The class loader of the type being transformed.
+             * @param module              The transformed type's module or {@code null} if the current VM does not support modules.
              * @param classBeingRedefined In case of a type redefinition, the loaded type being transformed or {@code null} if that is not the case.
              * @param protectionDomain    The protection domain of the type being transformed.
              * @param ignoredTypeMatcher  Identifies types that should not be instrumented.
@@ -4531,6 +4694,7 @@ public String toString() {
              */
             Resolution resolve(TypeDescription typeDescription,
                                ClassLoader classLoader,
+                               JavaModule module,
                                Class<?> classBeingRedefined,
                                ProtectionDomain protectionDomain,
                                RawMatcher ignoredTypeMatcher);
@@ -4664,15 +4828,22 @@ public String toString() {
                      */
                     private final ClassLoader classLoader;
 
+                    /**
+                     * The non-transformed type's module or {@code null} if the current VM does not support modules.
+                     */
+                    private final JavaModule module;
+
                     /**
                      * Creates a new unresolved resolution.
                      *
                      * @param typeDescription The type that is not transformed.
                      * @param classLoader     The unresolved type's class loader.
+                     * @param module          The non-transformed type's module or {@code null} if the current VM does not support modules.
                      */
-                    protected Unresolved(TypeDescription typeDescription, ClassLoader classLoader) {
+                    protected Unresolved(TypeDescription typeDescription, ClassLoader classLoader, JavaModule module) {
                         this.typeDescription = typeDescription;
                         this.classLoader = classLoader;
+                        this.module = module;
                     }
 
                     @Override
@@ -4699,7 +4870,7 @@ public Resolution prepend(Decoratable resolution) {
                                         BootstrapInjectionStrategy bootstrapInjectionStrategy,
                                         AccessControlContext accessControlContext,
                                         Listener listener) {
-                        listener.onIgnored(typeDescription, classLoader);
+                        listener.onIgnored(typeDescription, classLoader, module);
                         return NO_TRANSFORMATION;
                     }
 
@@ -4709,13 +4880,15 @@ public boolean equals(Object object) {
                         if (object == null || getClass() != object.getClass()) return false;
                         Unresolved that = (Unresolved) object;
                         return typeDescription.equals(that.typeDescription)
-                                && (classLoader != null ? classLoader.equals(that.classLoader) : that.classLoader == null);
+                                && (classLoader != null ? classLoader.equals(that.classLoader) : that.classLoader == null)
+                                && (module != null ? module.equals(that.module) : that.module == null);
                     }
 
                     @Override
                     public int hashCode() {
                         int result = typeDescription.hashCode();
                         result = 31 * result + (classLoader != null ? classLoader.hashCode() : 0);
+                        result = 31 * result + (module != null ? module.hashCode() : 0);
                         return result;
                     }
 
@@ -4724,6 +4897,7 @@ public String toString() {
                         return "AgentBuilder.Default.Transformation.Resolution.Unresolved{" +
                                 "typeDescription=" + typeDescription +
                                 ", classLoader=" + classLoader +
+                                ", module=" + module +
                                 '}';
                     }
                 }
@@ -4742,10 +4916,11 @@ public String toString() {
                 @Override
                 public Resolution resolve(TypeDescription typeDescription,
                                           ClassLoader classLoader,
+                                          JavaModule module,
                                           Class<?> classBeingRedefined,
                                           ProtectionDomain protectionDomain,
                                           RawMatcher ignoredTypeMatcher) {
-                    return new Resolution.Unresolved(typeDescription, classLoader);
+                    return new Resolution.Unresolved(typeDescription, classLoader, module);
                 }
 
                 @Override
@@ -4790,13 +4965,14 @@ protected Simple(RawMatcher rawMatcher, Transformer transformer, boolean decorat
                 @Override
                 public Transformation.Resolution resolve(TypeDescription typeDescription,
                                                          ClassLoader classLoader,
+                                                         JavaModule module,
                                                          Class<?> classBeingRedefined,
                                                          ProtectionDomain protectionDomain,
                                                          RawMatcher ignoredTypeMatcher) {
-                    return !ignoredTypeMatcher.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain)
-                            && rawMatcher.matches(typeDescription, classLoader, classBeingRedefined, protectionDomain)
-                            ? new Resolution(typeDescription, classLoader, protectionDomain, transformer, decorator)
-                            : new Transformation.Resolution.Unresolved(typeDescription, classLoader);
+                    return !ignoredTypeMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)
+                            && rawMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)
+                            ? new Resolution(typeDescription, classLoader, module, protectionDomain, transformer, decorator)
+                            : new Transformation.Resolution.Unresolved(typeDescription, classLoader, module);
                 }
 
                 @Override
@@ -4839,6 +5015,11 @@ public String toString() {
                      */
                     private final ClassLoader classLoader;
 
+                    /**
+                     * The transformed type's module or {@code null} if the current VM does not support modules.
+                     */
+                    private final JavaModule module;
+
                     /**
                      * The protection domain of the transformed type.
                      */
@@ -4859,17 +5040,20 @@ public String toString() {
                      *
                      * @param typeDescription  A description of the transformed type.
                      * @param classLoader      The class loader of the transformed type.
+                     * @param module           The transformed type's module or {@code null} if the current VM does not support modules.
                      * @param protectionDomain The protection domain of the transformed type.
                      * @param transformer      The transformer to be applied.
                      * @param decorator        {@code true} if this transformer serves as a decorator.
                      */
                     protected Resolution(TypeDescription typeDescription,
                                          ClassLoader classLoader,
+                                         JavaModule module,
                                          ProtectionDomain protectionDomain,
                                          Transformer transformer,
                                          boolean decorator) {
                         this.typeDescription = typeDescription;
                         this.classLoader = classLoader;
+                        this.module = module;
                         this.protectionDomain = protectionDomain;
                         this.transformer = transformer;
                         this.decorator = decorator;
@@ -4896,6 +5080,7 @@ public Sort getSort() {
                     public Transformation.Resolution append(Transformer transformer) {
                         return new Resolution(typeDescription,
                                 classLoader,
+                                module,
                                 protectionDomain,
                                 new Transformer.Compound(this.transformer, transformer),
                                 decorator);
@@ -4919,7 +5104,7 @@ public Sort getSort() {
                                 classLoader,
                                 protectionDomain,
                                 accessControlContext));
-                        listener.onTransformation(typeDescription, classLoader, dynamicType);
+                        listener.onTransformation(typeDescription, classLoader, module, dynamicType);
                         return dynamicType.getBytes();
                     }
 
@@ -4931,6 +5116,7 @@ public boolean equals(Object other) {
                         return typeDescription.equals(that.typeDescription)
                                 && decorator == that.decorator
                                 && !(classLoader != null ? !classLoader.equals(that.classLoader) : that.classLoader != null)
+                                && !(module != null ? !module.equals(that.module) : that.module != null)
                                 && !(protectionDomain != null ? !protectionDomain.equals(that.protectionDomain) : that.protectionDomain != null)
                                 && transformer.equals(that.transformer);
                     }
@@ -4940,6 +5126,7 @@ public int hashCode() {
                         int result = typeDescription.hashCode();
                         result = 31 * result + (decorator ? 1 : 0);
                         result = 31 * result + (classLoader != null ? classLoader.hashCode() : 0);
+                        result = 31 * result + (module != null ? module.hashCode() : 0);
                         result = 31 * result + (protectionDomain != null ? protectionDomain.hashCode() : 0);
                         result = 31 * result + transformer.hashCode();
                         return result;
@@ -4950,6 +5137,7 @@ public String toString() {
                         return "AgentBuilder.Default.Transformation.Simple.Resolution{" +
                                 "typeDescription=" + typeDescription +
                                 ", classLoader=" + classLoader +
+                                ", module=" + module +
                                 ", protectionDomain=" + protectionDomain +
                                 ", transformer=" + transformer +
                                 ", decorator=" + decorator +
@@ -5070,13 +5258,15 @@ protected Compound(List<? extends Transformation> transformations) {
                 @Override
                 public Resolution resolve(TypeDescription typeDescription,
                                           ClassLoader classLoader,
+                                          JavaModule module,
                                           Class<?> classBeingRedefined,
                                           ProtectionDomain protectionDomain,
                                           RawMatcher ignoredTypeMatcher) {
-                    Resolution current = new Resolution.Unresolved(typeDescription, classLoader);
+                    Resolution current = new Resolution.Unresolved(typeDescription, classLoader, module);
                     for (Transformation transformation : transformations) {
                         Resolution resolution = transformation.resolve(typeDescription,
                                 classLoader,
+                                module,
                                 classBeingRedefined,
                                 protectionDomain,
                                 ignoredTypeMatcher);
@@ -5121,6 +5311,47 @@ public String toString() {
          */
         protected static class ExecutingTransformer implements ClassFileTransformer {
 
+            /**
+             * A factory for creating a {@link ClassFileTransformer} that supports the features of the current VM.
+             */
+            protected static final Factory FACTORY;
+
+            /*
+             * Creates a factory for a class file transformer that supports the features of the current VM.
+             */
+            static {
+                Factory factory;
+                try {
+                    factory = new Factory.ForJava9CapableVm(new ByteBuddy()
+                            .subclass(ExecutingTransformer.class)
+                            .method(named("transform").and(takesArgument(0, JavaType.MODULE.getTypeStub())))
+                            .intercept(MethodCall.invoke(ExecutingTransformer.class.getDeclaredMethod("transform",
+                                    Object.class,
+                                    String.class,
+                                    Class.class,
+                                    ProtectionDomain.class,
+                                    byte[].class)).onSuper().withAllArguments())
+                            .make()
+                            .load(ExecutingTransformer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
+                            .getLoaded()
+                            .getDeclaredConstructor(ByteBuddy.class,
+                                    TypeLocator.class,
+                                    TypeStrategy.class,
+                                    Listener.class,
+                                    NativeMethodStrategy.class,
+                                    AccessControlContext.class,
+                                    InitializationStrategy.class,
+                                    BootstrapInjectionStrategy.class,
+                                    RawMatcher.class,
+                                    Transformation.class));
+                } catch (RuntimeException exception) {
+                    throw exception;
+                } catch (Exception ignored) {
+                    factory = Factory.ForLegacyVm.INSTANCE;
+                }
+                FACTORY = factory;
+            }
+
             /**
              * The Byte Buddy instance to be used.
              */
@@ -5213,6 +5444,50 @@ public ExecutingTransformer(ByteBuddy byteBuddy,
                                     Class<?> classBeingRedefined,
                                     ProtectionDomain protectionDomain,
                                     byte[] binaryRepresentation) {
+                return transform(JavaModule.UNSUPPORTED, classLoader, internalTypeName, classBeingRedefined, protectionDomain, binaryRepresentation);
+            }
+
+            /**
+             * Applies a transformation for a class that was captured by this {@link ClassFileTransformer}.
+             *
+             * @param rawModule            The instrumented class's Java {@code java.lang.reflect.Module}.
+             * @param internalTypeName     The internal name of the instrumented class.
+             * @param classBeingRedefined  The loaded {@link Class} being redefined or {@code null} if no such class exists.
+             * @param protectionDomain     The instrumented type's protection domain.
+             * @param binaryRepresentation The class file of the instrumented class in its current state.
+             * @return The transformed class file or an empty byte array if this transformer does not apply an instrumentation.
+             */
+            protected byte[] transform(Object rawModule,
+                                       String internalTypeName,
+                                       Class<?> classBeingRedefined,
+                                       ProtectionDomain protectionDomain,
+                                       byte[] binaryRepresentation) {
+                JavaModule module = JavaModule.of(rawModule);
+                return transform(module,
+                        module.getClassLoader(accessControlContext),
+                        internalTypeName,
+                        classBeingRedefined,
+                        protectionDomain,
+                        binaryRepresentation);
+            }
+
+            /**
+             * Applies a transformation for a class that was captured by this {@link ClassFileTransformer}.
+             *
+             * @param module               The instrumented class's Java module in its wrapped form or {@code null} if the current VM does not support modules.
+             * @param classLoader          The instrumented class's class loader.
+             * @param internalTypeName     The internal name of the instrumented class.
+             * @param classBeingRedefined  The loaded {@link Class} being redefined or {@code null} if no such class exists.
+             * @param protectionDomain     The instrumented type's protection domain.
+             * @param binaryRepresentation The class file of the instrumented class in its current state.
+             * @return The transformed class file or an empty byte array if this transformer does not apply an instrumentation.
+             */
+            private byte[] transform(JavaModule module,
+                                     ClassLoader classLoader,
+                                     String internalTypeName,
+                                     Class<?> classBeingRedefined,
+                                     ProtectionDomain protectionDomain,
+                                     byte[] binaryRepresentation) {
                 if (internalTypeName == null) {
                     return NO_TRANSFORMATION;
                 }
@@ -5225,6 +5500,7 @@ public ExecutingTransformer(ByteBuddy byteBuddy,
                                     ? typeLocator.typePool(classFileLocator, classLoader).describe(binaryTypeName).resolve()
                                     : new TypeDescription.ForLoadedType(classBeingRedefined),
                             classLoader,
+                            module,
                             classBeingRedefined,
                             protectionDomain,
                             ignoredTypeMatcher).apply(initializationStrategy,
@@ -5236,10 +5512,10 @@ public ExecutingTransformer(ByteBuddy byteBuddy,
                             accessControlContext,
                             listener);
                 } catch (Throwable throwable) {
-                    listener.onError(binaryTypeName, classLoader, throwable);
+                    listener.onError(binaryTypeName, classLoader, module, throwable);
                     return NO_TRANSFORMATION;
                 } finally {
-                    listener.onComplete(binaryTypeName, classLoader);
+                    listener.onComplete(binaryTypeName, classLoader, module);
                 }
             }
 
@@ -5290,6 +5566,151 @@ public String toString() {
                         ", transformation=" + transformation +
                         '}';
             }
+
+            /**
+             * A factory for creating a {@link ClassFileTransformer} for the current VM.
+             */
+            protected interface Factory {
+
+                /**
+                 * Creates a new class file transformer for the current VM.
+                 *
+                 * @param byteBuddy                  The Byte Buddy instance to be used.
+                 * @param typeLocator                The type locator to use.
+                 * @param typeStrategy               The definition handler to use.
+                 * @param listener                   The listener to notify on transformations.
+                 * @param nativeMethodStrategy       The native method strategy to apply.
+                 * @param accessControlContext       The access control context to use for loading classes.
+                 * @param initializationStrategy     The initialization strategy to use for transformed types.
+                 * @param bootstrapInjectionStrategy The injection strategy for injecting classes into the bootstrap class loader.
+                 * @param ignoredTypeMatcher         Identifies types that should not be instrumented.
+                 * @param transformation             The transformation object for handling type transformations.
+                 * @return A class file transformer for the current VM that supports the API of the current VM.
+                 */
+                ClassFileTransformer make(ByteBuddy byteBuddy,
+                                          TypeLocator typeLocator,
+                                          TypeStrategy typeStrategy,
+                                          Listener listener,
+                                          NativeMethodStrategy nativeMethodStrategy,
+                                          AccessControlContext accessControlContext,
+                                          InitializationStrategy initializationStrategy,
+                                          BootstrapInjectionStrategy bootstrapInjectionStrategy,
+                                          RawMatcher ignoredTypeMatcher,
+                                          Transformation transformation);
+
+                /**
+                 * A factory for a class file transformer on a JVM that supports the {@code java.lang.reflect.Module} API to override
+                 * the newly added method of the {@link ClassFileTransformer} to capture an instrumented class's module.
+                 */
+                class ForJava9CapableVm implements Factory {
+
+                    /**
+                     * A constructor for creating a {@link ClassFileTransformer} that overrides the newly added method for extracting
+                     * the {@code java.lang.reflect.Module} of an instrumented class.
+                     */
+                    private final Constructor<? extends ClassFileTransformer> executingTransformer;
+
+                    /**
+                     * Creates a class file transformer factory for a Java 9 capable VM.
+                     *
+                     * @param executingTransformer A constructor for creating a {@link ClassFileTransformer} that overrides the newly added
+                     *                             method for extracting the {@code java.lang.reflect.Module} of an instrumented class.
+                     */
+                    protected ForJava9CapableVm(Constructor<? extends ClassFileTransformer> executingTransformer) {
+                        this.executingTransformer = executingTransformer;
+                    }
+
+                    @Override
+                    public ClassFileTransformer make(ByteBuddy byteBuddy,
+                                                     TypeLocator typeLocator,
+                                                     TypeStrategy typeStrategy,
+                                                     Listener listener,
+                                                     NativeMethodStrategy nativeMethodStrategy,
+                                                     AccessControlContext accessControlContext,
+                                                     InitializationStrategy initializationStrategy,
+                                                     BootstrapInjectionStrategy bootstrapInjectionStrategy,
+                                                     RawMatcher ignoredTypeMatcher,
+                                                     Transformation transformation) {
+                        try {
+                            return executingTransformer.newInstance(byteBuddy,
+                                    typeLocator,
+                                    typeStrategy,
+                                    listener,
+                                    nativeMethodStrategy,
+                                    accessControlContext,
+                                    initializationStrategy,
+                                    bootstrapInjectionStrategy,
+                                    ignoredTypeMatcher,
+                                    transformation);
+                        } catch (IllegalAccessException exception) {
+                            throw new IllegalStateException("Cannot access " + executingTransformer, exception);
+                        } catch (InstantiationException exception) {
+                            throw new IllegalStateException("Cannot instantiate " + executingTransformer.getDeclaringClass(), exception);
+                        } catch (InvocationTargetException exception) {
+                            throw new IllegalStateException("Cannot invoke " + executingTransformer, exception.getCause());
+                        }
+                    }
+
+                    @Override
+                    public boolean equals(Object object) {
+                        if (this == object) return true;
+                        if (object == null || getClass() != object.getClass()) return false;
+                        ForJava9CapableVm that = (ForJava9CapableVm) object;
+                        return executingTransformer.equals(that.executingTransformer);
+                    }
+
+                    @Override
+                    public int hashCode() {
+                        return executingTransformer.hashCode();
+                    }
+
+                    @Override
+                    public String toString() {
+                        return "AgentBuilder.Default.ExecutingTransformer.Factory.ForJava9CapableVm{" +
+                                "executingTransformer=" + executingTransformer +
+                                '}';
+                    }
+                }
+
+                /**
+                 * A factory for a {@link ClassFileTransformer} on a VM that does not support the {@code java.lang.reflect.Module} API.
+                 */
+                enum ForLegacyVm implements Factory {
+
+                    /**
+                     * The singleton instance.
+                     */
+                    INSTANCE;
+
+                    @Override
+                    public ClassFileTransformer make(ByteBuddy byteBuddy,
+                                                     TypeLocator typeLocator,
+                                                     TypeStrategy typeStrategy,
+                                                     Listener listener,
+                                                     NativeMethodStrategy nativeMethodStrategy,
+                                                     AccessControlContext accessControlContext,
+                                                     InitializationStrategy initializationStrategy,
+                                                     BootstrapInjectionStrategy bootstrapInjectionStrategy,
+                                                     RawMatcher ignoredTypeMatcher,
+                                                     Transformation transformation) {
+                        return new ExecutingTransformer(byteBuddy,
+                                typeLocator,
+                                typeStrategy,
+                                listener,
+                                nativeMethodStrategy,
+                                accessControlContext,
+                                initializationStrategy,
+                                bootstrapInjectionStrategy,
+                                ignoredTypeMatcher,
+                                transformation);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return "AgentBuilder.Default.ExecutingTransformer.Factory.ForLegacyVm." + name();
+                    }
+                }
+            }
         }
 
         /**
@@ -5381,6 +5802,14 @@ public AgentBuilder disableClassFormatChanges() {
                 return materialize().type(typeMatcher, classLoaderMatcher);
             }
 
+            @Override
+            public Identified.Narrowable type(ElementMatcher<? super TypeDescription> typeMatcher,
+                                              ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                                              ElementMatcher<? super JavaModule> moduleMatcher) {
+                return materialize().type(typeMatcher, classLoaderMatcher, moduleMatcher);
+            }
+
+
             @Override
             public Identified.Narrowable type(RawMatcher matcher) {
                 return materialize().type(matcher);
@@ -5396,6 +5825,13 @@ public Ignored ignore(ElementMatcher<? super TypeDescription> ignoredTypes, Elem
                 return materialize().ignore(ignoredTypes, ignoredClassLoaders);
             }
 
+            @Override
+            public Ignored ignore(ElementMatcher<? super TypeDescription> typeMatcher,
+                                  ElementMatcher<? super ClassLoader> classLoaderMatcher,
+                                  ElementMatcher<? super JavaModule> moduleMatcher) {
+                return materialize().ignore(typeMatcher, classLoaderMatcher, moduleMatcher);
+            }
+
             @Override
             public Ignored ignore(RawMatcher rawMatcher) {
                 return materialize().ignore(rawMatcher);
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java
index f6498a2504..a992c63071 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/NamedElement.java
@@ -21,7 +21,7 @@
      *
      * @return The name of this element as given in a Java program's source code.
      */
-    String getSourceCodeName();
+    String getActualName();
 
     /**
      * A named element with a name that has a particular meaning to the Java runtime.
@@ -43,6 +43,19 @@
         String getInternalName();
     }
 
+    /**
+     * Describes a named element where naming the element is optional and an alternative default name is provided if no explicit name is given.
+     */
+    interface WithOptionalName extends NamedElement {
+
+        /**
+         * Returns {@code true} if this element has an explicit name.
+         *
+         * @return {@code true} if this element has an explicit name.
+         */
+        boolean isNamed();
+    }
+
     /**
      * A named element with a generic type name.
      */
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
index 8a42c530db..a759330288 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/field/FieldDescription.java
@@ -91,7 +91,7 @@ public String getInternalName() {
         }
 
         @Override
-        public String getSourceCodeName() {
+        public String getActualName() {
             return getName();
         }
 
@@ -159,8 +159,8 @@ public String toGenericString() {
             if (getModifiers() != EMPTY_MASK) {
                 stringBuilder.append(Modifier.toString(getModifiers())).append(" ");
             }
-            stringBuilder.append(getType().getSourceCodeName()).append(" ");
-            stringBuilder.append(getDeclaringType().asErasure().getSourceCodeName()).append(".");
+            stringBuilder.append(getType().getActualName()).append(" ");
+            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(".");
             return stringBuilder.append(getName()).toString();
         }
 
@@ -170,8 +170,8 @@ public String toString() {
             if (getModifiers() != EMPTY_MASK) {
                 stringBuilder.append(Modifier.toString(getModifiers())).append(" ");
             }
-            stringBuilder.append(getType().asErasure().getSourceCodeName()).append(" ");
-            stringBuilder.append(getDeclaringType().asErasure().getSourceCodeName()).append(".");
+            stringBuilder.append(getType().asErasure().getActualName()).append(" ");
+            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(".");
             return stringBuilder.append(getName()).toString();
         }
     }
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
index 305f99ac1a..f09ad452d2 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/MethodDescription.java
@@ -372,7 +372,7 @@ public String getName() {
         }
 
         @Override
-        public String getSourceCodeName() {
+        public String getActualName() {
             return isMethod()
                     ? getName()
                     : EMPTY_NAME;
@@ -666,8 +666,8 @@ public String toGenericString() {
                 stringBuilder.append(Modifier.toString(modifiers)).append(" ");
             }
             if (isMethod()) {
-                stringBuilder.append(getReturnType().getSourceCodeName()).append(" ");
-                stringBuilder.append(getDeclaringType().asErasure().getSourceCodeName()).append(".");
+                stringBuilder.append(getReturnType().getActualName()).append(" ");
+                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(".");
             }
             stringBuilder.append(getName()).append("(");
             boolean first = true;
@@ -677,7 +677,7 @@ public String toGenericString() {
                 } else {
                     first = false;
                 }
-                stringBuilder.append(typeDescription.getSourceCodeName());
+                stringBuilder.append(typeDescription.getActualName());
             }
             stringBuilder.append(")");
             TypeList.Generic exceptionTypes = getExceptionTypes();
@@ -690,7 +690,7 @@ public String toGenericString() {
                     } else {
                         first = false;
                     }
-                    stringBuilder.append(typeDescription.getSourceCodeName());
+                    stringBuilder.append(typeDescription.getActualName());
                 }
             }
             return stringBuilder.toString();
@@ -704,8 +704,8 @@ public String toString() {
                 stringBuilder.append(Modifier.toString(modifiers)).append(" ");
             }
             if (isMethod()) {
-                stringBuilder.append(getReturnType().asErasure().getSourceCodeName()).append(" ");
-                stringBuilder.append(getDeclaringType().asErasure().getSourceCodeName()).append(".");
+                stringBuilder.append(getReturnType().asErasure().getActualName()).append(" ");
+                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(".");
             }
             stringBuilder.append(getName()).append("(");
             boolean first = true;
@@ -715,7 +715,7 @@ public String toString() {
                 } else {
                     first = false;
                 }
-                stringBuilder.append(typeDescription.getSourceCodeName());
+                stringBuilder.append(typeDescription.getActualName());
             }
             stringBuilder.append(")");
             TypeList exceptionTypes = getExceptionTypes().asErasures();
@@ -728,7 +728,7 @@ public String toString() {
                     } else {
                         first = false;
                     }
-                    stringBuilder.append(typeDescription.getSourceCodeName());
+                    stringBuilder.append(typeDescription.getActualName());
                 }
             }
             return stringBuilder.toString();
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
index d7c34d181b..7590365b7e 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/method/ParameterDescription.java
@@ -24,6 +24,7 @@
  */
 public interface ParameterDescription extends AnnotatedCodeElement,
         NamedElement.WithRuntimeName,
+        NamedElement.WithOptionalName,
         ModifierReviewable,
         ByteCodeElement.TypeDependant<ParameterDescription.InDefinedShape, ParameterDescription.Token> {
 
@@ -53,14 +54,6 @@
      */
     int getIndex();
 
-    /**
-     * Checks if this parameter has an explicit name. A parameter without an explicit name is named implicitly by
-     * {@code argX} with {@code X} denoting the zero-based index.
-     *
-     * @return {@code true} if the parameter has an explicit name.
-     */
-    boolean isNamed();
-
     /**
      * Checks if this parameter has an explicit modifier. A parameter without a modifier is simply treated as
      * if it had a modifier of zero.
@@ -121,7 +114,7 @@ public String getInternalName() {
         }
 
         @Override
-        public String getSourceCodeName() {
+        public String getActualName() {
             return isNamed()
                     ? getName()
                     : EMPTY_NAME;
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
index 38b86535de..b8c2669ecc 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/PackageDescription.java
@@ -45,7 +45,7 @@ public String getInternalName() {
         }
 
         @Override
-        public String getSourceCodeName() {
+        public String getActualName() {
             return getName();
         }
 
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java b/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
index 3b0e3e38a0..862cf98e8d 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/description/type/TypeDescription.java
@@ -4129,8 +4129,8 @@ public StackSize getStackSize() {
             }
 
             @Override
-            public String getSourceCodeName() {
-                return asErasure().getSourceCodeName();
+            public String getActualName() {
+                return asErasure().getActualName();
             }
 
             @Override
@@ -4437,9 +4437,9 @@ public String getTypeName() {
             }
 
             @Override
-            public String getSourceCodeName() {
+            public String getActualName() {
                 return getSort().isNonGeneric()
-                        ? asErasure().getSourceCodeName()
+                        ? asErasure().getActualName()
                         : toString();
             }
 
@@ -4650,7 +4650,7 @@ public String getTypeName() {
             }
 
             @Override
-            public String getSourceCodeName() {
+            public String getActualName() {
                 return toString();
             }
 
@@ -4992,7 +4992,7 @@ public String getTypeName() {
             }
 
             @Override
-            public String getSourceCodeName() {
+            public String getActualName() {
                 return toString();
             }
 
@@ -5391,7 +5391,7 @@ public String getTypeName() {
             }
 
             @Override
-            public String getSourceCodeName() {
+            public String getActualName() {
                 return getSymbol();
             }
 
@@ -5546,7 +5546,7 @@ public String getTypeName() {
                 }
 
                 @Override
-                public String getSourceCodeName() {
+                public String getActualName() {
                     return getSymbol();
                 }
 
@@ -5785,8 +5785,8 @@ public String getSymbol() {
             }
 
             @Override
-            public String getSourceCodeName() {
-                return resolve().getSourceCodeName();
+            public String getActualName() {
+                return resolve().getActualName();
             }
 
             @Override
@@ -7071,7 +7071,7 @@ public AnnotationList getInheritedAnnotations() {
         }
 
         @Override
-        public String getSourceCodeName() {
+        public String getActualName() {
             if (isArray()) {
                 TypeDescription typeDescription = this;
                 int dimensions = 0;
@@ -7080,7 +7080,7 @@ public String getSourceCodeName() {
                     typeDescription = typeDescription.getComponentType();
                 } while (typeDescription.isArray());
                 StringBuilder stringBuilder = new StringBuilder();
-                stringBuilder.append(typeDescription.getSourceCodeName());
+                stringBuilder.append(typeDescription.getActualName());
                 for (int i = 0; i < dimensions; i++) {
                     stringBuilder.append("[]");
                 }
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
index ca4207ba06..dc602a3783 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/FixedValue.java
@@ -181,7 +181,7 @@ public static AssignerConfigurable value(TypeDescription fixedValue) {
      */
     public static AssignerConfigurable value(JavaConstant fixedValue) {
         return new ForPoolValue(fixedValue.asStackManipulation(),
-                fixedValue.getInstanceType(),
+                fixedValue.getType(),
                 Assigner.DEFAULT,
                 Assigner.Typing.STATIC);
     }
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
index fa1959f4c2..783a2f6e36 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/InvokeDynamic.java
@@ -2458,7 +2458,7 @@ public ForJavaConstant(JavaConstant javaConstant) {
 
                 @Override
                 public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
-                    return new Resolved.Simple(javaConstant.asStackManipulation(), javaConstant.getInstanceType());
+                    return new Resolved.Simple(javaConstant.asStackManipulation(), javaConstant.getType());
                 }
 
                 @Override
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
index 4f65c86652..2ee387af70 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/MethodCall.java
@@ -2344,7 +2344,7 @@ public ForJavaConstant(JavaConstant javaConstant) {
             public StackManipulation resolve(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
                 StackManipulation stackManipulation = new StackManipulation.Compound(
                         javaConstant.asStackManipulation(),
-                        assigner.assign(javaConstant.getInstanceType().asGenericType(), target.getType(), typing));
+                        assigner.assign(javaConstant.getType().asGenericType(), target.getType(), typing));
                 if (!stackManipulation.isValid()) {
                     throw new IllegalStateException("Cannot assign Class value to " + target);
                 }
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
index e1af068750..6ed7ef7ae7 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/AnnotationTypeMatcher.java
@@ -18,7 +18,7 @@
     /**
      * Creates a new matcher for an annotation description's type.
      *
-     * @param typeMatcher The type matcher to apply to an annotation's type.
+     * @param matcher The type matcher to apply to an annotation's type.
      */
     public AnnotationTypeMatcher(ElementMatcher<? super TypeDescription> matcher) {
         this.matcher = matcher;
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
index 23c04d7212..c1f8f02471 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderHierarchyMatcher.java
@@ -6,7 +6,7 @@
  *
  * @param <T> The exact type of the class loader that is matched.
  */
-public class ClassLoaderHierarchyMatcher<T extends ClassLoader> implements ElementMatcher<T> {
+public class ClassLoaderHierarchyMatcher<T extends ClassLoader> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The matcher to apply on each class loader in the hierarchy.
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
index 27c8256247..d27d6357a8 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ClassLoaderParentMatcher.java
@@ -5,7 +5,7 @@
  *
  * @param <T> The exact type of the class loader that is matched.
  */
-public class ClassLoaderParentMatcher<T extends ClassLoader> implements ElementMatcher<T> {
+public class ClassLoaderParentMatcher<T extends ClassLoader> extends ElementMatcher.Junction.AbstractBase<T> {
 
     /**
      * The class loader that is matched for being a child of the matched class loader.
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
index e29b5fb2cc..36098eb3e1 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatchers.java
@@ -15,6 +15,7 @@
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.description.type.TypeList;
+import net.bytebuddy.utility.JavaModule;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
@@ -511,7 +512,7 @@ private ElementMatchers() {
      * @param <T>    The type of the matched object.
      * @return A matcher that matches type variables with the given name.
      */
-    public static <T extends TypeDefinition> ElementMatcher<T> isVariable(String symbol) {
+    public static <T extends TypeDefinition> ElementMatcher.Junction<T> isVariable(String symbol) {
         return isVariable(named(symbol));
     }
 
@@ -522,7 +523,7 @@ private ElementMatchers() {
      * @param <T>     The type of the matched object.
      * @return A matcher that matches type variables with the given name.
      */
-    public static <T extends TypeDefinition> ElementMatcher<T> isVariable(ElementMatcher<? super NamedElement> matcher) {
+    public static <T extends TypeDefinition> ElementMatcher.Junction<T> isVariable(ElementMatcher<? super NamedElement> matcher) {
         return new TypeSortMatcher<T>(anyOf(TypeDefinition.Sort.VARIABLE, TypeDefinition.Sort.VARIABLE_SYMBOLIC)).and(matcher);
     }
 
@@ -629,6 +630,16 @@ private ElementMatchers() {
         return new NameMatcher<T>(new StringMatcher(regex, StringMatcher.Mode.MATCHES));
     }
 
+    /**
+     * Matches a {@link NamedElement.WithOptionalName} for having an explicit name.
+     *
+     * @param <T> The type of the matched object.
+     * @return An element matcher that checks if the matched optionally named element has an explicit name.
+     */
+    public static <T extends NamedElement.WithOptionalName> ElementMatcher.Junction<T> isNamed() {
+        return new IsNamedMatcher<T>();
+    }
+
     /**
      * Matches a {@link ByteCodeElement}'s descriptor against a given value.
      *
@@ -1529,7 +1540,7 @@ private ElementMatchers() {
      * Matches any type description that declares a super type that matches the provided matcher.
      *
      * @param matcher The type to be checked for being a super type of the matched type.
-     * @param <T>  The type of the matched object.
+     * @param <T>     The type of the matched object.
      * @return A matcher that matches any type description that declares a super type that matches the provided matcher.
      */
     public static <T extends TypeDescription> ElementMatcher.Junction<T> hasSuperType(ElementMatcher<? super TypeDescription> matcher) {
@@ -1540,7 +1551,7 @@ private ElementMatchers() {
      * Matches any type description that declares a super type that matches the provided matcher.
      *
      * @param matcher The type to be checked for being a super type of the matched type.
-     * @param <T>  The type of the matched object.
+     * @param <T>     The type of the matched object.
      * @return A matcher that matches any type description that declares a super type that matches the provided matcher.
      */
     public static <T extends TypeDescription> ElementMatcher.Junction<T> hasGenericSuperType(ElementMatcher<? super TypeDescription.Generic> matcher) {
@@ -1745,7 +1756,7 @@ private ElementMatchers() {
      * @param <T> The type of the matched object.
      * @return A matcher that only matches the bootstrap class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> isBootstrapClassLoader() {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> isBootstrapClassLoader() {
         return new NullMatcher<T>();
     }
 
@@ -1756,7 +1767,7 @@ private ElementMatchers() {
      * @param <T> The type of the matched object.
      * @return A matcher that only matches the system class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> isSystemClassLoader() {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> isSystemClassLoader() {
         return new EqualityMatcher<T>(ClassLoader.getSystemClassLoader());
     }
 
@@ -1767,7 +1778,7 @@ private ElementMatchers() {
      * @param <T> The type of the matched object.
      * @return A matcher that only matches the extension class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> isExtensionClassLoader() {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> isExtensionClassLoader() {
         return new EqualityMatcher<T>(ClassLoader.getSystemClassLoader().getParent());
     }
 
@@ -1779,7 +1790,7 @@ private ElementMatchers() {
      * @return A matcher that matches the given class loader and any class loader that is a child of the given
      * class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> isChildOf(ClassLoader classLoader) {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> isChildOf(ClassLoader classLoader) {
         return classLoader == BOOTSTRAP_CLASSLOADER
                 ? new BooleanMatcher<T>(true)
                 : ElementMatchers.<T>hasChild(is(classLoader));
@@ -1792,7 +1803,7 @@ private ElementMatchers() {
      * @param <T>     The type of the matched object.
      * @return A matcher that matches all class loaders in the hierarchy of the matched class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> hasChild(ElementMatcher<? super ClassLoader> matcher) {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> hasChild(ElementMatcher<? super ClassLoader> matcher) {
         return new ClassLoaderHierarchyMatcher<T>(matcher);
     }
 
@@ -1804,9 +1815,19 @@ private ElementMatchers() {
      * @return A matcher that matches the given class loader and any class loader that is a parent of the given
      * class loader.
      */
-    public static <T extends ClassLoader> ElementMatcher<T> isParentOf(ClassLoader classLoader) {
+    public static <T extends ClassLoader> ElementMatcher.Junction<T> isParentOf(ClassLoader classLoader) {
         return classLoader == BOOTSTRAP_CLASSLOADER
                 ? ElementMatchers.<T>isBootstrapClassLoader()
                 : new ClassLoaderParentMatcher<T>(classLoader);
     }
+
+    /**
+     * Matches a module if it exists, i.e. not {@code null}.
+     *
+     * @param <T>     The type of the matched object.
+     * @return A matcher that validates a module's existence.
+     */
+    public static <T extends JavaModule> ElementMatcher.Junction<T> supportsModules() {
+        return not(new NullMatcher<T>());
+    }
 }
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
new file mode 100755
index 0000000000..dd20ad99bf
--- /dev/null
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/IsNamedMatcher.java
@@ -0,0 +1,31 @@
+package net.bytebuddy.matcher;
+
+import net.bytebuddy.description.NamedElement;
+
+/**
+ * An element matcher that matches a named element only if is explicitly named.
+ *
+ * @param <T> The type of the matched entity.
+ */
+public class IsNamedMatcher<T extends NamedElement.WithOptionalName> extends ElementMatcher.Junction.AbstractBase<T> {
+
+    @Override
+    public boolean matches(T target) {
+        return target.isNamed();
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        return this == other || !(other == null || getClass() != other.getClass());
+    }
+
+    @Override
+    public int hashCode() {
+        return 31;
+    }
+
+    @Override
+    public String toString() {
+        return "isNamed()";
+    }
+}
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
index 1f47fec173..6ca6361512 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/NameMatcher.java
@@ -32,7 +32,7 @@ public NameMatcher(ElementMatcher<String> matcher) {
 
     @Override
     public boolean matches(T target) {
-        return matcher.matches(target.getSourceCodeName());
+        return matcher.matches(target.getActualName());
     }
 
     @Override
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
index f38507b783..4a9ea0a882 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaConstant.java
@@ -46,7 +46,7 @@
      *
      * @return A description of the type of the represented instance or at least a stub.
      */
-    TypeDescription getInstanceType();
+    TypeDescription getType();
 
     /**
      * Represents a {@code java.lang.invoke.MethodType} object.
@@ -276,7 +276,7 @@ public StackManipulation asStackManipulation() {
         }
 
         @Override
-        public TypeDescription getInstanceType() {
+        public TypeDescription getType() {
             return JavaType.METHOD_TYPE.getTypeStub();
         }
 
@@ -711,7 +711,7 @@ public StackManipulation asStackManipulation() {
         }
 
         @Override
-        public TypeDescription getInstanceType() {
+        public TypeDescription getType() {
             return JavaType.METHOD_HANDLE.getTypeStub();
         }
 
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
new file mode 100755
index 0000000000..91d0b4df4c
--- /dev/null
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaModule.java
@@ -0,0 +1,323 @@
+package net.bytebuddy.utility;
+
+import net.bytebuddy.description.NamedElement;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+/**
+ * Type-safe representation of a {@code java.lang.reflect.Module}. On platforms that do not support the module API, modules are represented by {@code null}.
+ */
+public class JavaModule implements NamedElement.WithOptionalName, PrivilegedAction<ClassLoader> {
+
+    /**
+     * Canonical representation of a Java module on a JVM that does not support the module API.
+     */
+    public static final JavaModule UNSUPPORTED = null;
+
+    /**
+     * The dispatcher to use for accessing Java modules, if available.
+     */
+    private static final Dispatcher DISPATCHER;
+
+    /*
+     * Extracts the dispatcher for Java modules that is supported by the current JVM.
+     */
+    static {
+        Dispatcher dispatcher;
+        try {
+            Class<?> module = Class.forName("java.lang.reflect.Module");
+            dispatcher = new Dispatcher.Enabled(Class.class.getDeclaredMethod("getModule"),
+                    module.getDeclaredMethod("getClassLoader"),
+                    module.getDeclaredMethod("isNamed"),
+                    module.getDeclaredMethod("getName"));
+        } catch (RuntimeException exception) {
+            throw exception;
+        } catch (Exception ignored) {
+            dispatcher = Dispatcher.Disabled.INSTANCE;
+        }
+        DISPATCHER = dispatcher;
+    }
+
+    /**
+     * The {@code java.lang.reflect.Module} instance this wrapper represents.
+     */
+    private final Object module;
+
+    /**
+     * Creates a new Java module representation.
+     *
+     * @param module The {@code java.lang.reflect.Module} instance this wrapper represents.
+     */
+    protected JavaModule(Object module) {
+        this.module = module;
+    }
+
+    /**
+     * Returns a representation of the supplied type's {@code java.lang.reflect.Module} or {@code null} if the current VM does not support modules.
+     *
+     * @param type The type for which to describe the module.
+     * @return A representation of the type's module or {@code null} if the current VM does not support modules.
+     */
+    public static JavaModule ofType(Class<?> type) {
+        return DISPATCHER.moduleOf(type);
+    }
+
+    /**
+     * Represents the supplied {@code java.lang.reflect.Module} as an instance of this class and validates that the
+     * supplied instance really represents a Java {@code Module}.
+     *
+     * @param module The module to represent.
+     * @return A representation of the supplied Java module.
+     */
+    public static JavaModule of(Object module) {
+        if (!JavaType.MODULE.getTypeStub().isInstance(module)) {
+            throw new IllegalArgumentException("Not a Java module: " + module);
+        }
+        return new JavaModule(module);
+    }
+
+    @Override
+    public boolean isNamed() {
+        return DISPATCHER.isNamed(module);
+    }
+
+    @Override
+    public String getActualName() {
+        return DISPATCHER.getName(module);
+    }
+
+    /**
+     * Returns the class loader of this module.
+     *
+     * @param accessControlContext The access control context to use for using extracting the class loader.
+     * @return The class loader of the represented module.
+     */
+    public ClassLoader getClassLoader(AccessControlContext accessControlContext) {
+        return AccessController.doPrivileged(this, accessControlContext);
+    }
+
+    /**
+     * Unwraps this instance to a {@code java.lang.reflect.Module}.
+     *
+     * @return The represented {@code java.lang.reflect.Module}.
+     */
+    public Object unwrap() {
+        return module;
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (this == object) return true;
+        if (object == null || getClass() != object.getClass()) return false;
+        JavaModule that = (JavaModule) object;
+        return module.equals(that.module);
+    }
+
+    @Override
+    public int hashCode() {
+        return module.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return module.toString();
+    }
+
+    @Override
+    public ClassLoader run() {
+        return DISPATCHER.getClassLoader(module);
+    }
+
+    /**
+     * A dispatcher for accessing the {@code java.lang.reflect.Module} API if it is available on the current VM.
+     */
+    protected interface Dispatcher {
+
+        /**
+         * Extracts the Java {@code Module} for the provided class or returns {@code null} if the current VM does not support modules.
+         *
+         * @param type The type for which to extract the module.
+         * @return The class's {@code Module} or {@code null} if the current VM does not support modules.
+         */
+        JavaModule moduleOf(Class<?> type);
+
+        /**
+         * Returns {@code true} if the supplied module is named.
+         *
+         * @param module The {@code java.lang.reflect.Module} to check for the existence of a name.
+         * @return {@code true} if the supplied module is named.
+         */
+        boolean isNamed(Object module);
+
+        /**
+         * Returns the module's name.
+         *
+         * @param module The {@code java.lang.reflect.Module} to check for its name.
+         * @return The module's (implicit or explicit) name.
+         */
+        String getName(Object module);
+
+        /**
+         * Returns the module's class loader.
+         *
+         * @param module The {@code java.lang.reflect.Module}
+         * @return The module's class loader.
+         */
+        ClassLoader getClassLoader(Object module);
+
+        /**
+         * A dispatcher for a VM that does support the {@code java.lang.reflect.Module} API.
+         */
+        class Enabled implements Dispatcher {
+
+            /**
+             * The {@code java.lang.Class#getModule()} method.
+             */
+            private final Method getModule;
+
+            /**
+             * The {@code java.lang.reflect.Module#getClassLoader()} method.
+             */
+            private final Method getClassLoader;
+
+            /**
+             * The {@code java.lang.reflect.Module#isNamed()} method.
+             */
+            private final Method isNamed;
+
+            /**
+             * The {@code java.lang.reflect.Module#getName()} method.
+             */
+            private final Method getName;
+
+            /**
+             * Creates a new enabled dispatcher.
+             *
+             * @param getModule      The {@code java.lang.Class#getModule()} method.
+             * @param getClassLoader The {@code java.lang.reflect.Module#getClassLoader()} method.
+             * @param isNamed        The {@code java.lang.reflect.Module#isNamed()} method.
+             * @param getName        The {@code java.lang.reflect.Module#getName()} method.
+             */
+            protected Enabled(Method getModule, Method getClassLoader, Method isNamed, Method getName) {
+                this.getModule = getModule;
+                this.getClassLoader = getClassLoader;
+                this.isNamed = isNamed;
+                this.getName = getName;
+            }
+
+            @Override
+            public JavaModule moduleOf(Class<?> type) {
+                try {
+                    return new JavaModule(getModule.invoke(type));
+                } catch (IllegalAccessException exception) {
+                    throw new IllegalStateException("Cannot access " + getModule, exception);
+                } catch (InvocationTargetException exception) {
+                    throw new IllegalStateException("Cannot invoke " + getModule, exception.getCause());
+                }
+            }
+
+            @Override
+            public ClassLoader getClassLoader(Object module) {
+                try {
+                    return (ClassLoader) getClassLoader.invoke(module);
+                } catch (IllegalAccessException exception) {
+                    throw new IllegalStateException("Cannot access " + getClassLoader, exception);
+                } catch (InvocationTargetException exception) {
+                    throw new IllegalStateException("Cannot invoke " + getClassLoader, exception.getCause());
+                }
+            }
+
+            @Override
+            public boolean isNamed(Object module) {
+                try {
+                    return (Boolean) isNamed.invoke(module);
+                } catch (IllegalAccessException exception) {
+                    throw new IllegalStateException("Cannot access " + isNamed, exception);
+                } catch (InvocationTargetException exception) {
+                    throw new IllegalStateException("Cannot invoke " + isNamed, exception.getCause());
+                }
+            }
+
+            @Override
+            public String getName(Object module) {
+                try {
+                    return (String) getName.invoke(module);
+                } catch (IllegalAccessException exception) {
+                    throw new IllegalStateException("Cannot access " + getName, exception);
+                } catch (InvocationTargetException exception) {
+                    throw new IllegalStateException("Cannot invoke " + getName, exception.getCause());
+                }
+            }
+
+            @Override
+            public boolean equals(Object object) {
+                if (this == object) return true;
+                if (object == null || getClass() != object.getClass()) return false;
+                Enabled enabled = (Enabled) object;
+                if (!getModule.equals(enabled.getModule)) return false;
+                if (!getClassLoader.equals(enabled.getClassLoader)) return false;
+                if (!isNamed.equals(enabled.isNamed)) return false;
+                return getName.equals(enabled.getName);
+            }
+
+            @Override
+            public int hashCode() {
+                int result = getModule.hashCode();
+                result = 31 * result + getClassLoader.hashCode();
+                result = 31 * result + isNamed.hashCode();
+                result = 31 * result + getName.hashCode();
+                return result;
+            }
+
+            @Override
+            public String toString() {
+                return "JavaModule.Dispatcher.Enabled{" +
+                        "getModule=" + getModule +
+                        ", getClassLoader=" + getClassLoader +
+                        ", isNamed=" + isNamed +
+                        ", getName=" + getName +
+                        '}';
+            }
+        }
+
+        /**
+         * A disabled dispatcher for a VM that does not support the {@code java.lang.reflect.Module} API.
+         */
+        enum Disabled implements Dispatcher {
+
+            /**
+             * The singleton instance.
+             */
+            INSTANCE;
+
+            @Override
+            public JavaModule moduleOf(Class<?> type) {
+                return UNSUPPORTED;
+            }
+
+            @Override
+            public ClassLoader getClassLoader(Object module) {
+                throw new IllegalStateException("Current VM does not support modules");
+            }
+
+            @Override
+            public boolean isNamed(Object module) {
+                throw new IllegalStateException("Current VM does not support modules");
+            }
+
+            @Override
+            public String getName(Object module) {
+                throw new IllegalStateException("Current VM does not support modules");
+            }
+
+            @Override
+            public String toString() {
+                return "JavaModule.Dispatcher.Disabled." + name();
+            }
+        }
+    }
+}
diff --git a/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
index b63337e939..ea709dccf0 100755
--- a/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
+++ b/byte-buddy-dep/src/main/java/net/bytebuddy/utility/JavaType.java
@@ -37,7 +37,12 @@
     /**
      * The {@code java.lang.reflect.Executable} type.
      */
-    EXECUTABLE("java.lang.reflect.Executable", Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT, AccessibleObject.class, Member.class, GenericDeclaration.class);
+    EXECUTABLE("java.lang.reflect.Executable", Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT, AccessibleObject.class, Member.class, GenericDeclaration.class),
+
+    /**
+     * The {@code java.lang.reflect.Module} type.
+     */
+    MODULE("java.lang.reflect.Module", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, Object.class);
 
     /**
      * The type description to represent this type which is either a loaded type or a stub.
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
index 747ecf0371..d2a40be61d 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderDefaultTest.java
@@ -13,6 +13,7 @@
 import net.bytebuddy.pool.TypePool;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.JavaModule;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -23,12 +24,11 @@
 import java.lang.instrument.ClassDefinition;
 import java.lang.instrument.ClassFileTransformer;
 import java.lang.instrument.Instrumentation;
+import java.lang.reflect.Constructor;
 import java.security.AccessControlContext;
 import java.security.AccessController;
 import java.security.ProtectionDomain;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.*;
 
 import static net.bytebuddy.matcher.ElementMatchers.none;
 import static org.hamcrest.CoreMatchers.*;
@@ -120,7 +120,7 @@ public void setUp() throws Exception {
     public void testSuccessfulWithoutExistingClass() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), null, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -132,8 +132,8 @@ public void testSuccessfulWithoutExistingClass() throws Exception {
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -148,7 +148,7 @@ public void testSuccessfulWithoutExistingClass() throws Exception {
                         REDEFINED.getProtectionDomain(),
                         accessControlContext));
         verifyNoMoreInteractions(dispatcher);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), null, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verify(transformer).transform(builder, new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
         verifyNoMoreInteractions(transformer);
@@ -158,7 +158,7 @@ public void testSuccessfulWithoutExistingClass() throws Exception {
     public void testSuccessfulWithoutExistingClassConjunction() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), null, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -170,8 +170,8 @@ public void testSuccessfulWithoutExistingClassConjunction() throws Exception {
                 .type(ElementMatchers.any()).and(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -192,7 +192,7 @@ public void testSuccessfulWithoutExistingClassConjunction() throws Exception {
     public void testSuccessfulWithoutExistingClassDisjunction() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), null, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -204,8 +204,8 @@ public void testSuccessfulWithoutExistingClassDisjunction() throws Exception {
                 .type(none()).or(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -225,7 +225,7 @@ public void testSuccessfulWithoutExistingClassDisjunction() throws Exception {
     @Test
     public void testSuccessfulWithExistingClass() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -237,8 +237,8 @@ public void testSuccessfulWithExistingClass() throws Exception {
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), REDEFINED, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -259,7 +259,7 @@ public void testSuccessfulWithExistingClass() throws Exception {
     public void testSkipRetransformationWithNonRedefinable() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(false);
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
@@ -272,8 +272,8 @@ public void testSkipRetransformationWithNonRedefinable() throws Exception {
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, true);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -288,7 +288,7 @@ public void testSkipRetransformationWithNonRedefinable() throws Exception {
     public void testSkipRetransformationWithNonMatched() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
@@ -302,15 +302,15 @@ public void testSkipRetransformationWithNonMatched() throws Exception {
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, true);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRetransformClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
@@ -319,11 +319,11 @@ public void testSkipRetransformationWithNonMatched() throws Exception {
     public void testSkipRetransformationWithNonMatchedListenerException() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
-        doThrow(new RuntimeException()).when(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
+        doThrow(new RuntimeException()).when(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
@@ -334,15 +334,15 @@ public void testSkipRetransformationWithNonMatchedListenerException() throws Exc
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, true);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRetransformClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
@@ -351,11 +351,11 @@ public void testSkipRetransformationWithNonMatchedListenerException() throws Exc
     public void testSkipRetransformationWithNonMatchedListenerCompleteException() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
-        doThrow(new RuntimeException()).when(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        doThrow(new RuntimeException()).when(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
@@ -366,22 +366,22 @@ public void testSkipRetransformationWithNonMatchedListenerCompleteException() th
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, true);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRetransformClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
 
     @Test
     public void testSuccessfulWithRetransformationMatched() throws Exception {
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain())).thenReturn(true);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
@@ -401,7 +401,7 @@ public void testSuccessfulWithRetransformationMatched() throws Exception {
         verify(instrumentation).retransformClasses(REDEFINED);
         verify(instrumentation).isRetransformClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
@@ -424,7 +424,7 @@ public void testRetransformationNotSupported() throws Exception {
     public void testSkipRedefinitionWithNonRedefinable() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(false);
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
@@ -438,8 +438,8 @@ public void testSkipRedefinitionWithNonRedefinable() throws Exception {
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -454,7 +454,7 @@ public void testSkipRedefinitionWithNonRedefinable() throws Exception {
     public void testSkipRedefinitionWithNonMatched() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
@@ -468,15 +468,15 @@ public void testSkipRedefinitionWithNonMatched() throws Exception {
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRedefineClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
@@ -501,8 +501,8 @@ public void testSkipRedefinitionWithIgnoredType() throws Exception {
                 .ignore(ignoredTypes)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -538,8 +538,8 @@ public void testSkipRedefinitionWithIgnoredClassLoader() throws Exception {
                 .ignore(ignoredTypes, ignoredClassLoaders)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -574,8 +574,8 @@ public void testSkipRedefinitionWithIgnoredTypeChainedConjunction() throws Excep
                 .ignore(ElementMatchers.any()).and(ignoredTypes)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -608,8 +608,8 @@ public void testSkipRedefinitionWithIgnoredTypeChainedDijunction() throws Except
                 .ignore(none()).or(ignoredTypes)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
@@ -626,11 +626,11 @@ public void testSkipRedefinitionWithIgnoredTypeChainedDijunction() throws Except
     public void testSkipRedefinitionWithNonMatchedListenerException() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
-        doThrow(new RuntimeException()).when(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
+        doThrow(new RuntimeException()).when(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
@@ -641,15 +641,15 @@ public void testSkipRedefinitionWithNonMatchedListenerException() throws Excepti
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRedefineClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
@@ -658,11 +658,11 @@ public void testSkipRedefinitionWithNonMatchedListenerException() throws Excepti
     public void testSkipRedefinitionWithNonMatchedListenerFinishedException() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
-        doThrow(new RuntimeException()).when(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        doThrow(new RuntimeException()).when(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
@@ -673,22 +673,22 @@ public void testSkipRedefinitionWithNonMatchedListenerFinishedException() throws
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verify(instrumentation).isModifiableClass(REDEFINED);
         verify(instrumentation).getAllLoadedClasses();
         verify(instrumentation).isRedefineClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(initializationStrategy);
     }
 
     @Test
     public void testSuccessfulWithRedefinitionMatched() throws Exception {
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
@@ -709,7 +709,7 @@ public void testSuccessfulWithRedefinitionMatched() throws Exception {
         verify(instrumentation).redefineClasses(any(ClassDefinition[].class));
         verify(instrumentation).isRedefineClassesSupported();
         verifyNoMoreInteractions(instrumentation);
-        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain());
+        verify(rawMatcher).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verifyZeroInteractions(dispatcher);
     }
@@ -733,7 +733,7 @@ public void testTransformationWithError() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         RuntimeException exception = mock(RuntimeException.class);
         when(resolution.resolve()).thenThrow(exception);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -746,8 +746,8 @@ public void testTransformationWithError() throws Exception {
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX),
                 nullValue(byte[].class));
-        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -758,7 +758,7 @@ public void testTransformationWithError() throws Exception {
     public void testIgnored() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(false);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -771,8 +771,8 @@ public void testIgnored() throws Exception {
                 .installOn(instrumentation);
         assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), REDEFINED, REDEFINED.getProtectionDomain(), QUX),
                 nullValue(byte[].class));
-        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onIgnored(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -794,7 +794,7 @@ public void testAuxiliaryTypeInitialization() throws Exception {
         when(dynamicType.getLoadedTypeInitializers()).thenReturn(loadedTypeInitializers);
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -805,9 +805,9 @@ public void testAuxiliaryTypeInitialization() throws Exception {
                 .with(accessControlContext)
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
-        assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), REDEFINED, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -830,7 +830,7 @@ public void testRedefinitionConsiderationException() throws Exception {
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
         when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED});
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenThrow(exception);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -843,8 +843,8 @@ public void testRedefinitionConsiderationException() throws Exception {
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         verify(instrumentation).addTransformer(classFileTransformer, false);
-        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
     }
 
@@ -854,7 +854,7 @@ public void testRetransformationConsiderationException() throws Exception {
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
         when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED});
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenThrow(exception);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -867,8 +867,8 @@ public void testRetransformationConsiderationException() throws Exception {
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         verify(instrumentation).addTransformer(classFileTransformer, true);
-        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
     }
 
@@ -878,9 +878,9 @@ public void testRedefinitionConsiderationExceptionListenerException() throws Exc
         when(instrumentation.isRedefineClassesSupported()).thenReturn(true);
         when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED});
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenThrow(exception);
-        doThrow(new RuntimeException()).when(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
+        doThrow(new RuntimeException()).when(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.REDEFINITION)
@@ -892,8 +892,8 @@ public void testRedefinitionConsiderationExceptionListenerException() throws Exc
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         verify(instrumentation).addTransformer(classFileTransformer, false);
-        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
     }
 
@@ -903,9 +903,9 @@ public void testRetransformationConsiderationExceptionListenerException() throws
         when(instrumentation.isRetransformClassesSupported()).thenReturn(true);
         when(instrumentation.getAllLoadedClasses()).thenReturn(new Class<?>[]{REDEFINED});
         when(instrumentation.isModifiableClass(REDEFINED)).thenReturn(true);
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), REDEFINED, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenThrow(exception);
-        doThrow(new RuntimeException()).when(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
+        doThrow(new RuntimeException()).when(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
                 .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)
@@ -917,8 +917,8 @@ public void testRetransformationConsiderationExceptionListenerException() throws
                 .type(rawMatcher).transform(transformer)
                 .installOn(instrumentation);
         verify(instrumentation).addTransformer(classFileTransformer, true);
-        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), exception);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        verify(listener).onError(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), exception);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
     }
 
@@ -926,7 +926,7 @@ public void testRetransformationConsiderationExceptionListenerException() throws
     public void testDecoratedTransformation() throws Exception {
         when(dynamicType.getBytes()).thenReturn(BAZ);
         when(resolution.resolve()).thenReturn(new TypeDescription.ForLoadedType(REDEFINED));
-        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain()))
+        when(rawMatcher.matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain()))
                 .thenReturn(true);
         ClassFileTransformer classFileTransformer = new AgentBuilder.Default(byteBuddy)
                 .with(initializationStrategy)
@@ -938,9 +938,9 @@ public void testDecoratedTransformation() throws Exception {
                 .type(rawMatcher).transform(transformer)
                 .type(rawMatcher).transform(transformer).asDecorator()
                 .installOn(instrumentation);
-        assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), null, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
-        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), dynamicType);
-        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader());
+        assertThat(classFileTransformer.transform(REDEFINED.getClassLoader(), REDEFINED.getName(), REDEFINED, REDEFINED.getProtectionDomain(), QUX), is(BAZ));
+        verify(listener).onTransformation(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), dynamicType);
+        verify(listener).onComplete(REDEFINED.getName(), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED));
         verifyNoMoreInteractions(listener);
         verify(instrumentation).addTransformer(classFileTransformer, false);
         verifyNoMoreInteractions(instrumentation);
@@ -955,7 +955,7 @@ public void testDecoratedTransformation() throws Exception {
                         REDEFINED.getProtectionDomain(),
                         accessControlContext));
         verifyNoMoreInteractions(dispatcher);
-        verify(rawMatcher, times(2)).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), null, REDEFINED.getProtectionDomain());
+        verify(rawMatcher, times(2)).matches(new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader(), JavaModule.ofType(REDEFINED), REDEFINED, REDEFINED.getProtectionDomain());
         verifyNoMoreInteractions(rawMatcher);
         verify(transformer, times(2)).transform(builder, new TypeDescription.ForLoadedType(REDEFINED), REDEFINED.getClassLoader());
         verifyNoMoreInteractions(transformer);
@@ -1057,6 +1057,14 @@ public AccessControlContext create() {
                         return new AccessControlContext(new ProtectionDomain[]{mock(ProtectionDomain.class)});
                     }
                 }).apply();
+        final Iterator<Constructor<?>> iterator = Arrays.asList(String.class.getDeclaredConstructors()).iterator();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.Factory.ForJava9CapableVm.class).create(new ObjectPropertyAssertion.Creator<Constructor<?>>() {
+            @Override
+            public Constructor<?> create() {
+                return iterator.next();
+            }
+        }).apply();
+        ObjectPropertyAssertion.of(AgentBuilder.Default.ExecutingTransformer.Factory.ForLegacyVm.class).apply();
     }
 
     public static class Foo {
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderListenerTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderListenerTest.java
index f48c1fc455..3fb67d96c8 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderListenerTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderListenerTest.java
@@ -4,6 +4,7 @@
 import net.bytebuddy.dynamic.DynamicType;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.JavaModule;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -30,13 +31,16 @@
     private AgentBuilder.Listener first, second;
 
     @Mock
-    private DynamicType dynamicType;
+    private TypeDescription typeDescription;
 
     @Mock
     private ClassLoader classLoader;
 
     @Mock
-    private TypeDescription typeDescription;
+    private JavaModule module;
+
+    @Mock
+    private DynamicType dynamicType;
 
     @Mock
     private Throwable throwable;
@@ -48,58 +52,58 @@ public void setUp() throws Exception {
 
     @Test
     public void testNoOp() throws Exception {
-        AgentBuilder.Listener.NoOp.INSTANCE.onTransformation(typeDescription, classLoader, dynamicType);
+        AgentBuilder.Listener.NoOp.INSTANCE.onTransformation(typeDescription, classLoader, module, dynamicType);
         verifyZeroInteractions(dynamicType);
-        AgentBuilder.Listener.NoOp.INSTANCE.onError(FOO, classLoader, throwable);
+        AgentBuilder.Listener.NoOp.INSTANCE.onError(FOO, classLoader, module, throwable);
         verifyZeroInteractions(throwable);
-        AgentBuilder.Listener.NoOp.INSTANCE.onIgnored(typeDescription, classLoader);
-        AgentBuilder.Listener.NoOp.INSTANCE.onComplete(FOO, classLoader);
+        AgentBuilder.Listener.NoOp.INSTANCE.onIgnored(typeDescription, classLoader, module);
+        AgentBuilder.Listener.NoOp.INSTANCE.onComplete(FOO, classLoader, module);
     }
 
     @Test
     public void testPseudoAdapter() throws Exception {
         AgentBuilder.Listener listener = new PseudoAdapter();
-        listener.onTransformation(typeDescription, classLoader, dynamicType);
+        listener.onTransformation(typeDescription, classLoader, module, dynamicType);
         verifyZeroInteractions(dynamicType);
-        listener.onError(FOO, classLoader, throwable);
+        listener.onError(FOO, classLoader, module, throwable);
         verifyZeroInteractions(throwable);
-        listener.onIgnored(typeDescription, classLoader);
-        listener.onComplete(FOO, classLoader);
+        listener.onIgnored(typeDescription, classLoader, module);
+        listener.onComplete(FOO, classLoader, module);
     }
 
     @Test
     public void testCompoundOnTransformation() throws Exception {
-        new AgentBuilder.Listener.Compound(first, second).onTransformation(typeDescription, classLoader, dynamicType);
-        verify(first).onTransformation(typeDescription, classLoader, dynamicType);
+        new AgentBuilder.Listener.Compound(first, second).onTransformation(typeDescription, classLoader, module, dynamicType);
+        verify(first).onTransformation(typeDescription, classLoader, module, dynamicType);
         verifyNoMoreInteractions(first);
-        verify(second).onTransformation(typeDescription, classLoader, dynamicType);
+        verify(second).onTransformation(typeDescription, classLoader, module, dynamicType);
         verifyNoMoreInteractions(second);
     }
 
     @Test
     public void testCompoundOnError() throws Exception {
-        new AgentBuilder.Listener.Compound(first, second).onError(FOO, classLoader, throwable);
-        verify(first).onError(FOO, classLoader, throwable);
+        new AgentBuilder.Listener.Compound(first, second).onError(FOO, classLoader, module, throwable);
+        verify(first).onError(FOO, classLoader, module, throwable);
         verifyNoMoreInteractions(first);
-        verify(second).onError(FOO, classLoader, throwable);
+        verify(second).onError(FOO, classLoader, module, throwable);
         verifyNoMoreInteractions(second);
     }
 
     @Test
     public void testCompoundOnIgnored() throws Exception {
-        new AgentBuilder.Listener.Compound(first, second).onIgnored(typeDescription, classLoader);
-        verify(first).onIgnored(typeDescription, classLoader);
+        new AgentBuilder.Listener.Compound(first, second).onIgnored(typeDescription, classLoader, module);
+        verify(first).onIgnored(typeDescription, classLoader, module);
         verifyNoMoreInteractions(first);
-        verify(second).onIgnored(typeDescription, classLoader);
+        verify(second).onIgnored(typeDescription, classLoader, module);
         verifyNoMoreInteractions(second);
     }
 
     @Test
     public void testCompoundOnComplete() throws Exception {
-        new AgentBuilder.Listener.Compound(first, second).onComplete(FOO, classLoader);
-        verify(first).onComplete(FOO, classLoader);
+        new AgentBuilder.Listener.Compound(first, second).onComplete(FOO, classLoader, module);
+        verify(first).onComplete(FOO, classLoader, module);
         verifyNoMoreInteractions(first);
-        verify(second).onComplete(FOO, classLoader);
+        verify(second).onComplete(FOO, classLoader, module);
         verifyNoMoreInteractions(second);
     }
 
@@ -107,8 +111,8 @@ public void testCompoundOnComplete() throws Exception {
     public void testStreamWritingOnTransformation() throws Exception {
         PrintStream printStream = mock(PrintStream.class);
         AgentBuilder.Listener listener = new AgentBuilder.Listener.StreamWriting(printStream);
-        listener.onTransformation(typeDescription, classLoader, dynamicType);
-        verify(printStream).println("[Byte Buddy] TRANSFORM " + FOO);
+        listener.onTransformation(typeDescription, classLoader, module, dynamicType);
+        verify(printStream).println("[Byte Buddy] TRANSFORM " + FOO + "[" + classLoader + ", " + module + "]");
         verifyNoMoreInteractions(printStream);
     }
 
@@ -116,8 +120,8 @@ public void testStreamWritingOnTransformation() throws Exception {
     public void testStreamWritingOnError() throws Exception {
         PrintStream printStream = mock(PrintStream.class);
         AgentBuilder.Listener listener = new AgentBuilder.Listener.StreamWriting(printStream);
-        listener.onError(FOO, classLoader, throwable);
-        verify(printStream).println("[Byte Buddy] ERROR " + FOO);
+        listener.onError(FOO, classLoader, module, throwable);
+        verify(printStream).println("[Byte Buddy] ERROR " + FOO + "[" + classLoader + ", " + module + "]");
         verifyNoMoreInteractions(printStream);
         verify(throwable).printStackTrace(printStream);
         verifyNoMoreInteractions(throwable);
@@ -127,8 +131,8 @@ public void testStreamWritingOnError() throws Exception {
     public void testStreamWritingOnComplete() throws Exception {
         PrintStream printStream = mock(PrintStream.class);
         AgentBuilder.Listener listener = new AgentBuilder.Listener.StreamWriting(printStream);
-        listener.onComplete(FOO, classLoader);
-        verify(printStream).println("[Byte Buddy] COMPLETE " + FOO);
+        listener.onComplete(FOO, classLoader, module);
+        verify(printStream).println("[Byte Buddy] COMPLETE " + FOO + "[" + classLoader + ", " + module + "]");
         verifyNoMoreInteractions(printStream);
     }
 
@@ -136,8 +140,8 @@ public void testStreamWritingOnComplete() throws Exception {
     public void testStreamWritingOnIgnore() throws Exception {
         PrintStream printStream = mock(PrintStream.class);
         AgentBuilder.Listener listener = new AgentBuilder.Listener.StreamWriting(printStream);
-        listener.onIgnored(typeDescription, classLoader);
-        verify(printStream).println("[Byte Buddy] IGNORE " + FOO);
+        listener.onIgnored(typeDescription, classLoader, module);
+        verify(printStream).println("[Byte Buddy] IGNORE " + FOO + "[" + classLoader + ", " + module + "]");
         verifyNoMoreInteractions(printStream);
     }
 
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherConjunctionTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherConjunctionTest.java
index ca57c86fdc..9297ab048a 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherConjunctionTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherConjunctionTest.java
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.JavaModule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -28,51 +29,54 @@
     @Mock
     private ClassLoader classLoader;
 
+    @Mock
+    private JavaModule module;
+
     @Mock
     private ProtectionDomain protectionDomain;
 
     @Test
     public void testMatches() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Conjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(true));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(true));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
-        verify(right).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        verify(right).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(right);
     }
 
     @Test
     public void testNotMatchesLeft() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Conjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(false));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(false));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
-        verify(right).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        verify(right).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(right);
     }
 
     @Test
     public void testNotMatchesRight() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Conjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(false));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(false));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
         verifyZeroInteractions(right);
     }
 
     @Test
     public void testNotMatchesEither() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Conjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(false));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(false));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
         verifyZeroInteractions(right);
     }
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherDisjunctionTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherDisjunctionTest.java
index 882a295cd8..4115eb9fe5 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherDisjunctionTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherDisjunctionTest.java
@@ -3,6 +3,7 @@
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.MockitoRule;
 import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.JavaModule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -28,52 +29,55 @@
     @Mock
     private ClassLoader classLoader;
 
+    @Mock
+    private JavaModule module;
+
     @Mock
     private ProtectionDomain protectionDomain;
 
     @Test
     public void testMatches() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Disjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(true));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(true));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
         verifyZeroInteractions(right);
     }
 
     @Test
     public void testNotMatchesLeft() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Disjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(true));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(true));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
         verifyZeroInteractions(right);
     }
 
     @Test
     public void testNotMatchesRight() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(true);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(true);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Disjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(true));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(true));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
-        verify(right).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        verify(right).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(right);
     }
 
     @Test
     public void testNotMatchesEither() throws Exception {
-        when(left.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
-        when(right.matches(typeDescription, classLoader, Foo.class, protectionDomain)).thenReturn(false);
+        when(left.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
+        when(right.matches(typeDescription, classLoader, module, Foo.class, protectionDomain)).thenReturn(false);
         AgentBuilder.RawMatcher rawMatcher = new AgentBuilder.RawMatcher.Disjunction(left, right);
-        assertThat(rawMatcher.matches(typeDescription, classLoader, Foo.class, protectionDomain), is(false));
-        verify(left).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        assertThat(rawMatcher.matches(typeDescription, classLoader, module, Foo.class, protectionDomain), is(false));
+        verify(left).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(left);
-        verify(right).matches(typeDescription, classLoader, Foo.class, protectionDomain);
+        verify(right).matches(typeDescription, classLoader, module, Foo.class, protectionDomain);
         verifyNoMoreInteractions(right);
     }
 
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherForElementMatchersTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherForElementMatchersTest.java
new file mode 100755
index 0000000000..735531841f
--- /dev/null
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/agent/builder/AgentBuilderRawMatcherForElementMatchersTest.java
@@ -0,0 +1,145 @@
+package net.bytebuddy.agent.builder;
+
+import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.matcher.ElementMatcher;
+import net.bytebuddy.test.utility.MockitoRule;
+import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import net.bytebuddy.utility.JavaModule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestRule;
+import org.mockito.Mock;
+
+import java.security.ProtectionDomain;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Mockito.*;
+
+public class AgentBuilderRawMatcherForElementMatchersTest {
+
+    @Rule
+    public TestRule mockitoRule = new MockitoRule(this);
+
+    @Mock
+    private ElementMatcher<TypeDescription> typeMatcher;
+
+    @Mock
+    private ElementMatcher<ClassLoader> classLoaderMatcher;
+
+    @Mock
+    private ElementMatcher<JavaModule> moduleMatcher;
+
+    @Mock
+    private TypeDescription typeDescription;
+
+    @Mock
+    private ClassLoader classLoader;
+
+    @Mock
+    private JavaModule module;
+
+    @Mock
+    private ProtectionDomain protectionDomain;
+
+    @Test
+    public void testNoneMatches() throws Exception {
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verifyNoMoreInteractions(classLoaderMatcher);
+        verifyZeroInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testModuleMatches() throws Exception {
+        when(moduleMatcher.matches(module)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verify(classLoaderMatcher).matches(classLoader);
+        verifyNoMoreInteractions(classLoaderMatcher);
+        verifyZeroInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testClassLoaderMatches() throws Exception {
+        when(classLoaderMatcher.matches(classLoader)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verifyZeroInteractions(classLoaderMatcher);
+        verifyNoMoreInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testModuleAndClassLoaderMatches() throws Exception {
+        when(moduleMatcher.matches(module)).thenReturn(true);
+        when(classLoaderMatcher.matches(classLoader)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verify(classLoaderMatcher).matches(classLoader);
+        verifyNoMoreInteractions(classLoaderMatcher);
+        verify(typeMatcher).matches(typeDescription);
+        verifyNoMoreInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testModuleAndTypeMatches() throws Exception {
+        when(moduleMatcher.matches(module)).thenReturn(true);
+        when(typeMatcher.matches(typeDescription)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verify(classLoaderMatcher).matches(classLoader);
+        verifyNoMoreInteractions(classLoaderMatcher);
+        verifyZeroInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testClassLoaderAndTypeMatches() throws Exception {
+        when(classLoaderMatcher.matches(classLoader)).thenReturn(true);
+        when(typeMatcher.matches(typeDescription)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verifyZeroInteractions(classLoaderMatcher);
+        verifyZeroInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testTypeMatches() throws Exception {
+        when(typeMatcher.matches(typeDescription)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(false));
+        verify(moduleMatcher).matches(module);
+        verifyNoMoreInteractions(moduleMatcher);
+        verifyZeroInteractions(classLoaderMatcher);
+        verifyZeroInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testAllMatches() throws Exception {
+        when(moduleMatcher.matches(module)).thenReturn(true);
+        when(classLoaderMatcher.matches(classLoader)).thenReturn(true);
+        when(typeMatcher.matches(typeDescription)).thenReturn(true);
+        assertThat(new AgentBuilder.RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher)
+                .matches(typeDescription, classLoader, module, Object.class, protectionDomain), is(true));
+        verify(classLoaderMatcher).matches(classLoader);
+        verifyNoMoreInteractions(classLoaderMatcher);
+        verify(typeMatcher).matches(typeDescription);
+        verifyNoMoreInteractions(typeMatcher);
+    }
+
+    @Test
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(AgentBuilder.RawMatcher.ForElementMatchers.class).apply();
+    }
+}
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
index 36fbda14a2..9ec9b1fe87 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionGenericTest.java
@@ -92,7 +92,7 @@ public void testNonGenericTypeNoSymbol() throws Exception {
     public void testSimpleParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(SimpleParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(typeDescription.getSourceCodeName(), is(SimpleParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(SimpleParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(SimpleParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(SimpleParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -146,7 +146,7 @@ public void testParameterizedTypeNoLowerBounds() throws Exception {
     public void testUpperBoundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(UpperBoundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(typeDescription.getSourceCodeName(), is(UpperBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(UpperBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(UpperBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(UpperBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -225,7 +225,7 @@ public void testUpperBoundsWildcardParameterizedTypeNoIterator() throws Exceptio
     public void testLowerBoundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(typeDescription.getSourceCodeName(), is(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(LowerBoundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -305,7 +305,7 @@ public void testLowerBoundWildcardParameterizedTypeNoIterator() throws Exception
     public void testUnboundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(UnboundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(typeDescription.getSourceCodeName(), is(UnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(UnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(UnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(UnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -384,7 +384,7 @@ public void testUnboundBoundWildcardParameterizedTypeNoIterator() throws Excepti
     public void testExplicitlyUnboundWildcardParameterizedType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(ExplicitlyUnboundWildcardParameterizedType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.PARAMETERIZED));
-        assertThat(typeDescription.getSourceCodeName(),
+        assertThat(typeDescription.getActualName(),
                 is(ExplicitlyUnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(),
                 is(ExplicitlyUnboundWildcardParameterizedType.class.getDeclaredField(FOO).getGenericType().toString()));
@@ -482,7 +482,7 @@ public void testGenericArrayType() throws Exception {
         assertThat(typeDescription.getDeclaredMethods().size(), is(0));
         assertThat(typeDescription.getSuperClass(), is(TypeDescription.Generic.OBJECT));
         assertThat(typeDescription.getInterfaces(), is(TypeDescription.ARRAY_INTERFACES));
-        assertThat(typeDescription.getSourceCodeName(), is(SimpleGenericArrayType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(SimpleGenericArrayType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(SimpleGenericArrayType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(SimpleGenericArrayType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -544,7 +544,7 @@ public void testGenericArrayOfGenericComponentType() throws Exception {
         assertThat(typeDescription.getOwnerType(), nullValue(TypeDescription.Generic.class));
         assertThat(typeDescription.getSuperClass(), is(TypeDescription.Generic.OBJECT));
         assertThat(typeDescription.getInterfaces(), is(TypeDescription.ARRAY_INTERFACES));
-        assertThat(typeDescription.getSourceCodeName(), is(GenericArrayOfGenericComponentType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(GenericArrayOfGenericComponentType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(GenericArrayOfGenericComponentType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(GenericArrayOfGenericComponentType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
@@ -595,7 +595,7 @@ public void testGenericArrayOfGenericComponentTypeNoLowerBounds() throws Excepti
     public void testTypeVariableType() throws Exception {
         TypeDescription.Generic typeDescription = describeType(SimpleTypeVariableType.class.getDeclaredField(FOO));
         assertThat(typeDescription.getSort(), is(TypeDefinition.Sort.VARIABLE));
-        assertThat(typeDescription.getSourceCodeName(), is(SimpleTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
+        assertThat(typeDescription.getActualName(), is(SimpleTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.getTypeName(), is(SimpleTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.toString(), is(SimpleTypeVariableType.class.getDeclaredField(FOO).getGenericType().toString()));
         assertThat(typeDescription.hashCode(),
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
index ec6d5d84d8..c91c02b878 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/description/type/AbstractTypeDescriptionTest.java
@@ -103,9 +103,9 @@ public void testName() throws Exception {
     public void testSourceName() throws Exception {
         for (Class<?> type : standardTypes) {
             if (type.isArray()) {
-                assertThat(describe(type).getSourceCodeName(), is(type.getComponentType().getName() + "[]"));
+                assertThat(describe(type).getActualName(), is(type.getComponentType().getName() + "[]"));
             } else {
-                assertThat(describe(type).getSourceCodeName(), is(type.getName()));
+                assertThat(describe(type).getActualName(), is(type.getName()));
             }
         }
     }
@@ -154,28 +154,28 @@ public void testIsLocalClass() throws Exception {
 
     @Test
     public void testJavaName() throws Exception {
-        assertThat(describe(Object.class).getSourceCodeName(), is(Object.class.getName()));
-        assertThat(describe(SampleClass.class).getSourceCodeName(), is(SampleClass.class.getName()));
-        assertThat(describe(void.class).getSourceCodeName(), is(void.class.getName()));
-        assertThat(describe(boolean.class).getSourceCodeName(), is(boolean.class.getName()));
-        assertThat(describe(byte.class).getSourceCodeName(), is(byte.class.getName()));
-        assertThat(describe(short.class).getSourceCodeName(), is(short.class.getName()));
-        assertThat(describe(char.class).getSourceCodeName(), is(char.class.getName()));
-        assertThat(describe(int.class).getSourceCodeName(), is(int.class.getName()));
-        assertThat(describe(long.class).getSourceCodeName(), is(long.class.getName()));
-        assertThat(describe(float.class).getSourceCodeName(), is(float.class.getName()));
-        assertThat(describe(double.class).getSourceCodeName(), is(double.class.getName()));
-        assertThat(describe(Object[].class).getSourceCodeName(), is(Object.class.getName() + "[]"));
-        assertThat(describe(SampleClass[].class).getSourceCodeName(), is(SampleClass.class.getName() + "[]"));
-        assertThat(describe(Object[][].class).getSourceCodeName(), is(Object.class.getName() + "[][]"));
-        assertThat(describe(boolean[].class).getSourceCodeName(), is(boolean.class.getName() + "[]"));
-        assertThat(describe(byte[].class).getSourceCodeName(), is(byte.class.getName() + "[]"));
-        assertThat(describe(short[].class).getSourceCodeName(), is(short.class.getName() + "[]"));
-        assertThat(describe(char[].class).getSourceCodeName(), is(char.class.getName() + "[]"));
-        assertThat(describe(int[].class).getSourceCodeName(), is(int.class.getName() + "[]"));
-        assertThat(describe(long[].class).getSourceCodeName(), is(long.class.getName() + "[]"));
-        assertThat(describe(float[].class).getSourceCodeName(), is(float.class.getName() + "[]"));
-        assertThat(describe(double[].class).getSourceCodeName(), is(double.class.getName() + "[]"));
+        assertThat(describe(Object.class).getActualName(), is(Object.class.getName()));
+        assertThat(describe(SampleClass.class).getActualName(), is(SampleClass.class.getName()));
+        assertThat(describe(void.class).getActualName(), is(void.class.getName()));
+        assertThat(describe(boolean.class).getActualName(), is(boolean.class.getName()));
+        assertThat(describe(byte.class).getActualName(), is(byte.class.getName()));
+        assertThat(describe(short.class).getActualName(), is(short.class.getName()));
+        assertThat(describe(char.class).getActualName(), is(char.class.getName()));
+        assertThat(describe(int.class).getActualName(), is(int.class.getName()));
+        assertThat(describe(long.class).getActualName(), is(long.class.getName()));
+        assertThat(describe(float.class).getActualName(), is(float.class.getName()));
+        assertThat(describe(double.class).getActualName(), is(double.class.getName()));
+        assertThat(describe(Object[].class).getActualName(), is(Object.class.getName() + "[]"));
+        assertThat(describe(SampleClass[].class).getActualName(), is(SampleClass.class.getName() + "[]"));
+        assertThat(describe(Object[][].class).getActualName(), is(Object.class.getName() + "[][]"));
+        assertThat(describe(boolean[].class).getActualName(), is(boolean.class.getName() + "[]"));
+        assertThat(describe(byte[].class).getActualName(), is(byte.class.getName() + "[]"));
+        assertThat(describe(short[].class).getActualName(), is(short.class.getName() + "[]"));
+        assertThat(describe(char[].class).getActualName(), is(char.class.getName() + "[]"));
+        assertThat(describe(int[].class).getActualName(), is(int.class.getName() + "[]"));
+        assertThat(describe(long[].class).getActualName(), is(long.class.getName() + "[]"));
+        assertThat(describe(float[].class).getActualName(), is(float.class.getName() + "[]"));
+        assertThat(describe(double[].class).getActualName(), is(double.class.getName() + "[]"));
     }
 
     @Test
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyObjectPropertiesTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyObjectPropertiesTest.java
index 19779b444a..d4614e3209 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyObjectPropertiesTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/auxiliary/TypeProxyObjectPropertiesTest.java
@@ -7,8 +7,6 @@
 import org.junit.Test;
 import org.mockito.Mockito;
 
-import java.util.Collections;
-
 import static org.mockito.Mockito.when;
 
 public class TypeProxyObjectPropertiesTest {
@@ -24,7 +22,7 @@ public void testObjectProperties() throws Exception {
             @Override
             public void apply(TypeDescription mock) {
                 FieldDescription.InDefinedShape fieldDescription = Mockito.mock(FieldDescription.InDefinedShape.class);
-                when(fieldDescription.getSourceCodeName()).thenReturn(TypeProxy.INSTANCE_FIELD);
+                when(fieldDescription.getActualName()).thenReturn(TypeProxy.INSTANCE_FIELD);
                 when(mock.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
             }
         }).skipSynthetic().apply();
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
index 8b4d663d5f..c429fc08d5 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldProxyBinderTest.java
@@ -97,11 +97,11 @@ public void testGetterForImplicitNamedFieldInHierarchy() throws Exception {
         when(target.getType()).thenReturn(genericGetterType);
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FieldProxy.Binder.BEAN_PROPERTY);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(genericFieldType);
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(source.getName()).thenReturn("getFoo");
-        when(source.getSourceCodeName()).thenReturn("getFoo");
+        when(source.getActualName()).thenReturn("getFoo");
         when(source.getInternalName()).thenReturn("getFoo");
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> binding = new FieldProxy.Binder(getterMethod, setterMethod).bind(annotationDescription,
@@ -117,7 +117,7 @@ public void testGetterForExplicitNamedFieldInHierarchy() throws Exception {
         when(target.getType()).thenReturn(genericGetterType);
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(genericFieldType);
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(source.getName()).thenReturn("getFoo");
@@ -141,7 +141,7 @@ public void testGetterForImplicitNamedFieldInNamedType() throws Exception {
         when(source.getReturnType()).thenReturn(genericFieldType);
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         when(source.getName()).thenReturn("getFoo");
-        when(source.getSourceCodeName()).thenReturn("getFoo");
+        when(source.getActualName()).thenReturn("getFoo");
         when(source.getInternalName()).thenReturn("getFoo");
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> binding = new FieldProxy.Binder(getterMethod, setterMethod).bind(annotationDescription,
@@ -177,10 +177,10 @@ public void testSetterForImplicitNamedFieldInHierarchy() throws Exception {
         when(target.getType()).thenReturn(genericSetterType);
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FieldProxy.Binder.BEAN_PROPERTY);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, fieldType));
-        when(source.getSourceCodeName()).thenReturn("setFoo");
+        when(source.getActualName()).thenReturn("setFoo");
         when(source.getInternalName()).thenReturn("setFoo");
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> binding = new FieldProxy.Binder(getterMethod, setterMethod).bind(annotationDescription,
@@ -196,7 +196,7 @@ public void testSetterForExplicitNamedFieldInHierarchy() throws Exception {
         when(target.getType()).thenReturn(genericSetterType);
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, fieldType));
         when(source.getName()).thenReturn("setFoo");
@@ -216,11 +216,11 @@ public void testSetterForImplicitNamedFieldInNamedType() throws Exception {
         doReturn(Foo.class).when(annotation).declaringType();
         when(instrumentedType.isAssignableTo(new TypeDescription.ForLoadedType(Foo.class))).thenReturn(true);
         when(annotation.value()).thenReturn(FieldProxy.Binder.BEAN_PROPERTY);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, fieldType));
         when(source.getName()).thenReturn("setFoo");
-        when(source.getSourceCodeName()).thenReturn("setFoo");
+        when(source.getActualName()).thenReturn("setFoo");
         when(source.getInternalName()).thenReturn("setFoo");
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         MethodDelegationBinder.ParameterBinding<?> binding = new FieldProxy.Binder(getterMethod, setterMethod).bind(annotationDescription,
@@ -237,7 +237,7 @@ public void testSetterForExplicitNamedFieldInNamedType() throws Exception {
         doReturn(Foo.class).when(annotation).declaringType();
         when(instrumentedType.isAssignableTo(new TypeDescription.ForLoadedType(Foo.class))).thenReturn(true);
         when(annotation.value()).thenReturn(FOO);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, fieldType));
         when(source.getName()).thenReturn("setFoo");
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
index 8a9f7b8615..817b59484f 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bind/annotation/FieldValueBinderTest.java
@@ -66,7 +66,7 @@ public void testLegalAssignment() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
@@ -83,7 +83,7 @@ public void testIllegalAssignmentNonAssignable() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(false);
@@ -100,7 +100,7 @@ public void testIllegalAssignmentStaticMethod() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
@@ -118,7 +118,7 @@ public void testLegalAssignmentStaticMethodStaticField() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
@@ -151,7 +151,7 @@ public void testIllegalAssignmentNonVisible() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FOO);
         when(instrumentedType.getDeclaredFields()).thenReturn((FieldList) new FieldList.Explicit<FieldDescription>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(false);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
@@ -260,12 +260,12 @@ public void testGetterNameDiscovery() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FieldValue.Binder.Delegate.BEAN_PROPERTY);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
         when(source.getInternalName()).thenReturn("getFoo");
-        when(source.getSourceCodeName()).thenReturn("getFoo");
+        when(source.getActualName()).thenReturn("getFoo");
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.OBJECT);
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> binding = FieldValue.Binder.INSTANCE.bind(annotationDescription,
@@ -281,12 +281,12 @@ public void testGetterNameDiscoveryBoolean() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FieldValue.Binder.Delegate.BEAN_PROPERTY);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
         when(source.getInternalName()).thenReturn("isFoo");
-        when(source.getSourceCodeName()).thenReturn("isFoo");
+        when(source.getActualName()).thenReturn("isFoo");
         when(source.getReturnType()).thenReturn(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(boolean.class));
         when(source.getParameters()).thenReturn(new ParameterList.Empty<ParameterDescription.InDefinedShape>());
         MethodDelegationBinder.ParameterBinding<?> binding = FieldValue.Binder.INSTANCE.bind(annotationDescription,
@@ -302,12 +302,12 @@ public void testSetterNameDiscovery() throws Exception {
         doReturn(void.class).when(annotation).declaringType();
         when(annotation.value()).thenReturn(FieldValue.Binder.Delegate.BEAN_PROPERTY);
         when(instrumentedType.getDeclaredFields()).thenReturn(new FieldList.Explicit<FieldDescription.InDefinedShape>(fieldDescription));
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         when(fieldDescription.isVisibleTo(instrumentedType)).thenReturn(true);
         when(target.getDeclaredAnnotations()).thenReturn(new AnnotationList.Empty());
         when(stackManipulation.isValid()).thenReturn(true);
         when(source.getInternalName()).thenReturn("setFoo");
-        when(source.getSourceCodeName()).thenReturn("setFoo");
+        when(source.getActualName()).thenReturn("setFoo");
         when(source.getReturnType()).thenReturn(TypeDescription.Generic.VOID);
         when(source.getParameters()).thenReturn(new ParameterList.Explicit.ForTypes(source, TypeDescription.Generic.OBJECT));
         MethodDelegationBinder.ParameterBinding<?> binding = FieldValue.Binder.INSTANCE.bind(annotationDescription,
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
index 649ce90e66..c6a5e4ed00 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/implementation/bytecode/member/FieldAccessOtherTest.java
@@ -56,7 +56,7 @@ public void testEnumerationDescription() throws Exception {
         when(fieldDescription.isPublic()).thenReturn(true);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldDescription.isEnum()).thenReturn(true);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         StackManipulation stackManipulation = FieldAccess.forEnumeration(enumerationDescription);
         assertThat(stackManipulation.isValid(), is(true));
     }
@@ -66,7 +66,7 @@ public void testEnumerationDescriptionWithIllegalName() throws Exception {
         when(fieldDescription.isPublic()).thenReturn(true);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldDescription.isEnum()).thenReturn(true);
-        when(fieldDescription.getSourceCodeName()).thenReturn(BAR);
+        when(fieldDescription.getActualName()).thenReturn(BAR);
         StackManipulation stackManipulation = FieldAccess.forEnumeration(enumerationDescription);
         assertThat(stackManipulation.isValid(), is(false));
     }
@@ -76,7 +76,7 @@ public void testEnumerationDescriptionWithIllegalOwnership() throws Exception {
         when(fieldDescription.isPublic()).thenReturn(true);
         when(fieldDescription.isStatic()).thenReturn(false);
         when(fieldDescription.isEnum()).thenReturn(true);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         StackManipulation stackManipulation = FieldAccess.forEnumeration(enumerationDescription);
         assertThat(stackManipulation.isValid(), is(false));
     }
@@ -86,7 +86,7 @@ public void testEnumerationDescriptionWithIllegalVisibility() throws Exception {
         when(fieldDescription.isPublic()).thenReturn(false);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldDescription.isEnum()).thenReturn(true);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         StackManipulation stackManipulation = FieldAccess.forEnumeration(enumerationDescription);
         assertThat(stackManipulation.isValid(), is(false));
     }
@@ -96,7 +96,7 @@ public void testEnumerationDescriptionNonEnumeration() throws Exception {
         when(fieldDescription.isPublic()).thenReturn(true);
         when(fieldDescription.isStatic()).thenReturn(true);
         when(fieldDescription.isEnum()).thenReturn(false);
-        when(fieldDescription.getSourceCodeName()).thenReturn(FOO);
+        when(fieldDescription.getActualName()).thenReturn(FOO);
         StackManipulation stackManipulation = FieldAccess.forEnumeration(enumerationDescription);
         assertThat(stackManipulation.isValid(), is(false));
     }
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
index 9bf1f45ac1..5aad312e4f 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/ElementMatchersTest.java
@@ -2,6 +2,7 @@
 
 import net.bytebuddy.description.ByteCodeElement;
 import net.bytebuddy.description.ModifierReviewable;
+import net.bytebuddy.description.NamedElement;
 import net.bytebuddy.description.annotation.AnnotationDescription;
 import net.bytebuddy.description.field.FieldDescription;
 import net.bytebuddy.description.method.MethodDescription;
@@ -9,6 +10,7 @@
 import net.bytebuddy.description.type.TypeDefinition;
 import net.bytebuddy.description.type.TypeDescription;
 import net.bytebuddy.test.utility.JavaVersionRule;
+import net.bytebuddy.utility.JavaModule;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
@@ -388,7 +390,7 @@ public void testMethodName() throws Exception {
     @Test
     public void testNamed() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(named(FOO).matches(byteCodeElement), is(true));
         assertThat(named(FOO.toUpperCase()).matches(byteCodeElement), is(false));
         assertThat(named(BAR).matches(byteCodeElement), is(false));
@@ -397,7 +399,7 @@ public void testNamed() throws Exception {
     @Test
     public void testNamedIgnoreCase() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.namedIgnoreCase(FOO).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.namedIgnoreCase(FOO.toUpperCase()).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.namedIgnoreCase(BAR).matches(byteCodeElement), is(false));
@@ -406,7 +408,7 @@ public void testNamedIgnoreCase() throws Exception {
     @Test
     public void testNameStartsWith() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameStartsWith(FOO.substring(0, 2)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameStartsWith(FOO.substring(0, 2).toUpperCase()).matches(byteCodeElement), is(false));
         assertThat(ElementMatchers.nameStartsWith(BAR).matches(byteCodeElement), is(false));
@@ -415,7 +417,7 @@ public void testNameStartsWith() throws Exception {
     @Test
     public void testNameStartsWithIgnoreCase() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameStartsWithIgnoreCase(FOO.substring(0, 2)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameStartsWithIgnoreCase(FOO.substring(0, 2).toUpperCase()).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameStartsWithIgnoreCase(BAR).matches(byteCodeElement), is(false));
@@ -424,7 +426,7 @@ public void testNameStartsWithIgnoreCase() throws Exception {
     @Test
     public void testNameEndsWith() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameEndsWith(FOO.substring(1)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameEndsWith(FOO.substring(1).toUpperCase()).matches(byteCodeElement), is(false));
         assertThat(ElementMatchers.nameEndsWith(BAR).matches(byteCodeElement), is(false));
@@ -433,7 +435,7 @@ public void testNameEndsWith() throws Exception {
     @Test
     public void testNameEndsWithIgnoreCase() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameEndsWithIgnoreCase(FOO.substring(1)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameEndsWithIgnoreCase(FOO.substring(1).toUpperCase()).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameEndsWithIgnoreCase(BAR).matches(byteCodeElement), is(false));
@@ -442,7 +444,7 @@ public void testNameEndsWithIgnoreCase() throws Exception {
     @Test
     public void testNameContains() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameContains(FOO.substring(1, 2)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameContains(FOO.substring(1, 2).toUpperCase()).matches(byteCodeElement), is(false));
         assertThat(ElementMatchers.nameContains(BAR).matches(byteCodeElement), is(false));
@@ -451,7 +453,7 @@ public void testNameContains() throws Exception {
     @Test
     public void testNameContainsIgnoreCase() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameContainsIgnoreCase(FOO.substring(1, 2)).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameContainsIgnoreCase(FOO.substring(1, 2).toUpperCase()).matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameContainsIgnoreCase(BAR).matches(byteCodeElement), is(false));
@@ -460,12 +462,20 @@ public void testNameContainsIgnoreCase() throws Exception {
     @Test
     public void testNameMatches() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
-        when(byteCodeElement.getSourceCodeName()).thenReturn(FOO);
+        when(byteCodeElement.getActualName()).thenReturn(FOO);
         assertThat(ElementMatchers.nameMatches("^" + FOO + "$").matches(byteCodeElement), is(true));
         assertThat(ElementMatchers.nameMatches(FOO.toUpperCase()).matches(byteCodeElement), is(false));
         assertThat(ElementMatchers.nameMatches(BAR).matches(byteCodeElement), is(false));
     }
 
+    @Test
+    public void testIsNamed() throws Exception {
+        NamedElement.WithOptionalName namedElement = mock(NamedElement.WithOptionalName.class);
+        assertThat(ElementMatchers.isNamed().matches(namedElement), is(false));
+        when(namedElement.isNamed()).thenReturn(true);
+        assertThat(ElementMatchers.isNamed().matches(namedElement), is(true));
+    }
+
     @Test
     public void testHasDescriptor() throws Exception {
         ByteCodeElement byteCodeElement = mock(ByteCodeElement.class);
@@ -1037,6 +1047,12 @@ public void testIsParentOf() throws Exception {
         assertThat(ElementMatchers.isParentOf(mock(ClassLoader.class)).matches(null), is(true));
     }
 
+    @Test
+    public void testSupportsModules() throws Exception {
+        assertThat(ElementMatchers.supportsModules().matches(mock(JavaModule.class)), is(true));
+        assertThat(ElementMatchers.supportsModules().matches(null), is(false));
+    }
+
     @Test(expected = UnsupportedOperationException.class)
     public void testConstructorIsHidden() throws Exception {
         assertThat(Modifier.isPrivate(ElementMatchers.class.getDeclaredConstructor().getModifiers()), is(true));
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/IsNamedMatcherTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/IsNamedMatcherTest.java
new file mode 100755
index 0000000000..968aa60411
--- /dev/null
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/IsNamedMatcherTest.java
@@ -0,0 +1,32 @@
+package net.bytebuddy.matcher;
+
+import net.bytebuddy.description.NamedElement;
+import net.bytebuddy.description.type.TypeDescription;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.mockito.Mockito.when;
+
+public class IsNamedMatcherTest extends AbstractElementMatcherTest<IsNamedMatcher<?>> {
+
+    @Mock
+    private NamedElement.WithOptionalName namedElement;
+
+    @SuppressWarnings("unchecked")
+    public IsNamedMatcherTest() {
+        super((Class<IsNamedMatcher<?>>) (Object) IsNamedMatcher.class, "isNamed");
+    }
+
+    @Test
+    public void testMatch() throws Exception {
+        when(namedElement.isNamed()).thenReturn(true);
+        assertThat(new IsNamedMatcher<NamedElement.WithOptionalName>().matches(namedElement), is(true));
+    }
+
+    @Test
+    public void testPositiveToNegative() throws Exception {
+        assertThat(new IsNamedMatcher<NamedElement.WithOptionalName>().matches(namedElement), is(false));
+    }
+}
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/NameMatcherTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/NameMatcherTest.java
index d4a8ed11e4..3f3d3a63f1 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/NameMatcherTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/matcher/NameMatcherTest.java
@@ -26,7 +26,7 @@ public NameMatcherTest() {
 
     @Before
     public void setUp() throws Exception {
-        when(namedElement.getSourceCodeName()).thenReturn(FOO);
+        when(namedElement.getActualName()).thenReturn(FOO);
     }
 
     @Test
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
index 521989199a..00a762cbcc 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultComponentTypeLocatorTest.java
@@ -28,7 +28,7 @@ public void testForAnnotationProperty() throws Exception {
         when(typePool.describe(BAR)).thenReturn(new TypePool.Resolution.Simple(typeDescription));
         MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);
         when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));
-        when(methodDescription.getSourceCodeName()).thenReturn(FOO);
+        when(methodDescription.getActualName()).thenReturn(FOO);
         TypeDescription.Generic returnType = mock(TypeDescription.Generic.class);
         TypeDescription rawReturnType = mock(TypeDescription.class);
         when(returnType.asErasure()).thenReturn(rawReturnType);
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyDeclarationContextTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyDeclarationContextTest.java
index 0a823b737f..b92827bef9 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyDeclarationContextTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/pool/TypePoolDefaultLazyDeclarationContextTest.java
@@ -85,7 +85,7 @@ public void testDeclaredInMethodGetTypeIsNotNull() throws Exception {
     @SuppressWarnings("unchecked")
     public void testDeclaredInMethodGetMethodIsNull() throws Exception {
         MethodDescription methodDescription = mock(MethodDescription.class);
-        when(methodDescription.getSourceCodeName()).thenReturn(BAR);
+        when(methodDescription.getActualName()).thenReturn(BAR);
         when(methodDescription.getDescriptor()).thenReturn(QUX);
         TypeDescription typeDescription = mock(TypeDescription.class);
         TypePool typePool = mock(TypePool.class);
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaModuleTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaModuleTest.java
new file mode 100755
index 0000000000..515f4c7add
--- /dev/null
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaModuleTest.java
@@ -0,0 +1,65 @@
+package net.bytebuddy.utility;
+
+import net.bytebuddy.test.utility.ObjectPropertyAssertion;
+import org.junit.Test;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Iterator;
+
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.hamcrest.CoreMatchers.sameInstance;
+import static org.hamcrest.core.Is.is;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.mock;
+
+public class JavaModuleTest {
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testExtractModule() throws Exception {
+        JavaModule.of(mock(Object.class));
+    }
+
+    @Test
+    public void testUnwrap() throws Exception {
+        Object object = new Object();
+        JavaModule module = new JavaModule(object);
+        assertThat(module.unwrap(), sameInstance(object));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testIsNamedDisabledThrowException() throws Exception {
+        JavaModule.Dispatcher.Disabled.INSTANCE.isNamed(mock(Object.class));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testGetNameDisabledThrowException() throws Exception {
+        JavaModule.Dispatcher.Disabled.INSTANCE.getName(mock(Object.class));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testGetClassLoaderDisabledThrowException() throws Exception {
+        JavaModule.Dispatcher.Disabled.INSTANCE.getClassLoader(mock(Object.class));
+    }
+
+    @Test
+    public void testDisabledModuleIsNull() throws Exception {
+        assertThat(JavaModule.Dispatcher.Disabled.INSTANCE.moduleOf(Object.class), nullValue(JavaModule.class));
+    }
+
+    @Test
+    public void testObjectProperties() throws Exception {
+        ObjectPropertyAssertion.of(JavaModule.class).skipToString().apply();
+        Object object = new Object();
+        assertThat(new JavaModule(object).hashCode(), is(object.hashCode()));
+        assertThat(new JavaModule(object).toString(), is(object.toString()));
+        final Iterator<Method> iterator = Arrays.asList(Object.class.getDeclaredMethods()).iterator();
+        ObjectPropertyAssertion.of(JavaModule.Dispatcher.Enabled.class).create(new ObjectPropertyAssertion.Creator<Method>() {
+            @Override
+            public Method create() {
+                return iterator.next();
+            }
+        }).apply();
+        ObjectPropertyAssertion.of(JavaModule.Dispatcher.Disabled.class).apply();
+    }
+}
\ No newline at end of file
diff --git a/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java b/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
index 80973e02a7..6993ded4ed 100755
--- a/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
+++ b/byte-buddy-dep/src/test/java/net/bytebuddy/utility/JavaTypeTest.java
@@ -66,6 +66,14 @@ public void testExecutable() throws Exception {
         assertThat(JavaType.EXECUTABLE.getTypeStub().getInterfaces().contains(new TypeDescription.Generic.OfNonGenericType.ForLoadedType(GenericDeclaration.class)), is(true));
     }
 
+    @Test
+    public void testModule() throws Exception {
+        assertThat(JavaType.MODULE.getTypeStub().getName(), is("java.lang.reflect.Module"));
+        assertThat(JavaType.MODULE.getTypeStub().getModifiers(), is(Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL));
+        assertThat(JavaType.MODULE.getTypeStub().getSuperClass(), is(TypeDescription.Generic.OBJECT));
+        assertThat(JavaType.MODULE.getTypeStub().getInterfaces().size(), is(0));
+    }
+
     @Test
     @JavaVersionRule.Enforce(7)
     public void testJava7Types() throws Exception {
diff --git a/release-notes.md b/release-notes.md
index 50f881bbde..5c6575f815 100755
--- a/release-notes.md
+++ b/release-notes.md
@@ -14,7 +14,7 @@ Byte Buddy release notes
 ### 25. April 2016: version 1.3.18
 
 - The Owner type of a parameterized type created by a `TypePool` is no longer parameterized for a static inner type.
-- The receiver type of a constructor is no longer considered parameterized for a static inner type.
+- The receiver type of a executingTransformer is no longer considered parameterized for a static inner type.
 
 ### 23. April 2016: version 1.3.17
 
@@ -183,7 +183,7 @@ Byte Buddy release notes
 ### 14. December 2015: version 0.7.7
 
 - Fixed type resolution for anonymously loaded classes by the `ClassReloadingStrategy`.
-- Added additional `InitiailizationStrategy`s for self-injection where the new default strategy loads types that are independent of the instrumented type before completing the instrumentation. This way, the resolution does not fail for types that are accessed via reflection before initializing the types if a constructor is rebased.
+- Added additional `InitiailizationStrategy`s for self-injection where the new default strategy loads types that are independent of the instrumented type before completing the instrumentation. This way, the resolution does not fail for types that are accessed via reflection before initializing the types if a executingTransformer is rebased.
 
 ### 11. December 2015: version 0.7.6
 
@@ -396,7 +396,7 @@ Corrected incorrect deployment of version 0.6.7 which does not use a dependency
 ### 5. December 2014: version 0.5.1
 
 Added the `andThen` method to the `SuperMethodCall` instrumentation in order to allow for a more convenient 
-constructor interception where a hard-coded super method call is required by the Java verifier.
+executingTransformer interception where a hard-coded super method call is required by the Java verifier.
 
 ### 3. December 2014: version 0.5
 
