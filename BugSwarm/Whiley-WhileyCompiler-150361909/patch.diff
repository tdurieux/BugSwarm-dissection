diff --git a/build.xml b/build.xml
index 3cbe18ef60..6e90f3e29d 100755
--- a/build.xml
+++ b/build.xml
@@ -7,8 +7,12 @@
 
   <!-- The set of build files in the order they should be built. -->
   <filelist id="module.build.files" dir="modules">
+    <file name="wybs/build.xml"/>
+    <file name="wycs/build.xml"/>
     <file name="wyil/build.xml"/>
     <file name="wyc/build.xml"/>
+    <file name="wyrt/build.xml"/>
+    <file name="wyjc/build.xml"/>
   </filelist>
 
 
@@ -35,6 +39,15 @@
        windowtitle="Whiley Compiler API">
       <doctitle><![CDATA[<h1>The Whiley Compiler (v${version})</h1>]]></doctitle>
       <bottom><![CDATA[<i>Copyright &#169; 2011 David J. Pearce. All Rights Reserved.</i>]]></bottom>
+      <packageset dir="modules/wybs/src">
+	<include name="wyfs/**"/>
+	<include name="wybs/**"/>
+	<include name="wycc/**"/>
+      </packageset>
+      <packageset dir="modules/wycs/src">
+	<include name="wycs/**"/>
+	<exclude name="wycs/testing/**"/>
+      </packageset>
       <packageset dir="modules/wyil/src">
 	<include name="wyil/**"/>
 	<include name="wyautl_old/**"/>
@@ -44,8 +57,16 @@
 	<include name="wyc/**"/>
 	<exclude name="wyc/testing/**"/>
       </packageset>
+      <packageset dir="modules/wyjc/src">
+	<include name="wyjc/**"/>
+	<include name="wyjvm/**"/>
+	<exclude name="wyjc/testing/**"/>
+      </packageset>
+      <group title="Whiley Build System (WYBS)" packages="wybs:wyfs.*:wybs.*:wycc.*"/>
       <group title="Whiley Compiler (WYC)" packages="wyc:wyc.*"/>
       <group title="Whiley Intermediate Language (WYIL)" packages="wyil:wyil.*"/>
+      <group title="Whiley-2-Java Compiler (WYJC)" packages="wyjc:wyjc.*:wyjvm.*"/>
+      <group title="Whiley Constraint Solver (WYCS)" packages="wycs:wycs.*"/>
       </javadoc>
   </target>
 
@@ -70,18 +91,21 @@
       <include name="config.xml"/>
       <include name="modules/**/*.java"/>
       <include name="modules/**/*.whiley"/>
+      <include name="modules/**/*.wyrl"/>
+      <include name="modules/**/*.wycs"/>
       <include name="modules/**/*.xml"/>
       <include name="examples/**/*.whiley"/>
       <include name="tests/**/*.whiley"/>
       <include name="tests/**/*.sysout"/>
       <include name="bin/wyilc"/>
       <include name="bin/wyc"/>
+      <include name="bin/wyjc"/>
       <include name="bin/wyj"/>
       <include name="bin/wycc"/>
+      <include name="bin/wycs"/>
       <include name="bin/wy_common.bash"/>
       <include name="lib/*-v${version}.jar"/>
       <include name="lib/wyrl-v*.jar"/>
-      <include name="lib/wycs-v*.jar"/>      
       <include name="lib/jasm-v*.jar"/>
       <include name="lib/maven-ant-tasks*.jar"/>      
     </fileset>
diff --git a/config.xml b/config.xml
index bd0d8ae775..374d562a5c 100755
--- a/config.xml
+++ b/config.xml
@@ -12,14 +12,15 @@
   <property name="LIB_DIR" value="${rootdir}/lib/"/>
   <property name="DIST_DIR" value="${rootdir}/dist/"/>
 
+  <property name="WYBS_DIR" value="${rootdir}/modules/wybs/"/>
   <property name="WYC_DIR"  value="${rootdir}/modules/wyc/"/>
   <property name="WYIL_DIR" value="${rootdir}/modules/wyil/"/>
+  <property name="WYCS_DIR" value="${rootdir}/modules/wycs/"/>
+  <property name="WYRT_DIR" value="${rootdir}/modules/wyrt/"/>
 
   <!-- Paths to common JARs -->
-  <property name="WYCC_JAR" value="${LIB_DIR}/wycc-v0.4.0-SNAPSHOT.jar"/>  
+  <property name="JASM_JAR" value="${LIB_DIR}/jasm-v0.1.7.jar"/>
   <property name="WYRL_JAR" value="${LIB_DIR}/wyrl-v0.4.4.jar"/>
-  <property name="WYTP_JAR" value="${LIB_DIR}/wycs-v0.4.0.jar"/>
-  <property name="JASM_JAR" value="${LIB_DIR}/jasm-v0.1.7.jar"/>  
 
   <!-- Set the classpath for Junit and its dependencies -->
   <maven:dependencies pathId="junit.classpath">
diff --git a/modules/README b/modules/README
index 7c1d15d96d..f1c4eeb3c7 100755
--- a/modules/README
+++ b/modules/README
@@ -17,3 +17,12 @@ wyil/ --- The Whiley Intermediate Language (wyil).  The Whiley
           code for manipulating structural types in Whiley is included
           here.  In short, this package constitutes the bulk of the
           compiler.
+
+wyjc/ --- The Whiley-to-Java Compiler.  This extends the Whiley
+          Compiler (wyc) with additional transforms for converting
+          wyil code into Java bytecode.
+
+wyrt/ --- The Whiley Standard Library.  This provides the core
+          implementation for the standard library.  All architecture
+          specific code is omitted and, instead, is stored within the
+          respective back-end module (e.g. wyjc).
\ No newline at end of file
diff --git a/modules/wybs/README b/modules/wybs/README
new file mode 100755
index 0000000000..0d70ab14cf
--- /dev/null
+++ b/modules/wybs/README
@@ -0,0 +1,10 @@
+======================================================================
+Package Summary
+======================================================================
+
+src/wybs/ --- The Whiley Build System.  This library manages the
+              overall process of compiling the source files associated
+              with a project using a given set of build rules.
+              Different back-ends specificy different build rules to
+              determine which files get compiled to which
+              architectures.
\ No newline at end of file
diff --git a/modules/wybs/build.xml b/modules/wybs/build.xml
new file mode 100755
index 0000000000..f3ff92601d
--- /dev/null
+++ b/modules/wybs/build.xml
@@ -0,0 +1,83 @@
+<project name="wybs" default="build">
+
+  <!-- ================================================================== -->
+  <!-- Configuration -->
+  <!-- ================================================================== -->
+  <import file="../../config.xml"/>
+
+  <!-- ================================================================== -->
+  <!-- Compile -->
+  <!-- ================================================================== -->
+
+  <target name="compile-wybs">
+    <javac memoryMaximumSize="2048m" fork="true" debug="true" debuglevel="vars,lines,source" source="1.7" target="1.7" includeantruntime="true">
+      <src path="src"/>
+      <include name="*/**"/>
+      <exclude name="*/**/package-info.java"/>
+    </javac>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Test -->
+  <!-- ================================================================== -->
+
+  <target name="test"/>
+
+  <!-- ================================================================== -->
+  <!-- Build -->
+  <!-- ================================================================== -->
+
+  <target name="build" depends="compile-wybs">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wybs-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${LIB_DIR}/wybs-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src" includes="*/**/*.class"/>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: lib/${ant.project.name}-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Dist -->
+  <!-- ================================================================== -->
+
+  <target name="dist">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wybs-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${DIST_DIR}/wybs-all-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src">
+	<include name="wyfs/**/*.class"/>
+	<include name="wybs/**/*.class"/>
+	<include name="wycc/**/*.class"/>
+      </fileset>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: dist/${ant.project.name}-all-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Clean -->
+  <!-- ================================================================== -->
+
+  <target name="clean">
+    <delete includeEmptyDirs="true" failonerror="false">
+      <fileset dir="." includes="**/*.class,**/*.wyil,**/*.wyasm"/>
+    </delete>
+    <echo message="============================================="/>
+    <echo message="CLEANED: ${ant.project.name}"/>
+    <echo message="============================================="/>
+  </target>
+
+</project>
diff --git a/modules/wybs/src/wybs/lang/Build.java b/modules/wybs/src/wybs/lang/Build.java
new file mode 100755
index 0000000000..d65b699912
--- /dev/null
+++ b/modules/wybs/src/wybs/lang/Build.java
@@ -0,0 +1,195 @@
+package wybs.lang;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+
+public interface Build {
+
+	/**
+	 * <p>
+	 * Represents a top-level entity responsible for managing everything related
+	 * to a given build. A build project provides a global "namespace" where
+	 * named objects (e.g. source files, binary files) reside and/or are
+	 * created. A build project also contains one or more build rules which
+	 * determines how source files are transformed.
+	 * </p>
+	 * <p>
+	 * For a given set of source files, a build project defines (in an abstract
+	 * sense) a "build" --- that is, a specific plan of construction starting
+	 * from one or more source files and producing one or more binary files.
+	 * This is abstract because, in the normal course of events, the build is
+	 * only known "after the fact"; that is, once all binary files are
+	 * generated. This is necessary because it can be difficult to predict ahead
+	 * of time what binary files will be generated from a given source file.
+	 * </p>
+	 * <p>
+	 * Build projects have the opportunity to record the dependencies created
+	 * during a build. That is, a binary file depends on those source file(s)
+	 * required to build it. Recording this information is necessary if one
+	 * wants to perform an incremental (re)compilation. That is, using such
+	 * dependency information, one can avoid recompiling all source files from
+	 * scratch.
+	 * </p>
+	 * <p>
+	 * Finally, build projects may choose to record other information (e.g.
+	 * timing and other statistical information) and/or employ different
+	 * techniques (e.g. parallel builds).
+	 * </p>
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Project {
+
+		/**
+		 * Check whether or not a given entry is contained in this root;
+		 *
+		 * @param entry
+		 * @return
+		 */
+		public boolean contains(Path.Entry<?> entry) throws IOException;
+
+		/**
+		 * Check whether or not a given entry and content-type is contained in
+		 * this root.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public boolean exists(Path.ID id, Content.Type<?> ct) throws IOException;
+
+		/**
+		 * Get the entry corresponding to a given ID and content type. If no
+		 * such entry exists, return null.
+		 *
+		 * @param id
+		 *            --- id of module to lookup.
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public <T> Path.Entry<T> get(Path.ID id, Content.Type<T> ct) throws IOException;
+
+		/**
+		 * Get all objects matching a given content filter stored in this root.
+		 * In the case of no matches, an empty list is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param ct
+		 * @return
+		 */
+		public <T> List<Path.Entry<T>> get(Content.Filter<T> ct) throws IOException;
+
+		/**
+		 * Identify all entries matching a given content filter stored in this
+		 * root. In the case of no matches, an empty set is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param filter
+		 *            --- filter to match entries with.
+		 * @return
+		 */
+		public <T> Set<Path.ID> match(Content.Filter<T> filter) throws IOException;
+	}
+
+	/**
+	 * <p>
+	 * A build rule is an abstraction describing how a set of one or more source
+	 * files should be compiled. Each build rule is associated with a builder
+	 * responsible for compiling matching files, a destination root and a
+	 * mechanism for "matching source" files. For example, we could view a build
+	 * rule like this:
+	 * </p>
+	 *
+	 * <pre>
+	 * WhileyCompiler :: src/:whiley/lang/*.whiley => bin/
+	 * </pre>
+	 *
+	 * <p>
+	 * Here, the builder is the <code>WhileyCompiler</code>, whilst the
+	 * destination root is "bin/". Source files are taken from the root "src/"
+	 * matching the regex "whiley/lang/*.whiley".
+	 * </p>
+	 *
+	 * <p>
+	 * Different build rules are free to implement the "matching" mechanism as
+	 * they wish. Typically, one wants a generic way to describe a group of
+	 * source files using wildcards (often called the "includes"). Occasionally,
+	 * one also wants a way to exclude one or more files (oftern called the
+	 * "excludes").
+	 * </p>
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Rule {
+
+		/**
+		 * <p>
+		 * Apply this rule to a given compilation group, producing a set of
+		 * generated or modified files. This set may be empty if the rule does
+		 * not match against any source file in the group.
+		 * </p>
+		 *
+		 * @param group
+		 *            The set of files currently being compiled.
+		 * @param graph
+		 *            The build graph being constructed
+		 * @return The set of files generated by this rule (which may be empty,
+		 *         but cannot be <code>null</code>).
+		 * @throws IOException
+		 */
+		public Set<Path.Entry<?>> apply(Collection<? extends Path.Entry<?>> group, Build.Graph graph)
+				throws IOException;
+	}
+
+	/**
+	 * <p>
+	 * A build graph captures the relationships between compilation units. There
+	 * are two relationships of interest: <i>vertical</i> and <i>horizontal</i>
+	 * dependencies. For example one (or more) files being compiled to produce a
+	 * generated or <i>derived</i> file corresponds to a vertical dependency
+	 * between the original and the derived files. Horizontal dependencies
+	 * correspond to situations where one file at the same level uses symbols
+	 * from another.
+	 * </p>
+	 * 
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Graph {
+		/**
+		 * Determine the entry (the parent) that a given entry (the child) is
+		 * derived from, or null if no such entry exists. An entry is said to
+		 * derive from another if it generated from the other during the
+		 * compilation process. For example, a source file is compiled into a
+		 * binary or intermediate file. The latter is said to be derived from
+		 * the former.
+		 * 
+		 * @param child
+		 *            The child entry which is derived from zero or more parent
+		 *            entries.
+		 * @return
+		 */
+		Path.Entry<?> parent(Path.Entry<?> child);
+		
+		/**
+		 * Register a derivation from one file (the parent) to another (the
+		 * child). A derivation indicates that one file (e.g. a source file)
+		 * generated another (e.g. a binary file) during the compilation
+		 * process.
+		 * 
+		 * @param parent
+		 * @param child
+		 */
+		void registerDerivation(Path.Entry<?> parent, Path.Entry<?> child);
+	}
+}
diff --git a/modules/wybs/src/wybs/lang/Builder.java b/modules/wybs/src/wybs/lang/Builder.java
new file mode 100755
index 0000000000..f2af28c9f5
--- /dev/null
+++ b/modules/wybs/src/wybs/lang/Builder.java
@@ -0,0 +1,69 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wybs.lang;
+
+import java.io.IOException;
+import java.util.*;
+
+import wycc.util.Pair;
+import wyfs.lang.Path;
+
+/**
+ * <p>
+ * Responsible for transforming files from one content type to another.
+ * Typically this revolves around compiling a source file into one or more
+ * binary files, although other kinds of transformations are possible (e.g.
+ * source-to-source translations, etc).
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public interface Builder {
+
+	/**
+	 * Get the project this builder is operating on.
+	 *
+	 * @return
+	 */
+	public Build.Project project();
+
+	/**
+	 * Build a given set of source files to produce target files in specified
+	 * locations. A delta represents a list of pairs (s,t), where s is a source
+	 * file and t is the destination root for all generated files. Each file may
+	 * be associated with a different destination directory, in order to support
+	 * e.g. multiple output directories.
+	 *
+	 * @param delta
+	 *            --- the set of files to be built.
+	 * @param graph
+	 *            --- The build graph being constructed
+	 * @return --- the set of files generated or modified.
+	 */
+	public Set<Path.Entry<?>> build(
+			Collection<Pair<Path.Entry<?>, Path.Root>> delta, Build.Graph graph) throws IOException;
+}
diff --git a/modules/wybs/src/wybs/lang/package-info.java b/modules/wybs/src/wybs/lang/package-info.java
new file mode 100755
index 0000000000..6e618bdf28
--- /dev/null
+++ b/modules/wybs/src/wybs/lang/package-info.java
@@ -0,0 +1,31 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * Provides core interfaces for describing content, namespaces, builders and build rules.
+ *
+ * @author David J. Pearce
+ */
+package wybs.lang;
diff --git a/modules/wybs/src/wybs/package-info.java b/modules/wybs/src/wybs/package-info.java
new file mode 100755
index 0000000000..231efba470
--- /dev/null
+++ b/modules/wybs/src/wybs/package-info.java
@@ -0,0 +1,34 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * <b>The Whiley Build System</b>. This provides a generic and flexible build
+ * system which underpins the Whiley compiler. The need for such a build system
+ * stems from a requirement to integrate the Whiley compiler with different
+ * tools (e.g. Ant, Eclipse, etc).
+ *
+ * @author David J. Pearce
+ */
+package wybs;
diff --git a/modules/wybs/src/wybs/util/StdBuildGraph.java b/modules/wybs/src/wybs/util/StdBuildGraph.java
new file mode 100755
index 0000000000..91313f4761
--- /dev/null
+++ b/modules/wybs/src/wybs/util/StdBuildGraph.java
@@ -0,0 +1,31 @@
+package wybs.util;
+
+import java.util.HashMap;
+
+import wybs.lang.Build;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+
+/**
+ * Provides a straightforward implementation of the Build.Graph interface.
+ * 
+ * @author David J. Pearce
+ *
+ */
+public class StdBuildGraph implements Build.Graph {
+	/**
+	 * The derived from relation maps child entries to the parents they are
+	 * derived from.
+	 */
+	private HashMap<Path.Entry<?>, Path.Entry<?>> derivedFrom = new HashMap<>();
+
+	@Override
+	public Entry<?> parent(Entry<?> child) {
+		return derivedFrom.get(child);
+	}
+
+	@Override
+	public void registerDerivation(Path.Entry<?> parent, Path.Entry<?> child) {
+		derivedFrom.put(child, parent);
+	}
+}
diff --git a/modules/wybs/src/wybs/util/StdBuildRule.java b/modules/wybs/src/wybs/util/StdBuildRule.java
new file mode 100755
index 0000000000..5b998d44e3
--- /dev/null
+++ b/modules/wybs/src/wybs/util/StdBuildRule.java
@@ -0,0 +1,113 @@
+package wybs.util;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Set;
+
+import wybs.lang.Build;
+import wybs.lang.Builder;
+import wycc.util.Pair;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+
+/**
+ * <p>
+ * Provides a straightforward, yet flexible build rule implementation. This
+ * build rule supports both include and exclude filters. It is expected that
+ * this rule is sufficiently flexible for the majority of situations
+ * encountered.
+ * </p>
+ * <p>
+ * <b>NOTE</b>: instances of this class are immutable, although objects they
+ * reference may not be (e.g. builders).
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class StdBuildRule implements Build.Rule {
+	/**
+	 * The builder used to build files using this rule.
+	 */
+	final Builder builder;
+
+	/**
+	 * The source root containing all files which might be built using this
+	 * rule. However, whether or not files contained in this root will actually
+	 * be built depends on the includes and excludes filters.
+	 */
+	final Path.Root source;
+
+	/**
+	 * The destination root into which all files built using this rule are
+	 * placed.
+	 */
+	final Path.Root target;
+
+	/**
+	 * A content filter used to determine which files contained in the source
+	 * root should be built by this rule.  Maybe null.
+	 */
+	final Content.Filter<?> includes;
+
+	/**
+	 * A content filter used to determine which files contained in the source
+	 * root should be not built by this rule.  Maybe null.
+	 */
+	final Content.Filter<?> excludes;
+
+	/**
+	 * Construct a standard build rule.
+	 *
+	 * @param builder
+	 *            The builder used to build files using this rule.
+	 * @param srcRoot
+	 *            The source root containing all files which might be built
+	 *            using this rule. However, whether or not files contained in
+	 *            this root will actually be built depends on the includes and
+	 *            excludes filters.
+	 * @param includes
+	 *            A content filter used to determine which files contained in
+	 *            the source root should be built by this rule. Maybe null.
+	 * @param excludes
+	 *            A content filter used to determine which files contained in
+	 *            the source root should be not built by this rule. Maybe null.
+	 * @param targetRoot
+	 *            The destination root into which all files built using this
+	 *            rule are placed.
+	 */
+	public StdBuildRule(Builder builder, Path.Root srcRoot,
+			Content.Filter<?> includes, Content.Filter<?> excludes,
+			Path.Root targetRoot) {
+		this.builder = builder;
+		this.source = srcRoot;
+		this.target = targetRoot;
+		this.includes = includes;
+		this.excludes = excludes;
+	}
+
+	@Override
+	public Set<Path.Entry<?>> apply(Collection<? extends Path.Entry<?>> group, Build.Graph graph) throws IOException {
+		ArrayList<Pair<Path.Entry<?>, Path.Root>> matches = new ArrayList<Pair<Path.Entry<?>, Path.Root>>();
+
+		// First, determine the set of matching files
+		for (Path.Entry e : group) {
+			if (includes == null || !includes.matches(e.id(), e.contentType())) {
+				continue;
+			}
+			if (excludes != null && excludes.matches(e.id(), e.contentType())) {
+				continue;
+			}
+			matches.add(new Pair<Path.Entry<?>, Path.Root>(e, target));
+		}
+
+		// Second, build all matching files
+		if (matches.size() > 0) {
+			return builder.build(matches, graph);
+		} else {
+			return Collections.EMPTY_SET;
+		}
+	}
+}
diff --git a/modules/wybs/src/wybs/util/StdProject.java b/modules/wybs/src/wybs/util/StdProject.java
new file mode 100755
index 0000000000..bfde686178
--- /dev/null
+++ b/modules/wybs/src/wybs/util/StdProject.java
@@ -0,0 +1,263 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wybs.util;
+
+import java.io.IOException;
+import java.util.*;
+
+import wybs.lang.*;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+
+/**
+ * <p>
+ * Provides a straightforward implementation of Build.Project and a basic build
+ * system supporting an arbitrary number of build rules. The object space is
+ * defined by one or more "path roots" which are locations on the file system
+ * where named items may be found. Such locations may be, for example,
+ * directories. However, they may also be jar files, or even potentially network
+ * locations.
+ * </p>
+ * <p>
+ * The core strategy for building files is fairly simplistic, and assumes a
+ * "breadth-first" compilation tree. That is, where files at one level are all
+ * compiled producing a new set of files for the next level. In most cases, this
+ * is fine. However, in more complex compilation pipelines this can lead to
+ * compilation failures.
+ * </p>
+ *
+ * @author David J. Pearce
+ */
+public class StdProject implements Build.Project {
+
+	/**
+	 * The roots of all entries known to the system which form the global
+	 * namespace used by the builder(s).
+	 */
+	protected final ArrayList<Path.Root> roots;
+
+	/**
+	 * The rules associated with this project for transforming content. It is
+	 * assumed that for any given transformation there is only one possible
+	 * pathway described.
+	 */
+	protected final ArrayList<Build.Rule> rules;
+
+	public StdProject(Collection<Path.Root> roots) {
+		this.roots = new ArrayList<Path.Root>(roots);
+		this.rules = new ArrayList<Build.Rule>();
+	}
+
+	public StdProject(Collection<Path.Root>... roots) {
+		this.rules = new ArrayList<Build.Rule>();
+		this.roots = new ArrayList<Path.Root>();
+		for(Collection<Path.Root> root : roots) {
+			this.roots.addAll(root);
+		}
+	}
+
+	// ======================================================================
+	// Configuration Interface
+	// ======================================================================
+
+	/**
+	 * Add a new builder to this project.
+	 *
+	 * @param data.builder
+	 */
+	public void add(Build.Rule rule) {
+		rules.add(rule);
+	}
+
+	/**
+	 * Get the roots associated with this project.
+	 *
+	 * @return
+	 */
+	public List<Path.Root> roots() {
+		return roots;
+	}
+
+	/**
+	 * Get the build rules associated with this project.
+	 *
+	 * @return
+	 */
+	public List<Build.Rule> rules() {
+		return rules;
+	}
+
+	// ======================================================================
+	// Accessors
+	// ======================================================================
+
+
+	/**
+	 * Check whether or not a given entry is contained in this root;
+	 *
+	 * @param entry
+	 * @return
+	 */
+	@Override
+	public boolean contains(Path.Entry<?> entry) throws IOException {
+		for(int i=0;i!=roots.size();++i) {
+			if(roots.get(i).contains(entry)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Check whether or not a given entry and content-type is contained in
+	 * this root.
+	 *
+	 * @throws IOException
+	 *             --- in case of some I/O failure.
+	 */
+	public boolean exists(Path.ID id, Content.Type<?> ct) throws IOException {
+		for(int i=0;i!=roots.size();++i) {
+			if(roots.get(i).exists(id, ct)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Get the entry corresponding to a given ID and content type. If no
+	 * such entry exists, return null.
+	 *
+	 * @param id
+	 *            --- id of module to lookup.
+	 * @throws IOException
+	 *             --- in case of some I/O failure.
+	 *
+	 */
+	public <T> Path.Entry<T> get(Path.ID id, Content.Type<T> ct) throws IOException {
+		for(int i=0;i!=roots.size();++i) {
+			Path.Entry<T> e = roots.get(i).get(id, ct);
+			if(e != null) {
+				return e;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Get all objects matching a given content filter stored in this root.
+	 * In the case of no matches, an empty list is returned.
+	 *
+	 * @throws IOException
+	 *             --- in case of some I/O failure.
+	 *
+	 * @param ct
+	 * @return
+	 */
+	public <T> ArrayList<Path.Entry<T>> get(Content.Filter<T> filter) throws IOException {
+		ArrayList<Path.Entry<T>> r = new ArrayList<Path.Entry<T>>();
+		for(int i=0;i!=roots.size();++i) {
+			r.addAll(roots.get(i).get(filter));
+		}
+		return r;
+	}
+
+	/**
+	 * Identify all entries matching a given content filter stored in this
+	 * root. In the case of no matches, an empty set is returned.
+	 *
+	 * @throws IOException
+	 *             --- in case of some I/O failure.
+	 *
+	 * @param filter
+	 *            --- filter to match entries with.
+	 * @return
+	 */
+	public <T> HashSet<Path.ID> match(Content.Filter<T> filter) throws IOException {
+		HashSet<Path.ID> r = new HashSet<Path.ID>();
+		for(int i=0;i!=roots.size();++i) {
+			r.addAll(roots.get(i).match(filter));
+		}
+		return r;
+	}
+
+	// ======================================================================
+	// Mutators
+	// ======================================================================
+
+	/**
+	 * Force root to flush entries to permanent storage (where appropriate).
+	 * This is essential as, at any given moment, path entries may only be
+	 * stored in memory. We must flush them to disk in order to preserve any
+	 * changes that were made.
+	 */
+	public void flush() throws IOException {
+		for(int i=0;i!=roots.size();++i) {
+			roots.get(i).flush();
+		}
+	}
+
+	/**
+	 * Force root to refresh entries from permanent storage (where
+	 * appropriate). For items which has been modified, this operation has
+	 * no effect (i.e. the new contents are retained).
+	 */
+	public void refresh() throws IOException {
+		for(int i=0;i!=roots.size();++i) {
+			roots.get(i).refresh();
+		}
+	}
+
+	// ======================================================================
+	// Build
+	// ======================================================================
+
+	/**
+	 * Build a given set of source entries, including all files which depend
+	 * upon them.
+	 *
+	 * @param sources
+	 *            --- a collection of source file entries. This will not be
+	 *            modified by this method.
+	 * @throws Exception
+	 */
+	public void build(Collection<? extends Path.Entry<?>> sources) throws Exception {
+		Build.Graph graph = new StdBuildGraph();
+		
+		// Continue building all source files until there are none left. This is
+		// actually quite a naive implementation, as it ignores the potential
+		// need for staging dependencies.
+		do {
+			HashSet<Path.Entry<?>> generated = new HashSet<Path.Entry<?>>();
+			for (Build.Rule r : rules) {
+				generated.addAll(r.apply(sources,graph));
+			}
+			sources = generated;
+		} while (sources.size() > 0);
+
+		// Done!
+	}
+}
diff --git a/modules/wybs/src/wybs/util/package-info.java b/modules/wybs/src/wybs/util/package-info.java
new file mode 100755
index 0000000000..adc51c0d96
--- /dev/null
+++ b/modules/wybs/src/wybs/util/package-info.java
@@ -0,0 +1,31 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * Provides instantiations of the build system interfaces which cover the common cases.
+ *
+ * @author David J. Pearce
+ */
+package wybs.util;
diff --git a/modules/wybs/src/wycc/io/AbstractLexer.java b/modules/wybs/src/wycc/io/AbstractLexer.java
new file mode 100755
index 0000000000..fc272baae3
--- /dev/null
+++ b/modules/wybs/src/wycc/io/AbstractLexer.java
@@ -0,0 +1,656 @@
+// Copyright (c) 2013, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.io;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.math.BigInteger;
+import java.nio.charset.CharsetDecoder;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * <p>
+ * Provides a generic mechanism for turning an input file or string into a list
+ * of tokens. Every token records the text that constituted it, as well as its
+ * start and end position in the stream.
+ * </p>
+ * <p>
+ * There are several use cases for this class. The most important use case is
+ * obviously lexing a source file so that it can be fed into a parser and then
+ * into the remainder of a compiler. However, other use cases include pretty
+ * printers which read a stream and format it according to certain rules for
+ * indentation, etc.
+ * </p>
+ * <p>
+ * This class also provides several standard tokens and rules which are common
+ * across the various languages used within the Whiley compiler system.
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class AbstractLexer {
+	/**
+	 * The input stream.
+	 */
+	private final StringBuffer input;
+
+	/**
+	 * Lexing rules which determine how the input stream is broken down into
+	 * tokens.
+	 */
+	private final Rule[] rules;
+
+	/**
+	 * Construct from an input stream using UTF-8 as the default character
+	 * encoding.
+	 *
+	 * @param instream
+	 * @throws IOException
+	 */
+	public AbstractLexer(Rule[] rules, InputStream instream) throws IOException {
+		this(rules, new InputStreamReader(instream, "UTF-8"));
+	}
+
+	/**
+	 * Construct from an input stream using a given character set decoder.
+	 *
+	 * @param instream
+	 * @throws IOException
+	 */
+	public AbstractLexer(Rule[] rules, InputStream instream, CharsetDecoder decoder)
+			throws IOException {
+		this(rules, new InputStreamReader(instream, decoder));
+	}
+
+	/**
+	 * Construct from a reader (which already has some notion of character
+	 * enconding included).
+	 *
+	 * @param reader
+	 * @throws IOException
+	 */
+	public AbstractLexer(Rule[] rules, Reader reader) throws IOException {
+		BufferedReader in = new BufferedReader(reader);
+
+		StringBuffer text = new StringBuffer();
+		java.lang.String tmp;
+		while ((tmp = in.readLine()) != null) {
+			text.append(tmp);
+			text.append("\n");
+		}
+
+		this.input = text;
+		this.rules = rules;
+	}
+
+	/**
+	 * Scan the given input stream and produce a list of tokens, or an error.
+	 *
+	 * @return
+	 */
+	public List<Token> scan() throws Error {
+		ArrayList<Token> tokens = new ArrayList<Token>();
+		int pos = 0;
+		while (pos < input.length()) {
+			int start = pos;
+			for (int i = 0; i != rules.length; ++i) {
+				Rule rule = rules[i];
+				int left = input.length() - pos;
+				if (left >= rule.lookahead()) {
+					Token t = rule.match(input, pos);
+					if (t != null) {
+						tokens.add(t);
+						pos = pos + t.text.length();
+						break; // restart rule application loop
+					}
+				}
+			}
+			if(pos == start) {
+				throw new Error("unrecognised token encountered (" + input.charAt(pos) + ")",pos);
+			}
+		}
+		return tokens;
+	}
+
+	/**
+	 * A lexer rule is responsible for matching a given character sequence and
+	 * turning it into a token.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static abstract class Rule {
+		/**
+		 * Determines the maximum amount of lookahead required by this rule. The
+		 * system will guarantee there is enough lookahead space in the input
+		 * before calling the rule.
+		 *
+		 * @return
+		 */
+		public abstract int lookahead();
+
+		/**
+		 * Attempt to match this rule at a given position in the input stream.
+		 * Observe that upon a successful match (i.e. when the returned value is
+		 * not <code>null</code>) the stream will be advanced to
+		 * <code>Token.end + 1</code>.
+		 *
+		 * @param buffer
+		 * @param start
+		 * @return
+		 */
+		public abstract Token match(StringBuffer buffer, int start) throws Error;
+	}
+
+	// ===================================================================
+	// Standard Rules
+	// ===================================================================
+
+	/**
+	 * Standard rule for parsing Whitespace.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class WhitespaceRule extends Rule {
+
+		@Override
+		public int lookahead() {
+			return 1;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) {
+			int start = pos;
+
+			if(pos < input.length()) {
+
+				// First, look for new lines
+				if(input.charAt(pos) == '\n') {
+					pos++;
+					return new Token.NewLine("\n",start);
+				} else if((pos+1) < input.length() && input.charAt(pos) == '\r' && input.charAt(pos+1) == '\n') {
+					return new Token.NewLine("\r\n",start);
+				}
+
+				// Second, look for spaces
+				if(input.charAt(pos) == ' ') {
+					while (pos < input.length()
+							&& input.charAt(pos) == ' ') {
+						pos++;
+					}
+					return new Token.Spaces(input.substring(start, pos), start);
+				}
+
+				// Third, look for tabs
+				if(input.charAt(pos) == '\t') {
+					while (pos < input.length()
+							&& input.charAt(pos) == '\t') {
+						pos++;
+					}
+					return new Token.Tabs(input.substring(start, pos), start);
+				}
+			}
+
+			return null;
+		}
+	}
+
+	/**
+	 * Standard rule for parsing Operators.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class OperatorRule extends Rule {
+		private final java.lang.String[] operators;
+		private final int minLookahead;
+
+		public OperatorRule(java.lang.String[] operators) {
+			this.operators = operators;
+			int min = Integer.MAX_VALUE;
+			for(int i=0;i!=operators.length;++i) {
+				min = Math.min(operators[i].length(),min);
+			}
+			this.minLookahead = min;
+		}
+
+		@Override
+		public int lookahead() {
+			return minLookahead;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) {
+			int start = pos;
+			int nRemaining = input.length() - pos;
+			for (int i = 0; i != operators.length; ++i) {
+				java.lang.String operator = operators[i];
+				if (operator.length() <= nRemaining
+						&& matchString(input, pos, operator)) {
+					return new Token.Operator(operator, start);
+				}
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * Standard rule for parsing keywords.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class KeywordRule extends Rule {
+		private final java.lang.String[] keywords;
+		private final int minLookahead;
+
+		public KeywordRule(java.lang.String[] keywords) {
+			this.keywords = keywords;
+			int min = Integer.MAX_VALUE;
+			for(int i=0;i!=keywords.length;++i) {
+				min = Math.min(keywords[i].length(),min);
+			}
+			this.minLookahead = min;
+		}
+
+		@Override
+		public int lookahead() {
+			return minLookahead;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) {
+			int start = pos;
+			while (pos < input.length()
+					&& Character.isLetter(input.charAt(pos))) {
+				pos = pos + 1;
+			}
+			java.lang.String word = input.substring(start, pos);
+			for (int i = 0; i != keywords.length; ++i) {
+				java.lang.String keyword = keywords[i];
+				if (keyword.equals(word)) {
+					return new Token.Keyword(keyword, start);
+				}
+			}
+			return null;
+		}
+	}
+
+	/**
+	 * A standard rule for parsing identifiers. Identifiers may not start with a
+	 * numeric character, or an operator. But, they may start with e.g. '$', or
+	 * '_' and, obviously, any alpabetic character.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class IdentifierRule extends Rule {
+
+		@Override
+		public int lookahead() {
+			return 1;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) {
+			int start = pos;
+			if (!Character.isJavaIdentifierStart(input.charAt(pos))) {
+				return null;
+			}
+			pos = pos + 1;
+			while (pos < input.length()
+					&& Character.isJavaIdentifierPart(input.charAt(pos))) {
+				pos++;
+			}
+			java.lang.String text = input.substring(start, pos);
+			return new Token.Identifier(text, start);
+		}
+	}
+
+	/**
+	 * A standard rule for parsing strings which begin with quote marks. For
+	 * example, <code>"Hello World"</code>. This rule correctly handles escape
+	 * sequences, such as "\n", "\t" and "\\", etc.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class StringRule extends Rule {
+
+		@Override
+		public int lookahead() {
+			return 1;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) throws Error {
+			if(input.charAt(pos) != '\"') { return null; }
+			int start = pos;
+			boolean flag = false;
+			pos ++;
+			while(pos < input.length()) {
+				char c = input.charAt(pos);
+				if (flag) {
+					flag = false;
+					continue;
+				}
+				if (c == '\\') {
+					flag = true;
+					continue;
+				}
+				if (c == '\"') {
+					java.lang.String v = input.substring(start,++pos);
+					return new Token.String(scan(v, pos - v.length()),start);
+				}
+				pos = pos + 1;
+			}
+			throw new Error("unexpected end-of-string",pos-1);
+		}
+
+		private java.lang.String scan(java.lang.String v, int start) throws Error {
+			// Second, step through the string and replace escaped characters
+			int end = v.length()-1;
+			for (int i = 1; i < end; i++) {
+				if (v.charAt(i) == '\\') {
+					if (v.length() <= i + 1) {
+						throw new Error("unexpected end-of-string",start+i);
+					} else {
+						char replace = 0;
+						int len = 2;
+						switch (v.charAt(i + 1)) {
+							case 'b' :
+								replace = '\b';
+								break;
+							case 't' :
+								replace = '\t';
+								break;
+							case 'n' :
+								replace = '\n';
+								break;
+							case 'f' :
+								replace = '\f';
+								break;
+							case 'r' :
+								replace = '\r';
+								break;
+							case '"' :
+								replace = '\"';
+								break;
+							case '\'' :
+								replace = '\'';
+								break;
+							case '\\' :
+								replace = '\\';
+								break;
+							case 'u' :
+								len = 6; // unicode escapes are six digits long,
+								// including "slash u"
+								java.lang.String unicode = v.substring(i + 2, i + 6);
+								replace = (char) Integer.parseInt(unicode, 16); // unicode
+								break;
+							default :
+								throw new Error("unknown escape character",start+i);
+						}
+						v = v.substring(0, i) + replace + v.substring(i + len);
+					}
+				}
+			}
+			return v;
+		}
+
+	}
+
+	/**
+	 * A standard rule for parsing characters which begin with single quote
+	 * marks. For example, <code>'H'</code>. This rule correctly handles escape
+	 * sequences, such as '\n', '\t' and '\\', etc.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class CharRule extends Rule {
+
+		@Override
+		public int lookahead() {
+			return 1;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) throws Error {
+			char ans = ' ';		// set to keep javac out of trouble.
+			int start = pos;
+			boolean addflag = false;
+			boolean escflag = false;
+			boolean gotflag = false;
+			boolean ovflag = false;
+			pos ++;
+			while(pos < input.length()) {
+				char c = input.charAt(pos);
+				if (addflag) {
+					addflag = false;
+					ans = c;
+					continue;
+				}
+				if (c == '\\') {
+					gotflag = true;
+					escflag = true;
+					continue;
+				}
+				if (c == '\'') {
+					break;
+				}
+				ans = c;
+				ovflag = gotflag;
+				gotflag = true;
+				pos = pos + 1;
+			}
+			if (!( pos < input.length())) {
+				throw new Error("unexpected end-of-character", pos-1);
+			}
+			if (!gotflag) {
+				throw new Error("empty character", pos-1);
+			}
+			if (ovflag) {
+				throw new Error("character overflow", pos-1);
+			}
+			if (escflag) {
+				// escape code
+				switch(ans) {
+				case 't':
+					ans = '\t';
+					break;
+				case 'n':
+					ans = '\n';
+					break;
+				default:
+					throw new Error("unrecognised escape character",pos-1);
+				}
+			}
+			return new Token.Char(ans,input.substring(start,pos),start);
+		}
+
+	}
+
+	/**
+	 * A standard rule for parsing numbers represented in decimal (i.e. base
+	 * 10).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class DecimalRule extends Rule {
+
+		@Override
+		public int lookahead() {
+			return 1;
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) throws Error {
+			int start = pos;
+			if(!Character.isDigit(input.charAt(pos))) {
+				return null;
+			}
+			while (pos < input.length() && Character.isDigit(input.charAt(pos))) {
+				pos = pos + 1;
+			}
+
+			BigInteger beforePoint = new BigInteger(input.substring(start, pos));
+			BigInteger afterPoint = null;
+
+			if (pos < input.length() && input.charAt(pos) == '.') {
+				pos = pos + 1;
+				int dotStart = pos;
+				if (pos < input.length() && Character.isDigit(input.charAt(pos))) {
+					while (pos < input.length()
+							&& Character.isDigit(input.charAt(pos))) {
+						pos = pos + 1;
+					}
+					afterPoint = new BigInteger(input.substring(dotStart, pos));
+				} else {
+					// this is case for range e.g. 0..1
+					pos = pos - 1;
+				}
+			}
+			return new Token.Number(10,beforePoint,afterPoint,input.substring(start,pos),start);
+		}
+
+	}
+
+	/**
+	 * Standard rule for parsing line comments with user-defineable syntax.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class LineCommentRule extends Rule {
+		private java.lang.String syntax;
+		public LineCommentRule(java.lang.String syntax) {
+			this.syntax = syntax;
+		}
+
+		@Override
+		public int lookahead() {
+			return syntax.length();
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) throws Error {
+			// first, check whether this rule applies or not.
+			if(!matchString(input,pos,syntax)) {
+				return null;
+			}
+			// second scan until the end-of-line is reached.
+			int start = pos;
+			while (pos < input.length() && input.charAt(pos) != '\n') {
+				pos++;
+			}
+			return new Token.LineComment(input.substring(start, pos), start);
+		}
+	}
+
+	/**
+	 * Standard rule for parsing block comments with user-defineable start and
+	 * end syntax.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class BlockCommentRule extends Rule {
+		private java.lang.String startSyntax;
+		private java.lang.String endSyntax;
+
+		public BlockCommentRule(java.lang.String startSyntax, java.lang.String endSyntax) {
+			this.startSyntax = startSyntax;
+			this.endSyntax = endSyntax;
+		}
+
+		@Override
+		public int lookahead() {
+			return startSyntax.length();
+		}
+
+		@Override
+		public Token match(StringBuffer input, int pos) throws Error {
+			// first, check whether this rule applies or not.
+			if (!matchString(input, pos, startSyntax)) {
+				return null;
+			}
+			// second, parse the block comment!
+			int start = pos;
+			while ((pos + 1) < input.length()
+					&& !matchString(input, pos, endSyntax)) {
+				pos++;
+			}
+			pos += endSyntax.length();
+			return new Token.BlockComment(input.substring(start, pos), start);
+		}
+	}
+
+	// ===================================================================
+	// Helper Classes / Methods
+	// ===================================================================
+
+	private static boolean matchString(StringBuffer input, int pos,
+			java.lang.String syntax) {
+		int diff = input.length() - pos;
+		if(syntax.length() > diff) {
+			return false;
+		} else {
+			for (int i = 0; i != syntax.length(); ++i) {
+				if (syntax.charAt(i) != input.charAt(pos + i)) {
+					return false;
+				}
+			}
+			return true;
+		}
+	}
+
+	/**
+	 * Used to report lexing errors.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Error extends Exception {
+		private final int position;
+
+		public Error(java.lang.String msg, int position) {
+			super(msg);
+			this.position = position;
+		}
+
+		public int getPosition() {
+			return position;
+		}
+	}
+}
diff --git a/modules/wybs/src/wycc/io/Token.java b/modules/wybs/src/wycc/io/Token.java
new file mode 100755
index 0000000000..f9923024cb
--- /dev/null
+++ b/modules/wybs/src/wycc/io/Token.java
@@ -0,0 +1,268 @@
+package wycc.io;
+
+import java.math.BigInteger;
+
+/**
+ * An abstract notion representing a single token in the token stream produced
+ * by lexing a given input stream. A number of standard token kinds are also
+ * provided.
+ *
+ * @author David J. Pearce
+ *
+ */
+public abstract class Token {
+	public final java.lang.String text;
+	public final int start;
+
+	public Token(java.lang.String text, int pos) {
+		this.text = text;
+		this.start = pos;
+	}
+
+	/**
+	 * Get the last position in the original stream which contains a
+	 * character from this token.
+	 *
+	 * @return
+	 */
+	public int end() {
+		return start + text.length() - 1;
+	}
+
+	public java.lang.String toString() {
+		return "token:" + start + ": \"" + text + "\"";
+	}
+
+	// ===================================================================
+	// Standard Tokens
+	// ===================================================================
+
+
+	/**
+	 * Whitespace represents denotes the unused portions of the source file
+	 * which lie between the significant tokens.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public abstract static class Whitespace extends Token {
+		public Whitespace(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * Denotes a new line in the source file.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class NewLine extends Whitespace {
+		public NewLine(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * Denotes a sequence of one or more space characters
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Spaces extends Whitespace {
+		public Spaces(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * Denotes a sequence of one or more tab characters
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Tabs extends Whitespace {
+		public Tabs(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * An identifier is a token representing a sequence of (typically)
+	 * alpha-numeric characters, which starts with an alphabetic character.
+	 * Identifiers are commonly used for variable names, function names, etc.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Identifier extends Token {
+		public Identifier(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * A keyword is similar to an identifier which has been marked out as having
+	 * special significance. Keywords are commonly used in programming languages
+	 * to denote important structures (e.g. for-loops, if-conditions, etc).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Keyword extends Token {
+		public Keyword(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * A comment represents a section of the source file which should be
+	 * effectively ignored (at least, from the perspective of semantics).
+	 *
+	 * @author David J. Perarce
+	 *
+	 */
+	public static abstract class Comment extends Token {
+		public Comment(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * A line comment represents a comment which spans to the end of the current
+	 * line.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class LineComment extends Comment {
+		public LineComment(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * A block comment represents a comment which potentially spans several
+	 * lines of the source file.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class BlockComment extends Comment {
+		public BlockComment(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+
+	/**
+	 * Represents a string which begins and ends with double quotes.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class String extends Token {
+		public String(java.lang.String text, int pos) {
+			super(text, pos);
+		}
+	}
+
+	/**
+	 * Represents a single character which begins and ends with single quotes.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Char extends Token {
+		public final char character;
+
+		public Char(char c, java.lang.String text, int pos) {
+			super(text, pos);
+			this.character = c;
+		}
+	}
+
+	/**
+	 * A number which consists of an integer of unbounded size, followed by an
+	 * (optional) second integer of unbounded size separated by a decimal point.
+	 * This token additionally records the base in which the numbers were
+	 * represented (e.g. base 10, or base 16).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Number extends Token {
+		public final int base;
+		public final BigInteger beforePoint;
+		public final BigInteger afterPoint;
+
+		/**
+		 * Construct a token representing a decimal number represented in a
+		 * given base.
+		 *
+		 * @param base
+		 *            --- Must be greater than 1. Examples include decimal (base
+		 *            10), hexadecimal (base 16), Octogal (base 8) and Binary
+		 *            (base 2).
+		 * @param beforePoint
+		 *            --- the integer component occurring before (i.e. to the
+		 *            left of) the decimal point.
+		 * @param afterPoint
+		 *            --- the integer component occurring after (i.e. to the
+		 *            right of) the decimal point. This will be <code>null</code>
+		 *            if there was no decimal point.
+		 * @param text
+		 *            --- the actual text of the number.
+		 * @param pos
+		 *            --- the position.
+		 */
+		public Number(int base, BigInteger beforePoint, BigInteger afterPoint,
+				java.lang.String text, int pos) {
+			super(text, pos);
+			this.beforePoint = beforePoint;
+			this.afterPoint = afterPoint;
+			this.base = base;
+		}
+	}
+
+	/**
+	 * Represents an operator symbol, which may consist of 1 or more characters.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Operator extends Token {
+		public Operator(java.lang.String text, int pos) { super(text,pos);	}
+	}
+
+	public static final char UC_FORALL = '\u2200';
+	public static final char UC_EXISTS = '\u2203';
+	public static final char UC_EMPTYSET = '\u2205';
+	public static final char UC_SUBSET = '\u2282';
+	public static final char UC_SUBSETEQ = '\u2286';
+	public static final char UC_SUPSET = '\u2283';
+	public static final char UC_SUPSETEQ = '\u2287';
+	public static final char UC_SETUNION = '\u222A';
+	public static final char UC_SETINTERSECTION = '\u2229';
+	public static final char UC_LESSEQUALS = '\u2264';
+	public static final char UC_GREATEREQUALS = '\u2265';
+	public static final char UC_ELEMENTOF = '\u2208';
+	public static final char UC_LOGICALAND = '\u2227';
+	public static final char UC_LOGICALOR = '\u2228';
+
+	public static final java.lang.String sUC_FORALL = "" + UC_FORALL;
+	public static final java.lang.String sUC_EXISTS = "" + UC_EXISTS;
+	public static final java.lang.String sUC_EMPTYSET = "" + UC_EMPTYSET;
+	public static final java.lang.String sUC_SUBSET = "" + UC_SUBSET;
+	public static final java.lang.String sUC_SUBSETEQ = "" + UC_SUBSETEQ;
+	public static final java.lang.String sUC_SUPSET = "" + UC_SUPSET;
+	public static final java.lang.String sUC_SUPSETEQ = "" + UC_SUPSETEQ;
+	public static final java.lang.String sUC_SETUNION = "" + UC_SETUNION;
+	public static final java.lang.String sUC_SETINTERSECTION = "" + UC_SETINTERSECTION;
+	public static final java.lang.String sUC_LESSEQUALS = "" + UC_LESSEQUALS;
+	public static final java.lang.String sUC_GREATEREQUALS = "" + UC_GREATEREQUALS;
+	public static final java.lang.String sUC_ELEMENTOF = "" + UC_ELEMENTOF;
+	public static final java.lang.String sUC_LOGICALAND = "" + UC_LOGICALAND;
+	public static final java.lang.String sUC_LOGICALOR = "" + UC_LOGICALOR;
+
+}
\ No newline at end of file
diff --git a/modules/wybs/src/wycc/lang/Attribute.java b/modules/wybs/src/wycc/lang/Attribute.java
new file mode 100755
index 0000000000..f559ce0648
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/Attribute.java
@@ -0,0 +1,87 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+/**
+ * Represents a piece of meta-information that may be associated with a WYIL
+ * bytecode or declaration. For example, the location of the element in the
+ * source code which generated this bytecode.
+ *
+ * @author David J. Pearce
+ *
+ */
+public interface Attribute {
+
+	/**
+	 * Represents a location in the source code of a Whiley Module. For example,
+	 * this may be the location which generated a particular bytecode, or the
+	 * location of a particular type declaration.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public final static class Source implements Attribute {
+		public final int start;	 // starting character index
+		public final int end;	 // end character index
+		public final int line;   // line number
+
+		public Source(int start, int end, int line) {
+			this.start = start;
+			this.end = end;
+			this.line = line;
+		}
+
+		public String toString() {
+			return "@" + start + ":" + end;
+		}
+	}
+
+	/**
+	 * Represents an originating source location for a given syntactic element.
+	 * This typically occurs if some element from one file is included in
+	 * another element from another file.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public final static class Origin implements Attribute {
+		public final String filename;
+		public final int start;	 // starting character index
+		public final int end;	 // end character index
+		public final int line;   // line number
+
+		public Origin(String filename, int start, int end, int line) {
+			this.filename = filename;
+			this.start = start;
+			this.end = end;
+			this.line = line;
+		}
+
+		public String toString() {
+			return filename + "@" + start + ":" + end;
+		}
+	}
+}
diff --git a/modules/wybs/src/wycc/lang/CompilationUnit.java b/modules/wybs/src/wycc/lang/CompilationUnit.java
new file mode 100755
index 0000000000..6a4c4dddc0
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/CompilationUnit.java
@@ -0,0 +1,14 @@
+package wycc.lang;
+
+import wyfs.lang.Path;
+
+public interface CompilationUnit {
+	/**
+	 * Get the path entry with which this compilation unit is associated. This
+	 * may be a physical file on disk, a binary image stored in a jar file or an
+	 * entry in a virtual file system.
+	 * 
+	 * @return
+	 */
+	public Path.Entry<? extends CompilationUnit> getEntry();
+}
diff --git a/modules/wybs/src/wycc/lang/NameID.java b/modules/wybs/src/wycc/lang/NameID.java
new file mode 100755
index 0000000000..04dfc2bec7
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/NameID.java
@@ -0,0 +1,86 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+
+/**
+ * A Name Identifier consists of a module, and a name within that module. The
+ * purpose of this is to provide a uniform way of referring to modules +
+ * names throughout the compiler.
+ *
+ * @author David J. Pearce
+ *
+ */
+public final class NameID {
+	private final Path.ID module;
+	private final String name;
+
+	public NameID(Path.ID module, String name) {
+		this.module = module;
+		this.name = name;
+	}
+
+	public String name() {
+		return name;
+	}
+
+	public Path.ID module() {
+		return module;
+	}
+
+	public String toString() {
+		return module + ":" + name;
+	}
+
+	public int hashCode() {
+		return name.hashCode() ^ module.hashCode();
+	}
+
+	public boolean equals(Object o) {
+		if (o instanceof NameID) {
+			NameID u = (NameID) o;
+			return u.module.equals(module) && u.name.equals(name);
+		}
+		return false;
+	}
+	
+	/**
+	 * Create a NameID from a string representation. This is of the form
+	 * "module/id:name".
+	 * 
+	 * @param str
+	 * @return
+	 */
+	public static NameID fromString(String str) {
+		int index = str.indexOf(':');
+		String module = str.substring(0, index);
+		String name = str.substring(index + 1);
+		return new NameID(Trie.fromString(module), name);
+	}
+}
diff --git a/modules/wybs/src/wycc/lang/Pipeline.java b/modules/wybs/src/wycc/lang/Pipeline.java
new file mode 100755
index 0000000000..2fac5177b9
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/Pipeline.java
@@ -0,0 +1,314 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+import java.io.PrintWriter;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+
+import wybs.lang.Builder;
+
+/**
+ * A Pipeline consists of a number of stages which are applied to the
+ * intermediate language (wyil). A pipeline is instantiated before being used to
+ * create an instance of Compiler.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class Pipeline<T extends CompilationUnit> {
+
+	/**
+	 * Identify transforms which are registered for use with the Whiley
+	 * Compiler.
+	 */
+	private static final ArrayList<Class<? extends Transform<?>>> transforms = new ArrayList();
+
+
+	/**
+	 * The list of stage templates which make up this pipeline. When the
+	 * pipeline is instantiated, these stages are instantiated.
+	 */
+	private final ArrayList<Template<T>> stages;
+
+	public Pipeline(List<Template<T>> stages) {
+		this.stages = new ArrayList<Template<T>>(stages);
+	}
+
+	/**
+	 * Set a specific option on a given pipeline stage. The previous value of
+	 * this option is returned, or null if there is none.
+	 *
+	 * @param clazz
+	 * @param name
+	 * @param value
+	 * @return
+	 */
+	public Object setOption(Class<? extends Transform> clazz, String name,
+			Object value) {
+		for (Template template : stages) {
+			if (template.clazz == clazz) {
+				Map<String,Object> options = template.options;
+				if(options == Collections.EMPTY_MAP) {
+					options = new HashMap<String,Object>();
+					template.options = options;
+				}
+				return options.put(name, value);
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Apply a list of modifiers in the order of appearance. Modifiers may
+	 * remove stages, add new stages or reconfigure existing stages.
+	 *
+	 * @param modifiers
+	 */
+	public void apply(List<Modifier> modifiers) {
+		for (Modifier p : modifiers) {
+			Class<? extends Transform> stage = lookupTransform(p.name);
+			if(stage == null) {
+				throw new IllegalArgumentException("invalid pipeline stage \"" + p.name + "\"");
+			}
+			switch(p.op) {
+			case APPEND:
+				stages.add(new Template(stage,p.options));
+				break;
+			case REPLACE:
+			{
+				int index = findTransform(lookupTransform(p.name));
+				stages.set(index,new Template(stage,p.options));
+				break;
+			}
+			case REMOVE:
+			{
+				int index = findTransform(lookupTransform(p.name));
+				stages.remove(index);
+				break;
+			}
+			}
+		}
+	}
+
+	/**
+	 * <p>The following instantiates a compiler pipeline starting from the default
+	 * pipeline and applying those modifiers requested.</p>
+	 * <p>The enclosing builder is passed to a given transform when it is
+	 * instantiated. In some special cases, a transform will want access to
+	 * files in the namespace. For example, to check that a particular method
+	 * exists, etc.</p>
+	 *
+	 * @param builder --- enclosing builder
+	 * @return
+	 */
+	public List<Transform<T>> instantiate(Builder builder) {
+		ArrayList<Transform<T>> pipeline = new ArrayList<Transform<T>>();
+		for (Template<T> s : stages) {
+			pipeline.add(s.instantiate(builder));
+		}
+		return pipeline;
+	}
+
+	/**
+	 * A template is an uninstantiated pipeline stage. This contains all of the
+	 * necessary information to instantiate the stage.
+	 *
+	 * @author David J. Pearce
+	 */
+	public static class Template<T extends CompilationUnit> {
+		public final Class<? extends Transform<T>> clazz;
+		public Map<String,Object> options;
+
+		public Template(Class<? extends Transform<T>> clazz,
+				Map<String, Object> options) {
+			this.clazz = clazz;
+			this.options = options;
+		}
+
+		/**
+		 * Construct an instance of a given compiler stage, using the given argument
+		 * list. A constructor which accepts a ModuleLoader, and Map<String,String>
+		 * arguments will be called. If such a constructor doesn't exist, an
+		 * exception will be raised.
+		 *
+		 * @return
+		 */
+		public Transform<T> instantiate(Builder builder) {
+			Transform<T> stage;
+
+			// first, instantiate the transform
+			try {
+				Constructor<? extends Transform> c = clazz.getConstructor(
+						Builder.class);
+				stage = (Transform) c.newInstance(builder);
+
+			} catch (NoSuchMethodException e) {
+				throw new IllegalArgumentException(
+						"failed to instantiate transform \""
+								+ clazz.getSimpleName() + "\"",e);
+			} catch (InstantiationException e) {
+				throw new IllegalArgumentException(
+						"failed to instantiate transform \""
+								+ clazz.getSimpleName() + "\"",e);
+			} catch (InvocationTargetException e) {
+				throw new IllegalArgumentException(
+						"failed to instantiate transform \""
+								+ clazz.getSimpleName() + "\"",e);
+			} catch (IllegalAccessException e) {
+				throw new IllegalArgumentException(
+						"failed to instantiate transform \""
+								+ clazz.getSimpleName() + "\"",e);
+			}
+
+
+			// second, configure the instance
+			String attribute = "";
+			try {
+				for (Map.Entry<String, Object> e : options.entrySet()) {
+					attribute = e.getKey();
+					String name = "set" + capitalise(e.getKey());
+					Object value = e.getValue();
+					Method m;
+					if(value instanceof Boolean) {
+						m = clazz.getDeclaredMethod(name, boolean.class);
+					} else if(value instanceof Integer) {
+						m = clazz.getDeclaredMethod(name, int.class);
+					} else if(value instanceof Long) {
+						m = clazz.getDeclaredMethod(name, long.class);
+					} else {
+						// default
+						m = clazz.getDeclaredMethod(name, value.getClass());
+					}
+					m.invoke(stage, value);
+				}
+			} catch (NoSuchMethodException e) {
+				throw new IllegalArgumentException("failed to set attribute \""
+						+ attribute + "\" on transform \""
+						+ clazz.getSimpleName() + "\"",e);
+			} catch(InvocationTargetException e) {
+				throw new IllegalArgumentException("failed to set attribute \""
+						+ attribute + "\" on transform \""
+						+ clazz.getSimpleName() + "\"",e);
+			} catch(IllegalAccessException e) {
+				throw new IllegalArgumentException("failed to set attribute \""
+						+ attribute + "\" on transform \""
+						+ clazz.getSimpleName() + "\"",e);
+			}
+
+			return stage;
+		}
+	}
+
+	/**
+	 * Make the first letter of the string a captial.
+	 * @param str
+	 * @return
+	 */
+	private static String capitalise(String str) {
+		String rest = str.substring(1);
+		char c = Character.toUpperCase(str.charAt(0));
+		return c + rest;
+	}
+
+	/**
+	 * The pipeline modifier captures a requested adjustment to the compilation
+	 * pipeline.
+	 *
+	 * @author David J. Pearce
+	 */
+	public static class Modifier {
+		public final POP op;
+		public final String name;
+		public final Map<String,Object> options;
+
+		public Modifier(POP pop, String name, Map<String, Object> options) {
+			this.op = pop;
+			this.name = name;
+			this.options = options;
+		}
+	}
+
+	public enum POP {
+		APPEND,
+		BEFORE,
+		AFTER,
+		REPLACE,
+		REMOVE
+	}
+
+	/**
+	 * Search through the pipeline looking form the first matching stage.
+	 *
+	 * @param match
+	 * @return
+	 */
+	private int findTransform(Class<? extends Transform> match) {
+		int i = 0;
+		for (Template stage : stages) {
+			if (stage.clazz == match) {
+				return i;
+			}
+			++i;
+		}
+		throw new IllegalArgumentException("invalid stage name \"" + match
+				+ "\"");
+	}
+
+	/**
+	 * Register a transform with the system, in order that it can be used in a
+	 * given Pipeline. This is particularly useful because it allows transforms
+	 * to be referred to by abbreviations in pipeline modifiers.
+	 *
+	 * @param transform
+	 */
+	public static <S extends CompilationUnit> void register(
+			Class<? extends Transform<S>> transform) {
+		transforms.add(transform);
+	}
+
+	/**
+	 * Lookup a transform in the list of registered transforms. This matches the
+	 * given name again the class names of registered transforms. The matching
+	 * of names is case-insensitive and will also match a substring.
+	 *
+	 * @param name
+	 * @return
+	 */
+	public static Class<? extends Transform> lookupTransform(String name) {
+		name = name.toLowerCase();
+		for (Class<? extends Transform> t : transforms) {
+			String tn = t.getSimpleName().toLowerCase();
+			if (tn.startsWith(name)) {
+				return t;
+			}
+		}
+		throw new IllegalArgumentException("no transform matching \"" + name
+				+ "\"");
+	}
+}
diff --git a/modules/wybs/src/wycc/lang/SyntacticElement.java b/modules/wybs/src/wycc/lang/SyntacticElement.java
new file mode 100755
index 0000000000..facfe966ac
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/SyntacticElement.java
@@ -0,0 +1,91 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * A Syntactic Element represents any part of a source file which is relevant to
+ * the syntactic structure of the file, and in particular parts we may wish to
+ * add information too (e.g. line numbers, types, etc).
+ *
+ * @author David J. Pearce
+ *
+ */
+public interface SyntacticElement {
+
+	/**
+     * Get the list of attributes associated with this syntactice element.
+     *
+     * @return
+     */
+	public List<Attribute> attributes();
+
+	/**
+     * Get the first attribute of the given class type. This is useful
+     * short-hand.
+     *
+     * @param c
+     * @return
+     */
+	public <T extends Attribute> T attribute(Class<T> c);
+
+	public class Impl  implements SyntacticElement {
+		private List<Attribute> attributes;
+
+		public Impl() {
+			// I use copy on write here, since for the most part I don't expect
+			// attributes to change, and hence can be safely aliased. But, when they
+			// do change I need fresh copies.
+			attributes = new CopyOnWriteArrayList<Attribute>();
+		}
+
+		public Impl(Attribute x) {
+			attributes = new ArrayList<Attribute>();
+			attributes.add(x);
+		}
+
+		public Impl(Collection<Attribute> attributes) {
+			this.attributes = new ArrayList<Attribute>(attributes);
+		}
+
+		public Impl(Attribute[] attributes) {
+			this.attributes = new ArrayList<Attribute>(Arrays.asList(attributes));
+		}
+
+		public List<Attribute> attributes() { return attributes; }
+
+		public <T extends Attribute> T attribute(Class<T> c) {
+			for(Attribute a : attributes) {
+				if(c.isInstance(a)) {
+					return (T) a;
+				}
+			}
+			return null;
+		}
+	}
+}
diff --git a/modules/wybs/src/wycc/lang/SyntaxError.java b/modules/wybs/src/wycc/lang/SyntaxError.java
new file mode 100755
index 0000000000..b9dbe6980a
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/SyntaxError.java
@@ -0,0 +1,294 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintStream;
+
+import wyfs.lang.Path;
+
+/**
+ * This exception is thrown when a syntax error occurs in the parser.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class SyntaxError extends RuntimeException {
+	/**
+	 * The file entry to which this error applies
+	 */
+	private Path.Entry<?> entry;
+	
+	/**
+	 * The SyntacticElement to which this error refers
+	 */
+	private SyntacticElement element;
+
+	/**
+	 * Identify a syntax error at a particular point in a file.
+	 *
+	 * @param msg
+	 *            Message detailing the problem.
+	 * @param entry
+	 *            The path entry for the compilation unit this error refers to
+	 * @param element
+	 *            The syntactic element to this error refers 
+	 */
+	public SyntaxError(String msg, Path.Entry<?> entry, SyntacticElement element) {
+		super(msg);
+		this.entry = entry;
+		this.element = element;
+	}
+
+	/**
+	 * Identify a syntax error at a particular point in a file.
+	 *
+	 * @param msg
+	 *            Message detailing the problem.
+	 * @param entry
+	 *            The path entry for the compilation unit this error refers to
+	 * @param element
+	 *            The syntactic element to this error refers
+	 */
+	public SyntaxError(String msg, Path.Entry<?> entry, SyntacticElement element, Throwable ex) {
+		super(msg,ex);
+		this.entry = entry;
+		this.element = element;
+	}
+
+	/**
+	 * Get the syntactic element to which this error is attached.
+	 * 
+	 * @return
+	 */
+	public SyntacticElement getElement() {
+		return element;
+	}
+	
+	/**
+	 * Output the syntax error to a given output stream in full form. In full
+	 * form, contextual information from the originating source file is
+	 * included.
+	 */
+	public void outputSourceError(PrintStream output) {
+		outputSourceError(output,true);
+	}
+
+	/**
+	 * Output the syntax error to a given output stream in either full or brief
+	 * form. Brief form is intended to be used by 3rd party tools and is easier
+	 * to parse. In full form, contextual information from the originating
+	 * source file is included.
+	 */
+	public void outputSourceError(PrintStream output, boolean brief) {
+		if (entry == null) {
+			output.println("syntax error: " + getMessage());
+		} else {
+			EnclosingLine enclosing = readEnclosingLine(entry, element.attribute(Attribute.Source.class));
+			if(enclosing == null) {
+				output.println("syntax error: " + getMessage());
+			} else if(brief) {
+				printBriefError(output,entry,enclosing,getMessage());
+			} else {
+				printFullError(output,entry,enclosing,getMessage());
+			}
+		}
+	}
+
+	private void printBriefError(PrintStream output, Path.Entry<?> entry, EnclosingLine enclosing, String message) {
+		output.print(entry.location() + ":" + enclosing.lineNumber + ":"
+				+ enclosing.columnStart() + ":"
+				+ enclosing.columnEnd() + ":\""
+				+ escapeMessage(message) + "\"");
+
+		// Now print contextual information (if applicable)
+//		if(context != null && context.length > 0) {
+//			output.print(":");
+//			boolean firstTime=true;
+//			for(Attribute.Origin o : context) {
+//				if(!firstTime) {
+//					output.print(",");
+//				}
+//				firstTime=false;
+//				enclosing = readEnclosingLine(o.filename, o.start, o.end);
+//				output.print(filename + ":" + enclosing.lineNumber + ":"
+//						+ enclosing.columnStart() + ":"
+//						+ enclosing.columnEnd());
+//			}
+//		}
+
+		// Done
+		output.println();
+	}
+
+	private void printFullError(PrintStream output, Path.Entry<?> entry, EnclosingLine enclosing, String message) {
+		
+		output.println(entry.location() + ":" + enclosing.lineNumber + ": " + message);
+
+		printLineHighlight(output,enclosing);
+
+		// Now print contextual information (if applicable)
+//		if(context != null && context.length > 0) {
+//			for(Attribute.Origin o : context) {
+//				output.println();
+//				enclosing = readEnclosingLine(o.filename, o.start, o.end);
+//				output.println(o.filename + ":" + enclosing.lineNumber + " (context)");
+//				printLineHighlight(output,enclosing);
+//			}
+//		}
+	}
+
+	private void printLineHighlight(PrintStream output,
+			EnclosingLine enclosing) {
+		// NOTE: in the following lines I don't print characters
+		// individually. The reason for this is that it messes up the
+		// ANT task output.
+		String str = enclosing.lineText;
+
+		if (str.length() > 0 && str.charAt(str.length() - 1) == '\n') {
+			output.print(str);
+		} else {
+			// this must be the very last line of output and, in this
+			// particular case, there is no new-line character provided.
+			// Therefore, we need to provide one ourselves!
+			output.println(str);
+		}
+		str = "";
+		for (int i = 0; i < enclosing.columnStart(); ++i) {
+			if (enclosing.lineText.charAt(i) == '\t') {
+				str += "\t";
+			} else {
+				str += " ";
+			}
+		}
+		for (int i = enclosing.columnStart(); i <= enclosing.columnEnd(); ++i) {
+			str += "^";
+		}
+		output.println(str);
+	}
+
+	private static int parseLine(StringBuilder buf, int index) {
+		while (index < buf.length() && buf.charAt(index) != '\n') {
+			index++;
+		}
+		return index + 1;
+	}
+
+	private static class EnclosingLine {
+		private int lineNumber;
+		private int start;
+		private int end;
+		private int lineStart;
+		private int lineEnd;
+		private String lineText;
+
+		public EnclosingLine(int start, int end, int lineNumber, int lineStart, int lineEnd, String lineText) {
+			this.start = start;
+			this.end = end;
+			this.lineNumber = lineNumber;
+			this.lineStart = lineStart;
+			this.lineEnd = lineEnd;
+			this.lineText = lineText;
+		}
+
+		public int columnStart() {
+			return start - lineStart;
+		}
+
+		public int columnEnd() {
+			return Math.min(end, lineEnd) - lineStart;
+		}
+	}
+
+	private static EnclosingLine readEnclosingLine(Path.Entry<?> entry, Attribute.Source location) {
+		int line = 0;
+		int lineStart = 0;
+		int lineEnd = 0;
+		StringBuilder text = new StringBuilder();
+		try {
+			BufferedReader in = new BufferedReader(new InputStreamReader(entry.inputStream(), "UTF-8"));
+
+			// first, read whole file
+			int len = 0;
+			char[] buf = new char[1024];
+			while ((len = in.read(buf)) != -1) {
+				text.append(buf, 0, len);
+			}
+
+			while (lineEnd < text.length() && lineEnd <= location.start) {
+				lineStart = lineEnd;
+				lineEnd = parseLine(text, lineEnd);
+				line = line + 1;
+			}
+		} catch (IOException e) {
+			return null;
+		}
+		lineEnd = Math.min(lineEnd, text.length());
+
+		return new EnclosingLine(location.start, location.end, line, lineStart, lineEnd,
+				text.substring(lineStart, lineEnd));
+	}
+
+	public static final long serialVersionUID = 1l;
+
+	/**
+	 * An internal failure is a special form of syntax error which indicates
+	 * something went wrong whilst processing some piece of syntax. In other
+	 * words, is an internal error in the compiler, rather than a mistake in the
+	 * input program.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class InternalFailure extends SyntaxError {
+		public InternalFailure(String msg, Path.Entry<? extends CompilationUnit> entry, SyntacticElement element) {
+			super(msg, entry, element);
+		}
+
+		public InternalFailure(String msg, Path.Entry<? extends CompilationUnit> entry, SyntacticElement element,
+				Throwable ex) {
+			super(msg, entry, element, ex);
+		}
+
+		public String getMessage() {
+			String msg = super.getMessage();
+			if (msg == null || msg.equals("")) {
+				return "internal failure";
+			} else {
+				return "internal failure, " + msg;
+			}
+		}
+	}
+	
+	private static String escapeMessage(String message) {
+		message = message.replace("\n", "\\n");
+		message = message.replace("\"", "\\\"");
+		return message;
+	}
+
+}
diff --git a/modules/wybs/src/wycc/lang/Transform.java b/modules/wybs/src/wycc/lang/Transform.java
new file mode 100755
index 0000000000..2b14eb7e2c
--- /dev/null
+++ b/modules/wybs/src/wycc/lang/Transform.java
@@ -0,0 +1,53 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.lang;
+
+import java.io.IOException;
+
+
+/**
+ * Represents an action that may be applied to a module. Such actions typically
+ * either check that a module is valid (with respect to some particular
+ * concern), or apply optimisations to the module. Examples include <i>constant
+ * propagation</i> and <i>definite assignment analysis</i>.
+ *
+ * @author David J. Pearce
+ *
+ */
+public interface Transform<T extends CompilationUnit> {
+
+	/**
+	 * Apply this transform to the given module. Modifications are made to the
+	 * module in-place. To easy integration with other frameworks (e.g.
+	 * Eclipse), any exception may be thrown.
+	 *
+	 * @param file
+	 *            --- compilation unit to be transformed
+	 * @throws Exception
+	 *             --- some kind of failure occurred.
+	 */
+	public void apply(T file) throws IOException;
+}
diff --git a/modules/wybs/src/wycc/util/AbstractCompilationUnit.java b/modules/wybs/src/wycc/util/AbstractCompilationUnit.java
new file mode 100755
index 0000000000..2b274cbd6b
--- /dev/null
+++ b/modules/wybs/src/wycc/util/AbstractCompilationUnit.java
@@ -0,0 +1,18 @@
+package wycc.util;
+
+import wycc.lang.CompilationUnit;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+
+public class AbstractCompilationUnit<T extends CompilationUnit> implements CompilationUnit {
+	protected final Path.Entry<T> entry;
+	
+	public AbstractCompilationUnit(Path.Entry<T> entry) {
+		this.entry = entry;
+	}
+
+	@Override
+	public Entry<T> getEntry() {
+		return entry;
+	}
+}
diff --git a/modules/wybs/src/wycc/util/Logger.java b/modules/wybs/src/wycc/util/Logger.java
new file mode 100755
index 0000000000..ebd7fa19c7
--- /dev/null
+++ b/modules/wybs/src/wycc/util/Logger.java
@@ -0,0 +1,126 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.util;
+
+import java.io.PrintStream;
+
+/**
+ * Provides a standard interface for logging messages generated by builders.
+ * This includes syntax errors, warnings and miscellaneous debugging output.
+ *
+ * @author David J. Pearce
+ */
+public interface Logger {
+
+	/**
+	 * Log a message, along with a time. The time is used to indicate how long
+	 * it took for the action being reported. This is used primarily to signal
+	 * that a given stage has been completed in a certain amount of time.
+	 *
+	 * @param msg
+	 * @param time --- total time taken for stage
+     * @param time --- difference in available free memory
+	 */
+	public void logTimedMessage(String msg, long time, long memory);
+
+	/**
+	 * The NULL logger simply drops all logged messages. It's a simple, albeit
+	 * not that helpful, default.
+	 */
+	public static final Logger NULL = new Logger() {
+		public void logTimedMessage(String msg, long time, long memory) {
+			// do nothing.
+		}
+	};
+
+	/**
+	 * A simple implementation of <code>Logger</code> which writes to a given
+	 * <code>PrintStream</code>.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Default implements Logger {
+		private PrintStream logout;
+
+		public Default(PrintStream out) {
+			logout=out;
+		}
+		/**
+		 * This method is just a helper to format the output
+		 */
+		public void logTimedMessage(String msg, long time, long memory) {
+			logout.print(msg);
+			logout.print(" ");
+			double mem = memory;
+			mem = mem / (1024*1024);
+			memory = (long) mem;
+			String stats = " [" + Long.toString(time) + "ms";
+			if(memory > 0) {
+				stats += "+" + Long.toString(memory) + "mb]";
+			} else if(memory < 0) {
+				stats += Long.toString(memory) + "mb]";
+			} else {
+				stats += "]";
+			}
+			for (int i = 0; i < (90 - msg.length() - stats.length()); ++i) {
+				logout.print(".");
+			}
+			logout.println(stats);
+		}
+
+		public void logTotalTime(String msg, long time, long memory) {
+			memory = memory / 1024;
+
+			for (int i = 0; i <= 90; ++i) {
+				logout.print("=");
+			}
+
+			logout.println();
+
+			logout.print(msg);
+			logout.print(" ");
+
+			double mem = memory;
+			mem = mem / (1024*1024);
+			memory = (long) mem;
+			String stats = " [" + Long.toString(time) + "ms";
+			if(memory > 0) {
+				stats += "+" + Long.toString(memory) + "mb]";
+			} else if(memory < 0) {
+				stats += Long.toString(memory) + "mb]";
+			} else {
+				stats += "]";
+			}
+
+			for (int i = 0; i < (90 - msg.length() - stats.length()); ++i) {
+				logout.print(".");
+			}
+
+			logout.println(stats);
+		}
+	};
+}
diff --git a/modules/wybs/src/wycc/util/OptArg.java b/modules/wybs/src/wycc/util/OptArg.java
new file mode 100755
index 0000000000..b768816e5d
--- /dev/null
+++ b/modules/wybs/src/wycc/util/OptArg.java
@@ -0,0 +1,432 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.util;
+
+import java.io.File;
+import java.io.PrintStream;
+import java.util.*;
+
+import wycc.lang.Pipeline;
+import static wycc.lang.Pipeline.*;
+
+/**
+ * A small utility for parsing command-line options. It helps to take some of
+ * the hassle out of building the front-end of a Whiley compiler.
+ *
+ * @author David J. Pearce
+ *
+ */
+public final class OptArg {
+	/**
+	 * The long form of the option. (e.g. for "-version", the long form is
+	 * "version")
+	 */
+	public final String option;
+
+	/**
+	 * The short form of the option. (e.g. for "-version", the short form might
+	 * be "v" as in "-v")
+	 */
+	public final String shortForm;
+
+	/**
+	 * The kind of argument accepted by this option (if any).
+	 */
+	public final Kind argument;
+
+	/**
+	 * A description of the option. This is used when printing out "usage"
+	 * information.
+	 */
+	public final String description;
+
+	/**
+	 * A default value for the option (assuming it accepts an argument). This
+	 * may be null if there is no default value.
+	 */
+	public final Object defaultValue;
+
+	/**
+	 * Construct an option object which does not accept an argument.
+	 *
+	 * @param option
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option,String description) {
+		this.option = option;
+		this.shortForm = null;
+		this.argument = null;
+		this.description = description;
+		this.defaultValue = null;
+	}
+
+	/**
+	 * Construct an option object with a short form which does not accept an argument.
+	 *
+	 * @param option
+	 * @param shortForm
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option,String shortForm, String description) {
+		this.option = option;
+		this.shortForm = shortForm;
+		this.argument = null;
+		this.description = description;
+		this.defaultValue = null;
+	}
+
+	/**
+	 * Construct an option object which accepts an argument.
+	 *
+	 * @param option
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option, Kind argument,
+			String description) {
+		this.option = option;
+		this.shortForm = null;
+		this.argument = argument;
+		this.description = description;
+		this.defaultValue = null;
+	}
+
+	/**
+	 * Construct an option object with a short form which accepts an argument.
+	 *
+	 * @param option
+	 * @param shortForm
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option, String shortForm, Kind argument,
+			String description) {
+		this.option = option;
+		this.shortForm = shortForm;
+		this.argument = argument;
+		this.description = description;
+		this.defaultValue = null;
+	}
+
+	/**
+	 * Construct an option object which accepts an argument and has a default value.
+	 *
+	 * @param option
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option, Kind argument,
+			String description, Object defaultValue) {
+		this.option = option;
+		this.shortForm = null;
+		this.argument = argument;
+		this.description = description;
+		this.defaultValue = defaultValue;
+	}
+
+	/**
+	 * Construct an option object with a short form which accepts an argument and has a default value.
+	 *
+	 * @param option
+	 * @param argument
+	 * @param description
+	 * @param defaultValue
+	 */
+	public OptArg(String option, String shortForm, Kind argument,
+			String description, Object defaultValue) {
+		this.option = option;
+		this.shortForm = shortForm;
+		this.argument = argument;
+		this.description = description;
+		this.defaultValue = defaultValue;
+	}
+
+	interface Kind {
+		void process(String arg, String option, Map<String,Object> options);
+	}
+
+	public final static STRING STRING = new STRING();
+	public final static INT INT = new INT();
+	public final static FILE FILE = new FILE();
+	public final static FILEDIR FILEDIR = new FILEDIR();
+	public final static FILELIST FILELIST = new FILELIST();
+	public final static PIPELINEAPPEND PIPELINEAPPEND = new PIPELINEAPPEND();
+	public final static PIPELINECONFIGURE PIPELINECONFIGURE = new PIPELINECONFIGURE();
+	public final static PIPELINEREMOVE PIPELINEREMOVE = new PIPELINEREMOVE();
+
+	private static final class STRING implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			options.put(arg,option);
+		}
+		public String toString() {
+			return "<string>";
+		}
+	}
+
+	private static final class INT implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			options.put(arg,Integer.parseInt(option));
+		}
+		public String toString() {
+			return "<int>";
+		}
+	}
+
+	private static final class FILE implements Kind {
+		public void process(String arg, String option,
+				Map<String, Object> options) {
+			options.put(arg, new File(option));
+		}
+		public String toString() {
+			return "<file>";
+		}
+	}
+
+	private static final class FILEDIR implements Kind {
+		public void process(String arg, String option,
+				Map<String, Object> options) {
+			File dir = new File(option);
+			if(!dir.isDirectory()) {
+				throw new IllegalArgumentException("invalid path --- " + arg);
+			}
+			options.put(arg, dir);
+		}
+		public String toString() {
+			return "<filedir>";
+		}
+	}
+
+	private static final class FILELIST implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			ArrayList<File> rs = new ArrayList<File>();
+			for(String r : option.split(File.pathSeparator)) {
+				rs.add(new File(r));
+			}
+			options.put(arg, rs);
+		}
+		public String toString() {
+			return "<filelist>";
+		}
+	}
+
+	private static final class PIPELINEAPPEND implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			String[] name = option.split(":");
+			Map<String, Object> config = Collections.EMPTY_MAP;
+			if (name.length > 1) {
+				config = splitConfig(name[1]);
+			}
+			Pipeline.Modifier pmod = new Pipeline.Modifier(POP.APPEND, name[0], config);
+			Object o = options.get("pipeline");
+			ArrayList<Pipeline.Modifier> val;
+			if(o == null) {
+				val = new ArrayList();
+			} else {
+				val = (ArrayList) o;
+			}
+			val.add(pmod);
+			options.put("pipeline",val);
+		}
+		public String toString() {
+			return "stage[:options]";
+		}
+	}
+
+	private static final class PIPELINECONFIGURE implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			String[] name = option.split(":");
+			Map<String, Object> config = Collections.EMPTY_MAP;
+			if (name.length > 1) {
+				config = splitConfig(name[1]);
+			}
+			Pipeline.Modifier pmod = new Pipeline.Modifier(POP.REPLACE, name[0], config);
+			Object o = options.get("pipeline");
+			ArrayList<Pipeline.Modifier> val;
+			if(o == null) {
+				val = new ArrayList();
+			} else {
+				val = (ArrayList) o;
+			}
+			val.add(pmod);
+			options.put("pipeline",val);
+		}
+		public String toString() {
+			return "stage[:options]";
+		}
+	}
+
+	private static final class PIPELINEREMOVE implements Kind {
+		public void process(String arg, String option, Map<String,Object> options) {
+			String[] name = option.split(":");
+			Pipeline.Modifier pmod = new Pipeline.Modifier(POP.REMOVE, name[0],
+					Collections.EMPTY_MAP);
+			Object o = options.get("pipeline");
+			ArrayList<Pipeline.Modifier> val;
+			if (o == null) {
+				val = new ArrayList();
+			} else {
+				val = (ArrayList) o;
+			}
+			val.add(pmod);
+			options.put("pipeline", val);
+		}
+		public String toString() {
+			return "stage[:options]";
+		}
+	}
+
+	/**
+	 * Parse options from the list of arguments, removing those which are
+	 * recognised. Anything which is not recognised is left as is.
+	 *
+	 * @param args
+	 *            --- the list of argument strings. This is modified by removing
+	 *            those which are processed.
+	 * @param options
+	 *            --- the list of OptArg defining which options should be
+	 *            processed
+	 * @throws --- a <code>RuntimeException</code> if an unrecognised option is
+	 *         encountered (that is, a token starting with '-')..
+	 */
+	public static Map<String,Object> parseOptions(List<String> args, OptArg... options) {
+		HashMap<String,Object> result = new HashMap<String,Object>();
+		HashMap<String,OptArg> optmap = new HashMap<String,OptArg>();
+
+		for(OptArg opt : options) {
+			if(opt.defaultValue != null) {
+				result.put(opt.option, opt.defaultValue);
+			}
+			optmap.put(opt.option, opt);
+			optmap.put(opt.shortForm, opt);
+		}
+
+		Iterator<String> iter = args.iterator();
+		while(iter.hasNext()) {
+			String arg = iter.next();
+			if (arg.startsWith("-")) {
+				arg = arg.substring(1,arg.length());
+				OptArg opt = optmap.get(arg);
+				if(opt != null) {
+					// matched
+					iter.remove(); // remove option from args list
+					Kind k = opt.argument;
+					if(k != null) {
+						String param = iter.next();
+						iter.remove();
+						k.process(opt.option,param,result);
+					} else {
+						result.put(opt.option,null);
+					}
+				} else {
+					throw new RuntimeException("unknown command-line option: -" + arg);
+				}
+			}
+		}
+
+		return result;
+	}
+
+	public static void usage(PrintStream output, OptArg...options) {
+		// first, work out gap information
+		int gap = 0;
+		ArrayList<OptArg> opts = new ArrayList();
+		for (OptArg opt : options) {
+			opts.add(opt);
+			int len = opt.option.length();
+			if(opt.argument != null) {
+				len = len + opt.argument.toString().length();
+			}
+			if(opt.shortForm != null) {
+				len = len + opt.shortForm.length();
+				opts.add(new OptArg(opt.shortForm,opt.argument,opt.description + " [short form]"));
+			}
+			gap = Math.max(gap, len);
+		}
+
+		gap = gap + 1;
+
+		// now, print the information
+		for (OptArg opt : opts) {
+			output.print("  -" + opt.option);
+			int rest = gap - opt.option.length();
+			output.print(" ");
+			if(opt.argument != null) {
+				String arg = opt.argument.toString();
+				rest -= arg.length();
+				output.print(arg);
+			}
+			for (int i = 0; i < rest; ++i) {
+				output.print(" ");
+			}
+			output.println(opt.description);
+		}
+	}
+
+	/**
+	 * This splits strings of the form "x=y,v=w" into distinct components and
+	 * puts them into a map. In the case of a string like "x,y=z" then x is
+	 * loaded with the empty string.
+	 *
+	 * @param str
+	 * @return
+	 */
+	private static Map<String, Object> splitConfig(String str) {
+		HashMap<String, Object> options = new HashMap<String, Object>();
+		String[] splits = str.split(",");
+		for (String s : splits) {
+			String[] p = s.split("=");
+			if (p.length == 1) {
+				options.put(p[0], Boolean.TRUE);
+			} else {
+				options.put(p[0], parseValue(p[1]));
+			}
+		}
+		return options;
+	}
+
+	private static Object parseValue(String str) {
+		if(str.equals("true")) {
+			return Boolean.TRUE;
+		} else if(str.equals("false")) {
+			return Boolean.FALSE;
+		} else if(Character.isDigit(str.charAt(0))) {
+			if(str.charAt(str.length()-1) == 'L') {
+				return Long.parseLong(str.substring(0,str.length()-1));
+			} else {
+				return Integer.parseInt(str);
+			}
+		} else  {
+			return str;
+		}
+	}
+}
diff --git a/modules/wybs/src/wycc/util/Pair.java b/modules/wybs/src/wycc/util/Pair.java
new file mode 100755
index 0000000000..01a6a28fca
--- /dev/null
+++ b/modules/wybs/src/wycc/util/Pair.java
@@ -0,0 +1,72 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.util;
+
+/**
+ * This class represents a pair of items
+ *
+ * @author David J. Pearce
+ *
+ * @param <FIRST> Type of first item
+ * @param <SECOND> Type of second item
+ */
+public class Pair<FIRST,SECOND> {
+	protected final FIRST first;
+	protected final SECOND second;
+
+	public Pair(FIRST f, SECOND s) {
+		first=f;
+		second=s;
+	}
+
+	public FIRST first() { return first; }
+	public SECOND second() { return second; }
+
+	public int hashCode() {
+		int fhc = first == null ? 0 : first.hashCode();
+		int shc = second == null ? 0 : second.hashCode();
+		return fhc ^ shc;
+	}
+
+	public boolean equals(Object o) {
+		if(o instanceof Pair) {
+			Pair<FIRST, SECOND> p = (Pair<FIRST, SECOND>) o;
+			boolean r = false;
+			if(first != null) { r = first.equals(p.first()); }
+			else { r = p.first() == first; }
+			if(second != null) { r &= second.equals(p.second()); }
+			else { r &= p.second() == second; }
+			return r;
+		}
+		return false;
+	}
+
+	public String toString() {
+		String fstr = first != null ? first.toString() : "null";
+		String sstr = second != null ? second.toString() : "null";
+		return "(" + fstr + ", " + sstr + ")";
+	}
+}
diff --git a/modules/wybs/src/wycc/util/ResolveError.java b/modules/wybs/src/wycc/util/ResolveError.java
new file mode 100755
index 0000000000..a2c1b30da3
--- /dev/null
+++ b/modules/wybs/src/wycc/util/ResolveError.java
@@ -0,0 +1,44 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.util;
+
+/**
+ * A resolve error is thrown by the ModuleLoader, when it was unable to resolve
+ * a given class or package. This generally indicates some kind of compile time
+ * error (e.g. trying to import from module that doesn't exist). However, it
+ * could also indicate that the WHILEYPATH is not configured correctly.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class ResolveError extends Exception {
+	public ResolveError(String msg) {
+		super(msg);
+	}
+	public ResolveError(String msg, Throwable ex) {
+		super(msg,ex);
+	}
+}
diff --git a/modules/wybs/src/wycc/util/Triple.java b/modules/wybs/src/wycc/util/Triple.java
new file mode 100755
index 0000000000..ae80eadd78
--- /dev/null
+++ b/modules/wybs/src/wycc/util/Triple.java
@@ -0,0 +1,76 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycc.util;
+
+
+/**
+ * This class represents a triple of items
+ *
+ * @author David J. Pearce
+ *
+ * @param <FIRST> Type of first item
+ * @param <SECOND> Type of second item
+ * @param <THIRD> Type of second item
+ */
+public class Triple<FIRST,SECOND,THIRD> extends Pair<FIRST,SECOND> {
+	public THIRD third;
+
+	public Triple(FIRST f, SECOND s, THIRD t) {
+		super(f,s);
+		third=t;
+	}
+
+	public THIRD third() { return third; }
+
+	public int hashCode() {
+		int phc = super.hashCode();
+		int thc = third == null ? 0 : third.hashCode();
+		return phc ^ thc;
+	}
+
+	public boolean equals(Object o) {
+		if(o instanceof Triple) {
+			@SuppressWarnings("unchecked")
+			Triple<FIRST,SECOND,THIRD> p = (Triple<FIRST,SECOND,THIRD>) o;
+			boolean r=false;
+			if(first() != null) { r = first().equals(p.first()); }
+			else { r = p.first() == first(); }
+			if(second() != null) { r &= second().equals(p.second()); }
+			else { r &= p.second() == second(); }
+			if(third != null) { r &= third.equals(p.third()); }
+			else { r &= p.third() == third; }
+			return r;
+		}
+		return false;
+	}
+
+	public String toString() {
+		String f = first() == null ? "null" : first().toString();
+		String s = second() == null ? "null" : second().toString();
+		String t = third == null ? "null" : third.toString();
+		return "(" + f + "," + s + "," + t + ")";
+	}
+}
diff --git a/modules/wybs/src/wyfs/io/BinaryInputStream.java b/modules/wybs/src/wyfs/io/BinaryInputStream.java
new file mode 100755
index 0000000000..fce00fe2f5
--- /dev/null
+++ b/modules/wybs/src/wyfs/io/BinaryInputStream.java
@@ -0,0 +1,119 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.io;
+
+import java.io.*;
+
+public class BinaryInputStream extends InputStream {
+	protected InputStream input;
+	protected int value;
+	protected int count;
+
+	public BinaryInputStream(InputStream input) {
+		this.input = input;
+	}
+
+	public int read() throws IOException {
+		if(count == 0) {
+			return input.read();
+		} else {
+			return read_un(8);
+		}
+	}
+
+	public int read(byte[] bytes) throws IOException {
+		for (int i = 0; i != bytes.length; ++i) {
+			bytes[i] = (byte) read();
+		}
+		return bytes.length;
+	}
+
+	public int read(byte[] bytes, int offset, int length) throws IOException {
+		for(;offset < length;++offset) {
+			bytes[offset] = (byte) read();
+		}
+		return length;
+	}
+
+	public int read_u8() throws IOException {
+		if(count == 0) {
+			return input.read() & 0xFF;
+		} else {
+			return read_un(8);
+		}
+	}
+
+	public int read_u16() throws IOException {
+		return (read_u8() << 8) | read_u8();
+	}
+
+	public long read_u32() throws IOException {
+		// FIXME: this is most definitely broken
+		return (read_u8() << 24) | (read_u8() << 16) | (read_u8() << 8)
+				| read_u8();
+	}
+
+	public int read_un(int n) throws IOException {
+		int value = 0;
+		int mask = 1;
+		for(int i=0;i!=n;++i) {
+			if(read_bit()) {
+				value |= mask;
+			}
+			mask = mask << 1;
+		}
+		return value;
+	}
+
+	public int read_uv() throws IOException {
+		int value = 0;
+		boolean flag = true;
+		int shift = 0;
+		while(flag) {
+			int w = read_un(4);
+			flag = (w&8) != 0;
+			value = ((w&7)<<shift) | value;
+			shift = shift + 3;
+		}
+		return value;
+	}
+
+	public boolean read_bit() throws IOException {
+		if(count == 0) {
+			value = input.read();
+			if(value < 0) { throw new EOFException(); }
+			count = 8;
+		}
+		boolean r = (value&1) != 0;
+		value = value >> 1;
+		count = count - 1;
+		return r;
+	}
+
+	public void pad_u8() throws IOException {
+		count = 0; // easy!!
+	}
+}
diff --git a/modules/wybs/src/wyfs/io/BinaryOutputStream.java b/modules/wybs/src/wyfs/io/BinaryOutputStream.java
new file mode 100755
index 0000000000..1ce94590c9
--- /dev/null
+++ b/modules/wybs/src/wyfs/io/BinaryOutputStream.java
@@ -0,0 +1,242 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.io;
+
+import java.io.*;
+
+public class BinaryOutputStream extends OutputStream {
+	protected OutputStream output;
+	protected int value;
+	protected int count;
+
+	/**
+	 * Write out data in big-endian format.
+	 * @param output
+	 */
+	public BinaryOutputStream(OutputStream output) {
+		this.output = output;
+	}
+
+	/**
+	 * Write an unsigned integer value using 8bits using a big-endian encoding.
+	 *
+	 * @param w
+	 * @throws IOException
+	 */
+	public void write(int i) throws IOException {
+		if(count == 0) {
+			output.write(i & 0xFF);
+		} else {
+			write_un(i & 0xFF,8);
+		}
+	}
+
+	public void write(byte[] bytes) throws IOException {
+		for(byte b : bytes) {
+			write(b);
+		}
+	}
+
+	public void write(byte[] bytes, int offset, int length) throws IOException {
+		for(;offset < length;++offset) {
+			write(bytes[offset]);
+		}
+	}
+
+	/**
+	 * Write an unsigned integer value using 8bits using a big-endian encoding.
+	 *
+	 * @param w
+	 * @throws IOException
+	 */
+	public void write_u8(int w) throws IOException {
+		if(count == 0) {
+			output.write(w & 0xFF);
+		} else {
+			write_un(w & 0xFF,8);
+		}
+	}
+
+	/**
+	 * Write an unsigned integer value using 16bits using a big-endian encoding.
+	 *
+	 * @param w
+	 * @throws IOException
+	 */
+	public void write_u16(int w) throws IOException {
+		write_u8((w >> 8) & 0xFF);
+		write_u8(w & 0xFF);
+	}
+
+	/**
+	 * Write an unsigned integer value using 32bits using a big-endian encoding.
+	 *
+	 * @param w
+	 * @throws IOException
+	 */
+	public void write_u32(int w) throws IOException {
+		write_u8((w >> 24) & 0xFF);
+		write_u8((w >> 16) & 0xFF);
+		write_u8((w >> 8) & 0xFF);
+		write_u8(w & 0xFF);
+	}
+
+	/**
+	 * Write an unsigned integer value using a variable amount of space. The
+	 * value is split into 4 bit (big-endian) chunks, where the msb of each
+	 * chunk is a flag indicating whether there are more chunks. Therefore,
+	 * values between 0 and 7 fit into 4 bits. Similarly, values between 8 and
+	 * 63 fit into 8 bits, etc
+	 *
+	 * @param w
+	 *            --- number to convert (which cannot be negative)
+	 * @throws IOException
+	 */
+	public void write_uv(int w) throws IOException {
+		if(w < 0) {
+			throw new IllegalArgumentException("cannot write negative number in a variable amount of space");
+		}
+		do {
+			int t = w & 7;
+			w = w >> 3;
+			if(w != 0) {
+				write_un(8|t,4);
+			} else {
+				write_un(t,4);
+			}
+		} while(w != 0);
+	}
+
+	/**
+	 * Write an unsigned integer value using n bits using a big-endian encoding.
+	 *
+	 * @param w
+	 * @throws IOException
+	 */
+	public void write_un(int bits, int n) throws IOException {
+		int mask = 1;
+		for(int i=0;i<n;++i) {
+			boolean bit = (bits & mask) != 0;
+			write_bit(bit);
+			mask = mask << 1;
+		}
+	}
+
+	public void write_bit(boolean bit) throws IOException {
+		value = value >> 1;
+		if(bit) {
+			value |= 128;
+		}
+		count = count + 1;
+		if(count == 8) {
+			count = 0;
+			output.write(value);
+			value = 0;
+		}
+	}
+
+	/**
+	 * Pad out stream to nearest byte boundary
+	 * @throws IOException
+	 */
+	public void pad_u8() throws IOException {
+		if (count > 0) {
+			output.write(value >>> (8-count));
+			value = 0;
+			count = 0;
+		}
+	}
+
+	public void close() throws IOException {
+		flush();
+		output.close();
+	}
+
+	public void flush() throws IOException {
+		if(count != 0) {
+			// In this case, we're closing but we have a number of bits left to
+			// write. This means we have to pad out the remainder of a byte.
+			// Instead of padding with zeros, I pad with ones. The reason for
+			// this is that it forces an EOF when reading back in with read_uv().
+			value = value >>> (8-count);
+			int mask = 0xff & ((~0) << count);
+			value = value | mask;
+			output.write(value);
+		}
+	}
+
+	public static String bin2str(int v) {
+		if(v == 0) {
+			return "0";
+		}
+		int mask = 1 << 31;
+		String r = "";
+		boolean leading = true;
+		for(int i=0;i!=32;++i) {
+			if((v&mask) != 0) {
+				r = r + "1";
+				leading=false;
+			} else if(!leading) {
+				r = r + "0";
+			}
+			v = v << 1;
+		}
+		return r;
+	}
+
+	public static void main(String[] argss) {
+		try {
+			ByteArrayOutputStream bout = new ByteArrayOutputStream();
+			BinaryOutputStream binout = new BinaryOutputStream(bout);
+
+			binout.write_bit(true);
+			binout.write_bit(false);
+			binout.write_bit(true);
+			binout.pad_u8();
+			binout.write_bit(true);
+			binout.write_bit(false);
+			binout.write_bit(true);
+			binout.write_bit(true);
+
+			binout.close();
+			ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
+			BinaryInputStream binin = new BinaryInputStream(bin);
+
+			System.out.println(binin.read_bit());
+			System.out.println(binin.read_bit());
+			System.out.println(binin.read_bit());
+
+			binin.pad_u8();
+
+			System.out.println(binin.read_bit());
+			System.out.println(binin.read_bit());
+			System.out.println(binin.read_bit());
+			System.out.println(binin.read_bit());
+		} catch(IOException e) {
+
+		}
+	}
+}
diff --git a/modules/wybs/src/wyfs/lang/Content.java b/modules/wybs/src/wyfs/lang/Content.java
new file mode 100755
index 0000000000..34bbfde2d3
--- /dev/null
+++ b/modules/wybs/src/wyfs/lang/Content.java
@@ -0,0 +1,229 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.lang;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import wyfs.lang.Path.Entry;
+import wyfs.lang.Path.Filter;
+import wyfs.lang.Path.ID;
+import wyfs.util.Trie;
+
+public class Content {
+
+	/**
+	 * Provides an abstract mechanism for reading and writing file in
+	 * a given format. Whiley source files (*.whiley) are one example, whilst JVM
+	 * class files (*.class) are another.
+	 *
+	 * @author David J. Pearce
+	 *
+	 * @param <T>
+	 */
+	public interface Type<T> {
+
+		/**
+		 * Physically read the raw bytes from a given input stream and convert
+		 * into the format described by this content type.
+		 *
+		 * @param input
+		 *            --- input stream representing in the format described by
+		 *            this content type.
+		 * @return
+		 */
+		public T read(Path.Entry<T> e, InputStream input) throws IOException;
+
+		/**
+		 * Convert an object in the format described by this content type into
+		 * an appropriate byte stream and write it to an output stream
+		 *
+		 * @param output
+		 *            --- stream which this value is to be written to.
+		 * @param value
+		 *            --- value to be converted into bytes.
+		 */
+		public void write(OutputStream output, T value) throws IOException;
+	}
+
+	/**
+	 * A generic mechanism for selecting a subset of content based on a path
+	 * filter and a content type. For example, one might specify an
+	 * includes="whiley/**\/*.whiley" filter on a given root to identify which
+	 * source files should be compiled. This would be implemented using either a
+	 * content or path filter.
+	 *
+	 * @author David J. Pearce
+	 *
+	 * @param <T>
+	 */
+	public interface Filter<T> {
+
+		/**
+		 * Check whether a given entry is matched by this filter.
+		 *
+		 * @param entry
+		 *            --- entry to test.
+		 * @return --- entry (retyped) if it matches, otherwise null.
+		 */
+		public boolean matches(Path.ID id, Content.Type<T> ct);
+
+		/**
+		 * Check whether a given subpath is matched by this filter. A matching
+		 * subpath does not necessarily identify an exact match; rather, it may
+		 * be an enclosing folder.
+		 *
+		 * @param id
+		 * @return
+		 */
+		public boolean matchesSubpath(Path.ID id);
+	}
+
+	/**
+	 * Construct a content filter from a path filter and a content type.
+	 *
+	 * @param filter --- path filter
+	 * @param contentType
+	 * @return
+	 */
+	public static <T> Filter<T> filter(final Path.Filter filter, final Content.Type<T> contentType) {
+		return new Filter<T>() {
+			public boolean matches(Path.ID id, Content.Type<T> ct) {
+				return ct == contentType && filter.matches(id);
+			}
+			public boolean matchesSubpath(Path.ID id) {
+				return filter.matchesSubpath(id);
+			}
+			public String toString() {
+				return filter.toString();
+			}
+		};
+	}
+
+	/**
+	 * Construct a content filter from a string representing a path filter and a content type.
+	 *
+	 * @param filter --- path filter
+	 * @param contentType
+	 * @return
+	 */
+	public static <T> Filter<T> filter(final String pathFilter, final Content.Type<T> contentType) {
+		final Path.Filter filter = Trie.fromString(pathFilter);
+		return new Filter<T>() {
+			public boolean matches(Path.ID id, Content.Type<T> ct) {
+				return ct == contentType && filter.matches(id);
+			}
+			public boolean matchesSubpath(Path.ID id) {
+				return filter.matchesSubpath(id);
+			}
+			public String toString() {
+				return filter.toString();
+			}
+		};
+	}
+	/**
+	 * Combine two filters together produce one filter whose items must be
+	 * matched by at least one of the original filters.
+	 *
+	 * @param f1
+	 * @param f2
+	 * @return
+	 */
+	public static <T> Filter<T> or(final Filter<T> f1, final Filter<T> f2) {
+		return new Filter<T>() {
+			public boolean matches(Path.ID id, Content.Type<T> ct) {
+				return f1.matches(id, ct) || f2.matches(id, ct);
+			}
+			public boolean matchesSubpath(Path.ID id) {
+				return f1.matchesSubpath(id) || f2.matchesSubpath(id);
+			}
+			public String toString() {
+				return f1.toString() + "|" + f2.toString();
+			}
+		};
+	}
+
+	/**
+	 * Combine two filters together produce one filter whose items must be
+	 * matched by both of the original filters.
+	 *
+	 * @param f1
+	 * @param f2
+	 * @return
+	 */
+	public static <T> Filter<T> and(final Filter<T> f1, final Filter<T> f2) {
+		return new Filter<T>() {
+			public boolean matches(Path.ID id, Content.Type<T> ct) {
+				return f1.matches(id, ct) && f2.matches(id, ct);
+			}
+			public boolean matchesSubpath(Path.ID id) {
+				return f1.matchesSubpath(id) && f2.matchesSubpath(id);
+			}
+			public String toString() {
+				return f1.toString() + "&" + f2.toString();
+			}
+		};
+	}
+
+	/**
+	 * <p>
+	 * Responsible for associating content types to path entries. The simplest
+	 * way to do this is to base the decision purely on the suffix of the entry
+	 * in question. A standard implementation (wyc.util.SuffixRegistry) is
+	 * provided for this common case.
+	 * </p>
+	 *
+	 * <p>
+	 * In some situations, it does occur on occasion that suffix alone is not
+	 * enough. For example, a JVM class file may correspond to multiple content
+	 * types if it may come from different source languages. In such cases, a
+	 * probe of the content may be required to fully determine the content type.
+	 * </p>
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Registry {
+
+		/**
+		 * Attempt to associate a content type with this entry.
+		 *
+		 * @param e
+		 *            --- entry to associate with a content type.
+		 * @return
+		 */
+		public void associate(Path.Entry<?> e);
+
+		/**
+		 * Determine an appropriate suffix for a given content type.
+		 *
+		 * @param t
+		 * @return
+		 */
+		public String suffix(Type<?> t);
+	}
+}
diff --git a/modules/wybs/src/wyfs/lang/Path.java b/modules/wybs/src/wyfs/lang/Path.java
new file mode 100755
index 0000000000..213903fe54
--- /dev/null
+++ b/modules/wybs/src/wyfs/lang/Path.java
@@ -0,0 +1,448 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.lang;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.IOException;
+import java.util.*;
+
+public class Path {
+
+	/**
+	 * Represents a sequence of zero or more names which describe a path through
+	 * the namespace for a given project. For example, "whiley/lang/Math" is a
+	 * valid ID with three components: "whiley","lang","Math".
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface ID extends Iterable<String>, Comparable<ID> {
+
+		/**
+		 * Get the number of components that make up this ID.
+		 * @return
+		 */
+		public int size();
+
+		/**
+		 * Return the component at a given index.
+		 * @param index
+		 * @return
+		 */
+		public String get(int index);
+
+		/**
+		 * A convenience function that gets the last component of this path.
+		 *
+		 * @return
+		 */
+		public String last();
+
+		/**
+		 * Get the parent of this path.
+		 *
+		 * @return
+		 */
+		public ID parent();
+
+		/**
+		 * Get a sub ID from this id, which consists of those components between
+		 * start and end (exclusive).
+		 *
+		 * @param start
+		 *            --- starting component index
+		 * @param start
+		 *            --- one past last component index
+		 * @return
+		 */
+		public ID subpath(int start, int end);
+
+		/**
+		 * Append a component onto the end of this id.
+		 *
+		 * @param component
+		 *            --- to be appended
+		 * @return
+		 */
+		public ID append(String component);
+	}
+
+	/**
+	 * Represents an abstract or physical item of some sort which is reachable
+	 * from a <code>Root</code>. Valid instances of <code>Item</code> include
+	 * those valid instances of <code>Entry</code> and <code>Folder</code>.
+	 */
+	public interface Item {
+		/**
+		 * Return the identify of this item.
+		 *
+		 * @return
+		 */
+		public ID id();
+
+		/**
+		 * Force item to refresh contents from permanent storage (where
+		 * appropriate). For items which have been modified, this operation has
+		 * no effect (i.e. the new contents are retained). For folders, this
+		 * forces sub-folders to be refreshed as well.
+		 */
+		public void refresh() throws IOException;
+
+		/**
+		 * Force item to write contents to permanent storage (where
+		 * appropriate). For items which have not been modified, this operation
+		 * has no effect (i.e. the old contents are retained). For folers, this
+		 * forces sub-folders to be flushed as well.
+		 */
+		public void flush() throws IOException;
+	}
+
+	/**
+	 * Represents a physical item of some sort which is reachable from a
+	 * <code>Root</code>. Valid instances of <code>Entry</code> may correspond
+	 * to files on the file system, entries in a Jar file, or abstractions from
+	 * other tools (e.g. eclipse's <code>IFile</code>).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Entry<T> extends Item {
+
+		/**
+		 * Return the suffix of the item in question. This is necessary to
+		 * determine how we will process this item.
+		 *
+		 * @return
+		 */
+		public String suffix();
+
+		/**
+		 * Return a string indicating the true location of this entry.
+		 *
+		 * @return
+		 */
+		public String location();
+
+		/**
+		 * Get the last modification time for this file.
+		 *
+		 * @return
+		 */
+		public long lastModified();
+
+		/**
+		 * Check whether this file has been modified or not.
+		 *
+		 * @return
+		 */
+		public boolean isModified();
+
+		/**
+		 * Mark this entry as being modified.
+		 *
+		 * @return
+		 */
+		public void touch();
+
+		/**
+		 * Get the content type associated with this file. This provides a
+		 * generic mechanism for describing the information contained within the
+		 * file.
+		 */
+		public Content.Type<T> contentType();
+
+		/**
+		 * Associate this entry with a content type, and optionally provide the
+		 * contents. The ability to provide the contents is a convenience
+		 * function for cases where determining the content type requires
+		 * actually reading the contents!
+		 *
+		 * @param contentType
+		 *            --- content type to associate
+		 * @param contents
+		 *            --- contents to associate, or null if none.
+		 */
+		public void associate(Content.Type<T> contentType, T contents);
+		
+		/**
+		 * Read contents of file. Note, however, that this does not mean the
+		 * contents are re-read from permanent storage. If the contents are
+		 * already available in memory, then they will returned without
+		 * accessing permanent storage.
+		 */
+		public T read() throws IOException;
+
+		/**
+		 * Write the contents of this entry. It is assumed that the contents
+		 * matches the content-type given for this entry. Finally, note also
+		 * that this does not mean the contents are written to permanent
+		 * storage.
+		 *
+		 * @param contents
+		 */
+		public void write(T contents) throws IOException;
+
+		/**
+		 * Open a generic input stream to the entry.
+		 *
+		 * @return
+		 * @throws IOException
+		 */
+		public InputStream inputStream() throws IOException;
+
+		/**
+		 * Open a generic output stream to the entry.
+		 *
+		 * @return
+		 * @throws IOException
+		 */
+		public OutputStream outputStream() throws IOException;
+	}
+
+	/**
+	 * An folder represents a special kind of entry which contains entries (and
+	 * other folders). As such, it cannot be considered a concrete entry which
+	 * can be read and written in the normal manner. Rather, it provides access
+	 * to entries. For example, in a physical file system, a folder would
+	 * correspond to a directory.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Folder extends Item {
+
+		/**
+		 * Check whether or not a given entry is contained in this folder;
+		 *
+		 * @param entry
+		 * @return
+		 */
+		public boolean contains(Path.Entry<?> entry) throws IOException;
+
+		/**
+		 * folder) and content-type is contained in this folder.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public boolean exists(ID id, Content.Type<?> ct) throws IOException;
+
+		/**
+		 * Get the entry corresponding to a given ID (taken relative to this
+		 * folder) and content type. If no such entry exists, return null.
+		 *
+		 * @param id
+		 *            --- id of module to lookup.
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public <T> Path.Entry<T> get(ID id, Content.Type<T> ct)
+				throws IOException;
+
+		/**
+		 * Get all objects contained in this folder (including those contained
+		 * in subfolders). In the case of no matches, an empty list is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param ct
+		 * @return
+		 */
+		public List<Path.Entry<?>> getAll() throws IOException;
+
+		/**
+		 * Get all objects matching a given content filter stored in this folder
+		 * (including its subfolders). In the case of no matches, an empty list
+		 * is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param ct
+		 * @return
+		 */
+		public <T> void getAll(Content.Filter<T> ct, List<Path.Entry<T>> entries)
+				throws IOException;
+
+		/**
+		 * Identify all entries matching a given content filter stored in this
+		 * folder (including its subfolders). In the case of no matches, an
+		 * empty set is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param filter
+		 *            --- filter to match entries with.
+		 * @return
+		 */
+		public <T> void getAll(Content.Filter<T> filter, Set<Path.ID> entries)
+				throws IOException;
+
+		/**
+		 * Create a new entry in this folder with the given ID (taken relative
+		 * to this folder) and content-type. This will recursively construct
+		 * sub-folders as necessary.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param entry
+		 */
+		public <T> Path.Entry<T> create(Path.ID id, Content.Type<T> ct) throws IOException;
+	}
+
+	/**
+	 * Represents the root of a hierarchy of named entries. A instance of root
+	 * may correspond to a file system directory, a Jar file, or some other
+	 * abstraction representings a collection of files (e.g. eclipse's
+	 * <code>IContainer</code>).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Root {
+
+		/**
+		 * Check whether or not a given entry is contained in this root;
+		 *
+		 * @param entry
+		 * @return
+		 */
+		public boolean contains(Path.Entry<?> entry) throws IOException;
+
+		/**
+		 * Check whether or not a given entry and content-type is contained in
+		 * this root.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public boolean exists(ID id, Content.Type<?> ct) throws IOException;
+
+		/**
+		 * Get the entry corresponding to a given ID and content type. If no
+		 * such entry exists, return null.
+		 *
+		 * @param id
+		 *            --- id of module to lookup.
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 */
+		public <T> Path.Entry<T> get(ID id, Content.Type<T> ct)
+				throws IOException;
+
+		/**
+		 * Get all objects matching a given content filter stored in this root.
+		 * In the case of no matches, an empty list is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param ct
+		 * @return
+		 */
+		public <T> List<Path.Entry<T>> get(Content.Filter<T> ct)
+				throws IOException;
+
+		/**
+		 * Identify all entries matching a given content filter stored in this
+		 * root. In the case of no matches, an empty set is returned.
+		 *
+		 * @throws IOException
+		 *             --- in case of some I/O failure.
+		 *
+		 * @param filter
+		 *            --- filter to match entries with.
+		 * @return
+		 */
+		public <T> Set<Path.ID> match(Content.Filter<T> filter)
+				throws IOException;
+
+		/**
+		 * Create an entry of a given content type at a given path. If the entry
+		 * already exists, then it is just returned.
+		 *
+		 * @param id
+		 *            --- Path.ID for the new entry
+		 * @param ct
+		 *            --- content type of the new entry
+		 * @return
+		 * @throws IOException
+		 */
+		public <T> Path.Entry<T> create(ID id, Content.Type<T> ct)
+				throws IOException;
+
+		/**
+		 * Force root to flush entries to permanent storage (where appropriate).
+		 * This is essential as, at any given moment, path entries may only be
+		 * stored in memory. We must flush them to disk in order to preserve any
+		 * changes that were made.
+		 */
+		public void flush() throws IOException;
+
+		/**
+		 * Force root to refresh entries from permanent storage (where
+		 * appropriate). For items which has been modified, this operation has
+		 * no effect (i.e. the new contents are retained).
+		 */
+		public void refresh() throws IOException;
+	}
+
+	/**
+	 * A generic mechanism for selecting one or more paths. For example, one
+	 * might specify an includes="whiley/**\/*.whiley" filter on a given root to
+	 * identify which source files should be compiled. This would be implemented
+	 * using either a content or path filter.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface Filter {
+
+		/**
+		 * Check whether a given entry is matched by this filter.
+		 *
+		 * @param id
+		 *            --- id to test.
+		 * @return --- true if it matches, otherwise false.
+		 */
+		public boolean matches(Path.ID id);
+
+		/**
+		 * Check whether a given subpath is matched by this filter. A matching
+		 * subpath does not necessarily identify an exact match; rather, it may
+		 * be an enclosing folder.
+		 *
+		 * @param id
+		 * @return
+		 */
+		public boolean matchesSubpath(Path.ID id);
+	}
+
+}
diff --git a/modules/wybs/src/wyfs/package-info.java b/modules/wybs/src/wyfs/package-info.java
new file mode 100755
index 0000000000..bc1c851f50
--- /dev/null
+++ b/modules/wybs/src/wyfs/package-info.java
@@ -0,0 +1,45 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * <p>
+ * <b>The Whiley File System</b>. This provides a generic and flexible
+ * representation of hierarchically named objects. In essence, this is an
+ * abstract view of a "filesystem" which may be mapped to a physical file system
+ * (e.g. files, directories) or something else (e.g. an in-memory file system,
+ * the Eclipse filesystem, etc).
+ * </p>
+ * <p>
+ * A standard implementation of the file system is also provided which is based
+ * around physical files, directories and archive files (e.g. jars). This
+ * standard implementation is sufficient for a command-line compiler. However,
+ * when running a compiler from within an IDE (e.g. Eclipse) alternative
+ * implementations specific to the IDE may be required.
+ * </p>
+ *
+ * @author David J. Pearce
+ */
+package wyfs;
+
diff --git a/modules/wybs/src/wyfs/util/AbstractEntry.java b/modules/wybs/src/wyfs/util/AbstractEntry.java
new file mode 100755
index 0000000000..62f2d7ae9d
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/AbstractEntry.java
@@ -0,0 +1,101 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.IOException;
+import java.util.*;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+
+/**
+ * Provides a simple implementation of <code>Path.Entry</code>. This caches
+ * content in a field and employs a <code>modifies</code> bit to determine if
+ * that content needs to be written to permanent storage.
+ *
+ * @author David J. Pearce
+ *
+ * @param <T>
+ */
+public abstract class AbstractEntry<T> implements Path.Entry<T> {
+	protected final Path.ID id;
+	protected Content.Type<T> contentType;
+	protected T contents = null;
+	protected boolean modified = false;
+
+	public AbstractEntry(Path.ID mid) {
+		this.id = mid;
+	}
+
+	public Path.ID id() {
+		return id;
+	}
+
+	public void touch() {
+		this.modified = true;
+	}
+
+	public boolean isModified() {
+		return modified;
+	}
+
+	public Content.Type<T> contentType() {
+		return contentType;
+	}
+
+	public void refresh() throws IOException {
+		if(!modified) {
+			contents = null; // reset contents
+		}
+	}
+
+	public void flush() throws IOException {
+		if(modified && contents != null) {
+			contentType.write(outputStream(), contents);
+			this.modified = false;
+		}
+	}
+
+	public T read() throws IOException {
+		if (contents == null) {
+			contents = contentType.read(this,inputStream());
+		}
+		return contents;
+	}
+
+	public void write(T contents) throws IOException {
+		this.modified = true;
+		this.contents = contents;
+	}
+
+	public void associate(Content.Type<T> contentType, T contents) {
+		if(this.contentType != null) {
+			throw new IllegalArgumentException("content type already associated with this entry");
+		}
+		this.contentType = contentType;
+		this.contents = contents;
+	}	
+}
diff --git a/modules/wybs/src/wyfs/util/AbstractFolder.java b/modules/wybs/src/wyfs/util/AbstractFolder.java
new file mode 100755
index 0000000000..a0efd2dac4
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/AbstractFolder.java
@@ -0,0 +1,340 @@
+// Copyright (c) 2012, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Set;
+
+import wybs.lang.*;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+import wyfs.lang.Path.ID;
+
+/**
+ * An abstract folder contains other folders, and path entries. As such, it
+ * cannot be considered a concrete entry which can be read and written in the
+ * normal manner. Rather, it provides access to entries. In a physical file
+ * system, a folder would correspond to a directory.
+ *
+ * @author David J. Pearce
+ *
+ */
+public abstract class AbstractFolder implements Path.Folder {
+	protected final Path.ID id;
+	private Path.Item[] contents;
+	private int nentries;
+
+	/**
+	 * Construct an Abstract Folder representing a given ID (taken relative to
+	 * the enclosing root).
+	 *
+	 * @param id
+	 */
+	public AbstractFolder(Path.ID id) {
+		this.id = id;
+	}
+
+	@Override
+	public Path.ID id() {
+		return id;
+	}
+
+	@Override
+	public boolean contains(Path.Entry<?> e) throws IOException {
+		updateContents();
+		Path.ID eid = e.id();
+		boolean contained;
+
+		if(id == eid.parent()) {
+			// The requested entry is contained in this folder. Therefore, we
+			// need to search for it.
+			contained = true;
+		} else if(id == eid.subpath(0,id.size())) {
+			// This folder is a parent of the requested entry. Therefore, we
+			// need to looking for a matching folder entry. If we find one, then
+			// we ask it for the requested entry.
+			eid = eid.subpath(0,id.size()+1);
+			contained = false;
+		} else {
+			return false;
+		}
+
+		int idx = binarySearch(contents,nentries,eid);
+		if(idx >= 0) {
+			// At this point, we've found a matching index for the given ID.
+			// However, there maybe multiple matching IDs (e.g. with different
+			// content types). Therefore, we need to check them all to see if
+			// they match the requested entry.
+			Path.Item item = contents[idx];
+			do {
+				if (item == e) {
+					return true;
+				} else if(!contained && item instanceof Path.Folder) {
+					Path.Folder folder = (Path.Folder) item;
+					return folder.contains(e);
+				}
+			} while (++idx < nentries
+					&& (item = contents[idx]).id().equals(eid));
+		}
+
+		// no dice
+		return false;
+	}
+
+	@Override
+	public boolean exists(ID id, Content.Type<?> ct) throws IOException{
+		return get(id,ct) != null;
+	}
+
+	@Override
+	public <T> Path.Entry<T> get(ID eid, Content.Type<T> ct) throws IOException{
+		updateContents();
+
+		ID tid = id.append(eid.get(0));
+
+		int idx = binarySearch(contents,nentries,tid);
+		if(idx >= 0) {
+			// At this point, we've found a matching index for the given ID.
+			// However, there maybe multiple matching IDs with different
+			// content types. Therefore, we need to check them all to see if
+			// they match the requested entry.
+			Path.Item item = contents[idx];
+			do {
+				if(item instanceof Entry && eid.size() == 1) {
+					// In this case, we're looking for and have found an exact
+					// item.
+					Entry entry = (Entry) item;
+					if (entry.contentType() == ct) {
+						return entry;
+					}
+				} else if (item instanceof Path.Folder && eid.size() > 1) {
+					// In this case, the ID is indicates the item is not
+					// contained in this folder.
+					Path.Folder folder = (Path.Folder) item;
+					return folder.get(eid.subpath(1,eid.size()), ct);
+				}
+			} while (++idx < nentries
+					&& (item = contents[idx]).id().equals(tid));
+		}
+
+		// no dice
+		return null;
+	}
+
+	@Override
+	public List<Entry<?>> getAll() throws IOException{
+		ArrayList entries = new ArrayList();
+		updateContents();
+
+		// It would be nice to further optimise this loop. Basically, to avoid
+		// creating so many ArrayList objects. However, it's tricky to get right
+		// given Java's generic type system.
+
+		for(int i=0;i!=nentries;++i) {
+			Path.Item item = contents[i];
+			if(item instanceof Entry) {
+				Entry entry = (Entry) item;
+				entries.add(entry);
+			} else if (item instanceof Path.Folder) {
+				Path.Folder folder = (Path.Folder) item;
+				entries.addAll(folder.getAll());
+			}
+		}
+
+		return entries;
+	}
+
+	@Override
+	public <T> void getAll(Content.Filter<T> filter, List<Entry<T>> entries) throws IOException{
+		updateContents();
+
+		// It would be nice to further optimise this loop. The key issue is that,
+		// at some point, we might know the filter could never match. In which
+		// case, we want to stop the recursion early, rather than exploring a
+		// potentially largel subtree.
+
+		for(int i=0;i!=nentries;++i) {
+			Path.Item item = contents[i];
+			if(item instanceof Entry) {
+				Entry entry = (Entry) item;
+				if(filter.matches(entry.id(),entry.contentType())) {
+					entries.add(entry);
+				}
+			} else if (item instanceof Path.Folder
+					&& filter.matchesSubpath(item.id())) {
+				Path.Folder folder = (Path.Folder) item;
+				folder.getAll(filter, entries);
+			}
+		}
+	}
+
+	@Override
+	public <T> void getAll(Content.Filter<T> filter, Set<Path.ID> entries) throws IOException{
+		updateContents();
+
+		// It would be nice to further optimise this loop. The key issue is that,
+		// at some point, we might know the filter could never match. In which
+		// case, we want to stop the recursion early, rather than exploring a
+		// potentially largel subtree.
+
+		for(int i=0;i!=nentries;++i) {
+			Path.Item item = contents[i];
+			if (item instanceof Entry) {
+				Entry entry = (Entry) item;
+				if (filter.matches(entry.id(), entry.contentType())) {
+					entries.add(entry.id());
+				}
+			} else if (item instanceof Path.Folder
+					&& filter.matchesSubpath(item.id())) {
+				Path.Folder folder = (Path.Folder) item;
+				folder.getAll(filter, entries);
+			}
+		}
+	}
+
+	@Override
+	public void refresh() {
+		contents = null;
+	}
+
+	@Override
+	public void flush() throws IOException {
+		if(contents != null) {
+			for(int i=0;i!=nentries;++i) {
+				contents[i].flush();
+			}
+		}
+	}
+
+	protected Path.Folder getFolder(String name) throws IOException {
+		updateContents();
+
+		ID tid = id.append(name);
+
+		int idx = binarySearch(contents, nentries, tid);
+		if (idx >= 0) {
+			// At this point, we've found a matching index for the given ID.
+			// However, there maybe multiple matching IDs with different
+			// content types. Therefore, we need to check them all to see if
+			// they match the requested entry.
+			Path.Item item = contents[idx];
+			do {
+				if (item instanceof Path.Folder) {
+					// In this case, the ID is indicates the item is not
+					// contained in this folder.
+					return (Path.Folder) item;
+				}
+			} while (++idx < nentries
+					&& (item = contents[idx]).id().equals(tid));
+		}
+
+		// no dice
+		return null;
+	}
+
+	/**
+	 * Insert a newly created item into this folder. Observe we assume
+	 * <code>entry.id().parent() == id</code>.
+	 *
+	 * @param item
+	 */
+	protected void insert(Path.Item item) throws IOException {
+		if (item.id().parent() != id) {
+			throw new IllegalArgumentException(
+					"Cannot insert with incorrect Path.Item (" + item.id() + ") into AbstractFolder (" + id + ")");
+		}
+		updateContents();
+
+		Path.ID id = item.id();
+		int index = binarySearch(contents, nentries, id);
+
+		if (index < 0) {
+			index = -index - 1; // calculate insertion point
+		} else {
+			// indicates already an entry with a different content type
+		}
+
+		if ((nentries + 1) < contents.length) {
+			System.arraycopy(contents, index, contents, index + 1, nentries
+					- index);
+		} else {
+			Path.Item[] tmp = new Path.Item[(nentries + 1) * 2];
+			System.arraycopy(contents, 0, tmp, 0, index);
+			System.arraycopy(contents, index, tmp, index + 1, nentries - index);
+			contents = tmp;
+		}
+
+		contents[index] = item;
+		nentries++;
+	}
+
+	private final void updateContents() throws IOException{
+		if(contents == null) {
+			contents = contents();
+			nentries = contents.length;
+			Arrays.sort(contents,entryComparator);
+		}
+	}
+
+	/**
+	 * Extract all entries from the given folder.
+	 */
+	protected abstract Path.Item[] contents() throws IOException;
+
+	private static final int binarySearch(final Path.Item[] children, int nchildren, final Path.ID key) {
+		int low = 0;
+        int high = nchildren-1;
+
+        while (low <= high) {
+            int mid = (low + high) >> 1;
+            int c = children[mid].id().compareTo(key);
+            if (c < 0) {
+                low = mid + 1;
+            } else if (c > 0) {
+                high = mid - 1;
+            } else {
+            	// found a batch, locate start point
+            	mid = mid - 1;
+				while (mid >= 0 && children[mid].id().compareTo(key) == 0) {
+					mid = mid - 1;
+				}
+				return mid + 1;
+            }
+        }
+        return -(low + 1);
+	}
+
+	private static final Comparator<Path.Item> entryComparator = new Comparator<Path.Item>() {
+		public int compare(Path.Item e1, Path.Item e2) {
+			return e1.id().compareTo(e2.id());
+		}
+	};
+}
diff --git a/modules/wybs/src/wyfs/util/AbstractRoot.java b/modules/wybs/src/wyfs/util/AbstractRoot.java
new file mode 100755
index 0000000000..e71effa47e
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/AbstractRoot.java
@@ -0,0 +1,103 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+import wyfs.lang.Path.Folder;
+import wyfs.lang.Path.ID;
+import wyfs.lang.Path.Root;
+
+/**
+ * Provides a simple implementation of <code>Path.Root</code>. This maintains a
+ * cache all entries contained in the root.
+ *
+ * @author David J. Pearce
+ *
+ */
+public abstract class AbstractRoot<T extends Folder> implements Root {
+	protected final Content.Registry contentTypes;
+	protected final T root;
+
+	public AbstractRoot(Content.Registry contentTypes) {
+		this.contentTypes = contentTypes;
+		this.root = root();
+	}
+
+	public boolean contains(Path.Entry<?> e) throws IOException {
+		return root.contains(e);
+	}
+
+	public boolean exists(ID id, Content.Type<?> ct) throws IOException{
+		return root.exists(id,ct);
+	}
+
+	public <T> Path.Entry<T> get(ID id, Content.Type<T> ct) throws IOException{
+		Path.Entry<T> e = root.get(id,ct);
+		return e;
+	}
+
+	public <T> List<Entry<T>> get(Content.Filter<T> filter) throws IOException{
+		ArrayList<Entry<T>> entries = new ArrayList<Entry<T>>();
+		root.getAll(filter, entries);
+		return entries;
+	}
+
+	public <T> Set<Path.ID> match(Content.Filter<T> filter) throws IOException{
+		HashSet<Path.ID> ids = new HashSet<Path.ID>();
+		root.getAll(filter, ids);
+		return ids;
+	}
+
+	@Override
+	public <T> Path.Entry<T> create(Path.ID id, Content.Type<T> ct) throws IOException {
+		return root.create(id,ct);
+	}
+
+	public void refresh() throws IOException{
+		root.refresh();
+	}
+
+	public void flush() throws IOException{
+		root.flush();
+	}
+
+	/**
+	 * Get the root folder for this abstract root. Note that this should be
+	 * loaded from scratch, and not cached in any way. This ensures that
+	 * invoking AbstractRoot.refresh() does indeed refresh entries.
+	 *
+	 * @return
+	 */
+	protected abstract T root();
+}
\ No newline at end of file
diff --git a/modules/wybs/src/wyfs/util/DirectoryRoot.java b/modules/wybs/src/wyfs/util/DirectoryRoot.java
new file mode 100755
index 0000000000..6d353074be
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/DirectoryRoot.java
@@ -0,0 +1,319 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.*;
+import java.util.*;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Content.Filter;
+import wyfs.lang.Content.Registry;
+import wyfs.lang.Content.Type;
+import wyfs.lang.Path.Entry;
+import wyfs.lang.Path.ID;
+
+/**
+ * Provides an implementation of <code>Path.Root</code> for representing a file
+ * system directory.
+ *
+ * @author David J. Pearce
+ *
+ */
+public final class DirectoryRoot extends AbstractRoot<DirectoryRoot.Folder> {
+
+	public final static FileFilter NULL_FILTER = new FileFilter() {
+		public boolean accept(File file) {
+			return true;
+		}
+	};
+
+	private final FileFilter filter;
+	private final File dir;
+
+	/**
+	 * Construct a directory root from a filesystem path expressed as a string,
+	 * and an appropriate file filter. In converting the path to a File object,
+	 * an IOException may arise if it is an invalid path.
+	 *
+	 * @param path
+	 *            --- location of directory on filesystem, expressed as a native
+	 *            path (i.e. separated using File.separatorChar, etc)
+	 * @throws IOException
+	 */
+	public DirectoryRoot(String path, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = new File(path);
+		this.filter = NULL_FILTER;
+	}
+
+	/**
+	 * Construct a directory root from a filesystem path expressed as a string,
+	 * and an appropriate file filter. In converting the path to a File object,
+	 * an IOException may arise if it is an invalid path.
+	 *
+	 * @param path
+	 *            --- location of directory on filesystem, expressed as a native
+	 *            path (i.e. separated using File.separatorChar, etc)
+	 * @param filter
+	 *            --- filter on which files are included.
+	 * @throws IOException
+	 */
+	public DirectoryRoot(String path, FileFilter filter, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = new File(path);
+		this.filter = filter;
+	}
+
+	/**
+	 * Construct a directory root from a filesystem path expressed as a string,
+	 * and an appropriate file filter. In converting the path to a File object,
+	 * an IOException may arise if it is an invalid path.
+	 *
+	 * @param path
+	 *            --- location of directory on filesystem, expressed as a native
+	 *            path (i.e. separated using File.separatorChar, etc)
+	 * @throws IOException
+	 */
+	public DirectoryRoot(File dir, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = dir;
+		this.filter = NULL_FILTER;
+	}
+
+	/**
+	 * Construct a directory root from a filesystem path expressed as a string,
+	 * and an appropriate file filter. In converting the path to a File object,
+	 * an IOException may arise if it is an invalid path.
+	 *
+	 * @param path
+	 *            --- location of directory on filesystem, expressed as a native
+	 *            path (i.e. separated using File.separatorChar, etc)
+	 * @param filter
+	 *            --- filter on which files are included.
+	 * @throws IOException
+	 */
+	public DirectoryRoot(File dir, FileFilter filter, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = dir;
+		this.filter = filter;
+	}
+
+	public File location() {
+		return dir;
+	}
+
+	public String toString() {
+		return dir.getPath();
+	}
+
+	@Override
+	protected Folder root() {
+		return new Folder(Trie.ROOT);
+	}
+
+	/**
+	 * Given a list of physical files on the file system, determine their
+	 * corresponding <code>Path.Entry</code> instances in this root (if there
+	 * are any).
+	 *
+	 * @param files
+	 *            --- list of files on the physical file system.
+	 * @param contentType
+	 *            --- content type of files to match.
+	 * @return --- list of path entries where each entry matches the
+	 *         corresponding entry in files, or is null (if there is no match).
+	 * @throws IOException
+	 */
+	public <T> List<Path.Entry<T>> find(List<File> files,
+			Content.Type<T> contentType)
+			throws IOException {
+		ArrayList<Path.Entry<T>> sources = new ArrayList<Path.Entry<T>>();
+		String suffix = "." + contentTypes.suffix(contentType);
+		String location = location().getCanonicalPath();
+
+		for (File file : files) {
+			String filePath = file.getCanonicalPath();
+			if (filePath.startsWith(location)) {
+				int end = location.length();
+				if (end > 1) {
+					end++;
+				}
+				String module = filePath.substring(end).replace(
+						File.separatorChar, '/');
+				if (module.endsWith(suffix)) {
+					module = module.substring(0,
+							module.length() - suffix.length());
+					Path.ID mid = Trie.fromString(module);
+					Path.Entry<T> entry = this.get(mid, contentType);
+					if (entry != null) {
+						sources.add(entry);
+						continue;
+					}
+				}
+			}
+			sources.add(null);
+		}
+
+		return sources;
+	}
+
+	/**
+	 * An entry is a file on the file system which represents a Whiley module. The
+	 * file may be encoded in a range of different formats. For example, it may be a
+	 * source file and/or a binary wyil file.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Entry<T> extends AbstractEntry<T> implements Path.Entry<T> {
+		private final java.io.File file;
+
+		public Entry(Path.ID id, java.io.File file) {
+			super(id);
+			this.file = file;
+		}
+
+		public String location() {
+			return file.getPath();
+		}
+
+		public long lastModified() {
+			return file.lastModified();
+		}
+
+		public File file() {
+			return file;
+		}
+
+		public String suffix() {
+			String filename = file.getName();
+			String suffix = "";
+			int pos = filename.lastIndexOf('.');
+			if (pos > 0) {
+				suffix = filename.substring(pos + 1);
+			}
+			return suffix;
+		}
+
+		public InputStream inputStream() throws IOException {
+			return new FileInputStream(file);
+		}
+
+		public OutputStream outputStream() throws IOException {
+			file.getParentFile().mkdirs();
+			return new FileOutputStream(file);
+		}
+
+		public String toString() {
+			return file.toString();
+		}
+	}
+
+	/**
+	 * Represents a directory on a physical file system.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public final class Folder extends AbstractFolder {
+		public Folder(Path.ID id) {
+			super(id);
+		}
+
+		@Override
+		protected Path.Item[] contents() throws IOException {
+			File myDir = new File(dir, id.toString().replace('/', File.separatorChar));
+
+			if (myDir.exists() && myDir.isDirectory()) {
+				File[] files = myDir.listFiles(filter);
+				Path.Item[] items = new Path.Item[files.length];
+				int count = 0;
+				for(int i=0;i!=files.length;++i) {
+					File file = files[i];
+					String filename = file.getName();
+					if (file.isDirectory()) {
+						items[count++] = new Folder(id.append(filename));
+					} else {
+						int idx = filename.lastIndexOf('.');
+						if (idx > 0) {
+							String name = filename.substring(0, idx);
+							Path.ID oid = id.append(name);
+							Entry e = new Entry(oid, file);
+							contentTypes.associate(e);
+							items[count++] = e;
+						}
+					}
+				}
+
+				if(count != items.length) {
+					// trim the end since we didn't use all allocated elements.
+					return Arrays.copyOf(items,count);
+				} else {
+					// minor optimisation
+					return items;
+				}
+			} else {
+				return new Path.Item[0];
+			}
+		}
+
+		@Override
+		public <T> Path.Entry<T> create(ID nid, Content.Type<T> ct)
+				throws IOException {
+			if (nid.size() == 1) {
+				// attempting to create an entry in this folder
+				Path.Entry<T> e = super.get(nid.subpath(0, 1), ct);
+				if (e == null) {
+					// Entry doesn't already exist, so create it
+					nid = id.append(nid.get(0));
+					String physID = nid.toString().replace('/',
+							File.separatorChar);
+					physID = physID + "." + contentTypes.suffix(ct);
+					File nfile = new File(dir.getAbsolutePath()
+							+ File.separatorChar + physID);
+					e = new Entry(nid, nfile);
+					e.associate(ct, null);
+					super.insert(e);
+				}
+				return e;
+			} else {
+				// attempting to create entry in subfolder.
+				Path.Folder folder = getFolder(nid.get(0));
+				if (folder == null) {
+					// Folder doesn't already exist, so create it.
+					folder = new Folder(id.append(nid.get(0)));
+					super.insert(folder);
+				}
+				return folder.create(nid.subpath(1, nid.size()), ct);
+			}
+		}
+
+		public String toString() {
+			return dir + ":" + id;
+		}
+	}
+}
diff --git a/modules/wybs/src/wyfs/util/JarFileRoot.java b/modules/wybs/src/wyfs/util/JarFileRoot.java
new file mode 100755
index 0000000000..b078562ad8
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/JarFileRoot.java
@@ -0,0 +1,195 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.*;
+import java.util.*;
+import java.util.jar.*;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Content.Type;
+
+/**
+ * Provides an implementation of <code>Path.Root</code> for representing the
+ * contents of a jar file.
+ *
+ * @author David J. Pearce
+ *
+ */
+public final class JarFileRoot extends AbstractRoot<JarFileRoot.Folder> implements Path.Root {
+	private final File dir;
+	private Path.Item[] jfContents;
+
+	public JarFileRoot(String dir, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = new File(dir);
+		refresh();
+	}
+
+	public JarFileRoot(File dir, Content.Registry contentTypes) throws IOException {
+		super(contentTypes);
+		this.dir = dir;
+		refresh();
+	}
+
+	@Override
+	public <T> Path.Entry<T> create(Path.ID id, Content.Type<T> ct) throws IOException {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public void flush() {
+		// no-op, since jar files are read-only.
+	}
+
+	@Override
+	public void refresh() throws IOException {
+		JarFile jf = new JarFile(dir);
+		Enumeration<JarEntry> entries = jf.entries();
+		this.jfContents = new Path.Item[jf.size()];
+		int i = 0;
+		while (entries.hasMoreElements()) {
+			JarEntry e = entries.nextElement();
+			String filename = e.getName();
+			int lastSlash = filename.lastIndexOf('/');
+			Trie pkg = lastSlash == -1 ? Trie.ROOT : Trie.fromString(filename.substring(0, lastSlash));
+			if(!e.isDirectory()) {
+				int lastDot = filename.lastIndexOf('.');
+				String name = lastDot >= 0 ? filename.substring(lastSlash + 1, lastDot) : filename;
+				String suffix = lastDot >= 0 ? filename.substring(lastDot + 1) : null;
+				Trie id = pkg.append(name);
+				Entry pe = new Entry(id, jf, e);
+				contentTypes.associate(pe);
+				jfContents[i++] = pe;
+			} else {
+				// folder
+				jfContents[i++] = new Folder(pkg);
+			}
+		}
+	}
+
+	@Override
+	protected Folder root() {
+		return new Folder(Trie.ROOT);
+	}
+
+	public String toString() {
+		return dir.getPath();
+	}
+
+
+	/**
+	 * Represents a directory on a physical file system.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public final class Folder extends AbstractFolder {
+		public Folder(Path.ID id) {
+			super(id);
+		}
+
+		@Override
+		protected Path.Item[] contents() throws IOException {
+			// This algorithm is straightforward. I use a two loops instead of a
+			// single loop with ArrayList to avoid allocating on the heap.
+			int count = 0 ;
+			for(int i=0;i!=jfContents.length;++i) {
+				Path.Item item = jfContents[i];
+				if(item.id().parent() == id) {
+					count++;
+				}
+			}
+
+			Path.Item[] myContents = new Path.Item[count];
+			count=0;
+			for(int i=0;i!=jfContents.length;++i) {
+				Path.Item item = jfContents[i];
+				if(item.id().parent() == id) {
+					myContents[count++] = item;
+				}
+			}
+
+			return myContents;
+		}
+
+		@Override
+		public <T> wyfs.lang.Path.Entry<T> create(Path.ID id, Content.Type<T> ct) {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	private static final class Entry<T> extends AbstractEntry<T> implements Path.Entry<T> {
+		private final JarFile parent;
+		private final JarEntry entry;
+
+		public Entry(Trie mid, JarFile parent, JarEntry entry) {
+			super(mid);
+			this.parent = parent;
+			this.entry = entry;
+		}
+
+		public String location() {
+			return parent.getName();
+		}
+
+		public long lastModified() {
+			return entry.getTime();
+		}
+
+		public boolean isModified() {
+			// cannot modify something in a Jar file.
+			return false;
+		}
+
+		public void touch() {
+			throw new UnsupportedOperationException();
+		}
+
+		public String suffix() {
+			String suffix = "";
+			String filename = entry.getName();
+			int pos = filename.lastIndexOf('.');
+			if (pos > 0) {
+				suffix = filename.substring(pos + 1);
+			}
+			return suffix;
+		}
+
+		public InputStream inputStream() throws IOException {
+			return parent.getInputStream(entry);
+		}
+
+		public OutputStream outputStream() throws IOException {
+			throw new UnsupportedOperationException();
+		}
+
+		public void write(T contents) {
+			throw new UnsupportedOperationException();
+		}
+	}
+}
diff --git a/modules/wybs/src/wyfs/util/Trie.java b/modules/wybs/src/wyfs/util/Trie.java
new file mode 100755
index 0000000000..0da9e869ec
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/Trie.java
@@ -0,0 +1,372 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyfs.util;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Iterator;
+
+import wyfs.lang.Path;
+
+/**
+ * <p>
+ * Provides a standard implementation of the Path.ID and Path.Filter interfaces.
+ * It employs the <i>flyweight pattern</i> to ensure every ID can only ever
+ * correspond to a single instanceof of Trie. That, it ensures that any two
+ * instances which represent the same Path.ID are, in fact, the same instance.
+ * </p>
+ * <p>
+ * As the name suggests, the implementation is based around a n-ary tree where
+ * each node stores a component of a path. There is a single master root of all
+ * possible paths and all possible instances of <code>Trie</code> extend this.
+ * </p>
+ * <p>
+ * <b>NOTE:</b> the implementation does not currently attempt to garbage collect
+ * tries. Therefore, the memory consumed is proportional to the total number of
+ * distinct tries created throughout the program's life
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public final class Trie implements Path.ID, Path.Filter {
+
+	private static final Trie[] ONE_CHILD = new Trie[1];
+
+	// =========================================================
+	// Public Constants
+	// =========================================================
+
+	public static final Trie ROOT = new Trie(null,"");
+
+	// =========================================================
+	// Private State
+	// =========================================================
+
+	private final Trie parent;
+	private final String component;
+	private final int depth;
+	private final boolean isConcrete;
+	private Trie[] children;
+	private int nchildren;
+
+	// =========================================================
+	// Public Methods
+	// =========================================================
+
+
+	Trie(final Trie parent, final String component) {
+		this.parent = parent;
+		this.component = component;
+		if(parent != null) {
+			this.depth = parent.depth + 1;
+		} else {
+			this.depth = -1;
+		}
+		this.children = ONE_CHILD;
+		this.nchildren = 0;
+		this.isConcrete = (parent == null || parent.isConcrete)
+				&& !component.contains("*");
+	}
+
+	public int size() {
+		return depth + 1;
+	}
+
+	public boolean isConcrete() {
+		return isConcrete;
+	}
+
+	public String get(final int index) {
+		if(index == depth) {
+			return component;
+		} else if(index > depth) {
+			throw new IllegalArgumentException("index out-of-bounds");
+		} else {
+			return parent.get(index);
+		}
+	}
+
+	public boolean matches(Path.ID id) {
+		return match(id, 0, 0, false);
+	}
+
+	public boolean matchesSubpath(Path.ID id) {
+		return match(id, 0, 0, true);
+	}
+
+	public String last() {
+		return component;
+	}
+
+	public Trie parent() {
+		return parent;
+	}
+
+	public Trie subpath(int start, int end) {
+		Trie id = Trie.ROOT;
+		for(int i=start;i!=end;++i) {
+			// TODO: this could be made more efficient
+			id = id.append(get(i));
+		}
+		return id;
+	}
+	public Trie parent(int depth) {
+		if(this.depth < depth) {
+			return this;
+		} else {
+			return parent.parent(depth);
+		}
+	}
+
+	public Iterator<String> iterator() {
+		return new InternalIterator(this);
+	}
+
+	public int compareTo(final Path.ID o) {
+		if(o instanceof Trie) {
+			// We can be efficient here
+			Trie t1 = this;
+			Trie t2 = (Trie) o;
+			while(t1.depth > t2.depth) {
+				t1 = t1.parent;
+			}
+			while(t2.depth > t1.depth) {
+				t2 = t2.parent;
+			}
+			while(t1.parent != t2.parent) {
+				t1 = t1.parent;
+				t2 = t2.parent;
+			}
+			int c = t1.component.compareTo(t2.component);
+			if(c != 0) { return c; }
+			// assert t2 == o
+			int tDepth = t2.depth;
+			if(depth < tDepth) {
+				return -1;
+			} else if(depth > tDepth) {
+				return 1;
+			} else {
+				return 0;
+			}
+		} else {
+			throw new IllegalArgumentException("Attempting to compare Trie with some other Path.ID");
+		}
+	}
+
+	public int hashCode() {
+		int hc = component.hashCode();
+		if(parent != null) {
+			hc = hc ^ parent.hashCode();
+		}
+		return hc;
+	}
+
+	public boolean equals(final Object o) {
+		return this == o;
+	}
+
+	public Trie append(final String component) {
+		int index = binarySearch(children, nchildren, component);
+		if(index >= 0) {
+			return children[index];
+		}
+
+		Trie nt = new Trie(this,component);
+		index = -index - 1; // calculate insertion point
+
+		if((nchildren+1) < children.length) {
+			System.arraycopy(children, index, children, index+1, nchildren - index);
+		} else {
+			Trie[] tmp = new Trie[children.length * 2];
+			System.arraycopy(children, 0, tmp, 0, index);
+			System.arraycopy(children, index, tmp, index+1, nchildren - index);
+			children = tmp;
+		}
+
+		children[index] = nt;
+		nchildren++;
+		return nt;
+	}
+
+	public String toString() {
+		if(parent == null || parent == ROOT) {
+			return component;
+		} else {
+			return parent.toString() + "/" + component;
+		}
+	}
+
+	public String toNativeString() {
+		if(parent == null || parent == ROOT) {
+			return component;
+		} else {
+			return parent.toString() + File.separatorChar + component;
+		}
+	}
+
+	/**
+	 * Construct a Trie from a string, where '/' is the separator.
+	 * s
+	 * @param str
+	 * @return
+	 */
+	public static Trie fromString(String str) {
+		String[] components = str.split("/");
+		Trie r = ROOT;
+		for(int i=0;i!=components.length;++i) {
+			r = r.append(components[i]);
+		}
+		return r;
+	}
+
+	/**
+	 * Construct a Trie from a Path ID.
+	 *
+	 * @param str
+	 * @return
+	 */
+	public static Trie fromString(Path.ID id) {
+		if(id instanceof Trie) {
+			return ((Trie)id);
+		}
+		Trie r = ROOT;
+		for(int i=0;i!=id.size();++i) {
+			r = r.append(id.get(i));
+		}
+		return r;
+	}
+	/**
+	 * Construct a Trie by appending a string onto a Path ID.
+	 *
+	 * @param str
+	 * @return
+	 */
+	public static Trie fromString(Path.ID id, String str) {
+		if(id instanceof Trie) {
+			return ((Trie)id).append(str);
+		}
+		Trie r = ROOT;
+		for(int i=0;i!=id.size();++i) {
+			r = r.append(id.get(i));
+		}
+		r = r.append(str);
+		return r;
+	}
+
+	// =========================================================
+	// Private Methods
+	// =========================================================
+
+	private boolean match(Path.ID id, int idIndex, int myIndex, boolean submatch) {
+		int mySize = depth + 1;
+		if (myIndex == mySize && idIndex == id.size()) {
+			return true;
+		} else if(idIndex == id.size()) {
+			return submatch;
+		} else if (myIndex == mySize) {
+			return false;
+		}
+
+		String myComponent = get(myIndex);
+		if (myComponent.equals("*")) {
+			return match(id, idIndex + 1, myIndex + 1, submatch);
+		} else if (myComponent.equals("**")) {
+			myIndex++;
+			for (int i = idIndex; i <= id.size(); ++i) {
+				if (match(id, i, myIndex, submatch)) {
+					return true;
+				}
+			}
+			return false;
+		} else {
+			return myComponent.equals(id.get(idIndex))
+					&& match(id, idIndex + 1, myIndex + 1, submatch);
+		}
+	}
+
+	private static final int binarySearch(final Trie[] children, final int nchildren, final String key) {
+		int low = 0;
+        int high = nchildren-1;
+
+        while (low <= high) {
+            int mid = (low + high) >> 1;
+            int c = children[mid].component.compareTo(key);
+
+            if (c < 0) {
+                low = mid + 1;
+            } else if (c > 0) {
+                high = mid - 1;
+            } else {
+                return mid;
+            }
+        }
+        return -(low + 1);
+	}
+
+	private static final class InternalIterator implements Iterator<String> {
+		private final Trie id;
+		private int index;
+
+		public InternalIterator(Trie id) {
+			this.id = id;
+			this.index = 0;
+		}
+
+		public boolean hasNext() {
+			return index <= id.depth;
+		}
+
+		public String next() {
+			return id.get(index++);
+		}
+
+		public void remove() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	public static void main(String[] args) {
+		Trie t1 = ROOT.append("Hello");
+		Trie t2 = t1.append("*");
+		Trie t3 = t2.append("Blah");
+		System.out.println("T1: " + t3.parent(1));
+		System.out.println("T2: " + t3.parent(2));
+		System.out.println("T3: " + t3.parent(3));
+		Trie[] ids = {ROOT,t2,t3,t1};
+		for(Trie id : ids) {
+			System.out.println(id + "(" + id.size() + ")");
+		}
+		Arrays.sort(ids);
+		for(Trie id : ids) {
+			System.out.println(id);
+		}
+
+		for(String c : t3) {
+			System.out.println(c);
+		}
+	}
+}
diff --git a/modules/wybs/src/wyfs/util/VirtualRoot.java b/modules/wybs/src/wyfs/util/VirtualRoot.java
new file mode 100755
index 0000000000..784892dd33
--- /dev/null
+++ b/modules/wybs/src/wyfs/util/VirtualRoot.java
@@ -0,0 +1,186 @@
+package wyfs.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Path.ID;
+import wyfs.util.DirectoryRoot.Folder;
+
+/**
+ * <p>
+ * Provides an implementation of <code>Path.Root</code> which stores files in
+ * memory, rather than on disk or within e.g. a Jar file. Initially, a virtual
+ * root is completely empty since there is nothing backing it. Virtual roots are
+ * used to hold temporary files that are generated during compilation and which
+ * one does not want stored on e.g. the file system.
+ * </p>
+ *
+ * <p>
+ * As an example, intermediate Wyil files are often stored in virtual root. The
+ * build task will typically use a virtual root as the default (meaning wyil
+ * files are not written to disk during compilation), but the user can then
+ * override this in order to examine them (e.g. for debugging).
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class VirtualRoot extends AbstractRoot<VirtualRoot.Folder> {
+
+	/**
+	 * Construct a virtual root out of nothing.
+	 *
+	 * @param contentTypes
+	 *            --- registry of known content types and their "suffixes"
+	 * @throws IOException
+	 */
+	public VirtualRoot(Content.Registry contentTypes) {
+		super(contentTypes);
+	}
+
+	@Override
+	protected Folder root() {
+		return new Folder(Trie.ROOT);
+	}
+
+	/**
+	 * An entry is a file on the file system which represents a Whiley module. The
+	 * file may be encoded in a range of different formats. For example, it may be a
+	 * source file and/or a binary wyil file.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Entry<T> extends AbstractEntry<T> implements Path.Entry<T> {
+
+		/**
+		 * The following is use to determine the appropriate "suffix" of an
+		 * entry.
+		 */
+		private final Content.Registry contentTypes;
+
+		/**
+		 * The raw data representing the contents of this file. Initially, this
+		 * is empty as one would expect.
+		 */
+		private byte[] data;
+
+		/**
+		 * Number of bytes in data actually used.
+		 */
+		private int length;
+		
+		/**
+		 * The last modified date. This is a time stamp used to determine when
+		 * the file was last modified in order to calculate which dependents
+		 * need recompilation.
+		 */
+		private long lastModified;
+
+		public Entry(Path.ID id, Content.Registry contentTypes) {
+			super(id);
+			this.data = new byte[0];
+			this.contentTypes = contentTypes;
+		}
+
+		public String location() {
+			return "~:" + id.toString();
+		}
+
+		public String suffix() {
+			return contentTypes.suffix(contentType);
+		}
+
+		public long lastModified() {
+			return lastModified;
+		}
+
+		public InputStream inputStream() {
+			return new ByteArrayInputStream(data,0,length);
+		}
+
+		public OutputStream outputStream() {
+			lastModified = System.currentTimeMillis();
+			data = new byte[0];
+			length = 0;
+			// create an output stream which will automatically resize the given
+			// array.
+			return new OutputStream() {		
+				public void write(byte[] bytes) {
+					data = new byte[bytes.length];
+					System.arraycopy(bytes, 0, data, 0, bytes.length);
+					length = data.length;
+				}
+				public void write(byte[] bytes, int off, int len) {
+					data = new byte[len];
+					System.arraycopy(bytes, off, data, 0, len);
+					length = data.length;
+				}
+				public void write(int b) {
+					if (length >= data.length) {
+						data = Arrays.copyOf(data, (data.length + 1) * 2);
+					}
+					data[length++] = (byte) b;
+				}
+			};
+		}
+
+		public String toString() {
+			return location();
+		}
+	}
+
+	/**
+	 * Represents a directory in the virtual file system.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public final class Folder extends AbstractFolder {
+		public Folder(Path.ID id) {
+			super(id);
+		}
+
+		@Override
+		protected Path.Item[] contents() throws IOException {
+			// Initially, a virtual folder is always empty.
+			return new Path.Item[0];
+		}
+
+		@Override
+		public <T> Path.Entry<T> create(ID nid, Content.Type<T> ct) throws IOException {
+			if (nid.size() == 1) {
+				// attempting to create an entry in this folder
+				Path.Entry<T> e = super.get(nid.subpath(0, 1), ct);
+				if (e == null) {
+					// Entry doesn't already exist, so create it
+					nid = id.append(nid.get(0));
+					e = new Entry(nid, contentTypes);
+					e.associate(ct, null);
+					super.insert(e);
+				}
+				return e;
+			} else {
+				// attempting to create entry in subfolder.
+				Path.Folder folder = getFolder(nid.get(0));
+				if (folder == null) {
+					// Folder doesn't already exist, so create it.
+					folder = new Folder(id.append(nid.get(0)));
+					super.insert(folder);
+				}
+				return folder.create(nid.subpath(1, nid.size()), ct);
+			}
+		}
+
+		public String toString() {
+			return "~:" + id;
+		}
+	}
+}
diff --git a/modules/wyc/build.xml b/modules/wyc/build.xml
index 7a4defa425..1f2f886b5b 100755
--- a/modules/wyc/build.xml
+++ b/modules/wyc/build.xml
@@ -6,9 +6,9 @@
   <import file="../../config.xml"/>
 
   <path id="wyc.classpath">
-    <pathelement path="${WYIL_DIR}/src"/>    
-    <pathelement path="${WYCC_JAR}"/>
-    <pathelement path="${WYTP_JAR}"/>
+    <pathelement path="${WYBS_DIR}/src"/>
+    <pathelement path="${WYIL_DIR}/src"/>
+    <pathelement path="${WYCS_DIR}/src"/>
     <pathelement path="${WYRL_JAR}"/>
     <path refid="junit.classpath"/>
   </path>
@@ -76,7 +76,47 @@
     <echo message="============================================="/>
   </target>
 
- <!-- ================================================================== -->
+  <!-- ================================================================== -->
+  <!-- Dist -->
+  <!-- ================================================================== -->
+
+  <target name="dist">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wyc.WycMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wyc-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${DIST_DIR}/wyc-all-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="${WYBS_DIR}/src">
+	<include name="wybs/**/*.class"/>
+	<include name="wycc/**/*.class"/>
+	<include name="wyfs/**/*.class"/>
+      </fileset>
+      <fileset dir="${WYCS_DIR}/src">
+	<include name="wycs/**/*.class"/>
+	<exclude name="wyc/testing/**"/>
+      </fileset>
+      <fileset dir="${WYIL_DIR}/src">
+	<include name="wyautl_old/**/*.class"/>
+	<include name="wybs/**/*.class"/>
+	<include name="wycs/**/*.class"/>
+	<include name="wyil/**/*.class"/>
+      </fileset>
+      <fileset dir="src">
+	<include name="wyc/**/*.class"/>
+	<include name="wyjc/**/*.class"/>
+	<include name="wyjvm/**/*.class"/>
+      </fileset>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: dist/${ant.project.name}-all-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
   <!-- Clean -->
   <!-- ================================================================== -->
 
diff --git a/modules/wyc/src/wyc/WycMain.java b/modules/wyc/src/wyc/WycMain.java
new file mode 100755
index 0000000000..c6fabdb589
--- /dev/null
+++ b/modules/wyc/src/wyc/WycMain.java
@@ -0,0 +1,395 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyc;
+
+import java.io.*;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.URI;
+import java.util.*;
+
+import wybs.lang.*;
+import wybs.util.*;
+import wyc.builder.WhileyBuilder;
+import wyc.lang.WhileyFile;
+import wyc.util.*;
+import wycc.lang.Pipeline;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.lang.Pipeline.Template;
+import wycc.lang.SyntaxError.InternalFailure;
+import wycc.util.OptArg;
+import wyil.*;
+import wyil.lang.WyilFile;
+import wyil.util.*;
+import static wycc.lang.SyntaxError.*;
+
+/**
+ * The main class provides all of the necessary plumbing to process command-line
+ * options, construct an appropriate pipeline and then instantiate the Whiley
+ * Compiler to generate class files.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WycMain {
+
+	public static final int MAJOR_VERSION;
+	public static final int MINOR_VERSION;
+	public static final int MINOR_REVISION;
+	public static final int BUILD_NUMBER;
+
+	public static final int SUCCESS = 0;
+	public static final int SYNTAX_ERROR = 1;
+	public static final int INTERNAL_FAILURE = 2;
+
+	public static final OptArg[] DEFAULT_OPTIONS = new OptArg[] {
+			new OptArg("help", "Print this help information"),
+			new OptArg("version", "Print version information"),
+			new OptArg("verbose",
+					"Print detailed information on what the compiler is doing"),
+			new OptArg("brief", "Enable brief reporting of error messages"),
+			new OptArg("verify",
+					"Enable detailed verification checking"),					
+			new OptArg("smt-verify",
+					"Enable detailed verification checking using an external SMT solver"),
+			new OptArg("vcs", "Enable generation of verification conditions"),
+			new OptArg("whileypath", "wp", OptArg.FILELIST,
+					"Specify where to find whiley (binary) files",
+					new ArrayList<String>()),
+			new OptArg("bootpath", "bp", OptArg.FILELIST,
+					"Specify where to find whiley standard library files",
+					new ArrayList<String>()),
+			new OptArg("whileydir", "wd", OptArg.FILEDIR,
+					"Specify where to find whiley source files", new File(".")),
+			new OptArg("wyildir", "od", OptArg.FILEDIR,
+					"Specify where to place generated wyil files"),
+			new OptArg("wyaldir", OptArg.FILEDIR,
+					"Specify where to place generated wyal files"),
+					new OptArg("wycsdir", OptArg.FILEDIR,
+					"Specify where to place generated wycs files"),
+			new OptArg("X", OptArg.PIPELINECONFIGURE,
+					"configure existing pipeline stage"),
+			new OptArg("A", OptArg.PIPELINEAPPEND, "append new pipeline stage"),
+			new OptArg("R", OptArg.PIPELINEREMOVE,
+					"remove existing pipeline stage") };
+
+	/**
+	 * Initialise the error output stream so as to ensure it will display
+	 * unicode characters (when possible). Additionally, extract version
+	 * information from the enclosing jar file.
+	 */
+	static {
+
+		// determine version numbering from the MANIFEST attributes
+		String versionStr = WycMain.class.getPackage()
+				.getImplementationVersion();
+		if (versionStr != null) {
+			String[] vb = versionStr.split("-");
+			String[] pts = vb[0].split("\\.");
+			if (vb.length == 1) {
+				BUILD_NUMBER = 0;
+			} else {
+				BUILD_NUMBER = Integer.parseInt(vb[1]);
+			}
+
+			MAJOR_VERSION = Integer.parseInt(pts[0]);
+			MINOR_VERSION = Integer.parseInt(pts[1]);
+			MINOR_REVISION = Integer.parseInt(pts[2]);
+		} else {
+			System.err.println("WARNING: version numbering unavailable");
+			MAJOR_VERSION = 0;
+			MINOR_VERSION = 0;
+			MINOR_REVISION = 0;
+			BUILD_NUMBER = 0;
+		}
+	}
+
+	// =========================================================================
+	// Instance Fields
+	// =========================================================================
+
+	/**
+	 * The command-line options accepted by the main method.
+	 */
+	protected final OptArg[] options;
+
+	/**
+	 * The build-task responsible for actually compiling and building files.
+	 */
+	protected final WycBuildTask builder;
+
+	/**
+	 * Stream to which error messages are written
+	 */
+	public PrintStream stderr;
+
+	/**
+	 * Stream to which non-error messages are written
+	 */
+	public  PrintStream stdout;
+	// =========================================================================
+	// Constructors & Configuration
+	// =========================================================================
+
+	public WycMain(WycBuildTask builder, OptArg[] options) {
+		this(builder,options,System.out,System.err);
+	}
+
+	public WycMain(WycBuildTask builder, OptArg[] options, OutputStream stdout, OutputStream stderr) {
+		this.options = options;
+		this.builder = builder;
+		try {
+			this.stderr = new PrintStream(stderr, true, "UTF-8");
+			this.stdout = new PrintStream(stdout, true, "UTF-8");
+		} catch (Exception e) {
+			this.stdout = new PrintStream(stdout);
+			this.stderr = new PrintStream(stderr);
+		}
+	}
+
+	// =========================================================================
+	// Run Method
+	// =========================================================================
+
+	public int run(String[] _args) {
+		boolean verbose = false;
+		boolean brief = false;
+
+		try {
+			// =====================================================================
+			// Process Options
+			// =====================================================================
+
+			ArrayList<String> args = new ArrayList<String>(Arrays.asList(_args));
+			Map<String, Object> values = OptArg.parseOptions(args, options);
+
+			// Second, check if we're printing version
+			if (values.containsKey("version")) {
+				version();
+				return SUCCESS;
+			}
+
+			// Otherwise, if no files to compile specified, then print usage
+			if (args.isEmpty() || values.containsKey("help")) {
+				usage();
+				return SUCCESS;
+			}
+
+			brief = values.containsKey("brief");
+
+			// =====================================================================
+			// Configure Build Task & Sanity Check
+			// =====================================================================
+			verbose = values.containsKey("verbose");
+
+			configure(values);
+
+			ArrayList<File> delta = new ArrayList<File>();
+			for (String arg : args) {
+				delta.add(new File(arg));
+			}
+
+			// sanity check we've actually compiling things that exist
+			for(File f : delta) {
+				if(!f.exists()) {
+					stderr.println("wyc: file not found: " + f.getName());
+					return INTERNAL_FAILURE;
+				}
+			}
+
+			// =====================================================================
+			// Run Build Task
+			// =====================================================================
+
+			builder.build(delta);
+
+		} catch (InternalFailure e) {
+			e.outputSourceError(stderr,brief);
+			if (verbose) {
+				printStackTrace(stderr,e);				
+			}
+			return INTERNAL_FAILURE;
+		} catch (SyntaxError e) {
+			e.outputSourceError(stderr,brief);
+			if (verbose) {
+				printStackTrace(stderr,e);				
+			}
+			return SYNTAX_ERROR;
+		} catch (Throwable e) {
+			stderr.println("internal failure (" + e.getMessage() + ")");
+			if (verbose) {
+				printStackTrace(stderr,e);				
+			}
+			return INTERNAL_FAILURE;
+		}
+
+		return SUCCESS;
+	}
+
+	// =========================================================================
+	// Helper Methods
+	// =========================================================================
+
+	public void configure(Map<String,Object> values) throws IOException {
+		boolean verbose = values.containsKey("verbose");
+
+		builder.setVerbose(verbose);
+		builder.setVerification(values.containsKey("verify"));
+		builder.setSmtVerification(values.containsKey("smt-verify"));
+		builder.setVerificationConditions(values.containsKey("vcs"));
+
+		ArrayList<Pipeline.Modifier> pipelineModifiers = (ArrayList) values
+				.get("pipeline");
+		if (pipelineModifiers != null) {
+			builder.setPipelineModifiers(pipelineModifiers);
+		}
+
+		File whileyDir = (File) values.get("whileydir");
+		builder.setWhileyDir(whileyDir);
+
+		File wyilDir = (File) values.get("wyildir");
+		if (wyilDir != null) {
+			builder.setWyilDir(wyilDir);
+		}
+		File wyalDir = (File) values.get("wyaldir");
+		if (wyalDir != null) {
+			builder.setWyalDir(wyalDir);
+		}
+		File wycsDir = (File) values.get("wycsdir");
+		if (wycsDir != null) {
+			builder.setWycsDir(wycsDir);
+		}
+
+		ArrayList<File> bootpath = (ArrayList<File>) values.get("bootpath");
+		builder.setBootPath(bootpath);
+
+		ArrayList<File> whileypath = (ArrayList<File>) values
+				.get("whileypath");
+		builder.setWhileyPath(whileypath);
+	}
+
+	protected void version() {
+		stdout.println("Whiley Compiler (wyc) version "
+				+ MAJOR_VERSION + "." + MINOR_VERSION + "."
+				+ MINOR_REVISION + " (build " + BUILD_NUMBER + ")");
+	}
+
+	protected void usage() {
+		stdout.println("usage: wyc <options> <source-files>");
+		OptArg.usage(stdout, options);
+		usage(stdout, WycBuildTask.defaultPipeline);
+	}
+
+	/**
+	 * Print out the available list of options for the given pipeline
+	 */
+	protected void usage(PrintStream out, List<Pipeline.Template> stages) {
+		out.println("\nPipeline configuration:");
+		for (Template template : stages) {
+			Class<? extends Transform> t = template.clazz;
+			out.println("  -X " + t.getSimpleName().toLowerCase() + ":\t");
+			for (Method m : t.getDeclaredMethods()) {
+				String name = m.getName();
+				if (name.startsWith("set")) {
+					String shortName = name.substring(3).toLowerCase();
+					out.print("    " + shortName + "(" + argValues(m) + ")");
+					// print default value
+					try {
+						Method getter = t.getDeclaredMethod(name.replace("set",
+								"get"));
+						Object v = getter.invoke(null);
+						out.print("[default=" + v + "]");
+					} catch (NoSuchMethodException e) {
+						// just ignore
+					} catch (IllegalArgumentException e) {
+						// just ignore
+					} catch (IllegalAccessException e) {
+						// just ignore
+					} catch (InvocationTargetException e) {
+						// just ignore
+					}
+					// print description
+					try {
+						Method desc = t.getDeclaredMethod(name.replace("set",
+								"describe"));
+						Object v = desc.invoke(null);
+						out.print("\t" + v);
+					} catch (NoSuchMethodException e) {
+						// just ignore
+					} catch (IllegalArgumentException e) {
+						// just ignore
+					} catch (IllegalAccessException e) {
+						// just ignore
+					} catch (InvocationTargetException e) {
+						// just ignore
+					}
+					out.println();
+				}
+			}
+		}
+	}
+
+	protected static String argValues(Method m) {
+		String r = "";
+		for (Class<?> p : m.getParameterTypes()) {
+			if (p == boolean.class) {
+				r = r + "boolean";
+			} else if (p == int.class) {
+				r = r + "int";
+			} else if (p == String.class) {
+				r = r + "string";
+			}
+		}
+		return r;
+	}
+
+	/**
+	 * Print a complete stack trace. This differs from
+	 * Throwable.printStackTrace() in that it always prints all of the trace.
+	 * 
+	 * @param out
+	 * @param err
+	 */
+	protected static void printStackTrace(PrintStream out, Throwable err) {
+		out.println(err.getClass().getName() + ": " + err.getMessage());
+		for(StackTraceElement ste : err.getStackTrace()) {			
+			out.println("\tat " + ste.toString());
+		}
+		if(err.getCause() != null) {
+			out.print("Caused by: ");
+			printStackTrace(out,err.getCause());
+		}
+	}
+	
+	// =========================================================================
+	// Main Method
+	// =========================================================================
+
+	public static void main(String[] args) {
+		System.exit(new WycMain(new WycBuildTask(), DEFAULT_OPTIONS).run(args));
+	}
+}
\ No newline at end of file
diff --git a/modules/wyc/src/wyc/builder/CodeGenerator.java b/modules/wyc/src/wyc/builder/CodeGenerator.java
index 0faf316b68..cd15376df7 100755
--- a/modules/wyc/src/wyc/builder/CodeGenerator.java
+++ b/modules/wyc/src/wyc/builder/CodeGenerator.java
@@ -27,19 +27,18 @@
 
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.NameID;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError;
-import wybs.util.ResolveError;
-
 import static wyc.lang.WhileyFile.internalFailure;
 import static wyil.util.ErrorMessages.*;
 import wyc.lang.*;
 import wyc.lang.Stmt.*;
 import wyc.lang.WhileyFile.Context;
-import wycommon.util.Pair;
-import wycommon.util.Triple;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
 import wyfs.lang.Path;
 import wyil.lang.*;
 import wyil.lang.Bytecode.AliasDeclaration;
diff --git a/modules/wyc/src/wyc/builder/DefiniteAssignmentAnalysis.java b/modules/wyc/src/wyc/builder/DefiniteAssignmentAnalysis.java
index ab0d269cb6..2ca9e77b8f 100755
--- a/modules/wyc/src/wyc/builder/DefiniteAssignmentAnalysis.java
+++ b/modules/wyc/src/wyc/builder/DefiniteAssignmentAnalysis.java
@@ -3,9 +3,10 @@
 import wyc.lang.Expr;
 import wyc.lang.Stmt;
 import wyc.lang.WhileyFile;
-import wycommon.util.Triple;
+import wycc.lang.SyntaxError;
+import wycc.util.Triple;
 
-import static wybs.lang.SyntaxError.*;
+import static wycc.lang.SyntaxError.*;
 import static wyil.util.ErrorMessages.VARIABLE_POSSIBLY_UNITIALISED;
 import static wyil.util.ErrorMessages.errorMessage;
 
@@ -13,8 +14,6 @@
 import java.util.List;
 import java.util.Map;
 
-import wybs.lang.SyntaxError;
-
 /**
  * <p>
  * Responsible for checking that all variables are defined before they are used.
diff --git a/modules/wyc/src/wyc/builder/FlowTypeChecker.java b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
index be99bfcfa5..af37c94f23 100755
--- a/modules/wyc/src/wyc/builder/FlowTypeChecker.java
+++ b/modules/wyc/src/wyc/builder/FlowTypeChecker.java
@@ -25,9 +25,9 @@
 
 package wyc.builder;
 
-import static wybs.lang.SyntaxError.InternalFailure;
 import static wyc.lang.WhileyFile.internalFailure;
 import static wyc.lang.WhileyFile.syntaxError;
+import static wycc.lang.SyntaxError.InternalFailure;
 import static wyil.util.ErrorMessages.*;
 
 import java.io.IOException;
@@ -40,8 +40,12 @@
 import wybs.util.*;
 import wyc.lang.*;
 import wyc.lang.WhileyFile.Context;
-import wycommon.util.Pair;
-import wycommon.util.Triple;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
 import wyfs.lang.Path;
 import wyfs.util.Trie;
 import wyil.lang.Constant;
diff --git a/modules/wyc/src/wyc/builder/WhileyBuilder.java b/modules/wyc/src/wyc/builder/WhileyBuilder.java
index 533d1ce818..2dbe2d6ce3 100755
--- a/modules/wyc/src/wyc/builder/WhileyBuilder.java
+++ b/modules/wyc/src/wyc/builder/WhileyBuilder.java
@@ -31,14 +31,18 @@
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyfs.util.Trie;
-import wyil.checks.CoercionCheck;
-import wyil.checks.ModuleCheck;
+import wyil.*;
 import wyil.lang.*;
+import wyil.util.*;
 import wybs.lang.*;
 import wybs.util.*;
 import wyc.lang.*;
-import wycommon.util.Logger;
-import wycommon.util.Pair;
+import wycc.lang.NameID;
+import wycc.lang.Pipeline;
+import wycc.lang.Transform;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
 
 /**
  * Responsible for managing the process of turning source files into binary code
@@ -84,7 +88,7 @@
  * @author David J. Pearce
  *
  */
-public final class WhileyBuilder implements Build.Task {
+public final class WhileyBuilder implements Builder {
 
 	/**
 	 * The master project for identifying all resources available to the
@@ -94,8 +98,10 @@
 	private final Build.Project project;
 
 	/**
-	 * The logger used for logging system events
+	 * The list of stages which must be applied to a Wyil file.
 	 */
+	private final List<Transform<WyilFile>> stages;
+
 	private Logger logger;
 
 	/**
@@ -109,16 +115,13 @@
 	 * time. For example, the statement <code>import whiley.lang.*</code>
 	 * corresponds to the triple <code>("whiley.lang",*,null)</code>.
 	 */
-	private final HashMap<Trie,ArrayList<Path.ID>> importCache = new HashMap<>();
+	private final HashMap<Trie,ArrayList<Path.ID>> importCache = new HashMap();
 
-	public WhileyBuilder(Build.Project namespace) {
+	public WhileyBuilder(Build.Project namespace, Pipeline<WyilFile> pipeline) {
+		this.stages = pipeline.instantiate(this);
 		this.logger = Logger.NULL;
 		this.project = namespace;
 	}
-	
-	public String id() {
-		return "wyc.builder";
-	}
 
 	public Build.Project project() {
 		return project;
@@ -128,7 +131,6 @@ public void setLogger(Logger logger) {
 		this.logger = logger;
 	}
 
-	@SuppressWarnings("unchecked")
 	@Override
 	public Set<Path.Entry<?>> build(Collection<Pair<Path.Entry<?>, Path.Root>> delta, Build.Graph graph)
 			throws IOException {
@@ -148,7 +150,7 @@ public void setLogger(Logger logger) {
 			Path.Entry<?> src = p.first();
 			if (src.contentType() == WhileyFile.ContentType) {
 				Path.Entry<WhileyFile> sf = (Path.Entry<WhileyFile>) src;
-				sf.read(); // force file to be parsed
+				WhileyFile wf = sf.read();
 				count++;
 				srcFiles.put(sf.id(), sf);
 			}
@@ -213,12 +215,14 @@ public void setLogger(Logger logger) {
 		// Pipeline Stages
 		// ========================================================================
 
-		for (Pair<Path.Entry<?>, Path.Root> p : delta) {
-			Path.Entry<?> src = p.first();
-			Path.Root dst = p.second();
-			Path.Entry<WyilFile> wf = dst.get(src.id(), WyilFile.ContentType);
-			new ModuleCheck(this).apply(wf.read());
-			new CoercionCheck(this).apply(wf.read());
+		for (Transform stage : stages) {
+			for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+				Path.Entry<?> src = p.first();
+				Path.Root dst = p.second();
+				Path.Entry<WyilFile> wf = dst.get(src.id(),
+						WyilFile.ContentType);
+				process(wf.read(), stage);
+			}
 		}
 
 		// ========================================================================
@@ -346,39 +350,39 @@ public WyilFile getModule(Path.ID mid) throws IOException {
 	// Private Implementation
 	// ======================================================================
 
-//	private void process(WyilFile module) throws IOException {
-//		Runtime runtime = Runtime.getRuntime();
-//		long start = System.currentTimeMillis();
-//		long memory = runtime.freeMemory();
-//		String name = name(stage.getClass().getSimpleName());
-//
-//		try {
-//			stage.apply(module);
-//			logger.logTimedMessage("[" + module.getEntry().location() + "] applied " + name,
-//					System.currentTimeMillis() - start, memory - runtime.freeMemory());
-//			System.gc();
-//		} catch (RuntimeException ex) {
-//			logger.logTimedMessage("[" + module.getEntry().location() + "] failed on " + name + " (" + ex.getMessage() + ")",
-//					System.currentTimeMillis() - start, memory - runtime.freeMemory());
-//			throw ex;
-//		} catch (IOException ex) {
-//			logger.logTimedMessage("[" + module.getEntry().location() + "] failed on " + name + " (" + ex.getMessage() + ")",
-//					System.currentTimeMillis() - start, memory - runtime.freeMemory());
-//			throw ex;
-//		}
-//	}
-//
-//	private static String name(String camelCase) {
-//		boolean firstTime = true;
-//		String r = "";
-//		for(int i=0;i!=camelCase.length();++i) {
-//			char c = camelCase.charAt(i);
-//			if(!firstTime && Character.isUpperCase(c)) {
-//				r += " ";
-//			}
-//			firstTime=false;
-//			r += Character.toLowerCase(c);;
-//		}
-//		return r;
-//	}
+	private void process(WyilFile module, Transform stage) throws IOException {
+		Runtime runtime = Runtime.getRuntime();
+		long start = System.currentTimeMillis();
+		long memory = runtime.freeMemory();
+		String name = name(stage.getClass().getSimpleName());
+
+		try {
+			stage.apply(module);
+			logger.logTimedMessage("[" + module.getEntry().location() + "] applied " + name,
+					System.currentTimeMillis() - start, memory - runtime.freeMemory());
+			System.gc();
+		} catch (RuntimeException ex) {
+			logger.logTimedMessage("[" + module.getEntry().location() + "] failed on " + name + " (" + ex.getMessage() + ")",
+					System.currentTimeMillis() - start, memory - runtime.freeMemory());
+			throw ex;
+		} catch (IOException ex) {
+			logger.logTimedMessage("[" + module.getEntry().location() + "] failed on " + name + " (" + ex.getMessage() + ")",
+					System.currentTimeMillis() - start, memory - runtime.freeMemory());
+			throw ex;
+		}
+	}
+
+	private static String name(String camelCase) {
+		boolean firstTime = true;
+		String r = "";
+		for(int i=0;i!=camelCase.length();++i) {
+			char c = camelCase.charAt(i);
+			if(!firstTime && Character.isUpperCase(c)) {
+				r += " ";
+			}
+			firstTime=false;
+			r += Character.toLowerCase(c);;
+		}
+		return r;
+	}
 }
diff --git a/modules/wyc/src/wyc/io/WhileyFileLexer.java b/modules/wyc/src/wyc/io/WhileyFileLexer.java
index 7193c8193a..77ce7150fa 100755
--- a/modules/wyc/src/wyc/io/WhileyFileLexer.java
+++ b/modules/wyc/src/wyc/io/WhileyFileLexer.java
@@ -35,10 +35,10 @@
 import java.util.HashMap;
 import java.util.List;
 
-import wybs.lang.Attribute;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError;
 import wyc.lang.WhileyFile;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
 import wyfs.lang.Path;
 
 /**
diff --git a/modules/wyc/src/wyc/io/WhileyFileParser.java b/modules/wyc/src/wyc/io/WhileyFileParser.java
index 81a8dab299..3aef0c4914 100755
--- a/modules/wyc/src/wyc/io/WhileyFileParser.java
+++ b/modules/wyc/src/wyc/io/WhileyFileParser.java
@@ -36,20 +36,19 @@
 import java.util.List;
 import java.util.Set;
 
-import wybs.lang.Attribute;
-import wybs.lang.NameID;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError;
 import wyc.lang.*;
 import wyc.lang.Expr.ConstantAccess;
 import wyc.io.WhileyFileLexer.Token;
 import static wyil.util.ErrorMessages.*;
-import static wybs.lang.SyntaxError.*;
 import static wyc.io.WhileyFileLexer.Token.Kind.*;
-
+import static wycc.lang.SyntaxError.*;
 import wyc.lang.WhileyFile.*;
-import wycommon.util.Pair;
-import wycommon.util.Triple;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.util.Pair;
+import wycc.util.Triple;
 import wyfs.lang.Path;
 import wyfs.util.Trie;
 import wyil.lang.Modifier;
diff --git a/modules/wyc/src/wyc/io/WhileyFilePrinter.java b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
index cea8220284..6643fb5b22 100755
--- a/modules/wyc/src/wyc/io/WhileyFilePrinter.java
+++ b/modules/wyc/src/wyc/io/WhileyFilePrinter.java
@@ -11,7 +11,7 @@
 import wyc.lang.Stmt;
 import wyc.lang.SyntacticType;
 import wyc.lang.WhileyFile;
-import wycommon.util.Pair;
+import wycc.util.Pair;
 import wyil.lang.*;
 
 /**
diff --git a/modules/wyc/src/wyc/lang/Expr.java b/modules/wyc/src/wyc/lang/Expr.java
index d5ad120418..cbdd107839 100755
--- a/modules/wyc/src/wyc/lang/Expr.java
+++ b/modules/wyc/src/wyc/lang/Expr.java
@@ -27,13 +27,13 @@
 
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.NameID;
-import wybs.lang.SyntacticElement;
 import wyc.builder.FlowTypeChecker;
 import wyc.io.WhileyFileLexer;
-import wycommon.util.Pair;
-import wycommon.util.Triple;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+import wycc.util.Triple;
 import wyfs.lang.Path;
 import wyil.lang.*;
 
diff --git a/modules/wyc/src/wyc/lang/Exprs.java b/modules/wyc/src/wyc/lang/Exprs.java
index 947f9c2772..e867927ddf 100755
--- a/modules/wyc/src/wyc/lang/Exprs.java
+++ b/modules/wyc/src/wyc/lang/Exprs.java
@@ -4,9 +4,9 @@
 
 import java.util.HashSet;
 
-import wybs.lang.SyntaxError;
 import wyc.lang.WhileyFile.Context;
-import wycommon.util.Pair;
+import wycc.lang.SyntaxError;
+import wycc.util.Pair;
 import wyil.lang.Type;
 
 public class Exprs {
diff --git a/modules/wyc/src/wyc/lang/Nominal.java b/modules/wyc/src/wyc/lang/Nominal.java
index 358391f63d..b31f0d0585 100755
--- a/modules/wyc/src/wyc/lang/Nominal.java
+++ b/modules/wyc/src/wyc/lang/Nominal.java
@@ -2,7 +2,7 @@
 
 import java.util.*;
 
-import wycommon.util.Pair;
+import wycc.util.Pair;
 import wyil.lang.Type;
 
 /**
diff --git a/modules/wyc/src/wyc/lang/Stmt.java b/modules/wyc/src/wyc/lang/Stmt.java
index 4ebc2df7e1..8fb618cbe9 100755
--- a/modules/wyc/src/wyc/lang/Stmt.java
+++ b/modules/wyc/src/wyc/lang/Stmt.java
@@ -27,8 +27,8 @@
 
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.SyntacticElement;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
 import wyil.lang.Constant;
 import wyil.util.*;
 
diff --git a/modules/wyc/src/wyc/lang/SyntacticType.java b/modules/wyc/src/wyc/lang/SyntacticType.java
index 55b3af25b9..61e20fb393 100755
--- a/modules/wyc/src/wyc/lang/SyntacticType.java
+++ b/modules/wyc/src/wyc/lang/SyntacticType.java
@@ -27,9 +27,9 @@
 
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.SyntacticElement;
 import wyc.lang.SyntacticType.NonUnion;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
 
 /**
  * <p>
diff --git a/modules/wyc/src/wyc/lang/WhileyFile.java b/modules/wyc/src/wyc/lang/WhileyFile.java
index 3ad0fffdc6..a3860328d1 100755
--- a/modules/wyc/src/wyc/lang/WhileyFile.java
+++ b/modules/wyc/src/wyc/lang/WhileyFile.java
@@ -28,13 +28,13 @@
 import java.io.*;
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.CompilationUnit;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError;
-import wybs.util.AbstractCompilationUnit;
 import wyc.io.WhileyFileLexer;
 import wyc.io.WhileyFileParser;
+import wycc.lang.Attribute;
+import wycc.lang.CompilationUnit;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.util.AbstractCompilationUnit;
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyfs.util.Trie;
diff --git a/modules/wyc/src/wyc/testing/AllInvalidTests.java b/modules/wyc/src/wyc/testing/AllInvalidTests.java
index 9395822e34..fd26a34424 100755
--- a/modules/wyc/src/wyc/testing/AllInvalidTests.java
+++ b/modules/wyc/src/wyc/testing/AllInvalidTests.java
@@ -44,7 +44,7 @@
 
 import wyc.WycMain;
 import wyc.util.WycBuildTask;
-import wycommon.util.Pair;
+import wycc.util.Pair;
 
 /**
  * Run through all invalid test cases with verification enabled. Since every
diff --git a/modules/wyc/src/wyc/testing/AllValidTests.java b/modules/wyc/src/wyc/testing/AllValidTests.java
index e9041d8f27..a07e67d298 100755
--- a/modules/wyc/src/wyc/testing/AllValidTests.java
+++ b/modules/wyc/src/wyc/testing/AllValidTests.java
@@ -45,7 +45,7 @@
 import wybs.util.StdProject;
 import wyc.WycMain;
 import wyc.util.WycBuildTask;
-import wycommon.util.Pair;
+import wycc.util.Pair;
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyfs.util.DirectoryRoot;
diff --git a/modules/wyc/src/wyc/testing/AllValidVerificationTests.java b/modules/wyc/src/wyc/testing/AllValidVerificationTests.java
index 3bd7dc3bbe..eacf6ee46b 100755
--- a/modules/wyc/src/wyc/testing/AllValidVerificationTests.java
+++ b/modules/wyc/src/wyc/testing/AllValidVerificationTests.java
@@ -39,7 +39,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 import wyc.WycMain;
-import wycommon.util.Pair;
+import wycc.util.Pair;
 
 /**
  * Run through all valid test cases with verification enabled. Since every test
diff --git a/modules/wyc/src/wyc/testing/TestUtils.java b/modules/wyc/src/wyc/testing/TestUtils.java
index a322338ca3..5c24ec792c 100755
--- a/modules/wyc/src/wyc/testing/TestUtils.java
+++ b/modules/wyc/src/wyc/testing/TestUtils.java
@@ -9,11 +9,11 @@
 import java.util.Comparator;
 
 import wybs.lang.Build;
-import wybs.lang.NameID;
 import wybs.util.StdProject;
 import wyc.WycMain;
 import wyc.util.WycBuildTask;
-import wycommon.util.Pair;
+import wycc.lang.NameID;
+import wycc.util.Pair;
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyfs.util.DirectoryRoot;
diff --git a/modules/wyc/src/wyc/util/WycAntTask.java b/modules/wyc/src/wyc/util/WycAntTask.java
new file mode 100755
index 0000000000..29608870ec
--- /dev/null
+++ b/modules/wyc/src/wyc/util/WycAntTask.java
@@ -0,0 +1,144 @@
+// Copyright (c) 2012, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyc.util;
+
+import java.io.*;
+import java.util.*;
+
+import wybs.lang.*;
+import wybs.util.*;
+import wyc.builder.WhileyBuilder;
+import wyc.lang.WhileyFile;
+import wycc.lang.SyntaxError.InternalFailure;
+import wyil.lang.WyilFile;
+
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.taskdefs.MatchingTask;
+
+/**
+ * This class implements an baseline ant task for compiling whiley files via ant
+ * and an appropriate build.xml file. The following illustrates how this task
+ * can be used in a build.xml file:
+ *
+ * <pre>
+ * <taskdef name="wyc" classname="wyc.util.AntTask" classpath="lib/wyc.jar"/>
+ * <wyc whileydir="stdlib" includes="whiley\/**\/*.whiley" excludes="whiley/io/**"/>
+ * </pre>
+ *
+ * <p>
+ * The first line defines the new task, and requires <code>wyc.jar</code> (which
+ * contains this class) to be on the classpath; The second invokes the task to
+ * compile all files rooted in the <code>stdlib/</code> directory which are in
+ * the <code>whiley/</code> package, excluding those in <code>whiley/io</code>.
+ * </p>
+ *
+ * <p>
+ * <b>NOTE:</b> this class is intended to be overriden by the compiler backends
+ * which compile Wyil bytecodes to different architectures (e.g. JVM, C,
+ * JavaScript, etc).
+ * </p>
+ *
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WycAntTask extends MatchingTask {
+
+	protected final WycBuildTask builder;
+
+	public WycAntTask() {
+		this.builder = new WycBuildTask();
+	}
+
+	public WycAntTask(WycBuildTask builder) {
+		this.builder = builder;
+	}
+
+	public void setWhileydir(File dir) throws IOException {
+		builder.setWhileyDir(dir);
+	}
+
+    public void setWyildir (File dir) throws IOException {
+    	builder.setWyilDir(dir);
+    }
+
+    public void setWyaldir (File dir) throws IOException {
+    	builder.setWyalDir(dir);
+    }
+    
+    public void setWycsdir (File dir) throws IOException {
+    	builder.setWycsDir(dir);
+    }
+    
+    public void setIncludes(String includes) {
+    	builder.setIncludes(includes);
+    }
+
+    public void setExcludes(String excludes) {
+    	builder.setExcludes(excludes);
+    }
+
+    public void setWhileyPath (org.apache.tools.ant.types.Path path) throws IOException {
+    	ArrayList<File> whileypath = new ArrayList<File>();
+    	for(String file : path.list()) {
+    		whileypath.add(new File(file));
+    	}
+    	builder.setWhileyPath(whileypath);
+    }
+
+    public void setBootPath (org.apache.tools.ant.types.Path path) throws IOException {
+    	ArrayList<File> bootpath = new ArrayList<File>();
+    	for(String file : path.list()) {
+    		bootpath.add(new File(file));
+    	}
+    	builder.setBootPath(bootpath);
+    }
+
+    public void setVerbose(boolean b) {
+    	builder.setVerbose(b);
+    }
+
+    public void setVerification(boolean b) {
+    	builder.setVerification(b);
+    }
+
+    public void setVerificationConditions(boolean b) {
+    	builder.setVerificationConditions(b);
+    }
+    
+    public void execute() throws BuildException {
+    	try {
+    		int count = builder.buildAll();
+    		if(builder.getVerification()) {
+    			log("Compiled and Verified " + count + " source file(s)");
+    		} else {
+    			log("Compiled " + count + " source file(s)");
+    		}
+    	} catch(Exception e) {
+    		throw new BuildException(e);
+    	}
+    }
+}
diff --git a/modules/wyc/src/wyc/util/WycBuildTask.java b/modules/wyc/src/wyc/util/WycBuildTask.java
new file mode 100755
index 0000000000..2ac1dd6d44
--- /dev/null
+++ b/modules/wyc/src/wyc/util/WycBuildTask.java
@@ -0,0 +1,662 @@
+package wyc.util;
+
+import java.io.*;
+import java.util.*;
+
+import wybs.lang.*;
+import wybs.util.*;
+import wyfs.lang.Content;
+import wyfs.lang.Content.Filter;
+import wyfs.lang.Content.Type;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+import wyfs.lang.Path.ID;
+import wyfs.util.DirectoryRoot;
+import wyfs.util.JarFileRoot;
+import wyfs.util.VirtualRoot;
+import wyil.builders.Wyil2WyalBuilder;
+import wyil.checks.*;
+import wyc.builder.WhileyBuilder;
+import wyc.lang.WhileyFile;
+import wycc.lang.Pipeline;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycs.builders.Wyal2WycsBuilder;
+import wycs.core.WycsFile;
+import wycs.syntax.WyalFile;
+import wycs.transforms.VerificationCheck;
+import wycs.util.WycsBuildTask;
+import wyil.io.WyilFilePrinter;
+import wyil.lang.WyilFile;
+
+/**
+ * <p>
+ * Provides a general-purpose implementation for compiling Whiley source files
+ * into Wyil binary files. This is designed to make it easy to write compiler
+ * variants, such as for supporting different back-ends (e.g. Java or
+ * JavaScript) or for interfacing with other frameworks (e.g. Ant). This class
+ * is designed to be extended by clients which are providing some kind of
+ * compiler extension.
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WycBuildTask {
+
+	/**
+	 * The purpose of the source file filter is simply to ensure only source
+	 * files are loaded in a given directory root. It is not strictly necessary
+	 * for correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter whileyFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".whiley") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The purpose of the binary file filter is simply to ensure only binary
+	 * files are loaded in a given directory root. It is not strictly necessary
+	 * for correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter wyilFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wyil") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The purpose of the wyal file filter is simply to ensure only binary
+	 * files are loaded in a given directory root. It is not strictly necessary
+	 * for correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter wyalFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wyal") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The purpose of the wycs file filter is simply to ensure only binary
+	 * files are loaded in a given directory root. It is not strictly necessary
+	 * for correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter wycsFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wycs") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The purpose of the wyil or wycs file filter is simply to ensure only wycs
+	 * or wyil files are loaded in a given directory root. It is not strictly
+	 * necessary for correct operation, although hopefully it offers some
+	 * performance benefits.
+	 */
+	public static final FileFilter wyilOrWycsFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wyil") || f.getName().endsWith(".wycs") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * Default implementation of a content registry. This associates whiley and
+	 * wyil files with their respective content types.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Registry implements Content.Registry {
+		public void associate(Path.Entry e) {
+			String suffix = e.suffix();
+
+			if(suffix.equals("whiley")) {
+				e.associate(WhileyFile.ContentType, null);
+			} else if(suffix.equals("wyil")) {
+				e.associate(WyilFile.ContentType, null);
+			} else if(suffix.equals("wyal")) {
+				e.associate(WyalFile.ContentType, null);
+			} else if(suffix.equals("wycs")) {
+				e.associate(WycsFile.ContentType, null);
+			}
+		}
+
+		public String suffix(Content.Type<?> t) {
+			if(t == WhileyFile.ContentType) {
+				return "whiley";
+			} else if(t == WyilFile.ContentType) {
+				return "wyil";
+			} else if(t == WyalFile.ContentType) {
+				return "wyal";
+			} else if(t == WycsFile.ContentType) {
+				return "wycs";
+			} else {
+				return "dat";
+			}
+		}
+	}
+
+	public static final List<Pipeline.Template> defaultPipeline = Collections
+			.unmodifiableList(new ArrayList<Pipeline.Template>() {
+				{
+					add(new Pipeline.Template(ModuleCheck.class,
+							Collections.EMPTY_MAP));
+					add(new Pipeline.Template(CoercionCheck.class,
+							Collections.EMPTY_MAP));
+				}
+			});
+
+	/**
+	 * Register default transforms. This is necessary so they can be referred to
+	 * from the command-line using abbreviated names, rather than their full
+	 * names.
+	 */
+	static {		
+		Pipeline.register(ModuleCheck.class);
+		Pipeline.register(CoercionCheck.class);
+		Pipeline.register(WyilFilePrinter.class);		
+	}
+
+	/**
+	 * The master project content type registry. This is needed for the build
+	 * system to determine the content type of files it finds on the file
+	 * system.
+	 */
+	public final Content.Registry registry;
+
+	/**
+	 * For logging information.
+	 */
+	protected PrintStream logout = System.err;
+
+	/**
+	 * The boot path contains the location of the whiley runtime (wyrt) library.
+	 */
+	protected ArrayList<Path.Root> bootpath = new ArrayList<Path.Root>();
+
+	/**
+	 * The whiley path identifies additional items (i.e. libraries or
+	 * directories) which the compiler uses to resolve symbols (e.g. module
+	 * names, functions, etc).
+	 */
+	protected ArrayList<Path.Root> whileypath = new ArrayList<Path.Root>();
+
+	/**
+	 * The whiley source directory is the filesystem directory from which the
+	 * compiler will look for (whiley) source files.
+	 */
+	protected DirectoryRoot whileyDir;
+
+	/**
+	 * The wyil directory is the filesystem directory where all generated wyil
+	 * files will be placed.
+	 */
+	protected Path.Root wyilDir;
+
+	/**
+	 * The wyal directory is the filesystem directory where all generated wyal
+	 * files will be placed.
+	 */
+	protected Path.Root wyalDir;
+
+	/**
+	 * The wycs directory is the filesystem directory where all generated wycs
+	 * files will be placed.
+	 */
+	protected Path.Root wycsDir;
+
+	/**
+	 * Identifies which whiley source files should be considered for
+	 * compilation. By default, all files reachable from srcdir are considered.
+	 */
+	protected Content.Filter<WhileyFile> whileyIncludes = Content.filter("**", WhileyFile.ContentType);
+
+	/**
+	 * Identifies which whiley sources files should not be considered for
+	 * compilation. This overrides any identified by <code>whileyIncludes</code>
+	 * . By default, no files files reachable from srcdir are excluded.
+	 */
+	protected Content.Filter<WhileyFile> whileyExcludes = null;
+
+	/**
+	 * Identifies which wyil files generated from whiley source files which
+	 * should be considered for compilation. By default, all files reachable
+	 * from <code>whileyDestDir</code> are considered.
+	 */
+	protected Content.Filter<WyilFile> wyilIncludes = Content.filter("**", WyilFile.ContentType);
+
+	/**
+	 * Identifies which wyil files generated from whiley source files should not
+	 * be considered for compilation. This overrides any identified by
+	 * <code>wyilIncludes</code>.
+	 */
+	protected Content.Filter<WyilFile> wyilExcludes = null;
+
+	/**
+	 * Identifies which wyal files generated from whiley source files which
+	 * should be considered for compilation. By default, all files reachable
+	 * from <code>whileytDir</code> are considered.
+	 */
+	protected Content.Filter<WyalFile> wyalIncludes = Content.filter("**", WyalFile.ContentType);
+
+	/**
+	 * Identifies which wyal files generated from whiley source files should not
+	 * be considered for compilation.  This overrides any identified by
+	 * <code>wyalIncludes</code>.
+	 */
+	protected Content.Filter<WyalFile> wyalExcludes = null;
+
+	/**
+	 * The pipeline modifiers which will be applied to the default pipeline.
+	 */
+	protected ArrayList<Pipeline.Modifier> pipelineModifiers;
+
+	/**
+	 * Indicates whether or not the compiler should produce verbose information
+	 * during compilation. This is generally used for diagnosing bugs in the
+	 * compiler.
+	 */
+	protected boolean verbose = false;
+
+	/**
+	 * Indicates whether or not the compiler should enable detailed verification
+	 * checking of pre- and post-conditions.
+	 */
+	protected boolean verification = false;
+
+	/**
+	 * Indicates whether or not the compiler should generate the intermediate
+	 * verification conditions. If verification is true, then this is done
+	 * automatically. Otherwise, you can force it with this flag without
+	 * actually performing verification.
+	 */
+	protected boolean verificationConditions = false;
+	
+	/**
+	 * Indicates whether or not the compiler should enable detailed verification
+	 * checking of pre- and post-conditions using an external SMT solver.
+	 */
+	protected boolean smtVerification = false;
+
+
+	// ==========================================================================
+	// Constructors & Configuration
+	// ==========================================================================
+
+	public WycBuildTask() {
+		this.registry = new Registry();
+		this.wyilDir = new VirtualRoot(registry);
+		this.wyalDir = new VirtualRoot(registry);
+		this.wycsDir = new VirtualRoot(registry);
+	}
+
+	public WycBuildTask(Content.Registry registry) {
+		this.registry = registry;
+		this.wyilDir = new VirtualRoot(registry);
+		this.wyalDir = new VirtualRoot(registry);
+		this.wycsDir = new VirtualRoot(registry);
+	}
+
+	public void setLogOut(PrintStream logout) {
+		this.logout = logout;
+	}
+
+	public void setVerbose(boolean verbose) {
+		this.verbose = verbose;
+	}
+
+	public void setVerification(boolean verification) {
+		this.verification = verification;
+	}
+
+	public void setVerificationConditions(boolean flag) {
+		this.verificationConditions = flag;
+	}
+	
+	public void setSmtVerification(boolean verification) {
+		this.smtVerification = verification;
+	}
+
+	public boolean getVerification() {
+		return verification;
+	}
+
+	public boolean getVerificationConditions() {
+		return verificationConditions;
+	}
+	
+	public void setPipelineModifiers(List<Pipeline.Modifier> modifiers) {
+		this.pipelineModifiers = new ArrayList<Pipeline.Modifier>(modifiers);
+	}
+
+	public void setWhileyDir(File whileydir) throws IOException {
+		this.whileyDir = new DirectoryRoot(whileydir, whileyFileFilter, registry);
+		if(wyilDir instanceof VirtualRoot) {
+			// The point here is to ensure that when this build task is used in
+			// a standalone fashion, that wyil files are actually written to
+			// disk.
+			this.wyilDir = new DirectoryRoot(whileydir, wyilFileFilter, registry);
+		}
+	}
+
+    public void setWyilDir (File wyildir) throws IOException {
+        this.wyilDir = new DirectoryRoot(wyildir, wyilFileFilter, registry);
+    }
+
+    public void setWyalDir (File wyaldir) throws IOException {
+        this.wyalDir = new DirectoryRoot(wyaldir, wyalFileFilter, registry);
+    }
+
+    public void setWycsDir (File wycsdir) throws IOException {
+        this.wycsDir = new DirectoryRoot(wycsdir, wycsFileFilter, registry);
+    }
+
+    public void setWhileyPath(List<File> roots) throws IOException {
+		whileypath.clear();
+		for (File root : roots) {
+			try {
+				if (root.getName().endsWith(".jar")) {
+					whileypath.add(new JarFileRoot(root, registry));
+				} else {
+					whileypath.add(new DirectoryRoot(root, wyilFileFilter, registry));
+				}
+			} catch (IOException e) {
+				if (verbose) {
+					logout.println("Warning: " + root
+							+ " is not a valid package root");
+				}
+			}
+		}
+	}
+
+	public void setBootPath(List<File> roots) throws IOException {
+		bootpath.clear();
+		for (File root : roots) {
+			try {
+				if (root.getName().endsWith(".jar")) {
+					bootpath.add(new JarFileRoot(root, registry));
+				} else {					
+					bootpath.add(new DirectoryRoot(root, wyilOrWycsFileFilter, registry));
+				}
+			} catch (IOException e) {
+				if (verbose) {
+					logout.println("Warning: " + root
+							+ " is not a valid package root");
+				}
+			}
+		}
+	}
+
+    public void setIncludes(String includes) {
+    	String[] split = includes.split(",");
+    	Content.Filter<WhileyFile> whileyFilter = null;
+    	Content.Filter<WyilFile> wyilFilter = null;
+
+		for (String s : split) {
+			if (s.endsWith(".whiley")) {
+				String name = s.substring(0, s.length() - 7);
+				Content.Filter<WhileyFile> nf1 = Content.filter(name,
+						WhileyFile.ContentType);
+				whileyFilter = whileyFilter == null ? nf1 : Content.or(nf1,
+						whileyFilter);
+				// in this case, we are explicitly including some whiley source
+				// files. This implicitly means the corresponding wyil files are
+				// included.
+				Content.Filter<WyilFile> nf2 = Content.filter(name,
+						WyilFile.ContentType);
+				wyilFilter = wyilFilter == null ? nf2 : Content.or(nf2,
+						wyilFilter);
+			} else if (s.endsWith(".wyil")) {
+				// in this case, we are explicitly including some wyil files.
+				String name = s.substring(0, s.length() - 5);
+				Content.Filter<WyilFile> nf = Content.filter(name,
+						WyilFile.ContentType);
+				wyilFilter = wyilFilter == null ? nf : Content.or(nf,
+						wyilFilter);
+			}
+		}
+
+		if(whileyFilter != null) {
+			this.whileyIncludes = whileyFilter;
+		}
+		if(wyilFilter != null) {
+			this.wyilIncludes = wyilFilter;
+		}
+    }
+
+    public void setExcludes(String excludes) {
+    	String[] split = excludes.split(",");
+    	Content.Filter<WhileyFile> whileyFilter = null;
+		Content.Filter<WyilFile> wyilFilter = null;
+
+    	for(String s : split) {
+    		if(s.endsWith(".whiley")) {
+    			String name = s.substring(0,s.length()-7);
+    			Content.Filter<WhileyFile> nf1 = Content.filter(name,WhileyFile.ContentType);
+    			whileyFilter = whileyFilter == null ? nf1 : Content.or(nf1, whileyFilter);
+    			Content.Filter<WyilFile> nf2 = Content.filter(name,WyilFile.ContentType);
+				wyilFilter = wyilFilter == null ? nf2 : Content.or(
+						nf2, wyilFilter);
+    		} else if (s.endsWith(".wyil")) {
+				String name = s.substring(0, s.length() - 5);
+				Content.Filter<WyilFile> nf = Content.filter(name,
+						WyilFile.ContentType);
+				wyilFilter = wyilFilter == null ? nf : Content.or(
+						nf, wyilFilter);
+			}
+    	}
+
+    	this.whileyExcludes = whileyFilter;
+    	this.wyilExcludes = wyilFilter;
+    }
+
+    // ==========================================================================
+	// Build Methods
+	// ==========================================================================
+
+    /**
+	 * Building the given source files.
+	 *
+	 * @param _args
+	 */
+	public void build(List<File> files) throws Exception {
+		List<Path.Entry<WhileyFile>> entries = whileyDir.find(files,
+				WhileyFile.ContentType);
+		int j = 0;
+		for (int i = 0; j < files.size(); ++i, ++j) {
+			if (entries.get(i) == null) {
+				logout.println("WARNING: ignoring unknown file "
+						+ files.get(j).getName());
+				entries.remove(i--);
+			}
+		}
+		buildEntries(entries);
+	}
+
+    /**
+	 * Build all source files which have been modified.
+	 *
+	 * @param _args
+	 */
+	public int buildAll() throws Exception {
+		List delta = getModifiedSourceFiles();
+		buildEntries(delta);
+		return delta.size();
+	}
+
+	protected <T> void buildEntries(List<Path.Entry<T>> delta) throws Exception {
+
+		// ======================================================================
+		// Initialise Project
+		// ======================================================================
+
+		StdProject project = initialiseProject();
+
+		// ======================================================================
+		// Initialise Build Rules
+		// ======================================================================
+
+		addBuildRules(project);
+
+		// ======================================================================
+		// Build!
+		// ======================================================================
+
+		project.build(delta);
+
+		flush();
+	}
+
+	// ==========================================================================
+	// Misc
+	// ==========================================================================
+
+	/**
+     *
+     * @return
+     * @throws IOException
+     */
+	protected StdProject initialiseProject() throws IOException {
+		ArrayList<Path.Root> roots = new ArrayList<Path.Root>();
+
+		if(whileyDir != null) {
+			roots.add(whileyDir);
+		}
+
+		roots.add(wyilDir);
+		roots.add(wyalDir);
+		roots.add(wycsDir);
+		roots.addAll(whileypath);
+		roots.addAll(bootpath);
+
+		// second, construct the module loader
+		return new StdProject(roots);
+	}
+
+	/**
+	 * Initialise the Wyil pipeline to be used for compiling Whiley files. The
+	 * default implementation just returns <code>Pipeline.defaultPipeline</code>
+	 * .
+	 *
+	 * @return
+	 */
+	protected Pipeline initialisePipeline() {
+		return new Pipeline(defaultPipeline);
+	}
+
+	protected List getModifiedSourceFiles() throws IOException {
+		if (whileyDir == null) {
+			// Note, whileyDir can be null if e.g. compiling wyil -> wyjc
+			return new ArrayList();
+		} else {
+			return getModifiedSourceFiles(whileyDir, whileyIncludes, wyilDir,
+					WyilFile.ContentType);
+		}
+	}
+
+	/**
+	 * Add all build rules to the project. By default, this adds a standard
+	 * build rule for compiling whiley files to wyil files using the
+	 * <code>Whiley2WyilBuilder</code>.
+	 *
+	 * @param project
+	 */
+	protected void addBuildRules(StdProject project) {
+		if(whileyDir != null) {
+			// whileydir can be null if a subclass of this task doesn't
+			// necessarily require it.
+			Pipeline wyilPipeline = initialisePipeline();
+
+			if(pipelineModifiers != null) {
+        		wyilPipeline.apply(pipelineModifiers);
+        	}
+
+			// ========================================================
+			// Whiley => Wyil Compilation Rule
+			// ========================================================
+
+			WhileyBuilder wyilBuilder = new WhileyBuilder(project,wyilPipeline);
+
+			if(verbose) {
+				wyilBuilder.setLogger(new Logger.Default(System.err));
+			}
+
+			project.add(new StdBuildRule(wyilBuilder, whileyDir,
+					whileyIncludes, whileyExcludes, wyilDir));
+
+			// ========================================================
+			// Wyil => Wycs Compilation Rule
+			// ========================================================
+
+			if(verification || smtVerification || verificationConditions) {
+
+				// First, handle the conversion of wyil to wyal
+
+				Wyil2WyalBuilder wyalBuilder = new Wyil2WyalBuilder(project);
+
+				if(verbose) {
+					wyalBuilder.setLogger(new Logger.Default(System.err));
+				}
+
+				project.add(new StdBuildRule(wyalBuilder, wyilDir,
+						wyilIncludes, wyilExcludes, wyalDir));
+
+				// Second, handle the conversion of wyal to wycs				
+				Pipeline<WycsFile> wycsPipeline = new Pipeline(WycsBuildTask.defaultPipeline);
+
+				wycsPipeline.setOption(VerificationCheck.class,"enable",verification);
+				Wyal2WycsBuilder wycsBuilder = new Wyal2WycsBuilder(project,wycsPipeline);
+
+				if(verbose) {
+					wycsBuilder.setLogger(new Logger.Default(System.err));
+				}
+
+				project.add(new StdBuildRule(wycsBuilder, wyalDir,
+						wyalIncludes, wyalExcludes, wycsDir));				
+			}
+		}
+	}
+
+	/**
+	 * Generate the list of source files which need to be recompiled. By
+	 * default, this is done by comparing modification times of each whiley file
+	 * against its corresponding wyil file. Wyil files which are out-of-date are
+	 * scheduled to be recompiled.
+	 *
+	 * @return
+	 * @throws IOException
+	 */
+	public static <T,S> List<Path.Entry<T>> getModifiedSourceFiles(
+			Path.Root sourceDir, Content.Filter<T> sourceIncludes,
+			Path.Root binaryDir, Content.Type<S> binaryContentType) throws IOException {
+		// Now, touch all source files which have modification date after
+		// their corresponding binary.
+		ArrayList<Path.Entry<T>> sources = new ArrayList<Path.Entry<T>>();
+
+		for (Path.Entry<T> source : sourceDir.get(sourceIncludes)) {
+			// currently, I'm assuming everything is modified!
+			Path.Entry<S> binary = binaryDir.get(source.id(),
+					binaryContentType);
+			// first, check whether wycs file out-of-date with source file
+			if (binary == null || binary.lastModified() < source.lastModified()) {
+				sources.add(source);
+			}
+		}
+
+		return sources;
+	}
+
+	/**
+	 * Flush all built files to disk.
+	 */
+	protected void flush() throws IOException {
+		wyilDir.flush();
+		wyalDir.flush();
+		wycsDir.flush();
+	}		
+}
diff --git a/modules/wycs/README b/modules/wycs/README
new file mode 100755
index 0000000000..b468e073fe
--- /dev/null
+++ b/modules/wycs/README
@@ -0,0 +1,5 @@
+======================================================================
+Package Summary
+======================================================================
+
+src/wycs/ --- The Whiley Constraint Solver (Wycs).
diff --git a/modules/wycs/build.xml b/modules/wycs/build.xml
new file mode 100755
index 0000000000..58ec276421
--- /dev/null
+++ b/modules/wycs/build.xml
@@ -0,0 +1,102 @@
+<project name="wycs" default="build">
+  <import file="../../config.xml"/>
+
+  <path id="wycs.classpath">
+    <pathelement path="${WYBS_DIR}/src"/>
+    <pathelement path="${WYRL_JAR}"/>
+    <path refid="junit.classpath"/>
+  </path>
+
+  <!-- ================================================================== -->
+  <!-- Compile -->
+  <!-- ================================================================== -->
+
+  <target name="compile-wycs">
+    <taskdef name="wyrl" classname="wyrl.util.WyrlAntTask">
+      <classpath>
+	<path refid="wycs.classpath"/>
+      </classpath>
+    </taskdef>
+    <wyrl srcdir="src/" debug="false" source="wycs/core/Types.wyrl" output="wycs/core/Types.java"/>
+    <wyrl srcdir="src/" debug="false" source="wycs/solver/Solver.wyrl" output="wycs/solver/Solver.java"/>
+    <javac memoryMaximumSize="2048m" fork="true" debug="true" debuglevel="vars,lines,source" source="1.7" target="1.7" includeantruntime="true" classpath="../wybs/src/:../../${WYRL_JAR}">
+      <src path="src"/>
+      <include name="*/**"/>
+      <exclude name="*/**/package-info.java"/>
+      <classpath>
+	<path refid="wycs.classpath"/>
+      </classpath>
+    </javac>
+    <taskdef name="wycs" classname="wycs.util.WycsAntTask">
+      <classpath>
+	<pathelement path="src"/>
+	<path refid="wycs.classpath"/>
+      </classpath>
+    </taskdef>    
+    <wycs wyaldir="stdlib/" includes="*/**.wycs"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Test -->
+  <!-- ================================================================== -->
+
+  <target name="test"/>
+
+  <!-- ================================================================== -->
+  <!-- Build -->
+  <!-- ================================================================== -->
+
+  <target name="build" depends="compile-wycs">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wycs.WycsMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wycs-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${LIB_DIR}/wycs-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src" includes="*/**/*.class"/>
+      <fileset dir="stdlib" includes="*/**/*.wycs"/>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: lib/${ant.project.name}-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Dist -->
+  <!-- ================================================================== -->
+
+  <target name="dist">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wycs.WycsMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wycs-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${DIST_DIR}/wycs-all-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src" includes="wycs/**/*.class"/>
+      <fileset dir="stdlib" includes="wycs/**/*.wycs"/>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: dist/${ant.project.name}-all-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Clean -->
+  <!-- ================================================================== -->
+
+  <target name="clean">
+    <delete includeEmptyDirs="true" failonerror="false">
+      <fileset dir="." includes="**/*.class,**/*.wyil,**/*.wyasm"/>
+    </delete>
+    <echo message="============================================="/>
+    <echo message="CLEANED: ${ant.project.name}"/>
+    <echo message="============================================="/>
+  </target>
+
+</project>
diff --git a/modules/wycs/src/wycs/WycsMain.java b/modules/wycs/src/wycs/WycsMain.java
new file mode 100755
index 0000000000..b4ffa3e1b1
--- /dev/null
+++ b/modules/wycs/src/wycs/WycsMain.java
@@ -0,0 +1,327 @@
+//Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+//All rights reserved.
+//
+//Redistribution and use in source and binary forms, with or without
+//modification, are permitted provided that the following conditions are met:
+// * Redistributions of source code must retain the above copyright
+//   notice, this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright
+//   notice, this list of conditions and the following disclaimer in the
+//   documentation and/or other materials provided with the distribution.
+// * Neither the name of the <organization> nor the
+//   names of its contributors may be used to endorse or promote products
+//   derived from this software without specific prior written permission.
+//
+//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+//ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+//WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+//DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+//DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+//ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs;
+
+import java.io.*;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.*;
+
+import wyautl.io.PrettyAutomataReader;
+
+import static wycc.lang.SyntaxError.*;
+import wycc.lang.Pipeline;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.util.OptArg;
+import wycs.solver.Solver;
+import wycs.transforms.VerificationCheck;
+import wycs.util.WycsBuildTask;
+
+/**
+* The main class provides all of the necessary plumbing to process command-line
+* options, construct an appropriate pipeline and then instantiate the Whiley
+* Compiler to generate class files.
+*
+* @author David J. Pearce
+*
+*/
+public class WycsMain {
+
+	public static PrintStream errout;
+	public static final int MAJOR_VERSION;
+	public static final int MINOR_VERSION;
+	public static final int MINOR_REVISION;
+	public static final int BUILD_NUMBER;
+
+	public static final int SUCCESS=0;
+	public static final int SYNTAX_ERROR=1;
+	public static final int INTERNAL_FAILURE=2;
+
+	public static final OptArg[] DEFAULT_OPTIONS = new OptArg[] {
+			new OptArg("help", "Print this help information"),
+			new OptArg("version", "Print version information"),
+			new OptArg("verbose",
+					"Print detailed information on what the compiler is doing"),
+			new OptArg("debug", "Print detailed debugging information"),
+			new OptArg("decompile", "d", "Decompile a give wycs binary file"),
+			new OptArg("wycspath", "wp", OptArg.FILELIST,
+					"Specify where to find wycs (binary) files",
+					new ArrayList<String>()),
+			new OptArg("bootpath", "bp", OptArg.FILELIST,
+					"Specify where to find wycs standard library files",
+					new ArrayList<String>()),
+			new OptArg("wyaldir", "wd", OptArg.FILEDIR,
+					"Specify where to find wyal source files", new File(".")),
+			new OptArg("wycsdir", OptArg.FILEDIR,
+					"Specify where to find wycs binaryfiles", new File(".")),
+			new OptArg("X", OptArg.PIPELINECONFIGURE,
+					"Configure existing pipeline stage"),
+			new OptArg("A", OptArg.PIPELINEAPPEND, "append new pipeline stage"),
+			new OptArg("R", OptArg.PIPELINEREMOVE,
+					"Remove existing pipeline stage"),
+			new OptArg("wyone", "Debug wyone files") };
+
+	/**
+	 * Initialise the error output stream so as to ensure it will display
+	 * unicode characters (when possible). Additionally, extract version
+	 * information from the enclosing jar file.
+	 */
+	static {
+		try {
+			errout = new PrintStream(System.err, true, "UTF-8");
+		} catch(Exception e) {
+			errout = System.err;
+			System.err.println("Warning: terminal does not support unicode");
+		}
+
+		// determine version numbering from the MANIFEST attributes
+		String versionStr = WycsMain.class.getPackage().getImplementationVersion();
+		if(versionStr != null) {
+			String[] vb = versionStr.split("-");
+			String[] pts = vb[0].split("\\.");
+			if(vb.length == 1) {
+				BUILD_NUMBER=0;
+			} else {
+			BUILD_NUMBER = Integer.parseInt(vb[1]); }
+
+			MAJOR_VERSION = Integer.parseInt(pts[0]);
+			MINOR_VERSION = Integer.parseInt(pts[1]);
+			MINOR_REVISION = Integer.parseInt(pts[2]);
+		} else {
+			System.err.println("WARNING: version numbering unavailable");
+			MAJOR_VERSION = 0;
+			MINOR_VERSION = 0;
+			MINOR_REVISION = 0;
+			BUILD_NUMBER = 0;
+		}
+	}
+
+	// =========================================================================
+	// Instance Fields
+	// =========================================================================
+
+	/**
+	 * The command-line options accepted by the main method.
+	 */
+	protected final OptArg[] options;
+
+
+	/**
+	 * The build-task responsible for actually compiling and building files.
+	 */
+	protected final WycsBuildTask builder;
+
+	// =========================================================================
+	// Constructors & Configuration
+	// =========================================================================
+
+	public WycsMain(WycsBuildTask builder, OptArg[] options) {
+		this.options = options;
+		this.builder = builder;
+	}
+
+    // =========================================================================
+	// Run Method
+	// =========================================================================
+
+	public int run(String[] _args) {
+		boolean verbose = false;
+
+		try {
+			// =====================================================================
+			// Process Options
+			// =====================================================================
+
+			ArrayList<String> args = new ArrayList<String>(Arrays.asList(_args));
+			Map<String, Object> values = OptArg.parseOptions(args, options);
+
+			// Second, check if we're printing version
+			if (values.containsKey("version")) {
+				System.out.println("Whiley Constraint Solver (wycs) version "
+						+ MAJOR_VERSION + "." + MINOR_VERSION + "."
+						+ MINOR_REVISION + " (build " + BUILD_NUMBER + ")");
+				return SUCCESS;
+			}
+
+			// Otherwise, if no files to compile specified, then print usage
+			if (args.isEmpty() || values.containsKey("help")) {
+				System.out.println("usage: wycs <options> <source-files>");
+				OptArg.usage(System.out, options);
+				usage(System.out, WycsBuildTask.defaultPipeline);
+				return SUCCESS;
+			}
+
+			if (values.containsKey("wyone")) {				
+				FileReader input = new FileReader(args.get(0));
+				PrettyAutomataReader reader = new PrettyAutomataReader(input, Solver.SCHEMA);				
+				VerificationCheck.unsat(reader.read(),VerificationCheck.RewriteMode.UNFAIR,500,values.containsKey("debug"));
+				return SUCCESS;
+			}
+			
+			verbose = values.containsKey("verbose");
+
+			// =====================================================================
+			// Construct & Configure Build Task
+			// =====================================================================
+
+			builder.setVerbose(verbose);
+			builder.setDebug(values.containsKey("debug"));
+			builder.setDecompile(values.containsKey("decompile"));
+
+			ArrayList<Pipeline.Modifier> pipelineModifiers = (ArrayList) values
+					.get("pipeline");
+			if (pipelineModifiers != null) {
+				builder.setPipelineModifiers(pipelineModifiers);
+			}
+
+			File wyalDir = (File) values.get("wyaldir");
+			builder.setWyalDir(wyalDir);
+
+			File wycsDir = (File) values.get("wycsdir");
+			builder.setWycsDir(wycsDir);
+
+			ArrayList<File> bootpath = (ArrayList<File>) values.get("bootpath");
+			builder.setBootPath(bootpath);
+
+			ArrayList<File> wycspath = (ArrayList<File>) values.get("wycspath");
+			builder.setWycsPath(wycspath);
+
+			ArrayList<File> delta = new ArrayList<File>();
+			for (String arg : args) {
+				delta.add(new File(arg));
+			}
+
+			// sanity check we've actually compiling things that exist
+			for(File f : delta) {
+				if(!f.exists()) {
+					System.out.println("wycs: file not found: " + f.getName());
+					return INTERNAL_FAILURE;
+				}
+			}
+			// =====================================================================
+			// Run Build Task
+			// =====================================================================
+
+			builder.build(delta);
+
+		} catch (InternalFailure e) {
+			e.outputSourceError(errout,false);
+			if (verbose) {
+				e.printStackTrace(errout);
+			}
+			return INTERNAL_FAILURE;
+		} catch (SyntaxError e) {
+			e.outputSourceError(errout,false);
+			if (verbose) {
+				e.printStackTrace(errout);
+			}
+			return SYNTAX_ERROR;
+		} catch (Throwable e) {
+			errout.println("internal failure (" + e.getMessage() + ")");
+			if (verbose) {
+				e.printStackTrace(errout);
+			}
+			return INTERNAL_FAILURE;
+		}
+
+		return SUCCESS;
+	}
+
+ // =========================================================================
+	// Helper Methods
+	// =========================================================================
+
+	/**
+	 * Print out the available list of options for the given pipeline
+	 */
+	protected void usage(PrintStream out, List<Pipeline.Template> stages) {
+		out.println("\nPipeline configuration:");
+		for(Pipeline.Template template : stages) {
+			Class<? extends Transform> t = template.clazz;
+			out.println("  -X " + t.getSimpleName().toLowerCase() + ":\t");
+			for(Method m : t.getDeclaredMethods()) {
+				String name = m.getName();
+				if(name.startsWith("set")) {
+					String shortName = name.substring(3).toLowerCase();
+					out.print("    " + shortName + "(" + argValues(m) + ")");
+					// print default value
+					try {
+						Method getter = t.getDeclaredMethod(name.replace("set", "get"));
+						Object v = getter.invoke(null);
+						out.print("[default=" + v + "]");
+					} catch(NoSuchMethodException e) {
+						// just ignore
+					} catch (IllegalArgumentException e) {
+						// just ignore
+					} catch (IllegalAccessException e) {
+						// just ignore
+					} catch (InvocationTargetException e) {
+						// just ignore
+					}
+					// print description
+					try {
+						Method desc = t.getDeclaredMethod(name.replace("set", "describe"));
+						Object v = desc.invoke(null);
+						out.print("\t" + v);
+					} catch(NoSuchMethodException e) {
+						// just ignore
+					} catch (IllegalArgumentException e) {
+						// just ignore
+					} catch (IllegalAccessException e) {
+						// just ignore
+					} catch (InvocationTargetException e) {
+						// just ignore
+					}
+					out.println();
+				}
+			}
+		}
+	}
+
+	protected static String argValues(Method m) {
+		String r = "";
+		for(Class<?> p : m.getParameterTypes()) {
+			if(p == boolean.class) {
+				r = r + "boolean";
+			} else if(p == int.class) {
+				r = r + "int";
+			} else if(p == String.class) {
+				r = r + "string";
+			}
+		}
+		return r;
+	}
+	
+ // =========================================================================
+	// Main Method
+	// =========================================================================
+
+	public static void main(String[] args) {
+		System.exit(new WycsMain(new WycsBuildTask(), DEFAULT_OPTIONS).run(args));
+	}
+
+}
diff --git a/modules/wycs/src/wycs/builders/CodeGeneration.java b/modules/wycs/src/wycs/builders/CodeGeneration.java
new file mode 100755
index 0000000000..2d4539e281
--- /dev/null
+++ b/modules/wycs/src/wycs/builders/CodeGeneration.java
@@ -0,0 +1,576 @@
+package wycs.builders;
+
+import java.math.BigInteger;
+import java.util.*;
+
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
+import wycs.core.*;
+import wycs.syntax.*;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+import static wycc.lang.SyntaxError.*;
+import static wycs.transforms.TypePropagation.returnType;
+
+/**
+ * Responsible for translating an individual <code>WyalFile</code> into a
+ * <code>WycsFile</code>. By the time this is run, both type propagation and
+ * constraint expansion (for uninterpreted functions) must already have
+ * occurred. In most cases, the translation is straightforward as there is a
+ * one-one correspondence between many Wyal and Wycs constructs. However, some
+ * differences exist such as, for example, the lack of an implication statement
+ * and any notion of a list.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class CodeGeneration {
+	private final Wyal2WycsBuilder builder;
+	private WyalFile file;
+
+	public CodeGeneration(Wyal2WycsBuilder builder) {
+		this.builder = builder;
+	}
+
+	public WycsFile generate(WyalFile file, Path.Entry<WycsFile> entry) {
+		this.file = file;
+		ArrayList<WycsFile.Declaration> declarations = new ArrayList();
+		for (WyalFile.Declaration d : file.declarations()) {
+			WycsFile.Declaration e = generate(d);
+			if (e != null) {
+				declarations.add(e);
+			}
+		}
+		return new WycsFile(entry, declarations);
+	}
+
+	protected WycsFile.Declaration generate(WyalFile.Declaration declaration) {
+		if(declaration instanceof WyalFile.Import) {
+			// not sure what to do here?
+			return null;
+		} else if(declaration instanceof WyalFile.Macro) {
+			return generate((WyalFile.Macro)declaration);
+		} else if(declaration instanceof WyalFile.Function) {
+			return generate((WyalFile.Function)declaration);
+		} else if(declaration instanceof WyalFile.Type) {
+			return generate((WyalFile.Type)declaration);
+		} else if(declaration instanceof WyalFile.Assert) {
+			return generate((WyalFile.Assert)declaration);
+		} else {
+			throw new InternalFailure("unknown declaration encounterd", file.getEntry(), declaration);
+		}
+	}
+
+	protected WycsFile.Declaration generate(WyalFile.Macro d) {
+		try {
+			// First, determine function type
+			SemanticType from = builder.convert(d.from, d.generics, d);
+			SemanticType to = SemanticType.Bool;
+			SemanticType.Var[] generics = new SemanticType.Var[d.generics.size()];
+			for (int i = 0; i != generics.length; ++i) {
+				generics[i] = SemanticType.Var(d.generics.get(i));
+			}
+			SemanticType.Function type = SemanticType.Function(from, to, generics);
+			// Second, generate macro body
+			HashMap<String,Code> environment = new HashMap<String,Code>();
+			Code parameter = Code.Variable(from, new Code[0], 0,
+					attributes(d.from));
+			addDeclaredVariables(parameter,d.from,environment);
+			Code condition = generate(d.body, environment, d);
+			// Third, create declaration
+			return new WycsFile.Macro(d.name, type, condition,
+					attributes(d));
+		} catch (ResolveError re) {
+			// should be unreachable if type propagation is already succeeded.
+			throw new SyntaxError("cannot resolve as function or definition call", file.getEntry(), d, re);
+		}
+	}
+
+	protected WycsFile.Declaration generate(WyalFile.Function d) {
+		try {
+			// First, determine function type
+			SemanticType from = builder.convert(d.from, d.generics, d);
+			SemanticType to = builder.convert(d.to, d.generics, d);
+			SemanticType.Var[] generics = new SemanticType.Var[d.generics.size()];
+			for (int i = 0; i != generics.length; ++i) {
+				generics[i] = SemanticType.Var(d.generics.get(i));
+			}
+			SemanticType.Function type = SemanticType.Function(from, to, generics);
+			// Second, generate function condition (if applicable)
+			Code condition = null;
+			if (d.constraint != null) {
+				HashMap<String,Code> environment = new HashMap<String,Code>();
+				Code ret = Code.Variable(to, new Code[0], 0,
+						attributes(d.to));
+				Code parameter = Code.Variable(from, new Code[0], 1,
+						attributes(d.from));
+				addDeclaredVariables(parameter,d.from,environment);
+				addDeclaredVariables(ret,d.to,environment);
+				condition = generate(d.constraint, environment, d);
+			}
+			// Third, create declaration
+			return new WycsFile.Function(d.name, type, condition,
+					attributes(d));
+		} catch (ResolveError re) {
+			// should be unreachable if type propagation is already succeeded.
+			throw new SyntaxError("cannot resolve as function or definition call", file.getEntry(), d, re);
+		}
+	}
+
+	protected WycsFile.Declaration generate(WyalFile.Type d) {
+		try {
+			SemanticType from = builder.convert(d.type, d.generics, d);		
+			SemanticType.Var[] generics = new SemanticType.Var[d.generics.size()];
+			for (int i = 0; i != generics.length; ++i) {
+				generics[i] = SemanticType.Var(d.generics.get(i));
+			}		
+			// Second, generate type invariant (if applicable)
+			Code invariant = null;
+			if (d.invariant != null) {
+				HashMap<String,Code> environment = new HashMap<String,Code>();
+				Code parameter = Code.Variable(from, new Code[0], 0,
+						attributes(d.type));
+				addDeclaredVariables(parameter,d.type,environment);			
+				invariant = generate(d.invariant, environment, d);
+			}
+			// 
+			return new WycsFile.Type(d.name, from, invariant, attributes(d));
+		} catch (ResolveError re) {
+			// should be unreachable if type propagation is already succeeded.
+			throw new SyntaxError("cannot resolve as function or definition call", file.getEntry(), d, re);
+		}
+	}
+	
+	protected void addDeclaredVariables(Code root, TypePattern t,
+			HashMap<String, Code> environment) {
+
+		if(t instanceof TypePattern.Leaf) {
+			TypePattern.Leaf tl = (TypePattern.Leaf) t;
+			if(tl.var != null) {
+				environment.put(tl.var.name, root);
+			}
+		} else if(t instanceof TypePattern.Rational) {
+			// TODO: implement me!
+		} else if(t instanceof TypePattern.Tuple) {
+			TypePattern.Tuple tt = (TypePattern.Tuple) t;
+			for (int i = 0; i != tt.elements.size(); ++i) {
+				TypePattern p = tt.elements.get(i);
+				addDeclaredVariables(
+						Code.Load((SemanticType.Tuple) root.type, root, i,
+								attributes(t)), p,
+						environment);
+			}
+		} else if(t instanceof TypePattern.Record) {
+			// TODO: implement me!
+		} else if(t instanceof TypePattern.Intersection) {
+			// TODO: implement me!
+		} else if(t instanceof TypePattern.Union) {
+			// TODO: implement me!
+		}
+	}
+
+	protected WycsFile.Declaration generate(WyalFile.Assert d) {
+		Code condition = generate(d.expr, new HashMap<String,Code>(),d);
+		return new WycsFile.Assert(d.message, condition, attributes(d));
+	}
+
+	protected Code generate(Expr e, HashMap<String,Code> environment, WyalFile.Context context) {
+		if (e instanceof Expr.Variable) {
+			return generate((Expr.Variable) e, environment, context);
+		} else if (e instanceof Expr.Constant) {
+			return generate((Expr.Constant) e, environment, context);
+		} else if (e instanceof Expr.Cast) {
+			return generate((Expr.Cast) e, environment, context);
+		} else if (e instanceof Expr.Unary) {
+			return generate((Expr.Unary) e, environment, context);
+		} else if (e instanceof Expr.Binary) {
+			return generate((Expr.Binary) e, environment, context);
+		} else if (e instanceof Expr.Nary) {
+			return generate((Expr.Nary) e, environment, context);
+		} else if (e instanceof Expr.Quantifier) {
+			return generate((Expr.Quantifier) e, environment, context);
+		} else if (e instanceof Expr.Invoke) {
+			return generate((Expr.Invoke) e, environment, context);
+		} else if (e instanceof Expr.IndexOf) {
+			return generate((Expr.IndexOf) e, environment, context);
+		} else if (e instanceof Expr.Is) {
+			return generate((Expr.Is) e, environment, context);
+		} else {
+			throw new InternalFailure("unknown expression encountered (" + e + ")", file.getEntry(), e);
+		}
+	}
+
+	protected Code generate(Expr.Variable e, HashMap<String,Code> environment, WyalFile.Context context) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		return environment.get(e.name);
+	}
+
+	protected Code generate(Expr.Constant v, HashMap<String,Code> environment, WyalFile.Context context) {
+		return Code.Constant(v.value,
+				attributes(v));
+	}
+
+	protected Code generate(Expr.Cast e, HashMap<String,Code> environment, WyalFile.Context context) {
+		SemanticType type = e.operand.attribute(TypeAttribute.class).type;
+		SemanticType target = e.attribute(TypeAttribute.class).type;
+		Code operand = generate(e.operand,environment, context);
+		return Code.Cast(type,operand,target,attributes(e));
+	}
+	
+	protected Code generate(Expr.Unary e, HashMap<String,Code> environment, WyalFile.Context context) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		Code operand = generate(e.operand,environment, context);
+		Code.Op opcode;
+		switch(e.op) {
+		case NEG:
+			opcode = Code.Op.NEG;
+			break;
+		case NOT:
+			opcode = Code.Op.NOT;
+			break;
+		case LENGTHOF:
+			opcode = Code.Op.LENGTH;
+			break;
+		default:
+			throw new InternalFailure("unknown unary opcode encountered (" + e + ")", file.getEntry(), e);
+		}
+		return Code.Unary(type, opcode, operand,
+				attributes(e));
+	}
+
+	protected Code generate(Expr.Binary e, HashMap<String,Code> environment, WyalFile.Context context) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		Code lhs = generate(e.leftOperand,environment, context);
+		Code rhs = generate(e.rightOperand,environment, context);
+		Code.Op opcode;
+		switch(e.op) {
+		case AND:
+			return Code.Nary(type, Code.Op.AND, new Code[] { lhs, rhs },
+					attributes(e));
+		case OR:
+			return Code.Nary(type, Code.Op.OR, new Code[] { lhs, rhs },
+					attributes(e));
+		case ADD:
+			opcode = Code.Op.ADD;
+			break;
+		case SUB:
+			opcode = Code.Op.SUB;
+			break;
+		case MUL:
+			opcode = Code.Op.MUL;
+			break;
+		case DIV:
+			opcode = Code.Op.DIV;
+			break;
+		case REM:
+			opcode = Code.Op.REM;
+			break;
+		case EQ:
+			opcode = Code.Op.EQ;
+			break;
+		case NEQ:
+			opcode = Code.Op.NEQ;
+			break;
+		case IMPLIES:
+			lhs = Code.Unary(type, Code.Unary.Op.NOT, lhs);
+			return Code.Nary(type, Code.Op.OR, new Code[] { lhs, rhs },
+					attributes(e));
+		case IFF:
+			Code nLhs = Code.Unary(type, Code.Unary.Op.NOT,lhs);
+			Code nRhs = Code.Unary(type, Code.Unary.Op.NOT,rhs);
+			lhs = Code.Nary(type, Code.Op.AND, new Code[]{lhs,rhs});
+			rhs = Code.Nary(type, Code.Op.AND, new Code[]{nLhs,nRhs});
+			return Code.Nary(type, Code.Op.OR, new Code[]{lhs,rhs},
+					attributes(e));
+		case LT:
+			opcode = Code.Op.LT;
+			break;
+		case LTEQ:
+			opcode = Code.Op.LTEQ;
+			break;
+		case GT: {
+			opcode = Code.Op.LT;
+			Code tmp = lhs;
+			lhs = rhs;
+			rhs = tmp;
+			break;
+		}
+		case GTEQ: {
+			opcode = Code.Op.LTEQ;
+			Code tmp = lhs;
+			lhs = rhs;
+			rhs = tmp;
+			break;
+		}		
+		case ARRAYGEN: {
+			opcode = Code.Op.ARRAYGEN;
+			break;
+		}
+		default:
+			throw new InternalFailure("unknown binary opcode encountered (" + e + ")", file.getEntry(), e);
+		}
+
+		return Code.Binary(type, opcode, lhs, rhs,
+				attributes(e));
+	}
+
+	protected Code generate(Expr.Nary e, HashMap<String,Code> environment, WyalFile.Context context) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		Code[] operands = new Code[e.operands.size()];
+		for(int i=0;i!=operands.length;++i) {
+			operands[i] = generate(e.operands.get(i),environment, context);
+		}
+		Code.Op opcode;
+		switch(e.op) {
+		case TUPLE:
+			opcode = Code.Op.TUPLE;
+			break;
+		case ARRAY: 			
+			opcode = Code.Op.ARRAY;
+			break;		
+		default:
+			throw new InternalFailure("unknown unary opcode encountered (" + e + ")", file.getEntry(), e);
+		}
+		return Code.Nary(type, opcode, operands,
+				attributes(e));
+	}
+
+	protected Code generate(Expr.Quantifier e,
+			HashMap<String, Code> _environment, WyalFile.Context context) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		HashMap<String, Code> environment = new HashMap<String, Code>(
+				_environment);
+
+		ArrayList<Pair<SemanticType,Integer>> variables = new ArrayList<Pair<SemanticType,Integer>>();
+		addQuantifiedVariables(e.pattern, variables, environment);
+
+		Pair<SemanticType, Integer>[] types = variables.toArray(new Pair[variables.size()]);
+
+		Code operand = generate(e.operand, environment, context);
+
+		if(e instanceof Expr.ForAll) {
+			return Code.Quantifier(type, Code.Op.FORALL, operand, types,
+					attributes(e));
+		} else {
+			return Code.Quantifier(type, Code.Op.EXISTS, operand, types,
+					attributes(e));
+		}
+	}
+
+	// FIXME: The following is a bit of a hack really. The purpose is to ensure
+	// every quantified variable is unique through an entire expression. This is
+	// necessary because the rewrite rules for quantifiers don't proper handle
+	// name clashes between quantified variables.  See #389
+	private static int freshVar = 0;
+	private static int freshVar(HashMap<String, Code> environment) {
+		if(freshVar < environment.size()) {
+			freshVar = environment.size();
+		} else {
+			freshVar++;
+		}
+		return freshVar;
+	}
+
+	protected void addQuantifiedVariables(TypePattern t,
+			ArrayList<Pair<SemanticType, Integer>> variables,
+			HashMap<String, Code> environment) {
+
+		if(t instanceof TypePattern.Leaf) {
+			TypePattern.Leaf tl = (TypePattern.Leaf) t;
+			if (tl.var != null) {
+				int index = freshVar(environment);
+				SemanticType type = tl.attribute(TypeAttribute.class).type;
+				variables.add(new Pair<SemanticType,Integer>(type,index));
+				environment.put(
+						tl.var.name,
+						Code.Variable(type, index,
+								attributes(tl)));
+			}
+		} else if(t instanceof TypePattern.Tuple) {
+			TypePattern.Tuple tt = (TypePattern.Tuple) t;
+			for (int i = 0; i != tt.elements.size(); ++i) {
+				TypePattern p = tt.elements.get(i);
+				addQuantifiedVariables(p, variables, environment);
+			}
+		}
+	}
+
+
+	protected Code generate(Expr.Invoke e, HashMap<String, Code> environment,
+			WyalFile.Context context) {
+		Code operand = generate(e.operand, environment, context);
+		try {
+			ArrayList<SemanticType> generics = new ArrayList<SemanticType>();
+			List<SyntacticType> e_generics = e.generics;
+			for (int i = 0; i != e_generics.size(); ++i) {
+				SyntacticType gt = e_generics.get(i);
+				generics.add(gt.attribute(TypeAttribute.class).type);
+
+			}
+			NameID nid;
+			SemanticType.Function fnType;
+			
+			if(e.qualification == null) {
+				Pair<NameID, SemanticType.Function> p = builder
+						.resolveAsFunctionType(e.name, operand.returnType(),
+								generics, context);
+				nid = p.first();
+				fnType = p.second();
+			} else {
+				nid = new NameID(e.qualification, e.name);
+				Pair<SemanticType.Function, Map<String, SemanticType>> p = builder
+						.resolveAsFunctionType(nid, operand.returnType(),
+								generics, context);
+				fnType = p.first();
+			}
+			//
+			return Code.FunCall(fnType, operand, nid,
+					generics.toArray(new SemanticType[generics.size()]),
+					attributes(e));
+		} catch (ResolveError re) {
+			// should be unreachable if type propagation is already succeeded.
+			throw new SyntaxError(re.getMessage(), file.getEntry(), e, re);
+		}
+	}
+
+	protected Code generate(Expr.IndexOf e, HashMap<String, Code> environment,
+			WyalFile.Context context) {
+		SemanticType operand_type = (SemanticType) e
+				.attribute(TypeAttribute.class).type;
+		Code source = generate(e.operand, environment, context);
+
+		if (operand_type instanceof SemanticType.EffectiveTuple) {
+			SemanticType.EffectiveTuple tt = (SemanticType.EffectiveTuple) operand_type;
+			Value.Integer idx = (Value.Integer) ((Expr.Constant) e.index).value;
+			return Code.Load(tt.tupleType(), source, idx.value.intValue(),
+					attributes(e));
+		} else {
+			SemanticType.Array type = (SemanticType.Array) operand_type;
+			Code index = generate(e.index, environment, context);
+			return Code.IndexOf(type, source, index, attributes(e));
+		}
+	}
+
+	protected Code generate(Expr.Is e, HashMap<String, Code> environment,
+			WyalFile.Context context) {
+		SemanticType test = e.rightOperand.attribute(TypeAttribute.class).type;
+		Code source = generate(e.leftOperand, environment, context);
+		return Code.Is(source.returnType(), source, test, attributes(e));
+	}
+	
+	/**
+	 * This function attempts to find an appropriate binding for the generic
+	 * types accepted by a given function, and the supplied argument type. For
+	 * example, consider a call
+	 * <code>f(1)<code> for a function <code>f<T>(T)</code>. The appropriate
+	 * binding for this call is <code>{T=>int}</code>.
+	 *
+	 * @param nid
+	 *            --- name identifier for the named function
+	 * @param type
+	 *            --- the supplied argument type
+	 * @return
+	 */
+	protected Pair<SemanticType.Function,SemanticType[]> bindGenerics(NameID nid, SemanticType argumentType,
+			SyntacticElement elem) {
+		try {
+			WycsFile module = builder.getModule(nid.module());
+			// module should not be null if TypePropagation has already passed.
+			Object d = module.declaration(nid.name());
+			SemanticType[] generics;
+			SemanticType.Function funType;
+			if(d instanceof WycsFile.Function) {
+				WycsFile.Function fn = (WycsFile.Function) d;
+				generics = fn.type.generics();
+				funType = fn.type;
+			} else if(d instanceof WycsFile.Macro) {
+				WycsFile.Macro fn = (WycsFile.Macro) d;
+				generics = fn.type.generics();
+				funType = fn.type;
+			} else {
+				throw new InternalFailure("cannot resolve as function or macro call", file.getEntry(), elem);
+			}
+			HashMap<String,SemanticType> binding = new HashMap<String,SemanticType>();
+			if (!SemanticType.bind(funType.from(), argumentType, binding)) {
+				throw new InternalFailure("cannot bind function or macro call", file.getEntry(),
+						elem);
+			}
+			SemanticType[] result = new SemanticType[generics.length];
+			for(int i=0;i!=generics.length;++i) {
+				SemanticType.Var v = (SemanticType.Var) generics[i];
+				SemanticType type = binding.get(v.name());
+				if(type == null) {
+					throw new InternalFailure("cannot bind function or macro call",
+							file.getEntry(), elem);
+				}
+				result[i] = type;
+			}
+			
+			return new Pair<SemanticType.Function,SemanticType[]>(funType,result);
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), elem, ex);
+		}
+	}
+	
+	protected Code.FunCall invokeInternal(Path.ID module, String name,
+			Code argument, WyalFile.Context context) {
+		SemanticType argType = argument.returnType();
+		NameID nid = new NameID(module, name);
+		Pair<SemanticType.Function, SemanticType[]> p = bindGenerics(nid,
+				argType, context);			
+		return Code.FunCall(p.first(), argument, nid, p.second(), attributes(context));
+	}
+
+	protected static Attribute[] attributes(SyntacticElement d) {
+		ArrayList<Attribute> attrs = new ArrayList<Attribute>();
+		for(Attribute a : d.attributes()) {
+			if(a instanceof Attribute.Source || a instanceof Attribute.Origin) {
+				attrs.add(a);
+			}
+		}
+		return attrs.toArray(new Attribute[attrs.size()]);
+	}
+
+	protected static Code implies(Code lhs, Code rhs) {
+		lhs = Code.Unary(SemanticType.Bool, Code.Op.NOT, lhs);
+		return Code
+				.Nary(SemanticType.Bool, Code.Op.OR, new Code[] { lhs, rhs });
+	}
+
+	protected static Code and(Code... constraints) {
+		int count = 0;
+		for(Code c : constraints) {
+			if(c == null) {
+				count++;
+			}
+		}
+		if(count == 0) {
+			return Code.Nary(SemanticType.Bool, Code.Op.AND, constraints);
+		} else if(constraints.length-count == 1){
+			for(Code c : constraints) {
+				if(c != null) {
+					return c;
+				}
+			}
+		} else if(constraints.length-count > 0){
+			Code[] nconstraints = new Code[constraints.length-count];
+			int i=0;
+			for(Code c : constraints) {
+				if(c != null) {
+					nconstraints[i++] = c;
+				}
+			}
+			return Code.Nary(SemanticType.Bool, Code.Op.AND, nconstraints);
+		}
+		return Code.Constant(Value.Bool(true));
+	}
+
+
+	private static final Trie WYCS_CORE_LIST = Trie.ROOT.append("wycs")
+			.append("core").append("List");
+}
diff --git a/modules/wycs/src/wycs/builders/Wyal2WycsBuilder.java b/modules/wycs/src/wycs/builders/Wyal2WycsBuilder.java
new file mode 100755
index 0000000000..998c6d03da
--- /dev/null
+++ b/modules/wycs/src/wycs/builders/Wyal2WycsBuilder.java
@@ -0,0 +1,913 @@
+package wycs.builders;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static wycc.lang.SyntaxError.*;
+import static wycs.solver.Solver.SCHEMA;
+import wyautl.io.PrettyAutomataWriter;
+import wyrw.core.Rewriter;
+import wybs.lang.*;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.Pipeline;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
+import wycs.core.Code;
+import wycs.core.SemanticType;
+import wycs.core.Value;
+import wycs.core.WycsFile;
+import wycs.syntax.SyntacticType;
+import wycs.syntax.TypePattern;
+import wycs.syntax.WyalFile;
+import wycs.transforms.TypePropagation;
+import wycs.transforms.VerificationCheck;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+import wyfs.util.Trie;
+
+public class Wyal2WycsBuilder implements Builder, Logger {
+
+	/**
+	 * The master project for identifying all resources available to the
+	 * builder. This includes all modules declared in the project being verified
+	 * and/or defined in external resources (e.g. jar files).
+	 */
+	protected final Build.Project project;
+
+	/**
+	 * The list of stages which must be applied to a Wycs file.
+	 */
+	protected final List<Transform<WycsFile>> pipeline;
+
+	/**
+	 * The import cache caches specific import queries to their result sets.
+	 * This is extremely important to avoid recomputing these result sets every
+	 * time. For example, the statement <code>import wycs.lang.*</code>
+	 * corresponds to the triple <code>("wycs.lang",*,null)</code>.
+	 */
+	protected final HashMap<Trie, ArrayList<Path.ID>> importCache = new HashMap();
+
+	/**
+	 * A map of the source files currently being compiled.
+	 */
+	protected final HashMap<Path.ID, Path.Entry<WyalFile>> srcFiles = new HashMap<Path.ID, Path.Entry<WyalFile>>();
+
+	protected Logger logger = Logger.NULL;
+
+	protected boolean debug = false;
+
+	public Wyal2WycsBuilder(Build.Project project, Pipeline<WycsFile> pipeline) {
+		this.project = project;
+		this.pipeline = pipeline.instantiate(this);
+	}
+
+	public Build.Project project() {
+		return project;
+	}
+
+	public void setLogger(Logger logger) {
+		this.logger = logger;
+	}
+
+	public void setDebug(boolean debug) {
+		this.debug = debug;
+	}
+
+
+	@Override
+	public void logTimedMessage(String msg, long time, long memory) {
+		logger.logTimedMessage(msg, time, memory);
+	}
+
+	// ======================================================================
+	// Build Method
+	// ======================================================================
+
+	@Override
+	public Set<Path.Entry<?>> build(Collection<Pair<Entry<?>, Path.Root>> delta, Build.Graph graph) throws IOException {
+		Runtime runtime = Runtime.getRuntime();
+		long startTime = System.currentTimeMillis();
+		long startMemory = runtime.freeMemory();
+		long tmpTime = startTime;
+		long tmpMem = startMemory;
+
+		// ========================================================================
+		// Parse and register source files
+		// ========================================================================
+
+		srcFiles.clear();
+		int count = 0;
+		for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+			Path.Entry<?> src = p.first();
+			if (src.contentType() == WyalFile.ContentType) {
+				Path.Entry<WyalFile> sf = (Path.Entry<WyalFile>) src;
+				WyalFile wf = sf.read();
+				count++;
+				srcFiles.put(wf.id(), sf);
+			}
+		}
+
+		logger.logTimedMessage("Parsed " + count + " source file(s).",
+				System.currentTimeMillis() - tmpTime,
+				tmpMem - runtime.freeMemory());
+
+		// ========================================================================
+		// Stub Generation
+		// ========================================================================
+		runtime = Runtime.getRuntime();
+		tmpTime = System.currentTimeMillis();
+		tmpMem = runtime.freeMemory();
+		HashSet<Path.Entry<?>> generatedFiles = new HashSet<Path.Entry<?>>();
+		for(Pair<Path.Entry<?>,Path.Root> p : delta) {
+			Path.Entry<?> src = p.first();
+			Path.Root dst = p.second();
+			if (src.contentType() == WyalFile.ContentType) {
+				Path.Entry<WyalFile> source = (Path.Entry<WyalFile>) src;
+				Path.Entry<WycsFile> target = (Path.Entry<WycsFile>) dst.create(src.id(),WycsFile.ContentType);
+				graph.registerDerivation(source, target);
+				generatedFiles.add(target);
+				WyalFile wf = source.read();
+				WycsFile wycs = getModuleStub(wf);
+				target.write(wycs);
+			}
+		}
+		logger.logTimedMessage("Generated stubs for " + count + " source file(s).",
+				System.currentTimeMillis() - tmpTime, tmpMem - runtime.freeMemory());
+
+		// ========================================================================
+		// Type source files
+		// ========================================================================
+		runtime = Runtime.getRuntime();
+		tmpTime = System.currentTimeMillis();
+		tmpMem = runtime.freeMemory();
+
+		TypePropagation typer = new TypePropagation(this);
+		for(Pair<Path.Entry<?>,Path.Root> p : delta) {
+			Path.Entry<?> f = p.first();
+			if (f.contentType() == WyalFile.ContentType) {
+				Path.Entry<WyalFile> sf = (Path.Entry<WyalFile>) f;
+				WyalFile wf = sf.read();
+				typer.apply(wf);
+			}
+		}
+
+		logger.logTimedMessage("Typed " + count + " source file(s).",
+				System.currentTimeMillis() - tmpTime, tmpMem - runtime.freeMemory());
+
+
+		// ========================================================================
+		// Code Generation
+		// ========================================================================
+		runtime = Runtime.getRuntime();
+		tmpTime = System.currentTimeMillis();
+		tmpMem = runtime.freeMemory();
+
+		CodeGeneration generator = new CodeGeneration(this);
+		for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+			Path.Entry<?> src = p.first();
+			Path.Root dst = p.second();
+			if (src.contentType() == WyalFile.ContentType) {
+				Path.Entry<WyalFile> source = (Path.Entry<WyalFile>) src;
+				Path.Entry<WycsFile> target = (Path.Entry<WycsFile>) dst
+						.create(src.id(), WycsFile.ContentType);
+				WyalFile wf = source.read();
+				WycsFile wycs = generator.generate(wf,target);
+				target.write(wycs);
+			}
+		}
+
+		logger.logTimedMessage("Generated code for " + count + " source file(s).",
+					System.currentTimeMillis() - tmpTime, tmpMem - runtime.freeMemory());
+
+		// ========================================================================
+		// Pipeline Stages
+		// ========================================================================
+
+		for (Transform<WycsFile> stage : pipeline) {
+			for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+				Path.Root dst = p.second();
+				Path.Entry<WycsFile> df = dst.get(p.first().id(),WycsFile.ContentType);
+				WycsFile module = df.read();
+				try {
+					process(module, stage);
+				} catch (VerificationCheck.AssertionFailure ex) {
+					// FIXME: this feels a bit like a hack.
+					if(debug && ex.original() != null) {
+						Rewriter rw = ex.rewriter();
+						PrettyAutomataWriter writer = new PrettyAutomataWriter(System.out,SCHEMA,"Or","And");
+						writer.write(ex.original());
+						writer.flush();
+						System.err.println("\n\n=>\n");
+						writer.write(ex.reduction());
+						writer.flush();
+					}
+					// Determine the original source file, since we want to
+					// report the error on this file.
+					Path.Entry<?> source = determineSource(p.first(),graph);
+					throw new SyntaxError(ex.getMessage(), source, ex.assertion(), ex);
+				} 
+			}
+		}
+
+		// ========================================================================
+		// Done
+		// ========================================================================
+
+		long endTime = System.currentTimeMillis();
+		logger.logTimedMessage("Wyal => Wycs: compiled " + delta.size() + " file(s)",
+				endTime - startTime, startMemory - runtime.freeMemory());
+
+		return generatedFiles;
+	}
+
+	// ======================================================================
+	// Public Accessors
+	// ======================================================================
+
+	/**
+	 * Check whether or not a given Wycs module exists.
+	 *
+	 * @param mid
+	 *            --- fully qualified name.
+	 * @return
+	 */
+	public boolean exists(Path.ID mid) {
+		try {
+			// first, check in those files being compiled.
+			for(Map.Entry<Path.ID,Path.Entry<WyalFile>> e : srcFiles.entrySet()) {
+				Path.Entry<WyalFile> pe = e.getValue();
+				if(pe.id().equals(mid)) {
+					return true;
+				}
+			}
+			// second, check the wider namespace
+			return project.exists(mid, WycsFile.ContentType);
+		} catch (Exception e) {
+			return false;
+		}
+	}
+
+	/**
+	 * Get the Wycs module associated with a given module identifier. If the
+	 * module does not exist, null is returned.
+	 *
+	 * @param mid
+	 * @return
+	 * @throws Exception
+	 */
+	public WycsFile getModule(Path.ID mid) throws Exception {
+		Path.Entry<WycsFile> wyf = project.get(mid, WycsFile.ContentType);
+		if(wyf != null) {
+			// In this case, we have found an appropriate WycsFile which matches
+			// the given path.
+			return wyf.read();
+		} else {
+			// Found nothing.
+			return null;
+		}
+	}
+	
+	/**
+	 * Resolve a name found at a given context in a source file to determine its
+	 * fully qualified name. Essentially, the context will be used to determine
+	 * the active import statements which will be used to search for the name.
+	 * In this case, we are assuming that module stubs have not yet been
+	 * generated for all source files and, hence, we must consider source files
+	 * as well.
+	 *
+	 * @param name
+	 *            --- name to look for.
+	 * @param context
+	 *            --- context where name occurred.
+	 * @return
+	 * @throws ResolveError
+	 */
+	public NameID resolveAsName(String name, WyalFile.Context context)
+			throws ResolveError {
+		
+		// First, we need to check whether or not the name is in the enclosing
+		// file. If it is, then is what it must resolve to. Otherwise, we need
+		// to look further afield.
+		WyalFile enclosingFile = context.file();
+		if(enclosingFile.declaration(name) != null) {
+			// Ok, yes, there is a declaration of the given name in this file.
+			return new NameID(enclosingFile.id(),name);
+		} 
+		
+		// Otherwise, the name is defined in an external file and we need to
+		// search the imports list to find it.		
+		for (WyalFile.Import imp : context.imports()) {
+			for (Path.ID id : imports(imp.filter)) {
+				try {
+					// First, look to see whether this is a file that is
+					// currently being compoiled.
+					Path.Entry<WyalFile> srcFile = srcFiles.get(id);
+					if(srcFile != null) {
+						// Ok, yes this is one of the files currently being
+						// compiled. Therefore, let's see whether or not it
+						// contains a declaration with the given name.
+						WyalFile wf = srcFile.read();
+						if(wf.declaration(name) != null) {
+							return new NameID(id,name);
+						}
+					} else {
+						// Ok, this is not one of the files being currently
+						// compiled. Therefore, let's load the binary form of
+						// this file and see whether or not it contains the
+						// given name.
+						WycsFile wf = getModule(id);
+						if(wf != null && wf.declaration(name) != null) {
+							return new NameID(id,name);
+						}
+					}
+				} catch(SyntaxError e) {
+					throw e;
+				} catch (Exception e) {
+					throw new InternalFailure(e.getMessage(), context.file().getEntry(), context, e);
+				}
+			}
+		}
+		
+		throw new ResolveError("name not found: " + name);
+	}
+
+	public Path.ID resolveAsModule(String name, WyalFile.Context context) throws ResolveError {
+		// Search the imports list to find it.				
+		for (WyalFile.Import imp : context.imports()) {
+			for (Path.ID id : imports(imp.filter)) {
+				try {
+					if(id.last().equals(name)) {
+						return id;
+					}
+				} catch(SyntaxError e) {
+					throw e;
+				} catch (Exception e) {
+					throw new InternalFailure(e.getMessage(), context.file().getEntry(),
+							context, e);
+				}
+			}
+		}
+				
+		throw new ResolveError("module not found: " + name);	
+	}
+	
+	/**
+	 * This function must be called after stubs are created.
+	 * @param name
+	 * @param parameter
+	 * @param context
+	 * @return
+	 * @throws ResolveError
+	 */
+	public Triple<NameID, SemanticType.Function, Map<String, SemanticType>> resolveAsFunctionType(
+			String name, SemanticType parameter, List<SemanticType> generics,
+			WyalFile.Context context) throws ResolveError {
+		// First, attempt to resolve the name of the function. This tells us the
+		// scope in which it is defined.
+		NameID nid = resolveAsName(name, context);
+		// Second, find the best matching function.
+		Pair<SemanticType.Function, Map<String, SemanticType>> match = resolveAsFunctionType(
+				nid, parameter, generics, context);
+		return new Triple<NameID, SemanticType.Function, Map<String, SemanticType>>(
+				nid, match.first(), match.second());
+	}
+	
+	/**
+	 * This function must be called after stubs are created.
+	 * @param name
+	 * @param parameter
+	 * @param context
+	 * @return
+	 * @throws ResolveError
+	 */
+	public Pair<SemanticType.Function, Map<String, SemanticType>> resolveAsFunctionType(
+			NameID nid, SemanticType parameter, List<SemanticType> generics,
+			WyalFile.Context context)
+			throws ResolveError {
+		// Collect the types of all matching functions and macros. This
+		// so that we can then choose the best fit.
+		try {
+			WycsFile wf = getModule(nid.module());
+			if(wf == null) {
+				throw new ResolveError("module not found: " + nid.module());
+			}
+			ArrayList<SemanticType.Function> fnTypes = new ArrayList<SemanticType.Function>();
+			for (WycsFile.Declaration d : wf.declarations()) {
+				if (d.name().equals(nid.name())) {
+					if (d instanceof WycsFile.Function) {
+						WycsFile.Function f = (WycsFile.Function) d;
+						fnTypes.add(f.type);
+					} else if (d instanceof WycsFile.Macro) {
+						WycsFile.Macro f = (WycsFile.Macro) d;
+						fnTypes.add(f.type);
+					} else {
+						// Ignore this, as it's not a function or macro
+					}
+				}
+			}
+			// At this stage, we need to choose the best fit. In some cases a best
+			// fit may not exist, in which case we have ambiguity.
+			Pair<SemanticType.Function, Map<String, SemanticType>> candidate = selectCandidateFunctionOrMacro(
+					nid, parameter, generics, fnTypes, context);
+			// Done
+			return new Pair<SemanticType.Function, Map<String,SemanticType>>(candidate.first(), candidate.second());		
+		} catch(ResolveError e) {
+			throw e;
+		} catch(Exception e) {		
+			throw new InternalFailure(e.getMessage(),context.file().getEntry(),context,e);
+		}
+	}
+
+	public Pair<SemanticType.Function, Map<String, SemanticType>> selectCandidateFunctionOrMacro(
+			NameID name, SemanticType parameter, List<SemanticType> generics,
+			List<SemanticType.Function> candidates, WyalFile.Context context)
+			throws ResolveError {
+		SemanticType expandedParameter = expand(parameter,false,context);
+		SemanticType.Function candidateFn = null;	
+		HashMap<String,SemanticType> candidateBinding = null;
+		
+		for (int i = 0; i != candidates.size(); ++i) {
+			// f is the original function or macro type
+			SemanticType.Function f = candidates.get(i);			
+			// Construct the binding of generic variables to concrete variables.
+			HashMap<String,SemanticType> binding = new HashMap<String,SemanticType>();
+			SemanticType[] f_generics = f.generics();
+			for (int j = 0; j != Math.min(f_generics.length, generics.size()); ++j) {
+				SemanticType.Var v = (SemanticType.Var) f_generics[i];
+				binding.put(v.name(), generics.get(i));
+			}
+			// cf is the instantiated function or macro type
+			SemanticType.Function cf = (SemanticType.Function) f.substitute(binding);
+			// rf is the raw expanded form of the type. We need to expand it
+			// here, as otherwise the subtype operator won't work correctly.
+			SemanticType.Function rf = (SemanticType.Function) expand(cf, false, context);
+			// Now, see whether this a match and, if so, whether or not it is
+			// the current *best* match.
+			if (SemanticType.isSubtype(rf.from(), expandedParameter)) {
+				// The selection function is a potential candidate. However, we
+				// need to decide whether or not it is more precise than the
+				// current candidate.
+				if (candidateFn == null) {
+					candidateFn = f;
+					candidateBinding = binding;
+				} else if (SemanticType.isSubtype(candidateFn.from(), cf.from())) {					
+					// This means is strictly more precise.
+					candidateFn = f;
+					candidateBinding = binding;
+				} else if (SemanticType.isSubtype(cf.from(), candidateFn.from())) {					
+					// This means is strictly less precise.
+				} else {
+					// This means they in some sense have "equivalent" precision
+					// and, hence, we have some ambiguity.
+					throw new ResolveError("ambiguous function or macro");
+				}
+			}
+		}
+		if (candidateFn == null) {
+			String msg = "no match for " + name + "(" + parameter + ")";
+
+			for (SemanticType.Function p : candidates) {
+				msg += "\n\tfound: " + name + " : " + p;
+			}
+
+			throw new ResolveError(msg);
+		} else {
+			return new Pair<SemanticType.Function, Map<String, SemanticType>>(
+					candidateFn, candidateBinding);
+		}
+	}
+	
+	/**
+	 * This method takes a given import declaration, and expands it to find all
+	 * matching modules.
+	 *
+	 * @param key
+	 *            --- Path name which potentially contains a wildcard.
+	 * @return
+	 */
+	public List<Path.ID> imports(Trie key) throws ResolveError {
+		try {
+			ArrayList<Path.ID> matches = importCache.get(key);
+			if (matches != null) {
+				// cache hit
+				return matches;
+			} else {
+				// cache miss
+				matches = new ArrayList<Path.ID>();
+
+				for (Path.Entry<WyalFile> sf : srcFiles.values()) {
+					if (key.matches(sf.id())) {
+						matches.add(sf.id());
+					}
+				}
+
+				if (key.isConcrete()) {
+					// A concrete key is one which does not contain a wildcard.
+					// Therefore, it corresponds to exactly one possible item.
+					// It is helpful, from a performance perspective, to use
+					// NameSpace.exists() in such case, as this conveys the fact
+					// that we're only interested in a single item.
+					if (exists(key)) {
+						matches.add(key);
+					}
+				} else {
+					Content.Filter<?> binFilter = Content.filter(key,
+							WyalFile.ContentType);
+					for (Path.ID mid : project.match(binFilter)) {
+						matches.add(mid);
+					}
+				}
+
+				importCache.put(key, matches);
+			}
+
+			return matches;
+		} catch (Exception e) {
+			throw new ResolveError(e.getMessage(), e);
+		}
+	}
+
+	public SemanticType convert(TypePattern tp, List<String> generics,
+			WyalFile.Context context) throws ResolveError {
+		return convert(tp.toSyntacticType(), new HashSet<String>(generics),
+				context);
+	}
+
+	/**
+	 * <p>
+	 * Convert a syntactic type into a semantic type. A syntactic type
+	 * represents something written at the source-level which may be invalid, or
+	 * not expressed in the minial form.
+	 * </p>
+	 * <p>
+	 * For example, consider a syntactic type <code>int | !int</code>. This is a
+	 * valid type at the source level, and appears to be a union of two types.
+	 * In fact, semantically, this type is equivalent to <code>any</code> and,
+	 * for the purposes of subtype testing, needs to be represented as such.
+	 * </p>
+	 *
+	 *
+	 * @param type
+	 *            --- Syntactic type to be converted.
+	 * @param generics
+	 *            --- Set of declared generic variables.
+	 * @return
+	 */
+	public SemanticType convert(SyntacticType type, Set<String> generics,
+			WyalFile.Context context) throws ResolveError {
+
+		if(type instanceof SyntacticType.Void) {
+			return SemanticType.Void;
+		} else if(type instanceof SyntacticType.Any) {
+			return SemanticType.Any;
+		} else if(type instanceof SyntacticType.Null) {
+			return SemanticType.Null;
+		} else if(type instanceof SyntacticType.Bool) {
+			return SemanticType.Bool;
+		} else if(type instanceof SyntacticType.Char) {
+			return SemanticType.Int;
+		} else if(type instanceof SyntacticType.Int) {
+			return SemanticType.Int;
+		} else if(type instanceof SyntacticType.Real) {
+			return SemanticType.Real;
+		} else if (type instanceof SyntacticType.Variable) {
+			SyntacticType.Variable p = (SyntacticType.Variable) type;
+			if(!generics.contains(p.var)) {
+				throw new InternalFailure("undeclared generic variable encountered (" + p + ")",
+						context.file().getEntry(), type);
+			}
+			return SemanticType.Var(p.var);
+		} else if(type instanceof SyntacticType.Negation) {
+			SyntacticType.Negation t = (SyntacticType.Negation) type;
+			return SemanticType.Not(convert(t.element,generics,context));
+		} else if(type instanceof SyntacticType.List) {
+			// FIXME: need to include the list constraints here
+			SyntacticType.List t = (SyntacticType.List) type;
+			SemanticType element = convert(t.element,generics,context);
+			return SemanticType.Array(element);
+		} else if(type instanceof SyntacticType.Union) {
+			SyntacticType.Union t = (SyntacticType.Union) type;
+			SemanticType[] types = new SemanticType[t.elements.size()];
+			for(int i=0;i!=t.elements.size();++i) {
+				types[i] = convert(t.elements.get(i),generics,context);
+			}
+			return SemanticType.Or(types);
+		} else if(type instanceof SyntacticType.Intersection) {
+			SyntacticType.Intersection t = (SyntacticType.Intersection) type;
+			SemanticType[] types = new SemanticType[t.elements.size()];
+			for(int i=0;i!=t.elements.size();++i) {
+				types[i] = convert(t.elements.get(i),generics,context);
+			}
+			return SemanticType.And(types);
+		} else if(type instanceof SyntacticType.Tuple) {
+			SyntacticType.Tuple t = (SyntacticType.Tuple) type;
+			SemanticType[] types = new SemanticType[t.elements.size()];
+			for(int i=0;i!=t.elements.size();++i) {
+				types[i] = convert(t.elements.get(i),generics,context);
+			}
+			return SemanticType.Tuple(types);
+		} else if(type instanceof SyntacticType.Nominal) {
+			SyntacticType.Nominal n = (SyntacticType.Nominal) type;
+			List<String> n_names = n.names;
+			NameID nid;
+			// First, check whether or not we have an unqualified or fully
+			// qualified name. Currently, there is no support for partially
+			// qualified names which makes life easier at this point.
+			if(n_names.size() == 1) {
+				// This is an unqualified name and, hence, we need to qualify
+				// it. This means determining what file this name is defined it.
+				nid = resolveAsName(n_names.get(0), context);
+			} else {
+				// This is a fully qualified name. In this case, we don't need
+				// to determine what file it is defined in as this is given. All
+				// entries upto but not including the last name component
+				// correspond to the package identified, whilst the last
+				// component is the actual name.
+				Trie pkg = Trie.ROOT;
+				for (int i = 1; i != n_names.size(); ++i) {
+					pkg = pkg.append(n_names.get(i-1));
+				}
+				String name = n_names.get(n_names.size()-1);
+				nid = new NameID(pkg,name);
+			}
+			//
+			return SemanticType.Nominal(nid);
+		}
+
+		throw new InternalFailure("unknown syntactic type encountered",
+				context.file().getEntry(), type);
+	}
+
+	/**
+	 * <p>
+	 * Expand a semantic type by expanding all nominal types it contains with
+	 * their underlying type. For example:
+	 * </p>
+	 * 
+	 * <pre>
+	 * type nat is int where:
+	 *    x >= 0
+	 *    
+	 * assert:
+	 *    forall(nat x):
+	 *       x >= 0
+	 * </pre>
+	 * 
+	 * <p>
+	 * Here, the expanded version of type <code>nat</code> is <code>int</code>.
+	 * </p>
+	 *
+	 *
+	 * @param type
+	 *            --- Syntactic type to be converted.
+	 * @param maximallyConsumed
+	 *            Flag indicating whether to calculate maximally consumed type
+	 *            or not.
+	 * @return
+	 */
+	public SemanticType expand(SemanticType type, boolean maximallyConsumed, WyalFile.Context context) {
+		try {
+			if (type instanceof SemanticType.Atom) {
+				return type;
+			} else if (type instanceof SemanticType.Var) {
+				return type;
+			} else if (type instanceof SemanticType.Tuple) {
+				SemanticType.Tuple tt = (SemanticType.Tuple) type;
+				SemanticType[] elements = tt.elements();
+				boolean modified = false;
+				for (int i = 0; i != elements.length; ++i) {
+					SemanticType elem = elements[i];
+					elements[i] = expand(elem, maximallyConsumed, context);
+					if(elements[i] instanceof SemanticType.Void) {
+						// FIXME: this is something of a cludge.
+						return SemanticType.Void;
+					}
+					modified |= elements[i] != elem;
+				}
+				if (modified) {
+					return SemanticType.Tuple(elements);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.Function) {
+				SemanticType.Function ft = (SemanticType.Function) type;
+				SemanticType from = expand(ft.from(), maximallyConsumed, context);
+				SemanticType to = expand(ft.to(), maximallyConsumed, context);
+				SemanticType[] generics = ft.generics();
+				boolean modified = from != ft.from() || to != ft.to();
+				for (int i = 0; i != generics.length; ++i) {
+					SemanticType elem = generics[i];
+					generics[i] = expand(elem, maximallyConsumed, context);
+					modified |= generics[i] != elem;
+				}
+				if (modified) {
+					return SemanticType.Function(from, to, generics);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.Array) {
+				SemanticType.Array st = (SemanticType.Array) type;
+				SemanticType element = expand(st.element(), maximallyConsumed, context);
+				if (element != st.element()) {
+					return SemanticType.Array(element);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.Not) {
+				SemanticType.Not nt = (SemanticType.Not) type;
+				SemanticType element = expand(nt.element(), maximallyConsumed, context);
+				if (element != nt.element()) {
+					return SemanticType.Not(element);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.And) {
+				SemanticType.And at = (SemanticType.And) type;
+				SemanticType[] elements = at.elements();
+				boolean modified = false;
+				for (int i = 0; i != elements.length; ++i) {
+					SemanticType elem = elements[i];
+					elements[i] = expand(elem, maximallyConsumed, context);
+					modified |= elements[i] != elem;
+				}
+				if (modified) {
+					return SemanticType.And(elements);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.Or) {
+				SemanticType.Or at = (SemanticType.Or) type;
+				SemanticType[] elements = at.elements();
+				boolean modified = false;
+				for (int i = 0; i != elements.length; ++i) {
+					SemanticType elem = elements[i];
+					elements[i] = expand(elem, maximallyConsumed, context);
+					modified |= elements[i] != elem;
+				}
+				if (modified) {
+					return SemanticType.Or(elements);
+				} else {
+					return type;
+				}
+			} else if (type instanceof SemanticType.Nominal) {
+				SemanticType.Nominal nt = (SemanticType.Nominal) type;
+				WycsFile wf = getModule(nt.name().module());
+				if(wf == null) {
+					throw new SyntaxError("module not found: " + nt.name().module(), context.file().getEntry(), context);
+				}
+				WycsFile.Type td = wf.declaration(nt.name().name(),
+						WycsFile.Type.class);				
+				if(maximallyConsumed && td.invariant != null) {
+					return SemanticType.Void;
+				} else {
+					// FIXME: obviously, this doesn't work for recursive types!
+					return expand(td.type, maximallyConsumed, context);
+				}
+			}
+		} catch(SyntaxError e) {
+			throw e;
+		} catch (Exception e) {
+			throw new InternalFailure(e.getMessage(), context.file().getEntry(), context, e);
+		}
+		throw new InternalFailure("unknown type encountered", context.file().getEntry(),
+				context);
+	}
+
+	// ======================================================================
+	// Private Implementation
+	// ======================================================================
+
+	protected void process(WycsFile module, Transform<WycsFile> stage)
+			throws IOException {
+		Runtime runtime = Runtime.getRuntime();
+		long start = System.currentTimeMillis();
+		long memory = runtime.freeMemory();
+		String name = name(stage.getClass().getSimpleName());
+
+		try {
+			stage.apply(module);
+			logger.logTimedMessage("[" + module.getEntry() + "] applied "
+					+ name, System.currentTimeMillis() - start, memory
+					- runtime.freeMemory());
+			System.gc();
+		} catch (RuntimeException ex) {
+			logger.logTimedMessage("[" + module.getEntry() + "] failed on "
+					+ name + " (" + ex.getMessage() + ")",
+					System.currentTimeMillis() - start,
+					memory - runtime.freeMemory());
+			throw ex;
+		} catch (IOException ex) {
+			logger.logTimedMessage("[" + module.getEntry() + "] failed on "
+					+ name + " (" + ex.getMessage() + ")",
+					System.currentTimeMillis() - start,
+					memory - runtime.freeMemory());
+			throw ex;
+		}
+	}
+
+
+	/**
+	 * This converts a WyalFile into a WycsFile stub. A stub differs from a
+	 * complete implementation, in that it only contains type information for
+	 * functions and definitions. These are needed during the type propagation
+	 * phase, and must be calculated before hand.
+	 *
+	 * @param wyalFile
+	 * @return
+	 */
+	public WycsFile getModuleStub(WyalFile wyalFile) {
+		ArrayList<WycsFile.Declaration> declarations = new ArrayList<WycsFile.Declaration>();
+		for (WyalFile.Declaration d : wyalFile.declarations()) {
+			try {
+				if (d instanceof WyalFile.Macro) {
+					WyalFile.Macro def = (WyalFile.Macro) d;
+					SemanticType from = convert(def.from, def.generics, d);
+					SemanticType to = SemanticType.Bool;
+					SemanticType.Var[] generics = new SemanticType.Var[def.generics
+					                                                   .size()];
+					for (int i = 0; i != generics.length; ++i) {
+						generics[i] = SemanticType.Var(def.generics.get(i));
+					}
+					SemanticType.Function type = SemanticType.Function(from, to,
+							generics);
+					declarations.add(new WycsFile.Macro(def.name, type, null, def
+							.attribute(Attribute.Source.class)));
+				} else if (d instanceof WyalFile.Function) {
+					WyalFile.Function fun = (WyalFile.Function) d;
+					SemanticType from = convert(fun.from, fun.generics, d);
+					SemanticType to = convert(fun.to, fun.generics, d);
+					SemanticType.Var[] generics = new SemanticType.Var[fun.generics
+					                                                   .size()];
+					for (int i = 0; i != generics.length; ++i) {
+						generics[i] = SemanticType.Var(fun.generics.get(i));
+					}
+					SemanticType.Function type = SemanticType.Function(from, to,
+							generics);
+					declarations.add(new WycsFile.Function(fun.name, type, null,
+							fun.attribute(Attribute.Source.class)));
+				} else if (d instanceof WyalFile.Type) {
+					WyalFile.Type t = (WyalFile.Type) d;
+					SemanticType type = convert(t.type, t.generics, d);
+					SemanticType.Var[] generics = new SemanticType.Var[t.generics
+							.size()];
+					for (int i = 0; i != generics.length; ++i) {
+						generics[i] = SemanticType.Var(t.generics.get(i));
+					}
+					// The following is necessary in order to correctly handle
+					// type testing and the computation of the maximallyConsumed
+					// type. Specifically, in computing the maximallyConsumed
+					// type we check whether or not an invariant is given
+					// (though we do not care what the invariant says).
+					// Therefore, we include here a dummy invariant to trigger
+					// this when appropriate.
+					Code invariant = t.invariant == null ? null : Code.Constant(Value.Bool(true));
+					// FIXME: in the case of recursive type definitions, this is
+					// broken.
+					declarations.add(new WycsFile.Type(t.name, type, invariant, t
+							.attribute(Attribute.Source.class)));
+				}
+			} catch (ResolveError re) {
+				// should be unreachable if type propagation is already succeeded.
+				throw new SyntaxError(re.getMessage(), wyalFile.getEntry(), d, re);
+			}
+		}
+
+		return new WycsFile(wyalFile.getEntry(), declarations);
+	}
+
+	private static Path.Entry<?> determineSource(Path.Entry<?> child, Build.Graph graph) {
+		Path.Entry<?> parent = graph.parent(child);
+		while(parent != null) {
+			child = parent;
+			parent = graph.parent(child);
+		}
+		return child;		
+	}
+	
+	protected static String name(String camelCase) {
+		boolean firstTime = true;
+		String r = "";
+		for (int i = 0; i != camelCase.length(); ++i) {
+			char c = camelCase.charAt(i);
+			if (!firstTime && Character.isUpperCase(c)) {
+				r += " ";
+			}
+			firstTime = false;
+			r += Character.toLowerCase(c);
+			;
+		}
+		return r;
+	}
+}
diff --git a/modules/wycs/src/wycs/builders/Wycs2WyalBuilder.java b/modules/wycs/src/wycs/builders/Wycs2WyalBuilder.java
new file mode 100755
index 0000000000..56cc8ed0d3
--- /dev/null
+++ b/modules/wycs/src/wycs/builders/Wycs2WyalBuilder.java
@@ -0,0 +1,108 @@
+package wycs.builders;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static wycc.lang.SyntaxError.*;
+import static wycs.solver.Solver.SCHEMA;
+import wyautl.io.PrettyAutomataWriter;
+import wybs.lang.*;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycs.core.WycsFile;
+import wycs.io.WyalFilePrinter;
+import wycs.io.WycsFilePrinter;
+import wycs.solver.Solver;
+import wycs.syntax.WyalFile;
+import wycs.transforms.TypePropagation;
+import wycs.transforms.VerificationCheck;
+import wyfs.lang.Path;
+import wyfs.lang.Path.Entry;
+import wyfs.util.Trie;
+
+public class Wycs2WyalBuilder implements Builder {
+
+	/**
+	 * The master namespace for identifying all resources available to the
+	 * builder. This includes all modules declared in the project being verified
+	 * and/or defined in external resources (e.g. jar files).
+	 */
+	protected final Build.Project project;
+
+	protected Logger logger = Logger.NULL;
+
+	protected boolean debug = false;
+
+	public Wycs2WyalBuilder(Build.Project project) {
+		this.project = project;
+	}
+
+	public Build.Project project() {
+		return project;
+	}
+
+	public void setLogger(Logger logger) {
+		this.logger = logger;
+	}
+
+	public void setDebug(boolean debug) {
+		this.debug = debug;
+	}
+
+	// ======================================================================
+	// Build Method
+	// ======================================================================
+
+	@Override
+	public Set<Path.Entry<?>> build(Collection<Pair<Entry<?>, Path.Root>> delta, Build.Graph graph) throws IOException {
+		Runtime runtime = Runtime.getRuntime();
+		long startTime = System.currentTimeMillis();
+		long startMemory = runtime.freeMemory();
+		long tmpTime = startTime;
+		long tmpMem = startMemory;
+
+		// ========================================================================
+		// Parse and register source files
+		// ========================================================================
+
+		int count = 0;
+		HashSet<Path.Entry<?>> generatedFiles = new HashSet<Path.Entry<?>>();
+		for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+			Path.Entry<?> src = p.first();
+			Path.Root dst = p.second();
+			if (src.contentType() == WycsFile.ContentType) {
+				Path.Entry<WycsFile> source = (Path.Entry<WycsFile>) src;
+				Path.Entry<WyalFile> target = (Path.Entry<WyalFile>) dst.create(source.id(), WyalFile.ContentType);
+				graph.registerDerivation(source, source);
+				generatedFiles.add(target);
+				WycsFile wf = source.read();
+				// NOTE: following is really a temporary hack
+				new WycsFilePrinter(System.err).write(wf);
+				WyalFile waf = decompile(wf);
+				target.write(waf);
+				count++;
+			}
+		}
+
+		// ========================================================================
+		// Done
+		// ========================================================================
+
+		long endTime = System.currentTimeMillis();
+		logger.logTimedMessage("Wycs => Wyal: decompiled " + delta.size() + " file(s)",
+				endTime - startTime, startMemory - runtime.freeMemory());
+
+		return generatedFiles;
+	}
+
+	protected WyalFile decompile(WycsFile wycsFile) {
+		return new WyalFile(wycsFile.getEntry());
+	}
+}
diff --git a/modules/wycs/src/wycs/core/Code.java b/modules/wycs/src/wycs/core/Code.java
new file mode 100755
index 0000000000..8ffc4681f5
--- /dev/null
+++ b/modules/wycs/src/wycs/core/Code.java
@@ -0,0 +1,806 @@
+package wycs.core;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+
+/**
+ * Represents a "bytecode" in the language of the Wycs theorem prover. Bytecodes
+ * are recursively defined trees, where each node is an instance of
+ * <code>Code</code> with the following attributes:
+ *
+ * <ul>
+ * <li><b>Type</b>. Provides information about the type of operands used in the
+ * bytecode.</li>
+ * <li><b>Opcode</b> Determines the exact operation described by the bytecode.</li>
+ * <li><b>Operands</b> Identifies zero or more operands for this bytecode.</li>
+ * </ul>
+ *
+ * In addition, there are various subclasses of <code>Code</code> which encode
+ * additional information (e.g. constant values, variable indices, etc).
+ *
+ * @author David J. Pearce
+ *
+ * @param <T>
+ */
+public abstract class Code<T extends SemanticType> extends SyntacticElement.Impl {
+
+	/**
+	 * The type associated with this bytecode. Note that this is not necessarily
+	 * related to the type of the value that this expression evaluates to. To
+	 * access the that type, the <code>returnType()</code> method should be used.
+	 */
+	public final T type;
+
+	/**
+	 * The opcode which defines what this bytecode does. Observe that certain
+	 * bytecodes must correspond with specific subclasses. For example,
+	 * <code>opcode == LOAD</code> always indicates that <code>this</code> is an
+	 * instanceof <code>Load</code>.
+	 */
+	public final Op opcode;
+
+	/**
+	 * An array of zero of more code operands. The exact number of operands
+	 * depends on the opcode in question. For example, an <code>Add</code>
+	 * opcode indicates there are exactly <code>2</code> operands. On the
+	 * otherhand, a
+	 * <code>Tuple</copde> opcode indicates that there are zero or more operands.
+	 */
+	public final Code<?>[] operands;
+
+	public Code(T type, Op opcode, Code<?>[] operands, Attribute... attributes) {
+		super(attributes);
+		this.type = type;
+		this.opcode = opcode;
+		this.operands = operands;
+	}
+
+	public Code(T type, Op opcode, Code<?>[] operands, Collection<Attribute> attributes) {
+		super(attributes);
+		this.type = type;
+		this.opcode = opcode;
+		this.operands = operands;
+	}
+
+	/**
+	 * Determine the complete set of used variables, including both bound and
+	 * unbound variables. A variable is unbound if it is not captured by a
+	 * quantifier.
+	 * 
+	 * @param variables
+	 */
+	public void getUsedVariables(java.util.Set<Code.Variable> variables) {
+		for(int i=0;i!=operands.length;++i) {
+			operands[i].getUsedVariables(variables);
+		}
+	}
+	
+	/**
+	 * Substitute variables for bytecodes throughout this bytecode as determined
+	 * by a given map. Variables which are not keys of the <code>binding</code>
+	 * map are untouched. Note that variable capture is not prevented by this
+	 * operation, and care must be taken to ensure this does not arise.
+	 *
+	 * @param binding
+	 *            --- a map from variables to the bytecodes wwhich are to
+	 *            replace them.
+	 * @return
+	 */
+	public Code<?> substitute(Map<Integer,Code> binding) {
+		Code<?>[] nOperands = operands;
+		for(int i=0;i!=nOperands.length;++i) {
+			Code<?> o = nOperands[i];
+			Code<?> c = o.substitute(binding);
+			if(c != o && operands == nOperands) {
+				nOperands = Arrays.copyOf(operands, operands.length);
+			}
+			nOperands[i] = c;
+		}
+		if(nOperands != operands) {
+			return clone(type,opcode,nOperands);
+		}
+		return this;
+	}
+
+	/**
+	 * Rebind variables within the given expression. This includes variables
+	 * declared in quantifiers.
+	 *
+	 * @param binding
+	 *            --- a map from variables to the bytecodes wwhich are to
+	 *            replace them.
+	 * @return
+	 */
+	public Code<?> rebind(Map<Integer,Integer> binding) {
+		Code<?>[] nOperands = operands;
+		for(int i=0;i!=nOperands.length;++i) {
+			Code<?> o = nOperands[i];
+			Code<?> c = o.rebind(binding);
+			if(c != o && operands == nOperands) {
+				nOperands = Arrays.copyOf(operands, operands.length);
+			}
+			nOperands[i] = c;
+		}
+		if(nOperands != operands) {
+			return clone(type,opcode,nOperands);
+		}
+		return this;
+	}
+	
+	/**
+	 * Instantiate generic variables with concrete types in bytecodes as
+	 * determined by a given map. Generic variables which are not keys of the
+	 * <code>binding</code> map are untouched.
+	 *
+	 * @param binding
+	 *            --- a map from variables to the bytecodes wwhich are to
+	 *            replace them.
+	 * @return
+	 */
+	public Code<?> instantiate(Map<String,SemanticType> binding) {
+		// First, attempt to instantiate our type
+		T nType = (T) type.substitute(binding);
+
+		// Second, attempt to recursively instantiate generic variables in
+		// operands
+		Code<?>[] nOperands = operands;
+		for(int i=0;i!=nOperands.length;++i) {
+			Code<?> o = nOperands[i];
+			Code<?> c = o.instantiate(binding);
+			if(c != o && operands == nOperands) {
+				nOperands = Arrays.copyOf(operands, operands.length);
+			}
+			nOperands[i] = c;
+		}
+
+		if(nOperands != operands || nType != type) {
+			return clone(nType,opcode,nOperands);
+		}
+		return this;
+	}
+
+	public abstract Code<?> clone(T type, Op opcode, Code<?>[] operands);
+
+	/**
+	 * Determine the most precise type capturing any value that this bytecode
+	 * could evaluate to.
+	 *
+	 * @return
+	 */
+	public abstract SemanticType returnType();
+	
+	public String toString() {
+		String r = opcode.toString();
+		if(operands.length > 0) {
+			r = r + "(";
+			for(int i=0;i!=operands.length;++i) {
+				if(i != 0) {
+					r = r + ", ";
+				}
+				if(operands[i] != null) {
+					r = r + operands[i].toString();
+				} else {
+					r = r + "null";
+				}
+			}
+			r = r + ")";
+		}
+		return r;
+	}
+
+	// ==================================================================
+	// Constructors
+	// ==================================================================
+
+	public static Variable Variable(SemanticType type, int index, Attribute... attributes) {
+		return new Variable(type,new Code[0],index,attributes);
+	}
+
+	public static Variable Variable(SemanticType type, int index, Collection<Attribute> attributes) {
+		return new Variable(type,new Code[0],index,attributes);
+	}
+
+	public static Variable Variable(SemanticType type, Code<?>[] operands, int index, Attribute... attributes) {
+		return new Variable(type,operands,index,attributes);
+	}
+
+	public static Variable Variable(SemanticType type, Code<?>[] operands, int index, Collection<Attribute> attributes) {
+		return new Variable(type,operands,index,attributes);
+	}
+
+
+	public static Constant Constant(Value value, Attribute... attributes) {
+		return new Constant(value,attributes);
+	}
+
+	public static Constant Constant(Value value, Collection<Attribute> attributes) {
+		return new Constant(value,attributes);
+	}
+
+	public static Cast Cast(SemanticType type, Code<?> operand, SemanticType target, Attribute... attributes) {
+		return new Cast(type,operand,target,attributes);
+	}
+
+	public static Cast Cast(SemanticType type, Code<?> operand, SemanticType target, Collection<Attribute> attributes) {
+		return new Cast(type,operand,target,attributes);
+	}
+	
+	public static Unary Unary(SemanticType type, Op opcode, Code<?> operand,
+			Attribute... attributes) {
+		return new Unary(type,opcode,operand,attributes);
+	}
+
+	public static Unary Unary(SemanticType type, Op opcode, Code<?> operand,
+			Collection<Attribute> attributes) {
+		return new Unary(type,opcode,operand,attributes);
+	}
+
+	public static Binary Binary(SemanticType type, Op opcode, Code<?> leftOperand,
+			Code<?> rightOperand, Attribute... attributes) {
+		return new Binary(type,opcode,leftOperand,rightOperand,attributes);
+	}
+
+	public static Binary Binary(SemanticType type, Op opcode, Code<?> leftOperand,
+			Code<?> rightOperand, Collection<Attribute> attributes) {
+		return new Binary(type,opcode,leftOperand,rightOperand,attributes);
+	}
+
+	public static Nary Nary(SemanticType type, Op opcode, Code<?>[] operands,
+			Attribute... attributes) {
+		return new Nary(type,opcode,operands,attributes);
+	}
+
+	public static Nary Nary(SemanticType type, Op opcode, Code<?>[] operands,
+			Collection<Attribute> attributes) {
+		return new Nary(type,opcode,operands,attributes);
+	}
+
+	public static Load Load(SemanticType.Tuple type, Code<?> source, int index,
+			Attribute... attributes) {
+		return new Load(type,source,index,attributes);
+	}
+
+	public static Load Load(SemanticType.Tuple type, Code<?> source, int index,
+			Collection<Attribute> attributes) {
+		return new Load(type,source,index,attributes);
+	}
+
+	public static IndexOf IndexOf(SemanticType.Array type, Code<?> source, Code<?> index,
+			Attribute... attributes) {
+		return new IndexOf(type,source,index,attributes);
+	}
+
+	public static IndexOf IndexOf(SemanticType.Array type, Code<?> source, Code<?> index,
+			Collection<Attribute> attributes) {
+		return new IndexOf(type,source,index,attributes);
+	}
+
+	public static Is Is(SemanticType type, Code<?> operand, SemanticType test,
+			Attribute... attributes) {
+		return new Is(type, operand, test, attributes);
+	}
+
+	public static Is Is(SemanticType type, Code<?> operand, SemanticType test,
+			Collection<Attribute> attributes) {
+		return new Is(type, operand, test, attributes);
+	}
+	
+	
+	public static Quantifier Quantifier(SemanticType type, Op opcode,
+			Code<?> operand, Pair<SemanticType,Integer>[] types,
+			Attribute... attributes) {
+		return new Quantifier(type, opcode, operand, types, attributes);
+	}
+
+	public static Quantifier Quantifier(SemanticType type, Op opcode,
+			Code<?> operand, Pair<SemanticType,Integer>[] types,
+			Collection<Attribute> attributes) {
+		return new Quantifier(type, opcode, operand, types, attributes);
+	}
+
+	public static FunCall FunCall(SemanticType.Function type, Code<?> operand,
+			NameID nid, SemanticType[] binding, Attribute... attributes) {
+		return new FunCall(type,binding,operand,nid,attributes);
+	}
+
+	public static FunCall FunCall(SemanticType.Function type, Code<?> operand,
+			NameID nid, SemanticType[] binding, Collection<Attribute> attributes) {
+		return new FunCall(type,binding,operand,nid,attributes);
+	}
+
+	// ==================================================================
+	// Classes
+	// ==================================================================
+
+	public static enum Op {
+		NULL(0),
+		VAR(1),
+		CONST(2),
+		CAST(3),
+		NOT(4),
+		NEG(5),
+		LENGTH(6),
+		IS(7),
+		ADD(8),
+		SUB(9),
+		MUL(10),
+		DIV(11),
+		REM(12),
+		EQ(13),
+		NEQ(14),
+		LT(15),
+		LTEQ(16),
+		ARRAYGEN(17),
+		INDEXOF(18),		
+		AND(20),
+		OR(21),
+		TUPLE(22),
+		ARRAY(23),
+		LOAD(24),
+		EXISTS(25),
+		FORALL(26),
+		FUNCALL(27);	
+
+		public int offset;
+
+		private Op(int offset) {
+			this.offset = offset;
+		}
+	}
+
+	private static Code<?>[] NO_OPERANDS = new Code[0];
+
+	public final static class Variable extends Code<SemanticType> {
+		public final int index;
+
+		private Variable(SemanticType type, Code<?>[] operands, int index,
+				Attribute... attributes) {
+			super(type, Op.VAR, operands, attributes);
+			this.index = index;
+		}
+
+		private Variable(SemanticType type, Code<?>[] operands, int index,
+				Collection<Attribute> attributes) {
+			super(type, Op.VAR, operands, attributes);
+			this.index = index;
+		}
+
+		@Override
+		public void getUsedVariables(java.util.Set<Code.Variable> variables) {
+			variables.add(Code.Variable(type, index));
+		}
+		
+		@Override
+		public Code<?> substitute(Map<Integer,Code> binding) {
+			Code<?> r = binding.get(index);
+			if(r != null) {
+				return r;
+			} else{
+				return super.substitute(binding);
+			}
+		}
+
+		@Override
+		public Code<?> rebind(Map<Integer, Integer> binding) {
+			Code<?> r = super.rebind(binding);
+			Integer nIndex = binding.get(index);
+			if (nIndex != null) {
+				return new Code.Variable(type, r.operands, nIndex, attributes());
+			} else {
+				return r;
+			}
+		}
+		
+		@Override
+		public SemanticType returnType() {
+			return type;
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Variable(type,operands,index,attributes());
+		}
+	}
+
+	public final static class Constant extends Code<SemanticType> {
+		public final Value value;
+
+		private Constant(Value value, Attribute... attributes) {
+			super(value.type(),Op.CONST,NO_OPERANDS,attributes);
+			this.value = value;
+		}
+
+		private Constant(Value value, Collection<Attribute> attributes) {
+			super(value.type(), Op.CONST, NO_OPERANDS, attributes);
+			this.value = value;
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return value.type();
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return this;
+		}
+	}
+
+	public final static class Cast extends Code<SemanticType> {
+		public final SemanticType target;
+
+		private Cast(SemanticType type, Code<?> operand, SemanticType target, Attribute... attributes) {
+			super(type,Op.CAST,new Code[] { operand },attributes);
+			this.target = target;
+		}
+
+		private Cast(SemanticType type, Code<?> operand, SemanticType target, Collection<Attribute> attributes) {
+			super(type,Op.CAST,new Code[] { operand },attributes);			
+			this.target = target;
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return target;
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Cast(type,operands[0],target,attributes());
+		}
+	}
+
+	public final static class Is extends Code<SemanticType> {
+		public final SemanticType test;
+
+		private Is(SemanticType type, Code<?> operand, SemanticType test, Attribute... attributes) {
+			super(type,Op.IS,new Code[] { operand },attributes);
+			this.test = test;
+		}
+
+		private Is(SemanticType type, Code<?> operand, SemanticType test, Collection<Attribute> attributes) {
+			super(type,Op.IS,new Code[] { operand },attributes);
+			this.test = test;
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return SemanticType.Bool;
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Is(type,operands[0],test,attributes());
+		}
+	}
+	
+	public final static class Unary extends Code<SemanticType> {
+		private Unary(SemanticType type, Op opcode, Code<?> operand,
+				Attribute... attributes) {
+			super(type, opcode, new Code[] { operand }, attributes);
+			if (opcode.offset < Op.NOT.offset
+					|| opcode.offset > Op.LENGTH.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Unary constructor");
+			}
+		}
+
+		private Unary(SemanticType type, Op opcode, Code<?> operand,
+				Collection<Attribute> attributes) {
+			super(type, opcode, new Code[] { operand }, attributes);
+			if (opcode.offset < Op.NOT.offset
+					|| opcode.offset > Op.LENGTH.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Unary constructor");
+			}
+		}
+
+		@Override
+		public SemanticType returnType() {
+			switch(opcode) {
+			case NEG:
+			case NOT:
+				return type;
+			case LENGTH:
+				return SemanticType.Int;
+			}
+			throw new IllegalArgumentException("invalid opcode for unary bytecode");
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Unary(type,opcode,operands[0],attributes());
+		}
+	}
+
+	public final static class Binary extends Code<SemanticType> {
+		private Binary(SemanticType type, Op opcode, Code<?> leftOperand,
+				Code<?> rightOperand, Attribute... attributes) {
+			super(type, opcode, new Code[] { leftOperand, rightOperand },
+					attributes);
+			if (opcode.offset < Op.ADD.offset
+					|| opcode.offset > Op.ARRAYGEN.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Binary constructor");
+			}
+		}
+
+		private Binary(SemanticType type, Op opcode, Code<?> leftOperand,
+				Code rightOperand, Collection<Attribute> attributes) {
+			super(type, opcode, new Code[] { leftOperand, rightOperand },
+					attributes);
+			if (opcode.offset < Op.ADD.offset
+					|| opcode.offset > Op.ARRAYGEN.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Binary constructor");
+			}
+		}
+
+		@Override
+		public SemanticType returnType() {
+			switch(opcode) {
+			case ADD:
+			case SUB:
+			case MUL:
+			case DIV:
+			case REM:
+				return type;
+			case EQ:
+			case NEQ:
+			case LT:
+			case LTEQ:
+				return SemanticType.Bool;
+			case ARRAYGEN:
+				return type;
+			}
+			throw new IllegalArgumentException("invalid opcode for binary bytecode");
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Binary(type,opcode,operands[0],operands[1],attributes());
+		}
+	}
+
+	public final static class Nary extends Code<SemanticType> {
+		private Nary(SemanticType type, Op opcode, Code<?>[] operands,
+				Attribute... attributes) {
+			super(type, opcode, operands, attributes);
+			if (opcode.offset < Op.AND.offset || opcode.offset > Op.ARRAY.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Nary constructor");
+			}
+		}
+
+		private Nary(SemanticType type, Op opcode, Code<?>[] operands,
+				Collection<Attribute> attributes) {
+			super(type, opcode, operands, attributes);
+			if (opcode.offset < Op.AND.offset || opcode.offset > Op.ARRAY.offset) {
+				throw new IllegalArgumentException(
+						"invalid opcode for Nary constructor");
+			}
+		}
+
+		@Override
+		public SemanticType returnType() {
+			switch(opcode) {
+			case AND:
+			case OR:
+				return SemanticType.Bool;
+			case ARRAY:
+				return type;
+			case TUPLE:
+				return type;
+			}
+			throw new IllegalArgumentException("invalid opcode for binary bytecode");
+		}
+
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Nary(type,opcode,operands,attributes());
+		}
+	}
+
+	public final static class IndexOf extends Code<SemanticType.Array> {
+
+		private IndexOf(SemanticType.Array type, Code<?> source, Code<?> index,
+				Attribute... attributes) {
+			super(type, Op.INDEXOF, new Code[] { source, index }, attributes);
+		}
+
+		private IndexOf(SemanticType.Array type, Code<?> source, Code<?> index,
+				Collection<Attribute> attributes) {
+			super(type, Op.INDEXOF, new Code[] { source, index }, attributes);
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return type.element();
+		}
+
+		@Override
+		public Code<?> clone(SemanticType.Array type, Op opcode, Code<?>[] operands) {
+			return IndexOf(type,operands[0],operands[1],attributes());
+		}
+	}
+
+	public final static class Load extends Code<SemanticType.Tuple> {
+		public final int index;
+
+		private Load(SemanticType.Tuple type, Code<?> source, int index,
+				Attribute... attributes) {
+			super(type, Op.LOAD, new Code[] { source }, attributes);
+			this.index = index;
+		}
+
+		private Load(SemanticType.Tuple type, Code<?> source, int index,
+				Collection<Attribute> attributes) {
+			super(type, Op.LOAD, new Code[] { source }, attributes);
+			this.index = index;
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return type.element(index);
+		}
+
+		@Override
+		public Code<?> clone(SemanticType.Tuple type, Op opcode, Code<?>[] operands) {
+			return Load(type,operands[0],index,attributes());
+		}
+	}
+
+	public final static class Quantifier extends Code<SemanticType> {
+		public final Pair<SemanticType,Integer>[] types;
+
+		private Quantifier(SemanticType type, Op opcode,
+				Code<?> operand, Pair<SemanticType,Integer>[] types, Attribute... attributes) {
+			super(type, opcode, new Code[] { operand }, attributes);
+			if (opcode != Op.EXISTS && opcode != Op.FORALL) {
+				throw new IllegalArgumentException(
+						"invalid opcode for quantifier constructor");
+			}
+			this.types = types;
+		}
+
+		private Quantifier(SemanticType type, Op opcode, Code<?> operand,
+				Pair<SemanticType,Integer>[] types, Collection<Attribute> attributes) {
+			super(type, opcode, new Code[] { operand }, attributes);
+			if (opcode != Op.EXISTS && opcode != Op.FORALL) {
+				throw new IllegalArgumentException(
+						"invalid opcode for quantifier constructor");
+			}
+			this.types = types;
+		}
+
+		@Override
+		public SemanticType returnType() {
+			return SemanticType.Bool;
+		}
+
+		@Override
+		public void getUsedVariables(java.util.Set<Code.Variable> variables) {
+			super.getUsedVariables(variables);
+			for (Pair<SemanticType, Integer> p : types) {
+				variables.add(Code.Variable(p.first(), p.second()));
+			}
+		}
+		
+		@Override
+		public Code<?> clone(SemanticType type, Op opcode, Code<?>[] operands) {
+			return Quantifier(type,opcode,operands[0],types,attributes());
+		}
+
+		@Override
+		public Code<?> substitute(Map<Integer, Code> binding) {			
+			Code<?> operand = operands[0].substitute(binding);
+			if (operand != operands[0]) {
+				return new Quantifier(this.type, this.opcode, operand, types,
+						attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public Code<?> rebind(Map<Integer, Integer> binding) {
+			// FIXME: is this safe in the context of variable capture?
+			Code<?> operand = operands[0].rebind(binding);
+			Pair<SemanticType,Integer>[] types = rebind(this.types,binding);
+			if (operand != operands[0] || types != this.types) {
+				return new Quantifier(this.type, this.opcode, operand, types,
+						attributes());
+			} else {
+				return this;
+			}
+		}
+		
+		@Override
+		public Code<?> instantiate(Map<String,SemanticType> binding) {
+			Pair<SemanticType, Integer>[] nTypes = types;
+			for (int i = 0; i != types.length; ++i) {
+				Pair<SemanticType, Integer> p = nTypes[i];
+				SemanticType ot = p.first();
+				SemanticType nt = ot.substitute(binding);
+				if (nt != ot) {
+					if (types == nTypes) {
+						nTypes = Arrays.copyOf(types, nTypes.length);
+						nTypes[i] = new Pair<SemanticType, Integer>(nt,
+								p.second());
+					}
+				}
+			}
+
+			Code operand = operands[0].instantiate(binding);
+			if (operand != operands[0] || nTypes != types) {
+				return new Quantifier(this.type, this.opcode, operand, nTypes,
+						attributes());
+			} else {
+				return this;
+			}
+		}
+		
+		private static Pair<SemanticType, Integer>[] rebind(Pair<SemanticType, Integer>[] types,
+				Map<Integer, Integer> binding) {
+			Pair<SemanticType, Integer>[] nTypes = types;
+
+			for (int i = 0; i != nTypes.length; ++i) {
+				Pair<SemanticType, Integer> p = nTypes[i];
+				Integer nIndex = binding.get(p.second());
+				if (nIndex != null) {
+					if (nTypes == types) {
+						nTypes = Arrays.copyOf(types, types.length);
+					}
+					nTypes[i] = new Pair<SemanticType, Integer>(p.first(), nIndex);
+				}
+			}
+			return nTypes;
+		}
+	}
+
+	public final static class FunCall extends Code<SemanticType.Function> {
+		public final NameID nid;
+		public final SemanticType[] binding;
+
+		private FunCall(SemanticType.Function type, SemanticType[] binding, Code<?> operand, NameID nid,
+				Attribute... attributes) {
+			super(type, Op.FUNCALL, new Code[] { operand }, attributes);
+			this.nid = nid;
+			this.binding = Arrays.copyOf(binding, binding.length);
+		}
+
+		private FunCall(SemanticType.Function type, SemanticType[] binding, Code<?> operand, NameID nid,
+				Collection<Attribute> attributes) {
+			super(type, Op.FUNCALL, new Code[] { operand }, attributes);
+			this.nid = nid;
+			this.binding = Arrays.copyOf(binding, binding.length);
+		}
+
+		@Override
+		public SemanticType returnType() {
+			HashMap<String, SemanticType> binding = new HashMap<String, SemanticType>();
+			SemanticType[] type_generics = type.generics();
+			for (int j = 0; j != Math.min(type_generics.length,
+					this.binding.length); ++j) {
+				SemanticType.Var v = (SemanticType.Var) type_generics[j];
+				binding.put(v.name(), this.binding[j]);
+			}
+			return type.to().substitute(binding);
+		}
+
+		@Override
+		public Code<?> clone(SemanticType.Function type, Code.Op opcode,
+				Code<?>[] operands) {
+			return new FunCall(type, binding, operands[0], nid, attributes());
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/core/NormalForms.java b/modules/wycs/src/wycs/core/NormalForms.java
new file mode 100755
index 0000000000..5c0aad8ad8
--- /dev/null
+++ b/modules/wycs/src/wycs/core/NormalForms.java
@@ -0,0 +1,593 @@
+package wycs.core;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import wycc.util.Pair;
+
+/**
+ * Provides a number of encodings for many of the standard data types found in a
+ * typical programming language (especially, of course, those found in Whiley).
+ * More specifically, the supported data types are:
+ * <ul>
+ * <li><b>Sets/</b>
+ * <li><b>Records.</b> These are map field names (i.e. strings) to values of
+ * with heterogenous types (i.e. different fields can map to different types).
+ * Records are encoded as sets of tuples which implement
+ * <code>wycs.lang.Map</code> and where fields are represented as strings
+ * mapping to their contents.</li>
+ * <li><b>Lists.</b></li>
+ * <li><b>Maps.</b></li>
+ * <li><b>Strings.</b></li>
+ * </ul>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class NormalForms {
+
+	// =============================================================================
+	// Negation Normal Form
+	// =============================================================================
+
+	/**
+	 * Convert a given expression into negation normal form, where all logical
+	 * negations are pushed inwards as far as possible.
+	 *
+	 * @param e
+	 *            --- expression to be converted.
+	 * @return
+	 */
+	public static Code negationNormalForm(Code e) {
+		return negationNormalForm(e,false);
+	}
+
+	private static Code negationNormalForm(Code e, boolean negate) {
+		if(e instanceof Code.Variable || e instanceof Code.Constant) {
+			return negate(e,negate);
+		} else if(e instanceof Code.Unary) {
+			return negationNormalForm((Code.Unary)e,negate);
+		} else if(e instanceof Code.Binary) {
+			return negationNormalForm((Code.Binary)e,negate);
+		} else if(e instanceof Code.Nary) {
+			return negationNormalForm((Code.Nary)e,negate);
+		} else if(e instanceof Code.Quantifier) {
+			return negationNormalForm((Code.Quantifier)e,negate);
+		} else if(e instanceof Code.FunCall) {
+			return negationNormalForm((Code.FunCall)e,negate);
+		} else if(e instanceof Code.Load) {
+			return negationNormalForm((Code.Load)e,negate);
+		} else if(e instanceof Code.IndexOf) {
+			return negationNormalForm((Code.IndexOf)e,negate);
+		} else if(e instanceof Code.Is) {
+			return negationNormalForm((Code.Is)e,negate);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code negationNormalForm(Code.Unary e, boolean negate) {
+		switch (e.opcode) {
+		case LENGTH:
+		case NEG:
+			return negate(e, negate);
+		case NOT:
+			return negationNormalForm(e.operands[0], !negate);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code negationNormalForm(Code.Binary e, boolean negate) {
+		switch (e.opcode) {
+		case ADD:
+		case SUB:
+		case MUL:
+		case DIV:
+		case REM:
+		case LT:
+		case LTEQ:
+		case EQ:
+		case NEQ:
+			// TODO: there is a potential bug here if the arguments of this
+			// binary expression are boolean expressions.
+			return negate(e,negate);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code negationNormalForm(Code.Nary e, boolean negate) {
+		switch (e.opcode) {
+		case ARRAY:
+		case TUPLE:
+			return e; // noop
+		case AND:
+		case OR:
+			Code.Op op = e.opcode;
+			Code[] operands = new Code[e.operands.length];
+			if(negate) {
+				for(int i=0;i!=operands.length;++i) {
+					operands[i] = negationNormalForm(e.operands[i], true);
+				}
+				// swap the operation
+				op = op == Code.Nary.Op.AND ? Code.Nary.Op.OR : Code.Nary.Op.AND ;
+			} else {
+				for(int i=0;i!=operands.length;++i) {
+					operands[i] = negationNormalForm(e.operands[i], false);
+				}
+			}
+			return Code.Nary(SemanticType.Bool,op, operands, e.attributes());
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code negationNormalForm(Code.Quantifier e, boolean negate) {
+		Code.Op opcode = e.opcode;
+		if (negate) {
+			opcode = e.opcode == Code.Op.EXISTS ? Code.Op.FORALL
+					: Code.Op.EXISTS;
+		}
+		return Code.Quantifier(SemanticType.Bool, opcode,
+				negationNormalForm(e.operands[0], negate), e.types,
+				e.attributes());
+	}
+
+	private static Code negationNormalForm(Code.FunCall e, boolean negate) {
+		// TODO: there is a potential bug here if the arguments of this
+		// binary expression are boolean expressions.
+		return negate(e,negate);
+	}
+
+	private static Code negationNormalForm(Code.Load e, boolean negate) {
+		return negate(e, negate);
+	}
+
+	private static Code negationNormalForm(Code.IndexOf e, boolean negate) {
+		return negate(e, negate);
+	}
+	
+	private static Code negationNormalForm(Code.Is e, boolean negate) {
+		return negate(e, negate);
+	}
+	
+	private static Code negate(Code e, boolean negate) {
+		if (!negate) {
+			return e;
+		} else if (e instanceof Code.Unary
+				&& ((Code.Unary) e).opcode == Code.Unary.Op.NOT) {
+			return e;
+		} else if(e instanceof Code.Binary) {
+			Code.Binary be = (Code.Binary) e;
+			Code lhs = e.operands[0];
+			Code rhs = e.operands[1];
+			Code tmp;
+			Code.Op op;
+			switch(be.opcode) {
+			case LT:
+				op = Code.Op.LTEQ;
+				tmp = lhs; lhs = rhs; rhs = tmp;
+				break;
+			case LTEQ:
+				op = Code.Op.LT;
+				tmp = lhs; lhs = rhs; rhs = tmp;
+				break;
+			case EQ:
+				op = Code.Op.NEQ;
+				break;
+			case NEQ:
+				op = Code.Op.EQ;
+				break;
+			default:
+				return Code.Unary(SemanticType.Bool, Code.Op.NOT, e, e.attributes());
+			}
+			return Code.Binary(e.type, op, lhs, rhs, e.attributes());
+		}
+
+		return Code.Unary(SemanticType.Bool, Code.Op.NOT, e, e.attributes());
+	}
+
+	// =============================================================================
+	// Prefix Normal Form
+	// =============================================================================
+
+	/**
+	 * Convert a given expression into Prefix Normal Form, where there at most
+	 * one quantifier which universally quantifies the entire expression. For
+	 * example:
+	 *
+	 * <pre>
+	 * forall(int x)(x > 0 && forall(int y)(y < 0))
+	 * </pre>
+	 *
+	 * would become
+	 *
+	 * <pre>
+	 * forall(int x, int y)(x > 0 && y < 0)
+	 * </pre>
+	 *
+	 * @param e
+	 * @return
+	 */
+	public static Code prefixNormalForm(Code e) {
+		e = renameVariables(e);
+		e = skolemiseExistentials(e);
+		e = extractUniversals(e);
+		return e;
+	}
+
+	/**
+	 * Traverse the expression rename bound variables to ensure there is no
+	 * potential for variable capture during the conversion to PNF.
+	 *
+	 * @param e
+	 * @return
+	 */
+	public static Code renameVariables(Code e) {
+		return renameVariables(e, new HashMap<Integer, Integer>(),
+				new HashSet<Integer>());
+	}
+
+	/**
+	 * Traverse the expression rename bound variables to ensure there is no
+	 * potential for variable capture during the conversion to PNF.
+	 *
+	 * @param e
+	 * @param freeVariable
+	 *            --- the first available free variable.
+	 *            clashing with.
+	 * @return
+	 */
+	public static Code renameVariables(Code e, int freeVariable) {
+		HashSet<Integer> globals = new HashSet<Integer>();
+		globals.add(freeVariable-1);
+		return renameVariables(e, new HashMap<Integer, Integer>(),
+				new HashSet<Integer>(globals));
+	}
+
+	private static Code renameVariables(Code e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		if(e instanceof Code.Constant) {
+			return e;
+		} else if(e instanceof Code.Variable) {
+			return renameVariables ((Code.Variable)e,binding,globals);
+		} else if(e instanceof Code.Unary) {
+			return renameVariables ((Code.Unary)e,binding,globals);
+		} else if(e instanceof Code.Binary) {
+			return renameVariables ((Code.Binary)e,binding,globals);
+		} else if(e instanceof Code.Nary) {
+			return renameVariables ((Code.Nary)e,binding,globals);
+		} else if(e instanceof Code.Quantifier) {
+			return renameVariables ((Code.Quantifier)e,binding,globals);
+		} else if(e instanceof Code.FunCall) {
+			return renameVariables ((Code.FunCall)e,binding,globals);
+		} else if(e instanceof Code.Cast) {
+			return renameVariables ((Code.Cast)e,binding,globals);
+		} else if(e instanceof Code.Is) {
+			return renameVariables ((Code.Is)e,binding,globals);
+		} else if(e instanceof Code.Load) {
+			return renameVariables ((Code.Load)e,binding,globals);
+		} else if(e instanceof Code.IndexOf) {
+			return renameVariables ((Code.IndexOf)e,binding,globals);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code renameVariables(Code.Variable e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		Code[] operands = new Code[e.operands.length];
+		for (int i = 0; i != operands.length; ++i) {
+			operands[i] = renameVariables(e.operands[i], binding, globals);
+		}
+		Integer i = binding.get(e.index);
+		if(i == null) {
+			i = e.index;
+		}
+		return Code.Variable(e.type, operands, i, e.attributes());
+	}
+
+	private static Code renameVariables(Code.Unary e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.Unary(e.type,e.opcode,renameVariables(e.operands[0],binding,globals),e.attributes());
+	}
+
+	private static Code renameVariables(Code.Binary e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.Binary(e.type,e.opcode,
+				renameVariables(e.operands[0], binding, globals),
+				renameVariables(e.operands[1], binding, globals),
+				e.attributes());
+	}
+
+	private static Code renameVariables(Code.Nary e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		Code[] operands = new Code[e.operands.length];
+		for(int i=0;i!=operands.length;++i) {
+			operands[i] = renameVariables(e.operands[i],binding,globals);
+		}
+		return Code.Nary(e.type,e.opcode,operands,e.attributes());
+	}
+
+	private static Code renameVariables(Code.FunCall e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.FunCall(e.type,
+				renameVariables(e.operands[0], binding, globals), e.nid,
+				e.binding, e.attributes());
+	}
+
+	private static Code renameVariables(Code.Quantifier e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		binding = new HashMap<Integer, Integer>(binding);
+		Pair<SemanticType,Integer>[] variables = new Pair[e.types.length];
+		int freeVariable = findLargest(globals) + 1;
+		for (int i = 0; i != variables.length; ++i) {
+			Pair<SemanticType,Integer> p = e.types[i];
+			int var = p.second();
+			int index = freeVariable++;
+			binding.put(var, index);
+			globals.add(index);
+			variables[i] = new Pair<SemanticType,Integer>(p.first(),
+					index);
+		}
+		Code operand = renameVariables(e.operands[0], binding, globals);
+		return Code.Quantifier(e.type, e.opcode, operand, variables,
+				e.attributes());
+	}
+
+	private static Code renameVariables(Code.Cast e, HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.Cast(e.type, renameVariables(e.operands[0], binding, globals), e.target, e.attributes());
+	}
+
+	private static Code renameVariables(Code.Is e, HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.Is(e.type, renameVariables(e.operands[0], binding, globals), e.test, e.attributes());
+	}
+
+	private static Code renameVariables(Code.Load e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.Load(e.type,
+				renameVariables(e.operands[0], binding, globals), e.index,
+				e.attributes());
+	}
+
+	private static Code renameVariables(Code.IndexOf e,
+			HashMap<Integer, Integer> binding, HashSet<Integer> globals) {
+		return Code.IndexOf(e.type,
+				renameVariables(e.operands[0], binding, globals),
+				renameVariables(e.operands[1], binding, globals),
+				e.attributes());
+	}
+	
+	private static int findLargest(Set<Integer> vars) {
+		int max = -1;
+		for(int i : vars) {
+			max = Math.max(max,i);
+		}
+		return max;
+	}
+
+	public static Code skolemiseExistentials(Code e) {
+		return skolemiseExistentials(e, new HashMap(), new ArrayList());
+	}
+
+	private static Code skolemiseExistentials(Code e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		if(e instanceof Code.Constant) {
+			return e;
+		} else if(e instanceof Code.Variable) {
+			return skolemiseExistentials((Code.Variable)e,binding,captured);
+		} else if(e instanceof Code.Unary) {
+			return skolemiseExistentials((Code.Unary)e,binding,captured);
+		} else if(e instanceof Code.Binary) {
+			return skolemiseExistentials((Code.Binary)e,binding,captured);
+		} else if(e instanceof Code.Nary) {
+			return skolemiseExistentials((Code.Nary)e,binding,captured);
+		} else if(e instanceof Code.Quantifier) {
+			return skolemiseExistentials((Code.Quantifier)e,binding,captured);
+		} else if(e instanceof Code.FunCall) {
+			return skolemiseExistentials((Code.FunCall)e,binding,captured);
+		} else if(e instanceof Code.Load) {
+			return skolemiseExistentials((Code.Load)e,binding,captured);
+		} else if(e instanceof Code.IndexOf) {
+			return skolemiseExistentials((Code.IndexOf)e,binding,captured);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code skolemiseExistentials(Code.Variable e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code sub = binding.get(e.index);
+		if(sub != null) {
+			return sub;
+		} else {
+			return e;
+		}
+	}
+
+	private static Code skolemiseExistentials(Code.Unary e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		return Code.Unary(e.type, e.opcode,
+				skolemiseExistentials(e.operands[0], binding, captured),
+				e.attributes());
+	}
+
+	private static Code skolemiseExistentials(Code.Binary e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code lhs = skolemiseExistentials(e.operands[0], binding, captured);
+		Code rhs = skolemiseExistentials(e.operands[1], binding, captured);
+		return Code.Binary(e.type, e.opcode, lhs, rhs, e.attributes());
+	}
+
+	private static Code skolemiseExistentials(Code.Nary e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code[] operands = new Code[e.operands.length];
+		for (int i = 0; i != operands.length; ++i) {
+			operands[i] = skolemiseExistentials(e.operands[i], binding,
+					captured);
+		}
+		return Code.Nary(e.type, e.opcode, operands, e.attributes());
+	}
+
+	private static Code skolemiseExistentials(Code.Quantifier e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		if(e.opcode == Code.Op.FORALL) {
+			captured = new ArrayList<Code.Variable>(captured);
+			Pair<SemanticType,Integer>[] types = new Pair[e.types.length];
+			for (int i = 0; i != types.length; ++i) {
+				Pair<SemanticType,Integer> p = e.types[i];
+				captured.add(Code.Variable(p.first(), new Code[0], p.second()));
+				types[i] = p;
+			}
+			Code operand = skolemiseExistentials(e.operands[0], binding,
+					captured);
+			return Code.Quantifier(e.type, e.opcode, operand, types,
+					e.attributes());
+		} else {
+			binding = new HashMap<Integer,Code>(binding);
+			for(Pair<SemanticType,Integer> p : e.types) {
+				skolemiseVariable(p.first(),p.second(),binding,captured);
+			}
+			return skolemiseExistentials(e.operands[0],binding,captured);
+		}
+	}
+
+	private static void skolemiseVariable(SemanticType type, Integer var,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+
+		if (captured.isEmpty()) {
+			// easy case
+			binding.put(var, Code.Variable(type, new Code[0], var));
+		} else {
+			Code[] operands = new Code[captured.size()];
+			for (int i = 0; i != operands.length; ++i) {
+				Code.Variable c = captured.get(i);
+				operands[i] = c;
+			}
+			Code skolem = Code.Variable(type, operands, var);
+			binding.put(var, skolem);
+		}
+	}
+
+	private static Code skolemiseExistentials(Code.FunCall e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code operand = skolemiseExistentials(e.operands[0], binding, captured);
+		return Code.FunCall(e.type, operand, e.nid, e.binding, e.attributes());
+	}
+
+	private static Code skolemiseExistentials(Code.Load e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code operand = skolemiseExistentials(e.operands[0], binding, captured);
+		return Code.Load(e.type, operand, e.index, e.attributes());
+	}
+
+	private static Code skolemiseExistentials(Code.IndexOf e,
+			HashMap<Integer, Code> binding, ArrayList<Code.Variable> captured) {
+		Code operand1 = skolemiseExistentials(e.operands[0], binding, captured);
+		Code operand2 = skolemiseExistentials(e.operands[1], binding, captured);
+		return Code.IndexOf(e.type, operand1, operand2, e.attributes());
+	}
+
+	public static Code extractUniversals(Code e) {
+		ArrayList<Pair<SemanticType,Integer>> environment = new ArrayList();
+		e = extractUniversals(e, environment);
+		if (environment.size() != 0) {
+			Pair<SemanticType,Integer>[] vars = environment
+					.toArray(new Pair[environment.size()]);
+			// FIXME: should really include attributes here
+			return Code.Quantifier(SemanticType.Bool,Code.Op.FORALL,e,vars);
+		} else {
+			return e;
+		}
+	}
+
+	private static Code extractUniversals(Code e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		if(e instanceof Code.Constant) {
+			return e;
+		} else if(e instanceof Code.Variable) {
+			return extractUniversals((Code.Variable)e,environment);
+		} else if(e instanceof Code.Unary) {
+			return extractUniversals((Code.Unary)e,environment);
+		} else if(e instanceof Code.Binary) {
+			return extractUniversals((Code.Binary)e,environment);
+		} else if(e instanceof Code.Nary) {
+			return extractUniversals((Code.Nary)e,environment);
+		} else if(e instanceof Code.Quantifier) {
+			return extractUniversals((Code.Quantifier)e,environment);
+		} else if(e instanceof Code.FunCall) {
+			return extractUniversals((Code.FunCall)e,environment);
+		} else if(e instanceof Code.Load) {
+			return extractUniversals((Code.Load)e,environment);
+		} else if(e instanceof Code.IndexOf) {
+			return extractUniversals((Code.IndexOf)e,environment);
+		}
+		throw new IllegalArgumentException("unknown expression encountered: "
+				+ e);
+	}
+
+	private static Code extractUniversals(Code.Variable e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		return e;
+	}
+
+	private static Code extractUniversals(Code.Unary e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		return Code.Unary(e.type, e.opcode,
+				extractUniversals(e.operands[0], environment), e.attributes());
+	}
+
+	private static Code extractUniversals(Code.Binary e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		Code lhs = extractUniversals(e.operands[0],environment);
+		Code rhs = extractUniversals(e.operands[1],environment);
+		return Code.Binary(e.type,e.opcode,lhs,rhs,e.attributes());
+	}
+
+	private static Code extractUniversals(Code.Nary e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		Code[] operands = new Code[e.operands.length];
+		for (int i = 0; i != operands.length; ++i) {
+			operands[i] = extractUniversals(e.operands[i], environment);
+		}
+		return Code.Nary(e.type,e.opcode,operands,e.attributes());
+	}
+
+	private static Code extractUniversals(Code.FunCall e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		return Code.FunCall(e.type,
+				extractUniversals(e.operands[0], environment), e.nid,
+				e.binding, e.attributes());
+	}
+
+	private static Code extractUniversals(Code.Load e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		return Code.Load(e.type, extractUniversals(e.operands[0], environment),
+				e.index, e.attributes());
+	}
+
+	private static Code extractUniversals(Code.IndexOf e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+		return Code.IndexOf(e.type, extractUniversals(e.operands[0], environment),
+				extractUniversals(e.operands[1], environment), e.attributes());
+	}
+	
+	private static Code extractUniversals(Code.Quantifier e,
+			ArrayList<Pair<SemanticType, Integer>> environment) {
+
+		if(e.opcode == Code.Op.FORALL) {
+			for(Pair<SemanticType, Integer> p : e.types) {
+				environment.add(p);
+			}
+		} else {
+			// existentials should all be eliminated by skolemiseExistentials
+			throw new IllegalArgumentException(
+					"extenstential encountered: " + e);
+		}
+
+		return extractUniversals(e.operands[0],environment);
+	}
+}
diff --git a/modules/wycs/src/wycs/core/SemanticType.java b/modules/wycs/src/wycs/core/SemanticType.java
new file mode 100755
index 0000000000..5fed6c26d9
--- /dev/null
+++ b/modules/wycs/src/wycs/core/SemanticType.java
@@ -0,0 +1,895 @@
+package wycs.core;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.Map;
+
+import wyautl.core.*;
+import wyrw.core.*;
+import wyrw.util.*;
+import wycc.lang.NameID;
+import static wycs.core.Types.*;
+
+public abstract class SemanticType {
+
+	// =============================================================
+	// Public Interface
+	// =============================================================
+
+	public static final Any Any = new Any();
+	public static final Void Void = new Void();
+	public static final Null Null = new Null();
+	public static final Bool Bool = new Bool();
+	public static final Int Int = new Int();
+	public static final Real Real = new Real();
+	public static final String String = new String();
+	public static final SemanticType IntOrReal = Or(Int,Real);
+	public static final Array ArrayAny = new Array(Any);
+	
+	public static Var Var(java.lang.String name) {
+		return new Var(name);
+	}
+
+	public static Nominal Nominal(NameID name) {
+		return new Nominal(name);
+	}
+	
+	public static Tuple Tuple(SemanticType... elements) {
+		for (SemanticType t : elements) {
+			if (t instanceof SemanticType.Void) {
+				throw new IllegalArgumentException(
+						"Tuple type cannot contain void element");
+			}
+		}
+		return new Tuple(elements);
+	}
+
+	public static Tuple Tuple(java.util.Collection<SemanticType> elements) {
+		SemanticType[] es = new SemanticType[elements.size()];
+		int i = 0;
+		for (SemanticType t : elements) {
+			if (t instanceof SemanticType.Void) {
+				throw new IllegalArgumentException(
+						"Tuple type cannot contain void element");
+			}
+			es[i++] = t;
+		}
+		return new Tuple(es);
+	}
+
+	public static Array Array(SemanticType element) {
+		return new Array(element);
+	}
+
+	public static SemanticType Not(SemanticType element) {
+		// FIXME: this could be more efficient
+		return construct(new Not(element).automaton);
+	}
+
+	public static SemanticType And(SemanticType... elements) {
+		// FIXME: this could be more efficient
+		return construct(new And(elements).automaton);
+	}
+
+	public static SemanticType And(java.util.Collection<SemanticType> elements) {
+		SemanticType[] es = new SemanticType[elements.size()];
+		int i = 0;
+		for (SemanticType t : elements) {
+			es[i++] = t;
+		}
+		// FIXME: this could be more efficient
+		return construct(new And(es).automaton);
+	}
+
+	public static SemanticType Or(SemanticType... elements) {
+		// FIXME: this could be more efficient
+		return construct(new Or(elements).automaton);
+	}
+
+	public static SemanticType Or(java.util.Collection<SemanticType> elements) {
+		SemanticType[] es = new SemanticType[elements.size()];
+		int i = 0;
+		for (SemanticType t : elements) {
+			es[i++] = t;
+		}
+		// FIXME: this could be more efficient
+		return construct(new Or(es).automaton);
+	}
+
+	public static Function Function(SemanticType from, SemanticType to,
+			SemanticType... generics) {
+		return new Function(from, to, generics);
+	}
+
+	// ==================================================================
+	// Atoms
+	// ==================================================================
+
+	public static abstract class Atom extends SemanticType {
+		public Atom(int kind) {
+			if (kind != K_AnyT && kind != K_VoidT && kind != K_NullT
+					&& kind != K_BoolT && kind != K_StringT && kind != K_IntT
+					&& kind != K_RealT) {
+				throw new IllegalArgumentException("Invalid atom kind");
+			}
+			int root = automaton.add(new Automaton.Term(kind));
+			automaton.setRoot(0, root);
+		}
+
+		@Override
+		public SemanticType substitute(Map<java.lang.String, SemanticType> binding) {
+			// atom can never have anything substituted.
+			return this;
+		}
+	}
+
+	public static final class Any extends Atom {
+		private Any() {
+			super(K_AnyT);
+		}
+	}
+
+	public static final class Void extends Atom {
+		private Void() {
+			super(K_VoidT);
+		}
+	}
+
+	public static final class Null extends Atom {
+		private Null() {
+			super(K_NullT);
+		}
+	}
+
+	public static final class Bool extends Atom {
+		private Bool() {
+			super(K_BoolT);
+		}
+	}
+
+	public static final class Int extends Atom {
+		private Int() {
+			super(K_IntT);
+		}
+	}
+
+	public static final class Real extends Atom {
+		private Real() {
+			super(K_RealT);
+		}
+	}
+
+	public static final class String extends Atom {
+		private String() {
+			super(K_StringT);
+		}
+	}
+
+	public static class Var extends SemanticType {
+		public Var(java.lang.String name) {
+			int root = Types.VarT(automaton, name);
+			automaton.setRoot(0,root);
+		}
+		private Var(Automaton automaton) {
+			super(automaton);
+			int kind = automaton.get(automaton.getRoot(0)).kind;
+			if (kind != K_VarT) {
+				throw new IllegalArgumentException("Invalid variable kind");
+			}
+		}
+		public java.lang.String name() {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);
+			Automaton.Strung str = (Automaton.Strung) automaton.get(term.contents);
+			return str.value;
+		}
+	}
+
+	public static class Nominal extends SemanticType {
+		public Nominal(NameID nid) {
+			int root = Types.NominalT(automaton, nid.toString());
+			automaton.setRoot(0,root);
+		}
+		private Nominal(Automaton automaton) {
+			super(automaton);
+			int kind = automaton.get(automaton.getRoot(0)).kind;
+			if (kind != K_NominalT) {
+				throw new IllegalArgumentException("Invalid variable kind");
+			}
+		}
+		public NameID name() {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);
+			Automaton.Strung str = (Automaton.Strung) automaton.get(term.contents);
+			return NameID.fromString(str.value);
+		}
+	}
+	
+	// ==================================================================
+	// Unary Terms
+	// ==================================================================
+
+	public static class Not extends SemanticType {
+		public Not(SemanticType element) {
+			Automaton element_automaton = element.automaton;
+			int elementRoot = automaton.addAll(element_automaton.getRoot(0),
+					element_automaton);
+			int root = automaton.add(new Automaton.Term(K_NotT, elementRoot));
+			automaton.setRoot(0,root);
+		}
+		private Not(Automaton automaton) {
+			super(automaton);
+			int kind = automaton.get(automaton.getRoot(0)).kind;
+			if (kind != K_NotT) {
+				throw new IllegalArgumentException("Invalid unary kind");
+			}
+		}
+		public SemanticType element() {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);
+			return extract(term.contents);
+		}
+	}
+
+	public final static class Array extends SemanticType {
+		
+		private Array(SemanticType element) {			
+			Automaton element_automaton = element.automaton;
+			int child = automaton.addAll(element_automaton.getRoot(0),
+					element_automaton);
+			int root = automaton.add(new Automaton.Term(K_ArrayT, child));
+			automaton.setRoot(0,root);
+		}
+
+		private Array(Automaton automaton) {
+			super(automaton);
+			int kind = automaton.get(automaton.getRoot(0)).kind;
+			if (kind != K_ArrayT) {
+				throw new IllegalArgumentException("Invalid set kind");
+			}
+		}
+
+		public SemanticType element() {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);			
+			return extract(term.contents);
+		}
+	}
+
+
+	// ==================================================================
+	// Nary Terms
+	// ==================================================================
+
+	public static abstract class Nary extends SemanticType {
+		private Nary(Automaton automaton) {
+			super(automaton);
+			int kind = automaton.get(automaton.getRoot(0)).kind;
+			if (kind != K_AndT && kind != K_OrT && kind != K_TupleT
+					&& kind != K_FunctionT) {
+				throw new IllegalArgumentException("Invalid nary kind");
+			}
+		}
+		private Nary(int kind, int compound, SemanticType... elements) {
+			int[] children = new int[elements.length];
+			for (int i = 0; i != children.length; ++i) {
+				SemanticType element = elements[i];
+				Automaton element_automaton = element.automaton;
+				int child = automaton.addAll(element_automaton.getRoot(0),
+						element_automaton);
+				children[i] = child;
+			}
+			int compoundRoot;
+			switch (compound) {
+			case wyrl.core.Types.K_Set:
+				compoundRoot = automaton.add(new Automaton.Set(children));
+				break;
+			case wyrl.core.Types.K_Bag:
+				compoundRoot = automaton.add(new Automaton.Bag(children));
+				break;
+			case wyrl.core.Types.K_List:
+				compoundRoot = automaton.add(new Automaton.List(children));
+				break;
+			default:
+				throw new IllegalArgumentException(
+						"invalid compound type in Nary constructor");
+			}
+
+			int root = automaton.add(new Automaton.Term(kind, compoundRoot));
+			automaton.setRoot(0,root);
+		}
+
+		public SemanticType element(int index) {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);
+			Automaton.Collection collection = (Automaton.Collection) automaton
+					.get(term.contents);
+			return extract(collection.get(index));
+		}
+
+		public SemanticType[] elements() {
+			int root = automaton.getRoot(0);
+			Automaton.Term term = (Automaton.Term) automaton.get(root);
+			Automaton.Collection collection = (Automaton.Collection) automaton
+					.get(term.contents);
+			SemanticType[] elements = new SemanticType[collection.size()];
+			for (int i = 0; i != elements.length; ++i) {
+				elements[i] = extract(collection.get(i));
+			}
+			return elements;
+		}
+	}
+
+	public static final class And extends Nary {
+		private And(SemanticType... bounds) {
+			super(K_AndT,wyrl.core.Types.K_Set,bounds);
+		}
+
+		private And(Automaton automaton) {
+			super(automaton);
+		}
+	}
+
+	public static class Or extends Nary {
+		private Or(SemanticType... bounds) {
+			super(K_OrT,wyrl.core.Types.K_Set,bounds);
+		}
+
+		private Or(Automaton automaton) {
+			super(automaton);
+		}
+	}
+
+	public static class OrTuple extends Or implements EffectiveTuple {
+		private OrTuple(SemanticType... bounds) {
+			super(bounds);
+		}
+
+		private OrTuple(Automaton automaton) {
+			super(automaton);
+		}
+
+		public int size() {
+			int size = Integer.MAX_VALUE;
+			SemanticType[] elements = elements();
+			for(int i=0;i!=elements.length;++i) {
+				SemanticType.Tuple tt = (SemanticType.Tuple) elements[i];
+				size = Math.min(size, tt.elements().length);
+			}
+			return size;
+		}
+
+		public SemanticType tupleElement(int index) {
+			SemanticType[] elements = elements();
+			SemanticType[] bounds = new SemanticType[elements.length];
+			for (int i = 0; i != elements.length; ++i) {
+				SemanticType.Tuple tt = (SemanticType.Tuple) elements[i];
+				bounds[i] = tt.element(i);
+			}
+			return SemanticType.Or(bounds);
+		}
+
+		public SemanticType.Tuple tupleType() {
+			SemanticType[] elements = elements();
+			SemanticType[] bounds = new SemanticType[size()];
+			SemanticType.Tuple result = null;
+			for (int i = 0; i != elements.length; ++i) {
+				SemanticType.Tuple tt = (SemanticType.Tuple) elements[i];
+				for(int j=0;j!=bounds.length;++j) {
+					SemanticType j_b1 = bounds[i];
+					SemanticType j_b2 = tt.element(j);
+					if(j_b1 == null) {
+						bounds[j] = tt.element(j);
+					} else {
+						bounds[j] = SemanticType.Or(j_b1,j_b2);
+					}
+					result = SemanticType.Tuple(bounds);
+				}
+			}
+			return result;
+		}
+	}
+
+	// ==================================================================
+	// Compounds
+	// ==================================================================
+
+	/**
+	 * An effective tuple is either a tuple, or a union of tuples.
+	 *
+	 * @author djp
+	 *
+	 */
+	public interface EffectiveTuple {
+
+		/**
+		 * Returns the number of direct addressable elements. That is, the
+		 * smallest number of elements in any tuples.
+		 *
+		 * @return
+		 */
+		public int size();
+
+		/**
+		 * Returns the effective type of the element at the given index.
+		 *
+		 * @param index
+		 * @return
+		 */
+		public SemanticType tupleElement(int index);
+
+		/**
+		 * Returns the effective tuple type.
+		 * @return
+		 */
+		public SemanticType.Tuple tupleType();
+	}
+
+	public final static class Tuple extends Nary implements EffectiveTuple {
+		private Tuple(SemanticType... elements) {
+			super(K_TupleT, wyrl.core.Types.K_List, elements);
+		}
+
+		private Tuple(Automaton automaton) {
+			super(automaton);
+		}
+
+		public int size() {
+			return elements().length;
+		}
+
+		public SemanticType tupleElement(int index) {
+			return element(index);
+		}
+
+		public SemanticType.Tuple tupleType() {
+			return this;
+		}
+	}
+
+	public final static class Function extends Nary {
+		private Function(SemanticType from, SemanticType to, SemanticType... generics) {
+			super(K_FunctionT, wyrl.core.Types.K_List, append(from,to,generics));
+		}
+
+		private Function(Automaton automaton) {
+			super(automaton);
+		}
+
+		public SemanticType from() {
+			return element(0);
+		}
+
+		public SemanticType to() {
+			return element(1);
+		}
+
+		public SemanticType[] generics() {
+			SemanticType[] elements = elements();
+			SemanticType[] generics = new SemanticType[elements.length-2];
+			for (int i = 2; i != elements.length; ++i) {
+				generics[i - 2] = elements[i];
+			}
+			return generics;
+		}
+	}
+
+	// =============================================================
+	// Private Implementation
+	// =============================================================
+
+	protected final Automaton automaton;
+
+	private SemanticType() {
+		this.automaton = new Automaton();
+	}
+
+	private SemanticType(Automaton automaton) {
+		this.automaton = automaton;
+	}
+
+	public Automaton automaton() {
+		return automaton;
+	}
+
+	public int hashCode() {
+		return automaton.hashCode();
+	}
+
+	public boolean equals(Object o) {
+		if (o instanceof SemanticType) {
+			SemanticType r = (SemanticType) o;
+			return automaton.equals(r.automaton);
+		}
+		return false;
+	}
+
+	/**
+	 * Substitute type variables for concrete types according to a given
+	 * binding.
+	 *
+	 * @param binding
+	 *            --- a map from type variable's to concrete types.
+	 * @return
+	 */
+	public SemanticType substitute(Map<java.lang.String,SemanticType> binding) {
+		// First, check whether a matching type variable exists.
+		boolean matched = false;
+		for(int i=0;i!=automaton.nStates();++i) {
+			Automaton.State s = (Automaton.State) automaton.get(i);
+			if(s != null && s.kind == Types.K_VarT) {
+				Automaton.Term t = (Automaton.Term) s;
+				Automaton.Strung str = (Automaton.Strung) automaton.get(t.contents);
+				if(binding.containsKey(str.value)) {
+					matched=true;
+					break;
+				}
+			}
+		}
+
+		if(!matched) {
+			return this;
+		} else {
+			// Second, perform the substitution
+			Automaton nAutomaton = new Automaton(automaton);
+
+			int[] keys = new int[binding.size()];
+			int[] types = new int[binding.size()];
+
+			int i=0;
+			for(Map.Entry<java.lang.String, SemanticType> e : binding.entrySet()) {
+				java.lang.String key = e.getKey();
+				SemanticType type = e.getValue();
+				keys[i] = Types.VarT(nAutomaton, key);
+				types[i++] = nAutomaton.addAll(type.automaton.getRoot(0), type.automaton);
+			}
+
+			int root = nAutomaton.getRoot(0);
+			int[] mapping = new int[nAutomaton.nStates()];
+			for(i=0;i!=mapping.length;++i) {
+				mapping[i] = i;
+			}
+			for(i=0;i!=keys.length;++i) {
+				mapping[keys[i]] = types[i];
+			}
+			nAutomaton.setRoot(0, nAutomaton.substitute(root, mapping));
+			return construct(nAutomaton);
+		}
+	}
+
+	public java.lang.String toString() {
+		int root = automaton.getRoot(0);
+		int[] headers = new int[automaton.nStates()];
+		Automata.traverse(automaton,root,headers);
+		return toString(root,headers);
+	}
+
+	public java.lang.String toString(int root, int[] headers) {
+		java.lang.String body = "";
+		int header = 0;
+		if(root >= 0) {
+			header = headers[root];
+			if(header == 3) {
+				// FIXME: still a bug here in the case of a header whose
+				// recursive reference is not reached (i.e. because it's blocked
+				// by a Nominal type).
+				body = ("$" + root + "<");
+				headers[root] = -1;
+			} else if(header < 0) {
+				return "$" + root;
+			}
+		}
+
+		Automaton.Term term = (Automaton.Term) automaton.get(root);
+		switch(term.kind) {
+			case K_VoidT:
+				body += "void";
+				break;
+			case K_AnyT:
+				body += "any";
+				break;
+			case K_NullT:
+				body += "null";
+				break;
+			case K_BoolT:
+				body += "bool";
+				break;
+			case K_IntT:
+				body += "int";
+				break;
+			case K_RealT:
+				body += "real";
+				break;
+			case K_StringT:
+				body += "string";
+				break;
+			case K_VarT: {
+				Automaton.Strung s = (Automaton.Strung) automaton.get(term.contents);
+				body += s.value;
+				break;
+			}
+			case K_NominalT: {
+				Automaton.Strung s = (Automaton.Strung) automaton.get(term.contents);
+				body += s.value;
+				break;
+			}
+			case K_NotT:
+				body += "!" + toString(term.contents,headers);
+				break;
+			case K_OrT : {
+				Automaton.Set set = (Automaton.Set) automaton
+						.get(term.contents);
+				for (int i = 0; i != set.size(); ++i) {
+					if (i != 0) {
+						body += "|";
+					}
+					body += toString(set.get(i), headers);
+				}
+				break;
+			}
+			case K_AndT : {
+				Automaton.Set set = (Automaton.Set) automaton
+						.get(term.contents);
+				for (int i = 0; i != set.size(); ++i) {
+					if (i != 0) {
+						body += "&";
+					}
+					body += toString(set.get(i), headers);
+				}
+				break;
+			}
+			case K_ArrayT:
+				body += "[" + toString(term.contents,headers) + "]";				
+				break;
+			case K_TupleT: {
+				Automaton.List elements = (Automaton.List) automaton.get(term.contents);
+				java.lang.String tmp = "";
+				for(int i=0;i!=elements.size();++i) {
+					if(i != 0) {
+						tmp += ",";
+					}
+					tmp += toString(elements.get(i),headers);
+				}
+				body += "(" + tmp + ")";
+				break;
+			}
+			case K_FunctionT: {
+				Automaton.List elements = (Automaton.List) automaton.get(term.contents);
+				java.lang.String tmp = "";
+				if(elements.size() > 2) {
+					for(int i=2;i<elements.size();++i) {
+						if(i != 2) {
+							tmp += ",";
+						}
+						tmp += toString(elements.get(i),headers);
+					}
+					body += "<" + tmp + ">";
+				}
+				body += toString(elements.get(0), headers) + "=>"
+					+ toString(elements.get(1), headers);
+				break;
+			}
+			default:
+				throw new IllegalArgumentException("unknown type encountered (" + SCHEMA.get(term.kind).name + ")");
+		}
+
+		if(header > 1) {
+			body += ">";
+		}
+
+		return body;
+	}
+
+	/**
+	 * Extract the type described by a given node in the automaton. This is
+	 * primarily used to extract subcomponents of a type (e.g. the element of a
+	 * reference type).
+	 *
+	 * @param child
+	 *            --- child node to be extracted.
+	 * @return
+	 */
+	protected SemanticType extract(int child) {
+		Automaton automaton = new Automaton();
+		int root = automaton.addAll(child, this.automaton);
+		automaton.setRoot(0,root);
+		return construct(automaton);
+	}
+
+	/**
+	 * Construct a given type from an automaton. This is primarily used to
+	 * reconstruct a type after expansion.
+	 *
+	 * @param automaton
+	 * @return
+	 */
+	public static SemanticType construct(Automaton automaton) {
+		// First, we canonicalise the automaton
+		Reductions.minimiseAndReduce(automaton, 5000, Types.SCHEMA, Types.reductions);
+		automaton.canonicalise();
+
+		// Second, construct the object representing the type
+		int root = automaton.getRoot(0);
+		Automaton.State state = automaton.get(root);
+		switch(state.kind) {
+		// atoms
+		case K_VoidT:
+			return Void;
+		case K_AnyT:
+			return Any;
+		case K_NullT:
+			return Null;
+		case K_BoolT:
+			return Bool;
+		case K_IntT:
+			return Int;
+		case K_RealT:
+			return Real;
+		case K_VarT:
+			return new SemanticType.Var(automaton);
+		case K_NominalT:
+			return new SemanticType.Nominal(automaton);
+		case K_StringT:
+			return String;
+		// connectives
+		case K_NotT:
+			return new SemanticType.Not(automaton);
+		case K_AndT:
+			return new SemanticType.And(automaton);
+		case K_OrT: {
+			SemanticType.Or t = new SemanticType.Or(automaton);
+			if(isOrTuple(t)) {
+				return new SemanticType.OrTuple(automaton);
+			} else {
+				return t;
+			}
+		}
+		// compounds
+		case K_ArrayT:
+			return new SemanticType.Array(automaton);
+		case K_TupleT:
+			return new SemanticType.Tuple(automaton);
+		case K_FunctionT:
+			return new SemanticType.Function(automaton);
+		default:
+			int kind = state.kind;
+			if(kind < 0) {
+				kind = -kind + Automaton.K_FREE;
+			}
+			throw new IllegalArgumentException("Unknown kind encountered - " + SCHEMA.get(kind).name);
+		}
+	}
+
+	/**
+	 * Check whether or not this is a union of tuples
+	 *
+	 * @param type
+	 * @return
+	 */
+	private static boolean isOrTuple(SemanticType.Or type) {
+		SemanticType[] elements = type.elements();
+		for (int i = 0; i != elements.length; ++i) {
+			if (!(elements[i] instanceof SemanticType.Tuple)) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * Check that t1 :> t2 or, equivalently, that t2 is a subtype of t1. A type
+	 * <code>t1</code> is said to be a subtype of another type <code>t2</code>
+	 * iff the semantic set described by <code>t1</code> contains that described
+	 * by <code>t2</code>.
+	 *
+	 * @param t1
+	 *            --- Semantic type to test whether contains <code>t2</code>.
+	 * @param t2
+	 *            --- Semantic type to test whether contained by <code>t1</code>.
+	 */
+	public static boolean isSubtype(SemanticType t1, SemanticType t2) {
+		SemanticType result = SemanticType.And(SemanticType.Not(t1),t2);
+//		try {
+//			new PrettyAutomataWriter(System.err, SCHEMA, "And",
+//					"Or").write(result.automaton);
+//			System.out.println();
+//		} catch(IOException e) {}	
+		boolean r = result.equals(SemanticType.Void);
+//		System.out.println("CHECKING SUBTYPE: " + t1 + " :> " + t2 + " : " + r);
+//		try {
+//			new PrettyAutomataWriter(System.err, SCHEMA, "And",
+//					"Or").write(result.automaton);
+//			System.out.println();
+//		} catch(IOException e) {}
+		return r;
+	}
+
+	/**
+	 * Attempt to bind a generic type against a concrete type. This will fail if
+	 * no possible binding exists, otherwise it produces a binding from
+	 * variables in the generic type to components from the concrete type.
+	 * Examples include:
+	 * <ul>
+	 * <li>Binding <code>T</code> against <code>int</code> produces the binding
+	 * <code>{T=>int}</code>.</li>
+	 * <li>Binding <code>(T,int)</code> against <code>(int,int)</code> produces
+	 * the binding <code>{T=>int}</code>.</li>
+	 * <li>Binding <code>(S,T)</code> against <code>(int,bool)</code> produces
+	 * the binding <code>{S=>int,T=>bool}</code>.</li>
+	 * <li>Binding <code>(T,T)</code> against <code>(int,bool)</code> fails
+	 * produces the binding <code>{T=>(int|bool)}</code>.</li>
+	 * </ul>
+	 *
+	 * <b>NOTE:</b> this function is not yet fully implemented, and will not
+	 * always produce a binding when one exists.
+	 *
+	 * @param generic
+	 *            --- the generic type whose variables we are trying to bind.
+	 * @param concrete
+	 *            --- the concrete type whose subcomponents will be matched
+	 *            against variables contained in the generic type.
+	 * @param binding
+	 *            --- a map into which the binding from variables names in
+	 *            generic to subcomponents of concrete will be placed.
+	 * @return --- true if a binding was found, or false otherwise.
+	 */
+	public static boolean bind(SemanticType generic, SemanticType concrete,
+			java.util.Map<java.lang.String, SemanticType> binding) {
+
+		// FIXME: this function is broken for recursive types!
+
+		// FIXME: this function should also be moved into SemanticType
+
+		// Whilst this function is cool, it's basically very difficult to make
+		// it work well. I wonder whether or not there's a better way to
+		// implement this?
+
+		if(generic.equals(concrete)) {
+			// this is a match, so we don't need to do anything.
+			return true;
+		} else if(generic instanceof SemanticType.Var) {
+			SemanticType.Var var = (SemanticType.Var) generic;
+			SemanticType b = binding.get(var.name());
+			if(b != null && !b.equals(concrete)) {
+				// this indicates we've already bound this argument to something
+				// different.
+				return false;
+			}
+			binding.put(var.name(), concrete);
+			return true;
+		} else if (generic instanceof SemanticType.Array
+				&& concrete instanceof SemanticType.Array) {
+			SemanticType.Array pt = (SemanticType.Array) generic;
+			SemanticType.Array at = (SemanticType.Array) concrete;
+			return bind(pt.element(),at.element(),binding);
+		} else if (generic instanceof SemanticType.Tuple
+				&& concrete instanceof SemanticType.Tuple) {
+			SemanticType.Tuple pt = (SemanticType.Tuple) generic;
+			SemanticType.Tuple at = (SemanticType.Tuple) concrete;
+			SemanticType[] pt_elements = pt.elements();
+			SemanticType[] at_elements = at.elements();
+			if(pt_elements.length != at_elements.length) {
+				return false;
+			} else {
+				for(int i=0;i!=pt_elements.length;++i) {
+					if(!bind(pt_elements[i],at_elements[i],binding)) {
+						return false;
+					}
+				}
+				return true;
+			}
+		} else {
+			// basically assume failure [though we could do better, e.g. for
+			// unions, etc].
+			return false;
+		}
+	}
+
+	private static SemanticType[] append(SemanticType t1, SemanticType t2, SemanticType... ts) {
+		SemanticType[] r = new SemanticType[ts.length+2];
+		r[0] = t1;
+		r[1] = t2;
+		System.arraycopy(ts, 0, r, 2, ts.length);
+		return r;
+	}	
+}
diff --git a/modules/wycs/src/wycs/core/Types.wyrl b/modules/wycs/src/wycs/core/Types.wyrl
new file mode 100755
index 0000000000..4cb23f1dd2
--- /dev/null
+++ b/modules/wycs/src/wycs/core/Types.wyrl
@@ -0,0 +1,28 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.core
+
+include "../solver/Types.wyrl"
diff --git a/modules/wycs/src/wycs/core/Value.java b/modules/wycs/src/wycs/core/Value.java
new file mode 100755
index 0000000000..5046dd31d3
--- /dev/null
+++ b/modules/wycs/src/wycs/core/Value.java
@@ -0,0 +1,454 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.core;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.*;
+
+import wycc.util.Pair;
+import wyautl.util.BigRational;
+
+public abstract class Value implements Comparable<Value> {
+
+	public abstract SemanticType type();
+
+	public static final Null Null = new Null();
+
+	public static Bool Bool(boolean value) {
+		return get(new Bool(value));
+	}
+
+	public static Decimal Decimal(BigDecimal value) {
+		return get(new Decimal(value));
+	}
+
+	public static Integer Integer(BigInteger value) {
+		return get(new Integer(value));
+	}
+
+	public static String String(java.lang.String string) {
+		return get(new String(string));
+	}
+
+	public static Array Array(Collection<Value> values) {
+		return get(new Array(values));
+	}
+
+	public static Tuple Tuple(Collection<Value> values) {
+		return get(new Tuple(values));
+	}
+
+	public static final class Null extends Value {
+		private Null() {
+		}
+		public int hashCode() {
+			return 0;
+		}
+		public boolean equals(Object o) {
+			return o instanceof Null;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Bool) {
+				return 1;
+			} else {
+				return -1;
+			}
+		}
+		public java.lang.String toString() {
+			return "null";
+		}
+
+		public SemanticType type() {
+			return SemanticType.Null;
+		}
+	}
+
+	public static final class Bool extends Value {
+		public final boolean value;
+		private Bool(boolean value) {
+			this.value = value;
+		}
+		public int hashCode() {
+			return value ? 1 : 0;
+		}
+		public boolean equals(Object o) {
+			if(o instanceof Bool) {
+				Bool i = (Bool) o;
+				return value == i.value;
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Bool) {
+				Bool b = (Bool) v;
+				if(value == b.value) {
+					return 0;
+				} else if(value) {
+					return 1;
+				}
+			} else if(v instanceof Null) {
+				return 1;
+			}
+			return -1;
+		}
+		public java.lang.String toString() {
+			if(value) { return "true"; }
+			else {
+				return "false";
+			}
+		}
+
+		public SemanticType type() {
+			return SemanticType.Bool;
+		}
+	}
+
+	public static final class Decimal extends Value {
+		public final BigDecimal value;
+		private Decimal(BigDecimal value) {
+			this.value = value;
+		}
+		public int hashCode() {
+			return value.hashCode();
+		}
+		public boolean equals(Object o) {
+			if(o instanceof Decimal) {
+				Decimal i = (Decimal) o;
+				return value.equals(i.value);
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Decimal) {
+				Decimal i = (Decimal) v;
+				return value.compareTo(i.value);
+			} else if(v instanceof Null || v instanceof Bool || v instanceof Integer) {
+				return 1;
+			}
+			return -1;
+		}
+		public java.lang.String toString() {
+			java.lang.String r = value.toString();
+			// We need to force the string to include the decimal point.
+			if(!r.contains(".")) {
+				return r + ".0";
+			} else {
+				return r;
+			}
+		}
+
+		public Value.Decimal add(Value.Decimal val) {
+			return Value.Decimal(value.add(val.value));
+		}
+		public Value.Decimal subtract(Value.Decimal val) {
+			return Value.Decimal(value.subtract(val.value));
+		}
+		public Value.Decimal multiply(Value.Decimal val) {
+			return Value.Decimal(value.multiply(val.value));
+		}
+		public Value.Decimal divide(Value.Decimal val) {
+			return Value.Decimal(value.divide(val.value));
+		}
+		public SemanticType type() {
+			return SemanticType.Real;
+		}
+	}
+
+	public static final class Integer extends Value {
+		public final BigInteger value;
+		private Integer(BigInteger value) {
+			this.value = value;
+		}
+		public int hashCode() {
+			return value.hashCode();
+		}
+		public boolean equals(Object o) {
+			if(o instanceof Integer) {
+				Integer i = (Integer) o;
+				return value.equals(i.value);
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Integer) {
+				Integer i = (Integer) v;
+				return value.compareTo(i.value);
+			} else if (v instanceof Null || v instanceof Bool || v instanceof Decimal) {
+				return 1;
+			}
+			return -1;
+		}
+		public java.lang.String toString() {
+			return value.toString();
+		}
+
+		public Value.Integer add(Value.Integer val) {
+			return Value.Integer(value.add(val.value));
+		}
+		public Value.Integer subtract(Value.Integer val) {
+			return Value.Integer(value.subtract(val.value));
+		}
+		public Value.Integer multiply(Value.Integer val) {
+			return Value.Integer(value.multiply(val.value));
+		}
+		public Value.Integer divide(Value.Integer val) {
+			return Value.Integer(value.divide(val.value));
+		}
+		public Value.Integer remainder(Value.Integer val) {
+			return Value.Integer(value.remainder(val.value));
+		}
+		public SemanticType type() {
+			return SemanticType.Int;
+		}
+	}
+
+	public static final class String extends Value {
+		public final java.lang.String value;
+		private String(java.lang.String value) {
+			this.value = value;
+		}
+		public int hashCode() {
+			return value.hashCode();
+		}
+		public boolean equals(Object o) {
+			if(o instanceof String) {
+				String i = (String) o;
+				return value.equals(i.value);
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof String) {
+				String i = (String) v;
+				return value.compareTo(i.value);
+			} else if (v instanceof Null || v instanceof Bool || v instanceof Decimal
+					|| v instanceof Integer) {
+				return 1;
+			}
+			return -1;
+		}
+		public java.lang.String toString() {
+			return "\"" + value.toString() + "\"";
+		}
+
+		public SemanticType type() {
+			return SemanticType.String;
+		}
+	}
+
+	public static final class Array extends Value {
+		public final ArrayList<Value> values;
+		private Array() {
+			this.values = new ArrayList<Value>();
+		}
+		private Array(Collection<Value> value) {
+			this.values = new ArrayList<Value>(value);
+		}
+		public int hashCode() {
+			return values.hashCode();
+		}
+		public boolean equals(Object o) {
+			if(o instanceof Array) {
+				Array i = (Array) o;
+				return values.equals(i.values);
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Array) {
+				Array l = (Array) v;
+				if(values.size() < l.values.size()) {
+					return -1;
+				} else if(values.size() > l.values.size()) {
+					return 1;
+				} else {
+					// this case is slightly awkward, since we can't rely on the
+					// iteration order for HashSet.
+					ArrayList<Value> vs1 = new ArrayList<Value>(values);
+					ArrayList<Value> vs2 = new ArrayList<Value>(l.values);
+					Collections.sort(vs1);
+					Collections.sort(vs2);
+					for(int i=0;i!=values.size();++i) {
+						Value v1 = vs1.get(i);
+						Value v2 = vs2.get(i);
+						int c = v1.compareTo(v2);
+						if(c != 0) { return c; }
+					}
+					return 0;
+				}
+			} else if (v instanceof Null
+					|| v instanceof Bool
+					|| v instanceof Decimal
+					|| v instanceof Integer
+					|| v instanceof String
+					|| v instanceof Tuple) {
+				return 1;
+			}
+			return -1;
+		}
+		public java.lang.String toString() {
+			java.lang.String r = "[";
+			boolean firstTime=true;
+			for(Value v : values) {
+				if(!firstTime) {
+					r += ",";
+				}
+				firstTime=false;
+				r += v;
+			}
+			return r + "]";
+		}
+
+		public Array union(Array rhs) {
+			Value.Array nset = new Value.Array(values);
+			nset.values.addAll(rhs.values);
+			return nset;
+
+		}
+
+		public Array add(Value val) {
+			Value.Array nset = new Value.Array(values);
+			nset.values.add(val);
+			return nset;
+
+		}
+
+		public Array difference(Array rhs) {
+			Value.Array nset = new Value.Array(values);
+			nset.values.removeAll(rhs.values);
+			return nset;
+		}
+
+		public Array remove(Value val) {
+			Value.Array nset = new Value.Array(values);
+			nset.values.remove(val);
+			return nset;
+
+		}
+
+		public Array intersect(Array rhs) {
+			Value.Array nset = new Value.Array();
+			for(Value v : values) {
+				if(rhs.values.contains(v)) {
+					nset.values.add(v);
+				}
+			}
+			return nset;
+		}
+
+		public SemanticType type() {
+			SemanticType[] types = new SemanticType[values.size()];
+			int i = 0;
+			for(Value v : values) {
+				types[i++] = v.type();
+			}
+			return SemanticType.Array(SemanticType.Or(types));			
+		}
+	}
+
+	public static final class Tuple extends Value {
+		public final ArrayList<Value> values;
+		private Tuple(Collection<Value> values) {
+			this.values = new ArrayList<Value>(values);
+		}
+
+		public int hashCode() {
+			return values.hashCode();
+		}
+		public boolean equals(Object o) {
+			if(o instanceof Tuple) {
+				Tuple i = (Tuple) o;
+				return values.equals(i.values);
+			}
+			return false;
+		}
+		public int compareTo(Value v) {
+			if(v instanceof Tuple) {
+				Tuple l = (Tuple) v;
+				if(values.size() < l.values.size()) {
+					return -1;
+				} else if(values.size() > l.values.size()) {
+					return 1;
+				} else {
+					ArrayList<Value> vs1 = values;
+					ArrayList<Value> vs2 = l.values;
+					for(int i=0;i!=values.size();++i) {
+						Value s1 = vs1.get(i);
+						Value s2 = vs2.get(i);
+						int c = s1.compareTo(s2);
+						if(c != 0) { return c; }
+					}
+					return 0;
+				}
+			} else if (v instanceof Null
+					|| v instanceof Bool
+					|| v instanceof Decimal
+					|| v instanceof Integer
+					|| v instanceof String
+					|| v instanceof Array) {
+				return 1;
+			}
+			return -1;
+		}
+
+		public java.lang.String toString() {
+			java.lang.String r = "(";
+			boolean firstTime=true;
+			for(Value v : values) {
+				if(!firstTime) {
+					r += ",";
+				}
+				firstTime=false;
+				r += v;
+			}
+			return r + ")";
+		}
+
+		public SemanticType type() {
+			SemanticType[] types = new SemanticType[values.size()];
+			int i = 0;
+			for (Value v : values) {
+				types[i++] = v.type();
+			}
+			return SemanticType.Tuple(types);
+		}
+	}
+
+	private static final ArrayList<Value> values = new ArrayList<Value>();
+	private static final HashMap<Value,java.lang.Integer> cache = new HashMap<Value,java.lang.Integer>();
+
+	private static <T extends Value> T get(T type) {
+		java.lang.Integer idx = cache.get(type);
+		if(idx != null) {
+			return (T) values.get(idx);
+		} else {
+			cache.put(type, values.size());
+			values.add(type);
+			return type;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/core/WycsFile.java b/modules/wycs/src/wycs/core/WycsFile.java
new file mode 100755
index 0000000000..4159b4b8d0
--- /dev/null
+++ b/modules/wycs/src/wycs/core/WycsFile.java
@@ -0,0 +1,211 @@
+package wycs.core;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import wycc.lang.Attribute;
+import wycc.lang.CompilationUnit;
+import wycc.lang.SyntacticElement;
+import wycc.util.AbstractCompilationUnit;
+import wycs.io.WyalFilePrinter;
+import wycs.io.WycsFileReader;
+import wycs.io.WycsFileWriter;
+import wycs.syntax.Expr;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+
+public class WycsFile extends AbstractCompilationUnit {
+
+	// =========================================================================
+	// Content Type
+	// =========================================================================
+
+	public static final Content.Type<WycsFile> ContentType = new Content.Type<WycsFile>() {
+		public Path.Entry<WycsFile> accept(Path.Entry<?> e) {
+			if (e.contentType() == this) {
+				return (Path.Entry<WycsFile>) e;
+			}
+			return null;
+		}
+
+		public WycsFile read(Path.Entry<WycsFile> e, InputStream input)
+				throws IOException {
+			WycsFileReader reader = new WycsFileReader(e,input);
+			return reader.read();
+		}
+
+		public void write(OutputStream output, WycsFile module)
+				throws IOException {
+			WycsFileWriter writer = new WycsFileWriter(
+					output);
+			writer.write(module);
+		}
+
+		public String toString() {
+			return "Content-Type: wycs";
+		}
+	};
+
+	// =========================================================================
+	// State
+	// =========================================================================
+
+	private final ArrayList<Declaration> declarations;
+
+	// =========================================================================
+	// Constructors
+	// =========================================================================
+
+	public WycsFile(Path.Entry<? extends CompilationUnit> entry) {
+		super(entry);
+		this.declarations = new ArrayList<Declaration>();
+	}
+
+	public WycsFile(Path.Entry<? extends CompilationUnit> entry, Collection<Declaration> declarations) {
+		super(entry);
+		this.declarations = new ArrayList<Declaration>(declarations);
+	}
+
+	// =========================================================================
+	// Accessors
+	// =========================================================================
+
+	public List<Declaration> declarations() {
+		return declarations;
+	}
+
+	public Declaration declaration(String name) {
+		for(Declaration d : declarations) {
+			if(d.name().equals(name)) {
+				return d;
+			}
+		}
+		return null;
+	}
+
+	public Declaration declaration(String name, SemanticType type) {
+		for (Declaration d : declarations) {
+			if (d.name().equals(name)) {
+				if (d instanceof Function && ((Function) d).type.equals(type)) {
+					return d;
+				} else if (d instanceof Macro && ((Macro) d).type.equals(type)) {
+					return d;
+				}
+			}
+		}
+		return null;
+	}
+	
+	public <T extends Declaration> T declaration(String name, Class<T> type) {
+		for (Declaration d : declarations) {
+			if (d.name().equals(name) && type.isInstance(d)) {
+				return (T) d;
+			}
+		}
+		return null;
+	}
+
+	// =========================================================================
+	// Types
+	// =========================================================================
+
+	public interface Declaration extends SyntacticElement {
+		public String name();
+	}
+
+	public static class Function extends SyntacticElement.Impl implements Declaration {
+		public final String name;
+		public final SemanticType.Function type;
+		public Code<?> constraint;
+
+		public Function(String name, SemanticType.Function type,
+				Code<?> constraint, Attribute... attributes) {
+			super(attributes);
+			if (!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: "
+						+ name);
+			}
+			this.name = name;
+			this.type = type;
+			this.constraint = constraint;
+		}
+
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+
+	public static class Macro extends SyntacticElement.Impl implements Declaration {
+		public final String name;
+		public final SemanticType.Function type;
+		public Code<?> condition;
+
+		public Macro(String name, SemanticType.Function type,
+				Code<?> condition, Attribute... attributes) {
+			super(attributes);
+			if (!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: "
+						+ name);
+			}
+			this.name = name;
+			this.type = type;
+			this.condition = condition;
+		}
+
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+
+	public static class Assert extends SyntacticElement.Impl implements Declaration {
+		public final String message;
+		public Code<?> condition;
+
+		public Assert(String message, Code<?> condition, Attribute... attributes) {
+			super(attributes);
+			this.message = message;
+			this.condition = condition;
+		}
+
+		public Assert(String message, Code<?> condition, Collection<Attribute> attributes) {
+			super(attributes);
+			this.message = message;
+			this.condition = condition;
+		}
+
+		public String name() {
+			return ""; // anonymous
+		}
+	}
+	
+	public static class Type extends SyntacticElement.Impl implements Declaration {
+		public final String name;
+		public final SemanticType type;
+		public Code<?> invariant;
+		
+		public Type(String name, SemanticType type, Code<?> invariant, Attribute... attributes) {
+			super(attributes);
+			this.name = name;
+			this.type = type;
+			this.invariant = invariant;		
+		}
+		
+		public Type(String name, SemanticType type, Code<?> invariant, Collection<Attribute> attributes) {
+			super(attributes);
+			this.name = name;
+			this.type = type;
+			this.invariant = invariant;		
+		}
+
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/io/WyalFileLexer.java b/modules/wycs/src/wycs/io/WyalFileLexer.java
new file mode 100755
index 0000000000..b41edb7da4
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WyalFileLexer.java
@@ -0,0 +1,963 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.io;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycs.syntax.WyalFile;
+import wyfs.lang.Path;
+
+/**
+ * Split a source file into a list of tokens. These tokens can then be fed into
+ * the parser in order to generate an Abstract Syntax Tree (AST).
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WyalFileLexer {
+
+	private final Path.Entry<WyalFile> entry;
+	private final StringBuilder input;
+	private int pos;
+
+	public WyalFileLexer(Path.Entry<WyalFile> entry) throws IOException {
+		this.entry = entry;
+		//
+		Reader reader = new InputStreamReader(entry.inputStream(),"UTF8");
+		BufferedReader in = new BufferedReader(reader);
+
+        StringBuilder text = new StringBuilder();
+		int len = 0;
+		char[] buf = new char[1024];
+		while ((len = in.read(buf)) != -1) {
+			text.append(buf, 0, len);
+		}
+        input = text;
+	}
+
+	/**
+	 * Scan all characters from the input stream and generate a corresponding
+	 * list of tokens, whilst discarding all whitespace and comments.
+	 *
+	 * @return
+	 */
+	public List<Token> scan() {
+		ArrayList<Token> tokens = new ArrayList<Token>();
+		pos = 0;
+
+		while (pos < input.length()) {
+			char c = input.charAt(pos);
+
+			if (Character.isDigit(c)) {
+				tokens.add(scanNumericConstant());
+			} else if (c == '"') {
+				tokens.add(scanStringConstant());
+			} else if (c == '\'') {
+				tokens.add(scanCharacterConstant());
+			} else if (isOperatorStart(c)) {
+				tokens.add(scanOperator());
+			} else if (Character.isLetter(c) || c == '_' || c == '$') {
+				tokens.add(scanIdentifier());
+			} else if (Character.isWhitespace(c)) {
+				scanWhiteSpace(tokens);
+			} else {
+				syntaxError("unknown token encountered",pos);
+			}
+		}
+
+		return tokens;
+	}
+
+	/**
+	 * Scan a numeric constant. That is a sequence of digits which gives either
+	 * an integer constant, or a real constant (if it includes a dot) or a byte
+	 * (if it ends in a 'b').
+	 *
+	 * @return
+	 */
+	public Token scanNumericConstant() {
+		int start = pos;
+		while (pos < input.length() && Character.isDigit(input.charAt(pos))) {
+			pos = pos + 1;
+		}
+		if (pos < input.length() && input.charAt(pos) == '.') {
+			pos = pos + 1;
+			if (pos < input.length() && input.charAt(pos) == '.') {
+				// this is case for range e.g. 0..1
+				pos = pos - 1;
+				return new Token(Token.Kind.IntValue, input.substring(start,
+						pos), start);
+			}
+			while (pos < input.length() && Character.isDigit(input.charAt(pos))) {
+				pos = pos + 1;
+			}
+			return new Token(Token.Kind.RealValue, input.substring(start, pos),
+					start);
+		} else {
+			return new Token(Token.Kind.IntValue, input.substring(start, pos),
+					start);
+		}
+	}
+
+	/**
+	 * Scan a character constant, such as e.g. 'c'. Observe that care must be
+	 * taken to properly handle escape codes. For example, '\n' is a single
+	 * character constant which is made up from two characters in the input
+	 * string.
+	 *
+	 * @return
+	 */
+	public Token scanCharacterConstant() {
+		int start = pos;
+		pos++;
+		char c = input.charAt(pos++);
+		if (c == '\\') {
+			// escape code
+			switch (input.charAt(pos++)) {
+			case 'b':
+				c = '\b';
+				break;
+			case 't':
+				c = '\t';
+				break;
+			case 'n':
+				c = '\n';
+				break;
+			case 'f':
+				c = '\f';
+				break;
+			case 'r':
+				c = '\r';
+				break;
+			case '"':
+				c = '\"';
+				break;
+			case '\'':
+				c = '\'';
+				break;
+			case '\\':
+				c = '\\';
+				break;
+			default:
+				syntaxError("unrecognised escape character", pos);
+			}
+		}
+		if (input.charAt(pos) != '\'') {
+			syntaxError("unexpected end-of-character", pos);
+		}
+		pos = pos + 1;
+		return new Token(Token.Kind.CharValue, input.substring(start, pos),
+				start);
+	}
+
+	public Token scanStringConstant() {
+		int start = pos;
+		boolean escaped = false;
+		pos++;
+		while (pos < input.length()) {
+			char c = input.charAt(pos);
+			if (c == '"' && !escaped) {
+				String v = input.substring(start, ++pos);
+				return new Token(Token.Kind.StringValue, v, start);
+			} else if(c == '\\' && !escaped) {
+				escaped = true;
+			} else {
+				escaped = false;
+			}
+			pos = pos + 1;
+		}
+		syntaxError("unexpected end-of-string", pos - 1);
+		return null;
+	}
+
+	public static final char UC_FORALL = '\u2200';
+	public static final char UC_EXISTS = '\u2203';
+	public static final char UC_EMPTYSET = '\u2205';
+	public static final char UC_SUBSET = '\u2282';
+	public static final char UC_SUBSETEQ = '\u2286';
+	public static final char UC_SUPSET = '\u2283';
+	public static final char UC_SUPSETEQ = '\u2287';
+	public static final char UC_SETUNION = '\u222A';
+	public static final char UC_SETINTERSECTION = '\u2229';
+	public static final char UC_LESSEQUALS = '\u2264';
+	public static final char UC_GREATEREQUALS = '\u2265';
+	public static final char UC_ELEMENTOF = '\u2208';
+	public static final char UC_LOGICALAND = '\u2227';
+	public static final char UC_LOGICALOR = '\u2228';
+
+	static final char[] opStarts = { ',', '(', ')', '[', ']', '{', '}', '+',
+			'-', '*', '/', '%', '^', '!', '?', '=', '<', '>', ':', ';', '&', '|',
+			'.', '~',
+			// Unicode operators
+			UC_FORALL,
+			UC_EXISTS,
+			UC_EMPTYSET,
+			UC_SUBSET,
+			UC_SUBSETEQ,
+			UC_SUPSET,
+			UC_SUPSETEQ,
+			UC_SETUNION,
+			UC_SETINTERSECTION,
+			UC_LESSEQUALS,
+			UC_GREATEREQUALS,
+			UC_ELEMENTOF
+	};
+
+	public boolean isOperatorStart(char c) {
+		for (char o : opStarts) {
+			if (c == o) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	public Token scanOperator() {
+		char c = input.charAt(pos);
+
+		switch (c) {
+		case '.':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '.') {
+				pos = pos + 2;
+				if (pos < input.length() && input.charAt(pos) == '.') {
+					return new Token(Token.Kind.DotDotDot, "...", pos++);
+				} else {
+					return new Token(Token.Kind.DotDot, "..", pos);
+				}
+			} else {
+				return new Token(Token.Kind.Dot, ".", pos++);
+			}
+		case ',':
+			return new Token(Token.Kind.Comma, ",", pos++);
+		case ':':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '=') {
+				pos += 2;
+				return new Token(Token.Kind.ColonEquals, ":=", pos - 2);
+			} else {
+				return new Token(Token.Kind.Colon, ":", pos++);
+			}
+		case ';':
+			return new Token(Token.Kind.SemiColon, ";", pos++);
+		case '|':
+			if (pos + 1 < input.length() && input.charAt(pos + 1) == '|') {
+				pos += 2;
+				return new Token(Token.Kind.LogicalOr, "||", pos - 2);
+			} else {
+				return new Token(Token.Kind.VerticalBar, "|", pos++);
+			}
+		case '(':
+			return new Token(Token.Kind.LeftBrace, "(", pos++);
+		case ')':
+			return new Token(Token.Kind.RightBrace, ")", pos++);
+		case '[':
+			return new Token(Token.Kind.LeftSquare, "[", pos++);
+		case ']':
+			return new Token(Token.Kind.RightSquare, "]", pos++);
+		case '{':
+			return new Token(Token.Kind.LeftCurly, "{", pos++);
+		case '}':
+			return new Token(Token.Kind.RightCurly, "}", pos++);
+		case '+':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '+') {
+				pos = pos + 2;
+				return new Token(Token.Kind.PlusPlus, "++", pos);
+			} else {
+				return new Token(Token.Kind.Plus, "+", pos++);
+			}
+		case '-':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '>') {
+				pos += 2;
+				return new Token(Token.Kind.MinusGreater, "->", pos - 2);
+			} else {
+				return new Token(Token.Kind.Minus, "-", pos++);
+			}
+		case '*':
+			return new Token(Token.Kind.Star, "*", pos++);
+		case '&':
+			if (pos + 1 < input.length() && input.charAt(pos + 1) == '&') {
+				pos += 2;
+				return new Token(Token.Kind.LogicalAnd, "&&", pos - 2);
+			} else {
+				return new Token(Token.Kind.Ampersand, "&", pos++);
+			}
+		case '/':
+			if((pos+1) < input.length() && input.charAt(pos+1) == '/') {
+				return scanLineComment();
+			} else if((pos+1) < input.length() && input.charAt(pos+1) == '*') {
+				return scanBlockComment();
+			} else {
+				return new Token(Token.Kind.RightSlash, "/", pos++);
+			}
+		case '%':
+			return new Token(Token.Kind.Percent, "%", pos++);
+		case '^':
+			return new Token(Token.Kind.Caret, "^", pos++);
+		case '!':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '=') {
+				pos += 2;
+				return new Token(Token.Kind.NotEquals, "!=", pos - 2);
+			} else {
+				return new Token(Token.Kind.Shreak, "!", pos++);
+			}
+		case '=':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '=') {
+				pos += 2;
+				if (pos < input.length() && input.charAt(pos) == '>') {
+					pos++;
+					return new Token(Token.Kind.LogicalImplication, "==>", pos - 3);
+				} else {
+					return new Token(Token.Kind.EqualsEquals, "==", pos - 2);
+				}
+			} else if ((pos + 1) < input.length() && input.charAt(pos + 1) == '>') {
+				pos += 2;
+				return new Token(Token.Kind.EqualsGreater, "=>", pos - 2);
+			}
+			break;
+		case '<':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '=') {
+				pos += 2;
+				if ((pos+1) < input.length() && input.charAt(pos) == '=' && input.charAt(pos+1) == '>') {
+					pos += 2;
+					return new Token(Token.Kind.LogicalIff, "<==>", pos - 4);
+				} else {
+					return new Token(Token.Kind.LessEquals, "<=", pos - 2);
+				}
+			} else{
+				return new Token(Token.Kind.LeftAngle, "<", pos++);
+			}
+		case '>':
+			if ((pos + 1) < input.length() && input.charAt(pos + 1) == '=') {
+				pos += 2;
+				return new Token(Token.Kind.GreaterEquals, ">=", pos - 2);
+			} else {
+				return new Token(Token.Kind.RightAngle, ">", pos++);
+			}
+		// =================================================================
+		//
+		// =================================================================
+		case UC_LESSEQUALS:
+			return new Token(Token.Kind.LessEquals, "" + c, pos++);
+		case UC_GREATEREQUALS:
+			return new Token(Token.Kind.GreaterEquals, "" + c, pos++);
+		case UC_SETUNION:
+			return new Token(Token.Kind.SetUnion, "" + c, pos++);
+		case UC_SETINTERSECTION:
+			return new Token(Token.Kind.SetIntersection, "" + c, pos++);
+		case UC_ELEMENTOF:
+			return new Token(Token.Kind.ElementOf, "" + c, pos++);
+		case UC_SUBSET:
+			return new Token(Token.Kind.Subset, "" + c, pos++);
+		case UC_SUBSETEQ:
+			return new Token(Token.Kind.SubsetEquals, "" + c, pos++);
+		case UC_SUPSET:
+			return new Token(Token.Kind.Superset, "" + c, pos++);
+		case UC_SUPSETEQ:
+			return new Token(Token.Kind.SupersetEquals, "" + c, pos++);
+		case UC_EMPTYSET:
+			return new Token(Token.Kind.EmptySet, "" + c, pos++);
+		case UC_LOGICALOR:
+			return new Token(Token.Kind.LogicalOr, "" + c, pos++);
+		case UC_LOGICALAND:
+			return new Token(Token.Kind.LogicalAnd, "" + c, pos++);
+		}
+
+		syntaxError("unknown operator encountered: " + c, pos);
+		return null;
+	}
+
+	public Token scanIdentifier() {
+		int start = pos;
+		while (pos < input.length()
+				&& (input.charAt(pos) == '_' || input.charAt(pos) == '$'
+						|| input.charAt(pos) == '%' || Character
+							.isLetterOrDigit(input.charAt(pos)))) {
+			pos++;
+		}
+		String text = input.substring(start, pos);
+
+		// now, check for keywords
+		Token.Kind kind = keywords.get(text);
+		if (kind == null) {
+			// not a keyword, so just a regular identifier.
+			kind = Token.Kind.Identifier;
+		}
+		return new Token(kind, text, start);
+	}
+
+	public void scanWhiteSpace(List<Token> tokens) {
+		while (pos < input.length()
+				&& Character.isWhitespace(input.charAt(pos))) {
+			if (input.charAt(pos) == ' ' || input.charAt(pos) == '\t') {
+				tokens.add(scanIndent());
+			} else if (input.charAt(pos) == '\n') {
+				tokens.add(new Token(Token.Kind.NewLine, input.substring(pos,
+						pos + 1), pos));
+				pos = pos + 1;
+			} else if (input.charAt(pos) == '\r' && (pos + 1) < input.length()
+					&& input.charAt(pos + 1) == '\n') {
+				tokens.add(new Token(Token.Kind.NewLine, input.substring(pos,
+						pos + 2), pos));
+				pos = pos + 2;
+			} else {
+				syntaxError("unknown whitespace character encounterd: \""
+						+ input.charAt(pos), pos);
+			}
+		}
+	}
+
+	/**
+	 * Scan one or more spaces or tab characters, combining them to form an
+	 * "indent".
+	 *
+	 * @return
+	 */
+	public Token scanIndent() {
+		int start = pos;
+		while (pos < input.length()
+				&& (input.charAt(pos) == ' ' || input.charAt(pos) == '\t')) {
+			pos++;
+		}
+		return new Token(Token.Kind.Indent, input.substring(start, pos), start);
+	}
+
+	public Token scanLineComment() {
+		int start = pos;
+		while (pos < input.length() && input.charAt(pos) != '\n') {
+			pos++;
+		}
+		return new Token(Token.Kind.LineComment, input.substring(start, pos),
+				start);
+	}
+
+	public Token scanBlockComment() {
+		int start = pos;
+		while((pos+1) < input.length() && (input.charAt(pos) != '*' || input.charAt(pos+1) != '/')) {
+			pos++;
+		}
+		pos++;
+		pos++;
+		return new Token(Token.Kind.BlockComment,input.substring(start,pos),start);
+	}
+
+	/**
+	 * Skip over any whitespace at the current index position in the input
+	 * string.
+	 *
+	 * @param tokens
+	 */
+	public void skipWhitespace(List<Token> tokens) {
+		while (pos < input.length()
+				&& (input.charAt(pos) == '\n' || input.charAt(pos) == '\t')) {
+			pos++;
+		}
+	}
+
+	/**
+	 * Raise a syntax error with a given message at given index.
+	 *
+	 * @param msg
+	 *            --- message to raise.
+	 * @param index
+	 *            --- index position to associate the error with.
+	 */
+	private void syntaxError(String msg, int index) {
+		// FIXME: this is clearly not a sensible approach
+		SyntacticElement unknown = new SyntacticElement.Impl() {};
+		unknown.attributes().add(new Attribute.Source(index, index, -1));
+		throw new SyntaxError(msg, entry, unknown);
+	}
+
+	/**
+	 * A map from identifier strings to the corresponding token kind.
+	 */
+	public static final HashMap<String, Token.Kind> keywords = new HashMap<String, Token.Kind>() {
+		{
+			// types
+			put("void", Token.Kind.Void);
+			put("any", Token.Kind.Any);
+			put("null", Token.Kind.Null);
+			put("bool", Token.Kind.Bool);
+			put("int", Token.Kind.Int);
+			put("real", Token.Kind.Real);
+			// constants
+			put("true", Token.Kind.True);
+			put("false", Token.Kind.False);
+			// statements
+			put("assert", Token.Kind.Assert);
+			put("either", Token.Kind.Either);
+			put("or", Token.Kind.Or);
+			put("if", Token.Kind.If);
+			put("then", Token.Kind.Then);
+			// expressions
+			put("forall", Token.Kind.Forall);
+			put("exists", Token.Kind.Exists);
+			put("is", Token.Kind.Is);
+			put("in", Token.Kind.In);
+			// declarations
+			put("function", Token.Kind.Function);
+			put("import", Token.Kind.Import);
+			put("define", Token.Kind.Define);
+			put("constant", Token.Kind.Constant);
+			//put("type", Token.Kind.Type);
+			put("where", Token.Kind.Where);
+			put("ensures", Token.Kind.Ensures);
+			put("requires", Token.Kind.Requires);
+			put("public", Token.Kind.Public);
+			put("protected", Token.Kind.Protected);
+			put("private", Token.Kind.Private);
+			put("package", Token.Kind.Package);
+		}
+	};
+
+	/**
+	 * The base class for all tokens.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Token {
+
+		public enum Kind {
+			Identifier,
+			// Constants
+			True {
+				public String toString() {
+					return "true";
+				}
+			},
+			False {
+				public String toString() {
+					return "true";
+				}
+			},
+			RealValue,
+			IntValue,
+			CharValue,
+			StringValue,
+			// Types
+			Null {
+				public String toString() {
+					return "null";
+				}
+			},
+			Void {
+				public String toString() {
+					return "void";
+				}
+			},
+			Any {
+				public String toString() {
+					return "any";
+				}
+			},
+			Bool {
+				public String toString() {
+					return "bool";
+				}
+			},
+			Int {
+				public String toString() {
+					return "int";
+				}
+			},
+			Real {
+				public String toString() {
+					return "real";
+				}
+			},
+			Char {
+				public String toString() {
+					return "char";
+				}
+			},
+			String {
+				public String toString() {
+					return "string";
+				}
+			},
+			// Statements
+			Assert {
+				public String toString() {
+					return "assert";
+				}
+			},
+			Either {
+				public String toString() {
+					return "either";
+				}
+			},
+			Or {
+				public String toString() {
+					return "or";
+				}
+			},
+			If {
+				public String toString() {
+					return "if";
+				}
+			},
+			Then {
+				public String toString() {
+					return "then";
+				}
+			},
+			// Declarations
+			Package {
+				public String toString() {
+					return "package";
+				}
+			},
+			Import {
+				public String toString() {
+					return "import";
+				}
+			},
+			Public {
+				public String toString() {
+					return "public";
+				}
+			},
+			Private {
+				public String toString() {
+					return "private";
+				}
+			},
+			Protected {
+				public String toString() {
+					return "protected";
+				}
+			},
+			Function {
+				public String toString() {
+					return "function";
+				}
+			},
+			Assume {
+				public String toString() {
+					return "assume";
+				}
+			},
+			Constant {
+				public String toString() {
+					return "constant";
+				}
+			},
+			Define {
+				public String toString() {
+					return "define";
+				}
+			},
+			Requires {
+				public String toString() {
+					return "requires";
+				}
+			},
+			Ensures {
+				public String toString() {
+					return "ensures";
+				}
+			},
+			Where {
+				public String toString() {
+					return "where";
+				}
+			},
+			Throws {
+				public String toString() {
+					return "throws";
+				}
+			},
+			// Expressions
+			Forall {
+				public String toString() {
+					return "forall";
+				}
+			},
+			Exists {
+				public String toString() {
+					return "exists";
+				}
+			},
+			Is {
+				public String toString() {
+					return "is";
+				}
+			},
+			In {
+				public String toString() {
+					return "in";
+				}
+			},
+			Comma {
+				public String toString() {
+					return ",";
+				}
+			},
+			Colon {
+				public String toString() {
+					return ":";
+				}
+			},
+			ColonEquals {
+				public String toString() {
+					return ":=";
+				}
+			},
+			SemiColon {
+				public String toString() {
+					return ";";
+				}
+			},
+			Ampersand {
+				public String toString() {
+					return "&";
+				}
+			},
+			VerticalBar {
+				public String toString() {
+					return "|";
+				}
+			},
+			LeftBrace {
+				public String toString() {
+					return "(";
+				}
+			},
+			RightBrace {
+				public String toString() {
+					return ")";
+				}
+			},
+			LeftSquare {
+				public String toString() {
+					return "[";
+				}
+			},
+			RightSquare {
+				public String toString() {
+					return "]";
+				}
+			},
+			LeftAngle {
+				public String toString() {
+					return "<";
+				}
+			},
+			RightAngle {
+				public String toString() {
+					return ">";
+				}
+			},
+			LeftCurly {
+				public String toString() {
+					return "{";
+				}
+			},
+			RightCurly {
+				public String toString() {
+					return "}";
+				}
+			},
+			Plus {
+				public String toString() {
+					return "+";
+				}
+			},
+			PlusPlus {
+				public String toString() {
+					return "++";
+				}
+			},
+			Minus {
+				public String toString() {
+					return "-";
+				}
+			},
+			Star {
+				public String toString() {
+					return "*";
+				}
+			},
+			LeftSlash {
+				public String toString() {
+					return "\\";
+				}
+			},
+			RightSlash {
+				public String toString() {
+					return "//";
+				}
+			},
+			Percent {
+				public String toString() {
+					return "%";
+				}
+			},
+			Shreak {
+				public String toString() {
+					return "!";
+				}
+			},
+			Caret {
+				public String toString() {
+					return "^";
+				}
+			},
+			Dot {
+				public String toString() {
+					return ".";
+				}
+			},
+			DotDot {
+				public String toString() {
+					return "..";
+				}
+			},
+			DotDotDot {
+				public String toString() {
+					return "...";
+				}
+			},
+			EqualsEquals {
+				public String toString() {
+					return "==";
+				}
+			},
+			NotEquals {
+				public String toString() {
+					return "!=";
+				}
+			},
+			LessEquals {
+				public String toString() {
+					return "<=";
+				}
+			},
+			GreaterEquals {
+				public String toString() {
+					return ">=";
+				}
+			},
+			EqualsGreater {
+				public String toString() {
+					return "=>";
+				}
+			},
+			MinusGreater {
+				public String toString() {
+					return "->";
+				}
+			},
+			LogicalAnd {
+				public String toString() {
+					return "&&";
+				}
+			},
+			LogicalOr {
+				public String toString() {
+					return "||";
+				}
+			},
+			LogicalImplication {
+				public String toString() {
+					return "==>";
+				}
+			},
+			LogicalIff {
+				public String toString() {
+					return "<==>";
+				}
+			},
+			SetUnion {
+				public String toString() {
+					return "" + UC_SETUNION;
+				}
+			},
+			SetIntersection {
+				public String toString() {
+					return "" + UC_SETINTERSECTION;
+				}
+			},
+			ElementOf {
+				public String toString() {
+					return "" + UC_ELEMENTOF;
+				}
+			},
+			EmptySet {
+				public String toString() {
+					return "" + UC_EMPTYSET;
+				}
+			},
+			Subset {
+				public String toString() {
+					return "" + UC_SUBSET;
+				}
+			},
+			SubsetEquals {
+				public String toString() {
+					return "" + UC_SUBSETEQ;
+				}
+			},
+			Superset {
+				public String toString() {
+					return "" + UC_SUPSETEQ;
+				}
+			},
+			SupersetEquals {
+				public String toString() {
+					return "" + UC_SUPSETEQ;
+				}
+			},
+			// Other
+			NewLine, Indent, LineComment, BlockComment
+		}
+
+		public final Kind kind;
+		public final String text;
+		public final int start;
+
+		public Token(Kind kind, String text, int pos) {
+			this.kind = kind;
+			this.text = text;
+			this.start = pos;
+		}
+
+		public int end() {
+			return start + text.length() - 1;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/io/WyalFileParser.java b/modules/wycs/src/wycs/io/WyalFileParser.java
new file mode 100755
index 0000000000..711266718b
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WyalFileParser.java
@@ -0,0 +1,3491 @@
+package wycs.io;
+
+import java.io.File;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import static wycs.io.WyalFileLexer.Token.Kind.*;
+import wycs.core.Value;
+import wycs.io.WyalFileLexer.Token;
+import wycs.syntax.*;
+import wycs.syntax.Expr.Is;
+import wycc.lang.SyntaxError;
+import wycc.lang.SyntaxError.*;
+import wycc.lang.SyntacticElement;
+import wycc.lang.Attribute;
+import wycc.util.Pair;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+public class WyalFileParser {
+	private final Path.Entry<WyalFile> entry;
+	private ArrayList<Token> tokens;
+	private int index;
+
+	public WyalFileParser(Path.Entry<WyalFile> entry, List<Token> tokens) {
+		this.entry = entry;
+		this.tokens = new ArrayList<Token>(tokens);
+	}
+
+	/**
+	 * Read a <code>WyalFile</code> from the token stream. If the stream is
+	 * invalid in some way (e.g. contains a syntax error, etc) then a
+	 * <code>SyntaxError</code> is thrown.
+	 *
+	 * @return
+	 */
+	public WyalFile read() {
+		Path.ID pkg = parsePackage();
+
+		// Construct object representing this WyalFile.
+		WyalFile wf = new WyalFile(entry);
+
+		skipWhiteSpace();
+		while (index < tokens.size()) {
+			Token lookahead = tokens.get(index);
+			if (lookahead.kind == Import) {
+				parseImportDeclaration(wf);
+			} else {
+				checkNotEof();
+				lookahead = tokens.get(index);
+				if (lookahead.text.equals("assume")) {
+					parseAssumeDeclaration(wf);
+				} else if (lookahead.text.equals("assert")) {
+					parseAssertDeclaration(wf);
+				} else if (lookahead.text.equals("type")) {
+					parseTypeDeclaration(wf);
+				} else if (lookahead.text.equals("define")) {
+					parseMacroDeclaration(wf);
+				} else if (lookahead.kind == Function) {
+					parseFunctionDeclaration(wf);
+				} else {
+					syntaxError("unrecognised declaration", lookahead);
+				}
+			}
+			skipWhiteSpace();
+		}
+
+		return wf;
+	}
+
+	private Trie parsePackage() {
+		Trie pkg = Trie.ROOT;
+
+		if (tryAndMatch(true, Package) != null) {
+			// found a package keyword
+			pkg = pkg.append(match(Identifier).text);
+
+			while (tryAndMatch(true, Dot) != null) {
+				pkg = pkg.append(match(Identifier).text);
+			}
+
+			matchEndLine();
+			return pkg;
+		} else {
+			return pkg; // no package
+		}
+	}
+
+	/**
+	 * Parse an import declaration, which is of the form:
+	 *
+	 * <pre>
+	 * ImportDecl ::= Identifier ["from" ('*' | Identifier)] ( ('.' | '..') ('*' | Identifier) )*
+	 * </pre>
+	 *
+	 * @param wf
+	 *            WyalFile being constructed
+	 */
+	private void parseImportDeclaration(WyalFile wf) {
+		int start = index;
+
+		match(Import);
+
+		// First, parse "from" usage (if applicable)
+		Token token = tryAndMatch(true, Identifier, Star);
+		if (token == null) {
+			syntaxError("expected identifier or '*' here", token);
+		}
+		String name = token.text;
+		// NOTE: we don't specify "from" as a keyword because this prevents it
+		// from being used as a variable identifier.
+		Token lookahead;
+		if ((lookahead = tryAndMatchOnLine(Identifier)) != null) {
+			// Ok, this must be "from"
+			if (!lookahead.text.equals("from")) {
+				syntaxError("expected \"from\" here", lookahead);
+			}
+			token = match(Identifier);
+		}
+
+		// Second, parse package string
+		Trie filter = Trie.ROOT.append(token.text);
+		token = null;
+		while ((token = tryAndMatch(true, Dot, DotDot)) != null) {
+			if (token.kind == DotDot) {
+				filter = filter.append("**");
+			}
+			if (tryAndMatch(true, Star) != null) {
+				filter = filter.append("*");
+			} else {
+				filter = filter.append(match(Identifier).text);
+			}
+		}
+
+		int end = index;
+		matchEndLine();
+
+		wf.add(wf.new Import(filter, name, sourceAttr(start, end - 1)));
+	}
+
+	/**
+	 * Parse a <i>function declaration</i> which has the form:
+	 *
+	 * <pre>
+	 * FunctionDeclaration ::= "function" TypePattern "->" TypePattern (FunctionMethodClause)* ':' NewLine Block
+	 *
+	 * FunctionMethodClause ::= "throws" Type | "requires" Expr | "ensures" Expr
+	 * </pre>
+	 *
+	 * Here, the first type pattern (i.e. before "->") is referred to as the
+	 * "parameter", whilst the second is referred to as the "return". There are
+	 * three kinds of option clause:
+	 *
+	 * <ul>
+	 * <li><b>Throws clause</b>. This defines the exceptions which may be thrown
+	 * by this function. Multiple clauses may be given, and these are taken
+	 * together as a union. Furthermore, the convention is to specify the throws
+	 * clause before the others.</li>
+	 * <li><b>Requires clause</b>. This defines a constraint on the permissible
+	 * values of the parameters on entry to the function or method, and is often
+	 * referred to as the "precondition". This expression may refer to any
+	 * variables declared within the parameter type pattern. Multiple clauses
+	 * may be given, and these are taken together as a conjunction. Furthermore,
+	 * the convention is to specify the requires clause(s) before any ensure(s)
+	 * clauses.</li>
+	 * <li><b>Ensures clause</b>. This defines a constraint on the permissible
+	 * values of the the function or method's return value, and is often
+	 * referred to as the "postcondition". This expression may refer to any
+	 * variables declared within either the parameter or return type pattern.
+	 * Multiple clauses may be given, and these are taken together as a
+	 * conjunction. Furthermore, the convention is to specify the requires
+	 * clause(s) after the others.</li>
+	 * </ul>
+	 *
+	 * <p>
+	 * The following function declaration provides a small example to
+	 * illustrate:
+	 * </p>
+	 *
+	 * <pre>
+	 * function max(int x, int y) -> (int z)
+	 * // return must be greater than either parameter
+	 * ensures x <= z && y <= z
+	 * // return must equal one of the parmaeters
+	 * ensures x == z || y == z
+	 * </pre>
+	 *
+	 * <p>
+	 * Here, we see the specification for the well-known <code>max()</code>
+	 * function which returns the largest of its parameters. This does not throw
+	 * any exceptions, and does not enforce any preconditions on its parameters.
+	 * </p>
+	 */
+	private void parseFunctionDeclaration(WyalFile wf) {
+		int start = index;
+
+		match(Function);
+		ArrayList<String> generics = new ArrayList<String>();
+		String name = parseGenericSignature(true, generics);
+		HashSet<String> genericSet = new HashSet<String>(generics);
+
+		// Parse function or method parameters
+		HashSet<String> environment = new HashSet<String>();
+		TypePattern from = parseTypePattern(genericSet, environment, true);
+		match(MinusGreater);
+		// Explicit return type is given, so parse it! We first clone the
+		// environent and create a special one only for use within ensures
+		// clauses, since these are the only expressions which may refer to
+		// variables declared in the return type.
+		HashSet<String> ensuresEnvironment = new HashSet<String>(environment);
+		TypePattern to = parseTypePattern(genericSet, ensuresEnvironment, true);
+
+		// Parse optional throws/requires/ensures clauses
+
+		ArrayList<Expr> requires = new ArrayList<Expr>();
+		Expr ensures = null;
+		// FIXME: following should be a list!
+		SyntacticType throwws = new SyntacticType.Void();
+
+		Token lookahead;
+		while ((lookahead = tryAndMatch(true, Requires, Ensures, Throws)) != null) {
+			switch (lookahead.kind) {
+			case Requires: {
+				Expr condition;
+				if (tryAndMatch(true, Colon) != null) {
+					matchEndLine();
+					condition = parseBlock(wf, genericSet, environment,
+							ROOT_INDENT);
+				} else {
+					condition = parseLogicalExpression(wf, genericSet,
+							environment, false);
+				}
+				requires.add(condition);
+				break;
+			}
+			case Ensures: {
+				// Use the ensuresEnvironment here to get access to any
+				// variables declared in the return type pattern.
+				Expr condition;
+				if (tryAndMatch(true, Colon) != null) {
+					matchEndLine();
+					condition = parseBlock(wf, genericSet, ensuresEnvironment,
+							ROOT_INDENT);
+				} else {
+					condition = parseLogicalExpression(wf, genericSet,
+							ensuresEnvironment, false);
+				}
+				if(ensures == null) {
+					ensures = condition;
+				} else {
+					ensures = new Expr.Binary(Expr.Binary.Op.AND,ensures,condition);
+				}
+				break;
+			}
+			case Throws:
+				throwws = parseType(genericSet);
+				break;
+			}
+		}
+
+		WyalFile.Declaration declaration = wf.new Function(name, generics,
+				from, to, ensures, sourceAttr(start, index - 1));
+		wf.add(declaration);
+	}
+
+	/**
+	 * Parse a type declaration in a Wyal source file, which has the form:
+	 *
+	 * <pre>
+	 * "type" Identifier "is" TypePattern ["where" Expr]
+	 * </pre>
+	 *
+	 * Here, the type pattern specifies a type which may additionally be adorned
+	 * with variable names. The "where" clause is optional and is often referred
+	 * to as the type's "constraint". Variables defined within the type pattern
+	 * may be used within this constraint expressions. A simple example to
+	 * illustrate is:
+	 *
+	 * <pre>
+	 * type nat is (int x) where x >= 0
+	 * </pre>
+	 *
+	 * Here, we are defining a <i>constrained type</i> called <code>nat</code>
+	 * which represents the set of natural numbers (i.e the non-negative
+	 * integers).
+	 *
+	 * @see wycs.syntax.WyalFile.Type
+	 *
+	 * @param wf
+	 *            --- The Wyal file in which this declaration is defined.
+	 */
+	public void parseTypeDeclaration(WyalFile wf) {
+		int start = index;
+		// Match identifier rather than kind e.g. Type to avoid "type" being a
+		// keyword.
+		match(Identifier);
+		//
+		ArrayList<String> generics = new ArrayList<String>();
+		String name = parseGenericSignature(true, generics);
+		match(Is);
+		// Parse the type pattern
+		HashSet<String> genericSet = new HashSet<String>(generics);
+		TypePattern pattern = parseTypePattern(genericSet,
+				new HashSet<String>(), false);
+
+		Expr invariant = null;
+		// Check whether or not there is an optional "where" clause.
+		if (tryAndMatch(false, Where) != null) {
+			// Yes, there is a "where" clause so parse the constraint. First,
+			// construct the environment which will be used to identify the set
+			// of declared variables in the current scope.
+			HashSet<String> environment = new HashSet<String>();
+			pattern.addDeclaredVariables(environment);
+			if (tryAndMatch(true, Colon) != null) {
+				matchEndLine();
+				invariant = parseBlock(wf, genericSet, environment, ROOT_INDENT);
+			} else {
+				invariant = parseLogicalExpression(wf, genericSet, environment,
+						false);
+			}
+		}
+
+		WyalFile.Declaration declaration = wf.new Type(name, generics, pattern,
+				invariant, sourceAttr(start, index - 1));
+		wf.add(declaration);
+		return;
+	}
+
+	/**
+	 * Parse a constant declaration in a Wyal source file, which has the form:
+	 *
+	 * <pre>
+	 * DefineDeclaration ::= "macro" Identifier "is" Expr
+	 * </pre>
+	 *
+	 * A simple example to illustrate is:
+	 *
+	 * <pre>
+	 * define PI is 3.141592654
+	 * </pre>
+	 *
+	 * Here, we are defining a constant called <code>PI</code> which represents
+	 * the decimal value "3.141592654".
+	 *
+	 * @see wycs.syntax.WyalFile.Constant
+	 *
+	 * @param wf
+	 *            The WyAL file in which this declaration is defined.
+	 */
+	private void parseMacroDeclaration(WyalFile wf) {
+		int start = index;
+		match(Define);
+
+		ArrayList<String> generics = new ArrayList<String>();
+		String name = parseGenericSignature(true, generics);
+
+		HashSet<String> genericSet = new HashSet<String>(generics);
+		HashSet<String> environment = new HashSet<String>();
+		TypePattern from = parseTypePattern(genericSet, environment, true);
+
+		match(Is);
+		Expr condition;
+
+		if (tryAndMatch(true, Colon) != null) {
+			matchEndLine();
+			condition = parseBlock(wf, genericSet, environment, ROOT_INDENT);
+		} else {
+			condition = parseLogicalExpression(wf, genericSet, environment,
+					false);
+		}
+
+		wf.add(wf.new Macro(name, generics, from, condition, sourceAttr(start,
+				index - 1)));
+	}
+
+	protected String parseGenericSignature(boolean terminated,
+			List<String> generics) {
+		String name = match(Identifier).text;
+		if (tryAndMatch(terminated, LeftAngle) != null) {
+			// generic type
+			boolean firstTime = true;
+			while (eventuallyMatch(RightAngle) == null) {
+				if (!firstTime) {
+					match(Comma);
+				}
+				firstTime = false;
+				Token id = match(Identifier);
+				String generic = id.text;
+				if (generics.contains(generic)) {
+					syntaxError("duplicate generic variable", id);
+				}
+				generics.add(generic);
+			}
+		}
+		return name;
+	}
+	
+	/**
+	 * Parse an <code>assume</code> declaration in a WyAL source file.
+	 *
+	 * @param wf
+	 *            The WyAL file in which this declaration is defined.
+	 */
+	protected void parseAssumeDeclaration(WyalFile wf) {
+		int start = index;
+		match(Assume);
+
+		// Attempt to parse the message
+		Token token = tryAndMatch(true, String);
+		String msg = token == null ? null : token.text;
+
+		// Determine whether block or expression
+		HashSet<String> generics = new HashSet<String>();
+		HashSet<String> environment = new HashSet<String>();
+		Expr condition;
+
+		if (tryAndMatch(true, Colon) != null) {
+			matchEndLine();
+			condition = parseBlock(wf, generics, environment, ROOT_INDENT);
+		} else {
+			condition = parseLogicalExpression(wf, generics, environment, false);
+		}
+
+		wf.add(wf.new Assume(msg, condition, sourceAttr(start, index - 1)));
+	}
+
+	/**
+	 * Parse an <code>assert</code> declaration in a WyAL source file.
+	 *
+	 * @param wf
+	 *            The WyAL file in which this declaration is defined.
+	 */
+	protected void parseAssertDeclaration(WyalFile wf) {
+		int start = index;
+		match(Assert);
+
+		// Attempt to parse the message
+		Token token = tryAndMatch(true, StringValue);
+		String msg = token == null ? null : token.text;
+
+		// Determine whether block or expression
+		HashSet<String> generics = new HashSet<String>();
+		HashSet<String> environment = new HashSet<String>();
+		Expr condition;
+
+		if (tryAndMatch(true, Colon) != null) {
+			matchEndLine();
+			condition = parseBlock(wf, generics, environment, ROOT_INDENT);
+		} else {
+			condition = parseLogicalExpression(wf, generics, environment, false);
+		}
+
+		wf.add(wf.new Assert(msg, condition, sourceAttr(start, index - 1)));
+	}
+
+	/**
+	 * Parse a block of zero or more "statements" which share the same
+	 * indentation level. Their indentation level must be strictly greater than
+	 * that of their parent, otherwise the end of block is signaled. The
+	 * <i>indentation level</i> for the block is set by the first statement
+	 * encountered (assuming their is one). An error occurs if a subsequent
+	 * statement is reached with an indentation level <i>greater</i> than the
+	 * block's indentation level.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed.
+	 * @param parentIndent
+	 *            The indentation level of the parent, for which all statements
+	 *            in this block must have a greater indent. May not be
+	 *            <code>null</code>.
+	 * @return
+	 */
+	private Expr parseBlock(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, Indent parentIndent) {
+
+		// We must clone the environment here, in order to ensure variables
+		// declared within this block are properly scoped.
+		environment = new HashSet<String>(environment);
+
+		// First, determine the initial indentation of this block based on the
+		// first statement (or null if there is no statement).
+		Indent indent = getIndent();
+
+		// Second, check that this is indeed the initial indentation for this
+		// block (i.e. that it is strictly greater than parent indent).
+		if (indent == null || indent.lessThanEq(parentIndent)) {
+			// Initial indent either doesn't exist or is not strictly greater
+			// than parent indent and,therefore, signals an empty block.
+			//
+			return new Expr.Constant(Value.Bool(true));
+		} else {
+			// Initial indent is valid, so we proceed parsing statements with
+			// the appropriate level of indent.
+			//
+			ArrayList<Expr> constraints = new ArrayList<Expr>();
+			Indent nextIndent;
+			while ((nextIndent = getIndent()) != null
+					&& indent.lessThanEq(nextIndent)) {
+				// At this point, nextIndent contains the indent of the current
+				// statement. However, this still may not be equivalent to this
+				// block's indentation level.
+
+				// First, check the indentation matches that for this block.
+				if (!indent.equivalent(nextIndent)) {
+					// No, it's not equivalent so signal an error.
+					syntaxError("unexpected end-of-block", indent);
+				}
+
+				// Second, parse the actual statement at this point!
+				constraints.add(parseStatement(wf, generics, environment,
+						indent));
+			}
+
+			if (constraints.size() == 0) {
+				return new Expr.Constant(Value.Bool(true));
+			} else if (constraints.size() == 1) {
+				return constraints.get(0);
+			} else {
+				Expr r = null;
+				for (Expr c : constraints) {
+					if (r == null) {
+						r = c;
+					} else {
+						r = new Expr.Binary(Expr.Binary.Op.AND, r, c,
+								c.attributes());
+					}
+				}
+				return r;
+			}
+		}
+	}
+
+	/**
+	 * Determine the indentation as given by the Indent token at this point (if
+	 * any). If none, then <code>null</code> is returned.
+	 *
+	 * @return
+	 */
+	private Indent getIndent() {
+		skipEmptyLines();
+		if (index < tokens.size()) {
+			Token token = tokens.get(index);
+			if (token.kind == Indent) {
+				return new Indent(token.text, token.start);
+			}
+			return null;
+		}
+		return null;
+	}
+
+	/**
+	 * Parse a statement expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed.
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @return
+	 */
+	private Expr parseStatement(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, Indent indent) {
+		int start = index;
+		checkNotEof();
+
+		Token lookahead = tryAndMatch(false, If, Either, Exists, Forall);
+
+		if (lookahead != null && lookahead.kind == If) {
+			return parseIfThenStatement(wf, generics, environment, indent);
+		} else if (lookahead != null && lookahead.kind == Either) {
+			return parseEitherOrStatement(wf, generics, environment, indent);
+		} else if (lookahead != null && lookahead.kind == Forall) {
+			return parseExistsForallStatement(lookahead, wf, generics,
+					environment, indent);
+		} else if (lookahead != null && lookahead.kind == Exists) {
+			return parseExistsForallStatement(lookahead, wf, generics,
+					environment, indent);
+		} else {
+			Expr stmt = parseLogicalExpression(wf, generics, environment, false);
+			matchEndLine();
+			return stmt;
+		}
+	}
+
+	/**
+	 * Parse an if-then expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed.
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @return
+	 */
+	private Expr parseIfThenStatement(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, Indent indent) {
+		int start = index;
+		match(Colon);
+		matchEndLine();
+		Expr condition = parseBlock(wf, generics, environment, indent);
+		match(Then);
+		match(Colon);
+		matchEndLine();
+		Expr body = parseBlock(wf, generics, environment, indent);
+		return new Expr.Binary(Expr.Binary.Op.IMPLIES, condition, body,
+				sourceAttr(start, index - 1));
+	}
+
+
+	private Expr parseEitherOrStatement(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, Indent indent) {
+		int start = index;
+
+		Expr condition = null;
+		Indent nextIndent;
+		Token lookahead;
+
+		do {
+			match(Colon);
+			matchEndLine();
+			Expr term = parseBlock(wf, generics, environment, indent);
+			if(condition == null) {
+				condition = term;
+			} else {
+				condition = new Expr.Binary(Expr.Binary.Op.OR, condition, term, sourceAttr(start, index - 1));
+			}
+			nextIndent = getIndent();
+			if(nextIndent != null && nextIndent.equivalent(indent)) {
+				lookahead = tryAndMatch(false, Or);
+			} else {
+				lookahead = null;
+			}
+		} while (lookahead != null && lookahead.kind == Or);
+
+		return condition;
+	}
+
+	/**
+	 * Parse a quantifier expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed.
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @return
+	 */
+	private Expr parseExistsForallStatement(Token lookahead, WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment, Indent indent) {
+		int start = index - 1;
+
+		// Clone the environment here, since the following type pattern may
+		// updated this and such updates should only be visible to the
+		// conditions contained within the quantified statement.
+		environment = new HashSet<String>(environment);
+
+		TypePattern pattern = parseTypePattern(generics, environment, true);
+		Expr condition;
+
+		if (tryAndMatch(true, Colon) != null) {
+			matchEndLine();
+			condition = parseBlock(wf, generics, environment, ROOT_INDENT);
+		} else {
+			match(SemiColon);
+			condition = parseLogicalExpression(wf, generics, environment, false);
+		}
+
+		if (lookahead.kind == Exists) {
+			return new Expr.Exists(pattern, condition, sourceAttr(start,
+					index - 1));
+		} else {
+			return new Expr.ForAll(pattern, condition, sourceAttr(start,
+					index - 1));
+		}
+	}
+
+	/**
+	 * Parse a tuple expression, which has the form:
+	 *
+	 * <pre>
+	 * TupleExpr::= Expr (',' Expr)*
+	 * </pre>
+	 *
+	 * Tuple expressions are expressions which can return multiple values (i.e.
+	 * tuples). In many situations, tuple expressions are not permitted since
+	 * tuples cannot be used in that context.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed.
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseMultiExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		Expr lhs = parseUnitExpression(wf, generics, environment, terminated);
+
+		if (tryAndMatch(terminated, Comma) != null) {
+			// Indicates this is a tuple expression.
+			ArrayList<Expr> elements = new ArrayList<Expr>();
+			elements.add(lhs);
+			// Add all expressions separated by a comma
+			do {
+				elements.add(parseUnitExpression(wf, generics, environment,
+						terminated));
+			} while (tryAndMatch(terminated, Comma) != null);
+			// Done
+			return new Expr.Nary(Expr.Nary.Op.TUPLE, elements, sourceAttr(
+					start, index - 1));
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Parse a unit expression, which has the form:
+	 *
+	 * <pre>
+	 * UnitExpr::= LogicalExpression
+	 * </pre>
+	 *
+	 * <p>
+	 * A unit expression is essentially any expression, except that it is not
+	 * allowed to be a tuple expression. More specifically, it cannot be
+	 * followed by ',' (e.g. because the enclosing context uses ',').
+	 * </p>
+	 *
+	 * <p>
+	 * As an example consider a record expression, such as
+	 * <code>{x: e1, y: e2}</code>. Here, the sub-expression "e1" must be a
+	 * non-tuple expression since it is followed by ',' to signal the start of
+	 * the next field "y". Of course, e1 can be a tuple expression if we use
+	 * brackets as these help disambiguate the context.
+	 * </p>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 * @return
+	 */
+	private Expr parseUnitExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		return parseLogicalExpression(wf, generics, environment, terminated);
+	}
+
+	/**
+	 * Parse a logical expression of the form:
+	 *
+	 * <pre>
+	 * Expr ::= AndOrExpr [ "==>" UnitExpr]
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseLogicalExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		checkNotEof();
+		int start = index;
+		Expr lhs = parseAndOrExpression(wf, generics, environment, terminated);
+		Token lookahead = tryAndMatch(terminated, LogicalImplication,
+				LogicalIff);
+		if (lookahead != null) {
+			switch (lookahead.kind) {
+
+			case LogicalImplication: {
+				Expr rhs = parseUnitExpression(wf, generics, environment,
+						terminated);
+				return new Expr.Binary(Expr.Binary.Op.IMPLIES, lhs, rhs,
+						sourceAttr(start, index - 1));
+			}
+			case LogicalIff: {
+				Expr rhs = parseUnitExpression(wf, generics, environment,
+						terminated);
+				return new Expr.Binary(Expr.Binary.Op.IFF, lhs, rhs,
+						sourceAttr(start, index - 1));
+			}
+			default:
+				throw new RuntimeException("deadcode"); // dead-code
+			}
+
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Parse a logical expression of the form:
+	 *
+	 * <pre>
+	 * Expr ::= ConditionExpr [ ( "&&" | "||" ) Expr]
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseAndOrExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		checkNotEof();
+		int start = index;
+		Expr lhs = parseBitwiseOrExpression(wf, generics, environment,
+				terminated);
+		Token lookahead = tryAndMatch(terminated, LogicalAnd, LogicalOr);
+		if (lookahead != null) {
+			Expr.Binary.Op bop;
+			switch (lookahead.kind) {
+			case LogicalAnd:
+				bop = Expr.Binary.Op.AND;
+				break;
+			case LogicalOr:
+				bop = Expr.Binary.Op.OR;
+				break;
+			default:
+				throw new RuntimeException("deadcode"); // dead-code
+			}
+			Expr rhs = parseAndOrExpression(wf, generics, environment,
+					terminated);
+			return new Expr.Binary(bop, lhs, rhs, sourceAttr(start, index - 1));
+		}
+
+		return lhs;
+	}
+
+	private Expr parseBitwiseOrExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		// TODO
+		return parseBitwiseXorExpression(wf, generics, environment, terminated);
+	}
+
+	private Expr parseBitwiseXorExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		return parseBitwiseAndExpression(wf, generics, environment, terminated);
+	}
+
+	private Expr parseBitwiseAndExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		return parseConditionExpression(wf, generics, environment, terminated);
+	}
+
+	/**
+	 * Parse a condition expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseConditionExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		int start = index;
+		Token lookahead;
+
+		// First, attempt to parse quantifiers (e.g. some, all, no, etc)
+		if ((lookahead = tryAndMatch(terminated, Exists, Forall)) != null) {
+			return parseQuantifierExpression(lookahead, wf, generics,
+					environment, terminated);
+		}
+
+		Expr lhs = parseAdditiveExpression(wf, generics, environment, terminated);
+
+		lookahead = tryAndMatch(terminated, LessEquals, LeftAngle,
+				GreaterEquals, RightAngle, EqualsEquals, NotEquals, In, Is,
+				Subset, SubsetEquals, Superset, SupersetEquals);
+
+		if (lookahead != null) {
+			Expr.Binary.Op bop;
+			switch (lookahead.kind) {
+			case LessEquals:
+				bop = Expr.Binary.Op.LTEQ;
+				break;
+			case LeftAngle:
+				bop = Expr.Binary.Op.LT;
+				break;
+			case GreaterEquals:
+				bop = Expr.Binary.Op.GTEQ;
+				break;
+			case RightAngle:
+				bop = Expr.Binary.Op.GT;
+				break;
+			case EqualsEquals:
+				bop = Expr.Binary.Op.EQ;
+				break;
+			case NotEquals:
+				bop = Expr.Binary.Op.NEQ;
+				break;			
+			case Is:
+				// We handle this one slightly differently because the
+				// right-hand side is not an expression.
+				SyntacticType rhs = parseType(generics);
+				return new Expr.Is(lhs,rhs,sourceAttr(start,index-1));	
+			default:
+				syntaxError("Unknown binary operator: " + lookahead.kind,lookahead); // dead-code
+				return null;
+			}
+
+			Expr rhs = parseAdditiveExpression(wf, generics, environment,
+					terminated);
+			return new Expr.Binary(bop, lhs, rhs, sourceAttr(start, index - 1));
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Parse a quantifier expression, which is of the form:
+	 *
+	 * <pre>
+	 * QuantExpr ::= ("no" | "some" | "all")
+	 *               '{'
+	 *                   Identifier "in" Expr (',' Identifier "in" Expr)+
+	 *                   '|' LogicalExpr
+	 *               '}'
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @param environment
+	 * @return
+	 */
+	private Expr parseQuantifierExpression(Token lookahead, WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		int start = index - 1;
+
+		// Parse one or more source variables / expressions
+		environment = new HashSet<String>(environment);
+		TypePattern pattern = parseTypePattern(generics, environment,
+				terminated);
+		match(SemiColon);
+		Expr condition = parseLogicalExpression(wf, generics, environment,
+				terminated);
+
+		switch (lookahead.kind) {
+		case Forall:
+			return new Expr.ForAll(pattern, condition, sourceAttr(start,
+					index - 1));
+		case Exists:
+			return new Expr.Exists(pattern, condition, sourceAttr(start,
+					index - 1));
+		default:
+			syntaxError("unknown quantifier kind", lookahead);
+			return null;
+		}
+	}	
+		
+	/**
+	 * Parse an additive expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseAdditiveExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		Expr lhs = parseMultiplicativeExpression(wf, generics, environment,
+				terminated);
+
+		Token lookahead;
+		while ((lookahead = tryAndMatch(terminated, Plus, Minus)) != null) {
+			Expr.Binary.Op bop;
+			switch (lookahead.kind) {
+			case Plus:
+				bop = Expr.Binary.Op.ADD;
+				break;
+			case Minus:
+				bop = Expr.Binary.Op.SUB;
+				break;
+			default:
+				throw new RuntimeException("deadcode"); // dead-code
+			}
+
+			Expr rhs = parseMultiplicativeExpression(wf, generics, environment,
+					terminated);
+			lhs = new Expr.Binary(bop, lhs, rhs, sourceAttr(start, index - 1));
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Parse a multiplicative expression.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseMultiplicativeExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		int start = index;
+		Expr lhs = parseAccessExpression(wf, generics, environment, terminated);
+
+		Token lookahead = tryAndMatch(terminated, Star, RightSlash, Percent);
+		if (lookahead != null) {
+			Expr.Binary.Op bop;
+			switch (lookahead.kind) {
+			case Star:
+				bop = Expr.Binary.Op.MUL;
+				break;
+			case RightSlash:
+				bop = Expr.Binary.Op.DIV;
+				break;
+			case Percent:
+				bop = Expr.Binary.Op.REM;
+				break;
+			default:
+				throw new RuntimeException("deadcode"); // dead-code
+			}
+			Expr rhs = parseAccessExpression(wf, generics, environment,
+					terminated);
+			return new Expr.Binary(bop, lhs, rhs, sourceAttr(start, index - 1));
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Parse an <i>access expression</i>, which has the form:
+	 *
+	 * <pre>
+	 * AccessExpr::= PrimaryExpr
+	 *            | AccessExpr '[' AdditiveExpr ']'
+	 *            | AccessExpr '[' AdditiveExpr ".." AdditiveExpr ']'
+	 *            | AccessExpr '.' Identifier
+	 *            | AccessExpr '.' Identifier '(' [ Expr (',' Expr)* ] ')'
+	 *            | AccessExpr "->" Identifier
+	 * </pre>
+	 *
+	 * <p>
+	 * Access expressions are challenging for several reasons. First, they are
+	 * <i>left-recursive</i>, making them more difficult to parse correctly.
+	 * Secondly, there are several different forms above and, of these, some
+	 * generate multiple AST nodes as well (see below).
+	 * </p>
+	 *
+	 * <p>
+	 * This parser attempts to construct the most accurate AST possible and this
+	 * requires disambiguating otherwise identical forms. For example, an
+	 * expression of the form "aaa.bbb.ccc" can correspond to either a field
+	 * access, or a constant expression (e.g. with a package/module specifier).
+	 * Likewise, an expression of the form "aaa.bbb.ccc()" can correspond to an
+	 * indirect function/method call, or a direct function/method call with a
+	 * package/module specifier. To disambiguate these forms, the parser relies
+	 * on the fact any sequence of field-accesses must begin with a local
+	 * variable.
+	 * </p>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseAccessExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		Expr lhs = parseTermExpression(wf, generics, environment, terminated);
+		Token token;
+
+		while ((token = tryAndMatchOnLine(LeftSquare)) != null
+				|| (token = tryAndMatch(terminated, Dot)) != null) {
+			switch (token.kind) {
+			case LeftSquare:
+				// At this point, there are two possibilities: an access
+				// expression (e.g. x[i]), or a list update (e.g. xs[a:=b]). We have to disambiguate these four different
+				// possibilities.
+				// NOTE: expression guaranteed to be terminated by ']'.
+				Expr rhs = parseAdditiveExpression(wf, generics, environment, true);				
+				match(RightSquare);
+				lhs = new Expr.IndexOf(lhs, rhs, sourceAttr(start,
+						index - 1));
+				break;
+			case Dot:				
+				// At this point, we could have a field access, a package access
+				// or a method/function invocation. Therefore, we start by
+				// parsing the field access and then check whether or not its an
+				// invocation.
+				List<SyntacticType> genericArguments = Collections.EMPTY_LIST;
+				if(canMatch(terminated, LeftAngle) != null) {
+					// This indicates a direct or indirect invocation with
+					// generic arguments supplied.
+					 genericArguments = parseGenericArguments(wf,generics);
+				}
+				String name = match(Identifier).text;
+				// This indicates we have either a direct or indirect access or
+				// invocation. We can disambiguate between these two categories
+				// by examining what we have parsed already. A direct access or
+				// invocation requires a sequence of identifiers where the first
+				// is not a declared variable name.
+				Path.ID id = parsePossiblePathID(lhs, environment);
+
+				if (canMatch(terminated, LeftBrace) != null) {
+					// This indicates a direct or indirect invocation. First,
+					// parse arguments to invocation
+					Expr argument = parseInvocationArgument(wf, generics,
+							environment);
+					// Second, determine what kind of invocation we have.
+					if (id == null) {
+						// This indicates we have an indirect invocation
+						lhs = new Expr.FieldAccess(lhs, name, sourceAttr(start,
+								index - 1));
+						lhs = new Expr.IndirectInvoke(lhs,
+								genericArguments, argument,
+								sourceAttr(start, index - 1));
+					} else {
+						// This indicates we have an direct invocation
+						lhs = new Expr.Invoke(name, id,
+								genericArguments, argument,
+								sourceAttr(start, index - 1));
+					}
+
+				} else if (id != null) {				
+					// Must be a qualified constant access
+					lhs = new Expr.ConstantAccess(name, id, sourceAttr(start,
+							index - 1));
+				} else {
+					// Must be a plain old field access.
+					lhs = new Expr.FieldAccess(lhs, name, sourceAttr(start,
+							index - 1));
+				}
+			}
+		}
+
+		return lhs;
+	}
+
+	/**
+	 * Attempt to parse a possible module identifier. This will reflect a true
+	 * module identifier only if the root variable is not in the given
+	 * environment.
+	 *
+	 * @param src
+	 * @param environment
+	 * @return
+	 */
+	private Path.ID parsePossiblePathID(Expr src, HashSet<String> environment) {
+		if (src instanceof Expr.Variable) {
+			// this is a local variable, indicating that the we did not have
+			// a module identifier.
+			return null;
+		} else if (src instanceof Expr.ConstantAccess) {
+			Expr.ConstantAccess ca = (Expr.ConstantAccess) src;	
+			if(ca.qualification == null) {
+				return Trie.ROOT.append(ca.name);
+			} else {
+				return ca.qualification.append(ca.name);
+			}
+		} else if (src instanceof Expr.FieldAccess) {
+			Expr.FieldAccess ada = (Expr.FieldAccess) src;
+			Path.ID id = parsePossiblePathID(ada.operand, environment);
+			if (id != null) {
+				return id.append(ada.name);
+			} else {
+				return null;
+			}
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseTermExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		checkNotEof();
+
+		int start = index;
+		Token token = tokens.get(index);
+
+		switch (token.kind) {
+		case LeftBrace:
+			return parseBracketedExpression(wf, generics, environment,
+					terminated);
+		case Identifier:
+			match(Identifier);
+			if (isFunctionCall()) {
+				return parseInvokeExpression(wf, generics, environment, start,
+						token, terminated);
+			} else if (environment.contains(token.text)) {
+				// Signals a local variable access
+				return new Expr.Variable(token.text, sourceAttr(start,
+						index - 1));
+			} else {
+				// Otherwise, this must be a constant access of some kind.
+				// Observe that, at this point, we cannot determine whether or
+				// not this is a constant-access or a package-access which marks
+				// the beginning of a constant-access.
+				return new Expr.ConstantAccess(token.text, null, sourceAttr(
+						start, index - 1));
+			}
+		case Null:
+			return new Expr.Constant(Value.Null, sourceAttr(start, index++));
+		case True:
+			return new Expr.Constant(Value.Bool(true), sourceAttr(start,
+					index++));
+		case False:
+			return new Expr.Constant(Value.Bool(false), sourceAttr(start,
+					index++));
+		case CharValue: {
+			char c = parseCharacter(token.text);
+			BigInteger v = BigInteger.valueOf(c);
+			// TODO: might make sense to have a Value.Char
+			return new Expr.Constant(Value.Integer(v), sourceAttr(start,
+					index++));
+		}
+		case IntValue: {
+			BigInteger val = new BigInteger(token.text);
+			return new Expr.Constant(Value.Integer(val), sourceAttr(start,
+					index++));
+		}
+		case RealValue: {
+			BigDecimal val = new BigDecimal(token.text);
+			return new Expr.Constant(Value.Decimal(val), sourceAttr(start,
+					index++));
+		}
+		case StringValue: {
+			String str = parseString(token.text);
+			return new Expr.Constant(Value.String(str), sourceAttr(start,
+					index++));
+		}
+		case Minus:
+			return parseNegationExpression(wf, generics, environment,
+					terminated);
+		case VerticalBar:
+			return parseLengthOfExpression(wf, generics, environment,
+					terminated);
+		case LeftSquare:
+			return parseArrayExpression(wf, generics, environment, terminated);
+		case LeftCurly:
+			return parseRecordExpression(wf, generics, environment,
+					terminated);
+		case Shreak:
+			return parseLogicalNotExpression(wf, generics, environment,
+					terminated);
+		}
+
+		syntaxError("unrecognised term", token);
+		return null;
+	}
+
+	/**
+	 * Parse an expression beginning with a left brace. This is either a cast or
+	 * bracketed expression:
+	 *
+	 * <pre>
+	 * BracketedExpr ::= '(' Type ')' Expr
+	 *                      | '(' Expr ')'
+	 * </pre>
+	 *
+	 * <p>
+	 * The challenge here is to disambiguate the two forms (which is similar to
+	 * the problem of disambiguating a variable declaration from e.g. an
+	 * assignment). Getting this right is actually quite tricky, and we need to
+	 * consider what permissible things can follow a cast and/or a bracketed
+	 * expression. To simplify things, we only consider up to the end of the
+	 * current line in determining whether this is a cast or not. That means
+	 * that the expression following a cast *must* reside on the same line as
+	 * the cast.
+	 * </p>
+	 *
+	 * <p>
+	 * A cast can be followed by the start of any valid expression. This
+	 * includes: identifiers (e.g. "(T) x"), braces of various kinds (e.g.
+	 * "(T) [1,2]" or "(T) (1,2)"), unary operators (e.g. "(T) !x", "(T) |xs|",
+	 * etc). A bracketed expression, on the other hand, can be followed by a
+	 * binary operator (e.g. "(e) + 1"), a left- or right-brace (e.g.
+	 * "(1 + (x+1))" or "(*f)(1)") or a newline.
+	 * </p>
+	 * <p>
+	 * Most of these are easy to disambiguate by the following rules:
+	 * </p>
+	 * <ul>
+	 * <li>If what follows is a binary operator (e.g. +, -, etc) then this is an
+	 * bracketed expression, not a cast.</li>
+	 * <li>If what follows is a right-brace then this is a bracketed expression,
+	 * not a cast.</li>
+	 * <li>Otherwise, this is a cast.</li>
+	 * </ul>
+	 * <p>
+	 * Unfortunately, there are two problematic casts: '-' and '('. In Java, the
+	 * problem of '-' is resolved carefully as follows:
+	 * </p>
+	 *
+	 * <pre>
+	 * CastExpr::= ( PrimitiveType Dimsopt ) UnaryExpression
+	 *                 | ( ReferenceType ) UnaryExpressionNotPlusMinus
+	 * </pre>
+	 *
+	 * See JLS 15.16 (Cast Expressions). This means that, in cases where we can
+	 * be certain we have a type, then a general expression may follow;
+	 * otherwise, only a restricted expression may follow.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseBracketedExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		int start = index;
+		match(LeftBrace);
+
+		// At this point, we must begin to disambiguate casts from general
+		// bracketed expressions. In the case that what follows the left brace
+		// is something which can only be a type, then clearly we have a cast.
+		// However, in the other case, we may still have a cast since many types
+		// cannot be clearly distinguished from expressions at this stage (e.g.
+		// "(nat,nat)" could either be a tuple type (if "nat" is a type) or a
+		// tuple expression (if "nat" is a variable or constant).
+
+		SyntacticType t = parseDefiniteType(generics);
+
+		if (t != null) {
+			// At this point, it's looking likely that we have a cast. However,
+			// it's not certain because of the potential for nested braces. For
+			// example, consider "((char) x + y)". We'll parse the outermost
+			// brace and what follows *must* be parsed as either a type, or
+			// bracketed type.
+			if (tryAndMatch(true, RightBrace) != null) {
+				// Ok, finally, we are sure that it is definitely a cast.
+				Expr e = parseMultiExpression(wf, generics, environment,
+						terminated);
+				return new Expr.Cast(t, e, sourceAttr(start, index - 1));
+			}
+		}
+		// We still may have either a cast or a bracketed expression, and we
+		// cannot tell which yet.
+		index = start;
+		match(LeftBrace);
+		Expr e = parseMultiExpression(wf, generics, environment, true);
+		match(RightBrace);
+
+		// At this point, we now need to examine what follows to see whether
+		// this is a cast or bracketed expression. See JavaDoc comments
+		// above for more on this. What we do is first skip any whitespace,
+		// and then see what we've got.
+		int next = skipLineSpace(index);
+		if (next < tokens.size()) {
+			Token lookahead = tokens.get(next);
+
+			switch (lookahead.kind) {
+			case Null:
+			case True:
+			case False:
+			case CharValue:
+			case IntValue:
+			case RealValue:
+			case StringValue:
+			case LeftCurly:
+
+				// FIXME: there is a bug here when parsing a quantified
+				// expression such as
+				//
+				// "all { i in 0 .. (|items| - 1) | items[i] < items[i + 1] }"
+				//
+				// This is because the trailing vertical bar makes it look
+				// like this is a cast.
+
+			case LeftBrace:
+			case VerticalBar:
+			case Shreak:
+			case Identifier: {
+				// Ok, this must be cast so back track and reparse
+				// expression as a type.
+				index = start; // backtrack
+				SyntacticType type = parseUnitType(generics);
+				// Now, parse cast expression
+				e = parseUnitExpression(wf, generics, environment, terminated);
+				return new Expr.Cast(type, e, sourceAttr(start, index - 1));
+			}
+			default:
+				// default case, fall through and assume bracketed
+				// expression
+			}
+		}
+		// Assume bracketed
+		return e;
+	}
+
+	/**
+	 * Parse a list constructor expression, which is of the form:
+	 *
+	 * <pre>
+	 * ListExpr ::= '[' [ Expr (',' Expr)* ] ']'
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseArrayExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		match(LeftSquare);
+		ArrayList<Expr> exprs = new ArrayList<Expr>();
+
+		boolean firstTime = true;
+		boolean isArray = true;
+		while (eventuallyMatch(RightSquare) == null) {
+			if (!firstTime) {
+				if(!isArray) {
+					// Force failure
+					match(RightSquare);
+				} else  if(tryAndMatch(true,SemiColon) == null) {
+					match(Comma);
+				} else {
+					// This indicates an array
+					isArray = false;
+				}
+			}
+			firstTime = false;
+			// NOTE: we require the following expression be a "non-tuple"
+			// expression. That is, it cannot be composed using ',' unless
+			// braces enclose the entire expression. This is because the outer
+			// list constructor expression is used ',' to distinguish elements.
+			// Also, expression is guaranteed to be terminated, either by ']' or
+			// ','.
+			exprs.add(parseUnitExpression(wf, generics, environment, true));
+		}
+
+		if (isArray) {
+			return new Expr.Nary(Expr.Nary.Op.ARRAY, exprs, sourceAttr(start, index - 1));
+		} else {
+			return new Expr.Binary(Expr.Binary.Op.ARRAYGEN, exprs.get(0), exprs.get(1), sourceAttr(start, index - 1));
+		}
+	}
+
+	/**
+	 * Parse a record constructor, which is of the form:
+	 *
+	 * <pre>
+	 * RecordExpr ::= '{' Identifier ':' Expr (',' Identifier ':' Expr)* '}'
+	 * </pre>
+	 *
+	 * During parsing, we additionally check that each identifier is unique;
+	 * otherwise, an error is reported.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseRecordExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		match(LeftCurly);
+		HashSet<String> keys = new HashSet<String>();
+		ArrayList<Pair<String, Expr>> exprs = new ArrayList<Pair<String, Expr>>();
+
+		boolean firstTime = true;
+		while (eventuallyMatch(RightCurly) == null) {
+			if (!firstTime) {
+				match(Comma);
+			}
+			firstTime = false;
+			// Parse field name being constructed
+			Token n = match(Identifier);
+			// Check field name is unique
+			if (keys.contains(n.text)) {
+				syntaxError("duplicate tuple key", n);
+			}
+			match(Colon);
+			// Parse expression being assigned to field
+			// NOTE: we require the following expression be a "non-tuple"
+			// expression. That is, it cannot be composed using ',' unless
+			// braces enclose the entire expression. This is because the outer
+			// record constructor expression is used ',' to distinguish fields.
+			// Also, expression is guaranteed to be terminated, either by '}' or
+			// ','.
+			Expr e = parseUnitExpression(wf, generics, environment, true);
+			exprs.add(new Pair<String, Expr>(n.text, e));
+			keys.add(n.text);
+		}
+
+		return new Expr.Record(exprs, sourceAttr(start, index - 1));
+	}
+
+	/**
+	 * Parse a length of expression, which is of the form:
+	 *
+	 * <pre>
+	 * TermExpr::= ...
+	 *                 |  '|' Expr '|'
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseLengthOfExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		match(VerticalBar);
+		// We have to parse an Append Expression here, which is the most general
+		// form of expression that can generate a collection of some kind. All
+		// expressions higher up (e.g. logical expressions) cannot generate
+		// collections. Furthermore, the bitwise or expression could lead to
+		// ambiguity and, hence, we bypass that an consider append expressions
+		// only. However, the expression is guaranteed to be terminated by '|'.
+		Expr e = parseAdditiveExpression(wf, generics, environment, true);
+		match(VerticalBar);
+		return new Expr.Unary(Expr.Unary.Op.LENGTHOF, e, sourceAttr(start,
+				index - 1));
+	}
+
+	/**
+	 * Parse a negation expression, which is of the form:
+	 *
+	 * <pre>
+	 * TermExpr::= ...
+	 *                 |  '-' Expr
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseNegationExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		match(Minus);
+		Expr e = parseAccessExpression(wf, generics, environment, terminated);
+
+		// FIXME: we shouldn't be doing constant folding here, as it's
+		// unnecessary at this point and should be performed later during
+		// constant propagation.
+
+		if (e instanceof Expr.Constant) {
+			Expr.Constant c = (Expr.Constant) e;
+			if (c.value instanceof Value.Decimal) {
+				BigDecimal br = ((Value.Decimal) c.value).value;
+				return new Expr.Constant(Value.Decimal(br.negate()),
+						sourceAttr(start, index));
+			}
+		}
+
+		return new Expr.Unary(Expr.Unary.Op.NEG, e, sourceAttr(start, index));
+	}
+
+	/**
+	 * Parse an invocation expression, which has the form:
+	 *
+	 * <pre>
+	 * InvokeExpr::= Identifier '(' [ Expr (',' Expr)* ] ')'
+	 * </pre>
+	 *
+	 * Observe that this when this function is called, we're assuming that the
+	 * identifier and opening brace has already been matched.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseInvokeExpression(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment, int start, Token name,
+			boolean terminated) {
+		// First, parse the generic arguments (if any) to this invocation.
+		ArrayList<SyntacticType> types = parseGenericArguments(wf, generics);
+
+		// Second, parse the arguments to this invocation.
+		Expr argument = parseInvocationArgument(wf, generics, environment);
+
+		// unqualified direct invocation
+		return new Expr.Invoke(name.text, null, types, argument, sourceAttr(
+				start, index - 1));
+	}
+
+	/**
+	 * <p>
+	 * This function is called during parsing an expression after matching an
+	 * identifier. The goal is to determine whether what follows the identifier
+	 * indicates an invocation expression, or whether the identifier is just a
+	 * variable access of some sort.
+	 * </p>
+	 * <p>
+	 * Unfortunately, this function is rather "low-level". Essentially, it just
+	 * moves forwards through the tokens on the current line counting the nestng
+	 * level of any generic arguments it encounters. At the end, it looks to see
+	 * whether or not a left brace is present as, in this position, we can only
+	 * have an invocation.
+	 * </p>
+	 *
+	 * @return
+	 */
+	private boolean isFunctionCall() {
+		// First, attempt to parse a generic argument list if one exists.
+		int myIndex = this.index;
+
+		myIndex = skipLineSpace(myIndex);
+
+		if (myIndex < tokens.size() && tokens.get(myIndex).kind == LeftAngle) {
+			// This signals either an expression involving an inequality, or the
+			// start of a sequence of generic parameters. The goal now is to
+			// determine which it is. The complicating factor is that we must
+			// respect the nesting of generic type lists.
+			int count = 1;
+			myIndex = myIndex + 1;
+
+			while (myIndex < tokens.size() && count > 0) {
+				Token token = tokens.get(myIndex);
+				switch(token.kind) {
+				case LeftAngle:
+					count++;
+					break;
+				case RightAngle:
+					count--;
+					break;
+				case NewLine:
+					// In this case, we've prematurely reached the end of the
+					// line and, hence, this cannot be an invocation.
+					return false;
+				}
+				myIndex = skipLineSpace(myIndex+1);
+			}
+			// Check whether we finished parsing the nested generic arguments or
+			// not.
+			if (count != 0) {
+				// No, we must have reached the end of the file prematurely.
+				return false;
+			}
+		}
+
+		return myIndex < tokens.size() && tokens.get(myIndex).kind == LeftBrace;
+	}
+
+	/**
+	 * Parse a sequence of arguments separated by commas that ends in a
+	 * right-brace:
+	 *
+	 * <pre>
+	 * ArgumentList ::= [ Expr (',' Expr)* ] ')'
+	 * </pre>
+	 *
+	 * Note, when this function is called we're assuming the left brace was
+	 * already parsed.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private ArrayList<SyntacticType> parseGenericArguments(WyalFile wf,
+			HashSet<String> generics) {
+		ArrayList<SyntacticType> arguments = new ArrayList<SyntacticType>();
+		if (tryAndMatch(true, LeftAngle) != null) {
+			// generic arguments...
+			boolean firstTime = true;
+			while (eventuallyMatch(RightAngle) == null) {
+				if (!firstTime) {
+					match(Comma);
+				}
+				firstTime = false;
+				// Note, we have to parse a unit type here since comma's are
+				// already being used to separate the generic argument list.
+				arguments.add(parseUnitType(generics));
+			}
+		}
+
+		return arguments;
+	}
+
+	/**
+	 * Parse a sequence of arguments separated by commas that ends in a
+	 * right-brace:
+	 *
+	 * <pre>
+	 * ArgumentList ::= [ Expr (',' Expr)* ] ')'
+	 * </pre>
+	 *
+	 * Note, when this function is called we're assuming the left brace was
+	 * already parsed.
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @return
+	 */
+	private Expr parseInvocationArgument(WyalFile wf, HashSet<String> generics,
+			HashSet<String> environment) {
+		int start = index;
+
+		match(LeftBrace);
+
+		boolean firstTime = true;
+		ArrayList<Expr> args = new ArrayList<Expr>();
+		while (eventuallyMatch(RightBrace) == null) {
+			if (!firstTime) {
+				match(Comma);
+			} else {
+				firstTime = false;
+			}
+			// NOTE: we require the following expression be a "non-tuple"
+			// expression. That is, it cannot be composed using ',' unless
+			// braces enclose the entire expression. This is because the outer
+			// invocation expression is used ',' to distinguish arguments.
+			// However, expression is guaranteed to be terminated either by ')'
+			// or by ','.
+			Expr e = parseUnitExpression(wf, generics, environment, true);
+
+			args.add(e);
+		}
+
+		if (args.size() == 1) {
+			return args.get(0);
+		} else {
+			return new Expr.Nary(Expr.Nary.Op.TUPLE, args, sourceAttr(start,
+					index - 1));
+		}
+	}
+
+	/**
+	 * Parse a logical not expression, which has the form:
+	 *
+	 * <pre>
+	 * TermExpr::= ...
+	 *       | '!' Expr
+	 * </pre>
+	 *
+	 * @param wf
+	 *            The enclosing WyalFile being constructed. This is necessary to
+	 *            construct some nested declarations (e.g. parameters for
+	 *            lambdas)
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            The set of declared variables visible in the enclosing scope.
+	 *            This is necessary to identify local variables within this
+	 *            expression.
+	 * @param terminated
+	 *            This indicates that the expression is known to be terminated
+	 *            (or not). An expression that's known to be terminated is one
+	 *            which is guaranteed to be followed by something. This is
+	 *            important because it means that we can ignore any newline
+	 *            characters encountered in parsing this expression, and that
+	 *            we'll never overrun the end of the expression (i.e. because
+	 *            there's guaranteed to be something which terminates this
+	 *            expression). A classic situation where terminated is true is
+	 *            when parsing an expression surrounded in braces. In such case,
+	 *            we know the right-brace will always terminate this expression.
+	 *
+	 * @return
+	 */
+	private Expr parseLogicalNotExpression(WyalFile wf,
+			HashSet<String> generics, HashSet<String> environment,
+			boolean terminated) {
+		int start = index;
+		match(Shreak);
+		// Note: cannot parse unit expression here, because that messes up the
+		// precedence. For example, !result ==> other should be parsed as
+		// (!result) ==> other, not !(result ==> other).
+		Expr expression = parseConditionExpression(wf, generics, environment,
+				terminated);
+		return new Expr.Unary(Expr.Unary.Op.NOT, expression, sourceAttr(start,
+				index - 1));
+	}
+
+	/**
+	 * Attempt to parse something which maybe a type, or an expression. The
+	 * semantics of this function dictate that it returns an instanceof
+	 * SyntacticType *only* if what it finds *cannot* be parsed as an
+	 * expression, but can be parsed as a type. Otherwise, the state is left
+	 * unchanged.
+	 *
+	 * @return An instance of SyntacticType or null.
+	 */
+	public SyntacticType parseDefiniteType(HashSet<String> generics) {
+		int start = index; // backtrack point
+		try {
+			SyntacticType type = parseType(generics);
+			if (mustParseAsType(type)) {
+				return type;
+			}
+		} catch (SyntaxError e) {
+
+		}
+		index = start; // backtrack
+		return null;
+	}
+
+	/**
+	 * <p>
+	 * Determine whether or not the given type can be parsed as an expression.
+	 * In many cases, a type can (e.g. <code>{x}</code> is both a valid type and
+	 * expression). However, some types are not also expressions (e.g.
+	 * <code>int</code>, <code>{int f}</code>, <code>&int</code>, etc).
+	 * </p>
+	 *
+	 * <p>
+	 * This function *must* return false if what the given type could not be
+	 * parsed as an expression. However, if what it can be parsed as an
+	 * expression, then this function must return false (even if we will
+	 * eventually treat this as a type). This function is called from either the
+	 * beginning of a statement (i.e. to disambiguate variable declarations), or
+	 * after matching a left brace (i.e. to disambiguate casts).
+	 * </p>
+	 *
+	 * @param index
+	 *            Position in the token stream to begin looking from.
+	 * @return
+	 */
+	private boolean mustParseAsType(SyntacticType type) {
+
+		if (type instanceof SyntacticType.Primitive) {
+			// All primitive types must be parsed as types, since their
+			// identifiers are keywords.
+			return true;
+		} else if (type instanceof SyntacticType.Record) {
+			// Record types must be parsed as types, since e.g. {int f} is not a
+			// valid expression.
+			return true;
+		} else if (type instanceof SyntacticType.Tuple) {
+			SyntacticType.Tuple tt = (SyntacticType.Tuple) type;
+			boolean result = false;
+			for (SyntacticType element : tt.elements) {
+				result |= mustParseAsType(element);
+			}
+			return result;
+		} else if (type instanceof SyntacticType.Function) {
+			SyntacticType.Function tt = (SyntacticType.Function) type;
+			boolean result = false;
+			for (SyntacticType element : tt.paramTypes) {
+				result |= mustParseAsType(element);
+			}
+			return result | mustParseAsType(tt.ret);
+		} else if (type instanceof SyntacticType.Intersection) {
+			SyntacticType.Intersection tt = (SyntacticType.Intersection) type;
+			boolean result = false;
+			for (SyntacticType element : tt.elements) {
+				result |= mustParseAsType(element);
+			}
+			return result;
+		} else if (type instanceof SyntacticType.List) {
+			SyntacticType.List tt = (SyntacticType.List) type;
+			return mustParseAsType(tt.element);
+		} else if (type instanceof SyntacticType.Negation) {
+			SyntacticType.Negation tt = (SyntacticType.Negation) type;
+			return mustParseAsType(tt.element);
+		} else if (type instanceof SyntacticType.Nominal) {
+			return false; // always can be an expression
+		} else if (type instanceof SyntacticType.Reference) {
+			SyntacticType.Reference tt = (SyntacticType.Reference) type;
+			return mustParseAsType(tt.element);
+		} else if (type instanceof SyntacticType.Union) {
+			SyntacticType.Union tt = (SyntacticType.Union) type;
+			boolean result = false;
+			for (SyntacticType element : tt.elements) {
+				result |= mustParseAsType(element);
+			}
+			return result;
+		} else {
+			// Error!
+			throw new InternalFailure("unknown syntactic type encountered", entry, type);
+		}
+	}
+
+	/**
+	 * Attempt to parse something which maybe a type pattern, or an expression.
+	 * The semantics of this function dictate that it returns an instanceof
+	 * TypePattern *only* if what it finds *cannot* be parsed as an expression,
+	 * but can be parsed as a type pattern. Otherwise, the state is left
+	 * unchanged.
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 *
+	 * @return An instance of TypePattern or null.
+	 */
+	public TypePattern parsePossibleTypePattern(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index; // backtrack point
+		// clone environment to prevent effects on calling context
+		environment = new HashSet<String>(environment);
+		try {
+			TypePattern pattern = parseTypePattern(generics, environment,
+					terminated);
+			// At this point, we have parsed a potential type pattern. However,
+			// if it declares no variables then this could actually be an
+			// expression and we need to return null. Therefore, count the
+			// number of declared variables.
+			HashSet<String> declared = new HashSet<String>();
+			pattern.addDeclaredVariables(declared);
+			// If the count of declared variables is non-zero, then definitely
+			// not an expression. Otherwise, look to see whether the pattern
+			// describes something which must be a type. If not, then fall
+			// through and return null.
+			if (declared.size() > 0
+					|| mustParseAsType(pattern.toSyntacticType())) {
+				return pattern;
+			}
+		} catch (SyntaxError e) {
+
+		}
+		index = start; // backtrack
+		return null;
+	}
+
+	/**
+	 * <p>
+	 * Determine whether or not the given pattern can be parsed as an
+	 * expression. In many cases, a type can (e.g. <code>{x}</code> is both a
+	 * valid type and expression). However, some types are not also expressions
+	 * (e.g. <code>int</code>, <code>{int f}</code>, <code>&int</code>, etc).
+	 * </p>
+	 *
+	 * <p>
+	 * This function *must* return false if what the given pattern could not be
+	 * parsed as an expression. However, if what it can be parsed as an
+	 * expression, then this function must return false (even if we will
+	 * eventually treat this as a type). This function is called from either the
+	 * beginning of a statement (i.e. to disambiguate variable declarations), or
+	 * after matching a left brace (i.e. to disambiguate casts).
+	 * </p>
+	 *
+	 * @param index
+	 *            Position in the token stream to begin looking from.
+	 * @return
+	 */
+	private boolean mustParseAsTypePattern(TypePattern pattern) {
+		if (pattern instanceof TypePattern.Intersection) {
+			TypePattern.Intersection tp = (TypePattern.Intersection) pattern;
+			for (TypePattern el : tp.elements) {
+				if (mustParseAsTypePattern(el)) {
+					return true;
+				}
+			}
+			return false;
+		} else if (pattern instanceof TypePattern.Union) {
+			TypePattern.Union tp = (TypePattern.Union) pattern;
+			for (TypePattern el : tp.elements) {
+				if (mustParseAsTypePattern(el)) {
+					return true;
+				}
+			}
+			return false;
+		} else if (pattern instanceof TypePattern.Record) {
+			return true;
+		} else if (pattern instanceof TypePattern.Tuple) {
+			TypePattern.Tuple tp = (TypePattern.Tuple) pattern;
+			for (TypePattern el : tp.elements) {
+				if (mustParseAsTypePattern(el)) {
+					return true;
+				}
+			}
+			return false;
+		} else {
+			TypePattern.Leaf leaf = (TypePattern.Leaf) pattern;
+			return leaf.var != null || mustParseAsType(leaf.type);
+		}
+	}
+
+	/**
+	 * Parse top-level type pattern, which is of the form:
+	 *
+	 * <pre>
+	 * TypePattern ::= Type Ident
+	 *              |  TypePattern [Ident]  ( ',' TypePattern [Ident] )*
+	 *              |  TypePattern [Ident]  '/' TypePattern [Ident]
+	 * </pre>
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 * @return
+	 */
+	private TypePattern parseTypePattern(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+
+		TypePattern leaf = parseUnionTypePattern(generics, environment,
+				terminated);
+		leaf.addDeclaredVariables(environment);
+
+		if (tryAndMatch(terminated, Comma) != null) {
+			// Ok, this is a tuple type pattern
+			ArrayList<TypePattern> result = new ArrayList<TypePattern>();
+			result.add(leaf);
+			do {
+				leaf = parseUnionTypePattern(generics, environment, terminated);
+				leaf.addDeclaredVariables(environment);
+				result.add(leaf);
+			} while (tryAndMatch(terminated, Comma) != null);
+
+			// NOTE: The optional variable identifier must be null here as, if
+			// one existed, it would be given to the element
+			return new TypePattern.Tuple(result, null, sourceAttr(start,
+					index - 1));
+		} else {
+			// this is just a leaf pattern
+			return leaf;
+		}
+	}
+
+	/**
+	 * Parse a uniontype pattern "compound", which has the form:
+	 *
+	 * <pre>
+	 * UnionTypePattern ::= IntersectionTypePattern ('|' IntersectionTypePattern)*
+	 * </pre>
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 *
+	 * @return
+	 */
+	public TypePattern parseUnionTypePattern(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		TypePattern t = parseIntersectionTypePattern(generics, environment,
+				terminated);
+
+		// Now, attempt to look for union and/or intersection types
+		if (tryAndMatch(terminated, VerticalBar) != null) {
+			// This is a union type
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			types.add(t);
+			do {
+				types.add(parseIntersectionTypePattern(generics, environment,
+						terminated));
+			} while (tryAndMatch(terminated, VerticalBar) != null);
+			return new TypePattern.Union(types, null, sourceAttr(start,
+					index - 1));
+		} else {
+			return t;
+		}
+	}
+
+	/**
+	 * Parse an intersection type pattern, which has the form:
+	 *
+	 * <pre>
+	 * IntersectionTypePattern ::= RationalTypePattern ('&' RationalTypePattern)*
+	 * </pre>
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 * @return
+	 */
+	public TypePattern parseIntersectionTypePattern(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		TypePattern t = parseRationalTypePattern(generics, environment,
+				terminated);
+
+		// Now, attempt to look for union and/or intersection types
+		if (tryAndMatch(terminated, Ampersand) != null) {
+			// This is a union type
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			types.add(t);
+			do {
+				types.add(parseRationalTypePattern(generics, environment,
+						terminated));
+			} while (tryAndMatch(terminated, Ampersand) != null);
+			return new TypePattern.Intersection(types, null, sourceAttr(start,
+					index - 1));
+		} else {
+			return t;
+		}
+	}
+
+	/**
+	 * Parse a rational type pattern, which has the form:
+	 *
+	 * <pre>
+	 * RationalTypePattern ::= TypePatternTerm '/' TypePatternTerm
+	 * </pre>
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 * @return
+	 */
+	public TypePattern parseRationalTypePattern(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		TypePattern numerator = parseTypePatternTerm(generics, environment,
+				terminated);
+
+		// Now, attempt to look for union and/or intersection types
+		if (tryAndMatch(terminated, RightSlash) != null) {
+			// This is a rational type pattern
+			TypePattern denominator = parseTypePatternTerm(generics,
+					environment, terminated);
+			boolean lhs = numerator.toSyntacticType() instanceof SyntacticType.Int;
+			if (!lhs) {
+				throw new SyntaxError("invalid numerator for rational pattern", entry, numerator);
+			}
+			boolean rhs = denominator.toSyntacticType() instanceof SyntacticType.Int;
+			if (!rhs) {
+				throw new SyntaxError("invalid denominator for rational pattern", entry, numerator);
+			}
+			return new TypePattern.Rational(numerator, denominator, null, sourceAttr(start, index - 1));
+		} else {
+			return numerator;
+		}
+	}
+
+	/**
+	 * Parse a type pattern leaf, which has the form:
+	 *
+	 * <pre>
+	 * TypePatternTerm ::= Type [Ident]
+	 * </pre>
+	 *
+	 * @param generics
+	 *            Constraints the set of generic type variables declared in the
+	 *            enclosing scope.
+	 * @param environment
+	 *            Contains the set of variables previously declared in the
+	 *            current type pattern. This is essentially used as a record in
+	 *            order to spot invalid attempts to redeclare the same variables
+	 *            (e.g. as in "int x, int x")
+	 * @param terminated
+	 *            This indicates that the type is known to be terminated (or
+	 *            not). A type that's known to be terminated is one which is
+	 *            guaranteed to be followed by something. This is important
+	 *            because it means that we can ignore any newline characters
+	 *            encountered in parsing this type, and that we'll never overrun
+	 *            the end of the type (i.e. because there's guaranteed to be
+	 *            something which terminates this type). A classic situation
+	 *            where terminated is true is when parsing a type surrounded in
+	 *            braces. In such case, we know the right-brace will always
+	 *            terminate this type.
+	 * @return
+	 */
+	public TypePattern parseTypePatternTerm(HashSet<String> generics,
+			HashSet<String> environment, boolean terminated) {
+		int start = index;
+		TypePattern result;
+
+		if (tryAndMatch(terminated, LeftBrace) != null) {
+			// Bracketed type pattern
+			if(tryAndMatch(terminated,RightBrace) != null) {
+				// This indicates no type is provided. This is a short-hand
+				// notation for the void type.				
+				return new TypePattern.Leaf(new SyntacticType.Void(sourceAttr(
+						start, index - 1)), null, sourceAttr(start, index - 1));
+			} else {
+				result = parseTypePattern(generics, environment, true);
+				match(RightBrace);
+				Expr.Variable name = parseTypePatternVar(terminated);
+				if (name != null) {
+					return new TypePattern.Leaf(result.toSyntacticType(), name,
+							sourceAttr(start, index - 1));
+				} else {
+					return result;
+				}
+			}
+		} else if (tryAndMatch(terminated, LeftCurly) != null) {
+			// Record, Set or Map type pattern
+
+			// We could do better here in the case of record types which
+			// have nested type patterns. However, it seems an unlikely use case
+			// we just ignore it for now and acknowledge that, at some point, it
+			// might be nice to do better.
+			index = start; // backtrack
+			SyntacticType type = parseRecordType(generics);
+			Expr.Variable name = parseTypePatternVar(terminated);
+			if (name == null && type instanceof SyntacticType.Record) {
+				return new TypePattern.Record((SyntacticType.Record) type,
+						sourceAttr(start, index - 1));
+			} else {
+				return new TypePattern.Leaf(type, name, sourceAttr(start,
+						index - 1));
+			}
+		} else {
+			// Leaf
+			SyntacticType type = parseType(generics);
+			Expr.Variable name = parseTypePatternVar(terminated);
+
+			return new TypePattern.Leaf(type, name,
+					sourceAttr(start, index - 1));
+		}
+	}
+
+	public Expr.Variable parseTypePatternVar(boolean terminated) {
+		// Now, try and match the optional variable identifier
+		int start = index;
+		Token id = tryAndMatch(terminated, Identifier);
+		if (id != null) {
+			return new Expr.Variable(id.text, sourceAttr(start, index - 1));
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Parse a top-level type, which is of the form:
+	 *
+	 * <pre>
+	 * TupleType ::= Type (',' Type)*
+	 * </pre>
+	 *
+	 * @see wyc.lang.SyntacticType.Tuple
+	 * @return
+	 */
+	private SyntacticType parseType(HashSet<String> generics) {
+		int start = index;
+		SyntacticType type = parseUnionType(generics);
+
+		if (tryAndMatch(true, Comma) != null) {
+			// Match one or more types separated by commas
+			ArrayList<SyntacticType> types = new ArrayList<SyntacticType>();
+			types.add(type);
+			do {
+				types.add(parseUnionType(generics));
+			} while (tryAndMatch(true, Comma) != null);
+
+			return new SyntacticType.Tuple(types, sourceAttr(start, index - 1));
+		} else {
+			return type;
+		}
+	}
+
+	/**
+	 * Parse a unit (i.e. non-tuple type). This method is a place-hold which
+	 * redirects to whatever the appropriate entry point for non-tuple types is.
+	 * Note that tuple types can be parsed, but they must be bracketed.
+	 *
+	 * @return
+	 */
+	private SyntacticType parseUnitType(HashSet<String> generics) {
+		return parseUnionType(generics);
+	}
+
+	/**
+	 * Parse a union type, which is of the form:
+	 *
+	 * <pre>
+	 * UnionType ::= IntersectionType ('|' IntersectionType)*
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private SyntacticType parseUnionType(HashSet<String> generics) {
+		int start = index;
+		SyntacticType t = parseIntersectionType(generics);
+
+		// Now, attempt to look for union and/or intersection types
+		if (tryAndMatch(true, VerticalBar) != null) {
+			// This is a union type
+			ArrayList types = new ArrayList<SyntacticType>();
+			types.add(t);
+			do {
+				types.add(parseIntersectionType(generics));
+			} while (tryAndMatch(true, VerticalBar) != null);
+			return new SyntacticType.Union(types, sourceAttr(start, index - 1));
+		} else {
+			return t;
+		}
+	}
+
+	/**
+	 * Parse an intersection type, which is of the form:
+	 *
+	 * <pre>
+	 * IntersectionType ::= BaseType ('&' BaseType)*
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private SyntacticType parseIntersectionType(HashSet<String> generics) {
+		int start = index;
+		SyntacticType t = parseBaseType(generics);
+
+		// Now, attempt to look for union and/or intersection types
+		if (tryAndMatch(true, Ampersand) != null) {
+			// This is a union type
+			ArrayList types = new ArrayList<SyntacticType>();
+			types.add(t);
+			do {
+				types.add(parseBaseType(generics));
+			} while (tryAndMatch(true, Ampersand) != null);
+			return new SyntacticType.Intersection(types, sourceAttr(start,
+					index - 1));
+		} else {
+			return t;
+		}
+	}
+
+	private SyntacticType parseBaseType(HashSet<String> generics) {
+		checkNotEof();
+		int start = index;
+		Token token = tokens.get(index);
+		SyntacticType t;
+
+		switch (token.kind) {
+		case Void:
+			return new SyntacticType.Void(sourceAttr(start, index++));
+		case Any:
+			return new SyntacticType.Any(sourceAttr(start, index++));
+		case Null:
+			return new SyntacticType.Null(sourceAttr(start, index++));
+		case Bool:
+			return new SyntacticType.Bool(sourceAttr(start, index++));
+		case Char:
+			return new SyntacticType.Char(sourceAttr(start, index++));
+		case Int:
+			return new SyntacticType.Int(sourceAttr(start, index++));
+		case Real:
+			return new SyntacticType.Real(sourceAttr(start, index++));
+		case String:
+			return new SyntacticType.Strung(sourceAttr(start, index++));
+		case LeftBrace:
+			return parseBracketedType(generics);
+		case LeftCurly:
+			return parseRecordType(generics);
+		case LeftSquare:
+			return parseListType(generics);
+		case Shreak:
+			return parseNegationType(generics);
+		case Identifier:
+			return parseNominalOrVariableType(generics);
+		default:
+			syntaxError("unknown type encountered", token);
+			return null;
+		}
+	}
+
+	/**
+	 * Parse a negation type, which is of the form:
+	 *
+	 * <pre>
+	 * NegationType ::= '!' Type
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private SyntacticType parseNegationType(HashSet<String> generics) {
+		int start = index;
+		match(Shreak);
+		SyntacticType element = parseType(generics);
+		return new SyntacticType.Negation(element, sourceAttr(start, index - 1));
+	}
+
+	/**
+	 * Parse a bracketed type, which is of the form:
+	 *
+	 * <pre>
+	 * BracketedType ::= '(' Type ')'
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private SyntacticType parseBracketedType(HashSet<String> generics) {
+		int start = index;
+		match(LeftBrace);
+		SyntacticType type = parseType(generics);
+		match(RightBrace);
+		return type;
+	}
+
+	/**
+	 * Parse a list type, which is of the form:
+	 *
+	 * <pre>
+	 * ListType ::= '[' Type ']'
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private SyntacticType parseListType(HashSet<String> generics) {
+		int start = index;
+		match(LeftSquare);
+		SyntacticType element = parseType(generics);
+		match(RightSquare);
+		return new SyntacticType.List(element, sourceAttr(start, index - 1));
+	}
+
+	/**
+	 * Parse a set, map or record type, which are of the form:
+	 *
+	 * <pre>
+	 * SetType ::= '{' Type '}'
+	 * MapType ::= '{' Type "=>" Type '}'
+	 * RecordType ::= '{' Type Identifier (',' Type Identifier)* [ ',' "..." ] '}'
+	 * </pre>
+	 *
+	 * Disambiguating these three forms is relatively straightforward as all
+	 * three must be terminated by a right curly brace. Therefore, after parsing
+	 * the first Type, we simply check what follows. One complication is the
+	 * potential for "mixed types" where the field name and type and intertwined
+	 * (e.g. function read()->[byte]).
+	 *
+	 * @return
+	 */
+	private SyntacticType parseRecordType(HashSet<String> generics) {
+		int start = index;
+		match(LeftCurly);
+
+		ArrayList<Pair<SyntacticType, Expr.Variable>> types = new ArrayList<Pair<SyntacticType, Expr.Variable>>();
+		HashSet<String> names = new HashSet<String>();
+		// Otherwise, we have a record type and we must continue to parse
+		// the remainder of the first field.
+
+		Pair<SyntacticType, Expr.Variable> p = parseMixedType(generics);
+		types.add(p);
+		names.add(p.second().name);
+
+		// Now, we continue to parse any remaining fields.
+		boolean isOpen = false;
+		while (eventuallyMatch(RightCurly) == null) {
+			match(Comma);
+
+			if (tryAndMatch(true, DotDotDot) != null) {
+				// this signals an "open" record type
+				match(RightCurly);
+				isOpen = true;
+				break;
+			} else {
+				p = parseMixedType(generics);
+				Expr.Variable id = p.second();
+				if (names.contains(id.name)) {
+					throw new SyntaxError("duplicate record key", entry, id);
+				}
+				types.add(p);
+				names.add(id.name);
+			}
+		}
+		// Done
+		return new SyntacticType.Record(isOpen, types, sourceAttr(start,
+				index - 1));
+	}
+
+	/**
+	 * Parse a nominal type, which is of the form:
+	 *
+	 * <pre>
+	 * NominalType ::= Identifier ('.' Identifier)*
+	 * </pre>
+	 *
+	 * @see wyc.lang.SyntacticType.Nominal
+	 * @return
+	 */
+	private SyntacticType parseNominalOrVariableType(HashSet<String> generics) {
+		int start = index;
+		ArrayList<String> names = new ArrayList<String>();
+
+		// Match one or more identifiers separated by dots
+		do {
+			names.add(match(Identifier).text);
+		} while (tryAndMatch(true, Dot) != null);
+
+		if (names.size() == 1 && generics.contains(names.get(0))) {
+			// this is a generic type variable
+			return new SyntacticType.Variable(names.get(0), sourceAttr(start,
+					index - 1));
+		} else {
+			// this is a nominal type
+			return new SyntacticType.Nominal(names,
+					sourceAttr(start, index - 1));
+		}
+	}
+
+	/**
+	 * Parse a potentially mixed-type, which is of the form:
+	 *
+	 * <pre>
+	 * MixedType ::= Type Identifier
+	 *            |  "function" Type Identifier '(' [Type (',' Type)* ] ')' "->" Type [ "throws" Type ]
+	 *            |  "method" Type Identifier '(' [Type (',' Type)* ] ')' "->" Type [ "throws" Type ]
+	 * </pre>
+	 *
+	 * @return
+	 */
+	private Pair<SyntacticType, Expr.Variable> parseMixedType(
+			HashSet<String> generics) {
+		Token lookahead;
+		int start = index;
+
+		if ((lookahead = tryAndMatch(true, Function)) != null) {
+			// At this point, we *might* have a mixed function / method type
+			// definition. To disambiguate, we need to see whether an identifier
+			// follows or not.
+			Token id = tryAndMatch(true, Identifier);
+
+			if (id != null) {
+				// Yes, we have found a mixed function / method type definition.
+				// Therefore, we continue to pass the remaining type parameters.
+
+				ArrayList<SyntacticType> paramTypes = new ArrayList<SyntacticType>();
+				match(LeftBrace);
+
+				boolean firstTime = true;
+				while (eventuallyMatch(RightBrace) == null) {
+					if (!firstTime) {
+						match(Comma);
+					}
+					firstTime = false;
+					paramTypes.add(parseUnitType(generics));
+				}
+
+				SyntacticType ret;
+
+				// Functions require a return type (since otherwise they are
+				// just nops)
+				match(MinusGreater);
+				// Third, parse the return type
+				ret = parseUnitType(generics);
+
+				// Fourth, parse the optional throws type
+				SyntacticType throwsType = null;
+				if (tryAndMatch(true, Throws) != null) {
+					throwsType = parseType(generics);
+				}
+
+				// Done
+				SyntacticType type = new SyntacticType.Function(ret,
+						throwsType, paramTypes, sourceAttr(start, index - 1));
+
+				return new Pair<SyntacticType, Expr.Variable>(type,
+						new Expr.Variable(id.text, sourceAttr(id.start,
+								id.end())));
+			} else {
+				// In this case, we failed to match a mixed type. Therefore, we
+				// backtrack and parse as two separate items (i.e. type
+				// identifier).
+				index = start; // backtrack
+			}
+		}
+
+		// This is the normal case, where we expect an identifier to follow the
+		// type.
+		SyntacticType type = parseType(generics);
+		Token id = match(Identifier);
+		return new Pair<SyntacticType, Expr.Variable>(type, new Expr.Variable(
+				id.text, sourceAttr(id.start, id.end())));
+	}
+
+	public boolean mustParseAsMixedType() {
+		int start = index;
+		if (tryAndMatch(true, Function) != null
+				&& tryAndMatch(true, Identifier) != null) {
+			// Yes, this is a mixed type
+			index = start;
+			return true;
+		} else {
+			// No, this is not a mixed type
+			index = start;
+			return false;
+		}
+	}
+
+	/**
+	 * Match a given token kind, whilst moving passed any whitespace encountered
+	 * inbetween. In the case that meet the end of the stream, or we don't match
+	 * the expected token, then an error is thrown.
+	 *
+	 * @param kind
+	 * @return
+	 */
+	private Token match(Token.Kind kind) {
+		checkNotEof();
+		Token token = tokens.get(index++);
+		if (token.kind != kind) {
+			syntaxError("expecting \"" + kind + "\" here", token);
+		}
+		return token;
+	}
+
+	/**
+	 * Match a given sequence of tokens, whilst moving passed any whitespace
+	 * encountered inbetween. In the case that meet the end of the stream, or we
+	 * don't match the expected tokens in the expected order, then an error is
+	 * thrown.
+	 *
+	 * @param operator
+	 * @return
+	 */
+	private Token[] match(Token.Kind... kinds) {
+		Token[] result = new Token[kinds.length];
+		for (int i = 0; i != result.length; ++i) {
+			checkNotEof();
+			Token token = tokens.get(index++);
+			if (token.kind == kinds[i]) {
+				result[i] = token;
+			} else {
+				syntaxError("Expected \"" + kinds[i] + "\" here", token);
+			}
+		}
+		return result;
+	}
+
+	/**
+	 * Attempt to match a given kind of token with the view that it must
+	 * *eventually* be matched. This differs from <code>tryAndMatch()</code>
+	 * because it calls <code>checkNotEof()</code>. Thus, it is guaranteed to
+	 * skip any whitespace encountered in between. This is safe because we know
+	 * there is a terminating token still to come.
+	 *
+	 * @param kind
+	 * @return
+	 */
+	private Token eventuallyMatch(Token.Kind kind) {
+		checkNotEof();
+		Token token = tokens.get(index);
+		if (token.kind != kind) {
+			return null;
+		} else {
+			index = index + 1;
+			return token;
+		}
+	}
+
+	/**
+	 * Attempt to match a given token(s), whilst ignoring any whitespace in
+	 * between. Note that, in the case it fails to match, then the index will be
+	 * unchanged. This latter point is important, otherwise we could
+	 * accidentally gobble up some important indentation. If more than one kind
+	 * is provided then this will try to match any of them.
+	 *
+	 * @param terminated
+	 *            Indicates whether or not this function should be concerned
+	 *            with new lines. The terminated flag indicates whether or not
+	 *            the current construct being parsed is known to be terminated.
+	 *            If so, then we don't need to worry about newlines and can
+	 *            greedily consume them (i.e. since we'll eventually run into
+	 *            the terminating symbol).
+	 * @param kinds
+	 *
+	 * @return
+	 */
+	private Token tryAndMatch(boolean terminated, Token.Kind... kinds) {
+		// If the construct being parsed is know to be terminated, then we can
+		// skip all whitespace. Otherwise, we can't skip newlines as these are
+		// significant.
+		int next = terminated ? skipWhiteSpace(index) : skipLineSpace(index);
+
+		if (next < tokens.size()) {
+			Token t = tokens.get(next);
+			for (int i = 0; i != kinds.length; ++i) {
+				if (t.kind == kinds[i]) {
+					index = next + 1;
+					return t;
+				}
+			}
+		}
+		return null;
+	}
+	
+	/**
+	 * Check whether a given token(s) could be matched, whilst ignoring any
+	 * whitespace in between. Note that, in either case, the index will be
+	 * unchanged. If more than one kind is provided then this will check for
+	 * matching any of them.
+	 *
+	 * @param terminated
+	 *            Indicates whether or not this function should be concerned
+	 *            with new lines. The terminated flag indicates whether or not
+	 *            the current construct being parsed is known to be terminated.
+	 *            If so, then we don't need to worry about newlines and can
+	 *            greedily consume them (i.e. since we'll eventually run into
+	 *            the terminating symbol).
+	 * @param kinds
+	 *
+	 * @return
+	 */
+	private Token canMatch(boolean terminated, Token.Kind... kinds) {
+		// If the construct being parsed is know to be terminated, then we can
+		// skip all whitespace. Otherwise, we can't skip newlines as these are
+		// significant.
+		int next = terminated ? skipWhiteSpace(index) : skipLineSpace(index);
+
+		if (next < tokens.size()) {
+			Token t = tokens.get(next);
+			for (int i = 0; i != kinds.length; ++i) {
+				if (t.kind == kinds[i]) {
+					return t;
+				}
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Attempt to match a given token on the *same* line, whilst ignoring any
+	 * whitespace in between. Note that, in the case it fails to match, then the
+	 * index will be unchanged. This latter point is important, otherwise we
+	 * could accidentally gobble up some important indentation.
+	 *
+	 * @param kind
+	 * @return
+	 */
+	private Token tryAndMatchOnLine(Token.Kind kind) {
+		int next = skipLineSpace(index);
+		if (next < tokens.size()) {
+			Token t = tokens.get(next);
+			if (t.kind == kind) {
+				index = next + 1;
+				return t;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Match a the end of a line. This is required to signal, for example, the
+	 * end of the current statement.
+	 */
+	private void matchEndLine() {
+		// First, parse all whitespace characters except for new lines
+		index = skipLineSpace(index);
+
+		// Second, check whether we've reached the end-of-file (as signaled by
+		// running out of tokens), or we've encountered some token which not a
+		// newline.
+		if (index >= tokens.size()) {
+			return; // EOF
+		} else if (tokens.get(index).kind != NewLine) {
+			syntaxError("expected end-of-line", tokens.get(index));
+		} else {
+			index = index + 1;
+		}
+	}
+
+	/**
+	 * Check that the End-Of-File has not been reached. This method should be
+	 * called from contexts where we are expecting something to follow.
+	 */
+	private void checkNotEof() {
+		skipWhiteSpace();
+		if (index >= tokens.size()) {
+			// FIXME: this is clearly not a sensible approach
+			SyntacticElement unknown = new SyntacticElement.Impl() {
+			};
+			unknown.attributes().add(new Attribute.Source(index - 1, index - 1, -1));
+			throw new SyntaxError("unexpected end-of-file", entry, unknown);
+		}
+	}
+
+	/**
+	 * Skip over any whitespace characters.
+	 */
+	private void skipWhiteSpace() {
+		index = skipWhiteSpace(index);
+	}
+
+	/**
+	 * Skip over any whitespace characters, starting from a given index and
+	 * returning the first index passed any whitespace encountered.
+	 */
+	private int skipWhiteSpace(int index) {
+		while (index < tokens.size() && isWhiteSpace(tokens.get(index))) {
+			index++;
+		}
+		return index;
+	}
+
+	/**
+	 * Skip over any whitespace characters that are permitted on a given line
+	 * (i.e. all except newlines), starting from a given index and returning the
+	 * first index passed any whitespace encountered.
+	 */
+	private int skipLineSpace(int index) {
+		while (index < tokens.size() && isLineSpace(tokens.get(index))) {
+			index++;
+		}
+		return index;
+	}
+
+	/**
+	 * Skip over any empty lines. That is lines which contain only whitespace
+	 * and comments.
+	 */
+	private void skipEmptyLines() {
+		int tmp = index;
+		do {
+			tmp = skipLineSpace(tmp);
+			if (tmp < tokens.size() && tokens.get(tmp).kind != NewLine) {
+				return; // done
+			} else if (tmp >= tokens.size()) {
+				index = tmp;
+				return; // end-of-file reached
+			}
+			// otherwise, skip newline and continue
+			tmp = tmp + 1;
+			index = tmp;
+		} while (true);
+		// deadcode
+	}
+
+	/**
+	 * Define what is considered to be whitespace.
+	 *
+	 * @param token
+	 * @return
+	 */
+	private boolean isWhiteSpace(Token token) {
+		return token.kind == NewLine || isLineSpace(token);
+	}
+
+	/**
+	 * Define what is considered to be linespace.
+	 *
+	 * @param token
+	 * @return
+	 */
+	private boolean isLineSpace(Token token) {
+		return token.kind == Token.Kind.Indent
+				|| token.kind == Token.Kind.LineComment
+				|| token.kind == Token.Kind.BlockComment;
+	}
+
+	/**
+	 * Parse a character from a string of the form 'c' or '\c'.
+	 *
+	 * @param input
+	 * @return
+	 */
+	private char parseCharacter(String input) {
+		int pos = 1;
+		char c = input.charAt(pos++);
+		if (c == '\\') {
+			// escape code
+			switch (input.charAt(pos++)) {
+			case 'b':
+				c = '\b';
+				break;
+			case 't':
+				c = '\t';
+				break;
+			case 'n':
+				c = '\n';
+				break;
+			case 'f':
+				c = '\f';
+				break;
+			case 'r':
+				c = '\r';
+				break;
+			case '"':
+				c = '\"';
+				break;
+			case '\'':
+				c = '\'';
+				break;
+			case '\\':
+				c = '\\';
+				break;
+			default:
+				throw new RuntimeException("unrecognised escape character");
+			}
+		}
+		return c;
+	}
+
+	/**
+	 * Parse a string whilst interpreting all escape characters.
+	 *
+	 * @param v
+	 * @return
+	 */
+	protected String parseString(String v) {
+		/*
+		 * Parsing a string requires several steps to be taken. First, we need
+		 * to strip quotes from the ends of the string.
+		 */
+		v = v.substring(1, v.length() - 1);
+		// Second, step through the string and replace escaped characters
+		for (int i = 0; i < v.length(); i++) {
+			if (v.charAt(i) == '\\') {
+				if (v.length() <= i + 1) {
+					throw new RuntimeException("unexpected end-of-string");
+				} else {
+					char replace = 0;
+					int len = 2;
+					switch (v.charAt(i + 1)) {
+					case 'b':
+						replace = '\b';
+						break;
+					case 't':
+						replace = '\t';
+						break;
+					case 'n':
+						replace = '\n';
+						break;
+					case 'f':
+						replace = '\f';
+						break;
+					case 'r':
+						replace = '\r';
+						break;
+					case '"':
+						replace = '\"';
+						break;
+					case '\'':
+						replace = '\'';
+						break;
+					case '\\':
+						replace = '\\';
+						break;
+					case 'u':
+						len = 6; // unicode escapes are six digits long,
+						// including "slash u"
+						String unicode = v.substring(i + 2, i + 6);
+						replace = (char) Integer.parseInt(unicode, 16); // unicode
+						break;
+					default:
+						throw new RuntimeException("unknown escape character");
+					}
+					v = v.substring(0, i) + replace + v.substring(i + len);
+				}
+			}
+		}
+		return v;
+	}
+
+	/**
+	 * Parse a token representing a byte value. Every such token is a sequence
+	 * of one or more binary digits ('0' or '1') followed by 'b'. For example,
+	 * "00110b" is parsed as the byte value 6.
+	 *
+	 * @param input
+	 *            The token representing the byte value.
+	 * @return
+	 */
+	private byte parseByte(Token input) {
+		String text = input.text;
+		if (text.length() > 9) {
+			syntaxError("invalid binary literal (too long)", input);
+		}
+		int val = 0;
+		for (int i = 0; i != text.length() - 1; ++i) {
+			val = val << 1;
+			char c = text.charAt(i);
+			if (c == '1') {
+				val = val | 1;
+			} else if (c == '0') {
+
+			} else {
+				syntaxError("invalid binary literal (invalid characters)",
+						input);
+			}
+		}
+		return (byte) val;
+	}
+
+	private Attribute.Source sourceAttr(int start, int end) {
+		Token t1 = tokens.get(start);
+		Token t2 = tokens.get(end);
+		// FIXME: problem here with the line numbering ?
+		return new Attribute.Source(t1.start, t2.end(), 0);
+	}
+
+	private void syntaxError(String msg, Token t) {
+		// FIXME: this is clearly not a sensible approach
+		SyntacticElement unknown = new SyntacticElement.Impl() {
+		};
+		unknown.attributes().add(new Attribute.Source(t.start, t.start + t.text.length() - 1, -1));
+		throw new SyntaxError(msg, entry, unknown);
+	}
+
+	/**
+	 * Represents a given amount of indentation. Specifically, a count of tabs
+	 * and spaces. Observe that the order in which tabs / spaces occurred is not
+	 * retained.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	private static class Indent extends Token {
+		private final int countOfSpaces;
+		private final int countOfTabs;
+
+		public Indent(String text, int pos) {
+			super(Token.Kind.Indent, text, pos);
+			// Count the number of spaces and tabs
+			int nSpaces = 0;
+			int nTabs = 0;
+			for (int i = 0; i != text.length(); ++i) {
+				char c = text.charAt(i);
+				switch (c) {
+				case ' ':
+					nSpaces++;
+					break;
+				case '\t':
+					nTabs++;
+					break;
+				default:
+					throw new IllegalArgumentException(
+							"Space or tab character expected");
+				}
+			}
+			countOfSpaces = nSpaces;
+			countOfTabs = nTabs;
+		}
+
+		/**
+		 * Test whether this indentation is considered "less than or equivalent"
+		 * to another indentation. For example, an indentation of 2 spaces is
+		 * considered less than an indentation of 3 spaces, etc.
+		 *
+		 * @param other
+		 *            The indent to compare against.
+		 * @return
+		 */
+		public boolean lessThanEq(Indent other) {
+			return countOfSpaces <= other.countOfSpaces
+					&& countOfTabs <= other.countOfTabs;
+		}
+
+		/**
+		 * Test whether this indentation is considered "equivalent" to another
+		 * indentation. For example, an indentation of 3 spaces followed by 1
+		 * tab is considered equivalent to an indentation of 1 tab followed by 3
+		 * spaces, etc.
+		 *
+		 * @param other
+		 *            The indent to compare against.
+		 * @return
+		 */
+		public boolean equivalent(Indent other) {
+			return countOfSpaces == other.countOfSpaces
+					&& countOfTabs == other.countOfTabs;
+		}
+	}
+
+	/**
+	 * An abstract indentation which represents the indentation of top-level
+	 * declarations, such as function declarations. This is used to simplify the
+	 * code for parsing indentation.
+	 */
+	private static final Indent ROOT_INDENT = new Indent("", 0);
+}
diff --git a/modules/wycs/src/wycs/io/WyalFilePrinter.java b/modules/wycs/src/wycs/io/WyalFilePrinter.java
new file mode 100755
index 0000000000..f1e63f66e3
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WyalFilePrinter.java
@@ -0,0 +1,413 @@
+package wycs.io;
+
+import java.io.*;
+
+import static wycc.lang.SyntaxError.*;
+import wycs.syntax.*;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+public class WyalFilePrinter {
+	public static final String INDENT = "  ";
+
+	private PrintWriter out;
+
+	public WyalFilePrinter(OutputStream writer) throws UnsupportedEncodingException {
+		this(new OutputStreamWriter(writer,"UTF-8"));
+	}
+
+	public WyalFilePrinter(Writer writer) {
+		this.out = new PrintWriter(writer);
+	}
+
+	public void write(WyalFile wf) {
+		// First, write package information
+		Path.ID pkg = wf.id().parent();		
+		if(pkg != Trie.ROOT) {
+			out.println("package " + pkg.toString());
+			out.println();
+		}
+		// Second, write declarations.
+		for(WyalFile.Declaration d : wf.declarations()) {
+			write(wf, d);
+			out.println();
+		}
+		// Done.
+		out.flush();
+	}
+
+	private void write(WyalFile wf, WyalFile.Declaration s) {
+		if(s instanceof WyalFile.Function) {
+			write(wf,(WyalFile.Function)s);
+		} else if(s instanceof WyalFile.Macro) {
+			write(wf,(WyalFile.Macro)s);
+		} else if(s instanceof WyalFile.Type) {
+			write(wf,(WyalFile.Type)s);
+		} else if(s instanceof WyalFile.Assert) {
+			write(wf,(WyalFile.Assert)s);
+		} else if(s instanceof WyalFile.Import) {
+			write(wf,(WyalFile.Import)s);
+		} else {
+			throw new InternalFailure("unknown statement encountered " + s, wf.getEntry(), s);
+		}
+		out.println();
+	}
+
+	public void write(WyalFile wf, WyalFile.Import s) {
+		String str = s.filter.toString();
+		str = str.replace('/', '.');
+		if (s.name == null) {
+			out.print("import " + str);
+		} else {
+			out.print("import " + s.name + " from " + str);
+		}
+	}
+
+	public void write(WyalFile wf, WyalFile.Function s) {
+		out.print("function ");
+		out.print(s.name);
+		if(s.generics.size() > 0) {
+			out.print("<");
+			boolean firstTime=true;
+			for(String g : s.generics) {
+				if(!firstTime) {
+					out.print(", ");
+				}
+				firstTime=false;
+				out.print(g);
+			}
+			out.print("> ");
+		}
+		writeWithBraces(wf,s.from);	
+		out.print(" -> ");
+		writeWithBraces(wf,s.to);			
+		if(s.constraint != null) {
+			out.println(" where:");
+			indent(1);
+			writeWithoutBraces(wf,s.constraint,1);
+		}
+	}
+	
+	public void write(WyalFile wf, WyalFile.Macro s) {
+		out.print("define ");
+
+		out.print(s.name);
+		if(s.generics.size() > 0) {
+			out.print("<");
+			boolean firstTime=true;
+			for(String g : s.generics) {
+				if(!firstTime) {
+					out.print(", ");
+				}
+				firstTime=false;
+				out.print(g);
+			}
+			out.print(">");
+		}
+		writeWithBraces(wf,s.from);		
+		if(s.body != null) {		
+			out.println(" is:");
+			indent(1);
+			writeWithoutBraces(wf,s.body,1);
+		}
+	}
+
+	public void write(WyalFile wf, WyalFile.Type s) {
+		out.print("type ");
+		out.print(s.name);
+		if(s.generics.size() > 0) {
+			out.print("<");
+			boolean firstTime=true;
+			for(String g : s.generics) {
+				if(!firstTime) {
+					out.print(", ");
+				}
+				firstTime=false;
+				out.print(g);
+			}
+			out.print(">");
+		}
+		out.print(" is ");
+		writeWithBraces(wf,s.type);		
+		if(s.invariant != null) {
+			out.println(" where:");			
+			indent(1);
+			writeWithoutBraces(wf,s.invariant,1);
+		}
+	}
+	
+	public void write(WyalFile wf, WyalFile.Assert s) {
+		out.print("assert ");
+		if(s.message != null) {
+			out.print("\"" + s.message + "\"");
+		}
+		out.println(":");
+		indent(1);
+		writeWithoutBraces(wf,s.expr,1);
+		out.println();
+	}
+
+	/**
+	 * This function is called to print an expression which should be written
+	 * with braces if it is not a single atomic entity.
+	 *
+	 * @param wf
+	 * @param e
+	 * @param indent
+	 */
+	public void writeWithBraces(WyalFile wf, Expr e, int indent) {
+		out.print("(");
+		writeWithoutBraces(wf,e,indent);
+		out.print(")");		
+	}
+	
+	/**
+	 * This function is called to print an expression which should be written
+	 * with braces if it is not a single atomic entity.
+	 *
+	 * @param wf
+	 * @param e
+	 * @param indent
+	 */
+	public void writeWithOptionalBraces(WyalFile wf, Expr e, int indent) {
+		boolean needsBraces = needsBraces(e);
+		if(needsBraces) {
+			out.print("(");
+			writeWithoutBraces(wf,e,indent);
+			out.print(")");
+		} else {
+			writeWithoutBraces(wf,e,indent);
+		}
+	}
+
+	public void writeWithoutBraces(WyalFile wf, Expr e, int indent) {
+		if (e instanceof Expr.Constant || e instanceof Expr.Variable) {
+			out.print(e);
+		} else if(e instanceof Expr.Unary) {
+			write(wf, (Expr.Unary)e,indent);
+		} else if(e instanceof Expr.Cast) {
+			write(wf, (Expr.Cast)e,indent);
+		} else if(e instanceof Expr.Binary) {
+			write(wf, (Expr.Binary)e,indent);
+		} else if(e instanceof Expr.Nary) {
+			write(wf, (Expr.Nary)e,indent);
+		} else if(e instanceof Expr.Is) {
+			write(wf, (Expr.Is)e,indent);
+		} else if(e instanceof Expr.Quantifier) {
+			write(wf, (Expr.Quantifier)e,indent);
+		} else if(e instanceof Expr.Invoke) {
+			write(wf, (Expr.Invoke)e,indent);
+		} else if(e instanceof Expr.IndexOf) {
+			write(wf, (Expr.IndexOf)e,indent);
+		} else {
+			throw new InternalFailure("unknown expression encountered " + e, wf.getEntry(), e);
+		}
+	}
+
+	private void write(WyalFile wf, Expr.Cast e, int indent) {
+		out.print("(" + e.type + ") ");
+		writeWithOptionalBraces(wf,e.operand,indent);		
+	}
+	
+	private void write(WyalFile wf, Expr.Unary e, int indent) {
+		switch(e.op) {
+		case NOT:
+			out.print("!");
+			break;
+		case NEG:
+			out.print("-");
+			break;
+		case LENGTHOF:
+			out.print("|");
+			writeWithoutBraces(wf,e.operand,indent);
+			out.print("|");
+			return;
+		}
+		writeWithOptionalBraces(wf,e.operand,indent);
+	}
+
+	private void write(WyalFile wf, Expr.Binary e, int indent) {
+		switch(e.op) {
+		case IMPLIES:
+			out.println("if:");
+			indent(indent+1);
+			writeWithoutBraces(wf,e.leftOperand,indent+1);
+			out.println();
+			indent(indent);
+			out.println("then:");
+			indent(indent+1);
+			writeWithoutBraces(wf,e.rightOperand,indent+1);
+			break;
+		case AND:
+			writeWithoutBraces(wf,e.leftOperand,indent);
+			out.println();
+			indent(indent);
+			writeWithoutBraces(wf,e.rightOperand,indent);
+			break;
+		case OR:
+			out.println("either:");
+			indent(indent+1);
+			writeWithoutBraces(wf,e.leftOperand,indent+1);
+			out.println();
+			indent(indent);
+			out.println("or:");
+			indent(indent+1);
+			writeWithoutBraces(wf,e.rightOperand,indent+1);
+			break;
+		case ARRAYGEN:
+			out.print("[");
+			writeWithOptionalBraces(wf,e.leftOperand,indent);
+			out.print(";");
+			writeWithOptionalBraces(wf,e.rightOperand,indent);
+			out.print("]");
+			break;
+		default:
+			writeWithOptionalBraces(wf,e.leftOperand,indent);
+			out.print(" " + e.op + " ");
+			writeWithOptionalBraces(wf,e.rightOperand,indent);
+		}
+	}
+
+	private void write(WyalFile wf, Expr.Nary e, int indent) {
+		switch(e.op) {
+		case TUPLE:
+		{
+			boolean firstTime=true;
+			for(Expr operand : e.operands) {
+				if(!firstTime) {
+					out.print(", ");
+				} else {
+					firstTime = false;
+				}
+				writeWithoutBraces(wf,operand,indent);
+			}
+			return;
+		}		
+		case ARRAY: {
+			boolean firstTime=true;
+			out.print("[");
+			for(Expr operand : e.operands) {
+				if(!firstTime) {
+					out.print(", ");
+				} else {
+					firstTime = false;
+				}
+				writeWithOptionalBraces(wf,operand,indent);
+			}
+			out.print("]");
+			return;
+		}
+		}
+		throw new InternalFailure("unknown expression encountered \"" + e + "\" (" + e.getClass().getName() + ")",
+				wf.getEntry(), e);
+	}
+
+
+	private void write(WyalFile wf, Expr.Is e, int indent) {
+		writeWithOptionalBraces(wf,e.leftOperand,indent);
+		out.print(" is ");
+		out.print(e.rightOperand);
+	}
+	
+	private void write(WyalFile wf, Expr.Quantifier e, int indent) {
+		if(e instanceof Expr.ForAll) {
+			out.print("forall ");
+		} else {
+			out.print("exists ");
+		}
+
+		writeWithBraces(wf, e.pattern);
+		out.println(":");
+		indent(indent+1);
+		writeWithoutBraces(wf,e.operand,indent+1);
+	}
+
+	private void write(WyalFile wf, Expr.Invoke e, int indent) {
+		if(e.qualification != null) {
+			String qualification = e.qualification.toString().replace('/', '.'); 
+			out.print(qualification);
+			out.print(".");
+		}
+		if(e.generics.size() > 0) {
+			out.print("<");
+			for(int i=0;i!=e.generics.size();++i) {
+				if(i != 0) {
+					out.print(",");
+				}
+				out.print(e.generics.get(i));				
+			}
+			out.print(">");
+		}
+		out.print(e.name);			
+		writeWithBraces(wf,e.operand,indent);
+	}
+
+	private void write(WyalFile wf, Expr.IndexOf e, int indent) {
+		writeWithOptionalBraces(wf,e.operand,indent);
+		out.print("[");
+		out.print(e.index);
+		out.print("]");
+	}
+
+	protected void writeWithoutBraces(WyalFile wf, TypePattern p) {
+		if(p instanceof TypePattern.Tuple) {
+			TypePattern.Tuple t = (TypePattern.Tuple) p;
+			out.print("(");
+			for(int i=0;i!=t.elements.size();++i) {
+				if(i!=0) {
+					out.print(", ");
+				}
+				writeWithoutBraces(wf,t.elements.get(i));
+			}
+			out.print(")");
+		} else {
+			TypePattern.Leaf l = (TypePattern.Leaf) p;
+			out.print(l.type);
+			if(l.var != null) {
+				out.print(" " + l.var.name);
+			}
+		}
+	}
+
+	protected void writeWithBraces(WyalFile wf, TypePattern p) {
+		out.print("(");
+		if(p instanceof TypePattern.Tuple) {
+			TypePattern.Tuple t = (TypePattern.Tuple) p;
+			for(int i=0;i!=t.elements.size();++i) {
+				if(i!=0) {
+					out.print(", ");
+				}
+				writeWithoutBraces(wf,t.elements.get(i));
+			}
+		} else {
+			TypePattern.Leaf l = (TypePattern.Leaf) p;
+			out.print(l.type);
+			if(l.var != null) {
+				out.print(" " + l.var.name);
+			}
+		}
+		out.print(")");
+	}
+
+	private static boolean needsBraces(Expr e) {
+		 if(e instanceof Expr.Cast) {			 
+			 return true;
+		 } else if(e instanceof Expr.Binary) {
+			 Expr.Binary b = (Expr.Binary) e;
+			 switch(b.op) {
+			 case ARRAYGEN:
+				 break;
+			 default:
+				 return true;
+			 }
+		 }
+		 return false;
+	}
+
+	private void indent(int indent) {
+		indent = indent * 4;
+		for(int i=0;i<indent;++i) {
+			out.print(" ");
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/io/WycsFilePrinter.java b/modules/wycs/src/wycs/io/WycsFilePrinter.java
new file mode 100755
index 0000000000..06c9d38302
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WycsFilePrinter.java
@@ -0,0 +1,376 @@
+package wycs.io;
+
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.UnsupportedEncodingException;
+import java.io.Writer;
+
+import wycc.io.Token;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError.*;
+import wycc.util.Pair;
+import wycc.util.Triple;
+import wycs.core.Code;
+import wycs.core.SemanticType;
+import wycs.core.WycsFile;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+public class WycsFilePrinter {
+	private PrintWriter out;
+	private boolean raw=false;
+
+	public WycsFilePrinter(OutputStream writer) throws UnsupportedEncodingException {
+		this(new OutputStreamWriter(writer,"UTF-8"));
+	}
+
+	public WycsFilePrinter(Writer writer) {
+		this.out = new PrintWriter(writer);
+	}
+
+	public void write(WycsFile wf) {
+		// First, write package information
+		Path.ID pkg = wf.getEntry().id().parent();
+		if(pkg != Trie.ROOT) {
+			out.println("package " + pkg.toString());
+			out.println();
+		}
+		// Second, write all declarations
+		for(WycsFile.Declaration d : wf.declarations()) {
+			write(wf, d);
+			out.println();
+		}
+		out.flush();
+	}
+
+	private void write(WycsFile wf, WycsFile.Declaration s) {
+		if(s instanceof WycsFile.Function) {
+			write(wf,(WycsFile.Function)s);
+		} else if(s instanceof WycsFile.Macro) {
+			write(wf,(WycsFile.Macro)s);
+		} else if(s instanceof WycsFile.Type) {
+			write(wf,(WycsFile.Type)s);
+		} else if(s instanceof WycsFile.Assert) {
+			write(wf,(WycsFile.Assert)s);
+		} else {
+			throw new InternalFailure("unknown statement encountered " + s,
+					wf.getEntry(), (SyntacticElement) s);
+		}
+		out.println();
+	}
+
+	public void write(WycsFile wf, WycsFile.Function s) {
+		out.print("function ");
+		out.print(s.name);
+		SemanticType[] generics = s.type.generics();
+		if(generics.length > 0) {
+			out.print("<");
+			boolean firstTime=true;
+			for(SemanticType g : generics) {
+				if(!firstTime) {
+					out.print(", ");
+				}
+				firstTime=false;
+				out.print(((SemanticType.Var)g).name());
+			}
+			out.print(">");
+		}
+		out.print("(" + s.type.element(0) + ") => " + s.type.element(1));
+		if(s.constraint != null) {
+			out.println(" where:");
+			indent(1);
+			write(wf,s.constraint);
+		}
+	}
+
+	public void write(WycsFile wf, WycsFile.Macro s) {
+		out.print("define ");
+
+		out.print(s.name);
+		SemanticType[] generics = s.type.generics();
+		if(generics.length > 0) {
+			out.print("<");
+			boolean firstTime=true;
+			for(SemanticType g : generics) {
+				if(!firstTime) {
+					out.print(", ");
+				}
+				firstTime=false;
+				out.print(((SemanticType.Var)g).name());
+			}
+			out.print(">");
+		}
+		out.print("(" + s.type.from() + ") => " + s.type.to());
+		if(s.condition != null) {
+			out.println(" as:");
+			write(wf,s.condition);
+		}
+	}
+
+	public void write(WycsFile wf, WycsFile.Type s) {
+		out.print("type ");
+
+		out.print(s.name);
+		out.print(" is " + s.type);
+		if(s.invariant != null) {
+			out.println(" where:");
+			write(wf,s.invariant);
+		}
+	}
+	
+	public void write(WycsFile wf, WycsFile.Assert s) {
+		out.print("assert ");
+		if(s.message != null) {
+			out.print("\"" + s.message + "\"");
+		}
+		out.println(":");
+		write(wf,s.condition);
+		out.println();
+	}
+
+	public void write(WycsFile wf, Code<?> code) {
+		if(raw) {
+			writeRaw(wf,code,0);
+		} else {
+			indent(1);
+			writeStructured(wf,code,1);
+		}
+	}
+
+	public void writeStructured(WycsFile wf, Code<?> code, int indent) {
+		if(code instanceof Code.Variable) {
+			writeStructured(wf, (Code.Variable) code, indent);
+		} else if(code instanceof Code.Constant) {
+			writeStructured(wf, (Code.Constant) code, indent);
+		} else if(code instanceof Code.Unary) {
+			writeStructured(wf, (Code.Unary) code, indent);
+		} else if(code instanceof Code.Binary) {
+			writeStructured(wf, (Code.Binary) code, indent);
+		} else if(code instanceof Code.Nary) {
+			writeStructured(wf, (Code.Nary) code, indent);
+		} else if(code instanceof Code.Load) {
+			writeStructured(wf, (Code.Load) code, indent);
+		} else if(code instanceof Code.IndexOf) {
+			writeStructured(wf, (Code.IndexOf) code, indent);
+		} else if(code instanceof Code.Is) {
+			writeStructured(wf, (Code.Is) code, indent);
+		} else if(code instanceof Code.Cast) {
+			writeStructured(wf, (Code.Cast) code, indent);
+		} else if(code instanceof Code.FunCall) {
+			writeStructured(wf, (Code.FunCall) code, indent);
+		} else if(code instanceof Code.Quantifier) {
+			writeStructured(wf, (Code.Quantifier) code, indent);
+		} else {
+			throw new InternalFailure("unknown bytecode encountered", wf.getEntry(), code);
+		}
+	}
+
+	public void writeStructured(WycsFile wf, Code.Variable code, int indent) {
+		out.print("r" + code.index);
+	}
+
+	public void writeStructured(WycsFile wf, Code.Constant code, int indent) {
+		out.print(code.value);
+	}
+
+	public void writeStructured(WycsFile wf, Code.Unary code, int indent) {
+		switch(code.opcode) {
+		case NEG:
+			out.print("-");
+			writeStructured(wf,code.operands[0],indent);
+			break;
+		case NOT:
+			out.println("not:");
+			indent(indent+1);
+			writeStructured(wf,code.operands[0],indent+1);
+			break;
+		case LENGTH:
+			out.print("|");
+			writeStructured(wf,code.operands[0],indent);
+			out.print("|");
+			break;
+		default:
+			throw new InternalFailure("unknown bytecode encountered", wf.getEntry(), code);
+		}
+	}
+
+	public void writeStructured(WycsFile wf, Code.Binary code, int indent) {
+		String op;
+		switch(code.opcode) {
+		case ADD:
+			op = " + ";
+			break;
+		case SUB:
+			op = " - ";
+			break;
+		case MUL:
+			op = " * ";
+			break;
+		case DIV:
+			op = " / ";
+			break;
+		case REM:
+			op = " % ";
+			break;
+		case EQ:
+			op = " == ";
+			break;
+		case NEQ:
+			op = " != ";
+			break;
+		case LT:
+			op = " < ";
+			break;
+		case LTEQ:
+			op = " <= ";
+			break;		
+		case ARRAYGEN:
+			out.print("[");
+			writeStructured(wf,code.operands[0],indent);
+			out.print(";");
+			writeStructured(wf,code.operands[1],indent);
+			out.print("]");
+			return;
+		default:
+			throw new InternalFailure("unknown bytecode encountered", wf.getEntry(), code);
+		}
+
+		writeStructured(wf,code.operands[0],indent);
+		out.print(op);
+		writeStructured(wf,code.operands[1],indent);
+	}
+
+	public void writeStructured(WycsFile wf, Code.Nary code, int indent) {
+		switch(code.opcode) {
+		case AND:
+			for(int i=0;i!=code.operands.length;++i) {
+				if(i!=0) {
+					out.println();
+					indent(indent);
+				}
+				writeStructured(wf,code.operands[i],indent);
+			}
+			break;
+		case OR:
+			for(int i=0;i!=code.operands.length;++i) {
+				if(i!=0) {
+					out.println();
+					indent(indent);
+				}
+				out.println("case:");
+				indent(indent+1);
+				writeStructured(wf,code.operands[i],indent+1);
+			}
+			break;
+		case TUPLE:
+			out.print("(");
+			for(int i=0;i!=code.operands.length;++i) {
+				if(i!=0) {
+					out.print(", ");
+				}
+				writeStructured(wf,code.operands[i],indent);
+			}
+			out.print(")");
+			break;
+		case ARRAY:
+			out.print("[");
+			for(int i=0;i!=code.operands.length;++i) {
+				if(i!=0) {
+					out.print(", ");
+				}
+				writeStructured(wf,code.operands[i],indent);
+			}
+			out.print("]");
+			break;
+		default:
+			throw new InternalFailure("unknown bytecode encountered", wf.getEntry(), code);
+		}
+	}
+
+	public void writeStructured(WycsFile wf, Code.Load code, int indent) {
+		writeStructured(wf,code.operands[0],indent);
+		out.print("[" + code.index + "]");
+	}
+
+	public void writeStructured(WycsFile wf, Code.IndexOf code, int indent) {
+		writeStructured(wf,code.operands[0],indent);
+		out.print("[");
+		writeStructured(wf,code.operands[1],indent);
+		out.print("]");
+	}
+	
+	public void writeStructured(WycsFile wf, Code.Is code, int indent) {
+		writeStructured(wf,code.operands[0],indent);
+		out.print(" is " + code.test);
+	}
+	
+	public void writeStructured(WycsFile wf, Code.Cast code, int indent) {
+		out.print("(" + code.type + ")");
+		writeStructured(wf,code.operands[0],indent);		
+	}
+	
+	public void writeStructured(WycsFile wf, Code.FunCall code, int indent) {
+		out.print(code.nid + "(");
+		writeStructured(wf,code.operands[0],indent);
+		out.print(")");
+	}
+
+	public void writeStructured(WycsFile wf, Code.Quantifier code, int indent) {
+		if(code.opcode == Code.Op.FORALL) {
+			out.print("forall(");
+		} else {
+			out.print("some(");
+		}
+		boolean firstTime=true;
+		for(Pair<SemanticType,Integer> p : code.types) {
+			if(!firstTime) {
+				out.print(", ");
+			}
+			firstTime=false;
+			out.print(p.first() + " r" + p.second());
+		}
+		out.println("):");
+		indent(indent+1);
+		writeStructured(wf,code.operands[0],indent+1);
+	}
+
+	public int writeRaw(WycsFile wf, Code<?> code, int index) {
+		int[] operands = new int[code.operands.length];
+		int next = index;
+		for(int i=0;i!=operands.length;++i) {
+			next = writeRaw(wf,code.operands[i],next);
+			operands[i] = next;
+		}
+		indent(1);
+		next = next + 1;
+		out.print("#" + next + " = ");
+		out.print(code.opcode.toString());
+		if(operands.length > 0) {
+			out.print("(");
+			for(int i=0;i!=operands.length;++i) {
+				if(i != 0) {
+					out.print(", ");
+				}
+				out.print("#" + operands[i]);
+			}
+			out.print(")");
+		}
+		if(code instanceof Code.Constant) {
+			Code.Constant c = (Code.Constant) code;
+			out.print(" " + c.value);
+		} else if(code instanceof Code.Variable) {
+			Code.Variable c = (Code.Variable) code;
+			out.print(" " + c.index);
+		}
+		out.println(" : " + code.type);
+		return next;
+	}
+
+	private void indent(int indent) {
+		indent = indent * 4;
+		for(int i=0;i<indent;++i) {
+			out.print(" ");
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/io/WycsFileReader.java b/modules/wycs/src/wycs/io/WycsFileReader.java
new file mode 100755
index 0000000000..f8e76ddf89
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WycsFileReader.java
@@ -0,0 +1,445 @@
+package wycs.io;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UnsupportedEncodingException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.List;
+
+import wyautl.core.Automaton;
+import wyautl.io.BinaryAutomataReader;
+import wycc.lang.NameID;
+import wycc.util.Pair;
+import wycs.core.*;
+import wyfs.io.BinaryInputStream;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+public class WycsFileReader {
+	private static final char[] magic = { 'W', 'Y', 'C', 'S', 'F', 'I', 'L',
+			'E' };
+
+	private Path.Entry<WycsFile> entry;
+	private BinaryInputStream input;
+	private String[] stringPool;
+	private Path.ID[] pathPool;
+	private NameID[] namePool;
+	private Value[] constantPool;
+	private SemanticType[] typePool;
+
+	public WycsFileReader(Path.Entry<WycsFile> entry, InputStream input) {
+		this.entry = entry;
+		this.input = new BinaryInputStream(input);
+	}
+
+	public void close() throws IOException {
+		input.close();
+	}
+
+	public WycsFile read() throws IOException {
+		for (int i = 0; i != 8; ++i) {
+			char c = (char) input.read_u8();
+			if (magic[i] != c) {
+				throw new IllegalArgumentException("invalid magic number");
+			}
+		}
+
+		// header block
+		int kind = input.read_uv();
+		int size = input.read_uv();
+		input.pad_u8();
+
+		if (kind != WycsFileWriter.BLOCK_Header) {
+			throw new IllegalArgumentException("header block must come first");
+		}
+
+		int majorVersion = input.read_uv();
+		int minorVersion = input.read_uv();
+
+		int stringPoolSize = input.read_uv();
+		int pathPoolSize = input.read_uv();
+		int namePoolSize = input.read_uv();
+		int typePoolSize = input.read_uv();
+		int constantPoolSize = input.read_uv();
+
+		int numBlocks = input.read_uv();
+
+		readStringPool(stringPoolSize);
+		readPathPool(pathPoolSize);
+		readNamePool(namePoolSize);
+		readTypePool(typePoolSize);
+
+		readConstantPool(constantPoolSize);
+
+		input.pad_u8();
+
+		return readModule();
+	}
+
+	private void readStringPool(int size) throws IOException {
+		final String[] myStringPool = new String[size];
+
+		for (int i = 0; i != size; ++i) {
+			int length = input.read_uv();
+			try {
+				byte[] data = new byte[length];
+				input.read(data);
+				String str = new String(data, 0, length, "UTF-8");
+				myStringPool[i] = str;
+			} catch (UnsupportedEncodingException e) {
+				throw new RuntimeException("UTF-8 Charset not supported?");
+			}
+		}
+		stringPool = myStringPool;
+	}
+
+	private void readPathPool(int size) throws IOException {
+		final Path.ID[] myPathPool = new Path.ID[size];
+		myPathPool[0] = Trie.ROOT;
+
+		for (int i = 1; i != size; ++i) {
+			int parent = input.read_uv();
+			int stringIndex = input.read_uv();
+			Path.ID id;
+			id = myPathPool[parent];
+			id = id.append(stringPool[stringIndex]);
+			myPathPool[i] = id;
+		}
+		pathPool = myPathPool;
+	}
+
+	private void readNamePool(int size) throws IOException {
+		final NameID[] myNamePool = new NameID[size];
+
+		for (int i = 0; i != size; ++i) {
+			// int kind = input.read_uv();
+			int pathIndex = input.read_uv();
+			int nameIndex = input.read_uv();
+			Path.ID id = pathPool[pathIndex];
+			String name = stringPool[nameIndex];
+			myNamePool[i] = new NameID(id, name);
+		}
+
+		namePool = myNamePool;
+	}
+
+	private void readConstantPool(int size) throws IOException {
+		final Value[] myConstantPool = new Value[size];
+
+		for (int i = 0; i != size; ++i) {
+			int code = input.read_uv();
+			Value constant;
+			switch (code) {
+			case WycsFileWriter.CONSTANT_Null:
+				constant = Value.Null;
+				break;
+			case WycsFileWriter.CONSTANT_False:
+				constant = Value.Bool(false);
+				break;
+			case WycsFileWriter.CONSTANT_True:
+				constant = Value.Bool(true);
+				break;
+			case WycsFileWriter.CONSTANT_Int: {
+				int len = input.read_uv();
+				byte[] bytes = new byte[len];
+				input.read(bytes);
+				BigInteger bi = new BigInteger(bytes);
+				constant = Value.Integer(bi);
+				break;
+			}
+			case WycsFileWriter.CONSTANT_Real: {
+				int len = input.read_uv();
+				byte[] bytes = new byte[len];
+				input.read(bytes);
+				BigInteger mantissa = new BigInteger(bytes);
+				int exponent = input.read_uv();
+				constant = Value.Decimal(new BigDecimal(mantissa, exponent));
+				break;
+			}
+			case WycsFileWriter.CONSTANT_String: {
+				int index = input.read_uv();
+				constant = Value.String(stringPool[index]);
+				break;
+			}
+			case WycsFileWriter.CONSTANT_Array: {
+				int len = input.read_uv();
+				ArrayList<Value> values = new ArrayList<Value>();
+				for (int j = 0; j != len; ++j) {
+					int index = input.read_uv();
+					values.add(myConstantPool[index]);
+				}
+				constant = Value.Array(values);
+				break;
+			}
+			case WycsFileWriter.CONSTANT_Tuple: {
+				int len = input.read_uv();
+				ArrayList<Value> values = new ArrayList<Value>();
+				for (int j = 0; j != len; ++j) {
+					int index = input.read_uv();
+					values.add(myConstantPool[index]);
+				}
+				constant = Value.Tuple(values);
+				break;
+			}
+			default:
+				throw new RuntimeException("Unknown constant encountered: "
+						+ code);
+			}
+			myConstantPool[i] = constant;
+		}
+
+		constantPool = myConstantPool;
+	}
+
+	private void readTypePool(int size) throws IOException {
+		final SemanticType[] myTypePool = new SemanticType[size];
+		BinaryAutomataReader reader = new BinaryAutomataReader(input,
+				Types.SCHEMA);
+		Automaton global = reader.read();
+
+		for (int i = 0; i != size; ++i) {
+			Automaton automaton = new Automaton();
+			int root = automaton.addAll(global.getRoot(i), global);
+			automaton.setRoot(0, root);
+			SemanticType t = SemanticType.construct(automaton);
+			myTypePool[i] = t;
+		}
+
+		typePool = myTypePool;
+	}
+
+	private WycsFile readModule() throws IOException {
+		int kind = input.read_uv(); // block identifier
+		int size = input.read_uv();
+		input.pad_u8();
+
+		int pathIdx = input.read_uv();
+		int numBlocks = input.read_uv();
+
+		List<WycsFile.Declaration> declarations = new ArrayList<WycsFile.Declaration>();
+		for (int i = 0; i != numBlocks; ++i) {
+			declarations.add(readBlock(WycsFile.Declaration.class));
+		}
+		
+		Path.ID id = pathPool[pathIdx];
+		
+		return new WycsFile(entry, declarations);
+	}
+
+	private <T> T readBlock(Class<T> expected) throws IOException {
+
+		input.pad_u8(); // pad out to next byte boundary
+
+		int kind = input.read_uv();
+		int size = input.read_uv();
+
+		input.pad_u8(); // pad out to next byte boundary
+		Object block;
+
+		switch (kind) {
+		case WycsFileWriter.BLOCK_Macro:
+			block = readMacroBlockBody();
+			break;
+		case WycsFileWriter.BLOCK_Type:
+			block = readTypeBlockBody();
+			break;
+		case WycsFileWriter.BLOCK_Function:
+			block = readFunctionBlockBody();
+			break;
+		case WycsFileWriter.BLOCK_Assert:
+			block = readAssertBlockBody();
+			break;
+		case WycsFileWriter.BLOCK_Code:
+			block = readCodeBlockBody();
+			break;
+		default:
+			throw new RuntimeException("unknown block encountered (" + kind
+					+ ")");
+		}
+
+		input.pad_u8(); // pad out to next byte boundary
+		
+		if (expected.isInstance(block)) {
+			return (T) block;
+		} else {
+			throw new RuntimeException("incorrect block encountered (" + kind
+					+ ")");
+		}
+	}
+
+	// ====================================================================
+	// Block body readers
+	// ====================================================================
+
+	private WycsFile.Declaration readMacroBlockBody() throws IOException {
+		int nameIdx = input.read_uv();
+		int typeIdx = input.read_uv();
+		int nBlocks = input.read_uv();
+		Code<?> code = readBlock(Code.class);
+
+		return new WycsFile.Macro(stringPool[nameIdx],
+				(SemanticType.Function) typePool[typeIdx], code);
+	}
+
+	private WycsFile.Declaration readTypeBlockBody() throws IOException {
+		int nameIdx = input.read_uv();
+		int typeIdx = input.read_uv();
+		int nBlocks = input.read_uv();
+		Code<?> code = null;
+		if(nBlocks > 0) {
+			code = readBlock(Code.class);
+		}
+
+		return new WycsFile.Type(stringPool[nameIdx],
+				(SemanticType) typePool[typeIdx], code);
+	}
+	
+	private WycsFile.Declaration readFunctionBlockBody() throws IOException {
+		int nameIdx = input.read_uv();
+		int typeIdx = input.read_uv();
+		int nBlocks = input.read_uv();
+		Code<?> code = null;
+		if (nBlocks > 0) {
+			code = readBlock(Code.class);
+		}
+		return new WycsFile.Function(stringPool[nameIdx],
+				(SemanticType.Function) typePool[typeIdx], code);
+	}
+
+	private WycsFile.Declaration readAssertBlockBody() throws IOException {
+		int nameIdx = input.read_uv();
+		int nBlocks = input.read_uv();
+		Code<?> code = readBlock(Code.class);
+		return new WycsFile.Assert(stringPool[nameIdx], code);
+	}
+
+	private Code readCodeBlockBody() throws IOException {
+		int opcode = input.read_u8();
+		if(opcode == Code.Op.NULL.offset) {
+			// special case
+			return null;
+		} else {
+			int typeIdx = input.read_uv();
+			SemanticType type = typePool[typeIdx];
+			int nOperands = input.read_uv();
+			Code[] operands = new Code[nOperands];
+			for (int i = 0; i != nOperands; ++i) {
+				operands[i] = readCodeBlockBody();
+			}
+			Code.Op op = op(opcode);
+
+			switch (op) {
+			case VAR: {
+				int varIdx = input.read_uv();
+				return Code.Variable(type, operands, varIdx);
+			}
+			case CAST: {
+				int targetTypeIdx = input.read_uv();
+				if (operands.length != 1) {
+					throw new RuntimeException(
+							"invalid cast bytecode encountered");
+				}
+				return Code.Cast(type,operands[0],typePool[targetTypeIdx]);
+			}
+			case CONST: {
+				int constIdx = input.read_uv();
+				if (operands.length != 0) {
+					throw new RuntimeException(
+							"invalid constant bytecode encountered");
+				}
+				return Code.Constant(constantPool[constIdx]);
+			}
+			case NOT:
+			case NEG:
+			case LENGTH:
+				if (operands.length != 1) {
+					throw new RuntimeException("invalid unary bytecode encountered");
+				}
+				return Code.Unary(type, op, operands[0]);
+			case ADD:
+			case SUB:
+			case MUL:
+			case DIV:
+			case REM:
+			case EQ:
+			case NEQ:
+			case LT:
+			case LTEQ:
+				if (operands.length != 2) {
+					throw new RuntimeException(
+							"invalid binary bytecode encountered");
+				}
+				return Code.Binary(type, op, operands[0], operands[1]);
+			case IS:
+				if (operands.length != 1) {
+					throw new RuntimeException(
+							"invalid is bytecode encountered");
+				}
+				int testIdx = input.read_uv();
+				return Code.Is(type, operands[0], typePool[testIdx]);
+			case AND:
+			case OR:
+			case TUPLE:
+			case ARRAY:
+				return Code.Nary(type, op, operands);
+			case LOAD: {
+				if (operands.length != 1 || !(type instanceof SemanticType.Tuple)) {
+					throw new RuntimeException("invalid load bytecode encountered");
+				}
+				int index = input.read_uv();
+				return Code.Load((SemanticType.Tuple) type, operands[0], index);
+			}
+			case INDEXOF: {
+				if (operands.length != 2 || !(type instanceof SemanticType.Array)) {
+					throw new RuntimeException("invalid indexof bytecode encountered");
+				}
+				return Code.IndexOf((SemanticType.Array) type, operands[0], operands[1]);
+			}
+			case FORALL:
+			case EXISTS: {
+				if (operands.length != 1) {
+					throw new RuntimeException(
+							"invalid quantifier bytecode encountered");
+				}
+				int length = input.read_uv();
+				Pair<SemanticType,Integer>[] types = new Pair[length];
+				for (int i = 0; i != length; ++i) {
+					int pTypeIdx = input.read_uv();
+					int pVarIdx = input.read_uv();
+					types[i] = new Pair<SemanticType,Integer>(
+							typePool[pTypeIdx], pVarIdx);
+				}
+				return Code.Quantifier(type, op, operands[0], types);
+			}
+			case FUNCALL: {
+				if (operands.length != 1
+						|| !(type instanceof SemanticType.Function)) {
+					throw new RuntimeException(
+							"invalid funcall bytecode encountered");
+				}
+				int nid = input.read_uv();
+				int length = input.read_uv();
+				SemanticType[] binding = new SemanticType[length];
+				for (int i = 0; i != length; ++i) {
+					int pTypeIdx = input.read_uv();
+					binding[i] = typePool[pTypeIdx];					
+				}
+				return Code.FunCall((SemanticType.Function) type, operands[0], namePool[nid], binding);
+			}
+			}
+
+			throw new RuntimeException("unknown opcode encountered: " + opcode);
+		}
+	}
+
+	private Code.Op op(int opcode) {
+		for (Code.Op op : Code.Op.values()) {
+			if (op.offset == opcode) {
+				return op;
+			}
+		}
+		throw new RuntimeException("unknown opcode encountered: " + opcode);
+	}
+}
diff --git a/modules/wycs/src/wycs/io/WycsFileWriter.java b/modules/wycs/src/wycs/io/WycsFileWriter.java
new file mode 100755
index 0000000000..ce2dcdd103
--- /dev/null
+++ b/modules/wycs/src/wycs/io/WycsFileWriter.java
@@ -0,0 +1,752 @@
+package wycs.io;
+
+import java.io.*;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+import wyautl.core.Automaton;
+import wyautl.io.BinaryAutomataWriter;
+import wyautl.util.BigRational;
+import wycc.lang.NameID;
+import wycc.util.Pair;
+import wycc.util.Triple;
+import wycs.core.*;
+import wyfs.io.BinaryOutputStream;
+import wyfs.lang.Path;
+
+public class WycsFileWriter {
+	private static final int MAJOR_VERSION = 0;
+	private static final int MINOR_VERSION = 1;
+
+	private BinaryOutputStream out;
+
+	private final ArrayList<String> stringPool  = new ArrayList<String>();
+	private final HashMap<String,Integer> stringCache = new HashMap<String,Integer>();
+	private final ArrayList<PATH_Item> pathPool = new ArrayList<PATH_Item>();
+	private final HashMap<Path.ID,Integer> pathCache = new HashMap<Path.ID,Integer>();
+	private final ArrayList<NAME_Item> namePool = new ArrayList<NAME_Item>();
+	private final HashMap<NameID,Integer> nameCache = new HashMap<NameID,Integer>();
+	private final ArrayList<Value> constantPool = new ArrayList<Value>();
+	private final HashMap<Value,Integer> constantCache = new HashMap<Value,Integer>();
+	private final ArrayList<SemanticType> typePool = new ArrayList<SemanticType>();
+	private final HashMap<SemanticType,Integer> typeCache = new HashMap<SemanticType,Integer>();
+
+	public WycsFileWriter(OutputStream output) {
+		this.out = new BinaryOutputStream(output);
+	}
+
+	public void write(WycsFile module) throws IOException {
+		// first, write magic number
+		out.write_u8(0x57); // W
+		out.write_u8(0x59); // Y
+		out.write_u8(0x43); // C
+		out.write_u8(0x53); // S
+		out.write_u8(0x46); // F
+		out.write_u8(0x49); // I
+		out.write_u8(0x4C); // L
+		out.write_u8(0x45); // E
+
+		// second, build pools
+		buildPools(module);
+
+		// third, write head block
+		writeBlock(BLOCK_Header,module,out);
+
+		// fourth, write module block(s)
+		writeBlock(BLOCK_Module,module,out);
+
+		out.flush();
+	}
+
+	private void writeBlock(int kind, Object data, BinaryOutputStream output)
+			throws IOException {
+
+		output.pad_u8(); // pad out to next byte boundary
+
+		// determine bytes for block
+		byte[] bytes = null;
+		switch(kind) {
+			case BLOCK_Header:
+				bytes = generateHeaderBlock((WycsFile) data);
+				break;
+			case BLOCK_Module:
+				bytes = generateModuleBlock((WycsFile) data);
+				break;
+			case BLOCK_Macro:
+				bytes = generateMacroBlock((WycsFile.Macro) data);
+				break;
+			case BLOCK_Function:
+				bytes = generateFunctionBlock((WycsFile.Function) data);
+				break;
+			case BLOCK_Type:
+				bytes = generateTypeBlock((WycsFile.Type) data);
+				break;			
+			case BLOCK_Assert:
+				bytes = generateAssertBlock((WycsFile.Assert) data);
+				break;
+			case BLOCK_Code:
+				bytes = generateCodeBlock((Code) data);
+				break;
+		}
+
+		output.write_uv(kind);
+		output.write_uv(bytes.length);
+		output.pad_u8(); // pad out to next byte boundary
+		output.write(bytes);
+	}
+
+	/**
+	 * Write the header information for this WYCS file, including the stratified
+	 * resource pool.
+	 *
+	 * @param module
+	 *
+	 * @throws IOException
+	 */
+	private byte[] generateHeaderBlock(WycsFile module)
+			throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		// second, write the file version number
+		output.write_uv(MAJOR_VERSION);
+		output.write_uv(MINOR_VERSION);
+
+		// third, write the various pool sizes
+		output.write_uv(stringPool.size());
+		output.write_uv(pathPool.size());
+		output.write_uv(namePool.size());
+		output.write_uv(typePool.size());
+		output.write_uv(constantPool.size());
+
+		// finally, write the number of remaining blocks
+		output.write_uv(module.declarations().size());
+
+		writeStringPool(output);
+		writePathPool(output);
+		writeNamePool(output);
+		writeTypePool(output);
+		writeConstantPool(output);
+
+		output.close();
+
+		return bytes.toByteArray();
+	}
+
+	private byte[] generateModuleBlock(WycsFile module) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		output.write_uv(pathCache.get(module.getEntry().id())); // FIXME: BROKEN!
+		output.write_uv(module.declarations().size());
+
+		for (WycsFile.Declaration d : module.declarations()) {
+			writeModuleBlock(d, output);
+		}
+
+		output.close();
+
+		return bytes.toByteArray();
+	}
+
+	/**
+	 * Write the list of strings making up the string pool in UTF8.
+	 *
+	 * @throws IOException
+	 */
+	private void writeStringPool(BinaryOutputStream output) throws IOException {
+		//System.out.println("Writing " + stringPool.size() + " string item(s).");
+		for (String s : stringPool) {
+			try {
+				byte[] bytes = s.getBytes("UTF-8");
+				output.write_uv(bytes.length);
+				output.write(bytes, 0, bytes.length);
+			} catch (UnsupportedEncodingException e) {
+				// hmmm, this aint pretty ;)
+			}
+		}
+	}
+
+	private void writePathPool(BinaryOutputStream output) throws IOException {
+		for(int i=1;i<pathPool.size();++i) {
+			PATH_Item p = pathPool.get(i);
+			output.write_uv(p.parentIndex);
+			output.write_uv(p.stringIndex);
+		}
+	}
+
+	private void writeNamePool(BinaryOutputStream output) throws IOException {
+		//System.out.println("Writing " + stringPool.size() + " name item(s).");
+		for (NAME_Item p : namePool) {
+			//output.write_uv(p.kind.kind());
+			output.write_uv(p.pathIndex);
+			output.write_uv(p.nameIndex);
+		}
+	}
+
+	private void writeConstantPool(BinaryOutputStream output) throws IOException {
+		// System.out.println("Writing " + constantPool.size() + " constant item(s).");
+
+		for (Value val : constantPool) {
+			if(val instanceof Value.Null) {
+				Value.Null b = (Value.Null) val;
+				output.write_uv(CONSTANT_Null);
+			} else if(val instanceof Value.Bool) {
+				Value.Bool b = (Value.Bool) val;
+				output.write_uv(b.value ? CONSTANT_True : CONSTANT_False);
+			} else if(val instanceof Value.Integer) {
+				Value.Integer i = (Value.Integer) val;
+				BigInteger num = i.value;
+				byte[] numbytes = num.toByteArray();
+				output.write_uv(CONSTANT_Int);
+				output.write_uv(numbytes.length);
+				output.write(numbytes);
+			} else if(val instanceof Value.String) {
+				Value.String s = (Value.String) val;
+				output.write_uv(CONSTANT_String);
+				String value = s.value;
+				output.write_uv(stringCache.get(value));
+
+			} else if(val instanceof Value.Decimal) {
+				Value.Decimal r = (Value.Decimal) val;
+				output.write_uv(CONSTANT_Real);
+				BigInteger mantissa = r.value.unscaledValue();
+				int exponent = r.value.scale();
+				byte[] bytes = mantissa.toByteArray();
+				output.write_uv(bytes.length);
+				output.write(bytes);
+				output.write_uv(exponent);
+
+			} else if(val instanceof Value.Array) {
+				Value.Array s = (Value.Array) val;
+				output.write_uv(CONSTANT_Array);
+				output.write_uv(s.values.size());
+				for(Value v : s.values) {
+					int index = constantCache.get(v);
+					output.write_uv(index);
+				}
+
+			} else if(val instanceof Value.Tuple) {
+				Value.Tuple t = (Value.Tuple) val;
+				output.write_uv(CONSTANT_Tuple);
+				output.write_uv(t.values.size());
+				for(Value v : t.values) {
+					int index = constantCache.get(v);
+					output.write_uv(index);
+				}
+			} else {
+				throw new RuntimeException("Unknown value encountered - " + val);
+			}
+		}
+	}
+
+	private void writeTypePool(BinaryOutputStream output) throws IOException {
+		// First, we accumulate the automata for all types in the pool into one
+		// automaton. This helps reduce the amount of redundancy between types.
+		Automaton global = new Automaton();
+		for (int i = 0; i != typePool.size(); ++i) {
+			Automaton automaton = typePool.get(i).automaton();
+			int root = global.addAll(automaton.getRoot(0), automaton);
+			global.setRoot(i, root);
+		}
+
+		global.minimise();
+		global.compact(0);
+		// FIXME: put this back in!!
+		// global.canonicalise();
+
+		// Second, we write the single global automaton to the output stream.
+		BinaryAutomataWriter writer = new BinaryAutomataWriter(output,
+				Types.SCHEMA);
+		writer.write(global);
+	}
+
+	private void writeModuleBlock(WycsFile.Declaration d,
+			BinaryOutputStream output) throws IOException {
+		if(d instanceof WycsFile.Macro) {
+			writeBlock(BLOCK_Macro, d ,output);
+		} else if(d instanceof WycsFile.Type) {
+			writeBlock(BLOCK_Type, d ,output);
+		} else if(d instanceof WycsFile.Function) {
+			writeBlock(BLOCK_Function, d, output);
+		} else if(d instanceof WycsFile.Assert) {
+			writeBlock(BLOCK_Assert, d, output);
+		}
+	}
+
+	private byte[] generateMacroBlock(WycsFile.Macro md) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		output.write_uv(stringCache.get(md.name()));
+		output.write_uv(typeCache.get(md.type));
+		output.write_uv(1);
+		writeBlock(BLOCK_Code,md.condition,output);
+
+		output.close();
+		return bytes.toByteArray();
+	}
+
+	private byte[] generateTypeBlock(WycsFile.Type md) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		output.write_uv(stringCache.get(md.name()));
+		output.write_uv(typeCache.get(md.type));
+		if(md.invariant == null) {
+			output.write_uv(0);			
+		} else {
+			output.write_uv(1);
+			writeBlock(BLOCK_Code,md.invariant,output);
+		}
+
+		output.close();
+		return bytes.toByteArray();
+	}
+	
+	private byte[] generateFunctionBlock(WycsFile.Function fd) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		output.write_uv(stringCache.get(fd.name()));
+		output.write_uv(typeCache.get(fd.type));
+		if(fd.constraint == null) {
+			output.write_uv(0); // no sub-blocks
+		} else {
+			output.write_uv(1); // one sub-block
+			writeBlock(BLOCK_Code,fd.constraint,output);
+		}
+
+		output.close();
+		return bytes.toByteArray();
+	}
+
+	private byte[] generateAssertBlock(WycsFile.Assert td) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		output.write_uv(stringCache.get(td.name()));
+		output.write_uv(1); // one sub-block
+		writeBlock(BLOCK_Code,td.condition,output);
+
+		output.close();
+		return bytes.toByteArray();
+	}
+
+	/**
+	 * Flatten a Wycs bytecode into a byte stream. Each Wycs bytecode represents
+	 * a tree of operations and, hence, this function recursively traverses the
+	 * tree.
+	 *
+	 * @param code
+	 * @return
+	 * @throws IOException
+	 */
+	private byte[] generateCodeBlock(Code<?> code) throws IOException {
+		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+		BinaryOutputStream output = new BinaryOutputStream(bytes);
+
+		writeCode(code,output);
+
+		output.close();
+		return bytes.toByteArray();
+	}
+
+	/**
+	 * <p>
+	 * Write a given code to a binary output stream. Every bytecode is written
+	 * in the following structure:
+	 * </p>
+	 *
+	 * <pre>
+	 * +---------------+
+	 * | opcode        |
+	 * +---------------+
+	 * | type index    |
+	 * +---------------+
+	 * | operand count |
+	 * +---------------+
+	 * | 1st operand   |
+	 * +---------------+
+	 * |               |
+	 *
+	 * ...
+	 * |               |
+	 * +---------------+
+	 * | Nth operand   |
+	 * +---------------+
+	 * | Payload       |
+	 * +---------------+
+	 * </pre>
+	 *
+	 * <p>
+	 * Each cell here is of varying size and is written using one or more 4-bit
+	 * nibbles. The type index is an index into the type pool which gives the
+	 * type associated with this bytecode. The operand count determines the
+	 * number of operands (if any). The payload is an option field which
+	 * contains bytecode specific data. For example, a constant bytecode will
+	 * contain an index into the constant pool here.
+	 * </p>
+	 *
+	 * @param code
+	 * @param output
+	 * @throws IOException
+	 */
+	private void writeCode(Code<?> code, BinaryOutputStream output) throws IOException {
+		if(code == null) {
+			// this is a special case
+			output.write_u8(Code.Op.NULL.offset);
+		} else {
+			output.write_u8(code.opcode.offset);
+			output.write_uv(typeCache.get(code.type));
+			output.write_uv(code.operands.length);
+			for(int i=0;i!=code.operands.length;++i) {
+				writeCode(code.operands[i],output);
+			}
+			// now, write bytecode specific stuff
+			switch(code.opcode){
+			case VAR: {
+				Code.Variable v = (Code.Variable) code;
+				output.write_uv(v.index);
+				break;
+			}
+			case CAST: {
+				Code.Cast c = (Code.Cast) code;
+				output.write_uv(typeCache.get(c.target));
+				break;
+			}
+			case CONST: {
+				Code.Constant c = (Code.Constant) code;
+				output.write_uv(constantCache.get(c.value));
+				break;
+			}
+			case IS: {
+				Code.Is is = (Code.Is) code; 
+				output.write_uv(typeCache.get(is.test));
+				break;
+			}
+			case LOAD: {
+				Code.Load c = (Code.Load) code;
+				output.write_uv(c.index);
+				break;
+			}			
+			case FORALL:
+			case EXISTS: {
+				Code.Quantifier c = (Code.Quantifier) code;
+				output.write_uv(c.types.length);
+				for (Pair<SemanticType,Integer> t : c.types) {
+					output.write_uv(typeCache.get(t.first()));
+					output.write_uv(t.second());
+				}
+				break;
+			}
+			case FUNCALL: {
+				Code.FunCall c = (Code.FunCall) code;
+				output.write_uv(nameCache.get(c.nid));
+				output.write_uv(c.binding.length);
+				for (SemanticType t : c.binding) {
+					output.write_uv(typeCache.get(t));					
+				}				
+			}
+			}
+		}
+	}
+
+	/**
+	 * Build the various pools of items (strings, types, constants, etc) which
+	 * are used within the bytecodes, and within the declarations (e.g.
+	 * assertions, etc). Each pool consists of an array of indexed items of the
+	 * same kind. Items in some pools (e.g. constant) may refer to items in
+	 * other pools (e.g. string) and this referencing is done via an index into
+	 * the given pool.
+	 *
+	 * @param module
+	 */
+	private void buildPools(WycsFile module) {
+		stringPool.clear();
+		stringCache.clear();
+
+		pathPool.clear();
+		pathCache.clear();
+		// preload the path root
+		pathPool.add(null);
+		pathCache.put(wyfs.util.Trie.ROOT,0);
+
+		constantPool.clear();
+		constantCache.clear();
+
+		typePool.clear();
+		typeCache.clear();
+
+		addPathItem(module.getEntry().id());
+		for(WycsFile.Declaration d : module.declarations()) {
+			buildPools(d);
+		}
+	}
+
+	private void buildPools(WycsFile.Declaration declaration) {
+		if(declaration instanceof WycsFile.Macro) {
+			buildPools((WycsFile.Macro)declaration);
+		} else if(declaration instanceof WycsFile.Type) {
+			buildPools((WycsFile.Type)declaration);
+		} else if(declaration instanceof WycsFile.Function) {
+			buildPools((WycsFile.Function)declaration);
+		} else if(declaration instanceof WycsFile.Assert) {
+			buildPools((WycsFile.Assert)declaration);
+		}
+	}
+
+	private void buildPools(WycsFile.Macro declaration) {
+		addStringItem(declaration.name());
+		addTypeItem(declaration.type);
+		buildPools(declaration.condition);
+	}
+
+	private void buildPools(WycsFile.Type declaration) {
+		addStringItem(declaration.name());
+		addTypeItem(declaration.type);
+		if(declaration.invariant != null) {
+			buildPools(declaration.invariant);
+		}
+	}
+
+	private void buildPools(WycsFile.Function declaration) {
+		addStringItem(declaration.name());
+		addTypeItem(declaration.type);
+		if(declaration.constraint != null) {
+			buildPools(declaration.constraint);
+		}
+	}
+
+	private void buildPools(WycsFile.Assert declaration) {
+		addStringItem(declaration.name());
+		buildPools(declaration.condition);
+	}
+
+	private void buildPools(Code code) {
+
+		// First, deal with special cases
+		if(code instanceof Code.Constant) {
+			Code.Constant c = (Code.Constant) code;
+			addConstantItem(c.value);
+		} else if(code instanceof Code.Cast) {
+			Code.Cast c = (Code.Cast) code;
+			addTypeItem(c.target);			
+		} else if(code instanceof Code.Quantifier) {
+			Code.Quantifier c = (Code.Quantifier) code;
+			for(Pair<SemanticType,Integer> p : c.types) {
+				addTypeItem(p.first());
+			}
+		} else if(code instanceof Code.FunCall) {
+			Code.FunCall c = (Code.FunCall) code;
+			addNameItem(c.nid);
+			for(SemanticType t : c.binding) {
+				addTypeItem(t);
+			}
+		} else if(code instanceof Code.Is) {
+			Code.Is c = (Code.Is) code;
+			addTypeItem(c.test);
+		} 
+
+		// Second, deal with standard cases
+		addTypeItem(code.type);
+
+		for(Code operand : code.operands) {
+			buildPools(operand);
+		}
+	}
+
+
+	private int addNameItem(NameID name) {
+		Integer index = nameCache.get(name);
+		if(index == null) {
+			int i = namePool.size();
+			nameCache.put(name, i);
+			namePool.add(new NAME_Item(addPathItem(name.module()),
+					addStringItem(name.name())));
+			return i;
+		} else {
+			return index;
+		}
+	}
+
+	private int addStringItem(String string) {
+		Integer index = stringCache.get(string);
+		if(index == null) {
+			int i = stringPool.size();
+			stringCache.put(string, i);
+			stringPool.add(string);
+			return i;
+		} else {
+			return index;
+		}
+	}
+
+	private int addPathItem(Path.ID pid) {
+		Integer index = pathCache.get(pid);
+		if(index == null) {
+			int parent = addPathItem(pid.parent());
+			int i = pathPool.size();
+			pathPool.add(new PATH_Item(parent,addStringItem(pid.last())));
+			pathCache.put(pid, i);
+			return i;
+		} else {
+			return index;
+		}
+	}
+
+	private int addTypeItem(SemanticType t) {
+
+		// TODO: this could be made way more efficient. In particular, we should
+		// combine resources into a proper aliased pool rather than write out
+		// types individually ... because that's sooooo inefficient!
+
+		Integer index = typeCache.get(t);
+		if(index == null) {
+			int i = typePool.size();
+			typeCache.put(t, i);
+			typePool.add(t);
+			return i;
+		} else {
+			return index;
+		}
+	}
+
+	private int addConstantItem(Value v) {
+
+		Integer index = constantCache.get(v);
+		if(index == null) {
+			// All subitems must have lower indices than the containing item.
+			// So, we must add subitems first before attempting to allocate a
+			// place for this value.
+			addConstantSubitems(v);
+
+			// finally allocate space for this constant.
+			int i = constantPool.size();
+			constantCache.put(v, i);
+			constantPool.add(v);
+			return i;
+		}
+		return index;
+	}
+
+	private void addConstantSubitems(Value v) {
+		if(v instanceof Value.String) {
+			Value.String s = (Value.String) v;
+			addStringItem(s.value);
+		} else if(v instanceof Value.Array) {
+			Value.Array s = (Value.Array) v;
+			for (Value e : s.values) {
+				addConstantItem(e);
+			}
+		} else if(v instanceof Value.Tuple) {
+			Value.Tuple t = (Value.Tuple) v;
+			for (Value e : t.values) {
+				addConstantItem(e);
+			}
+		}
+	}
+
+	/**
+	 * An PATH_Item represents a path item.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	private class PATH_Item {
+		/**
+		 * The index in the path pool of the parent for this item, or -1 if it
+		 * has not parent.
+		 */
+		public final int parentIndex;
+
+		/**
+		 * The index of this path component in the string pool
+		 */
+		public final int stringIndex;
+
+		public PATH_Item(int parentIndex, int stringIndex) {
+			this.parentIndex = parentIndex;
+			this.stringIndex = stringIndex;
+		}
+	}
+	private enum NAME_Kind {
+		PACKAGE(0),
+		MODULE(1),
+		CONSTANT(2),
+		TYPE(3),
+		FUNCTION(4),
+		METHOD(5);
+
+		private final int kind;
+
+		private NAME_Kind(int kind) {
+			this.kind = kind;
+		}
+
+		public int kind() {
+			return kind;
+		}
+	}
+
+	/**
+	 * A NAME_Item represents a named path item, such as a package, module or
+	 * something within a module (e.g. a function or method declaration).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	private class NAME_Item {
+		/**
+		 * The kind of name item this represents.
+		 */
+		// public final NAME_Kind kind;
+
+		/**
+		 * Index of path for this item in path pool
+		 */
+		public final int pathIndex;
+
+		/**
+		 * Index of string for this named item
+		 */
+		public final int nameIndex;
+
+		public NAME_Item(/*NAME_Kind kind, */int pathIndex, int nameIndex) {
+			//this.kind = kind;
+			this.pathIndex = pathIndex;
+			this.nameIndex = nameIndex;
+		}
+	}
+
+	// =========================================================================
+	// BLOCK identifiers
+	// =========================================================================
+
+	public final static int BLOCK_Header = 0;
+	public final static int BLOCK_Module = 1;
+	public final static int BLOCK_Documentation = 2;
+	public final static int BLOCK_License = 3;
+	// ... (anticipating some others here)
+	public final static int BLOCK_Code = 10;
+	public final static int BLOCK_Macro = 11;
+	public final static int BLOCK_Function = 12;
+	public final static int BLOCK_Assert = 13;
+	public final static int BLOCK_Type = 14;
+	// ... (anticipating some others here)
+
+	// =========================================================================
+	// CONSTANT identifiers
+	// =========================================================================
+
+	public final static int CONSTANT_Null = 0;
+	public final static int CONSTANT_True = 1;
+	public final static int CONSTANT_False = 2;
+	public final static int CONSTANT_Int = 3;
+	public final static int CONSTANT_Real = 4;
+	public final static int CONSTANT_Array = 5;
+	public final static int CONSTANT_String = 6;
+	public final static int CONSTANT_Tuple = 7;
+}
diff --git a/modules/wycs/src/wycs/solver/Arithmetic.wyrl b/modules/wycs/src/wycs/solver/Arithmetic.wyrl
new file mode 100755
index 0000000000..a9be2c68ad
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Arithmetic.wyrl
@@ -0,0 +1,382 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include "Core.wyrl"
+
+// ====================================================================
+// Multplication
+// ====================================================================
+
+// A multiplication term consists of a constant, and zero or more
+// variable multipliers.  For example, 2*x*y.
+term Mul[real,{|AExpr...|}]
+
+// Zero multiplied by anything gives zero (1); A term with no
+// multipliers is just a number (2).
+@rank(0)
+@name("Mul[0.0,{||}]")
+reduce Mul[real n, {|AExpr... rest|}]
+requires  n == 0.0 || |rest| == 0:
+    => Num(n)
+
+// Simplify terms containing constant multipliers.
+@rank(0)
+@name("Mul{|Num,AExpr|}")
+reduce Mul[real x, {|Num(real y), AExpr... rest|}]:
+    => Mul[x*y,rest]
+
+// Flattern nested multiplication terms.
+@rank(1)
+@name("Mul{|Mul,AExpr...|}")
+reduce Mul[real n1, {|Mul[real n2,{|AExpr... xs|}], AExpr... ys|}]:
+    => Mul[n1*n2,(xs ++ ys)]
+
+// Distribute multiplication through addition.
+@rank(1)
+@name("Mul{|Sum,AExpr...|}")
+reduce Mul[real n1, {|Sum[real n2, {|AExpr... xs|}], AExpr... ys|}]:
+    => let zs = {|Mul[n1,(x ++ ys)] | x in xs|},
+           z = Mul[n1*n2,ys]
+       in Sum[0.0,(z ++ zs)]
+
+// ====================================================================
+// Division
+// ====================================================================
+
+term Div[AExpr,AExpr]
+
+@rank(0)
+@name("Div[Num,Num]")
+reduce Div[Num(real x), Num(real y)]:
+    => Num(x/y)
+
+@rank(0)
+@name("Div[AExpr,Div]")
+reduce Div[AExpr x, Div[AExpr y, AExpr z]]:
+    => Div[Mul[1.0,{|x,z|}],y]
+
+@rank(0)
+@name("Div[Div,AExpr]")
+reduce Div[Div[AExpr x, AExpr y], AExpr z]:
+    => Div[x,Mul[1.0,{|y,z|}]]
+
+@rank(1)
+@name("Div[AExpr,Num]")
+reduce Div[AExpr x, Num(real n)]
+requires n < 0.0:
+    => Div[Mul[-1.0,{|x|}],Num(-n)]
+
+@rank(1)
+@name("Div[AExpr,Num]")
+reduce Div[AExpr x, Num(real n)]
+requires n == 1.0:
+    => x
+
+// Cancel terms [simplistic]
+@rank(1)
+@name("Div[Mul,AExpr]")
+reduce Div[Mul[real n, {|AExpr x, AExpr... xs|}],AExpr y]
+requires x == y:
+    => Mul[n, xs]
+
+@rank(1)
+@name("Div[Mul,AExpr]")
+reduce Div[Mul[real n, {|AExpr... xs|}],Num y]:
+    => Mul[n / *y, xs]
+
+// Distribute division through sum
+@rank(1)
+@name("Div[Sum,AExpr]")
+reduce Div[Sum[real n, {|AExpr... xs|}],AExpr y]:
+    => let ys = {| Div[x,y] | x in xs |}
+       in Sum[0.0, (ys ++ Div[Num(n),y])]
+
+// Distrubute division through mul
+@rank(1)
+@name("Div[Mul,AExpr]")
+reduce Div[Mul[real n, {|AExpr... xs|}],AExpr y]:
+    => Mul[n,(xs ++ Div[Num(1.0),y])]
+
+// ====================================================================
+// Summation
+// ====================================================================
+
+// A summation consists of a constant, and zero or more
+// multiplication components.  For example, 2+(1*x)+(1*y)
+// and also 2+(x*y)+z.
+term Sum[real,{|AExpr...|}]
+
+// A summation with no components is just a number.
+@rank(0)
+@name("Sum{||}")
+reduce Sum[real n, {||}]:
+    => Num(n)
+
+// A summation with a single variable expression is just that expression
+@rank(0)
+@name("Sum{|Mul{|VExpr|}|}")
+reduce Sum[real n, {|Mul[real m, {|VExpr x|}]|}]
+requires  n == 0.0 && m == 1.0:
+    => x
+
+// Normalise so that all variable summation components are multiplications.
+@rank(1)
+@name("Sum{|AExpr,AExpr...|}")
+reduce Sum[real n, {|AExpr x, AExpr... rest|}]
+requires !(x is Num || x is Sum || x is Mul):
+    => Sum [n,Mul[1.0,{|x|}] ++ rest]
+
+// Simplify summations with constant components.
+@rank(1)
+@name("Sum{|Num,AExpr...|}")
+reduce Sum[real x, {|Num(real y), AExpr... rest|}]:
+    => Sum[x+y,rest]
+
+// Simplify summations with related multication components.
+// For example, (2*x*y)+(3*x*y)+(2*x) ==> (5*x*y) + (2*x)
+@rank(2)
+@name("Sum{|Mul,Mul,AExpr|}")
+reduce Sum[real n, {|Mul[real x, {|AExpr...|} xs], Mul[real y, {|AExpr...|} ys], AExpr... zs|}]
+requires xs == ys:
+    => Sum[n, Mul[x+y, xs] ++ zs]
+
+// Flattern summations.
+@rank(2)
+@name("Sum{|Sum,AExpr|}")
+reduce Sum[real x, {|Sum[real y, {|AExpr... ys|}], AExpr... xs|}]:
+    => Sum[x+y, xs ++ ys]
+
+// ====================================================================
+// Equations
+// ====================================================================
+
+// The "arithmetic types", which are used for equations and inequalities
+define AType as IntT | RealT
+
+// An equation should be viewed as equating a given expression with
+// zero.
+term Equation[AType,AExpr]
+
+@rank(0)
+@name("Equation[Num]")
+reduce Equation[AType,Num(real v)]:
+    => False, if v != 0.0
+    => True
+
+// Normalise negative equations.  For example, 0 == -x becomes 0 == x.
+@rank(1)
+@name("Equation[Sum{|Mul[-m,{|AExpr...|}]]")
+reduce Equation[AType t,Sum[real n, {|Mul[real m, {|AExpr... xs|}]|}]]
+requires n == 0.0 && m < 0.0:
+    => Equation[t,Sum[n,{|Mul[-m,xs]|}]]
+
+// Normalise summations.  For example, 2x+2 becomes x+1, etc.
+// This rule is REALLY expensive, because GCD is REALLY expensive.
+@rank(2)
+@name("Equation[Sum{|Mul|}]")
+reduce Equation[AType t,Sum[real n, {|Mul... xs|} ms]]:
+    => let gcd = gcd[n,ms],
+           ys = {| Mul[(*x)[0] / gcd, (*x)[1]] | x in xs |}
+       in Equation[t,Sum[n / gcd, ys]], if |xs| > 0 && gcd != 1.0
+
+// For a given equation involving at least one linear term, substitute
+// through all expressions the right-hand side of this equation with
+// respect to a linear term.  For example, in 0 == x - y + 1 && x > y
+// we choose to substitute through x (since this is lexiographically
+// least) and rearrange the equation to give x = y - 1; then, we can
+// substitute to get 0 == x - y + 1 && y - 1 > y which reduces to false.
+//
+// NOTE: is an inference rule to ensure all terms are reduced before
+// this is called
+@rank(1)
+@name("Equation[Sum{|Mul,Mul|}]")
+reduce And{
+      Equation[AType t, Sum[real c, {|Mul[real vc, {|AExpr v|}], Mul... ms|} xs]] eq,
+      BExpr... bs}:
+     => let var = maxMultiplicand(xs),
+           rhs = Sum[0.0,{|Div[Mul[-1.0,{|Sum[c,ms]|}],Num(vc)]|}],
+           cs = { b[var \ rhs] | b in bs }
+        in And (eq ++ cs), if v == var && no { m in ms | v in (*m)[1] }
+
+@rank(1)
+@name("And{Equation[VExpr],BExpr...}")
+infer And{
+        Equation[AType t, VExpr v] eq,
+        BExpr... bs}:
+     => let cs = { b[v \ Num(0.0)] | b in bs }
+        in And (eq ++ cs)
+
+// The following native function is necessary because it cannot
+// easily be expressed within the rewrite language itself.  What it
+// does is pick the "lexicographically greatest" variable expression from a
+// set of multiplicands.  This is critical to ensuring that equation substitution
+// rule above is stable (i.e. that it does not oscillate continually
+// substituting for the other side).
+function maxMultiplicand{|Mul...|} => VExpr
+
+// 0 != e => 0 <= e-1 || 0 <= -e-1 (i.e. 1+e <= 0)
+@rank(1)
+@name("Not(Equation[IntT,AExpr])")
+reduce Not(Equation[IntT t,AExpr e]):
+    => let neg_em1 = Sum[-1.0,{|Mul[-1.0,{|e|}]|}],
+           em1 = Sum[-1.0,{|e|}]
+       in Or{Inequality[t,neg_em1],Inequality[t,em1]}
+
+// 0 != e => 0 < e || 0 < -e (i.e. e < 0)
+@rank(1)
+@name("Not(Equation[RealT,AExpr])")
+reduce Not(Equation[RealT t,AExpr e]):
+    => let neg_e = Mul[-1.0,{|e|}]
+       in Or{Inequality[t,neg_e],Inequality[t,e]}
+
+@rank(1)
+@name("Equals{|AExpr,AExpr|}")
+reduce Equals[AType t,{|AExpr e1,AExpr e2|}]:
+    => let neg_e1 = Mul[-1.0,{|e1|}]
+       in Equation[t,Sum[0.0,{|neg_e1,e2|}]]
+
+// ====================================================================
+// Inqualities
+// ====================================================================
+
+// Integer inequalities are non-strict (i.e. of the form 0 <= e) to avoid
+// an unnecessary disjunction.  That is, if we implement them as strict
+// inequalities (i.e. of the form 0 < x), then 0 <= x becomes 0 < x || x == 0.
+//
+// Rational Inequalities are strict inequalities, unlike integer
+// inequalities which are non-strict.  Again, this is to avoid an
+// unnecessary (and complex in this case) disjunction.  That is, if real
+// inequalities we non-strict then 0 < e would become 0 <= e && e != 0,
+// which is actually hard to implement.
+term Inequality[AType,AExpr]
+
+// Handle comparison against constant values, which always reduce to
+// either true or false.  Care must be taken int the case of a constant
+// which equals zero, since integer inequalities are non-strict whilst
+// real inequalities are strict.
+@rank(0)
+@name("Inequality[Num]")
+reduce Inequality[AType t, Num(real v)]:
+    => False, if v < 0.0
+    => False, if v == 0.0 && t == RealT
+    => True
+
+// Handle case of an negated integer inequality.  In such case, we can
+// safely encode this as another integer inequality, although care must
+// be taken as this only works for integer inequalities (which are
+// non-strict).  As an example !(x <= 1) gives x >= 2.  In the general
+// case, we have !(0 <= e) ==> 0 <= -e - 1 (i.e. e <= -1)
+@rank(1)
+@name("Not(Inequality)")
+reduce Not(Inequality[IntT t, AExpr e]):
+    => let neg_e = Mul[-1.0,{|e|}]
+       in Inequality[t, Sum[-1.0,{|neg_e|}]]
+
+// Normalise summations.  For example, 2x+2 becomes x+1, etc.
+// This rule is REALLY expensive, because GCD is REALLY expensive.
+@rank(2)
+@name("Inequality[Sum]")
+reduce Inequality[AType t,Sum[real n, {|Mul... xs|} ms]]:
+    => let gcd = gcd[n,ms],
+           ys = {| Mul[(*x)[0] / gcd, (*x)[1]] | x in xs |}
+       in Inequality[t,Sum[n / gcd, ys]], if |xs| > 0 && gcd != 1.0
+
+function gcd[real,{|Mul...|}] => real
+
+// Handle case where we have x <= y <= x (for integer inequalities).
+// In this case, we can infer that x == y.  Case must be taken as this
+// only works for integer inequalities (which are non-strict).
+@rank(1)
+@name("And{Inequality,Intequality,BExpr...}")
+reduce And{Inequality[IntT, Sum[real x1, {|Mul[real x2,{|AExpr vx1|}], Mul[real x3,{|AExpr vx2|}]|}] s1] ieq1,
+           Inequality[IntT, Sum[real y1, {|Mul[real y2,{|AExpr vy1|}], Mul[real y3,{|AExpr vy2|}]|}] s2] ieq2, 
+           BExpr... rest}
+requires  x1 == -y1 && x2 == -y2 && x3 == -y3 && vx1 == vy1 && vx2 == vy2:
+    => And (Equation[IntT,s1] ++ rest)
+
+// Handle closure over inequalities.  For example, if x <= y and y <=
+// z then we want to infer that x <= z.  This must be an inference
+// rule since it potentially increases the number of clauses (and, hence,
+// would potentially cause infinite loops as a reduction).
+//
+// Here's how it works.  We start with
+//
+// 0 <= x1 + x2 * v1 + x2 * xs  (1)
+// 0 <= y1 + y2 * v2 + y2 * ys  (2) [where v1 == v2]
+//
+// First, we rearrange (1) so all terms not involving the v1
+// multiplication are on the right-hand side.  Likewise, we rearrnage (2)
+// so all terms not involving v2 are on the left-hand size:
+//
+// -x2 * v1 <= x1 + x2 * xs
+//  y2 * v2 >= -y1 - (y2 * xs)
+//
+// Then, we multiply the second by -x2 and the first by y2:
+//
+// -x2 * y2 * v1 <= y2 * (x1 + x2 * xs)
+// -x2 * y2 * v2 >= -x2 * (-y1 - (y2 * xs))
+//
+// At this point, the left-hand side of both of the above inequalities
+// identical, and we can safely apply transitivity.  Since we've multipled
+// through by -x2 and y2 we need to check that x2 < 0.0 and y2 > 0.0,
+// otherwise we would need to reverse the signs and the inference wouldn't succeed.
+//
+@rank(1)
+@name("And{Inequality,Inequality,BExpr...}")
+infer And{Inequality[AType t1, Sum[real x1, {|Mul[real x2, {|AExpr v1|}], Mul... xs|} xxs] s1] eq1,
+          Inequality[AType t2, Sum[real y1, {|Mul[real y2, {|AExpr v2|}], Mul... ys|} yys] s2] eq2,
+          BExpr... rest}
+requires v1 == v2 && t1 == t2 && x2 < 0.0 && y2 > 0.0:
+     // neg-pos
+     => let vx = maxMultiplicand(xxs),
+            vy = maxMultiplicand(yys),
+            s3 = Mul[y2,{|Sum[x1,xs]|}],
+            s4 = Mul[-x2,{|Sum[y1,ys]|}],
+            eq3 = Inequality[t1,Sum[0.0,{|s3,s4|}]]
+        in And ({eq1,eq2,eq3} ++ rest), if vx == v1 && vy == v1
+     // pos-neg not required as symmetric
+
+@rank(1)
+@name("Inequality{Inequality,Inequality,BExpr...}")
+infer And{Inequality[AType t1, Sum[real x1, {|Mul[real x2, {|AExpr v1|}], Mul... xs|} xxs] s1] eq1,
+          Inequality[AType t2, VExpr v2] eq2,
+          BExpr... rest}
+requires v1 == v2 && t1 == t2 && x2 < 0.0:
+     // neg-pos
+     => let vx = maxMultiplicand(xxs),
+            eq3 = Inequality[t1,Sum[x1,xs]]
+        in And ({eq1,eq2,eq3} ++ rest), if vx == v1
+     // pos-neg not required as symmetric
+
+
+// ====================================================================
+// Arithmetic Expressions
+// ====================================================================
+
+define BExpr as Inequality | Equation | ...
+
+define AExpr as Num | Sum | Mul | Div | VExpr
+
+define Expr as AExpr | ...
diff --git a/modules/wycs/src/wycs/solver/Arrays.wyrl b/modules/wycs/src/wycs/solver/Arrays.wyrl
new file mode 100755
index 0000000000..c8c3c4960c
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Arrays.wyrl
@@ -0,0 +1,106 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include "Core.wyrl"
+
+// ====================================================================
+// Array Expressions
+// ====================================================================
+
+// An array is a mapping from an index value to another value.
+term Array[Expr...]
+
+@rank(2)
+@name("And{Equals[VExpr,Array],BExpr...}")
+reduce And{Equals[Type t, {|VExpr x, Array y|}] eq, BExpr... bs}:
+    => let cs = { b[x\y] | b in bs }
+       in And (eq ++ cs)
+
+// ====================================================================
+// Array Generators
+// ====================================================================
+
+// An array is a mapping from an index value to another value.
+term ArrayGen[Expr,Expr]
+
+@rank(2)
+@name("ArrayGen[Expr,Num]")
+reduce ArrayGen[Expr x, Num(real r)]:
+    => let n = num r,
+           xs = [ x | i in 0..n ]
+       in Array(xs)
+
+@rank(2)
+@name("And{Equals[VExpr,ArrayGen],BExpr...}")
+reduce And{Equals[Type t, {|VExpr x, ArrayGen y|}] eq, BExpr... bs}:
+    => let cs = { b[x\y] | b in bs }
+       in And (eq ++ cs)
+
+// ====================================================================
+// Length Expressions
+// ====================================================================
+
+@rank(0)
+@name("LengthOf(Array)")
+reduce LengthOf(Array[Expr... xs]):
+    => Num((real) |xs|)
+
+
+@rank(2)
+@name("LengthOf(ArrayGen)")
+reduce LengthOf(ArrayGen[Expr v, Expr n]):
+    => n
+
+// ====================================================================
+// IndexOf Expressions
+// ====================================================================
+
+// An index of expression represents an access expresion into a given
+// array (left) at a given index position (right).
+term IndexOf[Expr,Expr]
+
+@rank(0)
+@name("IndexOf[Array]")
+reduce IndexOf[Array[Expr... xs], Num(real i)]:
+    => let j = num i
+       in xs[j], if j >= 0 && j < |xs|
+
+@rank(0)
+@name("IndexOf[ArrayGen]")
+reduce IndexOf[ArrayGen[Expr v,Expr n], Expr]:
+    => v
+
+// ====================================================================
+// Expressions & Values
+// ====================================================================
+
+define Value as Array[Value...] | ArrayGen[Value,Value] | ...
+
+define SExpr as VExpr | Array | ArrayGen | ...
+
+define VExpr as IndexOf | ...
+
+define Expr as SExpr | ...
+
diff --git a/modules/wycs/src/wycs/solver/Core.wyrl b/modules/wycs/src/wycs/solver/Core.wyrl
new file mode 100755
index 0000000000..0d599ba9bb
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Core.wyrl
@@ -0,0 +1,327 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include "Types.wyrl"
+
+// ====================================================================
+// Null
+// ====================================================================
+
+term Null
+
+// ====================================================================
+// Bool
+// ====================================================================
+
+term True
+term False
+define Bool as True | False
+
+// ====================================================================
+// Numbers
+// ====================================================================
+
+term Num(real)
+
+// ====================================================================
+// Variables
+// ====================================================================
+
+// A variable is an expression identified solely by a string whose
+// value is currently unknown.
+term Var(string)
+
+// ====================================================================
+// Tuples
+// ====================================================================
+
+// A tuple represents a sequence of zero or more expressions.  In
+// otherwords, it's a compound expression built up from other
+// expressions.  For example, the pair (1,2) is a tuple consisting of two
+// expressions, namely 1 and 2.
+term Tuple[Expr...]
+
+// A tuple load operation selects the expression at a given (fixed)
+// index within a tuple.
+term Load[Expr,int]
+
+// Select the expression at the given index within a tuple.  This
+// requires that the index is within the bounds of the tuple.
+@rank(1) 
+@name("Load[Tuple[Expr...],int]")
+reduce Load[Tuple[Expr... ls], int idx]
+requires idx >= 0 && idx < |ls|:
+    => ls[idx]
+
+// Denotes the length of a tuple expression (and other kinds as well)
+term LengthOf(Expr)
+
+@rank(0)
+@name("LengthOf(Tuple[Expr...])")
+reduce LengthOf(Tuple[Expr... xs]):
+    => Num((real) |xs|)
+
+// Two tuples of different sizes are never equal (1); two tuples of
+// the same size are equal iff their subexpressions at matching indices
+// are equal.
+@rank(2)
+@name("EqualsTuple[Tuple,Tuple]")
+reduce Equals[TupleT[Type... ts],{|Tuple[Expr... xs],Tuple[Expr... ys]|}]:
+    => False, if |xs| != |ys|
+    => let eqs = { Equals[ts[i],{|xs[i],ys[i]|}] | i in 0..|xs| }
+       in And(eqs)
+
+@rank(2)
+@name("And{Equals[VExpr,Tuple],BExpr...}")
+reduce And{Equals[Type t, {|VExpr x, Tuple y|}] eq, BExpr... bs}:
+    => let cs = { b[x\y] | b in bs }
+       in And (eq ++ cs)
+
+// ====================================================================
+// Uninterpreted Functions
+// ====================================================================
+
+// An uninterpreted function is an expression representing an external
+// function call.  The only interpretation provided is that these are
+// mathematical functions which always return the same result given
+// the same input.  For example, suppose an uninterpreted function f
+// which takes two arguments.  Then, f(x1,y1) == f(x2,y2) if x1 == x2
+// and y1 == y2.
+term Fn[string,Expr...]
+
+// ====================================================================
+// Strings
+// ====================================================================
+
+term String(string)
+
+// ====================================================================
+// Logical Not
+// ====================================================================
+
+term Not(BExpr)
+
+// Invert a boolean value.
+@rank(0)
+@name("Not(Bool)")
+reduce Not(Bool b):
+    => False, if b == True
+    => True
+
+// Inverting an inverted expression yields the original expression.
+@rank(0)
+@name("Not(Not(BExpr))")
+reduce Not(Not(* x)):
+    => x
+
+// Apply De Morgan's law for inverting conjuncts.
+@rank(2)
+@name("Not(And{BExpr...})")
+reduce Not(And{BExpr... xs}):
+    => let ys = { Not(x) | x in xs }
+       in Or(ys)
+
+// Apply De Morgan's law for inverting disjuncts.
+@rank(1)
+@name("Not(Or{BExpr...})")
+reduce Not(Or{BExpr... xs}):
+    => let ys = { Not(x) | x in xs }
+       in And(ys)
+
+// ====================================================================
+// Logical And
+// ====================================================================
+
+// A conjunct is the logical "And" of a a set of zero or more boolean
+// expressions.
+term And{BExpr...}
+
+// A conjunct with one term gives that term
+@rank(1)
+@name("And{BExpr}")
+reduce And{BExpr x}:
+    => x
+
+// Eliminate conjuncts which are false.  Note that this is the most
+// *important rule* for overall performance!
+@rank(1)
+@name("And{False,BExpr...}")
+reduce And{False, BExpr... xs}:
+    => False
+
+// Reduce conjuncts containing known truths.
+@rank(1)
+@name("And{True,BExpr...}")
+reduce And{True, BExpr... xs}:
+    => And(xs), if |xs| > 0
+    => True
+
+// Flattern nested conjuncts
+@rank(1)
+@name("And{And{BExpr...},BExpr...}")
+reduce And{And{BExpr... xs}, BExpr... ys}:
+    => And (xs ++ ys)
+
+// A conjunct containing an expression and its inversion is
+// unsatisfiable.
+@rank(2)
+@name("And{Not(BExpr x),BExpr x,BExpr...}")
+reduce And{Not(BExpr x), BExpr y, BExpr... ys}
+requires x == y:
+    => False
+
+// Distribute conjuncts over disjuncts.  This rule can be quite
+// expensive and making it an inference rule can help.
+@rank(3)
+@name("And{Or{BExpr...},BExpr...}")
+reduce And{Or{BExpr... xs}, BExpr... ys}:
+    => let ys = { And(x ++ ys) | x in xs }
+       in Or(ys)
+
+// ====================================================================
+// Logical Or
+// ====================================================================
+
+// A disjunct is the logical "Or" of a a set of zero or more boolean
+// expressions.
+term Or{BExpr...}
+@rank(0)
+@name("Or{BExpr}")
+reduce Or{BExpr x}:
+    => x
+@rank(1)
+@name("Or{True,BExpr...}")
+reduce Or{True, BExpr... xs}:
+    => True
+
+@rank(1)
+@name("Or{False,BExpr...}")
+reduce Or{False, BExpr... xs}:
+    => Or (xs), if |xs| > 0
+    => False
+
+@rank(2)
+@name("Or{Not(BExpr x),BExpr x,BExpr...}")
+reduce Or{Not(BExpr x), BExpr y, BExpr... ys}
+requires x == y:
+    => True
+
+@rank(1)
+@name("Or{Or{BExpr...},BExpr...}")
+reduce Or{Or{BExpr... xs}, BExpr... ys}:
+    => Or (xs ++ ys)
+
+// ====================================================================
+// Equality
+// ====================================================================
+
+// An equality between two expressions of a given type.  The type is
+// important in some cases (e.g. for distinguishing integer versus real
+// equalities).
+term Equals[Type,{|Expr,Expr|}]
+
+// An expression is always equal to itself. Notice that we cannot conclude False
+// when we have general expressions that aren't equal, because these may
+// eventually reduce to the same value (or not).
+@rank(1)
+@name("Equals{|Expr,Expr|}")
+reduce Equals[Type t, {|Expr x, Expr y|}]
+requires x == y:
+    => True
+
+// Any two distinct values are never equal (2).
+@rank(1)
+@name("Equals{|Value,Value|}")
+reduce Equals[Type t, {|Value x, Value y|}]
+requires x != y:
+    => False
+
+// Substitute any variable which is known to equal a value through
+// for that value in all expressions.
+@rank(2)
+@name("And{Equals{|VExpr,Value|},BExpr...}")
+reduce And{Equals[Type t, {|VExpr x, Value y|}] eq, BExpr... bs}:
+    => let cs = { b[x\y] | b in bs }
+       in And (eq ++ cs)
+
+// When two variables are equal, substitute one for the other in all
+// expressions.  We need to carefully choose a unique representative
+// from the two variables in order to prevent a loop where we substitute
+// for one variable, and then repeat this for the other, and so on.
+//
+// NOTE: this must be an inference rule in order to force the two
+// variable expressions to be in a canonical form and, hence, directly
+// comparable.
+@name("And{Equals{|VExpr,VExpr|},BExpr...}")
+infer And{Equals[Type t, {|VExpr,VExpr|} vs] eq, BExpr... bs}:
+    => let x = max(vs), // must be greatest
+           y = min(vs), // must be least
+           cs = { b[x\y] | b in bs }
+       in And (eq ++ cs), if x != y
+
+// The following native function is necessary because it cannot
+// currently be expressed within the rewrite language itself.  What it
+// does is pick the "lexicographically least" variable expression from a
+// set of them.  This is critical to ensuring that equality reduction
+// rules above are stable (i.e. that they do not oscillate continually
+// substituting for the other side).
+function min{|VExpr...|} => VExpr
+
+// The following is the exact opposite of the above --- i.e. it
+// selects the "lexiographically greatest" element.
+function max{|VExpr...|} => VExpr
+
+// ====================================================================
+// Expressions & Values
+// ====================================================================
+
+// A value is a concrete term which cannot be further reduced.  The
+// base values are boolean true or false, and a tuple of values.  Other
+// values include integers, rationals and sets of values.
+define Value as Null | Bool | Num | String | Tuple[Value...] | ...
+
+// Variable Expressions are those which represent variables or
+// sub-components thereof.  Such expressions can in principle
+// return a value of any kind.
+define VExpr as Var | Fn | Load | LengthOf | ...
+
+// Tuple expressions are either tuple constructors or variables.
+define TExpr as VExpr | Tuple
+
+// Boolean expressions are those which can return a boolean value.
+// Variable expressions must be included in this, since they can return
+// any kind of value.
+define BExpr as VExpr | Bool | And | Or | Not | Equals | ...
+
+// General expressions (i.e. *everything*).
+define Expr as Value | Tuple | BExpr | ...
+
+
+
+
+
+
+
+
diff --git a/modules/wycs/src/wycs/solver/Quantifiers.wyrl b/modules/wycs/src/wycs/solver/Quantifiers.wyrl
new file mode 100755
index 0000000000..aea55d1415
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Quantifiers.wyrl
@@ -0,0 +1,134 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+include "Core.wyrl"
+include "Arrays.wyrl"
+
+// ====================================================================
+// ForAll
+// ====================================================================
+
+term ForAll[{[Var,Type]...}, BExpr]
+
+// Quantifying over a constant, or an empty set of variables is
+// redundant (in which case we can simply drop the quantifier).
+@rank(1)
+@name("ForAll({},Bool)")
+reduce ForAll[{[Var,Type]...qs}, BExpr be]
+requires be is Bool || |qs| == 0:
+       => be
+
+// Negate a universal quantifier to produce an existential quantifier
+@rank(0)
+@name("Not(ForAll)")
+reduce Not(ForAll[{[Var,Type]...} vars, BExpr be]):
+       => Exists[vars, Not(be)]
+
+// Merge nested universal quantifiers
+@rank(1)
+@name("ForAll[ForAll]")
+reduce ForAll[{[Var,Type]...} xs, ForAll[{[Var,Type]...} ys, BExpr e]]:
+       => ForAll[xs++ys,e]
+
+// Eliminate unused variables as these can prevent instantiation.
+@rank(1)
+@name("ForAll[{Var,Var...},BExpr]")
+reduce ForAll[{[Var v,Type], [Var,Type]... xs}, BExpr e]:
+       => ForAll[xs,e], if !(contains[e,v])
+
+// Push quantifier inwards?
+
+// Attempt to instantiate quantifier with a given expression
+@rank(3)
+@name("And{BExpr,ForAll,BExpr...}")
+infer And{
+    // The expression we're instantiating over
+    BExpr e1,
+    // The Quantifier we're attempting to instantiate
+    ForAll[{[Var, Type], [Var,Type]...} vs, BExpr e2] qf,
+    // The rest
+    BExpr... es}
+requires !(e1 is ForAll):
+    => let instantiations = instantiate[e1,vs,e2]
+       in And({e1,qf} ++ es ++ instantiations), if |instantiations| > 0
+
+// ====================================================================
+// Exists
+// ====================================================================
+
+term Exists[{[Var,Type]...}, BExpr]
+
+// Quantifying over a constant, or an empty set of variables is
+// redundant (in which case we can simply drop the quantifier).
+@rank(1)
+@name("Exists[{},Bool]")
+reduce Exists[{[Var,Type]...qs}, BExpr be]
+requires be is Bool || |qs| == 0:
+       => be
+
+// Negate an existential quantifier to produce a universal quantifier.
+@rank(2)
+@name("Not(Exists)")
+reduce Not(Exists[{[Var,Type]...} vars, BExpr be]):
+       => ForAll[vars, Not(be)]
+
+// Merge consequtive existentials together
+@rank(1)
+@name("Exists[Exists,BExpr]")
+reduce Exists[{[Var,Type]...} xs, Exists[{[Var,Type]...} ys, BExpr e]]:
+       => Exists[xs++ys,e]
+
+// Move extenstentials outwards (?)
+@rank(1)
+@name("And{Exists,BExpr...}")
+reduce And{Exists[{[Var,Type]...} vs, BExpr e], BExpr... es}:
+       => Exists[vs, And(e++es)]
+
+// ====================================================================
+// Instantiate function
+// ====================================================================
+
+// Attempt to bind a quantified expression (right) with a concrete
+// expression (left), generating one or more candidate bindings over one
+// or more quantified variables. These bindings are then used to
+// instantiate the quantified expression.
+function instantiate[BExpr, {[Var,Type]...}, BExpr] => {BExpr}
+
+// ====================================================================
+// Contains function
+// ====================================================================
+
+// Determine whether the variable v is used within the expression e.
+function contains[BExpr, Var] => bool
+
+// ====================================================================
+// Expressions & Values
+// ====================================================================
+
+define BExpr as ForAll | Exists | ...
+
+
+
+
diff --git a/modules/wycs/src/wycs/solver/Solver$native.java b/modules/wycs/src/wycs/solver/Solver$native.java
new file mode 100755
index 0000000000..6bd9b62bbc
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Solver$native.java
@@ -0,0 +1,843 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.HashSet;
+
+import wyautl.core.Automaton;
+import wyautl.util.BigRational;
+
+/**
+ * Implements a lexiographic ordering of variable expressions.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class Solver$native {
+
+	/**
+	 * Determine the minimum element from a bag of elements according to an
+	 * internal ordering defined here.
+	 *
+	 * @param automaton
+	 *            The automaton being operated over
+	 * @param rBag
+	 *            A reference to a bag state which contains those elements to
+	 *            compare.
+	 * @return
+	 */
+	public static Automaton.Term min(Automaton automaton, int rBag) {
+		Automaton.Bag bag = (Automaton.Bag) automaton.get(rBag);
+		int least = -1;
+		for(int i=0;i!=bag.size();++i) {
+			int child = bag.get(i);
+			if (least == -1 || compare(automaton, child, least) < 0) {
+				least = child;
+			}
+		}
+		return (Automaton.Term) automaton.get(least);
+	}
+
+	/**
+	 * Determine the maximum element from a bag of elements according to an
+	 * internal ordering defined here.
+	 *
+	 * @param automaton
+	 *            The automaton being operated over
+	 * @param rBag
+	 *            A reference to a bag state which contains those elements to
+	 *            compare.
+	 * @return
+	 */
+	public static Automaton.Term max(Automaton automaton, int rBag) {
+		Automaton.Bag bag = (Automaton.Bag) automaton.get(rBag);
+		int greatest = -1;
+		for (int i = 0; i != bag.size(); ++i) {
+			int child = bag.get(i);
+			if (greatest == -1 || compare(automaton, child, greatest) > 0) {
+				greatest = child;
+			}
+		}
+		return (Automaton.Term) automaton.get(greatest);
+	}
+
+	public static Automaton.Term maxMultiplicand(Automaton automaton, int rBag) {
+
+		Automaton.Bag bag = (Automaton.Bag) automaton.get(rBag);
+		int greatest = -1;
+		for (int i = 0; i != bag.size(); ++i) {
+			Automaton.Term mulTerm = (Automaton.Term) automaton.get(bag.get(i));
+			Automaton.List mulChildren = (Automaton.List) automaton
+					.get(mulTerm.contents);
+			Automaton.Bag mulChildChildren = (Automaton.Bag) automaton
+					.get(mulChildren.get(1));
+			if (mulChildChildren.size() == 1) {
+				int child = mulChildChildren.get(0);
+				if (greatest == -1 || compare(automaton, child, greatest) > 0) {
+					greatest = child;
+				}
+			}
+		}
+		return (Automaton.Term) automaton.get(greatest);
+	}
+
+	/**
+	 * Implements the internal ordering of automaton states.
+	 *
+	 * @param automaton
+	 * @param r1
+	 *            Reference to first state to compare
+	 * @param r2
+	 *            Reference to second state to compare
+	 * @return
+	 */
+	private static int compare(Automaton automaton, int r1, int r2) {
+		if(r1 == r2) { return 0; }
+		Automaton.State s1 = automaton.get(r1);
+		Automaton.State s2 = automaton.get(r2);
+		// first, easy case
+		if(s1.kind < s2.kind) {
+			return -1;
+		} else if(s1.kind > s2.kind) {
+			return 1;
+		}
+
+		if(s1 instanceof Automaton.Constant) {
+			Automaton.Constant<Comparable> b1 = (Automaton.Constant) s1;
+			Automaton.Constant<Comparable> b2 = (Automaton.Constant) s2;
+			return b1.value.compareTo(b2.value);
+		} else if(s1 instanceof Automaton.Term) {
+			Automaton.Term t1 = (Automaton.Term) s1;
+			Automaton.Term t2 = (Automaton.Term) s2;
+			int t1_contents = t1.contents;
+			int t2_contents = t2.contents;
+			if(t1_contents == Automaton.K_VOID) {
+				return t2_contents == Automaton.K_VOID ? 0 : -1;
+			} else if(t2_contents == Automaton.K_VOID) {
+				return 1;
+			} else {
+				return compare(automaton,t1.contents,t2.contents);
+			}
+		} else {
+			Automaton.Collection c1 = (Automaton.Collection) s1;
+			Automaton.Collection c2 = (Automaton.Collection) s2;
+			int c1_size = c1.size();
+			int c2_size = c2.size();
+			if(c1_size < c2_size) {
+				return -1;
+			} else if(c1_size > c2_size) {
+				return 1;
+			}
+			for(int i=0;i!=c1_size;++i) {
+				int c = compare(automaton,c1.get(i),c2.get(i));
+				if(c != 0) {
+					return c;
+				}
+			}
+			return 0;
+		}
+	}
+
+	public static Automaton.Real gcd(Automaton automaton, Automaton.List args) {
+		// PRECONDITION: terms.size() > 0
+		Automaton.Real constant = (Automaton.Real) automaton.get(args.get(0));
+		Automaton.Bag terms = (Automaton.Bag) automaton.get(args.get(1));
+
+		// Must use abs() here, otherwise can end up with negative gcd.
+		// This is problematic for inequalities as it necessitate
+		// changing their sign.
+		BigRational gcd = constant.value.abs();
+
+		if(gcd.equals(BigRational.ZERO)) {
+			// Basically, if there is no coefficient, then ignore it.
+			gcd = null;
+		}
+
+		// Now, iterate through each term examining its coefficient and
+		// determining the GreatestCommonDivisor of the whole lot.
+		for(int i=0;i!=terms.size();++i) {
+			int child = terms.get(i);
+			Automaton.Term mul = (Automaton.Term) automaton.get(child);
+			Automaton.List ls = (Automaton.List) automaton.get(mul.contents);
+			Automaton.Real coefficient = (Automaton.Real) automaton.get(ls.get(0));
+			BigRational val = coefficient.value;
+			if(gcd == null) {
+				// Must use abs() here, otherwise can end up with negative gcd.
+				// This is problematic for inequalities as it necessitate
+				// changing their sign.
+				gcd = val.abs();
+			} else {
+				// Note, gcd of two numbers (either of which may be negative) is
+				// always positive.
+				gcd = gcd.gcd(val);
+			}
+		}
+
+		if(gcd == null || gcd.equals(BigRational.ZERO)) {
+			// This is basically a sanity check. A zero coefficient is possible,
+			// and can cause the final gcd to be zero. Likewise, it's possible
+			// (at the moment) that this function can be called with
+			// terms.size() == 0 and, hence, gcd == null.
+			return new Automaton.Real(BigRational.ONE);
+		} else {
+			// Done.
+			return new Automaton.Real(gcd);
+		}
+	}
+
+	/**
+	 * Determine whether a given variable v is contained within a given
+	 * expression e.
+	 *
+	 * @param automaton
+	 * @param args
+	 * @return
+	 */
+	public static boolean contains(Automaton automaton, Automaton.List args) {
+		int e = (int) args.get(0);
+		int v = (int) args.get(1);
+		return contains(automaton,e,v);
+	}
+
+	public static boolean contains(Automaton automaton, int e, int v) {
+		if(e == v) { return true; }
+
+		Automaton.State s1 = automaton.get(e);
+
+		if(s1 instanceof Automaton.Constant) {
+			return false;
+		} else if(s1 instanceof Automaton.Term) {
+			Automaton.Term t1 = (Automaton.Term) s1;
+			if(t1.contents != Automaton.K_VOID) {
+				return contains(automaton,t1.contents,v);
+			}
+			return false;
+		} else {
+			Automaton.Collection c1 = (Automaton.Collection) s1;
+			for(int i=0;i!=c1.size();++i) {
+				int child = c1.get(i);
+				if(contains(automaton,child,v)) {
+					return true;
+				}
+			}
+			return false;
+		}
+	}
+
+	/**
+	 * <p>
+	 * Attempt to bind a quantified expression with a concrete expression,
+	 * producing one or more candidate bindings over one or more quantified
+	 * variables. Any such bindings are then used to instantiate the quantified
+	 * expression. For example, consider these expressions:
+	 * </p>
+	 *
+	 * <pre>
+	 * in(1) && forall y . !in(y)
+	 * </pre>
+	 *
+	 * <p>
+	 * Here, we want to instantiate the quantifier with the binding
+	 * <code>y=1</code> to produce a contradiction. This function will be called
+	 * to bind <code>in(1)</code> against <code>in(y)</code> over the set
+	 * <code>{y}</code> of quantified variables. In this case, there is only one
+	 * candidate binding (i.e. <code>y=1</code>). When a binding is found the
+	 * quantified expression (<code>!in(y)</code>) is instantiated after
+	 * substituting all quantified variables according to the binding.
+	 * Therefore, we instantiate <code>!in(y)[y/1]</code> which gives
+	 * <code>!in(1)</code>.
+	 * </p>
+	 * <p>
+	 * In many cases, there will be no possible candidate bindings. For example,
+	 * attempting to bind <code>in(1)</code> with <code>out(y)</code> will fail
+	 * because the predicates differ. Likewise, attempting to bind
+	 * <code>in(1,2)</code> against <code>in(x,x)</code> will fail because there
+	 * is no binding for <code>x</code> which can reproduce <code>in(1,2)</code>
+	 * .
+	 * </p>
+	 * <p>
+	 * When given the concrete and quantified expressions, this function must
+	 * first identify <i>triggers</i> on which binding can be performed. A
+	 * trigger is a matching clause in both the concrete and quantified
+	 * expressions which can be used to bind the quantified variables. To
+	 * understand this, consider a more complex example:
+	 * </p>
+	 *
+	 * <pre>
+	 * in(1) && !out(1) && forall x . in(x) ==> out(x)
+	 * </pre>
+	 *
+	 * <p>
+	 * Let's assume for this example the concrete expression is
+	 * <code>in(1)</code>. Now, we cannot the quantified expression as a whole
+	 * against this concrete expression, because there is no possible binding
+	 * for <code>x</code> which will reproduce <code>in(1)</code> from
+	 * <code>in(x) ==> out(x)</code>. Instead, we need to traverse the
+	 * quantified expression looking for an appropriate trigger to use which, in
+	 * this case, is <code>in(x)</code>. Having found a trigger, we can then use
+	 * it to try and construct an appropriate binding and, if successful,
+	 * instantiate the quantified expression as a whole.
+	 * </p>
+	 *
+	 * <p>
+	 * Finally, it can happen that there are multiple possible bindings for any
+	 * given concrete/quantified expression pairing, and this function should
+	 * return them all. Here is one example:
+	 * </p>
+	 *
+	 * <pre>
+	 * in(1,2) && forall x . !in(1,x) ==> !in(x,2)
+	 * </pre>
+	 * <p>
+	 * In this case there are two valid bindings, namely <code>x=1</code> and
+	 * <code>x=2</code>. However, only one of these bindings will produce the
+	 * contradiction and, hence, it is critical to explore all possible
+	 * bindings.
+	 * </p>
+	 *
+	 * @param automaton
+	 *            The automaton being operated over.
+	 * @param args
+	 *            The arguments list, which consists of the concrete expression,
+	 *            the list of quantified variables and the quantified
+	 *            expression.
+	 * @return
+	 */
+	public static Automaton.Set instantiate(Automaton automaton,
+			Automaton.List args) {
+
+		int concreteExpression = args.get(0);
+		int quantifiedExpression = args.get(2);
+		Automaton.Set quantifiedVarSet = (Automaton.Set) automaton.get(args
+				.get(1));
+
+		// Construct a simple way to identified quantified variables
+		boolean[] quantifiedVariables = markQuantifiedVariables(automaton,quantifiedVarSet);
+		boolean[] quantifiedTriggers = markTriggers(automaton,quantifiedExpression);
+		boolean[] concreteTriggers = markTriggers(automaton,concreteExpression);		
+				
+		// Attempt to find as many bindings as possible. This is a
+		// potentially expensive operation when the quantified expression is
+		// large and/or there are a large number of quantified variables.
+		ArrayList<Binding> bindings = generateBindings(automaton,quantifiedVariables,quantifiedTriggers,concreteTriggers); 		
+		
+		// If one or more bindings have been computed, then apply them to the
+		// quantified expression to produce one or more instantiated
+		// expressions.
+		if (bindings.size() > 0) {
+			return instantiateQuantifiedExpression(automaton,quantifiedExpression,bindings);
+		} else {
+			// No bindings found, so just return empty set. This is an
+			// optimisation because the case of no bindings has high probability
+			// and we want to avoid creating a new set every time.
+			return Automaton.EMPTY_SET;
+		}
+	}
+	
+	/**
+	 * Mark those states in the automaton which correspond to quantified
+	 * variables. This provides an easy way to identify them during traversal of
+	 * the automaton.
+	 * 
+	 * @param automaton
+	 *            --- Automaton in question
+	 * @param quantifiedVarSet
+	 *            --- Set of variables from quantifier.
+	 * @return
+	 */
+	private static boolean[] markQuantifiedVariables(Automaton automaton, Automaton.Set quantifiedVarSet) {
+		boolean[] quantifiedVariables = new boolean[automaton.nStates()];
+		for (int i = 0; i != quantifiedVarSet.size(); ++i) {
+			Automaton.List tuple = (Automaton.List) automaton
+					.get(quantifiedVarSet.get(i));
+			int qvar = tuple.get(0);
+			quantifiedVariables[qvar] = true;
+		}
+		return quantifiedVariables;
+	}
+
+	/**
+	 * Substitute the given bindings into the quantified expression producing one
+	 * or more concrete instantiations of the expression.
+	 * 
+	 * @param automaton 
+	 * @param quantifiedExpression --- Expression being instantiated.
+	 * @param bindings --- List of bindings
+	 * @return
+	 */
+	private static Automaton.Set instantiateQuantifiedExpression(Automaton automaton, int quantifiedExpression,
+			ArrayList<Binding> bindings) {
+		// Apply the substitution for the each binding to produce o given
+		// instantiation.
+		int bindings_size = bindings.size();
+		int[] instances = new int[bindings_size];
+		int index = 0;
+		
+		for (int i = 0; i != bindings_size; ++i) {
+			Binding binding = bindings.get(i);
+			if (binding.numberUnbound == 0) {
+				instances[index++] = automaton.substitute(
+						quantifiedExpression, binding.binding);
+			} else {
+				instances = Arrays.copyOfRange(instances, 0,
+						instances.length - 1);
+			}
+		}
+
+		return new Automaton.Set(instances);
+	}
+	
+	/**
+	 * Traverse the automaton from the given root looking for any "triggers".
+	 * These are instances of a particular term type (e.g. index of)
+	 * 
+	 * @param automaton
+	 *            --- The automaton we're traversing.
+	 * @param root
+	 *            --- State we're traversing from
+	 * @return
+	 */
+	private static boolean[] markTriggers(Automaton automaton, int root) {
+		boolean[] triggers = new boolean[automaton.nStates()];
+		boolean[] visited = new boolean[automaton.nStates()];
+		markTriggers(automaton,root,triggers,visited);		
+		return triggers;
+	}
+	
+	/**
+	 * Traverse automaton from given root marking any states which are triggers.
+	 * 
+	 * @param automaton
+	 *            --- Automaton being traversed
+	 * @param root
+	 *            --- State to traverse from
+	 * @param triggers
+	 *            --- Marked triggers
+	 */
+	private static void markTriggers(Automaton automaton, int root, boolean[] triggers, boolean[] visited) {		
+		Automaton.State state = automaton.get(root);		
+		if(root >= 0 && !visited[root]) {
+			visited[root] = true;
+			triggers[root] |= isTrigger(state.kind);
+		} else {
+			return;
+		}
+		// Now, continue traversing as far as possible
+		
+		switch(state.kind) {
+		case Automaton.K_BOOL:
+		case Automaton.K_INT:		
+		case Automaton.K_REAL:
+		case Automaton.K_STRING:
+			break;
+		case Automaton.K_SET:
+		case Automaton.K_BAG:
+		case Automaton.K_LIST: {
+			Automaton.Collection c = (Automaton.Collection) state;
+			for(int i=0;i!=c.size();++i) {
+				markTriggers(automaton,c.get(i),triggers,visited);
+			}
+			break;
+		}
+		default: {
+			Automaton.Term term = (Automaton.Term) state;
+			if(term.contents != Automaton.K_VOID) {
+				markTriggers(automaton,term.contents,triggers,visited);
+			}
+		}			
+		}
+	}
+
+	/**
+	 * Determine whether a given term kind is a trigger or not. Currently, this
+	 * is hard-coded but it need not be.
+	 * 
+	 * @param kind
+	 * @return
+	 */
+	private static boolean isTrigger(int kind) {
+		return kind == Solver.K_IndexOf;
+	}
+	
+	/**
+	 * Generate all possible bindings by attempting to bind each quantified
+	 * trigger with each concrete trigger.
+	 * 
+	 * @param automaton
+	 * @param quantifiedVariables
+	 * @param quantifiedTriggers
+	 * @param concreteTriggers
+	 * @return
+	 */
+	private static ArrayList<Binding> generateBindings(Automaton automaton, boolean[] quantifiedVariables,
+			boolean[] quantifiedTriggers, boolean[] concreteTriggers) {
+		ArrayList<Binding> bindings = new ArrayList<Binding>();
+		
+		for (int i = 0; i != quantifiedTriggers.length; ++i) {
+			if (quantifiedTriggers[i]) {
+				for (int j = 0; j != concreteTriggers.length; ++j) {
+					if (concreteTriggers[j]) {
+						// FIXME: I feel like the following could be improved.
+						// Certainly, for matching only IndexOf expressions the
+						// full bind function is unnecessary. However, for the
+						// general case, we would need it. Furthermore, this
+						// approach won't guarantee to bind all quantified
+						// variables (though it might still work out as it'll
+						// pick them off one at a time).
+						ArrayList<Binding> localBindings = new ArrayList<Binding>();
+						localBindings.add(new Binding(quantifiedVariables));
+						bind(automaton, j, i, quantifiedVariables, localBindings);
+						bindings.addAll(localBindings);
+					}
+				}
+			}
+		}
+
+		return bindings;
+	}
+
+	/**
+	 * Traverse the automaton attempting to match a quantified expression
+	 * against a concrete expression over a set of quantified variables. The
+	 * quantified expression must be identical to the concrete expression in
+	 * every respect up to the quantified variables. The remaining portions of
+	 * the concrete expression are then used to form the binding for the
+	 * quantified variables. This binding can still fail if an attempt is made
+	 * to bind one variable to multiple distinct pieces of the concrete
+	 * expression.
+	 *
+	 * @param automaton
+	 *            The automaton we're traversing.
+	 * @param concreteRef
+	 *            A reference into the concrete expression we're binding
+	 *            against.
+	 * @param triggerRef
+	 *            A reference into the quantified expression we're binding
+	 *            against.
+	 * @param quantifiedVariables
+	 *            The automaton states representing the quantified variables in
+	 *            the quantified expression.
+	 * @return
+	 */
+	private static void bind(Automaton automaton, int concreteRef,
+			int triggerRef, boolean[] quantifiedVariables,
+			ArrayList<Binding> bindings) {
+		
+		// TODO: For the moment, this function can only produce one binding.
+		// However, for completeness, it needs to be able to produce multiple
+		// bindings.
+
+		if (concreteRef == triggerRef) {
+			// This indicates we've encountered two identical expressions,
+			// neither of which can contain the variables we're binding.
+			// Hence, there is no benefit from continuing.
+			return;
+		} else if (triggerRef >= 0 && quantifiedVariables[triggerRef]) {
+			// This indicates we've hit a quantified variable, and we must
+			// attempt to update all bindings accordingly.
+			for (int i = 0; i != bindings.size(); ++i) {
+				Binding binding = bindings.get(i);
+				if (!binding.bind(concreteRef, triggerRef)) {
+					// This binding failed, so discard
+					bindings.remove(i);
+					i = i - 1;
+				}
+			}
+
+			return;
+		}
+
+		// Otherwise, we are still hunting down one or more quantified variables
+		// and attempting to bind them.
+
+		Automaton.State concreteState = automaton.get(concreteRef);
+		Automaton.State triggerState = automaton.get(triggerRef);
+
+		// Start with easy cases.
+		if (concreteState.kind != triggerState.kind) {
+			// This indicates two non-identical states with different kind. No
+			// binding is possible here, and so all bindings we are exploring
+			// fail.
+			bindings.clear();
+		} else if (concreteState instanceof Automaton.Constant) {
+			// These are all atomic states which have different values (by
+			// construction). At this stage, we ignore such minor differences to
+			// enable more potential bindings to be created. 			
+		} else if (concreteState instanceof Automaton.Term) {
+			Automaton.Term concreteTerm = (Automaton.Term) concreteState;
+			Automaton.Term triggerTerm = (Automaton.Term) triggerState;
+			// In this case, we have two non-identical terms of the same
+			// kind and, hence, we must continue traversing the automaton
+			// in an effort to complete the binding.
+			bind(automaton, concreteTerm.contents, triggerTerm.contents,
+					quantifiedVariables, bindings);
+		} else {
+			Automaton.Collection concreteCollection = (Automaton.Collection) concreteState;
+			Automaton.Collection triggerCollection = (Automaton.Collection) triggerState;
+
+			if (concreteState instanceof Automaton.List) {
+				Automaton.List concreteList = (Automaton.List) concreteCollection;
+				Automaton.List triggerList = (Automaton.List) triggerCollection;
+				bind(automaton, concreteList, triggerList, quantifiedVariables,
+						bindings);
+			} else if (concreteState instanceof Automaton.Set) {
+				Automaton.Set concreteSet = (Automaton.Set) concreteState;
+				Automaton.Set triggerSet = (Automaton.Set) triggerState;
+				bindSetOrBag(automaton, concreteSet, triggerSet, quantifiedVariables,
+						bindings);
+			} else {
+				Automaton.Bag concreteBag = (Automaton.Bag) concreteState;
+				Automaton.Bag triggerBag = (Automaton.Bag) triggerState;
+				bindSetOrBag(automaton, concreteBag, triggerBag, quantifiedVariables,
+						bindings);
+			}
+		}
+	}
+
+	static private void bind(Automaton automaton, Automaton.List concreteList,
+			Automaton.List triggerList, boolean[] quantifiedVariables,
+			ArrayList<Binding> bindings) {
+		// Lists are the easiest to handle, because we can perform a
+		// linear comparison.
+		int l1_size = concreteList.size();
+
+		if (l1_size != triggerList.size()) {
+			// Here, we have lists of different size and, hence,
+			// all bindings being explored must fail.
+			bindings.clear();
+		} else {
+			// In this case, we need to explore each child in sequence to see
+			// whether or not a suitable binding can be determined.
+			for (int i = 0; i != l1_size; ++i) {
+				int lr1 = concreteList.get(i);
+				int lr2 = triggerList.get(i);
+
+				if (lr1 != lr2) {
+					// Here, we have non-identical elements at the same
+					// position. Therefore, we traverse them to look to update
+					// the bindings we are exploring.
+					bind(automaton, lr1, lr2, quantifiedVariables, bindings);
+
+					if (bindings.isEmpty()) {
+						// Early termination since no valid bindings
+						// encountered.
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	static private boolean bindSetOrBag(Automaton automaton, Automaton.Collection concreteSet,
+			Automaton.Collection triggerSet, boolean[] quantifiedVariables, ArrayList<Binding> bindings) {
+
+		// Note, concrete and trigger sets do not have to have same size here.
+		int concreteSize = concreteSet.size();
+		int triggerSize = triggerSet.size();
+
+		// NOTE: this matches every trigger child with a concrete child, but not
+		// vice-versa. See #379.
+
+		for (int i = 0; i != triggerSize; ++i) {
+			int trigger_child = triggerSet.get(i);
+
+			// Here, we take a copy of the current bindings list. The reason for
+			// this is so we can clear bindings for each concrete item and build
+			// it up again. However, since a failing match in the subsequent
+			// innerBind() will clear the bindings passed in, we need to keep
+			// this copy so we can recreate it.
+			ArrayList<Binding> originalBindings = clone(bindings);
+			bindings.clear();
+
+			for (int j = 0; j != concreteSize; ++j) {
+				int concrete_child = concreteSet.get(j);
+				// Make a local copy of the original bindings. This is to allow
+				// us to pass this local copy through the following child and
+				// see what bindings (if any) are left.
+				ArrayList<Binding> localBindings = clone(originalBindings);
+				bind(automaton, concrete_child, trigger_child,
+						quantifiedVariables, localBindings);
+				// Finally, whatever bindings are left we add to the list of
+				// bindings being explored.
+				bindings.addAll(localBindings);
+			}
+		}
+
+		return true;
+	}
+
+	/**
+	 * Create a deep clone of this array list, including the bindings it
+	 * contains.
+	 *
+	 * @param bindings
+	 * @return
+	 */
+	private static ArrayList<Binding> clone(ArrayList<Binding> bindings) {
+		ArrayList<Binding> newBindings = new ArrayList<Binding>(bindings);
+		for (int i = 0; i != newBindings.size(); ++i) {
+			Binding binding = newBindings.get(i);
+			newBindings.set(i, new Binding(binding));
+		}
+		return newBindings;
+	}
+
+	/**
+	 * <p>
+	 * Represents a partial (or complete) binding, as may be encountered during
+	 * (or at the end) of the binding process. The binding is simply a mapping
+	 * from quantified variables to their instantiated terms.
+	 * </p>
+	 * <p>
+	 * The binding must keep track of how many variables have actually been
+	 * bound. This is because we may not end up instantiating all variables and
+	 * we must know when this occurs in order to ensure the remaining variables
+	 * remain quantified afterwards.
+	 * </p>
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	private final static class Binding implements Comparable<Binding> {
+		/**
+		 * The mapping from automaton states to automaton states. Initially,
+		 * each state maps to itself. As the computation proceeds, those states
+		 * representing quantified variables will be mapped to other (concrete)
+		 * states.
+		 */
+		private final int[] binding;
+
+		/**
+		 * Counts the number of unbound quantified variables. If this reaches
+		 * zero, we know that every quantified variables has been bound.
+		 */
+		private int numberUnbound;
+
+		/**
+		 * Construct a fresh binding from a given set of quantifiedVariables.
+		 *
+		 * @param quantifiedVariables
+		 */
+		public Binding(boolean[] quantifiedVariables) {
+			this.binding = new int[quantifiedVariables.length];
+			// Initialise all states so they map to themselves, and count the
+			// number of quantified variables.
+			for (int i = 0; i != quantifiedVariables.length; ++i) {
+				this.binding[i] = i;
+				if (quantifiedVariables[i]) {
+					this.numberUnbound++;
+				}
+			}
+		}
+
+		public Binding(Binding binding) {
+			this.binding = Arrays.copyOf(binding.binding,
+					binding.binding.length);
+			this.numberUnbound = binding.numberUnbound;
+		}
+
+		/**
+		 * Bind a concrete state reference to a quantified state reference.
+		 *
+		 * @param concreteRef
+		 *            Concrete state bound to
+		 * @param quantifiedRef
+		 *            Variable state being bound
+		 * @return
+		 */
+		public boolean bind(int concreteRef, int quantifiedRef) {
+			int current = binding[quantifiedRef];
+
+			if (current != quantifiedRef && current != concreteRef) {
+				// In this case, the binding we've found conflicts with a
+				// previously established binding of the same variable.
+				// Therefore, no valid binding is possible and we must fail.
+				return false;
+			} else if (current == quantifiedRef) {
+				// In this case, there was no previous binding for this
+				// variable so we establish one now.
+				binding[quantifiedRef] = concreteRef;
+				numberUnbound = numberUnbound - 1;
+			} else {
+				// Otherwise, we leave the existing binding as is.
+			}
+
+			return true;
+		}
+
+		@Override
+		public int compareTo(Binding b) {
+			int c = compare(binding,b.binding);
+			if(c != 0) {
+				return c;
+			} else if(numberUnbound < b.numberUnbound){
+				return -1;
+			} else if(numberUnbound > b.numberUnbound){
+				return 1;
+			} else {
+				return 0;
+			}
+		}	
+		
+		@Override
+		public boolean equals(Object o) {
+			if(o instanceof Binding) {
+				Binding b = (Binding) o;
+				return compareTo(b) == 0;
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public int hashCode() {
+			return Arrays.hashCode(binding);
+		}
+	}
+	
+	private static int compare(int[] lhs, int[] rhs) {
+		if(lhs.length < rhs.length) {
+			return -1;
+		} else if(lhs.length > rhs.length) {
+			return 1;
+		} else {
+			for(int i=0;i!=lhs.length;++i) {
+				int l = lhs[i];
+				int r = rhs[i];
+				if(l < r) {
+					return -1;
+				} else if(l > r) {
+					return 1;
+				}
+			}
+			return 0;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/solver/Solver.wyrl b/modules/wycs/src/wycs/solver/Solver.wyrl
new file mode 100755
index 0000000000..29f604aabe
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Solver.wyrl
@@ -0,0 +1,8 @@
+package wycs.solver
+
+include "Core.wyrl"
+include "Arithmetic.wyrl"
+include "Arrays.wyrl"
+include "Quantifiers.wyrl"
+include "TypeTests.wyrl"
+
diff --git a/modules/wycs/src/wycs/solver/SolverUtil.java b/modules/wycs/src/wycs/solver/SolverUtil.java
new file mode 100755
index 0000000000..4c559f58be
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/SolverUtil.java
@@ -0,0 +1,193 @@
+package wycs.solver;
+
+import static wycs.solver.Solver.Div;
+import static wycs.solver.Solver.Mul;
+import static wycs.solver.Solver.Sum;
+import wyautl.core.Automaton;
+import wycs.core.SemanticType;
+
+/**
+ * Provides a bunch of utility methods to simplify interfacing with the Solver
+ * directly.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class SolverUtil {
+
+	/**
+	 * Construct an automaton node representing the negation of an arithmetic
+	 * expression.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- the expression to negate
+	 * @return the index of the new node.
+	 */
+	static public int Neg(Automaton automaton, int lhs) {
+		return Solver.Mul(automaton, automaton.add(new Automaton.Real(-1)),
+				automaton.add(new Automaton.Bag(lhs)));
+	}
+
+	/**
+	 * Construct an automaton node representing the addition of two arithmetic
+	 * expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Add(Automaton automaton, int lhs, int rhs) {
+		return Solver.Sum(automaton,
+				automaton.add(new Automaton.Real(0)),
+				automaton.add(new Automaton.Bag(lhs, rhs)));
+	}
+
+	/**
+	 * Construct an automaton node representing the subtraction of two arithmetic
+	 * expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Sub(Automaton automaton, int lhs, int rhs) {
+		rhs = Neg(automaton,rhs);
+		return Solver.Sum(automaton,
+				automaton.add(new Automaton.Real(0)),
+				automaton.add(new Automaton.Bag(lhs, rhs)));
+	}
+
+	/**
+	 * Construct an automaton node representing the multiplication of two
+	 * arithmetic expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Mul(Automaton automaton, int lhs, int rhs) {
+		return Solver.Mul(automaton,
+				automaton.add(new Automaton.Real(1)),
+				automaton.add(new Automaton.Bag(lhs, rhs)));
+	}
+
+	/**
+	 * Construct an automaton node representing the multiplication of two
+	 * arithmetic expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Div(Automaton automaton, int lhs, int rhs) {
+		return Solver.Div(automaton, lhs, rhs);
+	}
+
+	/**
+	 * Construct an automaton node representing the equality of two
+	 * expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Equals(Automaton automaton, int type, int lhs, int rhs) {
+		return Solver.Equals(automaton,
+				type,
+				automaton.add(new Automaton.Bag(lhs, rhs)));
+	}
+
+	/**
+	 * Construct an automaton node representing an inequality comparing
+	 * two arithmetic expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	public static int LessThan(Automaton automaton, int type, int lhs, int rhs) {
+		// lhs < rhs ==> lhs + 1 <= rhs ==> 0 < rhs -(lhs + 1)
+		Automaton.State state = automaton.get(type);
+		if(state.kind == Solver.K_IntT) {
+			// integer case wheren inequality is non-strict.
+			lhs = Add(automaton, lhs, Solver.Num(automaton, 1));
+			int expr = Add(automaton, Neg(automaton, lhs), rhs);
+			return Solver.Inequality(automaton,type,expr);
+		} else {
+			// non-integer case where inequality is strict.
+			int expr = Add(automaton, Neg(automaton, lhs), rhs);
+			return Solver.Inequality(automaton,type,expr);
+		}
+	}
+
+	/**
+	 * Construct an automaton node representing the addition of two arithmetic
+	 * expressions.
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	public static int LessThanEq(Automaton automaton, int type, int lhs,
+			int rhs) {
+		Automaton.State state = automaton.get(type);
+		int expr = Add(automaton, Neg(automaton, lhs), rhs);
+		int ieq = Solver.Inequality(automaton,type,expr);
+		if(state.kind == Solver.K_IntT) {
+			// integer case wheren inequality is non-strict.
+			return ieq;
+		} else {
+			// non-integer case where inequality is strict.
+			int eq = Solver.Equals(automaton, type,
+					automaton.add(new Automaton.Bag(lhs, rhs)));
+			return Solver.Or(automaton, ieq, eq);
+		}
+	}
+
+	/**
+	 * Construct an automaton node representing the logical implication between
+	 * two nodes
+	 *
+	 * @param automaton
+	 *            --- automaton to create new node in.
+	 * @param lhs
+	 *            --- left expression.
+	 * @param rhs
+	 *            --- right expression.
+	 * @return the index of the new node.
+	 */
+	static public int Implies(Automaton automaton, int lhs, int rhs) {
+		lhs = Solver.Not(automaton, lhs);
+		return Solver.Or(automaton, new int[]{lhs,rhs});
+	}
+}
diff --git a/modules/wycs/src/wycs/solver/TypeTests.wyrl b/modules/wycs/src/wycs/solver/TypeTests.wyrl
new file mode 100755
index 0000000000..c01cc714f6
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/TypeTests.wyrl
@@ -0,0 +1,21 @@
+// ====================================================================
+// Is
+// ====================================================================
+
+term Is[Expr,Type]
+
+// No expression can yield the VoidT
+@name("Is_1")
+reduce Is[Expr e, VoidT]:
+    => False
+
+// Inverting a type test gives a type test
+@name("Is_2")
+reduce Not(Is[Expr e, Type t]):
+    => Is([e,NotT(t)])
+
+// Transitivity of type tests
+@name("Is_3")
+reduce And{Is[Expr e1, Type t1], Is[Expr e2, Type t2], BExpr... bs}
+requires e1 == e2:
+    => And({Is[e1,AndT{t1,t2}]} ++ bs)
diff --git a/modules/wycs/src/wycs/solver/Types.wyrl b/modules/wycs/src/wycs/solver/Types.wyrl
new file mode 100755
index 0000000000..4ea407275c
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/Types.wyrl
@@ -0,0 +1,272 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ====================================================================
+// Overview
+// ====================================================================
+//
+// Defines a language of types similar to that found in this paper:
+//
+// * "Sound and Complete Flow Typing with Unions, Intersections and
+//    Negations", David J. Pearce, In Proceedings of VMCAI, 2013.
+
+// ====================================================================
+// Not
+// ====================================================================
+
+term NotT(Type)
+
+@rank(0)
+@name("NotT(AnyT)")
+reduce NotT(AnyT):
+    => VoidT
+
+@rank(0)
+@name("NotT(VoidT)")
+reduce NotT(VoidT):
+    => AnyT
+
+@rank(0)
+@name("NotT(NotT)")
+reduce NotT(NotT(Type t)):
+    => t
+
+@rank(1)
+@name("NotT(OrT)")
+reduce NotT(OrT{Type... es}):
+    => let ns = { NotT(e) | e in es }
+       in AndT(ns)
+
+@rank(2)
+@name("NotT(AndT)")
+reduce NotT(AndT{Type... es}):
+    => let ns = { NotT(e) | e in es }
+       in OrT(ns)
+
+// ====================================================================
+// And
+// ====================================================================
+
+term AndT{Type...}
+
+@rank(0)
+@name("AndT{}")
+reduce AndT{}:
+    => VoidT
+
+@rank(0)
+@name("AndT{Type}")
+reduce AndT{Type t}:
+    => t
+
+@rank(1)
+@name("AndT{AndT,Type...}")
+reduce AndT{AndT{Type... xs}, Type... ys}:
+    => AndT (xs ++ ys)
+
+@rank(3)
+@name("AndT{OrT,Type...}")
+reduce AndT{OrT{Type... xs}, Type... ys}:
+    => let zs = { AndT(x ++ ys) | x in xs }
+       in OrT (zs)
+
+// ====================================================================
+// Or
+// ====================================================================
+
+term OrT{Type...}
+
+@rank(0) 
+@name("OrT{}")
+reduce OrT{}:
+    => VoidT
+
+@rank(0)
+@name("OrT{Type}")
+reduce OrT{Type t}:
+    => t
+
+@rank(1)
+@name("OrT{OrT,Type...}")
+reduce OrT{OrT{Type... xs}, Type... ys}:
+    => OrT (xs ++ ys)
+
+// ====================================================================
+// Tuple
+// ====================================================================
+term TupleT[Type...]
+
+@rank(0)
+@name("TupleT[Type...]")
+reduce TupleT[Type... ts]
+requires VoidT in ts:
+    => VoidT
+
+@rank(0)
+@name("TupleT[]")
+reduce TupleT[Type... ts]
+requires |ts| == 0:
+    => VoidT
+
+@rank(0)
+@name("TupleT[Type]")
+reduce TupleT[Type t]:
+    => t
+
+@rank(2)
+@name("AndT{TupleT,TupleT,Type...}")
+reduce AndT{TupleT[Type... t1s], TupleT[Type... t2s], Type... ts}:
+    => VoidT, if |t1s| != |t2s|
+    => let r = [ AndT{t1s[i],t2s[i]} | i in 0..|t1s| ]
+       in AndT(TupleT(r) ++ ts)
+
+@rank(2)
+@name("AndT{TupleT,NotT(TupleT,Type...}")
+reduce AndT{TupleT[Type... t1s] t1, NotT(TupleT[Type... t2s]), Type... ts}:
+    => AndT(t1 ++ ts), if |t1s| != |t2s|
+    => VoidT, if |t1s| == 0
+    => let r = [ AndT{t1s[i],NotT(t2s[i])} | i in 0..|t1s| ]
+       in AndT(TupleT(r) ++ ts)
+
+@rank(2)
+@name("AndT{TupleT,NotT(ArrayT),Type...}")
+reduce AndT{TupleT[Type...] t1, NotT(ArrayT(Type)), Type... ts}:
+    => AndT({t1} ++ ts)
+
+// TODO: pull disjuncts out of tuples?
+
+// ====================================================================
+// Array
+// ====================================================================
+term ArrayT(Type)
+
+// Handle the case of an invalid set type.  This rule is really what
+// makes set types complicated.  The rule is necessary purely to help
+// with intersection.  For example {(int,int)} & {int} =>
+// {(int,int)&int}{void}. This makes sense, but is deceiving.  For
+// example, {int} & !{any} => {int&!any} => {void} as well.
+@rank(0)
+@name("ArrayT(VoidT)")
+reduce ArrayT(VoidT):
+    => VoidT
+
+@rank(2)
+@name("AndT{ArrayT,ArrayT,Type...}")
+reduce AndT{ArrayT(Type t1), ArrayT(Type t2), Type... ts}:
+    => AndT(ArrayT(AndT{t1,t2})++ts)
+
+@rank(2)
+@name("AndT{ArrayT,NotT(ArrayT),Type...}")
+reduce AndT{ArrayT(Type t1), NotT(ArrayT(Type t2)), Type... ts}:
+    => AndT(ArrayT(AndT{t1,NotT(t2)})++ts)
+
+@rank(2)
+@name("AndT{ArrayT,NotT(Tuple),Type...}")
+reduce AndT{ArrayT(Type) t1, NotT(TupleT[Type...]), Type... ts}:
+    => AndT({t1} ++ ts)
+
+@rank(1)
+@name("AndT{ArrayT,Proton,Type...}")
+reduce AndT{ArrayT(Type) s, Proton p, Type... ts}
+requires !(p is AnyT):
+    => VoidT
+
+@rank(2)
+@name("OrT{ArrayT,ArrayT,Type...}")
+reduce OrT{ArrayT(Type t1) s1, ArrayT(Type t2) s2, Type... ts}
+requires t1 == t2:
+    => OrT({s1}++ts)
+
+// ====================================================================
+// Atoms
+// ====================================================================
+
+term AnyT
+term VoidT
+term NullT
+term BoolT
+term IntT
+term RealT
+term StringT
+term VarT(string)
+term NominalT(string)
+
+define Quark as AnyT | NullT | VoidT | BoolT | IntT | RealT | StringT | VarT(string) | NominalT(string)
+define Proton as Quark | TupleT[Proton...] | ArrayT(Proton)
+define Atom as Proton | NotT(Proton)
+
+@rank(0)
+@name("AndT{VoidT,Type...}")
+reduce AndT{VoidT, Type... xs}:
+    => VoidT
+
+@rank(0)
+@name("AndT{AnyT, Type...}")
+reduce AndT{AnyT, Type... xs}:
+    => AndT(xs)
+
+// a1 needs to be a quark here, as the rule for tuples is handled
+// above.
+@rank(1)
+@name("AndT{Quark,Proton,Type...}")
+reduce AndT{Quark a1, Proton a2, Type... ts}
+requires a1 != a2 && a1 != AnyT && a2 != AnyT:
+    => VoidT
+
+// a1 needs to be a quark here, as the rule for tuples is handled
+// above.
+@rank(1)
+@name("AndT{Quark,NotT(Proton),Type...}")
+reduce AndT{Quark a1, NotT(Proton a2), Type... ts}
+requires a1 == a2:
+    => VoidT
+
+@rank(1)
+@name("AndT{Quark,NotT(Proton),Type...}")
+reduce AndT{Quark a1, NotT(Proton a2), Type... ts}
+requires a1 != a2 && a2 != AnyT:
+    => AndT (a1 ++ ts)
+
+@rank(0)
+@name("OrT{AnyT,Type...}")
+reduce OrT{AnyT, Type... xs}:
+    => AnyT
+
+@rank(0)
+@name("Or{VoidT,Type...}")
+reduce OrT{VoidT, Type... xs}:
+    => OrT(xs)
+
+// ====================================================================
+// Function
+// ====================================================================
+term FunctionT[Type,Type, Type...]
+
+// ====================================================================
+// General Type
+// ====================================================================
+
+define Type as Atom | NotT | OrT | AndT | ArrayT | TupleT | FunctionT
+
diff --git a/modules/wycs/src/wycs/solver/smt/Block.java b/modules/wycs/src/wycs/solver/smt/Block.java
new file mode 100755
index 0000000000..cfa2ba446a
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Block.java
@@ -0,0 +1,102 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Represents a block of statements. A block is surrounded by a {@link wycs.solver.smt.Stmt.Push}
+ * and {@link wycs.solver.smt.Stmt.Pop} statement in order to have any declarations and assertions
+ * localised to itself.
+ *
+ * @author Henry J. Wylde
+ */
+public final class Block implements Element {
+
+    /**
+     * A list of elements in this block. Uses a {@link java.util.LinkedHashSet} as the container to
+     * remove any duplicate {@link wycs.solver.smt.Stmt.DeclareFun}, {@link
+     * wycs.solver.smt.Stmt.DeclareSort}, {@link wycs.solver.smt.Stmt.DefineFun}, {@link
+     * wycs.solver.smt.Stmt.DefineSort} and {@link wycs.solver.smt.Stmt.Assert}s. Doing this means
+     * we don't have to manually check for their existence and ensures they are uniquely defined.
+     */
+    private final Set<Element> elements = new LinkedHashSet<Element>();
+
+    /**
+     * Appends the given elements to this block.
+     *
+     * @param elements the elements to add.
+     */
+    public void append(Element... elements) {
+        append(Arrays.asList(elements));
+    }
+
+    /**
+     * Appends the given elements to this block.
+     *
+     * @param elements the elements to add.
+     */
+    public void append(Collection<? extends Element> elements) {
+        if (elements.contains(null)) {
+            throw new NullPointerException("elements cannot contain null");
+        }
+
+        this.elements.addAll(elements);
+    }
+
+    /**
+     * Clears this block, removing all elements.
+     */
+    public void clear() {
+        elements.clear();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        if (elements.isEmpty()) {
+            return "";
+        }
+
+        StringBuilder sb = new StringBuilder();
+
+        sb.append(new Stmt.Push(1));
+        sb.append("\n");
+        for (Element element : elements) {
+            sb.append(element);
+            sb.append("\n");
+        }
+        sb.append(new Stmt.Pop(1));
+        sb.append("\n");
+
+        return sb.toString();
+    }
+}
diff --git a/modules/wycs/src/wycs/solver/smt/Element.java b/modules/wycs/src/wycs/solver/smt/Element.java
new file mode 100755
index 0000000000..73dc0a278f
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Element.java
@@ -0,0 +1,34 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+/**
+ * An element in a {@link wycs.solver.smt.Smt2File}. This interface is used for a composite design
+ * pattern.
+ *
+ * @author Henry J. Wylde
+ */
+public interface Element {}
diff --git a/modules/wycs/src/wycs/solver/smt/Logic.java b/modules/wycs/src/wycs/solver/smt/Logic.java
new file mode 100755
index 0000000000..6ef08a715d
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Logic.java
@@ -0,0 +1,40 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+/**
+ * Roughly speaking, a logic is a collection of theorems that are required to run the {@link
+ * wycs.solver.smt.Smt2File}. For details on a specific logic, see {@linktourl
+ * http://smtlib.cs.uiowa.edu/logics.shtml}.
+ *
+ * @author Henry J. Wylde
+ */
+public enum Logic {
+
+    AUFLIA, AUFLIRA, AUFNIRA, LRA, QF_ABV, QF_AUFBV, QF_AUFLIA, QF_AX, QF_BV, QF_IDL, QF_LIA,
+    QF_LRA, QF_NIA, QF_NRA, QF_RDL, QF_UF, QF_UFBV, QF_UFIDL, QF_UFLIA, QF_UFLRA, QF_UFNRA, UFLRA,
+    UFNIA;
+}
diff --git a/modules/wycs/src/wycs/solver/smt/Option.java b/modules/wycs/src/wycs/solver/smt/Option.java
new file mode 100755
index 0000000000..07fe52fb91
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Option.java
@@ -0,0 +1,76 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+/**
+ * A utility class for some options provided by some of the solvers specified in {@link
+ * wycs.solver.smt.Solver}. These options are used in a {@link wycs.solver.smt.Stmt.SetOption}
+ * statement.
+ *
+ * @author Henry J. Wylde
+ */
+public final class Option {
+
+    /**
+     * Boolean. Sets whether the solver should print out "success" for each statement executed.
+     */
+    public static final String PRINT_SUCCESS = ":print-success";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should automatically
+     * configurate itself.
+     */
+    public static final String Z3_AUTO_CONFIG = ":auto-config";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should automatically
+     * configurate itself.
+     */
+    public static final String Z3_SMT_AUTO_CONFIG = ":smt.auto-config";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should pull nested
+     * quantifiers out to the front of an expression.
+     */
+    public static final String Z3_PULL_NESTED_QUANTIFIERS = ":pull-nested-quantifiers";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should pull nested
+     * quantifiers out to the front of an expression.
+     */
+    public static final String Z3_SMT_PULL_NESTED_QUANTIFIERS = ":smt.pull-nested-quantifiers";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should use its model based
+     * quantifier instantiation method for resolution.
+     */
+    public static final String Z3_MBQI = ":mbqi";
+    /**
+     * Boolean. {@link wycs.solver.smt.Solver#Z3} option. Sets whether Z3 should use its model based
+     * quantifier instantiation method for resolution.
+     */
+    public static final String Z3_SMT_MBQI = ":smt.mbqi";
+
+    /**
+     * This class may not be instantiated.
+     */
+    private Option() {}
+}
diff --git a/modules/wycs/src/wycs/solver/smt/Response.java b/modules/wycs/src/wycs/solver/smt/Response.java
new file mode 100755
index 0000000000..9ea39c02c7
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Response.java
@@ -0,0 +1,58 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+/**
+ * Utility class for constants representing the response of a SMT solver.
+ *
+ * @author Henry J. Wylde
+ */
+public final class Response {
+
+    /**
+     * Result is satisfiable; there is one or more models that make the assertions true.
+     */
+    public static final String SAT = "sat";
+    /**
+     * Result is unsatisfiable: there is one or more models that make the assertions false.
+     */
+    public static final String UNSAT = "unsat";
+    /**
+     * Result is unknown: may have timed out or was unable to come to a conclusion about the
+     * assertions.
+     */
+    public static final String UNKNOWN = "unknown";
+    /**
+     * Response says unsupported: a solver may return this is a {@link
+     * wycs.solver.smt.Stmt.SetOption} is not supported by that solver.
+     */
+    public static final String UNSUPPORTED = "unsupported";
+
+    /**
+     * This class cannot be instantiated.
+     */
+    private Response() {}
+}
diff --git a/modules/wycs/src/wycs/solver/smt/Smt2File.java b/modules/wycs/src/wycs/solver/smt/Smt2File.java
new file mode 100755
index 0000000000..f2985811a1
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Smt2File.java
@@ -0,0 +1,103 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * Represents a <i>SMT</i> file. A SMT file is made up of a list of statements and may be verified
+ * using a SMT solver.
+ *
+ * @author Henry J. Wylde
+ */
+public final class Smt2File {
+
+    /**
+     * A list of elements in this block. Uses a {@link java.util.LinkedHashSet} as the container to
+     * remove any duplicate {@link wycs.solver.smt.Stmt.DeclareFun}, {@link
+     * wycs.solver.smt.Stmt.DeclareSort}, {@link wycs.solver.smt.Stmt.DefineFun}, {@link
+     * wycs.solver.smt.Stmt.DefineSort} and {@link wycs.solver.smt.Stmt.Assert}s. Doing this means
+     * we don't have to manually check for their existence and ensures they are uniquely defined.
+     */
+    private final Set<Element> elements = new LinkedHashSet<Element>();
+
+    public Smt2File() {}
+
+    /**
+     * Appends the given elements to this file.
+     *
+     * @param elements the elements to add.
+     */
+    public void append(Element... elements) {
+        append(Arrays.asList(elements));
+    }
+
+    /**
+     * Appends the given elements to this file.
+     *
+     * @param elements the elements to add.
+     */
+    public void append(Collection<? extends Element> elements) {
+        if (elements.contains(null)) {
+            throw new NullPointerException("elements cannot contain null");
+        }
+
+        this.elements.addAll(elements);
+    }
+
+    /**
+     * Clears this file, removing all elements.
+     */
+    public void clear() {
+        elements.clear();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        if (elements.isEmpty()) {
+            return "";
+        }
+
+        StringBuilder sb = new StringBuilder();
+
+        for (Element element : elements) {
+            sb.append(element);
+
+            if (!(element instanceof Block)) {
+                sb.append("\n");
+            }
+        }
+
+        return sb.toString();
+    }
+}
+
diff --git a/modules/wycs/src/wycs/solver/smt/Sort.java b/modules/wycs/src/wycs/solver/smt/Sort.java
new file mode 100755
index 0000000000..5fe6876f73
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Sort.java
@@ -0,0 +1,564 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import wycc.util.Pair;
+
+/**
+ * A sort is the term for a type in the SMT domain. This class provides a few default sorts as well
+ * as the ability to create generic sorts, such as {@link wycs.solver.smt.Sort.Set}s or {@link
+ * wycs.solver.smt.Sort.Tuple}s. In order to utilise these generic sorts, it is required that the
+ * initialisers (from {@link #generateInitialisers(Solver)} be added to the surrounding {@link
+ * wycs.solver.smt.Block} or {@link wycs.solver.smt.Smt2File}.
+ * <p/>
+ * This design pattern is required as it is not possible to easily write custom theorems to add to
+ * SMT solvers.
+ *
+ * @author Henry J. Wylde
+ */
+public abstract class Sort {
+
+    /**
+     * The singleton any sort.
+     */
+    public static final Sort.Any ANY = new Sort.Any();
+    /**
+     * The singleton boolean sort.
+     */
+    public static final Sort.Bool BOOL = new Sort.Bool();
+    /**
+     * The singleton integer sort.
+     */
+    public static final Sort.Int INT = new Sort.Int();
+    /**
+     * The singleton real sort.
+     */
+    public static final Sort.Real REAL = new Sort.Real();
+
+    /**
+     * This class can only be instantiated locally.
+     */
+    Sort() {}
+
+    /**
+     * Generates the required statements to use this generic sort. Will also add in extra utility
+     * functions for working with the sort.
+     * <p/>
+     * This function takes a parameter, the solver, to generate the initialisers for. This allows a
+     * sort to provide specialised initialisers depending on which solver is being used. For
+     * example, Z3 provides a {@code map} function that can be used to efficiently define a set
+     * union operation.
+     *
+     * @param solver the solver to generate the initialisers for.
+     * @return the generated initialisation statements.
+     */
+    public abstract List<? extends Stmt> generateInitialisers();
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Any extends Sort {
+
+        private Any() {}
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            List<Stmt> initialisers = new ArrayList<Stmt>();
+
+            initialisers.addAll(generateSorts());
+
+            return initialisers;
+        }
+
+        public String getName() {
+            return "Any";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return getName();
+        }
+
+        private Collection<? extends Stmt> generateSorts() {
+            return Arrays.asList(new Stmt.DeclareSort(getName(), 0));
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Array extends Sort {
+
+        private final String index;
+        private final String element;
+
+        public Array(String index, String element) {
+            if (index == null) {
+                throw new NullPointerException("index cannot be null");
+            }
+            if (element == null) {
+                throw new NullPointerException("element cannot be null");
+            }
+
+            this.index = index;
+            this.element = element;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            return Collections.emptyList();
+        }
+
+        public String getName() {
+            return "Array";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(" + getName() + " " + index + " " + element + ")";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Bool extends Sort {
+
+        private Bool() {}
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            return Collections.emptyList();
+        }
+
+        public String getName() {
+            return "Bool";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return getName();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Int extends Sort {
+
+        private Int() {}
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            return Collections.emptyList();
+        }
+
+        public String getName() {
+            return "Int";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return getName();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Real extends Sort {
+
+        private Real() {}
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            return Collections.emptyList();
+        }
+
+        public String getName() {
+            return "Real";
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return getName();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Set extends Sort {
+
+        public static final String FUN_ADD_NAME = "add";
+        public static final String FUN_CONTAINS_NAME = "contains";
+        public static final String FUN_EMPTY_NAME = "empty";
+        public static final String FUN_LENGTH_NAME = "length";
+        public static final String FUN_REMOVE_NAME = "remove";
+        public static final String FUN_SUBSET_NAME = "subset";
+        public static final String FUN_SUBSETEQ_NAME = "subseteq";
+
+        private final String type;
+
+        public Set(String type) {
+            if (type == null) {
+                throw new NullPointerException("type cannot be null");
+            }
+
+            this.type = type;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public List<? extends Stmt> generateInitialisers() {
+            List<Stmt> initialisers = new ArrayList<Stmt>();
+
+            initialisers.addAll(generateSorts());
+            initialisers.addAll(generateAddFunctions());
+            initialisers.addAll(generateContainsFunctions());
+            initialisers.addAll(generateRemoveFunctions());
+            initialisers.addAll(generateEmptyConstants());
+            initialisers.addAll(generateLengthFunctions());
+            initialisers.addAll(generateEmptyLengthAssertions());
+            initialisers.addAll(generateSubsetFunctions());
+            // Causes lots of the tests to timeout
+            //initialisers.addAll(generateSubsetLengthAssertions());
+
+            return initialisers;
+        }
+
+        public String getEmptyNameAsQualified() {
+            return "(as " + FUN_EMPTY_NAME + " " + toString() + ")";
+        }
+
+        /**
+         * Gets the name of this set sort. The name is simply "Set".
+         * <p/>
+         * For the sort name to use in functions etc., use {@link #toString()}.
+         *
+         * @return the name of this set sort.
+         */
+        public String getName() {
+            return "Set";
+        }
+
+        /**
+         * Gets the name of this particular set sort, with it's type. The whole name is surrounded
+         * by parenthesis.
+         */
+        @Override
+        public String toString() {
+            return "(" + getName() + " " + type + ")";
+        }
+
+        private List<? extends Stmt> generateAddFunctions() {
+            List<Pair<String, String>> parameters = new ArrayList<Pair<String, String>>();
+            parameters.add(new Pair<String, String>("set", toString()));
+            parameters.add(new Pair<String, String>("t", type));
+            String expr = "(store set t true)";
+
+            return Arrays.asList(new Stmt.DefineFun(FUN_ADD_NAME, parameters, toString(), expr));
+        }
+
+        private List<? extends Stmt> generateContainsFunctions() {
+            List<Pair<String, String>> parameters = new ArrayList<Pair<String, String>>();
+            parameters.add(new Pair<String, String>("set", toString()));
+            parameters.add(new Pair<String, String>("t", type));
+            String expr = "(select set t)";
+
+            return Arrays.asList(new Stmt.DefineFun(FUN_CONTAINS_NAME, parameters, BOOL.toString(),
+                    expr));
+        }
+
+        private List<? extends Stmt> generateEmptyConstants() {
+            List<Stmt> stmts = new ArrayList<Stmt>();
+
+            stmts.add(new Stmt.DeclareFun(FUN_EMPTY_NAME, Collections.EMPTY_LIST, toString()));
+            // The empty set does not contain any elements
+            stmts.add(new Stmt.Assert(
+                    "(not (exists ((t " + type + ")) (contains " + getEmptyNameAsQualified()
+                            + " t)))"));
+
+            return stmts;
+        }
+
+        private List<? extends Stmt> generateEmptyLengthAssertions() {
+            return Arrays.asList(new Stmt.Assert(
+                    "(= (length " + getEmptyNameAsQualified() + ") 0)"));
+        }
+
+        private List<? extends Stmt> generateLengthFunctions() {
+            List<Stmt> stmts = new ArrayList<Stmt>();
+
+            stmts.add(new Stmt.DeclareFun(FUN_LENGTH_NAME, Arrays.asList(toString()),
+                    INT.toString()));
+            // The length of all sets is a natural number
+            stmts.add(new Stmt.Assert("(forall ((set " + toString() + ")) (<= 0 (length set)))"));
+            // A recursive conjecture for determining the length of sets
+            // Either a set is empty (and hence its length is 0) or:
+            // There exists some element t, contained within the set, hence its length must be 1 +
+            // the length of the set minus t
+            // TODO: This conjecture really should be iff or xor (going both ways), however using
+            // xor causes it to time out, so for now we use implication
+            stmts.add(new Stmt.Assert("(forall ((set " + toString() + ")) (=> (distinct set "
+                    + getEmptyNameAsQualified() + ") (exists ((t " + type
+                    + ")) (and (contains set t) (= (length set) (+ 1 (length (remove set t))))))))"));
+            // lines.add(new Stmt.Assert(
+            // "(forall ((set " + toString() + ")) (xor (= set " + FUN_EMPTY_NAME
+            // + ") (exists ((t " + type
+            // + ")) (and (contains set t) (= (length set) (+ 1 (length (remove set t))))))))"
+            // ));
+
+            return stmts;
+        }
+
+        private List<? extends Stmt> generateRemoveFunctions() {
+            List<Pair<String, String>> parameters = new ArrayList<Pair<String, String>>();
+            parameters.add(new Pair<String, String>("set", toString()));
+            parameters.add(new Pair<String, String>("t", type));
+            String expr = "(store set t false)";
+
+            return Arrays.asList(new Stmt.DefineFun(FUN_REMOVE_NAME, parameters, toString(), expr));
+        }
+
+        private List<? extends Stmt> generateSorts() {
+            List<String> parameters = Arrays.asList("T");
+            String expr = new Sort.Array("T", BOOL.toString()).toString();
+
+            return Arrays.asList(new Stmt.DefineSort(getName(), parameters, expr));
+        }
+
+        private List<? extends Stmt> generateSubsetFunctions() {
+            List<Pair<String, String>> parameters = new ArrayList<Pair<String, String>>();
+            parameters.add(new Pair<String, String>("first", toString()));
+            parameters.add(new Pair<String, String>("second", toString()));
+
+            String subseteqExpr;
+            String subsetExpr;
+
+            // There is a bug here, I'm not 100% sure how to properly use the map function
+            /*case Z3:
+                    // Z3 supports the map function
+
+                    // SubsetEq can be seen as creating the union of A => B
+                    // This union should contain all elements, so if there exists an element that
+                    // isn't contained within it, then the subseqEq expression is false
+                    subseteqExpr = "(forall ((t " + type
+                            + ")) (contains ((_ map or) ((_ map not) first) second) t))";
+                    subsetExpr = "(and (subseteq first second) (distinct first second))";
+
+                    break;*/
+
+            subseteqExpr = "(forall ((t " + type
+            		+ ")) (=> (contains first t) (contains second t)))";
+            subsetExpr = "(and (subseteq first second) (distinct first second))";
+
+            List<Stmt> functions = new ArrayList<Stmt>();
+            functions.add(new Stmt.DefineFun(FUN_SUBSETEQ_NAME, parameters, BOOL.toString(),
+                    subseteqExpr));
+            functions.add(new Stmt.DefineFun(FUN_SUBSET_NAME, parameters, BOOL.toString(),
+                    subsetExpr));
+
+            return functions;
+        }
+
+        private List<? extends Stmt> generateSubsetLengthAssertions() {
+            List<Stmt> stmts = new ArrayList<Stmt>();
+
+            // If a set is a proper subset of another, then its length must be less than the other's
+            // length
+            stmts.add(new Stmt.Assert("(forall ((set0 " + toString() + ") (set1 " + toString()
+                    + ")) (=> (subset set0 set1) (< (length set0) (length set1))))"));
+            // If a set subsets another, then its length must be less than or equal to the other's
+            // length
+            stmts.add(new Stmt.Assert("(forall ((set0 " + toString() + ") (set1 " + toString()
+                    + ")) (=> (subseteq set0 set1) (<= (length set0) (length set1))))"));
+
+            return stmts;
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Tuple extends Sort {
+
+        public static final String FUN_GET_NAME = "get";
+
+        private final List<String> types;
+
+        public Tuple(String... types) {
+            this(Arrays.asList(types));
+        }
+
+        public Tuple(List<String> types) {
+            if (types.contains(null)) {
+                throw new NullPointerException("types cannot contain null");
+            }
+
+            this.types = Collections.unmodifiableList(new ArrayList<String>(types));
+        }
+
+        public static String generateGetFunctionName(int index) {
+            return FUN_GET_NAME + index;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+
+        public List<? extends Stmt> generateInitialisers() {
+            List<Stmt> initialisers = new ArrayList<Stmt>();
+
+            initialisers.addAll(generateSorts());
+            initialisers.addAll(generateGetFunctions());
+            initialisers.addAll(generateEqualityAssertions());
+
+            return initialisers;
+        }
+
+        /**
+         * Gets the name of this tuple sort. The name is equivalent to "Tuple" with the elements
+         * size appended.
+         * <p/>
+         * For the sort name to use in functions etc., use {@link #toString()}.
+         *
+         * @return the name of this tuple sort.
+         */
+        public String getName() {
+            return "Tuple" + types.size();
+        }
+
+        /**
+         * Gets the name of this particular tuple sort, with it's types. The whole name is
+         * surrounded by parenthesis.
+         */
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder("(");
+            sb.append(getName());
+            for (String type : types) {
+                sb.append(" ").append(type);
+            }
+            sb.append(")");
+
+            return sb.toString();
+        }
+
+        private List<? extends Stmt> generateEqualityAssertions() {
+            List<Stmt> stmts = new ArrayList<Stmt>();
+
+            // Two tuples are equal if and only if all of their elements are equal
+            StringBuilder premise = new StringBuilder("(and");
+            for (int i = 0; i < types.size(); i++) {
+                premise.append(" (= ");
+                premise.append("(");
+                premise.append(generateGetFunctionName(i));
+                premise.append(" tuple0");
+                premise.append(") ");
+                premise.append("(");
+                premise.append(generateGetFunctionName(i));
+                premise.append(" tuple1");
+                premise.append(")");
+                premise.append(")");
+            }
+            premise.append(")");
+            stmts.add(new Stmt.Assert(
+                    "(forall ((tuple0 " + toString() + ") (tuple1 " + toString() + ")) (xor "
+                            + premise + " (distinct tuple0 tuple1)))"));
+
+            return stmts;
+        }
+
+        private List<? extends Stmt> generateGetFunctions() {
+            List<Stmt> stmts = new ArrayList<Stmt>();
+
+            for (int i = 0; i < types.size(); i++) {
+                stmts.add(new Stmt.DeclareFun(generateGetFunctionName(i), Arrays.asList(toString()),
+                        types.get(i)));
+            }
+
+            return stmts;
+        }
+
+        private List<? extends Stmt> generateSorts() {
+            return Arrays.asList(new Stmt.DeclareSort(getName(), types.size()));
+        }
+    }
+}
diff --git a/modules/wycs/src/wycs/solver/smt/Stmt.java b/modules/wycs/src/wycs/solver/smt/Stmt.java
new file mode 100755
index 0000000000..ddcc61a56a
--- /dev/null
+++ b/modules/wycs/src/wycs/solver/smt/Stmt.java
@@ -0,0 +1,678 @@
+// Copyright (c) 2014, Henry J. Wylde (hjwylde@gmail.com)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.solver.smt;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+import wycc.util.Pair;
+
+/**
+ * A statement in the SMT-LIB v2 language specification. The statements here are useful for
+ * enforcing some structure on the generation of a {@link wycs.solver.smt.Smt2File}. Note that each
+ * statement generally only takes {@link java.lang.String}s as parameters, so it is up to the user
+ * of this class to ensure the arguments are well-formed.
+ *
+ * @author Henry J. Wylde
+ */
+public abstract class Stmt implements Element {
+
+    /**
+     * This class may only be instantiated locally.
+     */
+    Stmt() {}
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public abstract String toString();
+
+    /**
+     * Computes a hash code of the given objects. The hash code is just the integer exclusive-or
+     * operation on the hash code of all the objects.
+     *
+     * @param objects the objects to hash.
+     * @return the hash code.
+     */
+    private static int Objects_hash(Object... objects) {
+        int hash = 0;
+        for (Object obj : objects) {
+            hash ^= obj.hashCode();
+        }
+
+        return hash;
+    }
+
+    /**
+     * An assertion statement. Used to state facts and conjectures within the SMT file.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Assert extends Stmt {
+
+        private final String expr;
+
+        /**
+         * Creates a new {@code Assert} statement with the given expression.
+         *
+         * @param expr the expression.
+         */
+        public Assert(String expr) {
+            if (expr == null) {
+                throw new NullPointerException("expr cannot be null");
+            }
+
+            this.expr = expr;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+
+            return expr.equals(((Assert) obj).expr);
+        }
+
+        /**
+         * Gets the expression.
+         *
+         * @return the expression.
+         */
+        public String getExpr() {
+            return expr;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return expr.hashCode();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(assert " + expr + ")";
+        }
+    }
+
+    /**
+     * A check satisfiable statement. This statement makes the SMT solver check whether the current
+     * list of assertions is satisfiable. It's response is one of {@value
+     * wycs.solver.smt.Response#SAT}, {@value wycs.solver.smt.Response#UNSAT} or {@value
+     * wycs.solver.smt.Response#UNKNOWN}.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class CheckSat extends Stmt {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(check-sat)";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class DeclareFun extends Stmt {
+
+        private final String name;
+        private final List<String> parameterSorts;
+        private final String returnSort;
+
+        public DeclareFun(String name, List<String> parameterSorts, String returnSort) {
+            if (name == null) {
+                throw new NullPointerException("name cannot be null");
+            }
+            if (parameterSorts.contains(null)) {
+                throw new NullPointerException("parameterSorts cannot contain null");
+            }
+            if (returnSort == null) {
+                throw new NullPointerException("returnSort cannot be null");
+            }
+
+            this.name = name;
+            this.returnSort = returnSort;
+            this.parameterSorts = Collections.unmodifiableList(new ArrayList<String>(
+                    parameterSorts));
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+
+            DeclareFun that = (DeclareFun) obj;
+
+            if (!name.equals(that.name)) {
+                return false;
+            }
+            if (!parameterSorts.equals(that.parameterSorts)) {
+                return false;
+            }
+
+            return returnSort.equals(that.returnSort);
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public List<String> getParameterSorts() {
+            return parameterSorts;
+        }
+
+        public String getReturnSort() {
+            return returnSort;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return Objects_hash(name, parameterSorts, returnSort);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+
+            sb.append("(declare-fun ");
+            sb.append(name);
+            sb.append(" (");
+            for (Iterator<String> it = parameterSorts.iterator(); it.hasNext(); ) {
+                sb.append(it.next());
+
+                if (it.hasNext()) {
+                    sb.append(" ");
+                }
+            }
+            sb.append(") ");
+            sb.append(returnSort);
+            sb.append(")");
+
+            return sb.toString();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class DeclareSort extends Stmt {
+
+        private final String name;
+        private final int size;
+
+        public DeclareSort(String name, int size) {
+            if (name == null) {
+                throw new NullPointerException("name cannot be null");
+            }
+            if (size < 0) {
+                throw new IllegalArgumentException("size cannot be negative");
+            }
+
+            this.name = name;
+            this.size = size;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+
+            DeclareSort that = (DeclareSort) obj;
+
+            return name.equals(that.name) && size == that.size;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public int getSize() {
+            return size;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return Objects_hash(name, size);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(declare-sort " + name + " " + size + ")";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class DefineFun extends Stmt {
+
+        private final String name;
+        private final List<Pair<String, String>> parameters;
+        private final String returnSort;
+        private final String expr;
+
+        public DefineFun(String name, List<Pair<String, String>> parameters, String returnSort,
+                String expr) {
+            if (name == null) {
+                throw new NullPointerException("name cannot be null");
+            }
+            if (parameters.contains(null)) {
+                throw new NullPointerException("parameters cannot contain null");
+            }
+            if (returnSort == null) {
+                throw new NullPointerException("returnSort cannot be null");
+            }
+            if (expr == null) {
+                throw new NullPointerException("expr cannot be null");
+            }
+
+            this.name = name;
+            this.returnSort = returnSort;
+            this.parameters = Collections.unmodifiableList(new ArrayList<Pair<String, String>>(
+                    parameters));
+            this.expr = expr;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+
+            DefineFun that = (DefineFun) obj;
+
+            if (!name.equals(that.name)) {
+                return false;
+            }
+            if (!parameters.equals(that.parameters)) {
+                return false;
+            }
+
+            return returnSort.equals(that.returnSort);
+        }
+
+        public String getExpr() {
+            return expr;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public List<Pair<String, String>> getParameters() {
+            return parameters;
+        }
+
+        public String getReturnSort() {
+            return returnSort;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return Objects_hash(name, parameters, returnSort, expr);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+
+            sb.append("(define-fun ");
+            sb.append(name);
+            sb.append(" (");
+            for (Iterator<Pair<String, String>> it = parameters.iterator(); it.hasNext(); ) {
+                Pair<String, String> parameter = it.next();
+
+                sb.append("(");
+                sb.append(parameter.first());
+                sb.append(" ");
+                sb.append(parameter.second());
+                sb.append(")");
+
+                if (it.hasNext()) {
+                    sb.append(" ");
+                }
+            }
+            sb.append(") ");
+            sb.append(returnSort);
+            sb.append(" ");
+            sb.append(expr);
+            sb.append(")");
+
+            return sb.toString();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class DefineSort extends Stmt {
+
+        private final String name;
+        private final List<String> parameters;
+        private final String expr;
+
+        public DefineSort(String name, List<String> parameters, String expr) {
+            if (name == null) {
+                throw new NullPointerException("name cannot be null");
+            }
+            if (parameters.contains(null)) {
+                throw new NullPointerException("parameters cannot contain null");
+            }
+            if (expr == null) {
+                throw new NullPointerException("expr cannot be null");
+            }
+
+            this.name = name;
+            this.parameters = Collections.unmodifiableList(new ArrayList<String>(parameters));
+            this.expr = expr;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || getClass() != obj.getClass()) {
+                return false;
+            }
+
+            DefineSort that = (DefineSort) obj;
+
+            if (!name.equals(that.name)) {
+                return false;
+            }
+            if (!parameters.equals(that.parameters)) {
+                return false;
+            }
+
+            return expr.equals(that.expr);
+        }
+
+        public String getExpr() {
+            return expr;
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public List<String> getParameters() {
+            return parameters;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return Objects_hash(name, parameters, expr);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+
+            sb.append("(define-sort ");
+            sb.append(name);
+            sb.append(" (");
+            for (Iterator<String> it = parameters.iterator(); it.hasNext(); ) {
+                sb.append(it.next());
+
+                if (it.hasNext()) {
+                    sb.append(" ");
+                }
+            }
+            sb.append(") ");
+            sb.append(expr);
+            sb.append(")");
+
+            return sb.toString();
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Exit extends Stmt {
+
+        public boolean equals(Object obj) {
+            return obj instanceof Exit;
+        }
+
+        public int hashCode() {
+            return 0;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(exit)";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Pop extends Stmt {
+
+        private final int count;
+
+        public Pop(int count) {
+            if (count < 0) {
+                throw new IllegalArgumentException("count cannot be less than 0");
+            }
+
+            this.count = count;
+        }
+
+        public int getCount() {
+            return count;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(pop " + count + ")";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class Push extends Stmt {
+
+        private final int count;
+
+        public Push(int count) {
+            if (count < 0) {
+                throw new IllegalArgumentException("count cannot be less than 0");
+            }
+
+            this.count = count;
+        }
+
+        public int getCount() {
+            return count;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(push " + count + ")";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class SetLogic extends Stmt {
+
+        private final Logic logic;
+
+        public SetLogic(Logic logic) {
+            if (logic == null) {
+                throw new NullPointerException("logic cannot be null");
+            }
+
+            this.logic = logic;
+        }
+
+        public Logic getLogic() {
+            return logic;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(set-logic " + logic + ")";
+        }
+    }
+
+    /**
+     * TODO: Documentation.
+     *
+     * @author Henry J. Wylde
+     */
+    public static final class SetOption extends Stmt {
+
+        private final String option;
+        private final String value;
+
+        public SetOption(String option, String value) {
+            if (option == null) {
+                throw new NullPointerException("option cannot be null");
+            }
+            if (value == null) {
+                throw new NullPointerException("value cannot be null");
+            }
+
+            this.option = option;
+            this.value = value;
+        }
+
+        public String getOption() {
+            return option;
+        }
+
+        public String getValue() {
+            return value;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public String toString() {
+            return "(set-option " + option + " " + value + ")";
+        }
+    }
+}
diff --git a/modules/wycs/src/wycs/syntax/Expr.java b/modules/wycs/src/wycs/syntax/Expr.java
new file mode 100755
index 0000000000..f90277c594
--- /dev/null
+++ b/modules/wycs/src/wycs/syntax/Expr.java
@@ -0,0 +1,1263 @@
+package wycs.syntax;
+
+import java.util.*;
+
+import wycc.io.Token;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+import wycc.util.Triple;
+import wycs.core.Value;
+import wyfs.lang.Path;
+
+public abstract class Expr extends SyntacticElement.Impl implements SyntacticElement {
+
+	public Expr(Attribute... attributes) {
+		super(attributes);
+	}
+
+	public Expr(Collection<Attribute> attributes) {
+		super(attributes);
+	}
+
+	public abstract void freeVariables(Set<String> matches);
+
+	public abstract Expr instantiate(Map<String,SyntacticType> binding);
+
+	public abstract Expr substitute(Map<String,Expr> binding);
+
+	public abstract boolean equivalent(Expr e);
+	
+	public abstract Expr copy();
+	
+	// ==================================================================
+	// Classes
+	// ==================================================================
+
+	public static class Variable extends Expr {
+		public final String name;
+
+		public Variable(String name, Attribute... attributes) {
+			super(attributes);
+			if(!isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+		}
+
+		public Variable(String name, Collection<Attribute> attributes) {
+			super(attributes);
+			if(!isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			matches.add(name);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			return this;
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr r = binding.get(name);
+			if(r != null) {
+				// FIXME: should clone here!!!
+				return r;
+			} else {
+				return this;
+			}
+		}
+		
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Variable) {
+				Variable v = (Variable) e;
+				return name.equals(v.name);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public Expr.Variable copy() {
+			return new Expr.Variable(name,attributes());
+		}
+		
+		public String toString() {
+			return name;
+		}
+	}
+
+	public static class Constant extends Expr {
+		public final Value value;
+
+		public Constant(Value value, Attribute... attributes) {
+			super(attributes);
+			this.value = value;
+		}
+
+		public Constant(Value value, Collection<Attribute> attributes) {
+			super(attributes);
+			this.value = value;
+		}
+
+		public void freeVariables(Set<String> matches) {
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			return this;
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			return this;
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Constant) {
+				Constant c = (Constant) e;
+				return value.equals(c.value);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Constant copy() {
+			return new Expr.Constant(value,attributes());
+		}
+		
+		public String toString() {
+			return value.toString();
+		}
+	}
+
+	public static class ConstantAccess extends Expr {
+		public final String name;
+		public final Path.ID qualification;
+
+		public ConstantAccess(String name, Path.ID qualification, Attribute... attributes) {
+			super(attributes);
+			this.name = name;
+			this.qualification = qualification;
+		}
+
+		public ConstantAccess(String name, Path.ID qualification, Collection<Attribute> attributes) {
+			super(attributes);
+			this.name = name;
+			this.qualification = qualification;
+		}
+
+		public void freeVariables(Set<String> matches) {
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			return this;
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			return this;
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof ConstantAccess) {
+				ConstantAccess c = (ConstantAccess) e;
+				return name.equals(c.name);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.ConstantAccess copy() {
+			return new Expr.ConstantAccess(name,qualification,attributes());
+		}
+		
+		public String toString() {
+			return name;
+		}
+	}
+
+	public static class Unary extends Expr {
+		public enum Op {
+			NOT(0),
+			NEG(1),
+			LENGTHOF(2);
+
+			public int offset;
+
+			private Op(int offset) {
+				this.offset = offset;
+			}
+		}
+
+		public final Op op;
+		public Expr operand;
+
+		public Unary(Op op, Expr expr, Attribute... attributes) {
+			super(attributes);
+			this.op = op;
+			this.operand = expr;
+		}
+
+		public Unary(Op op, Expr expr, Collection<Attribute> attributes) {
+			super(attributes);
+			this.op = op;
+			this.operand = expr;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			operand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr expr = operand.instantiate(binding);
+			if(expr == operand) {
+				return this;
+			} else {
+				return new Expr.Unary(op, expr, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr expr = operand.substitute(binding);
+			if(expr == operand) {
+				return this;
+			} else {
+				return new Expr.Unary(op, expr, attributes());
+			}
+		}
+		
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Unary) {
+				Unary v = (Unary) e;
+				return op == v.op && operand.equivalent(v.operand);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Unary copy() {
+			return new Expr.Unary(op,operand.copy(),attributes());
+		}
+
+		public String toString() {
+			String o = operand.toString();
+			if(needsBraces(operand)) {
+				o = "(" + o + ")";
+			}
+			switch(this.op) {
+			case NOT:
+				return "!" + o;
+			case NEG:
+				return "-" + o;
+			case LENGTHOF:
+				return "|" + o + "|";
+			}
+			return null;
+		}
+	}
+
+	public static class Cast extends Expr {
+		public final SyntacticType type;
+		public Expr operand;
+
+		public Cast(SyntacticType type, Expr expr, Attribute... attributes) {
+			super(attributes);
+			this.type = type;
+			this.operand = expr;
+		}
+
+		public Cast(SyntacticType type, Expr expr, Collection<Attribute> attributes) {
+			super(attributes);
+			this.type = type;
+			this.operand = expr;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			operand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr expr = operand.instantiate(binding);
+			if(expr == operand) {
+				return this;
+			} else {
+				return new Expr.Cast(type, expr, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr expr = operand.substitute(binding);
+			if(expr == operand) {
+				return this;
+			} else {
+				return new Expr.Cast(type, expr, attributes());
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Cast) {
+				Cast v = (Cast) e;
+				return type.equivalent(v.type) && operand.equivalent(v.operand);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Cast copy() {
+			return new Expr.Cast(type.copy(),operand.copy(),attributes());
+		}
+		
+		public String toString() {
+			return "(" + type + ") " + operand;
+		}
+	}
+
+	public static class Binary extends Expr {
+		public enum Op {
+			ADD(1) {
+				public String toString() {
+					return "+";
+				}
+			},
+			SUB(2) {
+				public String toString() {
+					return "-";
+				}
+			},
+			MUL(3) {
+				public String toString() {
+					return "*";
+				}
+			},
+			DIV(4) {
+				public String toString() {
+					return "/";
+				}
+			},
+			REM(5) {
+				public String toString() {
+					return "%";
+				}
+			},
+			EQ(6) {
+				public String toString() {
+					return "==";
+				}
+			},
+			NEQ(7) {
+				public String toString() {
+					return "!=";
+				}
+			},
+			AND(8) {
+				public String toString() {
+					return "&&";
+				}
+			},
+			OR(9) {
+				public String toString() {
+					return "||";
+				}
+			},
+			IMPLIES(10) {
+				public String toString() {
+					return "==>";
+				}
+			},
+			IFF(11) {
+				public String toString() {
+					return "<==>";
+				}
+			},
+			LT(12) {
+				public String toString() {
+					return "<";
+				}
+			},
+			LTEQ(13) {
+				public String toString() {
+					//return Character.toString(Token.UC_LESSEQUALS);
+					return "<=";
+				}
+			},
+			GT(14) {
+				public String toString() {
+					return ">";
+				}
+			},
+			GTEQ(15) {
+				public String toString() {
+					//return Character.toString(Token.UC_GREATEREQUALS);
+					return ">=";
+				}
+			},
+			ARRAYGEN(16) {
+				public String toString() {
+					return "[]";
+				}
+			};
+
+			public int offset;
+
+			private Op(int offset) {
+				this.offset = offset;
+			}
+		};
+
+		public final Op op;
+		public Expr leftOperand;
+		public Expr rightOperand;
+
+		public Binary(Op op, Expr lhs, Expr rhs, Attribute... attributes) {
+			super(attributes);
+			if(lhs == null || rhs == null) {
+				throw new IllegalArgumentException("invalid left or right operand");
+			}
+			this.op = op;
+			this.leftOperand = lhs;
+			this.rightOperand = rhs;
+		}
+
+		public Binary(Op op, Expr lhs, Expr rhs, Collection<Attribute> attributes) {
+			super(attributes);
+			if(lhs == null || rhs == null) {
+				throw new IllegalArgumentException("invalid left or right operand");
+			}
+			this.op = op;
+			this.leftOperand = lhs;
+			this.rightOperand = rhs;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			leftOperand.freeVariables(matches);
+			rightOperand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr lhs = leftOperand.instantiate(binding);
+			Expr rhs = rightOperand.instantiate(binding);
+			if(lhs == leftOperand && rhs == rightOperand) {
+				return this;
+			} else {
+				return new Expr.Binary(op, lhs, rhs, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr lhs = leftOperand.substitute(binding);
+			Expr rhs = rightOperand.substitute(binding);
+			if(lhs == leftOperand && rhs == rightOperand) {
+				return this;
+			} else {
+				return new Expr.Binary(op, lhs, rhs, attributes());
+			}
+		}
+		
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Binary) {
+				Binary v = (Binary) e;
+				return op == v.op && leftOperand.equivalent(v.leftOperand)
+						&& rightOperand.equivalent(v.rightOperand);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Binary copy() {
+			return new Expr.Binary(op,leftOperand.copy(),rightOperand.copy(),attributes());
+		}
+
+		public String toString() {
+			String lhs = leftOperand.toString();
+			String rhs = rightOperand.toString();
+			if(needsBraces(leftOperand)) {
+				lhs = "(" + lhs + ")";
+			}
+			if(needsBraces(rightOperand)) {
+				rhs = "(" + rhs + ")";
+			}
+			return lhs + " " + op + " " + rhs;
+		}
+	}
+
+	public static class Nary extends Expr {
+		public enum Op {
+			TUPLE(0),
+			ARRAY(3);
+
+			public int offset;
+
+			private Op(int offset) {
+				this.offset = offset;
+			}
+		}
+
+		public final Op op;
+		public final ArrayList<Expr> operands;
+
+		public Nary(Op op, List<Expr> operands, Attribute... attributes) {
+			super(attributes);
+			this.op = op;
+			this.operands = new ArrayList<Expr>(operands);
+		}
+
+		public Nary(Op op, List<Expr> operands, Collection<Attribute> attributes) {
+			super(attributes);
+			this.op = op;
+			this.operands = new ArrayList<Expr>(operands);
+		}
+
+		public Nary(Op op, Expr[] operands, Attribute... attributes) {
+			super(attributes);
+			this.op = op;
+			this.operands = new ArrayList<Expr>();
+			for(int i=0;i!=operands.length;++i) {
+				this.operands.add(operands[i]);
+			}
+		}
+
+		public Nary(Op op, Expr[] operands, Collection<Attribute> attributes) {
+			super(attributes);
+			this.op = op;
+			this.operands = new ArrayList<Expr>();
+			for(int i=0;i!=operands.length;++i) {
+				this.operands.add(operands[i]);
+			}
+		}
+
+		public void freeVariables(Set<String> matches) {
+			for(Expr operand : operands) {
+				operand.freeVariables(matches);
+			}
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			ArrayList<Expr> r_operands = operands;
+			for(int i=0;i!=operands.size();++i) {
+				Expr o = operands.get(i);
+				Expr e = o.instantiate(binding);
+				if(e != o && r_operands == operands) {
+					r_operands = new ArrayList<Expr>(operands);
+				}
+				r_operands.set(i,e);
+			}
+			if(r_operands == operands) {
+				return this;
+			} else {
+				return new Expr.Nary(op, r_operands, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			ArrayList<Expr> r_operands = operands;
+			for(int i=0;i!=operands.size();++i) {
+				Expr o = operands.get(i);
+				Expr e = o.substitute(binding);
+				if(e != o && r_operands == operands) {
+					r_operands = new ArrayList<Expr>(operands);
+				}
+				r_operands.set(i,e);
+			}
+			if(r_operands == operands) {
+				return this;
+			} else {
+				return new Expr.Nary(op, r_operands, attributes());
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Nary) {
+				Nary v = (Nary) e;
+				if (operands.size() != v.operands.size()) {
+					return false;
+				}
+				for (int i = 0; i != operands.size(); ++i) {
+					if (!operands.get(i).equivalent(v.operands.get(i))) {
+						return false;
+					}
+				}
+				return op == v.op;
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public Expr.Nary copy() {
+			return new Expr.Nary(op, clone(operands), attributes());
+		}
+		
+		public String toString() {
+			String beg;
+			String end;
+			String sep;
+			switch(this.op) {
+			case ARRAY:
+				beg = "[";
+				end = "]";
+				sep = ", ";
+				break;
+			case TUPLE:
+				beg = "(";
+				end = ")";
+				sep = ", ";
+				break;
+			default:
+				return "";
+			}
+
+			String r = beg;
+			for(int i=0;i!=operands.size();++i) {
+				if(i != 0) {
+					r = r + sep;
+				}
+				String os = operands.get(i).toString();
+				if(needsBraces(operands.get(i))) {
+					r = r + "(" + operands.get(i).toString() + ")";
+				} else {
+					r = r + operands.get(i).toString();
+				}
+			}
+			return r + end;
+		}
+	}
+
+	public static class Record extends Expr {
+		public ArrayList<Pair<String,Expr>> operands;
+
+		public Record(List<Pair<String,Expr>> operands, Attribute... attributes) {
+			super(attributes);
+			this.operands = new ArrayList<Pair<String,Expr>>(operands);
+		}
+
+		public Record(List<Pair<String,Expr>> operands, Collection<Attribute> attributes) {
+			super(attributes);
+			this.operands = new ArrayList<Pair<String,Expr>>(operands);
+		}
+
+		public void freeVariables(Set<String> matches) {
+			for(Pair<String,Expr> p : operands) {
+				p.second().freeVariables(matches);
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Record) {
+				Record v = (Record) e;
+				if (operands.size() != v.operands.size()) {
+					return false;
+				}
+				for (int i = 0; i != operands.size(); ++i) {
+					Pair<String, Expr> operand = operands.get(i);
+					Pair<String, Expr> v_operand = v.operands.get(i);
+					if (!operand.first().equals(v_operand.first())
+							|| !operand.second().equivalent(v_operand.second())) {
+						return false;
+					}
+				}
+				return true;
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Record copy() {
+			ArrayList<Pair<String,Expr>> nOperands = new ArrayList<Pair<String,Expr>>();
+			for (int i = 0; i != operands.size(); ++i) {
+				Pair<String, Expr> operand = operands.get(i);
+				nOperands.add(new Pair<String,Expr>(operand.first(), operand.second()
+						.copy()));
+			}
+			return new Expr.Record(nOperands, attributes());
+		}
+		
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			// TODO
+			return null;
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			// TODO
+			return null;
+		}
+	}
+
+	public static class IndexOf extends Expr {
+		public Expr operand;
+		public Expr index;
+
+		public IndexOf(Expr expr, Expr index, Attribute... attributes) {
+			super(attributes);
+			this.operand = expr;
+			this.index = index;
+		}
+
+		public IndexOf(Expr expr, Expr index, Collection<Attribute> attributes) {
+			super(attributes);
+			this.index = index;
+			this.operand = expr;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			operand.freeVariables(matches);
+			index.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr nOperand = operand.instantiate(binding);
+			Expr nIndex = index.instantiate(binding);
+			if(nOperand == operand && nIndex == index) {
+				return this;
+			} else {
+				return new Expr.IndexOf(nOperand, nIndex, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr nOperand = operand.substitute(binding);
+			Expr nIndex = index.substitute(binding);
+			if(nOperand == operand && index == nIndex) {
+				return this;
+			} else {
+				return new Expr.IndexOf(nOperand, nIndex, attributes());
+			}
+		}
+		
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof IndexOf) {
+				IndexOf v = (IndexOf) e;
+				return operand.equivalent(v.operand)
+						&& index.equivalent(v.index);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public Expr.IndexOf copy() {
+			return new Expr.IndexOf(operand.copy(), index.copy(),
+					attributes());
+		}
+		
+		public String toString() {
+			return operand + "[" + index + "]";
+		}
+	}
+
+	public static class FieldAccess extends Expr {
+		public Expr operand;
+		public String name;
+
+		public FieldAccess(Expr expr, String name, Attribute... attributes) {
+			super(attributes);
+			this.operand = expr;
+			this.name = name;
+		}
+
+		public FieldAccess(Expr expr, String name, Collection<Attribute> attributes) {
+			super(attributes);
+			this.operand = expr;
+			this.name = name;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			operand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr nOperand = operand.instantiate(binding);
+			if(nOperand == operand) {
+				return this;
+			} else {
+				return new Expr.FieldAccess(nOperand, name, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr nOperand = operand.substitute(binding);
+			if(nOperand == operand) {
+				return this;
+			} else {
+				return new Expr.FieldAccess(nOperand, name, attributes());
+			}
+		}
+
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof FieldAccess) {
+				FieldAccess v = (FieldAccess) e;
+				return operand.equivalent(v.operand) && name.equals(v.name);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public Expr.FieldAccess copy() {
+			return new Expr.FieldAccess(operand.copy(), name, attributes());
+		}
+		
+		public String toString() {
+			return operand + "." + name;
+		}
+	}
+
+	public static class Invoke extends Expr {
+		public final ArrayList<SyntacticType> generics;
+		public final Expr operand;
+		public final String name;
+		public Path.ID qualification;
+
+		public Invoke(String name, Path.ID qualification,
+				List<SyntacticType> generics, Expr operand,
+				Attribute... attributes) {
+			super(attributes);
+			if (!isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: "
+						+ name);
+			}
+			this.name = name;
+			this.qualification = qualification;
+			this.generics = new ArrayList<SyntacticType>(generics);
+			this.operand = operand;
+		}
+
+		public Invoke(String name, Path.ID qualification,
+				List<SyntacticType> generics, Expr operand,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			if (!isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: "
+						+ name);
+			}
+			this.name = name;
+			this.qualification = qualification;
+			this.generics = new ArrayList<SyntacticType>(generics);
+			this.operand = operand;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			operand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr.Nary r_operand = (Expr.Nary) operand.instantiate(binding);
+			if(r_operand == operand) {
+				return this;
+			} else {
+				return new Expr.Invoke(name, qualification, generics, r_operand, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr.Nary r_operand = (Expr.Nary) operand.substitute(binding);
+			if(r_operand == operand) {
+				return this;
+			} else {
+				return new Expr.Invoke(name, qualification, generics, r_operand, attributes());
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Invoke) {
+				Invoke v = (Invoke) e;
+				if (qualification == v.qualification) {
+					// if null then don't need to do anything
+				} else if (qualification != null) {
+					// In this case, both are non-null;
+					if (!qualification.equals(v.qualification)) {
+						return false;
+					}
+				} else {
+					// in this case, qualification == null and v.qualification
+					// != null
+					return false;
+				}
+				// Qualitications are identical.
+				return name.equals(v.name) && equivalent(generics, v.generics)
+						&& operand.equivalent(v.operand);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.Invoke copy() {
+			return new Expr.Invoke(name, qualification, cloneTypes(generics),
+					operand.copy(), attributes());
+		}
+		
+		public String toString() {
+			String r = name;
+			if(generics.size() > 0) {
+				r = r + "<";
+				for(int i=0;i!=generics.size();++i) {
+					if(i != 0) { r += ", "; }
+					r += generics.get(i);
+				}
+				r = r + ">";
+			}
+			return r + operand;
+		}
+	}
+
+	public static class IndirectInvoke extends Expr {
+		public final ArrayList<SyntacticType> generics;
+		public final Expr operand;
+		public Expr source;
+
+		public IndirectInvoke(Expr source,
+				List<SyntacticType> generics, Expr operand,
+				Attribute... attributes) {
+			super(attributes);
+			this.source = source;
+			this.generics = new ArrayList<SyntacticType>(generics);
+			this.operand = operand;
+		}
+
+		public IndirectInvoke(Expr source,
+				List<SyntacticType> generics, Expr operand,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.source = source;
+			this.generics = new ArrayList<SyntacticType>(generics);
+			this.operand = operand;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			source.freeVariables(matches);
+			operand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String, SyntacticType> binding) {
+			Expr r_source = source.instantiate(binding);
+			Expr.Nary r_operand = (Expr.Nary) operand.instantiate(binding);
+			if (r_source == source && r_operand == operand) {
+				return this;
+			} else {
+				return new Expr.IndirectInvoke(r_source, generics, r_operand,
+						attributes());
+			}
+		}
+
+		public Expr substitute(Map<String, Expr> binding) {
+			Expr r_source = source.substitute(binding);
+			Expr.Nary r_operand = (Expr.Nary) operand.substitute(binding);
+			if (r_source == source && r_operand == operand) {
+				return this;
+			} else {
+				return new Expr.IndirectInvoke(r_source, generics, r_operand,
+						attributes());
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof IndirectInvoke) {
+				IndirectInvoke v = (IndirectInvoke) e;
+				// Qualitications are identical.
+				return equivalent(generics, v.generics)
+						&& source.equivalent(v.source)
+						&& operand.equivalent(v.operand);
+			} else {
+				return false;
+			}
+		}
+		
+		@Override
+		public Expr.IndirectInvoke copy() {
+			return new Expr.IndirectInvoke(source.copy(),
+					cloneTypes(generics), operand.copy(), attributes());
+		}
+		
+		public String toString() {
+			String r = source.toString();
+			if(generics.size() > 0) {
+				r = r + "<";
+				for(int i=0;i!=generics.size();++i) {
+					if(i != 0) { r += ", "; }
+					r += generics.get(i);
+				}
+				r = r + ">";
+			}
+			return r + operand;
+		}
+	}
+
+	public static class Is extends Expr {
+		
+		public Expr leftOperand;
+		public SyntacticType rightOperand;
+
+		public Is(Expr lhs, SyntacticType rhs, Attribute... attributes) {
+			super(attributes);
+			if(lhs == null || rhs == null) {
+				throw new IllegalArgumentException("invalid left or right operand");
+			}
+			this.leftOperand = lhs;
+			this.rightOperand = rhs;
+		}
+
+		public Is(Expr lhs, SyntacticType rhs, Collection<Attribute> attributes) {
+			super(attributes);
+			if(lhs == null || rhs == null) {
+				throw new IllegalArgumentException("invalid left or right operand");
+			}
+			this.leftOperand = lhs;
+			this.rightOperand = rhs;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			leftOperand.freeVariables(matches);
+		}
+
+		public Expr instantiate(Map<String,SyntacticType> binding) {
+			Expr lhs = leftOperand.instantiate(binding);
+			if(lhs == leftOperand) {
+				return this;
+			} else {
+				return new Expr.Is(lhs, rightOperand, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr lhs = leftOperand.substitute(binding);
+			if(lhs == leftOperand) {
+				return this;
+			} else {
+				return new Expr.Is(lhs, rightOperand, attributes());
+			}
+		}
+		
+		@Override
+		public boolean equivalent(Expr e) {
+			if (e instanceof Is) {
+				Is v = (Is) e;
+				return leftOperand.equivalent(v.leftOperand)
+						&& rightOperand.equivalent(v.rightOperand);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public Expr.Is copy() {
+			return new Expr.Is(leftOperand.copy(), rightOperand.copy(),
+					attributes());
+		}
+		
+		public String toString() {
+			String lhs = leftOperand.toString();
+			String rhs = rightOperand.toString();
+			if(needsBraces(leftOperand)) {
+				lhs = "(" + lhs + ")";
+			}			
+			return lhs + " is " + rhs;
+		}
+	}
+	public static abstract class Quantifier extends Expr {
+		public TypePattern pattern;
+		public Expr operand;
+
+		public Quantifier(TypePattern variable, Expr operand,
+				Attribute... attributes) {
+			super(attributes);
+			this.pattern = variable;
+			this.operand = operand;
+		}
+
+		public Quantifier(TypePattern variable, Expr operand, Collection<Attribute> attributes) {
+			super(attributes);
+			this.pattern = variable;
+			this.operand = operand;
+		}
+
+		public void freeVariables(Set<String> matches) {
+			HashSet<String> myVars = new HashSet<String>();
+			HashSet<String> declaredVars = new HashSet<String>();
+			operand.freeVariables(myVars);
+			pattern.addDeclaredVariables(declaredVars);
+			myVars.removeAll(declaredVars);
+			matches.addAll(myVars);
+		}
+
+		public Expr instantiate(Map<String, SyntacticType> binding) {
+			Expr op = operand.instantiate(binding);
+			TypePattern p = pattern.instantiate(binding);
+			if (op == operand && p == pattern) {
+				return this;
+			} else if (this instanceof ForAll) {
+				return new Expr.ForAll(p, op, attributes());
+			} else {
+				return new Expr.Exists(p, op, attributes());
+			}
+		}
+
+		public Expr substitute(Map<String,Expr> binding) {
+			Expr op = operand.substitute(binding);
+			if (op == operand) {
+				return this;
+			} else if (this instanceof ForAll) {
+				return new Expr.ForAll(pattern, op,
+						attributes());
+			} else {
+				return new Expr.Exists(pattern, op,
+						attributes());
+			}
+		}
+
+		@Override
+		public boolean equivalent(Expr e) {
+			if (getClass() == e.getClass()) {
+				Quantifier v = (Quantifier) e;
+				// Qualitications are identical.
+				return pattern.equivalent(v.pattern)
+						&& operand.equivalent(v.operand);
+			} else {
+				return false;
+			}
+		}
+		
+		public String toString() {
+			String r = "[ ";
+			boolean firstTime = true;
+			r = r + pattern.toString();
+			return r + " : " + operand + " ]";
+		}
+	}
+
+	public static class ForAll extends Quantifier {
+		public ForAll(TypePattern variable,
+				Expr expr, Attribute... attributes) {
+			super(variable, expr, attributes);
+		}
+
+		public ForAll(TypePattern variable,
+				Expr expr, Collection<Attribute> attributes) {
+			super(variable, expr, attributes);
+		}
+
+		@Override
+		public Expr.ForAll copy() {
+			return new Expr.ForAll(pattern.copy(),
+					operand.copy(), attributes());
+		}
+		
+		public String toString() {
+			return "all " + super.toString();
+		}				
+	}
+
+	public static class Exists extends Quantifier {
+		public Exists(TypePattern variable,
+				Expr expr, Attribute... attributes) {
+			super(variable, expr, attributes);
+		}
+
+		public Exists(TypePattern variable,
+				Expr expr, Collection<Attribute> attributes) {
+			super(variable, expr, attributes);
+		}
+
+		@Override
+		public Expr.Exists copy() {
+			return new Expr.Exists(pattern.copy(),
+					operand.copy(), attributes());
+		}
+		
+		public String toString() {
+			return "exists " + super.toString();
+		}
+	}
+
+	private static boolean needsBraces(Expr e) {
+		if (e instanceof Expr.Binary) {
+			 return true;
+		 } else if(e instanceof Quantifier) {
+			 return true;
+		 }
+		 return false;
+	}
+
+	public static boolean isValidIdentifier(String x) {
+		if (x.length() == 0) {
+			return false;
+		}
+		if (!isValidIdentifierStart(x.charAt(0))) {
+			return false;
+		}
+		for (int i = 1; i != x.length(); ++i) {
+			if (!isValidIdentifierPart(x.charAt(i))) {
+				return false;
+			}
+		}
+		return true;
+	}
+	
+	public static boolean isValidIdentifierStart(char c) {
+		return Character.isJavaIdentifierStart(c) || c == '$' || c == '%';
+	}
+	
+	public static boolean isValidIdentifierPart(char c) {
+		return Character.isJavaIdentifierPart(c) || c == '$' || c == '%';
+	}
+	
+	public static boolean equivalent(List<SyntacticType> l1, List<SyntacticType> l2) {
+		if(l1.size() != l2.size()) {
+			return false;
+		} else {
+			for(int i=0;i!=l1.size();++i) {
+				if(!l1.get(i).equivalent(l2.get(i))) {
+					return false;
+				}
+			}
+			return true;
+		}
+	}
+	
+	/**
+	 * Clone all expressions in a list.
+	 * 
+	 * @param expressions
+	 * @return
+	 */
+	public static List<Expr> clone(List<Expr> expressions) {
+		ArrayList<Expr> result = new ArrayList<Expr>();
+		for(int i=0;i!=expressions.size();++i) {
+			result.add(expressions.get(i).copy());
+		}
+		return result;
+	}
+	
+	/**
+	 * Clone all types in a list.
+	 * 
+	 * @param expressions
+	 * @return
+	 */
+	public static List<SyntacticType> cloneTypes(List<SyntacticType> expressions) {
+		ArrayList<SyntacticType> result = new ArrayList<SyntacticType>();
+		for(int i=0;i!=expressions.size();++i) {
+			result.add(expressions.get(i).copy());
+		}
+		return result;
+	}
+}
diff --git a/modules/wycs/src/wycs/syntax/SyntacticType.java b/modules/wycs/src/wycs/syntax/SyntacticType.java
new file mode 100755
index 0000000000..7ef19b4080
--- /dev/null
+++ b/modules/wycs/src/wycs/syntax/SyntacticType.java
@@ -0,0 +1,987 @@
+package wycs.syntax;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+import wycs.core.SemanticType;
+
+public interface SyntacticType extends SyntacticElement {
+
+	public abstract SyntacticType instantiate(java.util.Map<String,SyntacticType> binding);
+
+	public abstract boolean equivalent(SyntacticType t);
+	
+	public abstract SyntacticType copy();
+	
+	public static abstract class Primitive extends SyntacticElement.Impl
+			implements SyntacticType {
+
+		public Primitive(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Primitive(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			return this;
+		}		
+	}
+
+	/**
+	 * The type <code>any</code> represents the type whose variables may hold
+	 * any possible value. <b>NOTE:</b> the any type is top in the type lattice.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Any extends Primitive {
+		public Any(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Any(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Any;
+		}
+		@Override
+		public SyntacticType.Any copy() {
+			return new SyntacticType.Any(attributes());
+		}
+		public String toString() {
+			return "any";
+		}		
+	}
+
+	/**
+	 * A void type represents the type whose variables cannot exist! That is,
+	 * they cannot hold any possible value. Void is used to represent the return
+	 * type of a function which does not return anything. However, it is also
+	 * used to represent the element type of an empty list of set. <b>NOTE:</b>
+	 * the void type is a subtype of everything; that is, it is bottom in the
+	 * type lattice.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Void extends Primitive {
+		public Void(Attribute... attributes) {
+			super(attributes);
+		}
+		public Void(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Void;
+		}
+		@Override
+		public SyntacticType.Void copy() {
+			return new SyntacticType.Void(attributes());
+		}
+		public String toString() {
+			return "void";
+		}
+	}
+
+	/**
+	 * The null type is a special type which should be used to show the absence
+	 * of something. It is distinct from void, since variables can hold the
+	 * special <code>null</code> value (where as there is no special "void"
+	 * value). With all of the problems surrounding <code>null</code> and
+	 * <code>NullPointerException</code>s in languages like Java and C, it may
+	 * seem that this type should be avoided. However, it remains a very useful
+	 * abstraction to have around and, in Whiley, it is treated in a completely
+	 * safe manner (unlike e.g. Java).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Null extends Primitive {
+		public Null(Attribute... attributes) {
+			super(attributes);
+		}
+		public Null(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Null;
+		}
+		@Override
+		public SyntacticType.Null copy() {
+			return new SyntacticType.Null(attributes());
+		}
+		public String toString() {
+			return "null";
+		}
+	}
+
+	/**
+	 * Represents the set of boolean values (i.e. true and false)
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Bool extends Primitive {
+		public Bool(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Bool(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Bool;
+		}
+		@Override
+		public SyntacticType.Bool copy() {
+			return new SyntacticType.Bool(attributes());
+		}
+		public String toString() {
+			return "bool";
+		}
+	}
+
+	/**
+	 * Represents a sequence of 8 bits. Note that, unlike many languages, there
+	 * is no representation associated with a byte. For example, to extract an
+	 * integer value from a byte, it must be explicitly decoded according to
+	 * some representation (e.g. two's compliment) using an auxillary function
+	 * (e.g. <code>Byte.toInt()</code>).
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Byte extends Primitive {
+		public Byte(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Byte(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Byte;
+		}
+		@Override
+		public SyntacticType.Byte copy() {
+			return new SyntacticType.Byte(attributes());
+		}
+		public String toString() {
+			return "byte";
+		}
+	}
+
+	/**
+	 * Represents a unicode character.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Char extends Primitive {
+		public Char(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Char(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Char;
+		}
+		@Override
+		public SyntacticType.Char copy() {
+			return new SyntacticType.Char(attributes());
+		}
+		public String toString() {
+			return "char";
+		}
+	}
+
+	/**
+	 * Represents the set of (unbound) integer values. Since integer types in
+	 * Whiley are unbounded, there is no equivalent to Java's
+	 * <code>MIN_VALUE</code> and <code>MAX_VALUE</code> for <code>int</code>
+	 * types.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Int extends Primitive {
+		public Int(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Int(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Int;
+		}
+		@Override
+		public SyntacticType.Int copy() {
+			return new SyntacticType.Int(attributes());
+		}
+		public String toString() {
+			return "int";
+		}
+	}
+
+	/**
+	 * The type <code>real</code> represents the set of (unbound) rational
+	 * numbers.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Real extends Primitive {
+		public Real(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Real(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		public Real(java.util.List<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Real;
+		}
+		@Override
+		public SyntacticType.Real copy() {
+			return new SyntacticType.Real(attributes());
+		}
+		public String toString() {
+			return "real";
+		}
+	}
+
+	/**
+	 * The type <code>string</code> represents a string of characters
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static final class Strung extends Primitive {
+		public Strung(Attribute... attributes) {
+			super(attributes);
+		}
+
+		public Strung(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			return t instanceof Strung;
+		}
+		@Override
+		public SyntacticType.Strung copy() {
+			return new SyntacticType.Strung(attributes());
+		}
+		public String toString() {
+			return "string";
+		}
+	}
+
+	public static class Variable extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final String var;
+
+		public Variable(String var, Attribute... attributes) {
+			super(attributes);
+			this.var = var;
+		}
+
+		public Variable(String var, Collection<Attribute> attributes) {
+			super(attributes);
+			this.var = var;
+		}
+		
+		public String toString() {
+			return var;
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			SyntacticType t = binding.get(var);
+			if (var != null) {
+				return t;
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Variable) {
+				Variable tt = (Variable) t;
+				return var.equals(tt.var);
+			}
+			return false;
+		}
+		
+		@Override
+		public SyntacticType.Variable copy() {
+			return new SyntacticType.Variable(var,attributes());
+		}
+	}
+
+	/**
+	 * Parse a negation type, which is of the form:
+	 *
+	 * <pre>
+	 * ReferenceType ::= '!' Type
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class Negation extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final SyntacticType element;
+
+		public Negation(SyntacticType element, Attribute... attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		public Negation(SyntacticType element, Collection<Attribute> attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		public String toString() {
+			return "!(" + element + ")";
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			SyntacticType t = element.instantiate(binding);
+			if (t != element) {
+				return new Negation(t, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Negation) {
+				Negation tt = (Negation) t;
+				return element.equivalent(tt.element);
+			}
+			return false;
+		}
+		
+		@Override
+		public SyntacticType.Negation copy() {
+			return new SyntacticType.Negation(element.copy(),attributes());
+		}
+	}
+
+	/**
+	 * Parse a reference type, which is of the form:
+	 *
+	 * <pre>
+	 * ReferenceType ::= '&' Type
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class Reference extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final SyntacticType element;
+
+		public Reference(SyntacticType element, Attribute... attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		public Reference(SyntacticType element, Collection<Attribute> attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		public String toString() {
+			return "&" + element;
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			SyntacticType t = element.instantiate(binding);
+			if (t != element) {
+				return new Reference(t, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Reference) {
+				Reference tt = (Reference) t;
+				return element.equivalent(tt.element);
+			}
+			return false;
+		}
+		
+		@Override
+		public SyntacticType.Reference copy() {
+			return new SyntacticType.Reference(element.copy(),attributes());
+		}
+	}
+
+	/**
+	 * Parse a nominal type, which is of the form:
+	 *
+	 * <pre>
+	 * NominalType ::= Identifier
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class Nominal extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final ArrayList<String> names;
+
+		public Nominal(Collection<String> names, Attribute... attributes) {
+			super(attributes);
+			this.names = new ArrayList<String>(names);
+		}
+
+		public Nominal(Collection<String> names,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.names = new ArrayList<String>(names);
+		}
+
+		public String toString() {
+			String r = "";
+			for (int i = 0; i != names.size(); ++i) {
+				if (i != 0) {
+					r += ".";
+				}
+				r += names.get(i);
+			}
+			return r;
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			return this;
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Nominal) {
+				Nominal tt = (Nominal) t;
+				return names.equals(tt.names);
+			}
+			return false;
+		}
+		
+		@Override
+		public SyntacticType.Nominal copy() {
+			return new SyntacticType.Nominal((ArrayList<String>) names.clone(),attributes());
+		}
+	}
+
+	/**
+	 * Represents a union type, which is of the form:
+	 *
+	 * <pre>
+	 * UnionType ::= IntersectionType ('|' IntersectionType)*
+	 * </pre>
+	 *
+	 * Union types are used to compose types together. For example, the type
+	 * <code>int|null</code> represents the type which is either an
+	 * <code>int</code> or <code>null</code>.
+	 *
+	 * @return
+	 */
+	public static class Union extends SyntacticElement.Impl implements
+			SyntacticType {
+		public java.util.List<SyntacticType> elements;
+
+		public Union(Collection<SyntacticType> types, Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(types);
+		}
+
+		public Union(Collection<SyntacticType> types,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(types);
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			java.util.List<SyntacticType> nElements = elements;
+			for (int i = 0; i != nElements.size(); ++i) {
+				SyntacticType e = nElements.get(i);
+				SyntacticType t = e.instantiate(binding);
+				if (nElements != elements) {
+					nElements.set(i, t);
+				} else if (e != t) {
+					nElements = new ArrayList<SyntacticType>(elements);
+					nElements.set(i, t);
+				}
+			}
+			if (nElements != elements) {
+				return new Union(nElements, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Union) {
+				Union tt = (Union) t;
+				return Util.equivalent(elements, tt.elements);
+			}
+			return false;
+		}
+
+		@Override
+		public SyntacticType.Union copy() {
+			return new SyntacticType.Union(Util.clone(elements),attributes());
+		}
+		
+		public String toString() {
+			String s = "";
+			for (int i = 0; i != elements.size(); ++i) {
+				if (i != 0) {
+					s += " | ";
+				}
+				s += elements.get(i);
+			}
+			return s;
+		}
+	}
+
+	/**
+	 * Represents an intersection type, which is of the form:
+	 *
+	 * <pre>
+	 * IntersectionType ::= BaseType ('&' BaseType)*
+	 * </pre>
+	 *
+	 * Intersection types are used to unify types together. For example, the
+	 * type <code>{int x, int y}&MyType</code> represents the type which is both
+	 * an instanceof of <code>{int x, int y}</code> and an instance of
+	 * <code>MyType</code>.
+	 *
+	 * @return
+	 */
+	public static class Intersection extends SyntacticElement.Impl implements
+			SyntacticType {
+		public java.util.List<SyntacticType> elements;
+
+		public Intersection(Collection<SyntacticType> elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(elements);
+		}
+
+		public Intersection(Collection<SyntacticType> elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(elements);
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			java.util.List<SyntacticType> nElements = elements;
+			for (int i = 0; i != nElements.size(); ++i) {
+				SyntacticType e = nElements.get(i);
+				SyntacticType t = e.instantiate(binding);
+				if (nElements != elements) {
+					nElements.set(i, t);
+				} else if (e != t) {
+					nElements = new ArrayList<SyntacticType>(elements);
+					nElements.set(i, t);
+				}
+			}
+			if (nElements != elements) {
+				return new Intersection(nElements, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Intersection) {
+				Intersection tt = (Intersection) t;
+				return Util.equivalent(elements, tt.elements);
+			}
+			return false;
+		}
+
+		@Override
+		public SyntacticType.Intersection copy() {
+			return new SyntacticType.Intersection(Util.clone(elements),attributes());
+		}
+		
+		public String toString() {
+			String s = "";
+			for (int i = 0; i != elements.size(); ++i) {
+				if (i != 0) {
+					s += " & ";
+				}
+				s += elements.get(i);
+			}
+			return s;
+		}
+	}
+
+	/**
+	 * Represents a list type, which is of the form:
+	 *
+	 * <pre>
+	 * ListType ::= '[' Type ']'
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class List extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final SyntacticType element;
+
+		public List(SyntacticType element, Attribute... attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		public List(SyntacticType element, Collection<Attribute> attributes) {
+			super(attributes);
+			this.element = element;
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			SyntacticType t = element.instantiate(binding);
+			if (t != element) {
+				return new List(t, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof List) {
+				List tt = (List) t;
+				return element.equivalent(tt.element);
+			}
+			return false;
+		}
+
+		@Override
+		public SyntacticType.List copy() {
+			return new SyntacticType.List(element.copy(),attributes());
+		}
+		
+		public String toString() {
+			return "[" + element + "]";
+		}
+	}
+
+	/**
+	 * Parse a tuple type, which is of the form:
+	 *
+	 * <pre>
+	 * TupleType ::= '(' Type (',' Type)* ')'
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class Tuple extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final java.util.List<SyntacticType> elements;
+
+		public Tuple(Collection<SyntacticType> elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(elements);
+		}
+
+		public Tuple(Collection<SyntacticType> elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<SyntacticType>(elements);
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			java.util.List<SyntacticType> nElements = elements;
+			for (int i = 0; i != nElements.size(); ++i) {
+				SyntacticType e = nElements.get(i);
+				SyntacticType t = e.instantiate(binding);
+				if (nElements != elements) {
+					nElements.set(i, t);
+				} else if (e != t) {
+					nElements = new ArrayList<SyntacticType>(elements);
+					nElements.set(i, t);
+				}
+			}
+			if (nElements != elements) {
+				return new Tuple(nElements, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Tuple) {
+				Tuple tt = (Tuple) t;
+				return Util.equivalent(elements, tt.elements);
+			}
+			return false;
+		}
+
+		@Override
+		public SyntacticType.Tuple copy() {
+			return new SyntacticType.Tuple(Util.clone(elements),attributes());
+		}
+		
+		public String toString() {
+			String s = "";
+			for (int i = 0; i != elements.size(); ++i) {
+				if (i != 0) {
+					s += ", ";
+				}
+				s += elements.get(i);
+			}
+			return "(" + s + ")";
+		}
+	}
+
+	/**
+	 * Represents record type, which is of the form:
+	 *
+	 * <pre>
+	 * RecordType ::= '{' Type Identifier (',' Type Identifier)* [ ',' "..." ] '}'
+	 * </pre>
+	 *
+	 * @return
+	 */
+	public static class Record extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final java.util.List<Pair<SyntacticType, Expr.Variable>> elements;
+		public final boolean isOpen;
+
+		public Record(boolean isOpen,
+				Collection<Pair<SyntacticType, Expr.Variable>> elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.isOpen = isOpen;
+			this.elements = new ArrayList<Pair<SyntacticType, Expr.Variable>>(
+					elements);
+		}
+
+		public Record(boolean isOpen,
+				Collection<Pair<SyntacticType, Expr.Variable>> elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.isOpen = isOpen;
+			this.elements = new ArrayList<Pair<SyntacticType, Expr.Variable>>(
+					elements);
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+			java.util.List<Pair<SyntacticType, Expr.Variable>> nElements = elements;
+			for (int i = 0; i != nElements.size(); ++i) {
+				Pair<SyntacticType, Expr.Variable> e = nElements.get(i);
+				SyntacticType t = e.first().instantiate(binding);
+				if (nElements != elements) {
+					nElements.set(i, new Pair<SyntacticType, Expr.Variable>(t,
+							e.second()));
+				} else if (e.second() != t) {
+					nElements = new ArrayList<Pair<SyntacticType, Expr.Variable>>(
+							elements);
+					nElements.set(i, new Pair<SyntacticType, Expr.Variable>(t,
+							e.second()));
+				}
+			}
+			if (nElements != elements) {
+				return new Record(isOpen, nElements, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Record) {
+				Record tt = (Record) t;
+				if (elements.size() != tt.elements.size()) {
+					return false;
+				}
+				for (int i = 0; i != elements.size(); ++i) {
+					Pair<SyntacticType, Expr.Variable> p1 = elements.get(i);
+					Pair<SyntacticType, Expr.Variable> p2 = tt.elements.get(i);
+					if (!p1.first().equivalent(p2.first())
+							|| !p1.second().equivalent(p2.second())) {
+						return false;
+					}
+				}
+				return isOpen == tt.isOpen;
+			}
+			return false;
+		}
+
+		@Override
+		public SyntacticType.Record copy() {
+			ArrayList<Pair<SyntacticType, Expr.Variable>> nElements = new ArrayList<Pair<SyntacticType,Expr.Variable>>();
+			for (int i = 0; i != elements.size(); ++i) {
+				Pair<SyntacticType, Expr.Variable> e = elements.get(i);
+				nElements.add(new Pair<>(e.first().copy(),e.second().copy()));
+			}
+			return new SyntacticType.Record(isOpen,nElements,attributes());
+		}
+		
+		public String toString() {
+			String s = "";
+			for (int i = 0; i != elements.size(); ++i) {
+				if (i != 0) {
+					s += ", ";
+				}
+				s += elements.get(i);
+			}
+			return "(" + s + ")";
+		}
+	}
+
+	public static class Function extends SyntacticElement.Impl implements
+			SyntacticType {
+		public final SyntacticType ret;
+		public final SyntacticType throwType;
+		public final ArrayList<SyntacticType> paramTypes;
+
+		public Function(SyntacticType ret, SyntacticType throwType,
+				Collection<SyntacticType> paramTypes, Attribute... attributes) {
+			super(attributes);
+			this.ret = ret;
+			this.throwType = throwType;
+			this.paramTypes = new ArrayList<SyntacticType>(paramTypes);
+		}
+
+		public Function(SyntacticType ret, SyntacticType throwType,
+				Collection<SyntacticType> paramTypes,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.ret = ret;
+			this.throwType = throwType;
+			this.paramTypes = new ArrayList<SyntacticType>(paramTypes);
+		}
+
+		@Override
+		public SyntacticType instantiate(
+				java.util.Map<String, SyntacticType> binding) {
+
+			java.util.List<SyntacticType> nParamTypes = paramTypes;
+			SyntacticType nRet = ret.instantiate(binding);
+			SyntacticType nThrow = throwType.instantiate(binding);
+
+			for (int i = 0; i != nParamTypes.size(); ++i) {
+				SyntacticType e = nParamTypes.get(i);
+				SyntacticType t = e.instantiate(binding);
+				if (nParamTypes != paramTypes) {
+					nParamTypes.set(i, t);
+				} else if (e != t) {
+					nParamTypes = new ArrayList<SyntacticType>(paramTypes);
+					nParamTypes.set(i, t);
+				}
+			}
+			if (nParamTypes != paramTypes || nRet != ret || nThrow != throwType) {
+				return new Function(nRet, nThrow, nParamTypes, attributes());
+			} else {
+				return this;
+			}
+		}
+
+		@Override
+		public boolean equivalent(SyntacticType t) {
+			if (t instanceof Function) {
+				Function tt = (Function) t;
+				return ret.equivalent(tt.ret)
+						&& throwType.equivalent(tt.throwType)
+						&& Util.equivalent(paramTypes, tt.paramTypes);
+			}
+			return false;
+		}
+		
+		@Override
+		public SyntacticType.Function copy() {
+			return new SyntacticType.Function(ret.copy(), throwType.copy(),
+					Util.clone(paramTypes), attributes());
+		}
+	}
+
+	class Util {
+		public static boolean equivalent(java.util.List<SyntacticType> l1,
+				java.util.List<SyntacticType> l2) {
+			if (l1.size() != l2.size()) {
+				return false;
+			} else {
+				for (int i = 0; i != l1.size(); ++i) {
+					if (!l1.get(i).equivalent(l2.get(i))) {
+						return false;
+					}
+				}
+				return true;
+			}
+		}
+		
+		/**
+		 * Clone a list of syntactic types.
+		 * 
+		 * @param types
+		 * @return
+		 */
+		public static java.util.List<SyntacticType> clone(java.util.List<SyntacticType> types) {
+			ArrayList<SyntacticType> nTypes = new ArrayList<SyntacticType>();
+			for(int i=0;i!=types.size();++i) {
+				nTypes.add(types.get(i).copy());
+			}
+			return nTypes;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/syntax/TypeAttribute.java b/modules/wycs/src/wycs/syntax/TypeAttribute.java
new file mode 100755
index 0000000000..7ec1f19e67
--- /dev/null
+++ b/modules/wycs/src/wycs/syntax/TypeAttribute.java
@@ -0,0 +1,11 @@
+package wycs.syntax;
+
+import wycc.lang.Attribute;
+import wycs.core.SemanticType;
+
+public class TypeAttribute implements Attribute {
+	public final SemanticType type;
+	public TypeAttribute(SemanticType type) {
+		this.type = type;
+	}
+}
diff --git a/modules/wycs/src/wycs/syntax/TypePattern.java b/modules/wycs/src/wycs/syntax/TypePattern.java
new file mode 100755
index 0000000000..ed8140fcd3
--- /dev/null
+++ b/modules/wycs/src/wycs/syntax/TypePattern.java
@@ -0,0 +1,482 @@
+package wycs.syntax;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+import wycs.core.SemanticType;
+import wycs.syntax.SyntacticType.Tuple;
+import wycs.syntax.SyntacticType.Util;
+
+/**
+ * Represents a type pattern which is used for pattern matching.
+ *
+ * @author djp
+ *
+ */
+public abstract class TypePattern extends SyntacticElement.Impl {
+
+	// FIXME: at some point in the future, a type pattern should implement
+	// WycsFile.Context. This would improve error reporting, especially with
+	// constraints.
+
+	public TypePattern(Attribute... attributes) {
+		super(attributes);
+	}
+
+	public TypePattern(Collection<Attribute> attributes) {
+		super(attributes);
+	}
+
+	public abstract SyntacticType toSyntacticType();
+
+	public abstract TypePattern instantiate(Map<String,SyntacticType> binding);
+
+	public abstract void addDeclaredVariables(Collection<String> variables);
+
+	public abstract boolean equivalent(TypePattern p);
+	
+	public abstract TypePattern copy();
+	
+	/**
+	 * A type pattern leaf is simply a syntactic type, along with an optional
+	 * variable identifier.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Leaf extends TypePattern {
+		public final SyntacticType type;
+		public final Expr.Variable var;
+
+		public Leaf(SyntacticType type, Expr.Variable var, Attribute... attributes) {
+			super(attributes);
+			this.type = type;
+			this.var = var;
+		}
+
+		public Leaf(SyntacticType type, Expr.Variable var,Collection<Attribute> attributes) {
+			super(attributes);
+			this.type = type;
+			this.var = var;
+		}
+
+		public SyntacticType toSyntacticType() {
+			return type;
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			if(var != null) {
+				variables.add(var.name);
+			}
+		}
+
+		@Override
+		public TypePattern.Leaf instantiate(Map<String, SyntacticType> binding) {
+			return new TypePattern.Leaf(type.instantiate(binding), var,
+					attributes());
+		}
+		
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Leaf) {
+				Leaf tt = (Leaf) t;
+				return type.equivalent(tt.type)
+						&& (var == tt.var || (var != null && var
+								.equivalent(tt.var)));
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Leaf copy() {
+			Expr.Variable v = var != null ? var.copy() : null;
+			return new TypePattern.Leaf(type.copy(),v,attributes());
+		}
+		
+		public String toString() {
+			if(var != null) {
+				return type + " " + var.name;
+			} else {
+				return type.toString();
+			}
+		}
+	}
+
+	/**
+	 * A rational type pattern is simply a sequence of two type patterns
+	 * seperated by '/' separated by commas.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Rational extends TypePattern {
+		public final TypePattern numerator;
+		public final TypePattern denominator;
+
+		public Rational(TypePattern numerator, TypePattern denominator,
+				Attribute... attributes) {
+			super(attributes);
+			this.numerator = numerator;
+			this.denominator = denominator;
+		}
+
+		public Rational(TypePattern numerator, TypePattern denominator,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.numerator = numerator;
+			this.denominator = denominator;
+		}
+
+		public SyntacticType.Primitive toSyntacticType() {
+			return new SyntacticType.Real(attributes());
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			numerator.addDeclaredVariables(variables);
+			denominator.addDeclaredVariables(variables);
+		}
+
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Rational) {
+				Rational tt = (Rational) t;
+				return numerator.equivalent(tt.numerator)
+						&& denominator.equivalent(tt.denominator);
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Rational copy() {
+			return new TypePattern.Rational(numerator.copy(),
+					denominator.copy(), attributes());
+		}
+		
+		@Override
+		public TypePattern instantiate(Map<String, SyntacticType> binding) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+	}
+
+	/**
+	 * A type pattern tuple is simply a sequence of two or type patterns
+	 * separated by commas.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Tuple extends TypePattern {
+		public final List<TypePattern> elements;
+
+		public Tuple(List<TypePattern> elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public Tuple(List<TypePattern> elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public Tuple(TypePattern[] elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>();
+			for(TypePattern p : elements) {
+				this.elements.add(p);
+			}
+		}
+
+		public Tuple(TypePattern[] elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>();
+			for(TypePattern p : elements) {
+				this.elements.add(p);
+			}
+		}
+
+		public SyntacticType.Tuple toSyntacticType() {
+			ArrayList<SyntacticType> types = new ArrayList<SyntacticType>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).toSyntacticType());
+			}
+			return new SyntacticType.Tuple(types, attributes());
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			for(TypePattern p : elements) {
+				p.addDeclaredVariables(variables);
+			}
+		}
+
+		@Override
+		public TypePattern instantiate(Map<String, SyntacticType> binding) {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).instantiate(binding));
+			}
+			return new TypePattern.Tuple(types,attributes());
+		}
+
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Tuple) {
+				Tuple tt = (Tuple) t;
+				return equivalent(elements,tt.elements);
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Tuple copy() {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).copy());
+			}
+			return new TypePattern.Tuple(types,attributes());
+		}
+		
+		public String toString() {
+			String r = "";
+			boolean firstTime = true;
+			for(TypePattern p : elements) {
+				if(!firstTime) {
+					r = r + ", ";
+				}
+				r += p.toString();
+			}
+			return r;
+		}
+	}
+
+	/**
+	 * A record type pattern is simply a sequence of two or type patterns
+	 * separated by commas enclosed in curly braces.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Record extends TypePattern {
+		public final List<TypePattern.Leaf> elements;
+		public final boolean isOpen;
+
+		public Record(SyntacticType.Record record, Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern.Leaf>();
+			this.isOpen = record.isOpen;
+			for (Pair<SyntacticType, Expr.Variable> p : record.elements) {
+				elements.add(new TypePattern.Leaf(p.first(),p.second()));
+			}
+		}
+
+		public Record(List<TypePattern.Leaf> elements, boolean isOpen,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern.Leaf>(elements);
+			this.isOpen = isOpen;
+		}
+
+		public Record(List<TypePattern.Leaf> elements, boolean isOpen,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern.Leaf>(elements);
+			this.isOpen = isOpen;
+		}
+
+		public SyntacticType.Record toSyntacticType() {
+			ArrayList<Pair<SyntacticType, Expr.Variable>> types = new ArrayList<Pair<SyntacticType, Expr.Variable>>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern.Leaf tp = elements.get(i);
+				types.add(new Pair<SyntacticType,Expr.Variable>(tp
+						.toSyntacticType(), tp.var));
+			}
+			return new SyntacticType.Record(isOpen, types, attributes());
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			for(TypePattern p : elements) {
+				p.addDeclaredVariables(variables);
+			}
+		}
+
+		@Override
+		public TypePattern instantiate(Map<String, SyntacticType> binding) {
+			ArrayList<TypePattern.Leaf> types = new ArrayList<TypePattern.Leaf>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern.Leaf tp = elements.get(i);
+				types.add(tp.instantiate(binding));
+			}
+			return new TypePattern.Record(types, isOpen, attributes());		
+		}
+		
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Record) {
+				Record tt = (Record) t;
+				return equivalent(elements,tt.elements) && isOpen == tt.isOpen;
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Record copy() {
+			ArrayList<TypePattern.Leaf> types = new ArrayList<TypePattern.Leaf>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).copy());
+			}
+			return new TypePattern.Record(types,isOpen,attributes());
+		}
+	}
+
+	/**
+	 * A union type pattern is a sequence of type patterns separated by a
+	 * vertical bar ('|').
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Union extends TypePattern {
+		public final List<TypePattern> elements;
+
+		public Union(List<TypePattern> elements, Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public Union(List<TypePattern> elements, Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public SyntacticType.Union toSyntacticType() {
+			ArrayList<SyntacticType> types = new ArrayList<SyntacticType>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern tp = (TypePattern) elements.get(i);
+				types.add((SyntacticType) tp.toSyntacticType());
+			}
+			return new SyntacticType.Union(types, attributes());
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			// TODO: at some point, we can extend this further to look at the
+			// elements type we have and try to extract common variables.
+		}
+
+		@Override
+		public TypePattern.Union instantiate(Map<String, SyntacticType> binding) {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern tp = elements.get(i);
+				types.add(tp.instantiate(binding));
+			}
+			return new TypePattern.Union(types, attributes());
+		}
+		
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Union) {
+				Union tt = (Union) t;
+				return equivalent(elements,tt.elements);
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Union copy() {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).copy());
+			}
+			return new TypePattern.Union(types,attributes());
+		}
+	}
+
+	/**
+	 * An intersection type pattern is a sequence of type patterns separated by a
+	 * vertical bar ('&').
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Intersection extends TypePattern {
+		public final List<TypePattern> elements;
+
+		public Intersection(List<TypePattern> elements,
+				Attribute... attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public Intersection(List<TypePattern> elements,
+				Collection<Attribute> attributes) {
+			super(attributes);
+			this.elements = new ArrayList<TypePattern>(elements);
+		}
+
+		public SyntacticType.Intersection toSyntacticType() {
+			ArrayList<SyntacticType> types = new ArrayList<SyntacticType>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern tp = (TypePattern) elements.get(i);
+				types.add(tp.toSyntacticType());
+			}
+			return new SyntacticType.Intersection(types, attributes());
+		}
+
+		public void addDeclaredVariables(Collection<String> variables) {
+			// TODO: at some point, we can extend this further to look at the
+			// elements type we have and try to extract common variables.
+		}
+
+		@Override
+		public TypePattern.Intersection instantiate(Map<String, SyntacticType> binding) {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				TypePattern tp = elements.get(i);
+				types.add(tp.instantiate(binding));
+			}
+			return new TypePattern.Intersection(types, attributes());
+		}
+		
+		@Override
+		public boolean equivalent(TypePattern t) {
+			if (t instanceof Intersection) {
+				Intersection tt = (Intersection) t;
+				return equivalent(elements,tt.elements);
+			}
+			return false;
+		}
+		
+		@Override
+		public TypePattern.Intersection copy() {
+			ArrayList<TypePattern> types = new ArrayList<TypePattern>();
+			for (int i = 0; i != elements.size(); ++i) {
+				types.add(elements.get(i).copy());
+			}
+			return new TypePattern.Intersection(types,attributes());
+		}
+	}
+	
+	public static boolean equivalent(java.util.List<? extends TypePattern> l1,
+			java.util.List<? extends TypePattern> l2) {
+		if (l1.size() != l2.size()) {
+			return false;
+		} else {
+			for (int i = 0; i != l1.size(); ++i) {
+				if (!l1.get(i).equivalent(l2.get(i))) {
+					return false;
+				}
+			}
+			return true;
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/syntax/WyalFile.java b/modules/wycs/src/wycs/syntax/WyalFile.java
new file mode 100755
index 0000000000..132955d9f1
--- /dev/null
+++ b/modules/wycs/src/wycs/syntax/WyalFile.java
@@ -0,0 +1,331 @@
+package wycs.syntax;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.*;
+
+import wycc.lang.Attribute;
+import wycc.lang.CompilationUnit;
+import wycc.lang.SyntacticElement;
+import wycc.util.AbstractCompilationUnit;
+import wycs.io.*;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+
+public class WyalFile extends AbstractCompilationUnit {
+
+	// =========================================================================
+	// Content Type
+	// =========================================================================
+
+	public static final Content.Type<WyalFile> ContentType = new Content.Type<WyalFile>() {
+		public Path.Entry<WyalFile> accept(Path.Entry<?> e) {
+			if (e.contentType() == this) {
+				return (Path.Entry<WyalFile>) e;
+			}
+			return null;
+		}
+
+		public WyalFile read(Path.Entry<WyalFile> e, InputStream input) throws IOException {
+			WyalFileLexer lexer = new WyalFileLexer(e);
+			List<WyalFileLexer.Token> tokens;
+			tokens = lexer.scan();
+			WyalFileParser parser = new WyalFileParser(e,tokens);
+			return parser.read();
+		}
+
+		public void write(OutputStream output, WyalFile module) throws IOException {
+			//WycsFileClassicalPrinter writer = new WycsFileClassicalPrinter(output);
+			WyalFilePrinter writer = new WyalFilePrinter(output);
+			writer.write(module);
+		}
+
+		public String toString() {
+			return "Content-Type: wyal";
+		}
+	};
+
+	// =========================================================================
+	// State
+	// =========================================================================
+
+	private final ArrayList<Declaration> declarations;
+
+	// =========================================================================
+	// Constructors
+	// =========================================================================
+
+	public WyalFile(Path.Entry<WyalFile> entry) {
+		super(entry);
+		this.declarations = new ArrayList<Declaration>();
+	}
+
+	// =========================================================================
+	// Accessors
+	// =========================================================================
+
+	public Path.ID id() {
+		return entry.id();
+	}
+
+	public List<Declaration> declarations() {
+		return declarations;
+	}
+
+	public Declaration declaration(String name) {
+		for(Declaration d : declarations) {
+			if(d.name().equals(name)) {
+				return d;
+			}
+		}
+		return null;
+	}
+
+	public <T extends Declaration> T declaration(String name, Class<T> type) {
+		for (Declaration d : declarations) {
+			if (d.name().equals(name) && type.isInstance(d)) {
+				return (T) d;
+			}
+		}
+		return null;
+	}
+
+	// =========================================================================
+	// Mutators
+	// =========================================================================
+
+	public void add(Declaration d) {
+		declarations.add(d);
+	}
+
+	// =========================================================================
+	// Types
+	// =========================================================================
+
+	public interface Context extends SyntacticElement {
+		public WyalFile file();
+		public List<Import> imports();
+	}
+
+	public interface Declaration extends Context {
+		public String name();
+	}
+
+	public abstract class AbstractContext extends SyntacticElement.Impl implements Context {
+
+		protected AbstractContext(Attribute... attributes) {
+			super(attributes);
+		}
+
+		protected AbstractContext(Collection<Attribute> attributes) {
+			super(attributes);
+		}
+
+		public WyalFile file() {
+			return WyalFile.this;
+		}
+
+		/**
+		 * Construct an appropriate list of import statements for a declaration in a
+		 * given file. Thus, only import statements up to and including the given
+		 * declaration will be included in the returned list.
+		 *
+		 * @param wf
+		 *            --- Whiley File in question to obtain list of import
+		 *            statements.
+		 * @param decl
+		 *            --- declaration in Whiley File for which the list is desired.
+		 * @return
+		 */
+		public List<Import> imports() {
+			Path.ID id = entry.id();
+			// this computation could (should?) be cached.
+			ArrayList<Import> imports = new ArrayList<Import>();
+			imports.add(new WyalFile.Import(Trie.fromString(id.parent(), "*"), null));
+
+			for(Declaration d : declarations) {
+				if(d == this) {
+					break;
+				} else if(d instanceof Import) {
+					imports.add((Import)d);
+				}
+			}
+			imports.add(new WyalFile.Import(Trie.fromString(id), "*"));
+
+			Collections.reverse(imports);
+
+			return imports;
+		}
+	}
+
+	public class Function extends AbstractContext implements
+			Declaration {
+		public final String name;
+		public final ArrayList<String> generics;
+		public final TypePattern from;
+		public final TypePattern to;
+		public Expr constraint;
+
+		public Function(String name, List<String> generics, TypePattern from,
+				TypePattern to, Expr constraint, Attribute... attributes) {
+			super(attributes);
+			if(!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+			this.generics = new ArrayList<String>(generics);
+			this.from = from;
+			this.to = to;
+			this.constraint = constraint;
+		}
+
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+
+	public class Macro extends AbstractContext implements Declaration {
+		public final String name;
+		public final ArrayList<String> generics;
+		public final TypePattern from;
+		public Expr body;
+
+		public Macro(String name, List<String> generics, TypePattern parameter,
+				Expr body, Attribute... attributes) {
+			super(attributes);
+			if(!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+			this.generics = new ArrayList<String>(generics);
+			this.from = parameter;
+			this.body = body;
+		}
+
+		public Macro(String name, List<String> generics, TypePattern parameter, Expr body, List<Attribute> attributes) {
+			super(attributes);
+			if (!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+			this.generics = new ArrayList<String>(generics);
+			this.from = parameter;
+			this.body = body;
+		}
+		
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+
+	public class Type extends AbstractContext implements Declaration {
+		public final String name;
+		public final ArrayList<String> generics;
+		public final TypePattern type;
+		public Expr invariant;
+
+		public Type(String name, List<String> generics, TypePattern parameter,
+				Expr body, Attribute... attributes) {
+			super(attributes);
+			if(!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+			this.generics = new ArrayList<String>(generics);
+			this.type = parameter;
+			this.invariant = body;
+		}
+		
+		public Type(String name, List<String> generics, TypePattern parameter,
+				Expr body, Collection<Attribute> attributes) {
+			super(attributes);
+			if(!Expr.isValidIdentifier(name)) {
+				throw new IllegalArgumentException("illegal identifier: " + name);
+			}
+			this.name = name;
+			this.generics = new ArrayList<String>(generics);
+			this.type = parameter;
+			this.invariant = body;
+		}
+
+		@Override
+		public String name() {
+			return name;
+		}
+	}
+
+	public class Assert extends AbstractContext implements Declaration {
+		public final String message;
+		public Expr expr;
+
+		public Assert(String message, Expr expr, Attribute... attributes) {
+			super(attributes);
+			this.message = message;
+			this.expr = expr;
+		}
+
+		public Assert(String message, Expr expr, Collection<Attribute> attributes) {
+			super(attributes);
+			this.message = message;
+			this.expr = expr;
+		}
+
+		public String name() {
+			return ""; // anonymous
+		}
+	}
+
+	public class Assume extends AbstractContext implements Declaration {
+		public final String name;
+		public Expr expr;
+
+		public Assume(String message, Expr expr, Attribute... attributes) {
+			super(attributes);
+			this.name = message;
+			this.expr = expr;
+		}
+
+		public Assume(String message, Expr expr, Collection<Attribute> attributes) {
+			super(attributes);
+			this.name = message;
+			this.expr = expr;
+		}
+
+		public String name() {
+			return ""; // anonymous
+		}
+	}
+
+	/**
+	 * Represents an import declaration in a Wycs source file. For example:
+	 *
+	 * <pre>
+	 * import wycs.lang.Map
+	 * </pre>
+	 *
+	 * Here, the package is <code>wycs.lang</code>, and the module is
+	 * <code>Map</code>.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public class Import extends AbstractContext implements Declaration {
+		public final Trie filter;
+		public final String name;
+
+		public Import(Trie filter, String name, Attribute... attributes) {
+			super(attributes);
+			this.filter = filter;
+			this.name = name;
+		}
+
+		public String name() {
+			return ""; // anonymous
+		}
+	}
+
+}
diff --git a/modules/wycs/src/wycs/testing/TestHarness.java b/modules/wycs/src/wycs/testing/TestHarness.java
new file mode 100755
index 0000000000..95af005ca1
--- /dev/null
+++ b/modules/wycs/src/wycs/testing/TestHarness.java
@@ -0,0 +1,97 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.testing;
+
+import static org.junit.Assert.fail;
+
+import java.io.*;
+
+import wycs.WycsMain;
+import wycs.util.WycsBuildTask;
+
+public class TestHarness {
+	private String sourcepath;    // path to source files
+	private static String WYRT_PATH;
+
+	static {
+
+		// The purpose of this is to figure out what the proper name for the
+		// wyrt file is.
+
+		File file = new File("../../lib/");
+		for(String f : file.list()) {
+			if(f.startsWith("wyrt-v")) {
+				WYRT_PATH="../../lib/" + f;
+			}
+		}
+	}
+
+	/**
+	 * Construct a test harness object.
+	 *
+	 * @param srcPath
+	 *            The path to the source files to be tested
+	 */
+	public TestHarness(String srcPath) {
+		this.sourcepath = srcPath.replace('/', File.separatorChar);
+	}
+
+	protected void verifyPassTest(String name) {
+		// this will need to turn on verification at some point.
+		name = sourcepath + File.separatorChar + name + ".wyal";
+
+		try {
+			if (compile("-bp", WYRT_PATH,
+						"-wyaldir", sourcepath,
+						"-wycsdir", sourcepath,
+						name) != WycsMain.SUCCESS) {
+				fail("Test failed to verify!");
+			}
+		} catch(IOException e) {
+			fail("Test threw IOException");
+		}
+	}
+
+	protected void verifyFailTest(String name) {
+		// this will need to turn on verification at some point.
+		name = sourcepath + File.separatorChar + name + ".wyal";
+
+		try {
+			if (compile("-bp", WYRT_PATH, "-wyaldir", sourcepath, "-wycsdir",
+					sourcepath, name) != WycsMain.SYNTAX_ERROR) {
+				fail("Test verified when it shouldn't have!");
+			}
+		} catch(IOException e) {
+			fail("Test threw IOException");
+		}
+	}
+
+
+	private static int compile(String... args) throws IOException {
+		return new WycsMain(new WycsBuildTask(), WycsMain.DEFAULT_OPTIONS)
+				.run(args);
+	}
+}
diff --git a/modules/wycs/src/wycs/testing/tests/InvalidTests.java b/modules/wycs/src/wycs/testing/tests/InvalidTests.java
new file mode 100755
index 0000000000..248798b041
--- /dev/null
+++ b/modules/wycs/src/wycs/testing/tests/InvalidTests.java
@@ -0,0 +1,58 @@
+package wycs.testing.tests;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import wycs.testing.TestHarness;
+
+public class InvalidTests extends TestHarness {
+	public InvalidTests() {
+		 super("tests/invalid");
+	 }
+
+	@Test public void Test_Invalid_001() { verifyFailTest("test_001"); }
+	@Test public void Test_Invalid_002() { verifyFailTest("test_002"); }
+	@Test public void Test_Invalid_003() { verifyFailTest("test_003"); }
+	@Test public void Test_Invalid_004() { verifyFailTest("test_004"); }
+	@Test public void Test_Invalid_005() { verifyFailTest("test_005"); }
+	@Test public void Test_Invalid_006() { verifyFailTest("test_006"); }
+	@Test public void Test_Invalid_007() { verifyFailTest("test_007"); }
+	@Test public void Test_Invalid_008() { verifyFailTest("test_008"); }
+	@Test public void Test_Invalid_009() { verifyFailTest("test_009"); }
+	@Test public void Test_Invalid_010() { verifyFailTest("test_010"); }
+	@Test public void Test_Invalid_011() { verifyFailTest("test_011"); }
+	@Ignore("Known Issue")
+	@Test public void Test_Invalid_012() { verifyFailTest("test_012"); }
+	@Test public void Test_Invalid_013() { verifyFailTest("test_013"); }
+	@Test public void Test_Invalid_014() { verifyFailTest("test_014"); }
+	@Test public void Test_Invalid_015() { verifyFailTest("test_015"); }
+	@Test public void Test_Invalid_016() { verifyFailTest("test_016"); }
+	@Test public void Test_Invalid_017() { verifyFailTest("test_017"); }
+	@Test public void Test_Invalid_018() { verifyFailTest("test_018"); }
+	@Test public void Test_Invalid_019() { verifyFailTest("test_019"); }
+	@Test public void Test_Invalid_020() { verifyFailTest("test_020"); }
+
+	@Test public void Test_Invalid_050() { verifyFailTest("test_050"); }
+	@Test public void Test_Invalid_051() { verifyFailTest("test_051"); }
+	@Test public void Test_Invalid_052() { verifyFailTest("test_052"); }
+	@Test public void Test_Invalid_053() { verifyFailTest("test_053"); }
+	@Test public void Test_Invalid_054() { verifyFailTest("test_054"); }
+	@Test public void Test_Invalid_055() { verifyFailTest("test_055"); }
+	@Test public void Test_Invalid_056() { verifyFailTest("test_056"); }
+	@Test public void Test_Invalid_057() { verifyFailTest("test_057"); }
+	@Test public void Test_Invalid_058() { verifyFailTest("test_058"); }
+	@Test public void Test_Invalid_059() { verifyFailTest("test_059"); }
+	@Test public void Test_Invalid_060() { verifyFailTest("test_060"); }
+	@Test public void Test_Invalid_061() { verifyFailTest("test_061"); }
+	@Test public void Test_Invalid_062() { verifyFailTest("test_062"); }
+	@Test public void Test_Invalid_063() { verifyFailTest("test_063"); }
+	@Test public void Test_Invalid_064() { verifyFailTest("test_064"); }
+	@Test public void Test_Invalid_065() { verifyFailTest("test_065"); }
+	@Test public void Test_Invalid_066() { verifyFailTest("test_066"); }
+
+	@Test public void Test_Invalid_100() { verifyFailTest("test_100"); }
+	@Test public void Test_Invalid_101() { verifyFailTest("test_101"); }
+	@Test public void Test_Invalid_102() { verifyFailTest("test_102"); }
+	@Test public void Test_Invalid_103() { verifyFailTest("test_103"); }
+	@Test public void Test_Invalid_104() { verifyFailTest("test_104"); }
+}
diff --git a/modules/wycs/src/wycs/testing/tests/ValidTests.java b/modules/wycs/src/wycs/testing/tests/ValidTests.java
new file mode 100755
index 0000000000..8b97f3c57b
--- /dev/null
+++ b/modules/wycs/src/wycs/testing/tests/ValidTests.java
@@ -0,0 +1,134 @@
+package wycs.testing.tests;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import wycs.testing.TestHarness;
+
+public class ValidTests extends TestHarness {
+	public ValidTests() {
+		 super("tests/valid");
+	 }
+
+	@Test public void Test_Arith_1() { verifyPassTest("test_arith_01"); }
+	@Test public void Test_Arith_2() { verifyPassTest("test_arith_02"); }
+	@Test public void Test_Arith_3() { verifyPassTest("test_arith_03"); }
+	@Test public void Test_Arith_4() { verifyPassTest("test_arith_04"); }
+	@Test public void Test_Arith_5() { verifyPassTest("test_arith_05"); }
+	@Test public void Test_Arith_6() { verifyPassTest("test_arith_06"); }
+	@Test public void Test_Arith_7() { verifyPassTest("test_arith_07"); }
+	@Test public void Test_Arith_8() { verifyPassTest("test_arith_08"); }
+	@Test public void Test_Arith_9() { verifyPassTest("test_arith_09"); }
+	@Test public void Test_Arith_10() { verifyPassTest("test_arith_10"); }
+	@Test public void Test_Arith_11() { verifyPassTest("test_arith_11"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_12() { verifyPassTest("test_arith_12"); }
+	@Test public void Test_Arith_13() { verifyPassTest("test_arith_13"); }
+	@Test public void Test_Arith_14() { verifyPassTest("test_arith_14"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_15() { verifyPassTest("test_arith_15"); }
+	@Test public void Test_Arith_16() { verifyPassTest("test_arith_16"); }
+	@Test public void Test_Arith_17() { verifyPassTest("test_arith_17"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_18() { verifyPassTest("test_arith_18"); }
+	@Test public void Test_Arith_19() { verifyPassTest("test_arith_19"); }
+	@Test public void Test_Arith_20() { verifyPassTest("test_arith_20"); }
+	@Test public void Test_Arith_21() { verifyPassTest("test_arith_21"); }
+	@Test public void Test_Arith_22() { verifyPassTest("test_arith_22"); }
+	@Test public void Test_Arith_23() { verifyPassTest("test_arith_23"); }
+	@Test public void Test_Arith_24() { verifyPassTest("test_arith_24"); }
+	@Test public void Test_Arith_25() { verifyPassTest("test_arith_25"); }
+	@Test public void Test_Arith_26() { verifyPassTest("test_arith_26"); }
+	@Test public void Test_Arith_27() { verifyPassTest("test_arith_27"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_28() { verifyPassTest("test_arith_28"); }
+	@Test public void Test_Arith_29() { verifyPassTest("test_arith_29"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_30() { verifyPassTest("test_arith_30"); }
+	@Ignore("Known Issue") @Test public void Test_Arith_31() { verifyPassTest("test_arith_31"); }
+	@Test public void Test_Arith_32() { verifyPassTest("test_arith_32"); }
+	@Test public void Test_Arith_33() { verifyPassTest("test_arith_33"); }
+	@Test public void Test_Arith_34() { verifyPassTest("test_arith_34"); }
+	@Test public void Test_Arith_35() { verifyPassTest("test_arith_35"); }
+	@Test public void Test_Arith_36() { verifyPassTest("test_arith_36"); }
+	@Test public void Test_Arith_37() { verifyPassTest("test_arith_37"); }
+	@Test public void Test_Arith_38() { verifyPassTest("test_arith_38"); }
+	@Test public void Test_Arith_39() { verifyPassTest("test_arith_39"); }
+	
+	@Test public void Test_Macro_1() { verifyPassTest("test_macro_01"); }
+	@Test public void Test_Macro_2() { verifyPassTest("test_macro_02"); }
+	@Test public void Test_Macro_3() { verifyPassTest("test_macro_03"); }
+
+	@Test public void Test_Bool_1() { verifyPassTest("test_bool_01"); }
+
+	@Test public void Test_Fun_1() { verifyPassTest("test_fun_01"); }
+	@Test public void Test_Fun_2() { verifyPassTest("test_fun_02"); }
+
+
+	@Test public void Test_List_1() { verifyPassTest("test_list_01"); }
+	@Test public void Test_List_2() { verifyPassTest("test_list_02"); }
+	@Test public void Test_List_5() { verifyPassTest("test_list_05"); }
+	@Ignore("#303") @Test public void Test_List_6() { verifyPassTest("test_list_06"); }
+	@Test public void Test_List_8() { verifyPassTest("test_list_08"); }
+	@Test public void Test_List_13() { verifyPassTest("test_list_13"); }
+	@Test public void Test_List_14() { verifyPassTest("test_list_14"); }
+	@Ignore("#378") @Test public void Test_List_15() { verifyPassTest("test_list_15"); }
+	@Test public void Test_List_16() { verifyPassTest("test_list_16"); }
+	@Test public void Test_List_17() { verifyPassTest("test_list_17"); }
+	@Test public void Test_List_18() { verifyPassTest("test_list_18"); }
+	@Ignore("Unknown") @Test public void Test_List_19() { verifyPassTest("test_list_19"); }
+	@Test public void Test_List_20() { verifyPassTest("test_list_20"); }		
+	@Test public void Test_List_21() { verifyPassTest("test_list_21"); }	
+	@Ignore("#290") @Test public void Test_List_22() { verifyPassTest("test_list_22"); }	
+	@Ignore("#290") @Test public void Test_List_23() { verifyPassTest("test_list_23"); }	
+	@Test public void Test_List_24() { verifyPassTest("test_list_24"); }	
+	@Test public void Test_List_25() { verifyPassTest("test_list_25"); }	
+	@Ignore("Unknown") @Test public void Test_List_26() { verifyPassTest("test_list_26"); }	
+	@Test public void Test_List_27() { verifyPassTest("test_list_27"); }	
+	@Test public void Test_List_28() { verifyPassTest("test_list_28"); }	
+	@Test public void Test_List_29() { verifyPassTest("test_list_29"); }	
+	@Test public void Test_List_30() { verifyPassTest("test_list_30"); }	
+	@Test public void Test_List_31() { verifyPassTest("test_list_31"); }	
+	@Test public void Test_List_32() { verifyPassTest("test_list_32"); }	
+	@Test public void Test_List_33() { verifyPassTest("test_list_33"); }	
+	@Test public void Test_List_34() { verifyPassTest("test_list_34"); }	
+	@Test public void Test_List_35() { verifyPassTest("test_list_35"); }	
+	@Test public void Test_List_36() { verifyPassTest("test_list_36"); }	
+	@Test public void Test_List_37() { verifyPassTest("test_list_37"); }
+	@Ignore("#508") @Test public void Test_List_38() { verifyPassTest("test_list_38"); }
+	@Test public void Test_List_39() { verifyPassTest("test_list_39"); }
+	@Test public void Test_List_40() { verifyPassTest("test_list_40"); }
+	@Test public void Test_List_41() { verifyPassTest("test_list_41"); }
+	@Test public void Test_List_42() { verifyPassTest("test_list_42"); }
+	@Test public void Test_List_43() { verifyPassTest("test_list_43"); }
+	@Test public void Test_List_44() { verifyPassTest("test_list_44"); }
+	@Test public void Test_List_45() { verifyPassTest("test_list_45"); }
+	@Test public void Test_List_46() { verifyPassTest("test_list_46"); }
+	@Test public void Test_List_47() { verifyPassTest("test_list_47"); }
+	@Test public void Test_List_48() { verifyPassTest("test_list_48"); }
+	@Test public void Test_List_49() { verifyPassTest("test_list_49"); }
+	@Test public void Test_List_50() { verifyPassTest("test_list_50"); }
+	
+	@Test public void Test_Type_01() { verifyPassTest("test_type_01"); }
+	@Test public void Test_Type_02() { verifyPassTest("test_type_02"); }
+	@Test public void Test_Type_03() { verifyPassTest("test_type_03"); }
+	@Ignore("#468") @Test public void Test_Type_04() { verifyPassTest("test_type_04"); }
+	@Test public void Test_Type_05() { verifyPassTest("test_type_05"); }
+	@Ignore("#468") @Test public void Test_Type_06() { verifyPassTest("test_type_06"); }
+	@Test public void Test_Type_07() { verifyPassTest("test_type_07"); }
+	@Ignore("#468") @Test public void Test_Type_08() { verifyPassTest("test_type_08"); }
+	@Ignore("#468") @Test public void Test_Type_09() { verifyPassTest("test_type_09"); }
+	@Test public void Test_Type_10() { verifyPassTest("test_type_10"); }
+	@Ignore("#468") @Test public void Test_Type_11() { verifyPassTest("test_type_11"); }
+	@Ignore("#468") @Test public void Test_Type_12() { verifyPassTest("test_type_12"); }
+	@Ignore("#468") @Test public void Test_Type_13() { verifyPassTest("test_type_13"); }
+	@Ignore("#468") @Test public void Test_Type_14() { verifyPassTest("test_type_14"); }
+	@Ignore("#468") @Test public void Test_Type_15() { verifyPassTest("test_type_15"); }
+	@Ignore("#468") @Test public void Test_Type_16() { verifyPassTest("test_type_16"); }
+	@Ignore("#468") @Test public void Test_Type_17() { verifyPassTest("test_type_17"); }
+	@Ignore("#468") @Test public void Test_Type_18() { verifyPassTest("test_type_18"); }
+	@Ignore("#468") @Test public void Test_Type_19() { verifyPassTest("test_type_19"); }
+	@Ignore("#468") @Test public void Test_Type_20() { verifyPassTest("test_type_20"); }
+	@Ignore("#468") @Test public void Test_Type_21() { verifyPassTest("test_type_21"); }
+	@Test public void Test_Type_22() { verifyPassTest("test_type_22"); }
+	@Test public void Test_Type_23() { verifyPassTest("test_type_23"); }
+	@Test public void Test_Type_24() { verifyPassTest("test_type_24"); }
+	@Test public void Test_Type_25() { verifyPassTest("test_type_25"); }
+		
+	@Test public void Test_Tuple_1() { verifyPassTest("test_tuple_01"); }		
+}
diff --git a/modules/wycs/src/wycs/transforms/MacroExpansion.java b/modules/wycs/src/wycs/transforms/MacroExpansion.java
new file mode 100755
index 0000000000..5b5981e65f
--- /dev/null
+++ b/modules/wycs/src/wycs/transforms/MacroExpansion.java
@@ -0,0 +1,620 @@
+package wycs.transforms;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+
+import static wycc.lang.SyntaxError.*;
+import wybs.lang.Builder;
+import wycc.lang.Transform;
+import wycc.util.Pair;
+import wycs.builders.Wyal2WycsBuilder;
+import wycs.core.Code;
+import wycs.core.SemanticType;
+import wycs.core.WycsFile;
+
+/**
+ * Responsible for inlining <i>macros</i> (i.e. named expressions or types
+ * created with the <code>defined</code> statement). For example:
+ *
+ * <pre>
+ * define implies(bool x, bool y) as !x || y
+ * 
+ * assert:
+ *    implies(true,true)
+ * </pre>
+ *
+ * The <code>define</code> statement creates the typed macro
+ * <code>implies(bool,bool)->bool</code>. After macro expansion, we are left
+ * with the following:
+ *
+ * <pre>
+ * define implies(bool x, bool y) as !x || y
+ * 
+ * assert:
+ *    !true || true
+ * </pre>
+ *
+ * Here, we can see that the <code>implies</code> macro has simply been replaced
+ * by its definition, with its parameters substituted accordingly for its
+ * arguments. The purpose of this transform is simply to implement this
+ * expansion procedure.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class MacroExpansion implements Transform<WycsFile> {
+
+	/**
+	 * Determines whether macro inlining is enabled or not.
+	 */
+	private boolean enabled = getEnable();
+
+	private final Wyal2WycsBuilder builder;
+
+	private WycsFile file;
+
+	// ======================================================================
+	// Constructor(s)
+	// ======================================================================
+
+	public MacroExpansion(Builder builder) {
+		this.builder = (Wyal2WycsBuilder) builder;
+	}
+
+	// ======================================================================
+	// Configuration Methods
+	// ======================================================================
+
+	public static String describeEnable() {
+		return "Enable/disable constraint inlining";
+	}
+
+	public static boolean getEnable() {
+		return true; // default value
+	}
+
+	public void setEnable(boolean flag) {
+		this.enabled = flag;
+	}
+
+	// ======================================================================
+	// Apply Method
+	// ======================================================================
+
+	public void apply(WycsFile wf) {
+		if (enabled) {
+			this.file = wf;
+			for (WycsFile.Declaration s : wf.declarations()) {
+				transform(s);
+			}
+		}
+	}
+
+	private void transform(WycsFile.Declaration s) {
+		if (s instanceof WycsFile.Function) {
+			WycsFile.Function sf = (WycsFile.Function) s;
+			transform(sf);
+		} else if (s instanceof WycsFile.Macro) {
+			WycsFile.Macro sf = (WycsFile.Macro) s;
+			transform(sf);
+		} else if (s instanceof WycsFile.Type) {
+			transform((WycsFile.Type) s);
+		} else if (s instanceof WycsFile.Assert) {
+			transform((WycsFile.Assert) s);
+		} else {
+			throw new InternalFailure("unknown declaration encountered (" + s + ")",
+					file.getEntry(), s);
+		}
+	}
+
+	private void transform(WycsFile.Function s) {
+		if (s.constraint != null) {
+			HashSet<Code.Variable> environment = new HashSet<Code.Variable>();
+			s.constraint.getUsedVariables(environment);
+			s.constraint = transform(s.constraint,environment);
+		}
+	}
+
+	private void transform(WycsFile.Macro s) {
+		HashSet<Code.Variable> environment = new HashSet<Code.Variable>();
+		s.condition.getUsedVariables(environment);
+		s.condition = transform(s.condition,environment);
+	}
+
+	private void transform(WycsFile.Assert s) {
+		HashSet<Code.Variable> environment = new HashSet<Code.Variable>();
+		s.condition.getUsedVariables(environment);
+		s.condition = transform(s.condition,environment);
+	}
+
+	private void transform(WycsFile.Type s) {
+		if(s.invariant != null) {
+			HashSet<Code.Variable> environment = new HashSet<Code.Variable>();
+			s.invariant.getUsedVariables(environment);
+			s.invariant = transform(s.invariant,environment);
+		}
+	}
+
+	private Code<?> transform(Code<?> e, Set<Code.Variable> environment) {
+		if (e instanceof Code.Variable || e instanceof Code.Constant) {
+			// do nothing
+			return e;
+		} else if (e instanceof Code.Cast) {
+			return transform((Code.Cast) e, environment);
+		}  else if (e instanceof Code.Unary) {
+			return transform((Code.Unary) e, environment);
+		} else if (e instanceof Code.Binary) {
+			return transform((Code.Binary) e, environment);
+		} else if (e instanceof Code.Nary) {
+			return transform((Code.Nary) e, environment);
+		} else if (e instanceof Code.Load) {
+			return transform((Code.Load) e, environment);
+		} else if (e instanceof Code.IndexOf) {
+			return transform((Code.IndexOf) e, environment);
+		} else if (e instanceof Code.Is) {
+			return transform((Code.Is) e, environment);
+		} else if (e instanceof Code.FunCall) {
+			return transform((Code.FunCall) e, environment);
+		} else if (e instanceof Code.Quantifier) {
+			return transform((Code.Quantifier) e, environment);
+		} else {
+			throw new InternalFailure("invalid expression encountered (" + e + ", " + e.getClass().getName() + ")",
+					file.getEntry(), e);
+		}
+	}
+
+	private Code<?> transform(Code.Cast e, Set<Code.Variable> environment) {
+		return Code.Cast(e.type, transform(e.operands[0], environment), e.target, e.attributes());
+	}
+	
+	private Code<?> transform(Code.Unary e, Set<Code.Variable> environment) {
+		return Code.Unary(e.type, e.opcode, transform(e.operands[0], environment),
+				e.attributes());
+	}
+
+	private Code<?> transform(Code.Binary e, Set<Code.Variable> environment) {
+		return Code.Binary(e.type, e.opcode, transform(e.operands[0], environment),
+				transform(e.operands[1], environment), e.attributes());
+	}
+
+	private Code<?> transform(Code.Is e, Set<Code.Variable> environment) {
+		Code operand = transform(e.operands[0], environment);
+		// Expand the type to extract any constraints associated with nominal
+		// contained within. These will produce null if there are no such
+		// constraints. 
+		Pair<SemanticType, Code<?>> p1 = expand(operand, e.type, 0);
+		Pair<SemanticType, Code<?>> p2 = expand(operand, e.test, 0);
+		// Check whether any constraints were produced and, if so, include them.
+		Code result = Code.Is(p1.first(), operand, p2.first(), e.attributes());
+		if (p2.second() != null) {
+			// Yes, there were some constraints included in the nominal type.
+			return and(result, p2.second());
+		} else {
+			// No, there were no constraints included.
+			return result;
+		}
+	}
+	
+	private Code<?> transform(Code.Nary e, Set<Code.Variable> environment) {
+		Code<?>[] e_operands = e.operands;
+		Code<?>[] operands = new Code[e_operands.length];
+		for (int i = 0; i != e_operands.length; ++i) {
+			operands[i] = transform(e_operands[i], environment);
+		}
+		return Code.Nary(e.type, e.opcode, operands, e.attributes());
+	}
+
+	private Code<?> transform(Code.Load e, Set<Code.Variable> environment) {
+		return Code.Load(e.type, transform(e.operands[0], environment), e.index,
+				e.attributes());
+	}
+
+	private Code<?> transform(Code.IndexOf e, Set<Code.Variable> environment) {
+		return Code.IndexOf(e.type, transform(e.operands[0], environment),
+				transform(e.operands[1], environment), e.attributes());
+	}
+	
+	private Code<?> transform(Code.FunCall e, Set<Code.Variable> environment) {
+		Code<?> r = e;
+		try {
+			WycsFile module = builder.getModule(e.nid.module());
+			// In principle, module should not be null if TypePropagation has
+			// already passed. However, in the case of a function call inserted
+			// during code generation, there is no guarantee that it was
+			// previously resolved. This can cause problems if the standard
+			// library is not on the path as e.g. x[i] is translated into
+			// a call to wycs.core.Map.IndexOf().
+			if (module == null) {
+				throw new InternalFailure("cannot resolve as module: " + e.nid.module(),
+						file.getEntry(), e);
+			}
+			Object d = module.declaration(e.nid.name(),e.type);			
+			if (d instanceof WycsFile.Function) {
+				// Do nothing, since functions are not expanded like macros.
+				// Instead, their axioms may be instantiated later either before
+				// or during rewriting.
+			} else if (d instanceof WycsFile.Macro) {
+				WycsFile.Macro m = (WycsFile.Macro) d;
+				HashMap<String, SemanticType> generics = buildGenericBinding(m.type.generics(), e.binding);
+				Code m_body = applyCaptureAvoidanceBinding(m.condition, environment, new int[] { 0 });
+				HashMap<Integer,Code> binding = new HashMap<Integer,Code>();
+				binding.put(0, e.operands[0]);				
+				r = m_body.substitute(binding).instantiate(generics);
+			} else {
+				throw new InternalFailure("cannot resolve as function or macro call",
+						file.getEntry(), e);
+			}
+		} catch (InternalFailure ex) {
+			throw ex;
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), e, ex);
+		}
+
+		transform(e.operands[0], environment);
+		return r;
+	}
+
+	private HashMap<String, SemanticType> buildGenericBinding(
+			SemanticType[] from, SemanticType[] to) {
+		HashMap<String, SemanticType> binding = new HashMap<String, SemanticType>();
+		for (int i = 0; i != to.length; ++i) {
+			SemanticType.Var v = (SemanticType.Var) from[i];
+			binding.put(v.name(), to[i]);
+		}
+		return binding;
+	}
+	
+	/**
+	 * Build a binding for all variables in a given code which maps them to
+	 * known fresh variables in the environment. A list of optional ignores can
+	 * be given which are not considered in the binding.
+	 * 
+	 * @param environment
+	 * @param ignores
+	 * @return
+	 */
+	private Code applyCaptureAvoidanceBinding(Code e, Set<Code.Variable> environment, int... ignores) {
+		HashMap<Integer, Integer> binding = new HashMap<Integer, Integer>();
+		HashSet<Code.Variable> usedVariables = new HashSet<Code.Variable>();
+		e.getUsedVariables(usedVariables);
+		if (environment.size() != 0) {
+			// If the environment is empty, we can't use max()
+			int count = max(environment);
+			for (Code.Variable v : usedVariables) {
+				if(!isIgnored(v,ignores)) {				
+					binding.put(v.index, count++);
+				}
+			}
+		}
+
+		return e.rebind(binding);
+	}
+
+	private boolean isIgnored(Code.Variable v, int... ignores) {
+		for(int i = 0; i != ignores.length;++i) {
+			if(v.index == ignores[i]) {
+				return true;
+			}
+		}
+		return false;
+	}
+	
+	private Code<?> transform(Code.Quantifier e, Set<Code.Variable> environment) {
+		// Need to expand type constraints
+		Pair<SemanticType, Integer>[] e_types = e.types;
+		Pair<SemanticType, Integer>[] n_types = new Pair[e_types.length];
+		Code<?> invariant = null;
+		for (int i = 0; i != e_types.length; ++i) {
+			Pair<SemanticType, Integer> p1 = e_types[i];
+			Code.Variable var = Code.Variable(p1.first(), p1.second());
+			Pair<SemanticType,Code<?>> p2 = expand(var, p1.first(), 0);
+			n_types[i] = new Pair<SemanticType,Integer>(p2.first(),p1.second());
+			Code<?> ei = p2.second();			
+			if (ei != null) {
+				invariant = invariant == null ? ei : and(invariant, ei);
+			}
+		}
+		Code<?> body = transform(e.operands[0], environment);
+		if (invariant != null) {
+			// We need to treat universal and existential quantifiers
+			// differently.
+			if(e.opcode == Code.Op.EXISTS) {
+				body = and(invariant, body);
+			} else {
+				body = implies(invariant, body);
+			}
+		}
+		return Code.Quantifier(e.type, e.opcode, body, n_types, e.attributes());
+	}
+
+	/**
+	 * Expand a given type into a predicate which must be true for variables of
+	 * that type. In many cases, this is just "true". However, for type
+	 * invariants, this yields the invariant. For example:
+	 * 
+	 * <pre>
+	 * type nat is (int x) where:
+	 *    x >= 0
+	 * </pre>
+	 * 
+	 * For variables of type <code>nat</code> the return predicate will be
+	 * <code>x >= 0</code>. In the case of no invariant being given, this method
+	 * will return null. This is a simplification to avoid unnecessary checks
+	 * being written into the bytecode further upstream.
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable            
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType type, int freeVar) {
+		if (type instanceof SemanticType.Atom || type instanceof SemanticType.Var) {
+			return new Pair<SemanticType,Code<?>>(type,null);
+		} else if (type instanceof SemanticType.Tuple) {
+			return expand(root, (SemanticType.Tuple) type, freeVar);
+		} else if (type instanceof SemanticType.Array) {
+			return expand(root, (SemanticType.Array) type, freeVar);
+		} else if (type instanceof SemanticType.Nominal) {
+			return expand(root, (SemanticType.Nominal) type, freeVar);			
+		} else if(type instanceof SemanticType.Not) {
+			return expand(root, (SemanticType.Not) type, freeVar);
+		} else if(type instanceof SemanticType.And) {
+			return expand(root, (SemanticType.And) type, freeVar);
+		} else if(type instanceof SemanticType.Or) {
+			return expand(root, (SemanticType.Or) type, freeVar);
+		} else {
+			throw new InternalFailure("deadcode reached (" + type.getClass().getName() + ")", file.getEntry(), root);
+		}
+	}
+
+	/**
+	 * Expand a given tuple type into an invariant or null (if none exists).
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType.Tuple type, int freeVar) {
+		SemanticType[] elements = type.elements();
+		SemanticType[] nelements = new SemanticType[elements.length];
+		Code<?> invariant = null;
+		// Go through each type element expanding its invariants. In the end, if
+		// no elements expand to an invariant then we stick with null.
+		// Otherwise, we have some invariant at the end.
+		for (int i = 0; i != elements.length; ++i) {
+			Code<?> ri = Code.Load(type, root, i);
+			Pair<SemanticType,Code<?>> p = expand(ri, elements[i], freeVar);
+			Code<?> ei = p.second();
+			nelements[i] = p.first();
+			if (ei != null) {
+				// This element has yielded an actual invariant. Now, decide
+				// whether this it the first one, or just another one.
+				if (invariant == null) {
+					// Yes, it's the first element which has given an invariant,
+					// therefore it is the current overall invariant.
+					invariant = ei;
+				} else {
+					// No, this is just another element which has given an
+					// invariant, therefore just and them together.
+					invariant = and(invariant, ei);
+				}
+			}
+		}
+		return new Pair<SemanticType,Code<?>>(SemanticType.Tuple(nelements),invariant);
+	}
+	
+	/**
+	 * Expand a given array type into an invariant or null (if none exists). If an
+	 * invariant is generated from the element, this will be generalised to all
+	 * elements of the set using a universal quantifier.
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType, Code<?>> expand(Code<?> root,
+			SemanticType.Array type, int freeVar) {
+		Code.Variable variable = Code.Variable(type.element(), freeVar);		
+		Pair<SemanticType, Code<?>> p = expand(variable, type.element(),
+				++freeVar);
+		SemanticType.Array nType = SemanticType.Array(p.first());
+		Code<?> invariant = p.second();
+		if (invariant != null) {
+			Code<?> indexOf = Code.IndexOf(nType, variable, root);
+			HashMap<Integer, Code> binding = new HashMap<Integer, Code>();
+			binding.put(variable.index, indexOf);
+			invariant = invariant.substitute(binding);
+			invariant = Code.Quantifier(SemanticType.Bool, Code.Op.FORALL,
+					invariant,
+					new Pair[] { new Pair<SemanticType, Integer>(p.first(),
+							variable.index) });
+		}
+		return new Pair<SemanticType, Code<?>>(nType, invariant);
+	}
+	
+	/**
+	 * Expand a given nominal type into an invariant or null (if none exists). 
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType.Nominal type, int freeVar) {
+		try {
+			WycsFile wf = builder.getModule(type.name().module());
+			WycsFile.Type td = wf.declaration(type.name().name(),
+					WycsFile.Type.class);
+			Pair<SemanticType,Code<?>> p = expand(root, td.type, freeVar);
+			Code<?> invariant = p.second();
+			Code<?> td_invariant = td.invariant;
+			if (td_invariant != null) {
+				// An explicit invariant is given. We now need to map the given
+				// root to the parameter of the invariant (which is always at
+				// index 0).
+				HashMap<Integer,Code> binding = new HashMap<Integer,Code>();
+				binding.put(0,root);
+				td_invariant = td_invariant.substitute(binding);
+				// Finally, decide whether to use as is or append to the
+				// invariant generated from the element type.
+				if (invariant == null) {
+					invariant = td_invariant;
+				} else {
+					invariant = and(invariant, td_invariant);
+				}
+			}
+			return new Pair<SemanticType,Code<?>>(p.first(),invariant);
+		} catch (Exception e) {
+			throw new InternalFailure(e.getMessage(), file.getEntry(), root, e);
+		}
+	}
+	
+	/**
+	 * Expand a given negation type into an invariant or null (if none exists).
+	 * If an invariant is generated from the element, this will be required to
+	 * fail (i.e. rather than suceeding).
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType.Not type, int freeVar) {
+		Code.Variable variable = Code.Variable(type.element(), freeVar);
+		Pair<SemanticType,Code<?>> p = expand(variable, type.element(), freeVar++);
+		Code<?> invariant = p.second();
+		if (invariant != null) {
+			invariant = Code.Unary(SemanticType.Bool, Code.Unary.Op.NOT, invariant);			
+		}
+		return new Pair<SemanticType,Code<?>>(SemanticType.Not(p.first()),invariant);
+	}
+	
+	/**
+	 * Expand a given intersection type into an invariant or null (if none exists).
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType.And type, int freeVar) {
+		SemanticType[] elements = type.elements();
+		SemanticType[] nelements = new SemanticType[elements.length];
+		Code<?> invariant = null;
+		// Go through each type element expanding its invariants. In the end, if
+		// no elements expand to an invariant then we stick with null.
+		// Otherwise, we have some invariant at the end.
+		for (int i = 0; i != elements.length; ++i) {
+			Pair<SemanticType,Code<?>> p = expand(root, elements[i], freeVar);
+			nelements[i] = p.first();
+			Code<?> ei = p.second();
+			if (ei != null) {
+				// This element has yielded an actual invariant. Now, decide
+				// whether this it the first one, or just another one.
+				if (invariant == null) {
+					// Yes, it's the first element which has given an invariant,
+					// therefore it is the current overall invariant.
+					invariant = ei;
+				} else {
+					// No, this is just another element which has given an
+					// invariant, therefore just and them together.
+					invariant = and(invariant, ei);
+				}
+			}
+		}
+		return new Pair<SemanticType,Code<?>>(SemanticType.And(nelements),invariant);
+	}
+	
+	/**
+	 * Expand a given union type into an invariant or null (if none exists).
+	 * 
+	 * @param root
+	 *            --- The root expression (e.g. the variable being constrained).
+	 * @param type
+	 *            --- the type being expanded
+	 * @param freeVar
+	 *            --- the next available free variable
+	 * @return An expression representing the expanded invariant of this type,
+	 *         or null if no such invariant exists.
+	 */
+	private Pair<SemanticType,Code<?>> expand(Code<?> root, SemanticType.Or type, int freeVar) {
+		SemanticType[] elements = type.elements();
+		SemanticType[] nelements = new SemanticType[elements.length];
+		Code<?> invariant = null;
+		// Go through each type element expanding its invariants. In the end, if
+		// no elements expand to an invariant then we stick with null.
+		// Otherwise, we have some invariant at the end.
+		for (int i = 0; i != elements.length; ++i) {
+			Pair<SemanticType, Code<?>> p = expand(root, elements[i], freeVar);
+			nelements[i] = p.first();
+			Code<?> ei = p.second();
+			if (ei != null) {
+				// This element has yielded an actual invariant. The first thing
+				// is to add the test that this is the given type.
+				ei = implies(Code.Is(type, root, p.first()),ei);
+				// Now, decide whether this it the first one, or just another
+				// one.
+				if (invariant == null) {
+					// Yes, it's the first element which has given an invariant,
+					// therefore it is the current overall invariant.
+					invariant = ei;
+				} else {
+					// No, this is just another element which has given an
+					// invariant, therefore just and them together.
+					invariant = or(invariant, ei);
+				}
+			}
+		}
+		return new Pair<SemanticType,Code<?>>(SemanticType.Or(nelements),invariant);
+	}
+	
+	private static Code<?> implies(Code<?> lhs, Code<?> rhs) {
+		lhs = Code.Unary(SemanticType.Bool, Code.Unary.Op.NOT, lhs);
+		return Code.Nary(SemanticType.Bool, Code.Op.OR, new Code[] { lhs, rhs });
+	}
+	
+	private static Code<?> and(Code<?> lhs, Code<?> rhs) {
+		return Code.Nary(SemanticType.Bool, Code.Op.AND, new Code[] { lhs, rhs });
+	}
+	
+	private static Code<?> or(Code<?> lhs, Code<?> rhs) {
+		return Code.Nary(SemanticType.Bool, Code.Op.OR, new Code[] { lhs, rhs });
+	}
+	
+	private static int max(Set<Code.Variable> variables) {
+		int max = variables.iterator().next().index;
+		for(Code.Variable v : variables) {
+			max = Math.max(max,v.index);
+		}
+		return max;
+	}
+}
diff --git a/modules/wycs/src/wycs/transforms/TypePropagation.java b/modules/wycs/src/wycs/transforms/TypePropagation.java
new file mode 100755
index 0000000000..3120129a73
--- /dev/null
+++ b/modules/wycs/src/wycs/transforms/TypePropagation.java
@@ -0,0 +1,691 @@
+package wycs.transforms;
+
+import java.util.*;
+
+import static wycc.lang.SyntaxError.*;
+import wybs.lang.Builder;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
+import wycs.builders.Wyal2WycsBuilder;
+import wycs.core.SemanticType;
+import wycs.core.Value;
+import wycs.syntax.*;
+import wyfs.lang.Path;
+
+public class TypePropagation implements Transform<WyalFile> {
+
+	/**
+	 * Determines whether type propagation is enabled or not.
+	 */
+	private boolean enabled = getEnable();
+
+	private final Wyal2WycsBuilder builder;
+
+	private WyalFile file;
+
+	// ======================================================================
+	// Constructor(s)
+	// ======================================================================
+
+	public TypePropagation(Builder builder) {
+		this.builder = (Wyal2WycsBuilder) builder;
+	}
+
+	// ======================================================================
+	// Configuration Methods
+	// ======================================================================
+
+	public static String describeEnable() {
+		return "Enable/disable type propagation";
+	}
+
+	public static boolean getEnable() {
+		return true; // default value
+	}
+
+	public void setEnable(boolean flag) {
+		this.enabled = flag;
+	}
+
+	// ======================================================================
+	// Apply method
+	// ======================================================================
+
+	public void apply(WyalFile wf) {
+		if (enabled) {
+			this.file = wf;
+
+			for (WyalFile.Declaration s : wf.declarations()) {
+				propagate(s);
+			}
+		}
+	}
+
+	private void propagate(WyalFile.Declaration s) {
+		if (s instanceof WyalFile.Function) {
+			propagate((WyalFile.Function) s);
+		} else if (s instanceof WyalFile.Macro) {
+			propagate((WyalFile.Macro) s);
+		} else if (s instanceof WyalFile.Type) {
+			propagate((WyalFile.Type) s);
+		} else if (s instanceof WyalFile.Assert) {
+			propagate((WyalFile.Assert) s);
+		} else if (s instanceof WyalFile.Import) {
+
+		} else {
+			throw new InternalFailure("unknown statement encountered (" + s + ")",
+					file.getEntry(), s);
+		}
+	}
+
+	private void propagate(WyalFile.Function s) {
+		if (s.constraint != null) {
+			HashSet<String> generics = new HashSet<String>(s.generics);
+			HashMap<String, SemanticType> environment = new HashMap<String, SemanticType>();
+			addDeclaredVariables(s.from, environment, generics, s);
+			addDeclaredVariables(s.to, environment, generics, s);
+			SemanticType r = propagate(s.constraint, environment, generics, s);
+			checkIsSubtype(SemanticType.Bool, r, s.constraint, s);
+		}
+	}
+
+	private void propagate(WyalFile.Macro s) {
+		HashSet<String> generics = new HashSet<String>(s.generics);
+		HashMap<String, SemanticType> environment = new HashMap<String, SemanticType>();
+		addDeclaredVariables(s.from, environment, generics, s);
+		SemanticType r = propagate(s.body, environment, generics, s);
+		checkIsSubtype(SemanticType.Bool, r, s.body, s);
+	}
+
+	private void propagate(WyalFile.Type s) {
+		if (s.invariant != null) {
+			HashSet<String> generics = new HashSet<String>(s.generics);
+			HashMap<String, SemanticType> environment = new HashMap<String, SemanticType>();
+			addDeclaredVariables(s.type, environment, generics, s);
+			SemanticType r = propagate(s.invariant, environment, generics, s);
+			checkIsSubtype(SemanticType.Bool, r, s.invariant, s);
+		}
+	}
+
+	/**
+	 * The purpose of this method is to add variable names declared within a
+	 * type pattern to the given environment. For example, as follows:
+	 *
+	 * <pre>
+	 * type tup is {int x, int y} where x < y
+	 * </pre>
+	 *
+	 * In this case, <code>x</code> and <code>y</code> are variable names
+	 * declared as part of the pattern.
+	 *
+	 * <p>
+	 * Note, variables are both declared and initialised with the given type. In
+	 * some cases (e.g. parameters), this makes sense. In other cases (e.g.
+	 * local variable declarations), it does not. In the latter, the variable
+	 * should then be updated with an appropriate type.
+	 * </p>
+	 *
+	 * @param src
+	 * @param t
+	 * @param environment
+	 */
+	private HashMap<String, SemanticType> addDeclaredVariables(
+			TypePattern pattern, HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		if (pattern instanceof TypePattern.Union) {
+			// FIXME: in principle, we can do better here. However, I leave this
+			// unusual case for the future.
+		} else if (pattern instanceof TypePattern.Intersection) {
+			// FIXME: in principle, we can do better here. However, I leave this
+			// unusual case for the future.
+		} else if (pattern instanceof TypePattern.Rational) {
+			TypePattern.Rational tp = (TypePattern.Rational) pattern;
+			environment = addDeclaredVariables(tp.numerator, environment,
+					generics, context);
+			environment = addDeclaredVariables(tp.denominator, environment,
+					generics, context);
+		} else if (pattern instanceof TypePattern.Record) {
+			TypePattern.Record tp = (TypePattern.Record) pattern;
+			for (TypePattern element : tp.elements) {
+				environment = addDeclaredVariables(element, environment,
+						generics, context);
+			}
+		} else if (pattern instanceof TypePattern.Tuple) {
+			TypePattern.Tuple tp = (TypePattern.Tuple) pattern;
+			for (TypePattern element : tp.elements) {
+				environment = addDeclaredVariables(element, environment,
+						generics, context);
+			}
+		} else {
+			TypePattern.Leaf lp = (TypePattern.Leaf) pattern;
+
+			if (lp.var != null) {
+				try {
+					SemanticType type = builder.convert(
+							pattern.toSyntacticType(), generics, context);
+					type = builder.expand(type, false, context);
+					environment.put(lp.var.name, type);
+				} catch (ResolveError re) {
+					throw new SyntaxError("cannot resolve as function or definition call", file.getEntry(), pattern,
+							re);
+				}
+			}
+		}
+
+		return environment;
+	}
+
+	private void propagate(WyalFile.Assert s) {
+		HashMap<String, SemanticType> environment = new HashMap<String, SemanticType>();
+		SemanticType t = propagate(s.expr, environment, new HashSet<String>(),
+				s);
+		checkIsSubtype(SemanticType.Bool, t, s.expr, s);
+	}
+
+	/**
+	 * Perform type propagation through a given expression, returning the type
+	 * of value that is returned by evaluating this expression.
+	 *
+	 * @param e
+	 * @param environment
+	 * @param generics
+	 * @param context
+	 * @return
+	 */
+	private SemanticType propagate(Expr e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		SemanticType t;
+		//		
+		if (e instanceof Expr.Variable) {
+			t = propagate((Expr.Variable) e, environment, generics, context);
+		} else if (e instanceof Expr.Cast) {
+			t = propagate((Expr.Cast) e, environment, generics, context);
+		} else if (e instanceof Expr.Constant) {
+			t = propagate((Expr.Constant) e, environment, generics, context);
+		} else if (e instanceof Expr.Unary) {
+			t = propagate((Expr.Unary) e, environment, generics, context);
+		} else if (e instanceof Expr.Binary) {
+			t = propagate((Expr.Binary) e, environment, generics, context);
+		} else if (e instanceof Expr.Nary) {
+			t = propagate((Expr.Nary) e, environment, generics, context);
+		} else if (e instanceof Expr.Is) {
+			t = propagate((Expr.Is) e, environment, generics, context);
+		} else if (e instanceof Expr.Quantifier) {
+			t = propagate((Expr.Quantifier) e, environment, generics, context);
+		} else if (e instanceof Expr.Invoke) {
+			t = propagate((Expr.Invoke) e, environment, generics, context);
+		} else if (e instanceof Expr.IndexOf) {
+			t = propagate((Expr.IndexOf) e, environment, generics, context);
+		} else {
+			throw new InternalFailure("unknown expression encountered (" + e + ")", file.getEntry(), e);
+		}
+		e.attributes().add(new TypeAttribute(t));
+		return returnType(e);
+	}
+
+	private SemanticType propagate(Expr.Variable e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		SemanticType t = environment.get(e.name);
+		if (t == null) {
+			throw new InternalFailure("undeclared variable encountered (" + e + ")",
+					file.getEntry(), e);
+		}
+		return t;
+	}
+
+	private SemanticType propagate(Expr.Constant e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		return e.value.type();
+	}
+
+	private SemanticType propagate(Expr.Cast e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		try {
+			SemanticType operandType = propagate(e.operand, environment, generics,
+					context);
+			SemanticType targetType = builder.convert(e.type, generics, context);
+			// FIXME: what to do with constraints?
+			operandType = builder.expand(operandType, false, context);
+			targetType = builder.expand(targetType, false, context);
+			// TODO: check cast is permitted.
+			return targetType;
+		} catch (ResolveError re) {
+			throw new SyntaxError(re.getMessage(), file.getEntry(), e, re);
+		}
+	}
+
+	private SemanticType propagate(Expr.Unary e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		// First, clone the environment. This is necessary to ensure that any
+		// retyping caused within the left or right expressions does not
+		// propagate out of this condition.
+		environment = (HashMap<String, SemanticType>) environment.clone();
+		//
+		SemanticType op_type = propagate(e.operand, environment, generics,
+				context);
+		//
+		switch (e.op) {
+		case NOT:
+			checkIsSubtype(SemanticType.Bool, op_type, e, context);
+			break;
+		case NEG:
+			checkIsSubtype(SemanticType.IntOrReal, op_type, e, context);
+			break;
+		case LENGTHOF:
+			checkIsSubtype(SemanticType.ArrayAny, op_type, e, context);
+		}
+		return op_type;
+	}
+
+	private SemanticType propagate(Expr.IndexOf e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		SemanticType src_type = propagate(e.operand, environment, generics,
+				context);
+		SemanticType index_type = propagate(e.index, environment, generics,
+				context);
+		if (src_type instanceof SemanticType.EffectiveTuple) {
+			SemanticType.EffectiveTuple tt = (SemanticType.EffectiveTuple) src_type;
+			checkIsSubtype(SemanticType.Int, index_type, e.operand, context);
+			if (!(e.index instanceof Expr.Constant)) {
+				throw new SyntaxError("constant index required for tuple load", file.getEntry(),
+						e.index);
+			}
+		} else {
+			checkIsSubtype(SemanticType.ArrayAny, src_type, e.operand, context);
+			// FIXME: handle case for effective array (i.e. union of sets)
+			SemanticType.Array st = (SemanticType.Array) src_type;
+			checkIsSubtype(SemanticType.Int, index_type, e.index, context);
+		}
+
+		return src_type;
+	}
+
+	private SemanticType propagate(Expr.Binary e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		HashMap<String, SemanticType> leftEnvironment = environment;
+		HashMap<String, SemanticType> rightEnvironment = environment;;
+		// First, clone the environment if appropriate. This is necessary to
+		// ensure that any retyping caused within the left or right expressions
+		// propagates out of this condition only when this makes sense.
+		switch(e.op) {		
+		case AND:
+			// don't do anything.
+			break;
+		case OR:
+			// protect any retypings from propagating out
+			leftEnvironment = (HashMap<String, SemanticType>) environment.clone();
+			rightEnvironment = (HashMap<String, SemanticType>) environment.clone();
+			break;
+		case IFF:					
+		case IMPLIES:
+			leftEnvironment = (HashMap<String, SemanticType>) environment.clone();
+			rightEnvironment = leftEnvironment;
+			break;
+		}
+		//
+		SemanticType lhs_type = propagate(e.leftOperand, leftEnvironment, generics,
+				context);
+		SemanticType rhs_type = propagate(e.rightOperand, rightEnvironment,
+				generics, context);
+		
+		if (e.op != Expr.Binary.Op.ARRAYGEN && SemanticType.And(lhs_type, rhs_type) instanceof SemanticType.Void) {
+			// This is useful to sanity check that the operands make sense. For
+			// example, the expression "1.0 == 1" does not yield an automaton
+			// that reduces to "True" (i.e. because the Equality state has type
+			// Or{Int,Real}). Therefore, to prevent subtle bugs which may arise
+			// from this, we explicitly ensure that there is some value in
+			// common with the left and right-hand sides.
+			throw new SyntaxError("operand types are not compatible (" + lhs_type + " vs " + rhs_type + ")",
+					context.file().getEntry(), e);
+		}
+
+		switch (e.op) {
+		case ADD:
+		case SUB:
+		case MUL:
+		case DIV:
+		case REM:
+			checkIsSubtype(SemanticType.IntOrReal, lhs_type, e.leftOperand, context);
+			checkIsSubtype(SemanticType.IntOrReal, rhs_type, e.rightOperand, context);
+			return SemanticType.Or(lhs_type, rhs_type);
+		case EQ:
+		case NEQ:
+			return SemanticType.Or(lhs_type, rhs_type);
+		case AND:
+		case OR:
+		case IMPLIES:
+		case IFF:
+			checkIsSubtype(SemanticType.Bool, lhs_type, e.leftOperand, context);
+			checkIsSubtype(SemanticType.Bool, rhs_type, e.rightOperand, context);
+			return SemanticType.Bool;
+		case LT:
+		case LTEQ:
+		case GT:
+		case GTEQ:
+			checkIsSubtype(SemanticType.IntOrReal, lhs_type, e.leftOperand, context);
+			checkIsSubtype(SemanticType.IntOrReal, rhs_type, e.rightOperand, context);
+			return SemanticType.Or(lhs_type, rhs_type);	
+		case ARRAYGEN:
+			checkIsSubtype(SemanticType.Int, rhs_type, e.rightOperand, context);
+			return SemanticType.Array(lhs_type);
+		}
+
+		throw new InternalFailure("unknown binary expression encountered (" + e + ")",
+				file.getEntry(), e);
+	}
+
+	private SemanticType propagate(Expr.Nary e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		List<Expr> e_operands = e.operands;
+		SemanticType[] op_types = new SemanticType[e_operands.size()];
+
+		for (int i = 0; i != e_operands.size(); ++i) {
+			op_types[i] = propagate(e_operands.get(i), environment, generics,
+					context);
+		}
+
+		switch (e.op) {
+		case TUPLE:
+			if (op_types.length == 0) {
+				return SemanticType.Void;
+			} else {
+				return SemanticType.Tuple(op_types);
+			}
+		case ARRAY:
+			if (op_types.length == 0) {
+				return SemanticType.Void;
+			} else {
+				return SemanticType.Array(SemanticType.Or(op_types));
+			}
+		}
+
+		throw new InternalFailure("unknown nary expression encountered (" + e + ")", file.getEntry(), e);
+	}
+
+	private SemanticType propagate(Expr.Is e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		//
+		try {
+			SemanticType lhs = propagate(e.leftOperand, environment, generics,
+					context);			
+			SemanticType rhs = builder.convert(e.rightOperand,
+					Collections.EMPTY_SET, context);			 	
+			lhs = builder.expand(lhs,false,context);
+			e.rightOperand.attributes().add(new TypeAttribute(rhs));				
+			// The following is rather strange, but appears to work.
+			// Essentially, it represents the greatest amount of knowledge we
+			// know about the given type.
+			rhs = SemanticType.Or(builder.expand(rhs,true,context),builder.expand(rhs,false,context));			
+			retypeExpression(e.leftOperand, rhs, environment, context);			
+			SemanticType intersection = SemanticType.And(lhs, rhs);
+//			if (intersection instanceof SemanticType.Void) {
+//				// These types have no intersection, hence this expression does
+//				// not make sense.
+//				throw new SyntaxError("incomparable operands", file.getEntry(), e);
+//			} else {
+//				// Otherwise, we're all good.
+//				return SemanticType.Bool;
+//			}
+			return SemanticType.Bool;
+		} catch (ResolveError ex) {
+			throw new SyntaxError("cannot resolve as type call", file.getEntry(), e, ex);
+		}
+	}
+
+	private SemanticType propagate(Expr.Quantifier e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+		environment = new HashMap<String, SemanticType>(environment);
+		propagate(e.pattern, environment, generics, context);
+		SemanticType r = propagate(e.operand, environment, generics, context);
+		checkIsSubtype(SemanticType.Bool, r, e.operand, context);
+
+		return SemanticType.Bool;
+	}
+
+	private void propagate(TypePattern pattern,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+
+		try {
+			// First, convert the syntactic type into a semantic type. This may
+			// still contain nominal types, however, and we need to get rid of
+			// them for type checking purposes.
+			SemanticType nominalType = builder.convert(
+					pattern.toSyntacticType(), generics, context);
+
+			if (pattern instanceof TypePattern.Tuple) {
+				TypePattern.Tuple tt = (TypePattern.Tuple) pattern;
+				for (TypePattern p : tt.elements) {
+					propagate(p, environment, generics, context);
+				}
+			} else if (pattern instanceof TypePattern.Leaf) {
+				TypePattern.Leaf l = (TypePattern.Leaf) pattern;
+				// Get rid of any nominal types that may exist.
+				SemanticType rawType = builder.expand(nominalType, false, context);
+				// Add the raw type to the environment.
+				environment.put(l.var.name, rawType);
+			}
+
+			pattern.attributes().add(new TypeAttribute(nominalType));
+		} catch (ResolveError re) {
+			throw new SyntaxError("cannot resolve as function or definition call",
+					file.getEntry(), pattern, re);
+		}
+	}
+
+	private SemanticType propagate(Expr.Invoke e,
+			HashMap<String, SemanticType> environment,
+			HashSet<String> generics, WyalFile.Context context) {
+
+		SemanticType argument = propagate(e.operand, environment, generics,
+				context);
+		
+		// Construct concrete types for generic substitution
+		ArrayList<SemanticType> ivkGenerics = new ArrayList<SemanticType>();
+		for (int i = 0; i != e.generics.size(); ++i) {
+			SyntacticType gt = e.generics.get(i);
+			try {
+				SemanticType t = builder.convert(gt, generics, context);
+				ivkGenerics.add(t);
+				gt.attributes().add(new TypeAttribute(t));
+			} catch (ResolveError re) {
+				throw new SyntaxError(re.getMessage(), file.getEntry(), gt, re);
+			}
+		}
+		// Now, attempt to resolve the function
+		try {
+			SemanticType.Function fnType;
+			Map<String, SemanticType> binding;
+
+			if (e.qualification == null) {
+				// In this case, no package qualification is given. Hence, we
+				// need to resolve the name based on the active important
+				// statements and declarations within the current file.
+				Triple<NameID, SemanticType.Function, Map<String, SemanticType>> p = builder
+						.resolveAsFunctionType(e.name, argument, ivkGenerics,
+								context);
+				fnType = p.second();
+				binding = p.third();
+			} else {
+				if(e.qualification.size() == 1) {
+					e.qualification = builder.resolveAsModule(e.qualification.last(), context);
+				} else {
+					// In this case, a complete package qualification has been given. Hence,
+					// we know the fully name identifier for this function and we
+					// need only to check it exists and access the relevant
+					// information.
+				}				
+				NameID nid = new NameID(e.qualification, e.name);
+				Pair<SemanticType.Function, Map<String, SemanticType>> p = builder
+						.resolveAsFunctionType(nid, argument, ivkGenerics,
+								context);
+				fnType = p.first();
+				binding = p.second();
+			}
+
+			SemanticType[] fn_generics = fnType.generics();
+
+			if (fn_generics.length != e.generics.size()) {
+				// could resolve this with inference in the future.
+				throw new SyntaxError(
+						"incorrect number of generic arguments provided (got "
+								+ e.generics.size() + ", required "
+								+ fn_generics.length + ")", context.file()
+								.getEntry(), e);
+			}
+
+			fnType = (SemanticType.Function) fnType.substitute(binding);
+			return builder.expand(fnType, false, context);
+		} catch (ResolveError re) {
+			throw new SyntaxError("cannot resolve as function or definition call", context.file().getEntry(), e, re);
+		}
+	}
+
+	/**
+	 * Calculate the most precise type that captures those possible values a
+	 * given expression can evaluate to.
+	 *
+	 * @param e
+	 * @return
+	 */
+	public static SemanticType returnType(Expr e) {
+		SemanticType type = e.attribute(TypeAttribute.class).type;
+		if (e instanceof Expr.Variable || e instanceof Expr.Constant
+				|| e instanceof Expr.Quantifier || e instanceof Expr.Cast
+				|| e instanceof Expr.Is) {
+			return type;
+		} else if (e instanceof Expr.Unary) {
+			Expr.Unary ue = (Expr.Unary) e;
+			switch (ue.op) {
+			case NOT:
+				return SemanticType.Bool;
+			case NEG:
+				return type;
+			case LENGTHOF:
+				return SemanticType.Int;
+			}
+		} else if (e instanceof Expr.Binary) {
+			Expr.Binary ue = (Expr.Binary) e;
+			switch (ue.op) {
+			case ADD:
+			case SUB:
+			case MUL:
+			case DIV:
+			case REM:
+				return type;
+			case AND:
+			case OR:
+			case EQ:
+			case NEQ:
+			case IMPLIES:
+			case IFF:
+			case LT:
+			case LTEQ:
+			case GT:
+			case GTEQ:
+				return SemanticType.Bool;
+			case ARRAYGEN:
+				return type;
+			}
+		} else if (e instanceof Expr.Nary) {
+			Expr.Nary ue = (Expr.Nary) e;
+			switch (ue.op) {
+			case TUPLE:
+			case ARRAY:
+				return type;
+			}
+		} else if (e instanceof Expr.IndexOf) {
+			Expr.IndexOf ue = (Expr.IndexOf) e;
+			if (type instanceof SemanticType.EffectiveTuple) {
+				SemanticType.EffectiveTuple tt = (SemanticType.EffectiveTuple) type;
+				Value.Integer idx = (Value.Integer) ((Expr.Constant) ue.index).value;
+				return tt.tupleElement(idx.value.intValue());
+			} else {
+				SemanticType.Array st = (SemanticType.Array) type;
+				return st.element();
+			}
+		} else {
+			Expr.Invoke fc = (Expr.Invoke) e;
+			return ((SemanticType.Function) type).to();
+		}
+		// should be deadcode.
+		throw new IllegalArgumentException("Invalid opcode for expression");
+	}
+
+	/**
+	 * Apply constraints imposed by fixing a given expression to be a given
+	 * type. For example, support we have:
+	 * 
+	 * <pre>
+	 * assert:
+	 *    forall(int|null x, null y):
+	 *        if:
+	 *           (x+1) is int
+	 *        then:
+	 *           x != y
+	 * </pre>
+	 * 
+	 * This assertion is true because retyping "x+1" implies that x is an int
+	 * 
+	 * @param e
+	 * @param type
+	 * @param environment
+	 * @param context
+	 */
+	public void retypeExpression(Expr e, SemanticType type,
+			HashMap<String, SemanticType> environment, WyalFile.Context context) {
+		if (e instanceof Expr.Variable) {
+			Expr.Variable v = (Expr.Variable) e;
+			// The new type is the intersection of the existing type and the
+			// asserted type.
+			SemanticType newType = SemanticType.And(environment.get(v.name),
+					type);
+			//
+			environment.put(v.name, newType);
+		} else {
+			// FIXME: implement other cases
+		}
+	}
+
+	/**
+	 * Check that t1 :> t2 or, equivalently, that t2 is a subtype of t1. A type
+	 * <code>t1</code> is said to be a subtype of another type <code>t2</code>
+	 * iff the semantic set described by <code>t1</code> contains that described
+	 * by <code>t2</code>.
+	 *
+	 * @param t1
+	 *            --- Semantic type that should contain <code>t2</code>.
+	 * @param t2
+	 *            --- Semantic type that shold be contained by <code>t1/code>.
+	 * @param element
+	 *            --- Syntax error is reported against this element if <code>t1
+	 *            </code> does not contain <code>t2</code>.
+	 */
+	private void checkIsSubtype(SemanticType t1, SemanticType t2,
+			SyntacticElement element, WyalFile.Context context) {
+		// First, we must eliminate all nominal information as much as possible
+		// before we can perform this test.
+		t1 = builder.expand(t1, false, context);
+		t2 = builder.expand(t2, false, context);
+		// Second, perform the subtype test.
+		if (!SemanticType.isSubtype(t1, t2)) {
+			throw new SyntaxError("expected type " + t1 + ", got type " + t2, file.getEntry(),
+					element);
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/transforms/VerificationCheck.java b/modules/wycs/src/wycs/transforms/VerificationCheck.java
new file mode 100755
index 0000000000..e5c2442152
--- /dev/null
+++ b/modules/wycs/src/wycs/transforms/VerificationCheck.java
@@ -0,0 +1,960 @@
+package wycs.transforms;
+
+import static wycc.lang.SyntaxError.*;
+import static wycs.solver.Solver.*;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.*;
+
+import wyautl.core.*;
+import wyautl.io.PrettyAutomataWriter;
+import wyrw.core.*;
+import wyrw.util.*;
+import wyautl.util.BigRational;
+import wybs.lang.Builder;
+import wycc.lang.SyntacticElement;
+import wycc.lang.Transform;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycc.util.Triple;
+import wycs.builders.Wyal2WycsBuilder;
+import wycs.core.Code;
+import wycs.core.NormalForms;
+import wycs.core.SemanticType;
+import wycs.core.Types;
+import wycs.core.Value;
+import wycs.core.WycsFile;
+import wycs.io.WycsFilePrinter;
+import wycs.solver.Solver;
+import wycs.solver.SolverUtil;
+import wyfs.util.Trie;
+
+/**
+ * Responsible for converting a <code>WycsFile</code> into an automaton that can
+ * then be simplified to test for satisfiability. The key challenge here is to
+ * break down the rich language of expressions described by the
+ * <code>WycsFile</code> format, such that they can be handled effectively by
+ * the <code>Solver</code>.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class VerificationCheck implements Transform<WycsFile> {
+	public enum RewriteMode {
+		UNFAIR, FAIR, EXHAUSTIVE
+	};
+
+	/**
+	 * Determines whether this transform is enabled or not.
+	 */
+	private boolean enabled = getEnable();
+
+	/**
+	 * Determines whether debugging is enabled or not
+	 */
+	private boolean debug = getDebug();
+
+	/**
+	 * Determine what rewriter to use.
+	 * 
+	 * NOTE: GlobalDispatch with RankComparator must be default to ensure rules
+	 * are chosen according to rank. See #510 on why this is necessary to manage
+	 * quantifier instantiation versus inequality inference.
+	 */
+	private RewriteMode rwMode = RewriteMode.UNFAIR;
+
+	/**
+	 * Determine the maximum number of inference steps permitted
+	 */
+	private int maxInferences = getMaxInferences();
+
+	private final Wyal2WycsBuilder builder;
+
+	private WycsFile file;
+
+	// ======================================================================
+	// Constructor(s)
+	// ======================================================================
+
+	public VerificationCheck(Builder builder) {
+		this.builder = (Wyal2WycsBuilder) builder;
+	}
+
+	// ======================================================================
+	// Configuration Methods
+	// ======================================================================
+
+	public static String describeEnable() {
+		return "Enable/disable verification";
+	}
+
+	public static boolean getEnable() {
+		return true; // default value
+	}
+
+	public void setEnable(boolean flag) {
+		this.enabled = flag;
+	}
+
+	public static String describeDebug() {
+		return "Enable/disable debugging information";
+	}
+
+	public static boolean getDebug() {
+		return false; // default value
+	}
+
+	public void setDebug(boolean flag) {
+		this.debug = flag;
+	}
+
+	public static String describeRwMode() {
+		return "Set the rewrite mode to use (unfair, fair or exhaustive)";
+	}
+
+	public static String getRwmode() {
+		return "unfaise"; // default value
+	}
+
+	public void setRwmode(String mode) {
+		for (RewriteMode rw : RewriteMode.values()) {
+			if (mode.equals(rw.name().toLowerCase())) {
+				this.rwMode = rw;
+				return;
+			}
+		}
+		throw new RuntimeException("unknown rewrite mode: " + mode);
+	}
+
+	public static String describeMaxInferences() {
+		return "Limits the number of inference steps permitted";
+	}
+
+	public static int getMaxInferences() {
+		return 2000; // default value
+	}
+
+	public void setMaxInferences(int limit) {
+		this.maxInferences = limit;
+	}
+
+	// ======================================================================
+	// Apply Method
+	// ======================================================================
+
+	/**
+	 * Verify the given list of Wycs statements.
+	 *
+	 * @param statements
+	 * @return the set of failing assertions (if any).
+	 */
+	public void apply(WycsFile wf) {
+		if (enabled) {
+			this.file = wf;
+
+			// Traverse each statement and verify any assertions we
+			// encounter.
+			List<WycsFile.Declaration> statements = wf.declarations();
+			int count = 0;
+			for (int i = 0; i != statements.size(); ++i) {
+				WycsFile.Declaration stmt = statements.get(i);
+
+				if (stmt instanceof WycsFile.Assert) {
+					checkValid((WycsFile.Assert) stmt, ++count);
+				} else if (stmt instanceof WycsFile.Function || stmt instanceof WycsFile.Macro
+						|| stmt instanceof WycsFile.Type) {
+					// TODO: we could try to verify that the function makes
+					// sense (i.e. that it's specification is satisfiable for at
+					// least one input).
+				} else {
+					throw new InternalFailure("unknown statement encountered " + stmt, file.getEntry(), stmt);
+				}
+			}
+		}
+	}
+
+	private void checkValid(WycsFile.Assert stmt, int number) {
+		Runtime runtime = Runtime.getRuntime();
+		long startTime = System.currentTimeMillis();
+		long startMemory = runtime.freeMemory();
+
+		Automaton automaton = new Automaton();
+		Automaton original = null;
+
+		Code neg = Code.Unary(SemanticType.Bool, Code.Op.NOT, stmt.condition);
+		// The following conversion is potentially very expensive, but is
+		// currently necessary for the instantiate axioms phase.
+		Code nnf = NormalForms.negationNormalForm(neg);
+		// Convert to prefix normal form. One reason for this is that it
+		// protectes against accidental variable capture by renaming all
+		// variables.
+		nnf = NormalForms.renameVariables(nnf);
+		// debug(nnf,file.getEntry());
+		int maxVar = findLargestVariable(nnf);
+
+		Code vc = instantiateAxioms(nnf, maxVar + 1);
+
+		// debug(vc,file.getEntry());
+
+		int assertion = translate(vc, automaton, new HashMap<String, Integer>());
+		automaton.setRoot(0, assertion);
+		// NOTE: don't need to minimise or compact here since the rewriter does
+		// this for me.
+		//
+		// automaton.minimise();
+		// automaton.compact();
+
+		if (debug) {
+			debug(neg, file);
+			debug(nnf, file);
+		}
+
+		RESULT result = unsat(automaton,rwMode,maxInferences,debug);
+
+		if (result instanceof RESULT.TIMEOUT) {
+			throw new AssertionFailure("timeout occurred during verification", stmt, null, automaton, original);
+		} else if (result instanceof RESULT.SAT) {
+			String msg = stmt.message;
+			msg = msg == null ? "assertion failure" : msg;
+			throw new AssertionFailure(msg, stmt, null, automaton, original);
+		}
+
+		long endTime = System.currentTimeMillis();
+		builder.logTimedMessage("[" + file.getEntry() + "] Verified assertion #" + number + " (steps " + result.numberOfSteps + ")",
+				endTime - startTime, startMemory - runtime.freeMemory());
+	}
+
+	private int translate(Code expr, Automaton automaton, HashMap<String, Integer> environment) {
+		int r;
+		if (expr instanceof Code.Constant) {
+			r = translate((Code.Constant) expr, automaton, environment);
+		} else if (expr instanceof Code.Cast) {
+			r = translate((Code.Cast) expr, automaton, environment);
+		} else if (expr instanceof Code.Variable) {
+			r = translate((Code.Variable) expr, automaton, environment);
+		} else if (expr instanceof Code.Binary) {
+			r = translate((Code.Binary) expr, automaton, environment);
+		} else if (expr instanceof Code.Unary) {
+			r = translate((Code.Unary) expr, automaton, environment);
+		} else if (expr instanceof Code.Nary) {
+			r = translate((Code.Nary) expr, automaton, environment);
+		} else if (expr instanceof Code.Load) {
+			r = translate((Code.Load) expr, automaton, environment);
+		} else if (expr instanceof Code.IndexOf) {
+			r = translate((Code.IndexOf) expr, automaton, environment);
+		} else if (expr instanceof Code.Is) {
+			r = translate((Code.Is) expr, automaton, environment);
+		} else if (expr instanceof Code.Quantifier) {
+			r = translate((Code.Quantifier) expr, automaton, environment);
+		} else if (expr instanceof Code.FunCall) {
+			r = translate((Code.FunCall) expr, automaton, environment);
+		} else {
+			throw new InternalFailure("unknown: " + expr.getClass().getName(), file.getEntry(), expr);
+		}
+
+		// debug(automaton,r);
+		return r;
+	}
+
+	private int translate(Code.Constant expr, Automaton automaton, HashMap<String, Integer> environment) {
+		return convert(expr.value, expr, automaton);
+	}
+
+	private int translate(Code.Cast expr, Automaton automaton, HashMap<String, Integer> environment) {
+		int e = translate(expr.operands[0], automaton, environment);
+		// FIXME: implement cast expressions!
+		return e;
+	}
+
+	private int translate(Code.Variable code, Automaton automaton, HashMap<String, Integer> environment) {
+		if (code.operands.length > 0) {
+			throw new RuntimeException("need to add support for variables with sub-components");
+		}
+		// TODO: just use an integer for variables directly
+		String name = "r" + code.index;
+		Integer idx = environment.get(name);
+		// FIXME: need to handle code.operands as well!
+		if (idx == null) {
+			// FIXME: this is a hack to work around modified operands after a
+			// loop.
+			return Var(automaton, name);
+		} else {
+			return idx;
+		}
+	}
+
+	private int translate(Code.Binary code, Automaton automaton, HashMap<String, Integer> environment) {
+		int lhs = translate(code.operands[0], automaton, environment);
+		int rhs = translate(code.operands[1], automaton, environment);
+
+		int type = convert(automaton, code.type);
+
+		switch (code.opcode) {
+		case ADD:
+			return SolverUtil.Add(automaton, lhs, rhs);
+		case SUB:
+			return SolverUtil.Sub(automaton, lhs, rhs);
+		case MUL:
+			return SolverUtil.Mul(automaton, lhs, rhs);
+		case DIV:
+			return SolverUtil.Div(automaton, lhs, rhs);
+		case REM:
+			return automaton.add(False);
+		case EQ:
+			return SolverUtil.Equals(automaton, type, lhs, rhs);
+		case NEQ:
+			return Not(automaton, SolverUtil.Equals(automaton, type, lhs, rhs));
+		case LT:
+			return SolverUtil.LessThan(automaton, type, lhs, rhs);
+		case LTEQ:
+			return SolverUtil.LessThanEq(automaton, type, lhs, rhs);
+		case ARRAYGEN:
+			return ArrayGen(automaton,lhs,rhs);
+		}
+		throw new InternalFailure("unknown binary bytecode encountered (" + code + ")", file.getEntry(), code);
+	}
+
+	private int translate(Code.Unary code, Automaton automaton, HashMap<String, Integer> environment) {
+		int e = translate(code.operands[0], automaton, environment);
+		switch (code.opcode) {
+		case NOT:
+			return Not(automaton, e);
+		case NEG:
+			return SolverUtil.Neg(automaton, e);
+		case LENGTH:
+			return LengthOf(automaton, e);
+		}
+		throw new InternalFailure("unknown unary bytecode encountered (" + code + ")", file.getEntry(), code);
+	}
+
+	private int translate(Code.Nary code, Automaton automaton, HashMap<String, Integer> environment) {
+		Code[] operands = code.operands;
+		int[] es = new int[operands.length];
+		for (int i = 0; i != es.length; ++i) {
+			es[i] = translate(operands[i], automaton, environment);
+		}
+		switch (code.opcode) {
+		case AND:
+			return And(automaton, es);
+		case OR:
+			return Or(automaton, es);
+		case ARRAY:
+			return Array(automaton, es);
+		case TUPLE:
+			return Tuple(automaton, es);
+		}
+		throw new InternalFailure("unknown nary expression encountered (" + code + ")", file.getEntry(), code);
+	}
+
+	private int translate(Code.Load code, Automaton automaton, HashMap<String, Integer> environment) {
+		int e = translate(code.operands[0], automaton, environment);
+		int i = automaton.add(new Automaton.Int(code.index));
+		return Solver.Load(automaton, e, i);
+	}
+
+	private int translate(Code.IndexOf code, Automaton automaton, HashMap<String, Integer> environment) {
+		int e = translate(code.operands[0], automaton, environment);
+		int i = translate(code.operands[1], automaton, environment);
+		return Solver.IndexOf(automaton, e, i);
+	}
+
+	private int translate(Code.Is code, Automaton automaton, HashMap<String, Integer> environment) {
+		int e = translate(code.operands[0], automaton, environment);
+		int t = convert(automaton, code.test);
+		return Solver.Is(automaton, e, t);
+	}
+
+	private int translate(Code.FunCall code, Automaton automaton, HashMap<String, Integer> environment) {
+		// uninterpreted function call
+		int argument = translate(code.operands[0], automaton, environment);
+		int[] es = new int[] { automaton.add(new Automaton.Strung(code.nid.toString())), argument };
+		return Fn(automaton, es);
+	}
+
+	private int translate(Code.Quantifier code, Automaton automaton, HashMap<String, Integer> environment) {
+		HashMap<String, Integer> nEnvironment = new HashMap<String, Integer>(environment);
+		Pair<SemanticType, Integer>[] variables = code.types;
+		int[] vars = new int[variables.length];
+
+		// int[] typeTests = new int[variables.length];
+		for (int i = 0; i != variables.length; ++i) {
+			Pair<SemanticType, Integer> p = variables[i];
+			// First, construct variable pairs
+			SemanticType type = p.first();
+			String var = "r" + p.second();
+			int varIdx = Var(automaton, var);
+			nEnvironment.put(var, varIdx);
+			int typeIdx = convert(automaton, type);
+			vars[i] = automaton.add(new Automaton.List(varIdx, typeIdx));
+			// Second, construct the appropriate type test for each variable
+			// typeTests[i] =
+			// Solver.Is(automaton,varIdx,convert(automaton,type));
+		}
+
+		int avars = automaton.add(new Automaton.Set(vars));
+		// int typeTest = And(automaton,typeTests);
+		int quantifiedExpression = translate(code.operands[0], automaton, nEnvironment);
+
+		if (code.opcode == Code.Op.FORALL) {
+			// return ForAll(automaton, avars,
+			// SolverUtil.Implies(automaton,typeTest, quantifiedExpression));
+			return ForAll(automaton, avars, quantifiedExpression);
+		} else {
+			// return Exists(automaton, avars, And(automaton,typeTest,
+			// quantifiedExpression));
+			return Exists(automaton, avars, quantifiedExpression);
+		}
+	}
+
+	/**
+	 * Convert between a WYIL value and a WYRL value. Basically, this is really
+	 * stupid and it would be good for them to be the same.
+	 *
+	 * @param value
+	 * @return
+	 */
+	private int convert(Value value, SyntacticElement element, Automaton automaton) {
+
+		if (value instanceof Value.Null) {
+			Value.Null b = (Value.Null) value;
+			return automaton.add(Null);
+		} else if (value instanceof Value.Bool) {
+			Value.Bool b = (Value.Bool) value;
+			return b.value ? automaton.add(True) : automaton.add(False);
+		} else if (value instanceof Value.Integer) {
+			Value.Integer v = (Value.Integer) value;
+			return Num(automaton, BigRational.valueOf(v.value));
+		} else if (value instanceof Value.Decimal) {
+			Value.Decimal v = (Value.Decimal) value;
+			return Num(automaton, new BigRational(v.value));
+		} else if (value instanceof Value.String) {
+			Value.String v = (Value.String) value;
+			return Solver.String(automaton, v.value);
+		} else if (value instanceof Value.Array) {
+			Value.Array vs = (Value.Array) value;
+			int[] vals = new int[vs.values.size()];
+			int i = 0;
+			for (Value c : vs.values) {
+				vals[i++] = convert(c, element, automaton);
+			}
+			return Array(automaton, vals);
+		} else if (value instanceof Value.Tuple) {
+			Value.Tuple vt = (Value.Tuple) value;
+			int[] vals = new int[vt.values.size()];
+			for (int i = 0; i != vals.length; ++i) {
+				vals[i] = convert(vt.values.get(i), element, automaton);
+			}
+			return Tuple(automaton, vals);
+		} else {
+			throw new InternalFailure("unknown value encountered (" + value + ", " + value.getClass().getName() + ")", file.getEntry(),
+					element);
+		}
+	}
+
+	/**
+	 * Construct an automaton node representing a given semantic type.
+	 *
+	 * @param automaton
+	 * @param type
+	 *            --- to be converted.
+	 * @return the index of the new node.
+	 */
+	public int convert(Automaton automaton, SemanticType type) {
+		Automaton type_automaton = type.automaton();
+		// The following is important to make sure that the type is in minimised
+		// form before verification begins. This firstly reduces the amount of
+		// work during verification, and also allows the functions in
+		// SolverUtils to work properly.
+		Reductions.minimiseAndReduce(type_automaton, 5000, Types.SCHEMA, Types.reductions);
+		return automaton.addAll(type_automaton.getRoot(0), type_automaton);
+	}
+
+	public static void debug(Automaton automaton) {
+		try {
+			// System.out.println(automaton);
+			PrettyAutomataWriter writer = new PrettyAutomataWriter(System.out, SCHEMA, "Or", "And");
+			writer.write(automaton);
+			writer.flush();
+		} catch (IOException e) {
+			System.out.println("I/O Exception - " + e);
+		}
+	}
+
+	public static void debug(Code code, WycsFile file) {
+		ArrayList<WycsFile.Declaration> tmpDecls = new ArrayList();
+		tmpDecls.add(new WycsFile.Assert("", code));
+		WycsFile tmp = new WycsFile(file.getEntry(), tmpDecls);
+		try {
+			new WycsFilePrinter(System.err).write(tmp);
+		} catch (IOException e) {
+		}
+	}
+
+	public static class AssertionFailure extends RuntimeException {
+		private final WycsFile.Assert assertion;
+		private final Rewriter rewriter;
+		private final Automaton reduced;
+		private final Automaton original;
+
+		public AssertionFailure(String msg, WycsFile.Assert assertion, Rewriter rewriter, Automaton reduced,
+				Automaton original) {
+			super(msg);
+			this.assertion = assertion;
+			this.rewriter = rewriter;
+			this.reduced = reduced;
+			this.original = original;
+		}
+
+		public WycsFile.Assert assertion() {
+			return assertion;
+		}
+
+		public Rewriter rewriter() {
+			return rewriter;
+		}
+
+		public Automaton reduction() {
+			return reduced;
+		}
+
+		public Automaton original() {
+			return original;
+		}
+	}
+
+	// =============================================================================
+	// Axiom Instantiation
+	// =============================================================================
+
+	/**
+	 * Blindly instantiate all axioms. Note, this function is assuming the
+	 * verification condition has already been negated for
+	 * proof-by-contradiction and converted into Negation Normal Form.
+	 *
+	 * @param condition
+	 *            Condition over which all axioms should be instantiated.
+	 * @param freeVariable
+	 *            First available free variable which can be used when
+	 *            instantiating axioms.
+	 * @return
+	 */
+	public Code instantiateAxioms(Code condition, int freeVariable) {
+		if (condition instanceof Code.Variable || condition instanceof Code.Constant) {
+			// do nothing
+			return condition;
+		} else if (condition instanceof Code.Unary) {
+			return instantiateAxioms((Code.Unary) condition, freeVariable);
+		} else if (condition instanceof Code.Binary) {
+			return instantiateAxioms((Code.Binary) condition, freeVariable);
+		} else if (condition instanceof Code.Nary) {
+			return instantiateAxioms((Code.Nary) condition, freeVariable);
+		} else if (condition instanceof Code.Quantifier) {
+			return instantiateAxioms((Code.Quantifier) condition, freeVariable);
+		} else if (condition instanceof Code.FunCall) {
+			return instantiateAxioms((Code.FunCall) condition, freeVariable);
+		} else if (condition instanceof Code.Load) {
+			return instantiateAxioms((Code.Load) condition, freeVariable);
+		} else if (condition instanceof Code.Is) {
+			return instantiateAxioms((Code.Is) condition, freeVariable);
+		} else if(condition instanceof Code.IndexOf) {
+			return instantiateAxioms((Code.IndexOf) condition, freeVariable);
+		} else {
+			throw new InternalFailure("invalid boolean expression encountered (" + condition + ")", file.getEntry(), condition);
+		}
+	}
+
+	private Code instantiateAxioms(Code.Unary condition, int freeVariable) {
+		switch (condition.opcode) {
+		case NOT:
+			return Code.Unary(condition.type, condition.opcode, instantiateAxioms(condition.operands[0], freeVariable),
+					condition.attributes());
+		default:
+			throw new InternalFailure("invalid boolean expression encountered (" + condition + ")", file.getEntry(),
+					condition);
+		}
+	}
+
+	private Code instantiateAxioms(Code.Binary condition, int freeVariable) {
+		switch (condition.opcode) {
+		case EQ:
+		case NEQ:
+		case LT:
+		case LTEQ: {
+			ArrayList<Code> axioms = new ArrayList<Code>();
+			instantiateFromExpression(condition, axioms, freeVariable);
+			return and(axioms, condition);
+		}
+		default:
+			throw new InternalFailure("invalid boolean expression encountered (" + condition + ")", file.getEntry(), condition);
+		}
+	}
+
+	private Code instantiateAxioms(Code.Nary condition, int freeVariable) {
+		switch (condition.opcode) {
+		case AND:
+		case OR: {
+			Code[] e_operands = new Code[condition.operands.length];
+			for (int i = 0; i != e_operands.length; ++i) {
+				e_operands[i] = instantiateAxioms(condition.operands[i], freeVariable);
+			}
+			return Code.Nary(condition.type, condition.opcode, e_operands, condition.attributes());
+		}
+		case TUPLE: {
+			return condition;
+		}
+		default:
+			throw new InternalFailure("invalid boolean expression encountered (" + condition + ")", file.getEntry(), condition);
+		}
+	}
+
+	private Code instantiateAxioms(Code.Is condition, int freeVariable) {
+		ArrayList<Code> axioms = new ArrayList<Code>();
+		instantiateFromExpression(condition.operands[0], axioms, freeVariable);
+		return and(axioms, condition);
+	}
+
+	private Code instantiateAxioms(Code.Quantifier condition, int freeVariable) {
+		return Code.Quantifier(condition.type, condition.opcode, instantiateAxioms(condition.operands[0], freeVariable),
+				condition.types, condition.attributes());
+	}
+
+	private Code instantiateAxioms(Code.FunCall condition, int freeVariable) {
+		ArrayList<Code> axioms = new ArrayList<Code>();
+		try {
+			WycsFile module = builder.getModule(condition.nid.module());
+			// module should not be null if TypePropagation has already passed.
+			Object d = module.declaration(condition.nid.name());
+			if (d instanceof WycsFile.Function) {
+				WycsFile.Function fn = (WycsFile.Function) d;
+				if (fn.constraint != null) {
+					// There are some axioms we can instantiate. First, we need
+					// to
+					// construct the generic binding for this function.
+					HashMap<String, SemanticType> generics = buildGenericBinding(fn.type.generics(), condition.binding);
+					Code axiom = renameToAvoidCapture(fn.constraint, freeVariable);
+					HashMap<Integer, Code> binding = new HashMap<Integer, Code>();
+					binding.put(1, condition.operands[0]);
+					binding.put(0, condition);
+					axiom = axiom.substitute(binding).instantiate(generics);
+					axioms.add(axiom);
+				}
+			} else if (d instanceof WycsFile.Macro) {
+				// we can ignore macros, because they are inlined separately by
+				// MacroExpansion.
+			} else {
+				throw new InternalFailure("cannot resolve as function or macro call", file.getEntry(), condition);
+			}
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), condition, ex);
+		}
+
+		instantiateFromExpression(condition.operands[0], axioms, freeVariable);
+		return and(axioms, condition);
+	}
+
+	private HashMap<String, SemanticType> buildGenericBinding(SemanticType[] from, SemanticType[] to) {
+		HashMap<String, SemanticType> binding = new HashMap<String, SemanticType>();
+		for (int i = 0; i != to.length; ++i) {
+			SemanticType.Var v = (SemanticType.Var) from[i];
+			binding.put(v.name(), to[i]);
+		}
+		return binding;
+	}
+
+	private Code instantiateAxioms(Code.Load condition, int freeVariable) {
+		return Code.Load(condition.type, instantiateAxioms(condition.operands[0], freeVariable), condition.index,
+				condition.attributes());
+	}
+
+	private Code instantiateAxioms(Code.IndexOf condition, int freeVariable) {
+		// I believe this is the appropriate thing to do here.
+		return condition;
+	}
+
+	private void instantiateFromExpression(Code expression, ArrayList<Code> axioms, int freeVariable) {
+		if (expression instanceof Code.Variable || expression instanceof Code.Constant) {
+			// do nothing
+		} else if (expression instanceof Code.Cast) {
+			instantiateFromExpression((Code.Cast) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.Unary) {
+			instantiateFromExpression((Code.Unary) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.Binary) {
+			instantiateFromExpression((Code.Binary) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.Nary) {
+			instantiateFromExpression((Code.Nary) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.Load) {
+			instantiateFromExpression((Code.Load) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.IndexOf) {
+			instantiateFromExpression((Code.IndexOf) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.Is) {
+			instantiateFromExpression((Code.Is) expression, axioms, freeVariable);
+		} else if (expression instanceof Code.FunCall) {
+			instantiateFromExpression((Code.FunCall) expression, axioms, freeVariable);
+		} else {
+			throw new InternalFailure(
+					"invalid expression encountered (" + expression + ", " + expression.getClass().getName() + ")",
+					file.getEntry(), expression);
+		}
+	}
+
+	private void instantiateFromExpression(Code.Cast expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+	}
+
+	private void instantiateFromExpression(Code.Unary expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+
+		if (expression.opcode == Code.Op.LENGTH) {
+			Code lez = Code.Binary(SemanticType.Int, Code.Op.LTEQ, Code.Constant(Value.Integer(BigInteger.ZERO)),
+					expression);
+			axioms.add(lez);
+		}
+	}
+
+	private void instantiateFromExpression(Code.Binary expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+		instantiateFromExpression(expression.operands[1], axioms, freeVariable);
+	}
+
+	private void instantiateFromExpression(Code.Nary expression, ArrayList<Code> axioms, int freeVariable) {
+		Code[] e_operands = expression.operands;
+		for (int i = 0; i != e_operands.length; ++i) {
+			instantiateFromExpression(e_operands[i], axioms, freeVariable);
+		}
+	}
+
+	private void instantiateFromExpression(Code.Load expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+	}
+
+	private void instantiateFromExpression(Code.IndexOf expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+		instantiateFromExpression(expression.operands[1], axioms, freeVariable);
+	}
+
+	private void instantiateFromExpression(Code.Is expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+	}
+
+	private void instantiateFromExpression(Code.FunCall expression, ArrayList<Code> axioms, int freeVariable) {
+		instantiateFromExpression(expression.operands[0], axioms, freeVariable);
+
+		try {
+			WycsFile module = builder.getModule(expression.nid.module());
+			// module should not be null if TypePropagation has already passed.
+			WycsFile.Function fn = module.declaration(expression.nid.name(), WycsFile.Function.class);
+			if (fn.constraint != null) {
+				// There are some axioms we can instantiate. First, we need to
+				// construct the generic binding for this function.
+				HashMap<String, SemanticType> generics = buildGenericBinding(fn.type.generics(), expression.binding);
+				Code axiom = renameToAvoidCapture(fn.constraint, freeVariable);
+				HashMap<Integer, Code> binding = new HashMap<Integer, Code>();
+				binding.put(1, expression.operands[0]);
+				binding.put(0, expression);
+				axiom = axiom.substitute(binding).instantiate(generics);
+				axioms.add(axiom);
+			}
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), expression, ex);
+		}
+	}
+
+	private Code renameToAvoidCapture(Code code, int freeVariable) {
+		HashSet<Pair<SemanticType, Integer>> usedVariables = new HashSet();
+		findUsedVariables(code, usedVariables);
+		return NormalForms.renameVariables(code, freeVariable);
+	}
+
+	/**
+	 * Determine the largest variable index within a given bytecode. This is
+	 * useful to avoid variable capture when importing axioms.
+	 *
+	 * @param condition
+	 * @return
+	 */
+	private int findLargestVariable(Code condition) {
+		if (condition instanceof Code.Variable) {
+			// do nothing
+			Code.Variable v = (Code.Variable) condition;
+			return v.index;
+		} else {
+			int max = -1;
+			for (Code c : condition.operands) {
+				max = Math.max(findLargestVariable(c), max);
+			}
+			return max;
+		}
+	}
+
+	/**
+	 * Determine the set of used variables within a given bytecode. This is
+	 * useful to avoid variable capture when importing axioms.
+	 *
+	 * @param condition
+	 * @return
+	 */
+	private void findUsedVariables(Code condition, HashSet<Pair<SemanticType, Integer>> vars) {
+		if (condition instanceof Code.Variable) {
+			// do nothing
+			Code.Variable v = (Code.Variable) condition;
+			vars.add(new Pair<SemanticType, Integer>(v.type, v.index));
+		} else {
+			for (Code c : condition.operands) {
+				findUsedVariables(c, vars);
+			}
+		}
+	}
+
+	private Code and(ArrayList<Code> axioms, Code c) {
+		if (axioms.size() == 0) {
+			return c;
+		} else {
+			Code[] clauses = new Code[axioms.size() + 1];
+			clauses[0] = c;
+			for (int i = 0; i != axioms.size(); ++i) {
+				clauses[i + 1] = axioms.get(i);
+			}
+			return Code.Nary(SemanticType.Bool, Code.Op.AND, clauses);
+		}
+	}
+
+	public static RESULT unsat(Automaton automaton,  RewriteMode rwMode, int maxSteps, boolean debug) {
+		// Graph rewrite is needed to ensure that previously visited states are
+		// not visited again.
+		Rewrite rewrite = new Inference(Solver.SCHEMA, new AbstractActivation.RankComparator("rank"), Solver.inferences, Solver.reductions);
+		// Initialise the rewrite with our starting state
+		int HEAD = rewrite.initialise(automaton);
+		// Stacked rewriter ensures that reduction rules are applied atomically
+		// Breadth-first rewriter ensures that the search spans outwards in a
+		// fair style. This protects against rule starvation.
+		Rewriter rewriter = createRewriter(rewrite,rwMode);
+		rewriter.reset(HEAD);
+		// Finally, perform the rewrite!		
+		rewriter.apply(maxSteps);		
+		List<Rewrite.State> states = rewrite.states();
+		int numberOfSteps = states.size();
+		if(debug) {
+			printRewriteProof(rewrite);
+		}
+		// Search through the states encountered and see whether we found a
+		// contradiction or not.
+		for (int i = 0; i != states.size(); ++i) { 
+			automaton = states.get(i).automaton();
+			int root = wyrw.core.Inference.USE_SUBSTITUTION ? i : 0;
+			if (automaton.get(automaton.getRoot(root)).equals(Solver.False)) {
+				// Yes, we found a contradiction!
+				return new RESULT.UNSAT(numberOfSteps);
+			}
+		}		
+		if (states.size() == maxSteps) {
+			// The rewrite has been bounded by the maximum number of permitted
+			// steps. Therefore, we declare it a timeout.
+			return new RESULT.TIMEOUT(numberOfSteps);
+		} else {
+			return new RESULT.SAT(numberOfSteps);
+		}
+	}
+
+	/**
+	 * Construct rewriter based on selected rewrite mode.
+	 * 
+	 * @param rewrite
+	 * @return
+	 */
+	private static Rewriter createRewriter(Rewrite rewrite, RewriteMode rwMode) {
+		switch(rwMode) {
+		case UNFAIR:
+			return new LinearRewriter(rewrite,LinearRewriter.UNFAIR_HEURISTIC); 
+		case EXHAUSTIVE:
+			return new BreadthFirstRewriter(rewrite);
+		}
+		throw new RuntimeException("Unknown rewrite mode encountered: " + rwMode);
+	}
+	
+	private static void printRewriteProof(Rewrite rewrite) {
+		List<Rewrite.State> states = rewrite.states();
+		List<Rewrite.Step> steps = rewrite.steps();
+		Counter good = new Counter();
+		Counter bad = new Counter();
+		int count = 0;
+		for(int i = 0; i != steps.size();++i) {
+			Rewrite.Step step = steps.get(i);			
+			int activation = step.activation();
+			Rewrite.Activation a = states.get(step.before()).activation(activation);
+			if(step.before() != step.after()) {
+				Automaton automaton = states.get(step.before()).automaton();
+				System.out.println("-- Step " + count + " (" + a.rule().annotation("name") + ", " + automaton.nStates() + " states) --");				
+				wyrl.util.Runtime.debug(automaton, Solver.SCHEMA, "And", "Or");
+				count = count + 1;
+				good.inc((String) a.rule().annotation("name"));
+			} else {
+				bad.inc((String) a.rule().annotation("name"));
+			}
+		}
+		System.out.println("Successfully applied: ");
+		printCounts(good);
+		System.out.println("\nUnsuccessfully applied: ");
+		printCounts(bad);
+	}
+	
+	private static void printCounts(Counter c) {
+		for(Map.Entry<String, Integer> e : c.counts()) {
+			System.out.println("\t" + e.getKey() + " = " + e.getValue());
+		}
+	}
+	
+	private RewriteRule[] append(RewriteRule[] lhs, RewriteRule[] rhs) {
+		RewriteRule[] rules = new RewriteRule[lhs.length + rhs.length];
+		System.arraycopy(lhs, 0, rules, 0, lhs.length);
+		System.arraycopy(rhs, 0, rules, lhs.length, rhs.length);
+		return rules;
+	}
+
+	/**
+	 * The result of a verification attempt.
+	 * 
+	 * @author David J. Pearce
+	 *
+	 */
+	public static abstract class RESULT {
+		public final int numberOfSteps;
+		public RESULT(int numberOfSteps) {
+			this.numberOfSteps = numberOfSteps;
+		}
+		
+		public static class SAT extends RESULT {
+			public SAT(int numberOfSteps) {
+				super(numberOfSteps);
+			}
+		}
+		
+		public static class UNSAT extends RESULT {
+			public UNSAT(int numberOfSteps) {
+				super(numberOfSteps);
+			}
+		}
+		
+		public static class TIMEOUT extends RESULT {
+			public TIMEOUT(int numberOfSteps) {
+				super(numberOfSteps);
+			}
+		}
+	}
+	
+	private static class Counter {
+		private HashMap<String,Integer> counts = new HashMap<String,Integer>();
+		
+		public void inc(String id) {
+			Integer count = counts.get(id);
+			if(count == null) {
+				count = 0;
+			} 
+			counts.put(id, count+1);
+		}
+		
+		public Set<Map.Entry<String,Integer>> counts() {
+			return counts.entrySet();
+		}
+	}
+}
diff --git a/modules/wycs/src/wycs/util/WycsAntTask.java b/modules/wycs/src/wycs/util/WycsAntTask.java
new file mode 100755
index 0000000000..c35490c2b8
--- /dev/null
+++ b/modules/wycs/src/wycs/util/WycsAntTask.java
@@ -0,0 +1,104 @@
+// Copyright (c) 2012, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wycs.util;
+
+import java.io.*;
+import java.util.*;
+
+
+import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.taskdefs.MatchingTask;
+
+/**
+ * This class implements an baseline ant task for compiling wyal files via ant
+ * and an appropriate build.xml file. The following illustrates how this task
+ * can be used in a build.xml file:
+ *
+ * <pre>
+ *   <taskdef name=\"wycs\" classname=\"wycs.util.WycsAntTask\" classpath=\"src/\"/>
+ *   <wycs wyaldir=\"stdlib/\" includes=\"*\/**.wycs\"/>
+ * </pre>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WycsAntTask extends MatchingTask {
+
+	protected final WycsBuildTask builder;
+
+	public WycsAntTask() {
+		this.builder = new WycsBuildTask();
+	}
+
+	public WycsAntTask(WycsBuildTask builder) {
+		this.builder = builder;
+	}
+
+	public void setWyaldir(File dir) throws IOException {
+		builder.setWyalDir(dir);
+	}
+
+    public void setWycsdir (File dir) throws IOException {
+    	builder.setWycsDir(dir);
+    }
+
+    public void setIncludes(String includes) {
+    	builder.setIncludes(includes);
+    }
+
+    public void setExcludes(String excludes) {
+    	builder.setExcludes(excludes);
+    }
+
+    public void setWycsPath (org.apache.tools.ant.types.Path path) throws IOException {
+    	ArrayList<File> whileypath = new ArrayList<File>();
+    	for(String file : path.list()) {
+    		whileypath.add(new File(file));
+    	}
+    	builder.setWycsPath(whileypath);
+    }
+
+    public void setBootPath (org.apache.tools.ant.types.Path path) throws IOException {
+    	ArrayList<File> bootpath = new ArrayList<File>();
+    	for(String file : path.list()) {
+    		bootpath.add(new File(file));
+    	}
+    	builder.setWycsPath(bootpath);
+    }
+
+    public void setVerbose(boolean b) {
+    	builder.setVerbose(b);
+    }
+
+    public void execute() throws BuildException {
+    	try {
+    		int count = builder.buildAll();
+    		log("Compiled " + count + " source file(s)");
+    	} catch(Exception e) {
+    		throw new BuildException(e);
+    	}
+    }
+}
diff --git a/modules/wycs/src/wycs/util/WycsBuildTask.java b/modules/wycs/src/wycs/util/WycsBuildTask.java
new file mode 100755
index 0000000000..62cce5371b
--- /dev/null
+++ b/modules/wycs/src/wycs/util/WycsBuildTask.java
@@ -0,0 +1,518 @@
+package wycs.util;
+
+import java.io.File;
+import java.io.FileFilter;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import wybs.util.StdBuildRule;
+import wybs.util.StdProject;
+import wycc.lang.Pipeline;
+import wycc.util.Logger;
+import wycs.builders.Wyal2WycsBuilder;
+import wycs.builders.Wycs2WyalBuilder;
+import wycs.core.WycsFile;
+import wycs.syntax.WyalFile;
+import wycs.transforms.*;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.util.DirectoryRoot;
+import wyfs.util.JarFileRoot;
+import wyfs.util.VirtualRoot;
+
+/**
+ * <p>
+ * Provides a general-purpose implementation for compiling Wycs source files
+ * into binary files and verifying them. This is designed to make it easy to
+ * interface with other frameworks (e.g. Ant). This class is designed to be
+ * extended by clients which are providing some kind of compiler extension.
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WycsBuildTask {
+
+	/**
+	 * The purpose of the wyal file filter is simply to ensure only wyal files
+	 * are loaded in a given directory root. It is not strictly necessary for
+	 * correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter wyalFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wyal") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The purpose of the wycs file filter is simply to ensure only wycs files
+	 * are loaded in a given directory root. It is not strictly necessary for
+	 * correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter wycsFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			return f.getName().endsWith(".wycs") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * Default implementation of a content registry. This associates whiley and
+	 * wyil files with their respective content types.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class Registry implements Content.Registry {
+		public void associate(Path.Entry e) {
+			String suffix = e.suffix();
+
+			if (suffix.equals("wyal")) {
+				e.associate(WyalFile.ContentType, null);
+			} else if (suffix.equals("wycs")) {
+				e.associate(WycsFile.ContentType, null);
+			}
+		}
+
+		public String suffix(Content.Type<?> t) {
+			if (t == WyalFile.ContentType) {
+				return "wyal";
+			} else if (t == WycsFile.ContentType) {
+				return "wycs";
+			} else {
+				return "dat";
+			}
+		}
+	}
+
+	public static final List<Pipeline.Template> defaultPipeline = Collections
+			.unmodifiableList(new ArrayList<Pipeline.Template>() {
+				{
+					add(new Pipeline.Template(MacroExpansion.class,
+							Collections.EMPTY_MAP));
+					add(new Pipeline.Template(VerificationCheck.class,
+							Collections.EMPTY_MAP));
+				}
+			});
+
+	/**
+	 * Register default transforms. This is necessary so they can be referred to
+	 * from the command-line using abbreviated names, rather than their full
+	 * names.
+	 */
+	static {
+		Pipeline.register(TypePropagation.class);
+		Pipeline.register(MacroExpansion.class);
+		Pipeline.register(VerificationCheck.class);
+	}
+
+	/**
+	 * The master project content type registry. This is needed for the build
+	 * system to determine the content type of files it finds on the file
+	 * system.
+	 */
+	public final Content.Registry registry;
+
+	/**
+	 * For logging information.
+	 */
+	protected PrintStream logout = System.err;
+
+	/**
+	 * The boot path contains the location of the wycs standard library.
+	 */
+	protected ArrayList<Path.Root> bootpath = new ArrayList<Path.Root>();
+
+	/**
+	 * The wycs path identifies additional items (i.e. libraries or
+	 * directories) which the compiler uses to resolve symbols (e.g. module
+	 * names, functions, etc).
+	 */
+	protected ArrayList<Path.Root> wycspath = new ArrayList<Path.Root>();
+
+	/**
+	 * The wyal source directory is the filesystem directory from which the
+	 * compiler will look for (wyal) source files.
+	 */
+	protected DirectoryRoot wyalDir;
+
+	/**
+	 * The wycs directory is the filesystem directory where all generated wycs
+	 * files will be placed.
+	 */
+	protected Path.Root wycsDir;
+
+	/**
+	 * The pipeline modifiers which will be applied to the default pipeline.
+	 */
+	protected ArrayList<Pipeline.Modifier> pipelineModifiers;
+
+	/**
+	 * Identifies which wyal source files should be considered for verification.
+	 * By default, all files reachable from srcdir are considered.
+	 */
+	protected Content.Filter<WyalFile> wyalIncludes = Content.filter("**",
+			WyalFile.ContentType);
+
+	/**
+	 * Identifies which wyal sources files should not be considered for
+	 * compilation. This overrides any identified by <code>whileyIncludes</code>
+	 * . By default, no files files reachable from srcdir are excluded.
+	 */
+	protected Content.Filter<WyalFile> wyalExcludes = null;
+
+	/**
+	 * Indicates whether or the compiler should produce verbose information
+	 * during compilation. This is generally used for diagnosing bugs in the
+	 * compiler.
+	 */
+	protected boolean verbose = false;
+
+	/**
+	 * Indicates whether or the compiler should produce debugging information
+	 * during compilation. This is generally used for advanced diagnosis of bugs
+	 * in the compiler.
+	 */
+	protected boolean debug = false;
+
+	/**
+	 * In decompilation mode, the build task will generate wyal files from wycs
+	 * files (rather than the other way around).
+	 */
+	protected boolean decompile = false;
+
+	// ==========================================================================
+	// Constructors & Configuration
+	// ==========================================================================
+
+	public WycsBuildTask() {
+		this.registry = new Registry();
+		this.wycsDir = new VirtualRoot(registry);
+	}
+
+	public WycsBuildTask(Content.Registry registry) {
+		this.registry = registry;
+		this.wycsDir = new VirtualRoot(registry);
+	}
+
+	public void setLogOut(PrintStream logout) {
+		this.logout = logout;
+	}
+
+	public void setVerbose(boolean verbose) {
+		this.verbose = verbose;
+	}
+
+	public void setDebug(boolean debug) {
+		this.debug = debug;
+	}
+
+	public void setDecompile(boolean decompile) {
+		this.decompile = decompile;
+	}
+
+	public void setWyalDir(File wyalDir) throws IOException {
+		this.wyalDir = new DirectoryRoot(wyalDir, wyalFileFilter, registry);
+		if (wycsDir instanceof VirtualRoot) {
+			// The point here is to ensure that when this build task is used in
+			// a standalone fashion, that wycs files are actually written to
+			// disk.
+			this.wycsDir = new DirectoryRoot(wyalDir, wycsFileFilter, registry);
+		}
+	}
+
+	public void setWycsDir(File wycsdir) throws IOException {
+		this.wycsDir = new DirectoryRoot(wycsdir, wycsFileFilter, registry);
+	}
+
+	public void setWycsPath(List<File> roots) throws IOException {
+		wycspath.clear();
+		for (File root : roots) {
+			try {
+				if (root.getName().endsWith(".jar")) {
+					wycspath.add(new JarFileRoot(root, registry));
+				} else {
+					wycspath.add(new DirectoryRoot(root, wycsFileFilter,
+							registry));
+				}
+			} catch (IOException e) {
+				if (verbose) {
+					logout.println("Warning: " + root
+							+ " is not a valid package root");
+				}
+			}
+		}
+	}
+
+	public void setBootPath(List<File> roots) throws IOException {
+		bootpath.clear();
+		for (File root : roots) {
+			try {
+				if (root.getName().endsWith(".jar")) {
+					bootpath.add(new JarFileRoot(root, registry));
+				} else {
+					bootpath.add(new DirectoryRoot(root, wyalFileFilter,
+							registry));
+				}
+			} catch (IOException e) {
+				if (verbose) {
+					logout.println("Warning: " + root
+							+ " is not a valid package root");
+				}
+			}
+		}
+	}
+
+	public void setPipelineModifiers(List<Pipeline.Modifier> modifiers) {
+		this.pipelineModifiers = new ArrayList<Pipeline.Modifier>(modifiers);
+	}
+
+	public void setIncludes(String includes) {
+		String[] split = includes.split(",");
+		Content.Filter<WyalFile> wyalFilter = null;
+
+		for (String s : split) {
+			if (s.endsWith(".wyal")) {
+				String name = s.substring(0, s.length() - 5);
+				Content.Filter<WyalFile> nf = Content.filter(name,
+						WyalFile.ContentType);
+				wyalFilter = wyalFilter == null ? nf : Content.or(nf,
+						wyalFilter);
+			}
+		}
+
+		if (wyalFilter != null) {
+			this.wyalIncludes = wyalFilter;
+		}
+	}
+
+	public void setExcludes(String excludes) {
+		String[] split = excludes.split(",");
+		Content.Filter<WyalFile> wyalFilter = null;
+		for (String s : split) {
+			if (s.endsWith(".wyal")) {
+				String name = s.substring(0, s.length() - 5);
+				Content.Filter<WyalFile> nf = Content.filter(name,
+						WyalFile.ContentType);
+				wyalFilter = wyalFilter == null ? nf : Content.or(nf,
+						wyalFilter);
+			}
+		}
+
+		this.wyalExcludes = wyalFilter;
+	}
+
+	// ==========================================================================
+	// Build Methods
+	// ==========================================================================
+
+	/**
+	 * Building the given source files.
+	 *
+	 * @param _args
+	 */
+	public void build(List<File> files) throws Exception {
+		if (decompile) {
+			if (wycsDir instanceof DirectoryRoot) {
+				DirectoryRoot wd = (DirectoryRoot) wycsDir;
+				buildEntries(getMatchingFiles(files, wd, WycsFile.ContentType));
+			} else {
+				System.out
+						.println("WARNING: decompiling without properly specified wycsdir");
+			}
+		} else {
+			buildEntries(getMatchingFiles(files, wyalDir, WyalFile.ContentType));
+		}
+	}
+
+	/**
+	 * Build all source files which have been modified.
+	 *
+	 * @param _args
+	 */
+	public int buildAll() throws Exception {
+		if(decompile) {
+			List<Path.Entry<WycsFile>> delta = getModifiedSourceFiles(wycsDir,
+					Content.filter("**", WycsFile.ContentType), wyalDir,
+					WyalFile.ContentType);
+			buildEntries(delta);
+			return delta.size();
+		} else {
+			List<Path.Entry<WyalFile>> delta = getModifiedSourceFiles(wyalDir,
+					wyalIncludes, wycsDir, WycsFile.ContentType);
+			buildEntries(delta);
+			return delta.size();
+		}
+	}
+
+	protected <T> void buildEntries(List<Path.Entry<T>> delta) throws Exception {
+
+		// ======================================================================
+		// Initialise Project
+		// ======================================================================
+
+		StdProject project = initialiseProject();
+
+		// ======================================================================
+		// Initialise Build Rules
+		// ======================================================================
+
+		if (decompile) {
+			addDecompileBuildRules(project);
+		} else {
+			addCompileBuildRules(project);
+		}
+
+		// ======================================================================
+		// Build!
+		// ======================================================================
+
+		project.build(delta);
+
+		flush();
+	}
+
+	// ==========================================================================
+	// Misc
+	// ==========================================================================
+
+	/**
+	 *
+	 * @return
+	 * @throws IOException
+	 */
+	protected StdProject initialiseProject() throws IOException {
+		ArrayList<Path.Root> roots = new ArrayList<Path.Root>();
+
+		if (wyalDir != null) {
+			roots.add(wyalDir);
+		}
+		roots.add(wycsDir);
+		roots.addAll(wycspath);
+		roots.addAll(bootpath);
+
+		// second, construct the module loader
+		return new StdProject(roots);
+	}
+
+	/**
+	 * Add all build rules to the project. By default, this adds a standard
+	 * build rule for compiling whiley files to wyil files using the
+	 * <code>Whiley2WyilBuilder</code>.
+	 *
+	 * @param project
+	 */
+	protected void addCompileBuildRules(StdProject project) {
+		if (wyalDir != null) {
+			Pipeline pipeline = initialisePipeline();
+
+			if (pipelineModifiers != null) {
+				pipeline.apply(pipelineModifiers);
+			}
+
+			// whileydir can be null if a subclass of this task doesn't
+			// necessarily require it.
+			Wyal2WycsBuilder builder = new Wyal2WycsBuilder(project, pipeline);
+
+			if (verbose) {
+				builder.setLogger(new Logger.Default(System.err));
+			}
+			builder.setDebug(debug);
+
+			project.add(new StdBuildRule(builder, wyalDir, wyalIncludes,
+					wyalExcludes, wycsDir));
+		}
+	}
+
+	protected void addDecompileBuildRules(StdProject project) {
+		if (wycsDir != null) {
+			// whileydir can be null if a subclass of this task doesn't
+			// necessarily require it.
+			Wycs2WyalBuilder builder = new Wycs2WyalBuilder(project);
+
+			if (verbose) {
+				builder.setLogger(new Logger.Default(System.err));
+			}
+			builder.setDebug(debug);
+
+			project.add(new StdBuildRule(builder, wycsDir, Content.filter("**",
+					WycsFile.ContentType), null, wyalDir));
+		}
+	}
+
+	/**
+	 * Initialise the Wyil pipeline to be used for compiling Whiley files. The
+	 * default implementation just returns <code>Pipeline.defaultPipeline</code>
+	 * .
+	 *
+	 * @return
+	 */
+	protected Pipeline initialisePipeline() {
+		return new Pipeline(defaultPipeline);
+	}
+
+	/**
+	 * Generate the list of source files whose modification time is after that
+	 * of their binary counterpart. This is useful for determining which source
+	 * files are out-of-date and should be scheduled for recompiliation.
+	 *
+	 * @return
+	 * @throws IOException
+	 */
+	public static <T,S> List<Path.Entry<T>> getModifiedSourceFiles(
+			Path.Root sourceDir, Content.Filter<T> sourceIncludes,
+			Path.Root binaryDir, Content.Type<S> binaryContentType) throws IOException {
+		// Now, touch all source files which have modification date after
+		// their corresponding binary.
+		ArrayList<Path.Entry<T>> sources = new ArrayList<Path.Entry<T>>();
+
+		for (Path.Entry<T> source : sourceDir.get(sourceIncludes)) {
+			// currently, I'm assuming everything is modified!
+			Path.Entry<S> binary = binaryDir.get(source.id(),
+					binaryContentType);
+			// first, check whether wycs file out-of-date with source file
+			if (binary == null || binary.lastModified() < source.lastModified()) {
+				sources.add(source);
+			}
+		}
+
+		return sources;
+	}
+
+	/**
+	 * Generate the list of matching path entries corresponding to thegiven
+	 * files on the filesystem. If one match cannot be found, an error is
+	 * thrown.
+	 *
+	 * @return
+	 * @throws IOException
+	 */
+	public static <T> List<Path.Entry<T>> getMatchingFiles(
+			List<File> files, DirectoryRoot dir,
+			Content.Type<T> contentType) throws IOException {
+		List<Path.Entry<T>> matches = dir.find(files, contentType);
+		for (int i = 0; i != matches.size(); ++i) {
+			File file = files.get(i);
+			Path.Entry<T> entry = matches.get(i);
+			if (entry == null) {
+				throw new RuntimeException("file not found: " + file);
+			}
+		}
+		return matches;
+	}
+
+	/**
+	 * Flush all built files to disk.
+	 */
+	protected void flush() throws IOException {
+		// NOTE: in principle we want to flush the wyaldir, since in
+		// decompilation mode this results in writing the decompiled file to
+		// disk. However, for now I have disabled this.
+		// wyalDir.flush();
+		wycsDir.flush();
+	}
+}
diff --git a/modules/wycs/stdlib/wycs/core/Array.wyal b/modules/wycs/stdlib/wycs/core/Array.wyal
new file mode 100755
index 0000000000..1a3363bfdf
--- /dev/null
+++ b/modules/wycs/stdlib/wycs/core/Array.wyal
@@ -0,0 +1,13 @@
+package wycs.core
+
+// A helper macro for handling array updates
+define update<T>([T] items, [T] nitems, int i) is:
+    |items| == |nitems|
+    forall(int j):
+        j != i ==> items[j] == nitems[j]
+
+define generate<T>([T] items, T element, int count) is:
+    |items| == count
+    forall(int j):
+        items[j] == element
+
diff --git a/modules/wycs/tests/invalid/test_001.wyal b/modules/wycs/tests/invalid/test_001.wyal
new file mode 100755
index 0000000000..c56b84d8ba
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_001.wyal
@@ -0,0 +1,4 @@
+assert:
+   forall(int x):
+     x >= 0 ==> x > 0
+
diff --git a/modules/wycs/tests/invalid/test_002.wyal b/modules/wycs/tests/invalid/test_002.wyal
new file mode 100755
index 0000000000..5166abccaa
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_002.wyal
@@ -0,0 +1,4 @@
+assert:
+ forall (int x):
+   x > 0 ==> x-1 > 0
+
diff --git a/modules/wycs/tests/invalid/test_003.wyal b/modules/wycs/tests/invalid/test_003.wyal
new file mode 100755
index 0000000000..64ca31aa7a
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_003.wyal
@@ -0,0 +1,4 @@
+assert:
+ forall(int x, int y):
+   (x+1 == y) ==> (x == y+1)
+
diff --git a/modules/wycs/tests/invalid/test_004.wyal b/modules/wycs/tests/invalid/test_004.wyal
new file mode 100755
index 0000000000..48cc9e816b
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_004.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall(int x):
+    x <= 0 ==> x < 0
+
diff --git a/modules/wycs/tests/invalid/test_005.wyal b/modules/wycs/tests/invalid/test_005.wyal
new file mode 100755
index 0000000000..d06a21587e
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_005.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall(int x):
+    x < 0 ==> x+1 < 0
+
diff --git a/modules/wycs/tests/invalid/test_006.wyal b/modules/wycs/tests/invalid/test_006.wyal
new file mode 100755
index 0000000000..069f35cf30
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_006.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall(int x):
+    x >= 0 ==> x*2 > 0
+
diff --git a/modules/wycs/tests/invalid/test_007.wyal b/modules/wycs/tests/invalid/test_007.wyal
new file mode 100755
index 0000000000..8b2ecf516c
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_007.wyal
@@ -0,0 +1,4 @@
+ // requires integer constraint solving
+assert:
+  forall(int x):
+    x < 0 || x >= 1
diff --git a/modules/wycs/tests/invalid/test_008.wyal b/modules/wycs/tests/invalid/test_008.wyal
new file mode 100755
index 0000000000..e66f272dc2
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_008.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x):
+    x >= 0 ==> x != 0
diff --git a/modules/wycs/tests/invalid/test_009.wyal b/modules/wycs/tests/invalid/test_009.wyal
new file mode 100755
index 0000000000..50fb1a55ba
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_009.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x, int y):
+    x >= y ==> x > y
diff --git a/modules/wycs/tests/invalid/test_010.wyal b/modules/wycs/tests/invalid/test_010.wyal
new file mode 100755
index 0000000000..103ca7a432
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_010.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x, int y):
+    x >= y ==> x == y
diff --git a/modules/wycs/tests/invalid/test_011.wyal b/modules/wycs/tests/invalid/test_011.wyal
new file mode 100755
index 0000000000..80c71e26c2
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_011.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x, int y):
+    x != y ==> (x + y == 2 * x)
diff --git a/modules/wycs/tests/invalid/test_012.wyal b/modules/wycs/tests/invalid/test_012.wyal
new file mode 100755
index 0000000000..096be1fd27
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_012.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x, int y):
+    (x == y % 2) ==> x > 0
diff --git a/modules/wycs/tests/invalid/test_013.wyal b/modules/wycs/tests/invalid/test_013.wyal
new file mode 100755
index 0000000000..1a25badc26
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_013.wyal
@@ -0,0 +1,5 @@
+define loop(int x) is x >= 0
+
+assert:
+  forall (int x):
+    loop(x) ==> loop(x-1)
diff --git a/modules/wycs/tests/invalid/test_014.wyal b/modules/wycs/tests/invalid/test_014.wyal
new file mode 100755
index 0000000000..e53307b17e
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_014.wyal
@@ -0,0 +1,5 @@
+define f(int x, int y) is x < y
+
+assert:
+  forall(int x, int y, int z):
+     f(x,z) && f(y,z) ==> f(x,y)
diff --git a/modules/wycs/tests/invalid/test_015.wyal b/modules/wycs/tests/invalid/test_015.wyal
new file mode 100755
index 0000000000..16d9f14fad
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_015.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall(int x):
+    x <= 0 ==> -x > 0
+
diff --git a/modules/wycs/tests/invalid/test_016.wyal b/modules/wycs/tests/invalid/test_016.wyal
new file mode 100755
index 0000000000..0141c29953
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_016.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x):
+    x > 0 ==> x >= 2
diff --git a/modules/wycs/tests/invalid/test_017.wyal b/modules/wycs/tests/invalid/test_017.wyal
new file mode 100755
index 0000000000..b95cdcda26
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_017.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x):
+    x * x > 0
diff --git a/modules/wycs/tests/invalid/test_018.wyal b/modules/wycs/tests/invalid/test_018.wyal
new file mode 100755
index 0000000000..02df04763f
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_018.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(bool x):
+    x == !x
diff --git a/modules/wycs/tests/invalid/test_019.wyal b/modules/wycs/tests/invalid/test_019.wyal
new file mode 100755
index 0000000000..38899660b6
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_019.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall(int x, int y):
+   (x <= y && y <= x+1) ==> x == y
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_020.wyal b/modules/wycs/tests/invalid/test_020.wyal
new file mode 100755
index 0000000000..7554a8f409
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_020.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (int x):
+        if:
+            x + 1 >= 0
+            (2 * x) + 2 <= 0
+        then:
+            x == 0
diff --git a/modules/wycs/tests/invalid/test_050.wyal b/modules/wycs/tests/invalid/test_050.wyal
new file mode 100755
index 0000000000..3e5bf6f1cc
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_050.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs):
+    xs == {} ==> |xs| == 1
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_051.wyal b/modules/wycs/tests/invalid/test_051.wyal
new file mode 100755
index 0000000000..4ce48ade60
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_051.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs):
+    |xs| == 1 ==> xs == {}
diff --git a/modules/wycs/tests/invalid/test_052.wyal b/modules/wycs/tests/invalid/test_052.wyal
new file mode 100755
index 0000000000..51f7cb83a3
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_052.wyal
@@ -0,0 +1,2 @@
+assert:
+  |{1,1}| == 2
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_053.wyal b/modules/wycs/tests/invalid/test_053.wyal
new file mode 100755
index 0000000000..d582368de8
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_053.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} ys, {int} xs):
+    xs ⊆ ys ==> |xs| < |ys|
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_054.wyal b/modules/wycs/tests/invalid/test_054.wyal
new file mode 100755
index 0000000000..a4e4af635b
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_054.wyal
@@ -0,0 +1,7 @@
+assert:
+  forall ({int} xs, {int} ys, {int} zs):
+    if:
+       xs ⊆ ys
+       zs ⊆ ys
+    then:
+       xs ⊆ zs
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_055.wyal b/modules/wycs/tests/invalid/test_055.wyal
new file mode 100755
index 0000000000..b203fba77a
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_055.wyal
@@ -0,0 +1,7 @@
+assert:
+  forall({int} xs, {int} ys):
+    if:
+       xs ⊆ ys
+       ys ⊆ xs
+    then:
+       xs != ys
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_056.wyal b/modules/wycs/tests/invalid/test_056.wyal
new file mode 100755
index 0000000000..aaa293e066
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_056.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs, {int} ys):
+    xs ⊆ ys ==> xs ⊂ ys
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_057.wyal b/modules/wycs/tests/invalid/test_057.wyal
new file mode 100755
index 0000000000..30e821c67b
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_057.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs, {int} ys):
+    xs ⊂ ys ==> |xs| > |ys|
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_058.wyal b/modules/wycs/tests/invalid/test_058.wyal
new file mode 100755
index 0000000000..4b60f2dae9
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_058.wyal
@@ -0,0 +1,7 @@
+assert:
+  forall ({int} xs):
+    if:
+       |xs| == 0
+    then:
+      exists(int x):
+         x in xs
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_059.wyal b/modules/wycs/tests/invalid/test_059.wyal
new file mode 100755
index 0000000000..7bcbd0434b
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_059.wyal
@@ -0,0 +1,11 @@
+define NatSet({int} xs) is:
+   forall (int x):
+     x in xs ==> x >= 0
+
+assert:
+  forall(int x, {int} xs):
+    if:
+       NatSet(xs)
+       x in xs
+    then:
+       x > 0
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_060.wyal b/modules/wycs/tests/invalid/test_060.wyal
new file mode 100755
index 0000000000..bb1ffb6f14
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_060.wyal
@@ -0,0 +1,11 @@
+define NatSet({int} xs) is:
+  forall(int x):
+    x in xs ==> x >= 0
+
+define PosSet({int} xs) is:
+  forall(int x):
+    x in xs ==> x > 0
+
+assert:
+   forall ({int} xs):
+       NatSet(xs) ==> PosSet(xs)
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_061.wyal b/modules/wycs/tests/invalid/test_061.wyal
new file mode 100755
index 0000000000..04c07d0075
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_061.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall(int x, {int} xs, {int} ys):
+       (x in xs && ys ⊆ xs) ==> x in ys
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_062.wyal b/modules/wycs/tests/invalid/test_062.wyal
new file mode 100755
index 0000000000..5f7a0d183a
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_062.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs, {int} ys):
+       xs ⊆ ys ==> |ys| > 0
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_063.wyal b/modules/wycs/tests/invalid/test_063.wyal
new file mode 100755
index 0000000000..886bdd0c46
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_063.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs):
+    |xs| >= 0 ==> |xs| > 0
diff --git a/modules/wycs/tests/invalid/test_064.wyal b/modules/wycs/tests/invalid/test_064.wyal
new file mode 100755
index 0000000000..06fca5c88b
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_064.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs):
+    |xs| > 0
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_065.wyal b/modules/wycs/tests/invalid/test_065.wyal
new file mode 100755
index 0000000000..79675267fe
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_065.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs, {int} ys):
+    xs ⊆ ys ==> |xs| >= |ys|
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_066.wyal b/modules/wycs/tests/invalid/test_066.wyal
new file mode 100755
index 0000000000..3aab3fc98c
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_066.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall({int} xs, {int} ys):
+    xs ⊆ ys ==> xs == ys
\ No newline at end of file
diff --git a/modules/wycs/tests/invalid/test_100.wyal b/modules/wycs/tests/invalid/test_100.wyal
new file mode 100755
index 0000000000..5509559de4
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_100.wyal
@@ -0,0 +1,19 @@
+define Map({(int,int)} pairs) is:
+  forall(int i1, int i2, int v1, int v2):
+    if:
+      (i1, v1) in pairs
+      (i2, v2) in pairs
+    then:
+      i1 != i2 || v1 == v2
+
+define List({(int,int)} pairs) is:
+  Map(pairs)
+  forall(int i, int v):
+    if:
+      (i, v) in pairs
+    then:
+      i ≥ 0
+      i < |pairs|
+
+assert Map({(2, 3), (2, 4)})
+assert List({(0, 3), (2, 4)})
diff --git a/modules/wycs/tests/invalid/test_101.wyal b/modules/wycs/tests/invalid/test_101.wyal
new file mode 100755
index 0000000000..ee98285d1a
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_101.wyal
@@ -0,0 +1,21 @@
+define Map({(int,int)} pairs) is:
+  forall(int i1, int i2, int v1, int v2):
+    if:
+      (i1, v1) in pairs
+      (i2, v2) in pairs
+    then:
+      i1 != i2 || v1 == v2
+
+define List({(int,int)} pairs) is:
+  Map(pairs)
+  forall(int i, int v):
+    if:
+      (i, v) in pairs
+    then:
+      i ≥ 0
+      i < |pairs|
+
+assert:
+   forall({int,int} xs):
+     Map(xs) ==> List(xs)
+
diff --git a/modules/wycs/tests/invalid/test_102.wyal b/modules/wycs/tests/invalid/test_102.wyal
new file mode 100755
index 0000000000..bd04f4bcf6
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_102.wyal
@@ -0,0 +1,13 @@
+define Bijection({int,int} pairs) is:
+  forall(int i1, int i2, int v1, int v2):
+    if:
+      (i1, v1) in pairs
+      (i2, v2) in pairs
+      (i1,v1) != (i2,v2)
+    then:
+      i1 != i2
+      v1 != v2
+
+assert Bijection({(1,2),(2,2),(3,4)})
+
+
diff --git a/modules/wycs/tests/invalid/test_103.wyal b/modules/wycs/tests/invalid/test_103.wyal
new file mode 100755
index 0000000000..3263e16f9a
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_103.wyal
@@ -0,0 +1,24 @@
+define Map<K,V> ({K,V} pairs) is:
+  forall(K k1, V v1, K k2, V v2):
+    if:
+      (k1,v1) in pairs
+      (k2,v2) in pairs
+      k1 == k2
+    then:
+      v1 == v2
+
+define Bijection({int,int} pairs) is:
+  forall(int i1, int i2, int v1, int v2):
+    if:
+      (i1, v1) in pairs
+      (i2, v2) in pairs
+      (i1,v1) != (i2,v2)
+    then:
+      i1 != i2
+      v1 != v2
+
+assert:
+  forall({int,int} pairs):
+    Map<int,int>(pairs) ==> Bijection(pairs)
+
+
diff --git a/modules/wycs/tests/invalid/test_104.wyal b/modules/wycs/tests/invalid/test_104.wyal
new file mode 100755
index 0000000000..1fe0c14112
--- /dev/null
+++ b/modules/wycs/tests/invalid/test_104.wyal
@@ -0,0 +1,11 @@
+define Closure({int,int} pairs) is:
+  forall(int x, int y, int z):
+    if:
+      (x, y) in pairs
+      (y, z) in pairs
+    then:
+      (x,z) in pairs
+
+assert Closure({(1,2),(2,3)})
+
+
diff --git a/modules/wycs/tests/valid/test_106.wyal b/modules/wycs/tests/valid/test_106.wyal
new file mode 100755
index 0000000000..797ee93239
--- /dev/null
+++ b/modules/wycs/tests/valid/test_106.wyal
@@ -0,0 +1,3 @@
+import wycs.core.List
+
+assert List<int>([3,4] ++ [2])
diff --git a/modules/wycs/tests/valid/test_arith_01.wyal b/modules/wycs/tests/valid/test_arith_01.wyal
new file mode 100755
index 0000000000..c6a46740e6
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_01.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall (int x):
+    x > 0 ==> x >= 0
+
diff --git a/modules/wycs/tests/valid/test_arith_02.wyal b/modules/wycs/tests/valid/test_arith_02.wyal
new file mode 100755
index 0000000000..5bff5b66a0
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_02.wyal
@@ -0,0 +1,5 @@
+assert:
+    forall (int x):
+       x > 0 ==> x+1 > 0
+
+
diff --git a/modules/wycs/tests/valid/test_arith_03.wyal b/modules/wycs/tests/valid/test_arith_03.wyal
new file mode 100755
index 0000000000..ab818d07c3
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_03.wyal
@@ -0,0 +1,4 @@
+assert:
+    forall (int x, int y):
+       (x+1 == y) ==> (x == y-1)
+
diff --git a/modules/wycs/tests/valid/test_arith_04.wyal b/modules/wycs/tests/valid/test_arith_04.wyal
new file mode 100755
index 0000000000..8ff01de7fd
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_04.wyal
@@ -0,0 +1,5 @@
+assert:
+    forall (int x):
+       x < 0 ==> x <= 0
+
+
diff --git a/modules/wycs/tests/valid/test_arith_05.wyal b/modules/wycs/tests/valid/test_arith_05.wyal
new file mode 100755
index 0000000000..6a78af6b2b
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_05.wyal
@@ -0,0 +1,4 @@
+assert:
+    forall (int x):
+       x < 0 ==> x-1 < 0
+
diff --git a/modules/wycs/tests/valid/test_arith_06.wyal b/modules/wycs/tests/valid/test_arith_06.wyal
new file mode 100755
index 0000000000..ed52208d5f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_06.wyal
@@ -0,0 +1,4 @@
+assert:
+    forall (int x):
+       x > 0 ==> x*2 > 0
+
diff --git a/modules/wycs/tests/valid/test_arith_07.wyal b/modules/wycs/tests/valid/test_arith_07.wyal
new file mode 100755
index 0000000000..1a732fb973
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_07.wyal
@@ -0,0 +1,4 @@
+ // requires integer constraint solving
+assert:
+    forall (int x):
+       x <= 0 || x >= 1
diff --git a/modules/wycs/tests/valid/test_arith_08.wyal b/modules/wycs/tests/valid/test_arith_08.wyal
new file mode 100755
index 0000000000..9dca1dac6b
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_08.wyal
@@ -0,0 +1,3 @@
+assert:
+    forall (int x):
+       x > 0 ==> x != 0
diff --git a/modules/wycs/tests/valid/test_arith_09.wyal b/modules/wycs/tests/valid/test_arith_09.wyal
new file mode 100755
index 0000000000..f600cd1999
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_09.wyal
@@ -0,0 +1,3 @@
+assert:
+    forall (int x, int y):
+       (x > y) ==> (x >= y)
diff --git a/modules/wycs/tests/valid/test_arith_10.wyal b/modules/wycs/tests/valid/test_arith_10.wyal
new file mode 100755
index 0000000000..97d7b1fc58
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_10.wyal
@@ -0,0 +1,3 @@
+assert:
+    forall (int x, int y):
+       (x == y) ==> (x >= y)
diff --git a/modules/wycs/tests/valid/test_arith_11.wyal b/modules/wycs/tests/valid/test_arith_11.wyal
new file mode 100755
index 0000000000..a95751cfeb
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_11.wyal
@@ -0,0 +1,4 @@
+assert:
+   forall (int x, int y):
+       (x == y) ==> (x + y == 2 * x)
+
diff --git a/modules/wycs/tests/valid/test_arith_12.wyal b/modules/wycs/tests/valid/test_arith_12.wyal
new file mode 100755
index 0000000000..756527be01
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_12.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall (int x, int y):
+       (x == y % 2) ==> (x >= 0 && x < 2)
diff --git a/modules/wycs/tests/valid/test_arith_13.wyal b/modules/wycs/tests/valid/test_arith_13.wyal
new file mode 100755
index 0000000000..aee0ccd0be
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_13.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall (int x):
+       x < 0 ==> -x > 0
diff --git a/modules/wycs/tests/valid/test_arith_14.wyal b/modules/wycs/tests/valid/test_arith_14.wyal
new file mode 100755
index 0000000000..cfcdf1ffc8
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_14.wyal
@@ -0,0 +1,4 @@
+assert:
+  forall (int x):
+       x > 0 ==> x >= 1
+
diff --git a/modules/wycs/tests/valid/test_arith_15.wyal b/modules/wycs/tests/valid/test_arith_15.wyal
new file mode 100755
index 0000000000..171539fb52
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_15.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall (int x):
+       x * x >= 0
diff --git a/modules/wycs/tests/valid/test_arith_16.wyal b/modules/wycs/tests/valid/test_arith_16.wyal
new file mode 100755
index 0000000000..1e9aa6d8be
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_16.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall (int x, int y):
+       (x <= y && y <= x) ==> x == y
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_arith_17.wyal b/modules/wycs/tests/valid/test_arith_17.wyal
new file mode 100755
index 0000000000..cf3664c9d3
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_17.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall (int x, int y, int z):
+    z == x - y && 0 <= x - y ==> 0 <= z
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_arith_18.wyal b/modules/wycs/tests/valid/test_arith_18.wyal
new file mode 100755
index 0000000000..eafda24417
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_18.wyal
@@ -0,0 +1,5 @@
+assert:
+  forall (int x):
+    x > 0
+    x < 2
+    x != 1
diff --git a/modules/wycs/tests/valid/test_arith_19.wyal b/modules/wycs/tests/valid/test_arith_19.wyal
new file mode 100755
index 0000000000..b888cf79b4
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_19.wyal
@@ -0,0 +1,7 @@
+type pos is (int x) where x > 0
+
+assert:
+    forall (pos r0):
+            r0 >= 0
+
+
diff --git a/modules/wycs/tests/valid/test_arith_20.wyal b/modules/wycs/tests/valid/test_arith_20.wyal
new file mode 100755
index 0000000000..10c43b1a30
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_20.wyal
@@ -0,0 +1,8 @@
+assert "constraint not satisfied":
+    forall (int r0):
+        if:
+            r0 >= 0
+        then:
+            r0 * 16 >= 0
+
+
diff --git a/modules/wycs/tests/valid/test_arith_21.wyal b/modules/wycs/tests/valid/test_arith_21.wyal
new file mode 100755
index 0000000000..aeece49209
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_21.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall (int x):
+     x < 0 || x > 0 || x == 0
diff --git a/modules/wycs/tests/valid/test_arith_22.wyal b/modules/wycs/tests/valid/test_arith_22.wyal
new file mode 100755
index 0000000000..9f1cb89da3
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_22.wyal
@@ -0,0 +1,8 @@
+assert:
+   forall (int x):
+     if:
+        x <= 0
+        2*x >= 0
+     then:
+        x == 0
+
diff --git a/modules/wycs/tests/valid/test_arith_23.wyal b/modules/wycs/tests/valid/test_arith_23.wyal
new file mode 100755
index 0000000000..69aeda6533
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_23.wyal
@@ -0,0 +1,10 @@
+assert:
+   forall (int x,int y,int z):
+     if:
+        x == y + z
+        y >= 0
+        z >= 0
+     then:
+        x >= y
+        x >= z
+
diff --git a/modules/wycs/tests/valid/test_arith_24.wyal b/modules/wycs/tests/valid/test_arith_24.wyal
new file mode 100755
index 0000000000..4da942467f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_24.wyal
@@ -0,0 +1,10 @@
+assert:
+   forall (int x,int y,int z):
+     if:
+        x == y + z
+        y > 0
+        z > 0
+     then:
+        x > y
+        x > z
+
diff --git a/modules/wycs/tests/valid/test_arith_25.wyal b/modules/wycs/tests/valid/test_arith_25.wyal
new file mode 100755
index 0000000000..1a420766d7
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_25.wyal
@@ -0,0 +1,8 @@
+assert:
+   forall (int x,int y,int z):
+     if:
+        x == y + z
+        x > y
+     then:
+        z > 0
+
diff --git a/modules/wycs/tests/valid/test_arith_26.wyal b/modules/wycs/tests/valid/test_arith_26.wyal
new file mode 100755
index 0000000000..da8174533e
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_26.wyal
@@ -0,0 +1,8 @@
+assert:
+   forall (int x,int y,int z):
+     if:
+        x == y + z
+        x != y
+     then:
+        z != 0
+
diff --git a/modules/wycs/tests/valid/test_arith_27.wyal b/modules/wycs/tests/valid/test_arith_27.wyal
new file mode 100755
index 0000000000..9901a80d9d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_27.wyal
@@ -0,0 +1,10 @@
+assert:
+   forall (int x):
+     if:
+        // when premise is false
+        x > 0
+        x < 0
+     then:
+        // you can prove anything!
+        x == 123
+
diff --git a/modules/wycs/tests/valid/test_arith_28.wyal b/modules/wycs/tests/valid/test_arith_28.wyal
new file mode 100755
index 0000000000..4c617a811f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_28.wyal
@@ -0,0 +1,10 @@
+assert:
+   forall (int x, int y):
+     if:
+        // when premise is false...
+        x == 2*y
+        x == 1
+     then:
+        // ...you can prove anything!
+        x == 123
+
diff --git a/modules/wycs/tests/valid/test_arith_29.wyal b/modules/wycs/tests/valid/test_arith_29.wyal
new file mode 100755
index 0000000000..7c067fb6d2
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_29.wyal
@@ -0,0 +1,7 @@
+assert:
+     forall (int x, int y):
+        if:
+           x == y - 1
+        then:
+           x < y
+
diff --git a/modules/wycs/tests/valid/test_arith_30.wyal b/modules/wycs/tests/valid/test_arith_30.wyal
new file mode 100755
index 0000000000..8f287e520f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_30.wyal
@@ -0,0 +1,7 @@
+assert "assertion failed":
+    forall (int r0, int r1):
+        if:
+            r0 == 2 * r1
+        then:
+            2 * r1 + 1 == r0 + 2
+
diff --git a/modules/wycs/tests/valid/test_arith_31.wyal b/modules/wycs/tests/valid/test_arith_31.wyal
new file mode 100755
index 0000000000..b62cce6d1d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_31.wyal
@@ -0,0 +1,8 @@
+assert:
+    forall (int r0, int r1):
+        if:
+            r0 >= 0
+            r1 >= 0
+        then:
+            0 <= r0 * r1
+
diff --git a/modules/wycs/tests/valid/test_arith_32.wyal b/modules/wycs/tests/valid/test_arith_32.wyal
new file mode 100755
index 0000000000..810dd978a9
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_32.wyal
@@ -0,0 +1,6 @@
+assert:
+    forall (int i, int r):
+        if:
+            r == 2 * i
+        then:
+            r + 2 == 2 * (i + 1)
diff --git a/modules/wycs/tests/valid/test_arith_33.wyal b/modules/wycs/tests/valid/test_arith_33.wyal
new file mode 100755
index 0000000000..d65818b131
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_33.wyal
@@ -0,0 +1,6 @@
+assert "division by zero":
+    forall int r1:
+        if:
+            r1 > 0
+        then:
+            ((real) r1) != 0.0
diff --git a/modules/wycs/tests/valid/test_arith_34.wyal b/modules/wycs/tests/valid/test_arith_34.wyal
new file mode 100755
index 0000000000..9c346c60a5
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_34.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (int x):
+        if:
+            x + 1 >= 0
+            (2 * x) + 2 <= 0
+        then:
+            x + 1 == 0
diff --git a/modules/wycs/tests/valid/test_arith_35.wyal b/modules/wycs/tests/valid/test_arith_35.wyal
new file mode 100755
index 0000000000..31239d2ca6
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_35.wyal
@@ -0,0 +1,8 @@
+assert:
+    forall (int x, [int] xs):
+        if:
+            x + 1 >= 0
+            (2 * x) + 2 <= 0
+            xs[x+1] == 0
+        then:
+            xs[0] == 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_arith_36.wyal b/modules/wycs/tests/valid/test_arith_36.wyal
new file mode 100755
index 0000000000..6943f02b93
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_36.wyal
@@ -0,0 +1,22 @@
+type nat is (int n) where n >= 0
+
+// Following verification conditions taken from sumax benchmark
+
+define invariant(int sum, int max, int k) is:
+    sum <= (max * k)
+
+assert:
+    forall(nat k, nat sum, nat max, nat item):
+        if:
+            invariant(sum,max,k)
+            item < max
+        then:
+            invariant(sum + item,max,k+1)
+
+assert:
+    forall (nat k, nat sum, nat item, nat max):
+        if:
+                invariant(sum, max, k)
+                max <= item
+        then:
+            invariant(sum + item, item, k + 1)
diff --git a/modules/wycs/tests/valid/test_arith_37.wyal b/modules/wycs/tests/valid/test_arith_37.wyal
new file mode 100755
index 0000000000..4d5fbae4c4
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_37.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (int x):
+        if:
+            x + 1 >= 0
+            x + 1 <= 0
+        then:
+            x + 1 == 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_arith_38.wyal b/modules/wycs/tests/valid/test_arith_38.wyal
new file mode 100755
index 0000000000..6190a6d413
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_38.wyal
@@ -0,0 +1,12 @@
+type nat is (int n) where n >= 0
+
+// Following verification conditions taken from sumax benchmark
+
+assert:
+    forall (nat k, nat sum, nat item, nat max):
+        if:
+            sum <= max * k
+            max <= item
+        then:
+            sum <= item * k
+
diff --git a/modules/wycs/tests/valid/test_arith_39.wyal b/modules/wycs/tests/valid/test_arith_39.wyal
new file mode 100755
index 0000000000..c8b918a54e
--- /dev/null
+++ b/modules/wycs/tests/valid/test_arith_39.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (int k, int sum, int j, int max):
+        if:
+            sum * j <= max * k
+        then:
+            sum * j <= max * k
+
diff --git a/modules/wycs/tests/valid/test_bool_01.wyal b/modules/wycs/tests/valid/test_bool_01.wyal
new file mode 100755
index 0000000000..f3477d6dfb
--- /dev/null
+++ b/modules/wycs/tests/valid/test_bool_01.wyal
@@ -0,0 +1,4 @@
+assert:
+   forall (bool x):
+       x == !!x
+
diff --git a/modules/wycs/tests/valid/test_fun_01.wyal b/modules/wycs/tests/valid/test_fun_01.wyal
new file mode 100755
index 0000000000..de32a174b7
--- /dev/null
+++ b/modules/wycs/tests/valid/test_fun_01.wyal
@@ -0,0 +1,9 @@
+function abs (int x) -> (int y)
+ensures:
+   x >= 0 ==> y > 0
+
+assert:
+  forall (int x):
+     x >= 0 ==> abs(x) > 0
+
+
diff --git a/modules/wycs/tests/valid/test_fun_02.wyal b/modules/wycs/tests/valid/test_fun_02.wyal
new file mode 100755
index 0000000000..447e047ebf
--- /dev/null
+++ b/modules/wycs/tests/valid/test_fun_02.wyal
@@ -0,0 +1,7 @@
+function indexOf([int] src, int i) -> (int r)
+ensures:
+    src[i] == r
+
+assert:
+  forall ([int] xs, int i):
+    indexOf(xs,i) > 0 ==> indexOf(xs,i) >= 0
diff --git a/modules/wycs/tests/valid/test_list_01.wyal b/modules/wycs/tests/valid/test_list_01.wyal
new file mode 100755
index 0000000000..2ff12aa561
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_01.wyal
@@ -0,0 +1,9 @@
+import wycs.core.Array
+
+assert:
+  forall ([int] xs, [int] ys):
+    if:
+        Array.<int>update(xs,ys,0)
+        ys[0] == 0
+    then:
+        ys[0] == 0
diff --git a/modules/wycs/tests/valid/test_list_02.wyal b/modules/wycs/tests/valid/test_list_02.wyal
new file mode 100755
index 0000000000..249a950f2b
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_02.wyal
@@ -0,0 +1,14 @@
+import wycs.core.Array
+
+assert "constraint not satisfied":
+    forall([int] xs, [int] ys):
+       if:
+          forall (int i):
+            xs[i] >= 0
+          Array.<int>update(xs,ys,0)
+          ys[0] == 1
+       then:           
+          forall (int j):
+             ys[j] >= 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_05.wyal b/modules/wycs/tests/valid/test_list_05.wyal
new file mode 100755
index 0000000000..4b3730b7cd
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_05.wyal
@@ -0,0 +1,5 @@
+import wycs.core.Map
+
+assert:
+  forall ([int] xs, int i):
+     xs[i] > 0 ==> xs[i] >= 0
diff --git a/modules/wycs/tests/valid/test_list_06.wyal b/modules/wycs/tests/valid/test_list_06.wyal
new file mode 100755
index 0000000000..43cb5d9fff
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_06.wyal
@@ -0,0 +1,7 @@
+assert:
+  forall ([int] xs):
+    if:
+      |xs| > 0
+    then:
+      exists (int v):
+        xs[0] == v
diff --git a/modules/wycs/tests/valid/test_list_08.wyal b/modules/wycs/tests/valid/test_list_08.wyal
new file mode 100755
index 0000000000..064239e540
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_08.wyal
@@ -0,0 +1,2 @@
+assert "precondition not satisfied":
+        [true][0] == true
diff --git a/modules/wycs/tests/valid/test_list_13.wyal b/modules/wycs/tests/valid/test_list_13.wyal
new file mode 100755
index 0000000000..83970bab9a
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_13.wyal
@@ -0,0 +1,8 @@
+assert:
+    forall([int] xs):
+        if:
+            forall(int i2):
+                   xs[i2] >= 0
+        then:
+            xs[0] >= 0
+
diff --git a/modules/wycs/tests/valid/test_list_14.wyal b/modules/wycs/tests/valid/test_list_14.wyal
new file mode 100755
index 0000000000..4df8263d12
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_14.wyal
@@ -0,0 +1,18 @@
+function test_sum([int], int) -> int
+
+assert "postcondition not satisfied":
+    forall ([int] xs):
+        if:
+            exists (int i1):
+                xs[i1] < 0
+            case:
+                false == true
+                exists (int i2):
+                    xs[i2] < 0
+            case:
+                forall (int i3):
+                    xs[i3] >= 0
+        then:
+            false
+
+
diff --git a/modules/wycs/tests/valid/test_list_15.wyal b/modules/wycs/tests/valid/test_list_15.wyal
new file mode 100755
index 0000000000..857d03f7fe
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_15.wyal
@@ -0,0 +1,18 @@
+function test_sum([int], int) -> int
+
+assert:
+    forall ([int] xs, int x):
+        if:
+            test_sum(xs, x + 1) >= 0
+            exists (int i1, int v1):
+                xs[i1] == v1
+                v1 < 0
+            forall (int i2, int v2):
+                if:
+                    xs[i2] == v2
+                then:
+                    v2 >= 0
+        then:
+            (xs[x] + test_sum(xs, x + 1)) >= 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_16.wyal b/modules/wycs/tests/valid/test_list_16.wyal
new file mode 100755
index 0000000000..3e308efabd
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_16.wyal
@@ -0,0 +1,12 @@
+assert "postcondition not satisfied":
+    forall ([int] xs, int x, int index):
+        if:
+            forall (int i):
+                if:
+                    i == 0
+                then:
+                    x != xs[i]
+            xs[index] == x
+            index == 0
+        then:
+            false == true
diff --git a/modules/wycs/tests/valid/test_list_17.wyal b/modules/wycs/tests/valid/test_list_17.wyal
new file mode 100755
index 0000000000..1894941a85
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_17.wyal
@@ -0,0 +1,8 @@
+assert "postcondition not satisfied":
+    forall ([int] xs, int c, int j):
+        if:
+            forall (int k, int i):
+                c != xs[i]
+            xs[j] == c
+        then:
+            false == true
diff --git a/modules/wycs/tests/valid/test_list_18.wyal b/modules/wycs/tests/valid/test_list_18.wyal
new file mode 100755
index 0000000000..45580cfc28
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_18.wyal
@@ -0,0 +1,4 @@
+assert:
+    forall [int] r0:
+        |r0| != 0 ==> 0 < |r0|
+
diff --git a/modules/wycs/tests/valid/test_list_19.wyal b/modules/wycs/tests/valid/test_list_19.wyal
new file mode 100755
index 0000000000..146eda8b61
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_19.wyal
@@ -0,0 +1,11 @@
+type nat is (int r0) where:
+    r0 >= 0
+
+assert "postcondition not satisfied":
+    forall ([nat] items, int i):
+        if:
+            i >= 0
+            i < |items|
+        then:
+            items[i] >= 0
+
diff --git a/modules/wycs/tests/valid/test_list_20.wyal b/modules/wycs/tests/valid/test_list_20.wyal
new file mode 100755
index 0000000000..761fa36bcb
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_20.wyal
@@ -0,0 +1,10 @@
+assert "loop invariant not restored":
+    forall (int item, [int] items):
+        if:
+            forall(int j):
+                items[j] == 0
+        then:
+            forall(int j):
+                items[j] == 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_21.wyal b/modules/wycs/tests/valid/test_list_21.wyal
new file mode 100755
index 0000000000..c216fdfcae
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_21.wyal
@@ -0,0 +1,3 @@
+assert:
+   forall ([int] xs, int x):
+      (x <= |xs| && x != |xs|) ==> x + 1 <= |xs|
diff --git a/modules/wycs/tests/valid/test_list_22.wyal b/modules/wycs/tests/valid/test_list_22.wyal
new file mode 100755
index 0000000000..53aa461192
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_22.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall ([int] xs):
+    xs == [] ==> |xs| == 0
diff --git a/modules/wycs/tests/valid/test_list_23.wyal b/modules/wycs/tests/valid/test_list_23.wyal
new file mode 100755
index 0000000000..1aae0738eb
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_23.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall([int] xs):
+       |xs| == 0 ==> xs == []
diff --git a/modules/wycs/tests/valid/test_list_24.wyal b/modules/wycs/tests/valid/test_list_24.wyal
new file mode 100755
index 0000000000..43ed3d4de4
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_24.wyal
@@ -0,0 +1,2 @@
+assert:
+  |[1]| == 1
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_list_25.wyal b/modules/wycs/tests/valid/test_list_25.wyal
new file mode 100755
index 0000000000..bc2493030b
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_25.wyal
@@ -0,0 +1,8 @@
+assert "constraint not satisfied":
+    forall [int] xs, int i:
+            if:
+                i >= 0
+                i < |xs|
+                |xs| == 0
+            then:
+                xs[i] >= 0
diff --git a/modules/wycs/tests/valid/test_list_26.wyal b/modules/wycs/tests/valid/test_list_26.wyal
new file mode 100755
index 0000000000..d9148025a7
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_26.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall ([int] xs):
+       |xs| > 0 ==> exists(int i, int v) ; xs[i] == v
diff --git a/modules/wycs/tests/valid/test_list_27.wyal b/modules/wycs/tests/valid/test_list_27.wyal
new file mode 100755
index 0000000000..e2e7cdd879
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_27.wyal
@@ -0,0 +1,10 @@
+define NatList([int] xs) is:
+  forall (int i):
+    xs[i] >= 0
+
+assert:
+  forall ([int] xs, int i):
+       if:        
+         NatList(xs)
+       then:
+         xs[i] >= 0
diff --git a/modules/wycs/tests/valid/test_list_28.wyal b/modules/wycs/tests/valid/test_list_28.wyal
new file mode 100755
index 0000000000..0737c5d40e
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_28.wyal
@@ -0,0 +1,11 @@
+define NatList([int] xs) is:
+  forall (int i):
+      xs[i] >= 0
+
+define PosSet([int] xs) is:
+  forall (int i):
+      xs[i] > 0
+
+assert:
+  forall ([int] xs):
+    PosSet(xs) ==> NatList(xs)
diff --git a/modules/wycs/tests/valid/test_list_29.wyal b/modules/wycs/tests/valid/test_list_29.wyal
new file mode 100755
index 0000000000..9f98d7dc97
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_29.wyal
@@ -0,0 +1,6 @@
+define In<T>(T x, [T] xs) is:
+  exists(int i):
+     xs[i] == x
+
+assert:
+  In<int>(1,[1,2])
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_list_30.wyal b/modules/wycs/tests/valid/test_list_30.wyal
new file mode 100755
index 0000000000..24990b75f4
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_30.wyal
@@ -0,0 +1,3 @@
+assert:
+  forall ([int] xs):
+    |xs| >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_list_31.wyal b/modules/wycs/tests/valid/test_list_31.wyal
new file mode 100755
index 0000000000..00edb2c7b9
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_31.wyal
@@ -0,0 +1,8 @@
+assert:
+  forall([int] xs):
+    if:
+      forall (int i):
+        xs[i] >= 0
+    then:
+      !(exists(int i) ; xs[i] < 0)
+
diff --git a/modules/wycs/tests/valid/test_list_32.wyal b/modules/wycs/tests/valid/test_list_32.wyal
new file mode 100755
index 0000000000..2adbfef4f0
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_32.wyal
@@ -0,0 +1,6 @@
+assert "index out of bounds (not less than length)":
+    forall([int] r0):
+        if:
+            |r0| > 0
+        then:
+            0 < |r0|
diff --git a/modules/wycs/tests/valid/test_list_33.wyal b/modules/wycs/tests/valid/test_list_33.wyal
new file mode 100755
index 0000000000..4712a86da6
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_33.wyal
@@ -0,0 +1,7 @@
+assert:
+   forall ([int] xs):
+      if:
+        forall (int i):
+          0 <= xs[i] && xs[i] <= 2
+      then:
+          xs[0] != 3
diff --git a/modules/wycs/tests/valid/test_list_34.wyal b/modules/wycs/tests/valid/test_list_34.wyal
new file mode 100755
index 0000000000..7d14ebd2e2
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_34.wyal
@@ -0,0 +1,9 @@
+assert "constraint not satisfied":
+  forall ([int] xs):
+      if:
+        forall (int i):
+          0 <= xs[i] && xs[i] <= 2
+      then:
+        forall (int j):
+          xs[j] >= 0
+
diff --git a/modules/wycs/tests/valid/test_list_35.wyal b/modules/wycs/tests/valid/test_list_35.wyal
new file mode 100755
index 0000000000..45580cfc28
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_35.wyal
@@ -0,0 +1,4 @@
+assert:
+    forall [int] r0:
+        |r0| != 0 ==> 0 < |r0|
+
diff --git a/modules/wycs/tests/valid/test_list_36.wyal b/modules/wycs/tests/valid/test_list_36.wyal
new file mode 100755
index 0000000000..b172a23dd7
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_36.wyal
@@ -0,0 +1,7 @@
+assert "assertion failure":
+    forall ([int] r0):
+        if:
+            |r0| != 0
+        then:
+            |r0| > 0
+
diff --git a/modules/wycs/tests/valid/test_list_37.wyal b/modules/wycs/tests/valid/test_list_37.wyal
new file mode 100755
index 0000000000..878cf5633d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_37.wyal
@@ -0,0 +1,8 @@
+assert:
+   forall ([int] xs, int i, int x, int y):
+      if:
+        xs[i] == x
+        xs[i] == y
+      then:
+        x == y
+
diff --git a/modules/wycs/tests/valid/test_list_38.wyal b/modules/wycs/tests/valid/test_list_38.wyal
new file mode 100755
index 0000000000..8264c4edc8
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_38.wyal
@@ -0,0 +1,13 @@
+define Bijection([int] xs) is:
+  forall(int i1, int i2, int v1, int v2):
+    if:
+      xs[i1] == v1
+      xs[i2] == v2
+      i1 != i2
+    then:
+      v1 != v2
+
+assert:
+    Bijection([1,2,3,4])
+
+
diff --git a/modules/wycs/tests/valid/test_list_39.wyal b/modules/wycs/tests/valid/test_list_39.wyal
new file mode 100755
index 0000000000..51c4809e06
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_39.wyal
@@ -0,0 +1,16 @@
+define invariant([int] items, int item, int i) is:
+    forall (int j):
+        if:
+            0 <= j
+            j < i
+        then:
+            items[j] == item
+
+assert:
+    forall ([int] items, int item, int i):
+        if:
+            invariant(items, item, i)            
+        then:
+            invariant(items, item, i)
+
+
diff --git a/modules/wycs/tests/valid/test_list_40.wyal b/modules/wycs/tests/valid/test_list_40.wyal
new file mode 100755
index 0000000000..93a6ee2de0
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_40.wyal
@@ -0,0 +1,16 @@
+define invariant([int] items) is:
+    forall (int j):
+        if:
+            0 <= j
+            j < 10
+        then:
+            items[j] == 0
+
+assert:
+    forall ([int] items):
+        if:
+            invariant(items)                       
+        then:
+            invariant(items)
+
+
diff --git a/modules/wycs/tests/valid/test_list_41.wyal b/modules/wycs/tests/valid/test_list_41.wyal
new file mode 100755
index 0000000000..4ebf51b30a
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_41.wyal
@@ -0,0 +1,17 @@
+define invariant([int] items, int item, int i) is:
+    forall (int j):
+        if:
+            0 <= j
+            j < i
+        then:
+            items[j] == item
+
+assert:
+    forall ([int] items, int item, int i):
+        if:
+            invariant(items, item, i)            
+            items[i] == item
+        then:
+            invariant(items, item, i+1)
+
+
diff --git a/modules/wycs/tests/valid/test_list_42.wyal b/modules/wycs/tests/valid/test_list_42.wyal
new file mode 100755
index 0000000000..5dce716317
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_42.wyal
@@ -0,0 +1,16 @@
+define invariant([int] items, int item, int i) is:
+    forall (int j):
+        if:
+            j < i
+        then:
+            items[j] > item
+
+assert:
+    forall ([int] items, int item, int i):
+        if:
+            invariant(items, item, i)            
+            items[i] > item
+        then:
+            invariant(items, item, i+1)
+
+
diff --git a/modules/wycs/tests/valid/test_list_43.wyal b/modules/wycs/tests/valid/test_list_43.wyal
new file mode 100755
index 0000000000..925fd69d0d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_43.wyal
@@ -0,0 +1,16 @@
+import wycs.core.Array
+
+define invariant([int] items) is:
+    forall (int i):
+        items[i] == 0
+            
+assert "loop invariant not restored":
+    forall ([int] items, [int] nitems, int n):
+        if:
+            invariant(items)
+            Array.<int>update(items,nitems,n)
+            nitems[n] == 0
+        then:
+            invariant(nitems)
+
+
diff --git a/modules/wycs/tests/valid/test_list_44.wyal b/modules/wycs/tests/valid/test_list_44.wyal
new file mode 100755
index 0000000000..44ff9e1089
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_44.wyal
@@ -0,0 +1,19 @@
+import wycs.core.Array
+
+define invariant([int] items, int n) is:
+    forall (int i):
+        if:
+            i < n
+        then:
+            items[i] == 0
+            
+assert "loop invariant not restored":
+    forall ([int] items, [int] nitems, int n):
+        if:
+            invariant(items,n)
+            Array.<int>update(items,nitems,n)
+            nitems[n] == 0
+        then:
+            invariant(nitems,n+1)
+
+
diff --git a/modules/wycs/tests/valid/test_list_45.wyal b/modules/wycs/tests/valid/test_list_45.wyal
new file mode 100755
index 0000000000..3b5cafb979
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_45.wyal
@@ -0,0 +1,11 @@
+import wycs.core.Array
+            
+assert "loop invariant not restored":
+    forall ([int] items, [int] nitems, int n):
+        if:
+            Array.<int>update(items,nitems,n)
+            nitems[n] == 0
+        then:
+            nitems[n] == 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_46.wyal b/modules/wycs/tests/valid/test_list_46.wyal
new file mode 100755
index 0000000000..2f43a99b56
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_46.wyal
@@ -0,0 +1,12 @@
+import wycs.core.Array
+
+assert "loop invariant not restored":
+    forall ([int] items, [int] nitems, int n):
+        if:
+            items[0] != 0
+            Array.<int>update(items,nitems,n)
+            nitems[n] == 0
+        then:
+            n > 0 ==> nitems[0] != 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_47.wyal b/modules/wycs/tests/valid/test_list_47.wyal
new file mode 100755
index 0000000000..700be6f204
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_47.wyal
@@ -0,0 +1,12 @@
+import wycs.core.Array
+
+assert "loop invariant not restored":
+    forall ([int] items, [int] nitems, int i, int n):
+        if:
+            Array.<int>update(items,nitems,n)
+            nitems[n] == 0
+            items[i] != 0
+        then:
+            n != i ==> nitems[i] != 0
+
+
diff --git a/modules/wycs/tests/valid/test_list_48.wyal b/modules/wycs/tests/valid/test_list_48.wyal
new file mode 100755
index 0000000000..75cebecf9c
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_48.wyal
@@ -0,0 +1,11 @@
+import wycs.core.Array
+
+assert "loop invariant not restored":
+    forall ([int] xs, [int] ys, [int] zs, int i):
+        if:
+            Array.<int>generate(ys, 0, |xs|)
+            Array.<int>update(ys, zs, i)
+        then:
+            |xs| == |zs|
+
+
diff --git a/modules/wycs/tests/valid/test_list_49.wyal b/modules/wycs/tests/valid/test_list_49.wyal
new file mode 100755
index 0000000000..31e5c24199
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_49.wyal
@@ -0,0 +1,35 @@
+import wycs.core.Array
+
+define lastIndexOf_ensures_0(null | int r0, [int] r1, int r2) is:
+    case:
+        r0 is !(int)
+        true
+    case:
+        r0 is int
+        r1[r0] == r2
+        true
+    true
+
+function lastIndexOf([int] r0, int r1) -> (null | int)
+
+define invariant([int] items, int i, int x, int last) is:
+    case:
+        last != -1
+        items[last] == x
+    case:
+        last == -1
+
+assert "loop invariant not restored":
+    forall (int i, [int] xs, int last, int nlast, int x):
+        if:
+            case:
+                invariant(xs, i, x, last)
+                xs[i] == x
+                nlast == i
+            case:
+                invariant(xs, i, x, last)
+                xs[i] != x
+                nlast == last
+        then:
+            invariant(xs, i + 1, x, nlast)
+
diff --git a/modules/wycs/tests/valid/test_list_50.wyal b/modules/wycs/tests/valid/test_list_50.wyal
new file mode 100755
index 0000000000..621f5d187f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_list_50.wyal
@@ -0,0 +1,11 @@
+define invariant([int] items, int item, int n) is:
+    exists(int i):
+        n < i && items[i] == item
+
+assert:
+    forall([int] items, int item, int n):
+        if:
+            invariant(items,item,n)
+            items[n] != item
+        then:
+            invariant(items,item,n+1)
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_macro_01.wyal b/modules/wycs/tests/valid/test_macro_01.wyal
new file mode 100755
index 0000000000..764eb5cd3a
--- /dev/null
+++ b/modules/wycs/tests/valid/test_macro_01.wyal
@@ -0,0 +1,6 @@
+define loop(int x) is:
+       x >= 0
+
+assert:
+  forall (int x):
+       loop(x) ==> loop(x+1)
diff --git a/modules/wycs/tests/valid/test_macro_02.wyal b/modules/wycs/tests/valid/test_macro_02.wyal
new file mode 100755
index 0000000000..8dd34fa687
--- /dev/null
+++ b/modules/wycs/tests/valid/test_macro_02.wyal
@@ -0,0 +1,5 @@
+define f(int x, int y) is x < y
+
+assert:
+  forall (int x, int y, int z):
+    f(x,y) && f(y,z) ==> f(x,z)
diff --git a/modules/wycs/tests/valid/test_macro_03.wyal b/modules/wycs/tests/valid/test_macro_03.wyal
new file mode 100755
index 0000000000..6118cc6d16
--- /dev/null
+++ b/modules/wycs/tests/valid/test_macro_03.wyal
@@ -0,0 +1,20 @@
+define f(int x) is:
+    x >= 0
+
+define f(real x) is:
+    x >= 0.0
+
+assert:
+    forall(int x):
+        if:
+            x >= 0
+        then:
+            f(x)
+
+assert:
+    forall(real x):
+        if:
+            x >= 0.0
+        then:
+            f(x)
+
diff --git a/modules/wycs/tests/valid/test_tuple_01.wyal b/modules/wycs/tests/valid/test_tuple_01.wyal
new file mode 100755
index 0000000000..208c7011a2
--- /dev/null
+++ b/modules/wycs/tests/valid/test_tuple_01.wyal
@@ -0,0 +1,8 @@
+assert:
+  forall((int,int) x):
+    if:
+        x[0] > x[1]
+        x[1] >= 0
+    then:
+        x[0] > 0
+
diff --git a/modules/wycs/tests/valid/test_type_01.wyal b/modules/wycs/tests/valid/test_type_01.wyal
new file mode 100755
index 0000000000..da0aecdfda
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_01.wyal
@@ -0,0 +1,6 @@
+type nat is (int x) where:
+    x >= 0
+
+assert:
+    forall(nat x):
+        x >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_02.wyal b/modules/wycs/tests/valid/test_type_02.wyal
new file mode 100755
index 0000000000..8e81b3ab22
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_02.wyal
@@ -0,0 +1,9 @@
+type nat is (int x) where:
+    x >= 0
+
+assert:
+    forall(nat x, int y):
+        if:
+            x == y
+        then:
+            y >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_03.wyal b/modules/wycs/tests/valid/test_type_03.wyal
new file mode 100755
index 0000000000..b2a094b44a
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_03.wyal
@@ -0,0 +1,6 @@
+type nat is (int x) where:
+    x >= 0
+
+assert:
+    forall(nat x, nat y):
+        x + y >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_04.wyal b/modules/wycs/tests/valid/test_type_04.wyal
new file mode 100755
index 0000000000..bd1b234fde
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_04.wyal
@@ -0,0 +1,8 @@
+type nat is (int x) where:
+    x >= 0
+
+function f(nat x) -> nat
+
+assert:
+    forall(nat x):
+        f(x) >= 0
diff --git a/modules/wycs/tests/valid/test_type_05.wyal b/modules/wycs/tests/valid/test_type_05.wyal
new file mode 100755
index 0000000000..45cb699297
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_05.wyal
@@ -0,0 +1,12 @@
+type nat is (int x) where:
+    x >= 0
+
+type pos is (int x) where:
+    x > 0
+
+assert:
+    forall(pos x, nat y):
+        if:
+           y > x
+        then:
+           y > 1
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_06.wyal b/modules/wycs/tests/valid/test_type_06.wyal
new file mode 100755
index 0000000000..2be346a7a8
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_06.wyal
@@ -0,0 +1,9 @@
+type nat is (int x) where:
+    x >= 0
+
+assert:
+    forall([nat] xs, nat i):
+        if:
+           i < |xs|
+        then:
+           xs[i] >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_07.wyal b/modules/wycs/tests/valid/test_type_07.wyal
new file mode 100755
index 0000000000..6d3e5d5ec2
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_07.wyal
@@ -0,0 +1,6 @@
+type lessThan is (int x, int y) where:
+    x < y
+
+assert:
+    forall(lessThan xs):
+        xs[0] < xs[1]
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_08.wyal b/modules/wycs/tests/valid/test_type_08.wyal
new file mode 100755
index 0000000000..56bebd8b02
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_08.wyal
@@ -0,0 +1,10 @@
+type nat is (int x) where:
+    x >= 0
+
+assert:
+    forall([nat] items, int i):
+        if:
+            i >= 0
+            i < |items|
+        then:
+            items[i] >= 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_09.wyal b/modules/wycs/tests/valid/test_type_09.wyal
new file mode 100755
index 0000000000..f1e42a4af4
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_09.wyal
@@ -0,0 +1,8 @@
+type Recursive is [Recursive|null]
+
+assert:
+    forall(Recursive x, [int] y):
+        if:
+            x == y
+        then:
+            |y| == 0
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_10.wyal b/modules/wycs/tests/valid/test_type_10.wyal
new file mode 100755
index 0000000000..3737a840ce
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_10.wyal
@@ -0,0 +1,8 @@
+type nat is (int x) where x >= 0
+
+type pos is (nat x) where x != 1
+
+assert:
+    forall(pos p):
+        p >= 0
+        p != 1
\ No newline at end of file
diff --git a/modules/wycs/tests/valid/test_type_11.wyal b/modules/wycs/tests/valid/test_type_11.wyal
new file mode 100755
index 0000000000..916f4e996d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_11.wyal
@@ -0,0 +1,12 @@
+define f_ensures_0(int r0, null | int r1) is:
+    r0 >= 0
+
+assert "postcondition not satisfied":
+    forall (null | int v):
+        if:
+            v is int
+            v >= 0
+        then:
+            test.f_ensures_0(v + 1, v)
+
+
diff --git a/modules/wycs/tests/valid/test_type_12.wyal b/modules/wycs/tests/valid/test_type_12.wyal
new file mode 100755
index 0000000000..0ba0e60b27
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_12.wyal
@@ -0,0 +1,4 @@
+assert:
+    null is null
+
+
diff --git a/modules/wycs/tests/valid/test_type_13.wyal b/modules/wycs/tests/valid/test_type_13.wyal
new file mode 100755
index 0000000000..10964e1014
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_13.wyal
@@ -0,0 +1,6 @@
+assert:
+    true is bool
+
+assert:
+    false is bool
+
diff --git a/modules/wycs/tests/valid/test_type_14.wyal b/modules/wycs/tests/valid/test_type_14.wyal
new file mode 100755
index 0000000000..75fb7c94ce
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_14.wyal
@@ -0,0 +1,9 @@
+assert:
+    1 is int
+
+assert:
+    -1 is int
+
+assert:
+    12345 is int
+
diff --git a/modules/wycs/tests/valid/test_type_15.wyal b/modules/wycs/tests/valid/test_type_15.wyal
new file mode 100755
index 0000000000..dc2fac1c87
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_15.wyal
@@ -0,0 +1,9 @@
+assert:
+    1.0 is real
+
+assert:
+    -1.0 is real
+
+assert:
+    123.45 is real
+
diff --git a/modules/wycs/tests/valid/test_type_16.wyal b/modules/wycs/tests/valid/test_type_16.wyal
new file mode 100755
index 0000000000..9ca286f794
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_16.wyal
@@ -0,0 +1,3 @@
+assert:
+    [1] is [int]
+
diff --git a/modules/wycs/tests/valid/test_type_17.wyal b/modules/wycs/tests/valid/test_type_17.wyal
new file mode 100755
index 0000000000..f14eb4d6cd
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_17.wyal
@@ -0,0 +1,2 @@
+assert:
+    [1] is [int]
diff --git a/modules/wycs/tests/valid/test_type_18.wyal b/modules/wycs/tests/valid/test_type_18.wyal
new file mode 100755
index 0000000000..8a351e4337
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_18.wyal
@@ -0,0 +1,2 @@
+assert:
+    (1,true) is (int,bool)
diff --git a/modules/wycs/tests/valid/test_type_19.wyal b/modules/wycs/tests/valid/test_type_19.wyal
new file mode 100755
index 0000000000..5392105441
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_19.wyal
@@ -0,0 +1,2 @@
+assert:
+    { f: 1 } is {int f}
diff --git a/modules/wycs/tests/valid/test_type_20.wyal b/modules/wycs/tests/valid/test_type_20.wyal
new file mode 100755
index 0000000000..42532b744f
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_20.wyal
@@ -0,0 +1,15 @@
+assert:
+    forall(int|null x):
+        if:
+            x == 1
+        then:
+            !(x is null)
+
+assert:
+    forall(int|null x):
+        if:
+            x != null
+        then:
+            !(x is null)
+
+
diff --git a/modules/wycs/tests/valid/test_type_21.wyal b/modules/wycs/tests/valid/test_type_21.wyal
new file mode 100755
index 0000000000..12e0fe11e5
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_21.wyal
@@ -0,0 +1,21 @@
+assert:
+    forall(null|bool x):
+        if:
+            x == null
+        then:
+            !(x is bool)
+
+assert:
+    forall(int|bool x):
+        if:
+            x == 1
+        then:
+            !(x is bool)
+
+assert:
+    forall(any x):
+        if:
+            x == (1,1)
+        then:
+            !(x is bool)
+
diff --git a/modules/wycs/tests/valid/test_type_22.wyal b/modules/wycs/tests/valid/test_type_22.wyal
new file mode 100755
index 0000000000..857d3f658d
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_22.wyal
@@ -0,0 +1,10 @@
+type nat is (int r0) where:
+    r0 >= 0
+
+assert "postcondition not satisfied":
+    forall (int x):
+        if:
+            x is nat
+        then:
+            x >= 0
+
diff --git a/modules/wycs/tests/valid/test_type_23.wyal b/modules/wycs/tests/valid/test_type_23.wyal
new file mode 100755
index 0000000000..e276dce210
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_23.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (null | int x):
+        if:
+            x is !(int)
+        then:
+            x is null
+
diff --git a/modules/wycs/tests/valid/test_type_24.wyal b/modules/wycs/tests/valid/test_type_24.wyal
new file mode 100755
index 0000000000..981779f16a
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_24.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (null | int x):
+        if:
+            x is null
+        then:
+            x is !(int)
+
diff --git a/modules/wycs/tests/valid/test_type_25.wyal b/modules/wycs/tests/valid/test_type_25.wyal
new file mode 100755
index 0000000000..2091b3f1ee
--- /dev/null
+++ b/modules/wycs/tests/valid/test_type_25.wyal
@@ -0,0 +1,7 @@
+assert:
+    forall (null | int x):
+        if:
+            x is null
+        then:
+            x is null
+
diff --git a/modules/wyil/build.xml b/modules/wyil/build.xml
index bc33ea330a..a53b2a00a0 100755
--- a/modules/wyil/build.xml
+++ b/modules/wyil/build.xml
@@ -6,8 +6,8 @@
   <import file="../../config.xml"/>
 
   <path id="wyil.classpath">
-    <pathelement path="${WYCC_JAR}"/>
-    <pathelement path="${WYTP_JAR}"/>
+    <pathelement path="${WYBS_DIR}/src"/>
+    <pathelement path="${WYCS_DIR}/src"/>
     <pathelement path="${WYRL_JAR}"/>
     <path refid="junit.classpath"/>
   </path>
@@ -54,6 +54,31 @@
     <echo message="============================================="/>
   </target>
 
+  <!-- ================================================================== -->
+  <!-- Dist -->
+  <!-- ================================================================== -->
+
+  <target name="dist">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wyil.WyilMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wyil-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${DIST_DIR}/wyil-all-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src">
+	<include name="wyautl_old/**/*.class"/>
+	<include name="wybs/**/*.class"/>
+	<include name="wyil/**/*.class"/>
+      </fileset>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: dist/${ant.project.name}-all-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
   <!-- ================================================================== -->
   <!-- Clean -->
   <!-- ================================================================== -->
diff --git a/modules/wyil/src/wyil/Main.java b/modules/wyil/src/wyil/Main.java
index 8ceb81611d..323c788304 100755
--- a/modules/wyil/src/wyil/Main.java
+++ b/modules/wyil/src/wyil/Main.java
@@ -2,13 +2,14 @@
 
 import java.io.*;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 
 import wybs.lang.Build;
 import wybs.util.StdProject;
-import wybs.lang.NameID;
-import wybs.lang.SyntaxError;
-import wybs.lang.SyntaxError.InternalFailure;
+import wycc.lang.NameID;
+import wycc.lang.SyntaxError;
+import wycc.lang.SyntaxError.InternalFailure;
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyfs.util.DirectoryRoot;
diff --git a/modules/wyil/src/wyil/builders/VerificationConditionGenerator.java b/modules/wyil/src/wyil/builders/VerificationConditionGenerator.java
index 08a49dae2d..688c7e1f54 100755
--- a/modules/wyil/src/wyil/builders/VerificationConditionGenerator.java
+++ b/modules/wyil/src/wyil/builders/VerificationConditionGenerator.java
@@ -9,12 +9,12 @@
 import java.math.BigInteger;
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.NameID;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError.InternalFailure;
-import wybs.util.ResolveError;
-import wycommon.util.Pair;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError.InternalFailure;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
 import wycs.core.Value;
 import wycs.syntax.Expr;
 import wycs.syntax.SyntacticType;
diff --git a/modules/wyil/src/wyil/builders/Wyil2WyalBuilder.java b/modules/wyil/src/wyil/builders/Wyil2WyalBuilder.java
index ff0dbee60b..589733b59b 100755
--- a/modules/wyil/src/wyil/builders/Wyil2WyalBuilder.java
+++ b/modules/wyil/src/wyil/builders/Wyil2WyalBuilder.java
@@ -29,10 +29,12 @@
 import java.util.*;
 
 import wybs.lang.Build;
-import wycommon.util.Logger;
-import wycommon.util.Pair;
+import wybs.lang.Builder;
 import wyfs.lang.Path;
 import wyil.lang.*;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycs.syntax.Expr;
 import wycs.syntax.WyalFile;
 
 /**
@@ -42,7 +44,7 @@
  * @author David J. Pearce
  *
  */
-public class Wyil2WyalBuilder implements Build.Task {
+public class Wyil2WyalBuilder implements Builder {
 
 	/**
 	 * The master namespace for identifying all resources available to the
@@ -56,6 +58,8 @@
 	 */
 	protected Logger logger = Logger.NULL;
 
+	private String filename;
+
 	public Wyil2WyalBuilder(Build.Project project) {
 		this.project = project;
 	}
@@ -68,12 +72,7 @@ public void setLogger(Logger logger) {
 		this.logger = logger;
 	}
 
-	public String id() {
-		return null;
-	}
-	
 	@Override
-	@SuppressWarnings("unchecked")
 	public Set<Path.Entry<?>> build(Collection<Pair<Path.Entry<?>, Path.Root>> delta, Build.Graph graph)
 			throws IOException {
 		Runtime runtime = Runtime.getRuntime();
diff --git a/modules/wyil/src/wyil/checks/CoercionCheck.java b/modules/wyil/src/wyil/checks/CoercionCheck.java
index 011ad295e0..b935018d44 100755
--- a/modules/wyil/src/wyil/checks/CoercionCheck.java
+++ b/modules/wyil/src/wyil/checks/CoercionCheck.java
@@ -28,11 +28,12 @@
 import java.util.*;
 
 import static wyil.util.ErrorMessages.*;
-import wybs.lang.Attribute;
-import wybs.lang.Build;
-import wybs.lang.SyntacticElement;
-import wybs.lang.SyntaxError;
-import wycommon.util.Pair;
+import wybs.lang.Builder;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.util.Pair;
 import wyil.lang.*;
 
 /**
@@ -72,10 +73,10 @@
  *
  * @author David J. Pearce
  */
-public class CoercionCheck {
+public class CoercionCheck implements Transform<WyilFile> {
 	private WyilFile file;
 
-	public CoercionCheck(Build.Task builder) {
+	public CoercionCheck(Builder builder) {
 
 	}
 
diff --git a/modules/wyil/src/wyil/checks/ModuleCheck.java b/modules/wyil/src/wyil/checks/ModuleCheck.java
index a04190ff37..c8367a2013 100755
--- a/modules/wyil/src/wyil/checks/ModuleCheck.java
+++ b/modules/wyil/src/wyil/checks/ModuleCheck.java
@@ -27,9 +27,10 @@
 
 import java.util.*;
 
-import wybs.lang.Build;
-import wybs.lang.SyntaxError;
-import wycommon.util.Pair;
+import wybs.lang.Builder;
+import wycc.lang.SyntaxError;
+import wycc.lang.Transform;
+import wycc.util.Pair;
 import wyil.lang.*;
 import wyil.lang.Bytecode.*;
 import wyil.lang.SyntaxTree.Location;
@@ -55,10 +56,10 @@
  * @author David J. Pearce
  *
  */
-public class ModuleCheck {
+public class ModuleCheck implements Transform<WyilFile> {
 	private WyilFile file;
 
-	public ModuleCheck(Build.Task builder) {
+	public ModuleCheck(Builder builder) {
 
 	}
 
diff --git a/modules/wyil/src/wyil/io/WyilFilePrinter.java b/modules/wyil/src/wyil/io/WyilFilePrinter.java
index f49ad8c568..e171a43e65 100755
--- a/modules/wyil/src/wyil/io/WyilFilePrinter.java
+++ b/modules/wyil/src/wyil/io/WyilFilePrinter.java
@@ -28,7 +28,7 @@
 import java.io.*;
 import java.util.*;
 
-import wybs.lang.Build;
+import wycc.lang.Transform;
 import wyil.lang.*;
 import wyil.lang.Constant;
 import wyil.lang.Bytecode.AliasDeclaration;
@@ -49,11 +49,11 @@
  * @author David J. Pearce
  *
  */
-public final class WyilFilePrinter {
+public final class WyilFilePrinter implements Transform<WyilFile> {
 	private PrintWriter out;
 	private boolean verbose = getVerbose();
 	
-	public WyilFilePrinter(Build.Task builder) {
+	public WyilFilePrinter(wybs.lang.Builder builder) {
 
 	}
 
@@ -244,6 +244,7 @@ private void writeStatement(int indent, Location<?> c, PrintWriter out) {
 	}
 	
 	private void writeAliasDeclaration(int indent, Location<AliasDeclaration> loc, PrintWriter out) {
+		Location<?>[] operands = loc.getOperands();
 		out.print("alias ");
 		out.print(loc.getType());
 		out.print(" ");
@@ -450,10 +451,23 @@ private void writeBracketedExpression(Location<?> expr, PrintWriter out) {
 	}
 
 	private void writeExpressions(Location<?>[] exprs, PrintWriter out) {
+		Bytecode last = null;
 		for (int i = 0; i != exprs.length; ++i) {
 			if (i != 0) {
 				out.print(", ");
 			}
+			Location<?> e = exprs[i];
+
+			// FIXME: support position operators
+			
+//			if (e instanceof SyntaxTree.PositionalLocation<?>) {
+//				SyntaxTree.PositionalLocation<?> p = (SyntaxTree.PositionalLocation<?>) e;
+//				if (p.getBytecode() == last) {
+//					continue;
+//				} else {
+//					last = p.getBytecode();
+//				}
+//			}
 			writeExpression(exprs[i], out);
 		}
 	}
@@ -800,7 +814,6 @@ private static void tabIndent(int indent, PrintWriter out) {
 		}
 	}
 	
-	@SuppressWarnings("unchecked")
 	private Location<VariableDeclaration> getVariableDeclaration(Location<?> loc) {
 		switch (loc.getOpcode()) {
 		case Bytecode.OPCODE_vardecl:
diff --git a/modules/wyil/src/wyil/io/WyilFileReader.java b/modules/wyil/src/wyil/io/WyilFileReader.java
index d5f9f510d1..f0ca48205a 100755
--- a/modules/wyil/src/wyil/io/WyilFileReader.java
+++ b/modules/wyil/src/wyil/io/WyilFileReader.java
@@ -29,8 +29,8 @@
 import java.math.BigInteger;
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.NameID;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
 import wyfs.io.BinaryInputStream;
 import wyfs.lang.Path;
 import wyfs.util.Trie;
diff --git a/modules/wyil/src/wyil/io/WyilFileWriter.java b/modules/wyil/src/wyil/io/WyilFileWriter.java
index b0ae011349..3604a2c692 100755
--- a/modules/wyil/src/wyil/io/WyilFileWriter.java
+++ b/modules/wyil/src/wyil/io/WyilFileWriter.java
@@ -29,8 +29,8 @@
 import java.math.BigInteger;
 import java.util.*;
 
-import wybs.lang.NameID;
-import wycommon.util.Pair;
+import wycc.lang.NameID;
+import wycc.util.Pair;
 import wyfs.io.BinaryOutputStream;
 import wyfs.lang.Path;
 import wyil.lang.*;
diff --git a/modules/wyil/src/wyil/lang/Bytecode.java b/modules/wyil/src/wyil/lang/Bytecode.java
index 50c631e10b..1cc26e4731 100755
--- a/modules/wyil/src/wyil/lang/Bytecode.java
+++ b/modules/wyil/src/wyil/lang/Bytecode.java
@@ -27,8 +27,13 @@
 
 import java.util.*;
 
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
+import wyil.lang.Bytecode.Extras;
+import wyil.lang.Bytecode.Operands;
+import wyil.lang.Bytecode.Schema;
 import wyil.util.AbstractBytecode;
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 
 /**
  * <p>
diff --git a/modules/wyil/src/wyil/lang/Constant.java b/modules/wyil/src/wyil/lang/Constant.java
index 0a1f3d4dbc..2afb5982ec 100755
--- a/modules/wyil/src/wyil/lang/Constant.java
+++ b/modules/wyil/src/wyil/lang/Constant.java
@@ -28,7 +28,7 @@
 import java.math.BigInteger;
 import java.util.*;
 
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 
 public abstract class Constant implements Comparable<Constant> {
 
diff --git a/modules/wyil/src/wyil/lang/SyntaxTree.java b/modules/wyil/src/wyil/lang/SyntaxTree.java
index 209b498291..61e886f0c1 100755
--- a/modules/wyil/src/wyil/lang/SyntaxTree.java
+++ b/modules/wyil/src/wyil/lang/SyntaxTree.java
@@ -3,8 +3,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import wybs.lang.Attribute;
-import wybs.lang.SyntacticElement;
+import wycc.lang.Attribute;
+import wycc.lang.SyntacticElement;
 
 /**
  * A SyntaxTree representation of the Whiley Intermediate Language (WyIL).
diff --git a/modules/wyil/src/wyil/lang/Type.java b/modules/wyil/src/wyil/lang/Type.java
index bca28396e7..0b79d75a9b 100755
--- a/modules/wyil/src/wyil/lang/Type.java
+++ b/modules/wyil/src/wyil/lang/Type.java
@@ -25,7 +25,7 @@
 import wyautl_old.io.BinaryAutomataWriter;
 import wyautl_old.lang.*;
 import wyautl_old.lang.Automaton.State;
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 import wyfs.io.BinaryInputStream;
 import wyfs.io.BinaryOutputStream;
 import wyfs.util.Trie;
diff --git a/modules/wyil/src/wyil/lang/WyilFile.java b/modules/wyil/src/wyil/lang/WyilFile.java
index 3478748eb2..c644e19ab6 100755
--- a/modules/wyil/src/wyil/lang/WyilFile.java
+++ b/modules/wyil/src/wyil/lang/WyilFile.java
@@ -30,10 +30,11 @@
 import java.io.OutputStream;
 import java.util.*;
 
-import wybs.lang.Attribute;
-import wybs.lang.CompilationUnit;
-import wybs.lang.SyntacticElement;
-import wybs.util.AbstractCompilationUnit;
+import wycc.lang.Attribute;
+import wycc.lang.CompilationUnit;
+import wycc.lang.SyntacticElement;
+import wycc.util.AbstractCompilationUnit;
+import wycc.util.Pair;
 import wyfs.lang.Content;
 import wyfs.lang.Path;
 import wyil.io.*;
diff --git a/modules/wyil/src/wyil/util/AbstractBytecode.java b/modules/wyil/src/wyil/util/AbstractBytecode.java
index 02101143a6..73bbbdb4ee 100755
--- a/modules/wyil/src/wyil/util/AbstractBytecode.java
+++ b/modules/wyil/src/wyil/util/AbstractBytecode.java
@@ -2,7 +2,7 @@
 
 import java.util.Arrays;
 
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 import wyil.lang.Bytecode;
 import wyil.lang.Constant;
 import wyil.lang.Type;
diff --git a/modules/wyil/src/wyil/util/ErrorMessages.java b/modules/wyil/src/wyil/util/ErrorMessages.java
index 63e0444af2..2eca48b134 100755
--- a/modules/wyil/src/wyil/util/ErrorMessages.java
+++ b/modules/wyil/src/wyil/util/ErrorMessages.java
@@ -25,6 +25,10 @@
 
 package wyil.util;
 
+import java.util.Collection;
+
+import wycc.lang.SyntaxError.InternalFailure;
+import wycc.lang.Attribute;
 import wyil.lang.Type;
 
 /**
diff --git a/modules/wyil/src/wyil/util/TypeSystem.java b/modules/wyil/src/wyil/util/TypeSystem.java
index 8bec8d871e..3fcb48998f 100755
--- a/modules/wyil/src/wyil/util/TypeSystem.java
+++ b/modules/wyil/src/wyil/util/TypeSystem.java
@@ -11,8 +11,9 @@
 import wyautl_old.lang.Automaton;
 import wyautl_old.lang.Automaton.State;
 import wybs.lang.Build;
-import wybs.lang.NameID;
-import wybs.util.ResolveError;
+import wycc.lang.NameID;
+import wycc.util.ResolveError;
+import wyfs.lang.Path;
 import wyil.lang.Type;
 import wyil.lang.WyilFile;
 
@@ -142,6 +143,7 @@ private Type expandOneLevel(Type type) throws ResolveError {
 			if (type instanceof Type.Nominal) {
 				Type.Nominal nt = (Type.Nominal) type;
 				NameID nid = nt.name();
+				Path.ID mid = nid.module();
 				WyilFile m = project.get(nid.module(), WyilFile.ContentType).read();
 				WyilFile.Type td = m.type(nid.name());
 				return expandOneLevel(td.type());
diff --git a/modules/wyil/src/wyil/util/interpreter/Interpreter.java b/modules/wyil/src/wyil/util/interpreter/Interpreter.java
index 92aae66310..9b64d849b0 100755
--- a/modules/wyil/src/wyil/util/interpreter/Interpreter.java
+++ b/modules/wyil/src/wyil/util/interpreter/Interpreter.java
@@ -10,10 +10,10 @@
 
 import wyautl.util.BigRational;
 import wybs.lang.Build;
-import wybs.lang.NameID;
-import wybs.lang.SyntacticElement;
-import wybs.util.ResolveError;
-import wycommon.util.Pair;
+import wycc.lang.NameID;
+import wycc.lang.SyntacticElement;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
 import wyfs.lang.Path;
 import wyil.lang.*;
 import wyil.lang.Bytecode.*;
diff --git a/modules/wyil/src/wyil/util/type/SubtypeOperator.java b/modules/wyil/src/wyil/util/type/SubtypeOperator.java
index 5e9c4f3166..7407b07de7 100755
--- a/modules/wyil/src/wyil/util/type/SubtypeOperator.java
+++ b/modules/wyil/src/wyil/util/type/SubtypeOperator.java
@@ -30,7 +30,7 @@
 import java.util.*;
 
 import wyautl_old.lang.*;
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 import wyil.lang.Type;
 
 /**
diff --git a/modules/wyil/src/wyil/util/type/TypeAlgorithms.java b/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
index e0a331c87e..576907d192 100755
--- a/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
+++ b/modules/wyil/src/wyil/util/type/TypeAlgorithms.java
@@ -36,7 +36,7 @@
 import java.util.HashMap;
 
 import wyautl_old.lang.*;
-import wybs.lang.NameID;
+import wycc.lang.NameID;
 import wyil.lang.Type;
 
 /**
diff --git a/modules/wyil/src/wyil/util/type/TypeParser.java b/modules/wyil/src/wyil/util/type/TypeParser.java
index 9b054b3fad..fb8cd24446 100755
--- a/modules/wyil/src/wyil/util/type/TypeParser.java
+++ b/modules/wyil/src/wyil/util/type/TypeParser.java
@@ -25,10 +25,13 @@
 
 package wyil.util.type;
 
+import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 
-import wybs.lang.NameID;
+import wycc.lang.NameID;
+import wyfs.lang.Path;
 import wyfs.util.Trie;
 import wyil.lang.Type;
 import static wyil.lang.Type.*;
diff --git a/modules/wyjc/README b/modules/wyjc/README
new file mode 100755
index 0000000000..500e927110
--- /dev/null
+++ b/modules/wyjc/README
@@ -0,0 +1,19 @@
+======================================================================
+Package Summary
+======================================================================
+
+src/wyjc/ --- The Whiley-to-Java Compiler.  This extends the Whiley
+              Compiler (wyc) with additional transforms for converting
+              wyil code into Java bytecode.
+
+src/wyjvm/ -- The Whiley JVM library.  This library is used for
+              generating valid Java bytecode.  It abstracts the
+              various bytecodes and their different forms and takes
+              care of their optimal translation into actual JVM
+              bytecodes.  In addition, it handles various annoying
+              aspects of Java bytecode, such as ensuring wide branches
+              are used when necessary.  Finally, passes are provided
+              for eliminating dead-code and santity checking the
+              generated bytecode.
+
+src/whiley/ - The native Java components of the standard library.
\ No newline at end of file
diff --git a/modules/wyjc/build.xml b/modules/wyjc/build.xml
new file mode 100755
index 0000000000..033737375e
--- /dev/null
+++ b/modules/wyjc/build.xml
@@ -0,0 +1,150 @@
+<project name="wyjc" default="build">
+
+  <!-- ================================================================== -->
+  <!-- Configuration -->
+  <!-- ================================================================== -->
+  <import file="../../config.xml"/>
+
+  <path id="wyjc.classpath">
+    <pathelement path="${WYBS_DIR}/src"/>
+    <pathelement path="${WYC_DIR}/src"/>
+    <pathelement path="${WYIL_DIR}/src"/>
+    <pathelement path="${WYCS_DIR}/src"/>
+    <pathelement path="${WYRL_JAR}"/>
+    <pathelement path="${JASM_JAR}"/>
+    <path refid="junit.classpath"/>
+  </path>
+
+  <!-- ================================================================== -->
+  <!-- Compile -->
+  <!-- ================================================================== -->
+
+  <target name="compile-wyjc">
+    <javac debug="true" debuglevel="vars,lines,source" source="1.7" target="1.7" includeantruntime="true">
+      <src path="src"/>
+      <include name="*/**"/>
+      <exclude name="*/**/package-info.java"/>
+      <classpath>
+	<path refid="wyjc.classpath"/>
+      </classpath>
+    </javac>
+    <taskdef name="wyjc" classname="wyjc.util.WyjcAntTask">
+      <classpath>
+	<path path="src"/>
+	<path refid="wyjc.classpath"/>
+      </classpath>
+    </taskdef>
+    <wyjc verbose="false" wyildir="${WYRT_DIR}/src" classdir="src" includes="whiley/**/*.wyil"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Test -->
+  <!-- ================================================================== -->
+
+  <!-- Set the default value of this property. Since Ant properties are immutable
+       if the value has already been set by the user with -Dtest.name.contains=...
+       this will not override that value. -->
+  <property name="test.name.contains" value=""/>
+
+  <target name="test" depends="compile-wyjc">
+    <junit fork="true" dir="${basedir}" failureProperty="tests.failed" printsummary="yes" showoutput="yes" outputtoformatters="no">
+      <classpath>
+	<pathelement path="src"/>
+        <path refid="wyjc.classpath"/>
+      </classpath>
+      <sysproperty key="test.name.contains" value="${test.name.contains}"/>
+      <batchtest>
+        <fileset dir="src" includes="wyjc/testing/*Tests.java"/>
+      </batchtest>
+      <formatter type="plain" usefile="false"/>
+    </junit>
+    <fail message="Test failure detected, stopping build." if="tests.failed"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Build -->
+  <!-- ================================================================== -->
+
+  <target name="build" depends="compile-wyjc">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wyjc.WyjcMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wyjc-v${version}.jar"/>
+    </manifest>
+    <jar destfile="${LIB_DIR}/wyjc-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="src" includes="*/**/*.class"/>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: lib/${ant.project.name}-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Dist -->
+  <!-- ================================================================== -->
+
+  <target name="dist" depends="build">
+    <mkdir dir="tmp"/>
+    <manifest file="tmp/MANIFEST.MF">
+      <attribute name="Built-By" value="${user.name}"/>
+      <attribute name="Main-Class" value="wyjc.WyjcMain"/>
+      <attribute name="Implementation-Version" value="${version}"/>
+      <attribute name="Implementation-Title" value="wyjc-v${version}.jar"/>
+    </manifest>
+    <unzip src="${JASM_JAR}" dest="tmp"/>
+    <unzip src="${WYRL_JAR}" dest="tmp"/>
+    <jar destfile="${DIST_DIR}/wyjc-all-v${version}.jar" manifest="tmp/MANIFEST.MF">
+      <fileset dir="${WYBS_DIR}/src">
+	<include name="wyfs/**/*.class"/>
+	<include name="wybs/**/*.class"/>
+	<include name="wycc/**/*.class"/>
+      </fileset>
+      <fileset dir="${WYC_DIR}/src">
+	<include name="wyc/**/*.class"/>
+      </fileset>
+      <fileset dir="${WYIL_DIR}/src">
+	<include name="wyautl_old/**/*.class"/>
+	<include name="wyil/**/*.class"/>
+      </fileset>
+      <fileset dir="${WYCS_DIR}/src">
+	<include name="wycs/**/*.class"/>
+	<include name="wycs/**/*.wycs"/>
+      </fileset>
+      <fileset dir="${WYRT_DIR}/src">
+	<include name="whiley/**/*.wyil"/>
+      </fileset>
+      <fileset dir="src">
+	<include name="whiley/**/*.class"/>
+	<include name="wyjc/**/*.class"/>
+	<include name="wyjvm/**/*.class"/>
+      </fileset>
+      <fileset dir="tmp">
+	<include name="jasm/**/*.class"/>
+	<include name="wyautl/**/*.class"/>
+	<include name="wyrl/**/*.class"/>
+	<include name="wyrw/**/*.class"/>	
+      </fileset>
+    </jar>
+    <delete dir="tmp"/>
+    <echo message="============================================="/>
+    <echo message="BUILT: dist/${ant.project.name}-all-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Clean -->
+  <!-- ================================================================== -->
+
+  <target name="clean">
+    <delete includeEmptyDirs="true" failonerror="false">
+      <fileset dir="." includes="**/*.class,**/*.wyil,**/*.wyasm"/>
+    </delete>
+    <echo message="============================================="/>
+    <echo message="CLEANED: ${ant.project.name}"/>
+    <echo message="============================================="/>
+  </target>
+
+</project>
diff --git a/modules/wyjc/src/whiley/io/File$native.java b/modules/wyjc/src/whiley/io/File$native.java
new file mode 100755
index 0000000000..c834d691bc
--- /dev/null
+++ b/modules/wyjc/src/whiley/io/File$native.java
@@ -0,0 +1,154 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.io;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.HashMap;
+
+import wyjc.runtime.Util;
+import wyjc.runtime.WyByte;
+import wyjc.runtime.WyObject;
+import wyjc.runtime.WyArray;
+import wyjc.runtime.WyRecord;
+
+public class File$native {
+	public static WyObject NativeFileReader(WyArray _filename) {
+		try {
+			String filename = Util.il2str(_filename);
+			return new WyObject(new FileInputStream(filename));
+		} catch(FileNotFoundException e) {
+			// ARGH
+		}
+		return null;
+	}
+
+	public static WyObject NativeFileWriter(WyArray _filename) {
+		try {
+			String filename = Util.il2str(_filename);
+			return new WyObject(new FileOutputStream(filename));
+		} catch(FileNotFoundException e) {
+			// ARGH
+		}
+		return null;
+	}
+
+	public static void close(WyObject p) {
+		Object o = p.state();
+		try {
+			if(o instanceof FileInputStream) {
+				((FileInputStream)o).close();
+			} else {
+				((FileOutputStream)o).close();
+			}
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+	}
+
+
+	public static void flush(WyObject p) {
+		Object o = p.state();
+		try {
+			if(o instanceof FileOutputStream) {
+				((FileOutputStream)o).flush();
+			}
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+	}
+
+	public static boolean hasMore(WyObject p) {
+		FileInputStream fin = (FileInputStream) p.state();
+		return false; // BROKEN
+	}
+
+	public static BigInteger available(WyObject p) {
+		FileInputStream fin = (FileInputStream) p.state();
+		try {
+			return BigInteger.valueOf(fin.available());
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+		return BigInteger.ZERO;
+	}
+
+	public static WyArray read(WyObject p, BigInteger max) {
+		FileInputStream fin = (FileInputStream) p.state();
+
+		WyArray r = new WyArray();
+		byte[] bytes = new byte[max.intValue()];
+		try {
+			int nbytes = fin.read(bytes);
+			for(int i=0;i!=nbytes;++i) {
+				r.add(WyByte.valueOf(bytes[i]));
+			}
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+
+		return r;
+	}
+
+	private static final int CHUNK_SIZE = 1024;
+	public static WyArray read(WyObject p) {
+		FileInputStream fin = (FileInputStream) p.state();
+
+		WyArray r = new WyArray();
+		try {
+			int nbytes = 0;
+			do {
+				byte[] bytes = new byte[CHUNK_SIZE];
+				nbytes = fin.read(bytes);
+				for(int i=0;i!=nbytes;++i) {
+					r.add(WyByte.valueOf(bytes[i]));
+				}
+			} while(nbytes == CHUNK_SIZE);
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+
+		return r;
+	}
+
+	public static void write(WyObject p, WyArray bytes) {
+		FileOutputStream fout = (FileOutputStream) p.state();
+
+		try {
+			byte[] bs = new byte[bytes.size()];
+			for(int i=0;i!=bs.length;++i) {
+				WyByte r = (WyByte) bytes.get(i);
+				bs[i] = r.value();
+			}
+			fout.write(bs);
+		} catch (IOException ioe) {
+			// what to do here??
+		}
+	}
+}
diff --git a/modules/wyjc/src/whiley/lang/Any$native.java b/modules/wyjc/src/whiley/lang/Any$native.java
new file mode 100755
index 0000000000..5c14d65268
--- /dev/null
+++ b/modules/wyjc/src/whiley/lang/Any$native.java
@@ -0,0 +1,62 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang;
+
+import wyjc.runtime.Util;
+import wyjc.runtime.WyArray;
+
+public class Any$native {
+	public static WyArray toString(Object o) {
+		return Util.str2il(toRealString(o));
+	}
+	public static WyArray toString(byte b) {
+		return Util.str2il(toRealString(b));
+	}
+	public static java.lang.String toRealString(Object o) {
+		if(o == null) {
+			return "null";
+		} else if(o instanceof java.lang.Byte) {
+			java.lang.Byte b = (java.lang.Byte) o;
+			return toRealString((byte)b);
+		} else {
+			return o.toString();
+		}
+	}
+
+	private static java.lang.String toRealString(byte b) {
+		java.lang.String r = "b";
+		byte v = b;
+		for(int i=0;i!=8;++i) {
+			if((v&0x1) == 1) {
+				r = "1" + r;
+			} else {
+				r = "0" + r;
+			}
+			v = (byte) (v >>> 1);
+		}
+		return r;
+	}
+}
diff --git a/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
new file mode 100755
index 0000000000..2ef64f57a2
--- /dev/null
+++ b/modules/wyjc/src/wyjc/Wyil2JavaBuilder.java
@@ -0,0 +1,2865 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc;
+
+import java.io.*;
+import java.math.BigInteger;
+import java.util.*;
+
+import wybs.lang.Build;
+import wybs.lang.Builder;
+import wycc.lang.Attribute;
+import wycc.lang.NameID;
+import wycc.lang.SyntaxError.InternalFailure;
+import wycc.util.Logger;
+import wycc.util.Pair;
+import wycc.util.ResolveError;
+import wycc.util.Triple;
+import wyfs.io.BinaryOutputStream;
+import wyfs.lang.Path;
+import wyfs.util.Trie;
+import wyil.lang.*;
+import wyil.lang.Constant;
+import wyil.lang.SyntaxTree.Location;
+import wyil.lang.Bytecode.Operator;
+import wyil.lang.Bytecode.VariableDeclaration;
+
+import static wyil.lang.Bytecode.*;
+import wyil.util.TypeSystem;
+
+import static wyjc.Wyil2JavaBuilder.WHILEYBOOL;
+import static wyjc.Wyil2JavaBuilder.WHILEYTYPE;
+import static wyjc.Wyil2JavaBuilder.WHILEYUTIL;
+
+import wyjc.util.BytecodeTranslators;
+import wyjc.util.LambdaTemplate;
+import wyjc.util.WyjcBuildTask;
+import jasm.attributes.LineNumberTable;
+import jasm.attributes.SourceFile;
+import jasm.lang.*;
+import jasm.lang.Bytecode;
+import jasm.lang.Modifier;
+import static jasm.lang.Modifier.*;
+import jasm.verifier.ClassFileVerifier;
+import wyrl.io.JavaIdentifierOutputStream;
+import static jasm.lang.JvmTypes.*;
+
+/**
+ * Responsible for converting WYIL files into Java Classfiles. This is a
+ * relatively straightforward process, given the all the hard work has already
+ * been done by the Whiley-2-Wyil builder.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class Wyil2JavaBuilder implements Builder {
+	private static int CLASS_VERSION = 49;
+
+	/**
+	 * The master project for identifying all resources available to the
+	 * builder. This includes all modules declared in the project being verified
+	 * and/or defined in external resources (e.g. jar files).
+	 */
+	protected final Build.Project project;
+
+	/**
+	 * The type system is useful for managing nominal types and converting them
+	 * into their underlying types.
+	 */
+	protected final TypeSystem typeSystem;
+
+	/**
+	 * For logging information.
+	 */
+	private Logger logger = Logger.NULL;
+
+	/**
+	 * Module being translated
+	 */
+	private WyilFile file;
+
+	/**
+	 * Type of enclosing class being generated
+	 */
+	private JvmType.Clazz owner;
+
+	/**
+	 * The set of generators for individual WyIL bytecodes
+	 */
+	private BytecodeTranslator[] generators;
+
+	/**
+	 * Map of Constant values to their pool index
+	 */
+	private HashMap<JvmConstant, Integer> constants;
+
+	/**
+	 * List of temporary classes created to implement lambda expressions
+	 */
+	private ArrayList<ClassFile> lambdaClasses;
+
+	/**
+	 * List of temporary methods created to implement lambda expressions
+	 */
+	private ArrayList<ClassFile.Method> lambdaMethods;
+	
+	/**
+	 * List of line number entries for current function / method being compiled.
+	 */
+	private ArrayList<LineNumberTable.Entry> lineNumbers;
+
+	public Wyil2JavaBuilder(Build.Project project) {
+		this.project = project;
+		this.typeSystem = new TypeSystem(project);
+		this.generators = BytecodeTranslators.standardFunctions;
+	}
+
+	public void setLogger(Logger logger) {
+		this.logger = logger;
+	}
+
+	public Build.Project project() {
+		return project;
+	}
+
+	public Set<Path.Entry<?>> build(Collection<Pair<Path.Entry<?>, Path.Root>> delta, Build.Graph graph)
+			throws IOException {
+
+		Runtime runtime = Runtime.getRuntime();
+		long start = System.currentTimeMillis();
+		long memory = runtime.freeMemory();
+
+		// ========================================================================
+		// Translate files
+		// ========================================================================
+		HashSet<Path.Entry<?>> generatedFiles = new HashSet<Path.Entry<?>>();
+
+		for (Pair<Path.Entry<?>, Path.Root> p : delta) {
+			Path.Root dst = p.second();
+			Path.Entry<WyilFile> source = (Path.Entry<WyilFile>) p.first();
+			Path.Entry<ClassFile> target = dst.create(source.id(), WyjcBuildTask.ContentType);
+			graph.registerDerivation(source, target);
+			generatedFiles.add(target);
+
+			// Translate WyilFile into JVM ClassFile
+			
+			// FIXME: put these in the context?
+			
+			lambdaClasses = new ArrayList<ClassFile>();
+			lambdaMethods = new ArrayList<ClassFile.Method>();
+			ClassFile contents = build(source.read());
+			contents.methods().addAll(lambdaMethods);
+
+			// Verify the generated file being written
+			//new ClassFileVerifier().apply(contents);
+
+			// Write class file into its destination
+			target.write(contents);
+
+			// Finally, write out any lambda classes + methods created to
+			// support the main class. This is necessary because every
+			// occurrence of a lambda expression in the WyilFile generates an
+			// inner class responsible for calling the given function.
+			Path.ID parent = target.id();
+			Path.ID pkg = parent.subpath(0, parent.size() - 1);
+			for (int i = 0; i != lambdaClasses.size(); ++i) {
+				Path.ID id = pkg.append(parent.last() + "$" + i);
+				Path.Entry<ClassFile> lf = dst.create(id, WyjcBuildTask.ContentType);
+				ClassFile lc = lambdaClasses.get(i);
+				// Verify generated class file
+				new ClassFileVerifier().apply(lc);
+				lf.write(lc);
+				generatedFiles.add(lf);
+			}			
+		}
+
+		// ========================================================================
+		// Done
+		// ========================================================================
+
+		long endTime = System.currentTimeMillis();
+		logger.logTimedMessage("Wyil => Java: compiled " + delta.size() + " file(s)", endTime - start,
+				memory - runtime.freeMemory());
+
+		return generatedFiles;
+	}
+
+	private ClassFile build(WyilFile wyilFile) {
+		this.file = wyilFile;
+		//
+		Path.Entry<WyilFile> entry = wyilFile.getEntry();
+		owner = new JvmType.Clazz(entry.id().parent().toString().replace('.', '/'), entry.id().last());
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);
+		ClassFile cf = new ClassFile(CLASS_VERSION, owner, JAVA_LANG_OBJECT, new ArrayList<JvmType.Clazz>(), modifiers);
+
+		cf.attributes().add(new SourceFile(wyilFile.getEntry().location()));
+
+		boolean addMainLauncher = false;
+
+		constants = new HashMap<JvmConstant, Integer>();
+		for (WyilFile.Block blk : wyilFile.blocks()) {
+			if (blk instanceof WyilFile.FunctionOrMethod) {
+				WyilFile.FunctionOrMethod method = (WyilFile.FunctionOrMethod) blk;
+				if (method.name().equals("main")) {
+					addMainLauncher = true;
+				}
+				cf.methods().addAll(build(method));
+			} else if (blk instanceof WyilFile.Type) {
+				cf.methods().add(build((WyilFile.Type) blk));
+			}
+		}
+
+		buildConstants(constants, lambdaClasses, cf);
+
+		if (addMainLauncher) {
+			cf.methods().add(buildMainLauncher(owner));
+		}
+
+		return cf;
+	}
+
+	private void buildConstants(HashMap<JvmConstant, Integer> constants, ArrayList<ClassFile> lambdas, ClassFile cf) {
+		buildValues(constants, lambdas, cf);
+	}
+
+	private void buildValues(HashMap<JvmConstant, Integer> constants, ArrayList<ClassFile> lambdas, ClassFile cf) {
+		int nvalues = 0;
+		Context context = new Context();
+		
+		for (Map.Entry<JvmConstant, Integer> entry : constants.entrySet()) {
+			JvmConstant c = entry.getKey();
+			if (c instanceof JvmValue) {
+				nvalues++;
+				Constant constant = ((JvmValue) c).value;
+				int index = entry.getValue();
+				// First, create the static final field that will hold this
+				// constant
+				String name = "constant$" + index;
+				List<Modifier> fmods = modifiers(ACC_PRIVATE, ACC_STATIC, ACC_FINAL);
+				JvmType type = toJvmType(constant.type());
+				ClassFile.Field field = new ClassFile.Field(name, type, fmods);
+				cf.fields().add(field);
+				// Now, create code to intialise this field
+				translateConstant(constant, context);
+				context.add(new Bytecode.PutField(owner, name, type, Bytecode.FieldMode.STATIC));
+			}
+		}
+
+		if (nvalues > 0) {
+			// create static initialiser method, but only if we really need to.
+			context.add(new Bytecode.Return(null));
+			List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC);
+			JvmType.Function ftype = new JvmType.Function(new JvmType.Void());
+			ClassFile.Method clinit = new ClassFile.Method("<clinit>", ftype, modifiers);
+			cf.methods().add(clinit);
+			// finally add code for staticinitialiser method			
+			jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), Collections.EMPTY_LIST, clinit);
+			clinit.attributes().add(code);
+		}
+	}
+
+	private ClassFile.Method buildMainLauncher(JvmType.Clazz owner) {
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_SYNTHETIC, ACC_STATIC);
+		JvmType.Function ft1 = new JvmType.Function(T_VOID, new JvmType.Array(JAVA_LANG_STRING));
+		ClassFile.Method cm = new ClassFile.Method("main", ft1, modifiers);
+		JvmType.Array strArr = new JvmType.Array(JAVA_LANG_STRING);
+		ArrayList<Bytecode> codes = new ArrayList<Bytecode>();
+		ft1 = new JvmType.Function(WHILEYRECORD, new JvmType.Array(JAVA_LANG_STRING));
+		codes.add(new Bytecode.Load(0, strArr));
+		codes.add(new Bytecode.Invoke(WHILEYUTIL, "systemConsole", ft1, Bytecode.InvokeMode.STATIC));
+		Type.Method wyft = Type.Method(new Type[0], Collections.<String> emptySet(), Collections.<String> emptyList(),
+				WHILEY_SYSTEM_T);
+		JvmType.Function ft3 = convertFunType(wyft);
+		codes.add(new Bytecode.Invoke(owner, nameMangle("main", wyft), ft3, Bytecode.InvokeMode.STATIC));
+		codes.add(new Bytecode.Return(null));
+
+		jasm.attributes.Code code = new jasm.attributes.Code(codes, new ArrayList(), cm);
+		cm.attributes().add(code);
+
+		return cm;
+	}
+
+	/**
+	 * Construct a method for accepting the constraints on this particular type.
+	 * 
+	 * @param td
+	 */
+	private ClassFile.Method build(WyilFile.Type td) {
+		List<Location<Expr>> td_invariants = td.getInvariant();
+		//
+		JvmType underlyingType = toJvmType(td.type());
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_SYNTHETIC);
+		JvmType.Function funType = new JvmType.Function(T_BOOL, underlyingType);
+		ClassFile.Method cm = new ClassFile.Method(td.name() + "$typeof", funType, modifiers);
+		// Generate code for testing implicit invariants of type (if any). That
+		// is, invariants implied by (nominal) component types.
+		Context context = new Context();
+		String falseLabel = freshLabel();
+		translateInvariantTest(falseLabel, td.type(), 0, 1, context);
+		// Generate code for testing explicit invariants of type (if any). To do
+		// this, we chain them together into a sequence of checks.
+		for (int i = 0; i != td_invariants.size(); ++i) {
+			translateExpression(td_invariants.get(i), context);
+			JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
+			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+		}			
+		// If we reach this point, then invariants must hold.
+		context.add(new Bytecode.LoadConst(true));
+		context.add(new Bytecode.Return(new JvmType.Bool()));
+		// Add the false label (in case it was used)
+		context.add(new Bytecode.Label(falseLabel));
+		context.add(new Bytecode.LoadConst(false));
+		context.add(new Bytecode.Return(new JvmType.Bool()));
+		// Done
+		jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), new ArrayList(), cm);
+		cm.attributes().add(code);
+		return cm;
+	}
+
+	private List<ClassFile.Method> build(WyilFile.FunctionOrMethod method) {
+		ArrayList<ClassFile.Method> methods = new ArrayList<ClassFile.Method>();
+
+		// Firstly, check to see whether or not this is a native method. Native
+		// methods are treated specially and redirect to the same-named methods,
+		// but with "$native" appended.
+		if (method.hasModifier(wyil.lang.Modifier.NATIVE)) {
+			methods.add(buildNativeOrExport(method, constants));
+		} else {
+			// Secondly, check to whether or not this is an exported method.
+			// Exported methods generate a single stub without name mangling
+			// that redirects to the actual method. This means that the actual
+			// method can be called as usual from within Whiley code, whilst
+			// external calls are correctly redirected.
+			if (method.hasModifier(wyil.lang.Modifier.EXPORT)) {
+				methods.add(buildNativeOrExport(method, constants));
+			}
+			// Finally, translate the method and its body.
+			methods.add(translate(method));
+		}
+
+		return methods;
+	}
+
+	/**
+	 * Construct a trampoline for handling native or export methods. In the
+	 * context of native methods, this generates a method which redirects to a
+	 * method which has the same name, but with "$native" appended on the end.
+	 * This method is implemented elsewhere and must be provided by the author
+	 * of this module. For export methods, this means providing a method without
+	 * name mangling which redirects to the method with name mangling.
+	 * 
+	 * @param method
+	 * @param constants
+	 * @return
+	 */
+	private ClassFile.Method buildNativeOrExport(WyilFile.FunctionOrMethod method,
+			HashMap<JvmConstant, Integer> constants) {
+		// Preliminaries
+		List<Modifier> modifiers = modifiers(ACC_STATIC,
+				method.hasModifier(wyil.lang.Modifier.PUBLIC) ? ACC_PUBLIC : null);
+		JvmType.Function ft = convertFunType(method.type());
+		// Apply name mangling (if applicable)
+		String name = method.name();
+		if (method.hasModifier(wyil.lang.Modifier.NATIVE)) {
+			name = nameMangle(method.name(), method.type());
+		}
+		// Construct method body
+		ClassFile.Method cm = new ClassFile.Method(name, ft, modifiers);
+		ArrayList<Bytecode> codes = translateNativeOrExport(method);
+		jasm.attributes.Code code = new jasm.attributes.Code(codes, Collections.EMPTY_LIST, cm);
+		cm.attributes().add(code);
+		// Done
+		return cm;
+	}
+
+	/**
+	 * Construct the body a "trampoline" method for handling native and export
+	 * methods.
+	 * 
+	 * @param method
+	 * @return
+	 */
+	private ArrayList<Bytecode> translateNativeOrExport(WyilFile.FunctionOrMethod method) {
+		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
+		Type.FunctionOrMethod ft = method.type();
+		int slot = 0;
+		// Load all parameters provided to this method ontot he stack
+		for (Type param : ft.params()) {
+			bytecodes.add(new Bytecode.Load(slot++, toJvmType(param)));
+		}
+		// Determine the target class and method for the invocation
+		JvmType.Clazz targetClass;
+		String targetMethod;
+		if (method.hasModifier(wyil.lang.Modifier.NATIVE)) {
+			targetClass = new JvmType.Clazz(owner.pkg(), owner.components().get(0).first(), "native");
+			targetMethod = method.name();
+		} else {
+			targetClass = new JvmType.Clazz(owner.pkg(), owner.components().get(0).first());
+			targetMethod = nameMangle(method.name(), method.type());
+		}
+		// Perform the invocation itself which constitutes the "trampoline"
+		bytecodes.add(new Bytecode.Invoke(targetClass, targetMethod, convertFunType(ft), Bytecode.InvokeMode.STATIC));
+		// Finally, return any values obtained from the invocation as necessary
+		JvmType returnType = null;
+		if (!ft.returns().isEmpty()) {
+			returnType = toJvmType(ft.returns().get(0));
+		}
+		bytecodes.add(new Bytecode.Return(returnType));
+		// Done
+		return bytecodes;
+	}
+
+	/**
+	 * Translate a given method or function. This generates a corresponding
+	 * function or method on the JVM which has the same name, plus a type
+	 * mangle.
+	 * 
+	 * @param method
+	 * @return
+	 */
+	private ClassFile.Method translate(WyilFile.FunctionOrMethod method) {
+		// Preliminaries
+		List<Modifier> modifiers = modifiers(ACC_STATIC,
+				method.hasModifier(wyil.lang.Modifier.PUBLIC) ? ACC_PUBLIC : null);
+		JvmType.Function ft = convertFunType(method.type());
+		// Construct the method itself
+		String name = nameMangle(method.name(), method.type());
+		ClassFile.Method cm = new ClassFile.Method(name, ft, modifiers);
+		// Translate the method body
+		lineNumbers = new ArrayList<LineNumberTable.Entry>();
+		Context context = new Context();		
+		translateBlock(method.getBody(),context);
+		// Add return bytecode (if necessary)
+		addReturnBytecode(context);
+		//
+		jasm.attributes.Code code = new jasm.attributes.Code(context.getBytecodes(), Collections.EMPTY_LIST, cm);
+		if (!lineNumbers.isEmpty()) {
+			code.attributes().add(new LineNumberTable(lineNumbers));
+		}
+		cm.attributes().add(code);
+		// Done
+		return cm;
+	}
+
+	/**
+	 * Every JVM method must be terminated by a return bytecode. This method
+	 * simply adds one if none was already generated.
+	 * 
+	 * @param context
+	 */
+	private void addReturnBytecode(Context context) {
+		List<Bytecode> bytecodes = context.getBytecodes();
+		if (bytecodes.size() > 0) {
+			Bytecode last = bytecodes.get(bytecodes.size() - 1);
+			if (last instanceof Bytecode.Return) {
+				// No return bytecode is needed
+				return;
+			}
+		}
+		// A return bytecode is needed
+		bytecodes.add(new Bytecode.Return(null));
+	}
+
+	// ===============================================================================
+	// Statements & Blocks
+	// ===============================================================================
+
+	/**
+	 * Translates all bytecodes in a given code block. This may be an outermost
+	 * block, or a nested block as part of e.g. a loop.
+	 * 
+	 * @param parentIndex
+	 *            The index of the enclosing bytecode (e.g. loop), or null (if
+	 *            outermost)
+	 * @param block
+	 *            WyIL bytecodes to be translated.
+	 * @param bytecodes
+	 *            List of bytecodes being accumulated
+	 */
+	private void translateBlock(SyntaxTree.Location<Block> block, Context context) {
+		for(int i=0;i!=block.numberOfOperands();++i) {
+			translateStatement(block.getOperand(i), context);
+		}
+	}
+
+	/**
+	 * Translate a WyIL bytecode at a given index into one or more JVM
+	 * bytecodes. The bytecode index is given to help with debugging (i.e. to
+	 * extract attributes associated with the given bytecode).
+	 * 
+	 */
+	private void translateStatement(Location<?> stmt, Context context) {
+		try {
+			switch (stmt.getOpcode()) {
+			case OPCODE_assert:
+			case OPCODE_assume:
+				translateAssertOrAssume((Location<AssertOrAssume>) stmt, context);
+				break;
+			case OPCODE_assign:
+				translateAssign((Location<Assign>) stmt, context);
+				break;
+			case OPCODE_break:
+				translateBreak((Location<Break>) stmt, context);
+				break;
+			case OPCODE_continue:
+				translateContinue((Location<Continue>) stmt, context);
+				break;
+			case OPCODE_debug:
+				translateDebug((Location<Debug>) stmt, context);
+				break;
+			case OPCODE_dowhile:
+				translateDoWhile((Location<DoWhile>) stmt, context);
+				break;
+			case OPCODE_fail:
+				translateFail((Location<Fail>) stmt, context);
+				break;
+			case OPCODE_if:
+			case OPCODE_ifelse:
+				translateIf((Location<If>) stmt, context);
+				break;
+			case OPCODE_invoke:
+			case OPCODE_indirectinvoke:
+				translateInvokeAsStmt(stmt,context);
+				break;
+			case OPCODE_namedblock:
+				translateNamedBlock((Location<NamedBlock>) stmt, context);
+				break;
+			case OPCODE_while:
+				translateWhile((Location<While>) stmt, context);
+				break;
+			case OPCODE_return:
+				translateReturn((Location<Return>) stmt, context);
+				break;
+			case OPCODE_skip:
+				translateSkip((Location<Skip>) stmt, context);
+				break;
+			case OPCODE_switch:
+				translateSwitch((Location<Switch>) stmt, context);
+				break;
+			case OPCODE_vardecl:
+			case OPCODE_vardeclinit:
+				translateVariableDeclaration((Location<VariableDeclaration>) stmt, context);
+				break;	
+			default:
+				throw new InternalFailure("unknown bytecode encountered (" + stmt + ")", file.getEntry(), stmt);
+			}
+		} catch (InternalFailure ex) {
+			throw ex;
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), stmt, ex);
+		}
+	}
+
+	private void translateAssertOrAssume(Location<AssertOrAssume> c, Context context) {
+		String trueLabel = freshLabel();
+		translateCondition(c.getOperand(0), trueLabel, null, context);
+		context.construct(JAVA_LANG_RUNTIMEEXCEPTION);
+		context.add(new Bytecode.Throw());
+		context.add(new Bytecode.Label(trueLabel));
+	}
+
+	/**
+	 * Translate an assignment statement.
+	 * 
+	 * @param code
+	 * @param context
+	 */
+	private void translateAssign(Location<Assign> code, Context context) {
+		Location<?>[] lhs = code.getOperandGroup(0);
+		Location<?>[] rhs = code.getOperandGroup(1);
+		// Translate and construct the lvals for this assignment. This
+		// will store all lval operands (e.g. array indices) into their
+		// corresponding operand register. To preserve the semantics of Whiley,
+		// we must translate the lhs before the rhs.
+		LVal[] lvals = translateLVals(lhs, context);
+		// Translate the operands in reverse order onto the stack, produce a
+		// type for each operand produced. The number of types may be larger
+		// than the number of rhs opeands in the case of an operand with
+		// multiple return values.
+		List<JvmType> types = translateExpressions(rhs, context);
+
+		// Now, store each operand into the slot location so that we can more
+		// easily access it later. This basically relies on an assumption that
+		// translateSimpleAssign() does not use any free registers during its
+		// translation.
+		int freeRegister = getFirstFreeRegister(code.getEnclosingTree());
+		for (int i = types.size() - 1; i >= 0; i = i - 1) {
+			context.add(new Bytecode.Store(freeRegister+i, types.get(i)));
+		}
+		// Assign each operand to the target lval.
+		int i = 0;
+		for (; i != lhs.length; ++i) {
+			translateSimpleAssign(lvals[i], freeRegister+i, types.get(i), context);
+		}
+		// Finally, pop any remaining operands off the stack. This can happen if
+		// values are being discarded.
+		for (; i < types.size(); ++i) {
+			context.add(new Bytecode.Pop(types.get(i)));
+		}
+	}
+
+	/**
+	 * Translate a simple assignment statement. This is one which is assigning a
+	 * single value into an lval, which could be either a variable, a field
+	 * assignment, an array element assignment or a dereference assignment. The
+	 * assigned value is assumed to have already been loaded on the stack.
+	 * 
+	 * @param lhs
+	 * @param rhsType
+	 */
+	private void translateSimpleAssign(LVal lhs, int rhs, JvmType type, Context context) {
+		if (lhs.path.size() > 0) {
+			// This is the complex case of an assignment to an element of a
+			// compound.
+			context.add(new Bytecode.Load(lhs.variable, type));
+			translateUpdate(lhs.path.iterator(), rhs, context);
+			context.add(new Bytecode.Store(lhs.variable, type));
+		} else {
+			// This is the simple case of a direct assignment to a single
+			// variable.
+			context.add(new Bytecode.Load(rhs, type));
+			context.add(new Bytecode.Store(lhs.variable, type));
+		}
+	}
+
+	/**
+	 * <p>
+	 * Translate the assignment to an LVal by iterating through the chain of
+	 * LVals, starting at the outermost and working inwards. For example:
+	 * </p>
+	 * 
+	 * <pre>
+	 * xs[i].f = 0
+	 * </pre>
+	 * <p>
+	 * In the above update, we have two LVals: an ArrayLVal and a RecordLVal.
+	 * The ArrayLVal is considered the "outermost" and the RecordLVal is
+	 * consider the "innermost". To translate this we pass the "current" value
+	 * for each level onto the next, which returns the "updated" value that we
+	 * then apply.
+	 * </p>
+	 * 
+	 * @param iterator
+	 *            --- Update iterator.
+	 * @param context
+	 */
+	private void translateUpdate(Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
+		// At this point, we have not yet reached the "innermost" position.
+		// Therefore, we keep recursing down the chain of LVals.
+		LVal.Element<?> lv = iterator.next();
+		if (lv instanceof LVal.Array) {
+			translateUpdate((LVal.Array) lv, iterator, rhs, context);
+		} else if (lv instanceof LVal.Record) {
+			translateUpdate((LVal.Record) lv, iterator, rhs, context);
+		} else {
+			translateUpdate((LVal.Reference) lv, iterator, rhs, context);
+		}
+	}
+
+	/**
+	 * <p>
+	 * Translate an assignment to an Array Lval. There are two essential cases
+	 * to consider:
+	 * </p>
+	 * 
+	 * <pre>
+	 * x[i] = 0
+	 * x.f[i] = 0
+	 * </pre>
+	 * 
+	 * <p>
+	 * In the first one, we have the array LVal as the "outermost" component of
+	 * the assignment. In the second one, it is part of an assignment to a
+	 * larger LVal which contains it (in this case, a record LVal).
+	 * </p>
+	 * 
+	 * @param lval
+	 * @param iterator
+	 * @param code
+	 * @param bytecodes
+	 */
+	private void translateUpdate(LVal.Array lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
+		if (iterator.hasNext()) {
+			// This is not the innermost case, hence we read out the current
+			// value of the location being assigned and pass that forward to the
+			// next stage.
+			context.add(new Bytecode.Dup(WHILEYARRAY));
+			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
+			JvmType.Function getFunType = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYARRAY, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
+			context.addReadConversion(lval.type.element());
+			translateUpdate(iterator, rhs, context);
+			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
+			context.add(new Bytecode.Swap());
+		} else {
+			// This is the innermost case, hence we can avoid the unnecessary
+			// read of the current value and, instead, just return the rhs value
+			// directly.
+			Type type = lval.type.element();
+			context.add(new Bytecode.Load(lval.index.getIndex(), WHILEYINT));
+			context.add(new Bytecode.Load(rhs, toJvmType(type)));
+			context.addWriteConversion(type);
+		}
+		JvmType.Function setFunType = new JvmType.Function(WHILEYARRAY, WHILEYARRAY, WHILEYINT, JAVA_LANG_OBJECT);
+		context.add(new Bytecode.Invoke(WHILEYARRAY, "set", setFunType, Bytecode.InvokeMode.STATIC));
+	}
+
+	private void translateUpdate(LVal.Record lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
+		Type.EffectiveRecord type = lval.type;
+		if (iterator.hasNext()) {
+			// This is not the innermost case, hence we read out the current
+			// value of the location being assigned and pass that forward to the
+			// next stage.
+			context.add(new Bytecode.Dup(WHILEYRECORD));
+			context.add(new Bytecode.LoadConst(lval.field));
+			JvmType.Function getFunType = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYRECORD, JAVA_LANG_STRING);
+			context.add(new Bytecode.Invoke(WHILEYRECORD, "internal_get", getFunType, Bytecode.InvokeMode.STATIC));
+			context.addReadConversion(type.field(lval.field));
+			translateUpdate(iterator, rhs, context);
+			context.add(new Bytecode.LoadConst(lval.field));
+			context.add(new Bytecode.Swap());
+		} else {
+			// This is the innermost case, hence we can avoid the unnecessary
+			// read of the current value and, instead, just return the rhs value
+			// directly.
+			context.add(new Bytecode.LoadConst(lval.field));
+			context.add(new Bytecode.Load(rhs, toJvmType(type.field(lval.field))));
+			context.addWriteConversion(type.field(lval.field));
+		}
+		JvmType.Function putFunType = new JvmType.Function(WHILEYRECORD, WHILEYRECORD, JAVA_LANG_STRING,
+				JAVA_LANG_OBJECT);
+		context.add(new Bytecode.Invoke(WHILEYRECORD, "put", putFunType, Bytecode.InvokeMode.STATIC));
+	}
+
+	private void translateUpdate(LVal.Reference lval, Iterator<LVal.Element<?>> iterator, int rhs, Context context) {
+		if (iterator.hasNext()) {
+			// This is not the innermost case, hence we read out the current
+			// value of the location being assigned and pass that forward to the
+			// next stage.
+			context.add(new Bytecode.Dup(WHILEYOBJECT));
+			JvmType.Function getFunType = new JvmType.Function(JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Invoke(WHILEYOBJECT, "state", getFunType, Bytecode.InvokeMode.VIRTUAL));
+			context.addReadConversion(lval.type.element());
+			translateUpdate(iterator, rhs, context);
+		} else {
+			// This is the innermost case, hence we can avoid the unnecessary
+			// read of the current value and, instead, just return the rhs value
+			// directly.
+			JvmType rhsJvmType = toJvmType(lval.type.element());
+			context.add(new Bytecode.Load(rhs, rhsJvmType));
+		}
+		JvmType.Function setFunType = new JvmType.Function(WHILEYOBJECT, JAVA_LANG_OBJECT);
+		context.add(new Bytecode.Invoke(WHILEYOBJECT, "setState", setFunType, Bytecode.InvokeMode.VIRTUAL));
+	}
+
+	private void translateBreak(Location<Break> c, Context context) {
+		context.add(new Bytecode.Goto(context.getBreakLabel()));
+	}
+	
+	private void translateContinue(Location<Continue> c, Context context) {
+		context.add(new Bytecode.Goto(context.getContinueLabel()));
+	}
+	
+	private void translateDebug(Location<Debug> c, Context context) {
+		JvmType.Function ftype = new JvmType.Function(T_VOID, WHILEYARRAY);
+		translateExpression(c.getOperand(0), context);
+		context.add(new Bytecode.Invoke(WHILEYUTIL, "print", ftype, Bytecode.InvokeMode.STATIC));
+	}
+
+	private void translateDoWhile(Location<DoWhile> c, Context context) {
+		// Allocate header label for loop
+		String headerLabel = freshLabel();
+		String breakLabel = freshLabel();
+		context.add(new Bytecode.Label(headerLabel));
+		// Translate body of loop.
+		translateBlock(c.getBlock(0),context.newLoopBlock(breakLabel, headerLabel));
+		// Translate the loop condition.
+		translateCondition(c.getOperand(0), headerLabel, null, context);
+		context.add(new Bytecode.Label(breakLabel));
+	}
+
+	private void translateFail(Location<Fail> c, Context context) {
+		context.add(new Bytecode.New(JAVA_LANG_RUNTIMEEXCEPTION));
+		context.add(new Bytecode.Dup(JAVA_LANG_RUNTIMEEXCEPTION));
+		context.add(new Bytecode.LoadConst("runtime fault encountered"));
+		JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_STRING);
+		context.add(new Bytecode.Invoke(JAVA_LANG_RUNTIMEEXCEPTION, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+		context.add(new Bytecode.Throw());
+	}
+
+	private void translateIf(Location<If> code, Context context) {
+		If bytecode = code.getBytecode();
+		String exitLabel = freshLabel();
+		String falseLabel = bytecode.hasFalseBranch() ? freshLabel() : exitLabel;
+		// First, translate the condition
+		translateCondition(code.getOperand(0), null, falseLabel, context);
+		// Second, translate the true branch
+		translateBlock(code.getBlock(SyntaxTree.TRUEBRANCH), context);
+		if (bytecode.hasFalseBranch()) {
+			// Third, translate false branch (if applicable)
+			context.add(new Bytecode.Goto(exitLabel));
+			context.add(new Bytecode.Label(falseLabel));
+			translateBlock(code.getBlock(SyntaxTree.FALSEBRANCH), context);
+			context.add(new Bytecode.Label(exitLabel));
+		} else {
+			context.add(new Bytecode.Label(falseLabel));
+		}
+	}
+
+	private void translateReturn(Location<Return> c, Context context) {
+		Location<?>[] operands = c.getOperands();
+		JvmType rt;
+		//
+		switch (operands.length) {
+		case 0:
+			// No return value.
+			rt = null;
+			break;
+		case 1:
+			// Exactly one return value, so we can (potentially) return it
+			// directly.
+			Location<?> operand = operands[0];
+			if(operand.numberOfTypes() == 1) {
+				// Yes, we can return directly.
+				translateExpression(operand, context);
+				// Determine return type
+				rt = toJvmType(operand.getType());
+				break;
+			}
+		default:
+			// More than one return value. In this case, we need to encode the
+			// return values into an object array. This is annoying, but it's
+			// because Java doesn't support multiple return values.
+			int freeRegister = getFirstFreeRegister(c.getEnclosingTree());
+			translateExpressionsToArray(operands, freeRegister, context);
+			rt = JAVA_LANG_OBJECT_ARRAY;			
+		}
+		// Done
+		context.add(new Bytecode.Return(rt));
+	}
+
+	private void translateSkip(Location<Skip> code, Context context) {
+		context.add(new Bytecode.Nop()); // easy
+	}
+	
+	private void translateSwitch(Location<Switch> code, Context context) {
+		String exitLabel = freshLabel();
+		Location<?> condition = code.getOperand(0);
+		JvmType type = toJvmType(condition.getType());
+		// Translate condition into a value and store into a temporary register.
+		// This is necessary because, according to the semantics of Whiley, we
+		// can only execute the condition expression once.
+		translateExpression(condition, context);
+		context.add(new Bytecode.Store(condition.getIndex(), type));
+		ArrayList<String> labels = new ArrayList<String>();
+		// Generate the dispatch table which checks the condition value against
+		// each of the case constants. If a match is found, we branch to a given
+		// label demarking the start of the case body (which will be translated
+		// later). In principle, using a tableswitch bytecode would be better
+		// here.
+		boolean hasDefault = false;
+		Case[] cases = code.getBytecode().cases();
+		for (int i = 0; i != code.numberOfBlocks(); ++i) {
+			Constant[] values = cases[i].values();
+			String caseLabel = freshLabel();
+			if (values.length == 0) {
+				// In this case, we have a default target which corresponds to
+				// an unconditional branch
+				context.add(new Bytecode.Goto(caseLabel));
+				hasDefault = true;
+			} else {
+				for (Constant value : values) {
+					translateConstant(value, context);
+					context.add(new Bytecode.Load(condition.getIndex(), type));
+					JvmType.Function ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+					context.add(new Bytecode.Invoke(WHILEYUTIL, "equals", ftype, Bytecode.InvokeMode.STATIC));
+					context.add(new Bytecode.If(Bytecode.IfMode.NE, caseLabel));
+				}
+			}
+			labels.add(caseLabel);
+		}
+		// If there was no default case, then add an unconditional branch over
+		// the case bodies to the end of the switch.
+		if (!hasDefault) {
+			context.add(new Bytecode.Goto(exitLabel));
+		}
+		// Translate each of the case bodies in turn.
+		for (int i = 0; i != cases.length; ++i) {
+			context.add(new Bytecode.Label(labels.get(i)));
+			translateBlock(code.getBlock(i), context);
+			context.add(new Bytecode.Goto(exitLabel));
+		}
+		// Finally, mark out the exit point of the switch
+		context.add(new Bytecode.Label(exitLabel));
+	}
+
+	private void translateNamedBlock(Location<NamedBlock> c, Context context) {
+		translateBlock(c.getBlock(0),context);
+	}
+	
+	private void translateWhile(Location<While> c, Context context) {
+		// Allocate header label for loop
+		String headerLabel = freshLabel();
+		String exitLabel = freshLabel();
+		context.add(new Bytecode.Label(headerLabel));
+		// Translate the loop condition.
+		translateCondition(c.getOperand(0), null, exitLabel, context);
+		// Translate body of loop.
+		translateBlock(c.getBlock(0),context.newLoopBlock(exitLabel, headerLabel));
+		// Terminate loop by branching back to head of loop
+		context.add(new Bytecode.Goto(headerLabel));
+		// This is where we exit the loop
+		context.add(new Bytecode.Label(exitLabel));
+	}
+
+	private void translateInvokeAsStmt(Location<?> stmt, Context context) {
+		// First, translate the invocation
+		List<Type> returns;		
+		if(stmt.getOpcode() == OPCODE_invoke) {
+			Location<Invoke> e = (Location<Invoke>) stmt; 			
+			translateInvoke(e, context);
+			returns = e.getBytecode().type().returns();
+		} else {			
+			Location<IndirectInvoke> e = (Location<IndirectInvoke>) stmt;
+			translateIndirectInvoke(e, context);
+			returns = e.getBytecode().type().returns();
+		}		
+		// Second, if there are results, pop them off the stack		
+		for(int i=0;i!=returns.size();++i) {
+			JvmType returnType = context.toJvmType(returns.get(i));
+			context.add(new Bytecode.Pop(returnType));
+		} 
+	}
+	
+	private void translateVariableDeclaration(Location<VariableDeclaration> code, Context context) {
+		if(code.numberOfOperands() > 0) {
+			JvmType type = context.toJvmType(code.getType());
+			translateExpression(code.getOperand(0),context);
+			context.add(new Bytecode.Store(code.getIndex(),type));
+		}
+	}
+	
+	// ===============================================================================
+	// LVals
+	// ===============================================================================
+
+	/**
+	 * Construct an array of LVals, one for each operand on the left-hand side
+	 * of an assignment. Each LVal provides a simple "path" representation of
+	 * the left-hand side with which we can more easily generate code for
+	 * implement the update.
+	 * 
+	 * @param lval
+	 *            LVal operand to translate
+	 * @param context
+	 * @return
+	 */
+	public LVal[] translateLVals(Location<?>[] lvals, Context context) {
+		LVal[] vals = new LVal[lvals.length];
+		for (int i = 0; i != vals.length; ++i) {
+			LVal lval = generateLVal(lvals[i], context);
+			translateLVal(lval, context);
+			vals[i] = lval;
+		}
+		return vals;
+	}
+
+	/**
+	 * <p>
+	 * Translate any operands for an LVal expression in left-to-right order.
+	 * This only applies to array lvals, as these have operands which need to be
+	 * evaluated.
+	 * </p>
+	 * 
+	 * <p>
+	 * <b>NOTE:</b> For simplicity, we just load any lval operands into their
+	 * corresponding bytecode registers.
+	 * </p>
+	 * 
+	 * @param lval
+	 * @param context
+	 */
+	public void translateLVal(LVal lval, Context context) {
+		for (LVal.Element<?> e : lval.path) {
+			if (e instanceof LVal.Array) {
+				LVal.Array ae = (LVal.Array) e;
+				translateExpression(ae.index, context);
+				context.add(new Bytecode.Store(ae.index.getIndex(), WHILEYINT));
+			}
+		}
+	}
+
+	/**
+	 * Generate an LVal expression from the left-hand side of an assignment. An
+	 * LVal expression is basically just a path representation of the lhs
+	 * expression.
+	 * 
+	 * @param lval
+	 *            LVal operand to translate
+	 * @param context
+	 * @return
+	 */
+	public LVal generateLVal(Location<?> lval, Context context) {
+		ArrayList<LVal.Element<?>> path = new ArrayList<LVal.Element<?>>();
+		while (lval.getOpcode() != OPCODE_varaccess) {
+			try {
+				wyil.lang.Bytecode.Expr code = (wyil.lang.Bytecode.Expr) lval.getBytecode();
+				switch (code.getOpcode()) {
+				case OPCODE_fieldload:
+					lval = lval.getOperand(0);
+					Type.EffectiveRecord recType = typeSystem.expandAsEffectiveRecord(lval.getType());
+					wyil.lang.Bytecode.FieldLoad fl = (wyil.lang.Bytecode.FieldLoad) code;
+					path.add(new LVal.Record(recType, fl.fieldName()));
+					break;
+				case OPCODE_arrayindex:
+					Location<?> index = lval.getOperand(1);
+					lval = lval.getOperand(0);
+					Type.EffectiveArray arrayType = typeSystem.expandAsEffectiveArray(lval.getType());
+					path.add(new LVal.Array(arrayType, index));
+					break;
+				case OPCODE_dereference:
+					lval = lval.getOperand(0);
+					Type.Reference refType = typeSystem.expandAsReference(lval.getType());
+					path.add(new LVal.Reference(refType));
+					break;
+				default:
+					throw new InternalFailure("unknown bytecode encountered (" + code + ")", file.getEntry(), lval);
+				}
+			} catch (ResolveError e) {
+				throw new InternalFailure(e.getMessage(), file.getEntry(), lval, e);
+			}
+		}
+		// At this point, we have to reverse the lvals because they were put
+		// into the array in the wrong order.
+		Collections.reverse(path);
+		// Done
+		Location<VariableDeclaration> decl = getVariableDeclaration(lval);
+		return new LVal(decl.getIndex(), path);
+	}
+
+	/**
+	 * Represents a type which may appear on the left of an assignment
+	 * expression. Arrays, Records and References are the only valid types for
+	 * an lval.
+	 *
+	 * @author David J. Pearce
+	 *
+	 */
+	public static class LVal {
+		public final int variable;
+		public final List<Element<?>> path;
+
+		public LVal(int variable, List<Element<?>> path) {
+			this.variable = variable;
+			this.path = new ArrayList<Element<?>>(path);
+		}
+
+		public static class Element<T> {
+			public final T type;
+
+			public Element(T type) {
+				this.type = type;
+			}
+		}
+
+		public static class Record extends Element<Type.EffectiveRecord> {
+			public final String field;
+
+			public Record(Type.EffectiveRecord type, String field) {
+				super(type);
+				this.field = field;
+			}
+		}
+
+		public static class Array extends Element<Type.EffectiveArray> {
+			public final Location<?> index;
+
+			public Array(Type.EffectiveArray type, Location<?> index) {
+				super(type);
+				this.index = index;
+			}
+		}
+
+		public static class Reference extends Element<Type.Reference> {
+			public Reference(Type.Reference type) {
+				super(type);
+			}
+		}
+	}
+
+	// ===============================================================================
+	// Conditions
+	// ===============================================================================
+
+	/**
+	 * <p>
+	 * Translate a given condition to determine whether it holds or not, then
+	 * branch to an appropriate label. If so, branch to the given true label, or
+	 * continue to next logical instruction if null. If not, branch to the given
+	 * false label, or continue to next logical instruction if null.
+	 * </p>
+	 * 
+	 * <p>
+	 * <b>NOTE:</b> Exactly one of trueLabel or falseLabel must be null to
+	 * represent the fall-thru case.
+	 * </p>
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateCondition(Location<?> condition, String trueLabel, String falseLabel, Context enclosing) {
+		// First, handle the special cases as necessar.
+		switch (condition.getOpcode()) {
+		case OPCODE_logicalnot:
+			translateNotCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
+			return;
+		case OPCODE_logicaland:
+			translateShortcircuitAndCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
+			return;
+		case OPCODE_logicalor:
+			translateShortcircuitOrCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
+			return;
+		case OPCODE_all:
+		case OPCODE_some:
+			translateQuantifierCondition((Location<Quantifier>) condition, trueLabel, falseLabel, enclosing);
+			return;
+		case OPCODE_is:
+			translateIsCondition((Location<Operator>) condition, trueLabel, falseLabel, enclosing);
+			return;
+		}
+		// We can't use a condition branch, so fall back to the default. In this
+		// case, we just evaluate the condition as normal which will result in a
+		// 1 or 0 being loaded on the stack. We can then perform a condition
+		// branch from that.
+		translateExpression(condition, enclosing);
+		// Now, dig a true boolean about of the WyBool object
+		JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
+		enclosing.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
+		// Finally, branch as necessary
+		if (trueLabel == null) {
+			enclosing.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+		} else {
+			enclosing.add(new Bytecode.If(Bytecode.IfMode.NE, trueLabel));
+		}
+	}
+
+	/**
+	 * Translate a logical not condition.
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateNotCondition(Location<?> code, String trueLabel, String falseLabel,
+			Context enclosing) {
+		// This case is very easy, as we can just swap the true and false
+		// labels.
+		translateCondition(code.getOperand(0), falseLabel, trueLabel, enclosing);
+	}
+
+	/**
+	 * Translate a logical and condition with short circuiting semantics.
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateShortcircuitAndCondition(Location<?> code, String trueLabel, String falseLabel,
+			Context enclosing) {
+		if (trueLabel == null) {
+			translateCondition(code.getOperand(0), null, falseLabel, enclosing);
+			translateCondition(code.getOperand(1), null, falseLabel, enclosing);
+		} else {
+			// implies falseLabel should be null
+			String exitLabel = freshLabel();
+			translateCondition(code.getOperand(0), null, exitLabel, enclosing);
+			translateCondition(code.getOperand(1), trueLabel, null, enclosing);
+			enclosing.add(new Bytecode.Label(exitLabel));
+		}
+	}
+
+	/**
+	 * Translate a logical or condition with short circuiting semantics.
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateShortcircuitOrCondition(Location<?> code, String trueLabel, String falseLabel,
+			Context enclosing) {
+		if (trueLabel == null) {
+			// implies false label is non-null
+			String exitLabel = freshLabel();
+			translateCondition(code.getOperand(0), exitLabel, null, enclosing);
+			translateCondition(code.getOperand(1), null, falseLabel, enclosing);
+			enclosing.add(new Bytecode.Label(exitLabel));
+		} else {
+			// implies false label is null
+			translateCondition(code.getOperand(0), trueLabel, null, enclosing);
+			translateCondition(code.getOperand(1), trueLabel, null, enclosing);
+		}
+	}
+
+
+	/**
+	 * Translate a quantifier condition into a set of nested loops with the
+	 * condition itself located in the innermost position.
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateQuantifierCondition(Location<?> condition, String trueLabel, String falseLabel,
+			Context context) {
+		String exitLabel = freshLabel();
+		if(trueLabel == null) {
+			trueLabel = exitLabel;
+		} else {
+			falseLabel = exitLabel;
+		}
+		translateQuantifierCondition(0, condition, trueLabel, falseLabel, context);
+		// Add complete branch (if necessary)
+		switch(condition.getOpcode()) {
+		case OPCODE_all:
+			if(trueLabel != exitLabel) {
+				context.add(new Bytecode.Goto(trueLabel));
+			}
+			break;
+		case OPCODE_some:
+		default:
+			if(falseLabel != exitLabel) {
+				context.add(new Bytecode.Goto(falseLabel));
+			}
+			break;
+		}
+		context.add(new Bytecode.Label(exitLabel));
+	}
+
+	/**
+	 * Helper function for translating quantifiers. The range index indicates
+	 * which range we are currently translating. We essentially recursve for
+	 * each range translating them one at a time into an enclosing loop. When
+	 * the innermost loop body is reached, we can then evaluate the condition
+	 * for the given range positions.
+	 * 
+	 * @param index
+	 *            Index into quantifier ranges. If matches number of ranges,
+	 *            then innermost position is reached.
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateQuantifierCondition(int index, Location<?> condition, String trueLabel,
+			String falseLabel, Context context) {
+		if (index == condition.numberOfOperandGroups()) {
+			// This is the innermost case. At this point, we are in the body of
+			// the innermost loop.  First, determine what is true and false :) 
+			String myTrueLabel = null;
+			String myFalseLabel = null;
+			switch(condition.getOpcode()) {
+			case OPCODE_all:
+				// if condition false, terminate early and return false.
+				myFalseLabel = falseLabel;
+				break;
+			case OPCODE_some:
+			default:
+				// if condition true, terminate early and return true.
+				myTrueLabel = trueLabel;
+				break;
+			}
+			// Translate the quantifier condition and, depending on the kind of
+			// quantifier, branch to either the true or false label.
+			translateCondition(condition.getOperand(0),myTrueLabel,myFalseLabel,context);
+		} else {
+			// This is the recursive case. Here, we need to construct an
+			// appropriate loop to iterate through the range.
+			Location<?>[] range = condition.getOperandGroup(index);
+			Location<?> var = range[SyntaxTree.VARIABLE];
+			Location<?> start = range[SyntaxTree.START];
+			Location<?> end = range[SyntaxTree.END];
+			translateExpression(start,context);
+			translateExpression(end,context);
+			context.add(new Bytecode.Store(end.getIndex(),WHILEYINT));
+			context.add(new Bytecode.Store(var.getIndex(),WHILEYINT));
+			// Create loop
+			String headerLabel = freshLabel();
+			String exitLabel = freshLabel();
+			// Generate loop condition
+			context.add(new Bytecode.Label(headerLabel));
+			context.add(new Bytecode.Load(var.getIndex(),WHILEYINT));
+			context.add(new Bytecode.Load(end.getIndex(),WHILEYINT));
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "equal", ftype, Bytecode.InvokeMode.STATIC));
+			ftype = new JvmType.Function(JvmTypes.T_BOOL);
+			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ftype, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.If(Bytecode.IfMode.NE, exitLabel));
+			// Recursively translate remainder of quantifier
+			translateQuantifierCondition(index+1,condition,trueLabel,falseLabel,context);
+			// Increment index variable
+			context.add(new Bytecode.Load(var.getIndex(), WHILEYINT));
+			context.add(new Bytecode.GetField(WHILEYINT, "ONE", WHILEYINT, Bytecode.FieldMode.STATIC));
+			ftype = new JvmType.Function(WHILEYINT, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYINT, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.Store(var.getIndex(), WHILEYINT));
+			// Branch back to top of loop
+			context.add(new Bytecode.Goto(headerLabel));
+			context.add(new Bytecode.Label(exitLabel));
+		}
+	}
+	
+	/**
+	 * Translate a type test condition. This is done here to ensure that we cast
+	 * the type appropriately before moving on to the true/false branches. For
+	 * example:
+	 * 
+	 * <pre>
+	 * function f(int|null x) -> (int r):
+	 *     if x is int:
+	 *         return x
+	 *     else:
+	 *         return 0
+	 * </pre>
+	 * 
+	 * In this case, the type of <code>x</code> will be <code>Object</code>, and
+	 * it must be cast to <code>int</code> on the true branch of the type test.
+	 * 
+	 * @param condition
+	 *            Type test to evaluate to see whether it is true or false
+	 * @param trueLabel
+	 *            Destination for when the condition is true. If null, execution
+	 *            continues to next logical instruction when condition holds.
+	 * @param falseLabel
+	 *            Destination for when the condition is false. If null,
+	 *            execution continues to next logical instruction when condition
+	 *            doesn't hold.
+	 * @param context
+	 *            Enclosing context
+	 */
+	private void translateIsCondition(Location<Operator> test, String trueLabel, String falseLabel,
+			Context context) {
+		Location<Const> rhs = (Location<Const>) test.getOperand(1);
+		Type rhsType = ((Constant.Type) rhs.getBytecode().constant()).value();
+		//
+		// Translate the type test itself
+		translateExpressions(test.getOperands(), context);
+		JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT);
+		context.add(new Bytecode.Swap());
+		context.add(new Bytecode.Invoke(WHILEYTYPE, "is", ftype, Bytecode.InvokeMode.VIRTUAL));
+		// Add the necessary branching instruction
+		JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
+		context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
+		// Determine the appropriate types for the true and false branches
+		Pair<Type,Type> flowTypes = determineFlowTypes(test,context);
+		// Add the necessary branch
+		if(flowTypes == null) {
+			// FIXME: bug here in case where constrained type is being tested
+			
+			// In this case, no retyping is possible. Therefore, we branch
+			// directly to the relevant destination.
+			if(trueLabel == null) {
+				context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+			} else {		
+				context.add(new Bytecode.If(Bytecode.IfMode.NE, trueLabel));
+			}
+		} else {
+			// In this case, a variable is being tested directly and, hence,
+			// needs to be retyped on both branches.
+			Location<VariableAccess> lhs = (Location<VariableAccess>) test.getOperand(0);
+			Location<VariableDeclaration> decl = getVariableDeclaration(lhs);
+			String tmpFalseLabel = freshLabel();
+			String tmpTrueLabel = freshLabel();
+			if(trueLabel == null) {		
+				context.add(new Bytecode.If(Bytecode.IfMode.NE, tmpTrueLabel));
+				context.add(new Bytecode.Label(tmpFalseLabel));
+				// This is the false branch. Apply the necessary cast.
+				retypeLocation(lhs,flowTypes.second(),context);
+				context.add(new Bytecode.Goto(falseLabel));
+				context.add(new Bytecode.Label(tmpTrueLabel));
+				// This is the true branch. Apply the necessary cast.
+				retypeLocation(lhs,flowTypes.first(),context);
+				// Now, check any invariants hold (or not)
+				int freeRegister = getFirstFreeRegister(test.getEnclosingTree());
+				translateInvariantTest(tmpFalseLabel, rhsType, decl.getIndex(), freeRegister, context);
+			} else {
+				context.add(new Bytecode.If(Bytecode.IfMode.EQ, tmpFalseLabel));
+				// This is the true branch. Apply the necessary cast.
+				retypeLocation(lhs,flowTypes.first(),context);
+				// Now, check any invariants hold (or not)
+				int freeRegister = getFirstFreeRegister(test.getEnclosingTree());
+				translateInvariantTest(tmpFalseLabel, rhsType, decl.getIndex(), freeRegister, context);
+				context.add(new Bytecode.Goto(trueLabel));
+				// This is the false branch. Apply the necessary cast.
+				context.add(new Bytecode.Label(tmpFalseLabel));
+				retypeLocation(lhs,flowTypes.second(),context);
+			}
+		}
+	}
+
+	/**
+	 * Determine the appropriate types for the true and false branches of a type
+	 * test.These are critical to determining the correct type to cast the
+	 * variable's contents to. The presence of constrained types complicates
+	 * this. For example, consider:
+	 *
+	 * <pre>
+	 *	 type nat is (int n) where n >= 0
+	 *	
+	 *	 function f(int|bool|null x) -> bool:
+	 *	 if x is nat|bool:
+	 *	 ...
+	 *	 else:
+	 *	 ...
+	 * </pre>
+	 * 
+	 * 
+	 * Here, the type of x on the true branch is int|bool, whilst on the false
+	 * branch it is int|null. To correctly handle this, we need to determine
+	 * maximal type which is fully consumed by another. In this case, the
+	 * maximal type fully consumed by nat|bool is bool and, hence, the type on
+	 * the false branch is int|bool|null - bool == int|null.
+	 * 
+	 * @param test
+	 * @param enclosing
+	 * @return
+	 */
+	private Pair<Type, Type> determineFlowTypes(Location<Operator> test, Context enclosing) {
+		Location<?> lhs = test.getOperand(0);
+		Location<Const> rhs = (Location<Const>) test.getOperand(1);		
+		
+		if(lhs.getBytecode() instanceof VariableAccess) {					
+			Type maximalConsumedType;
+			Type expandedLhsType;
+			Type expandedRhsType;
+			Type lhsType = lhs.getType();
+			Type rhsType = ((Constant.Type) rhs.getBytecode().constant()).value();
+			// Determine the maximally consumed type, and the underlying type.
+			try {
+				maximalConsumedType = typeSystem.getMaximallyConsumedType(rhsType);
+				expandedLhsType = typeSystem.getUnderlyingType(lhsType);
+				expandedRhsType = typeSystem.getUnderlyingType(rhsType);
+			} catch (Exception e) {
+				throw new InternalFailure("error computing maximally consumed type: " + rhsType, file.getEntry(), test,  e);
+			}
+			// Create the relevant types
+			Type typeOnTrueBranch = Type.intersect(expandedLhsType, expandedRhsType);
+			Type typeOnFalseBranch = Type.intersect(expandedLhsType, Type.Negation(maximalConsumedType));
+
+			return new Pair<Type,Type>(typeOnTrueBranch,typeOnFalseBranch);
+		} else {
+			return null;
+		}
+	}
+	
+	/**
+	 * Retype a given variable. This is done by casting the variable into the
+	 * appropriate type and assigning this over the original value.
+	 * 
+	 * @param location
+	 *            Variable to be retyped.
+	 * @param type
+	 *            Type variable should become
+	 * @param enclosing
+	 *            Enclosing context.
+	 */
+	private void retypeLocation(Location<VariableAccess> location, Type type, Context enclosing) {
+		Location<VariableDeclaration> decl = getVariableDeclaration(location);
+		enclosing.add(new Bytecode.Load(decl.getIndex(), toJvmType(type)));
+		enclosing.addReadConversion(type);
+		enclosing.add(new Bytecode.Store(decl.getIndex(), toJvmType(type)));
+	}
+	
+	/**
+	 * Translate any invariants contained in a given type. In the case the
+	 * invariant doesn't hold, we dispatch to a given false destination.
+	 * Otherwise, we fall through to the following instruction.
+	 * 
+	 * @param falseTarget
+	 *            Destination to branch if invariant is false
+	 * @param type
+	 *            Type whose invariants are being tested
+	 * @param variableRegister
+	 *            JVM register slot of variable which is being tested
+	 * @param freeRegister
+	 *            First free JVM register slot which can be used by this method
+	 * @param context
+	 */
+	private void translateInvariantTest(String falseTarget, Type type, int variableRegister, int freeRegister,
+			Context context) {
+		//
+		JvmType underlyingType = toJvmType(type);
+		//
+		if (type instanceof Type.Nominal) {
+			Type.Nominal c = (Type.Nominal) type;
+			Path.ID mid = c.name().module();
+			JvmType.Clazz owner = new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
+			JvmType.Function fnType = new JvmType.Function(new JvmType.Bool(), toJvmType(c));
+			context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
+			context.add(new Bytecode.Invoke(owner, c.name().name() + "$typeof", fnType, Bytecode.InvokeMode.STATIC));
+			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseTarget));
+		} else if (type instanceof Type.Leaf) {
+			// Do nout
+		} else if (type instanceof Type.Reference) {
+			Type.Reference rt = (Type.Reference) type;
+			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Load(variableRegister, underlyingType));
+			context.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype, Bytecode.InvokeMode.VIRTUAL));
+			context.addReadConversion(rt.element());
+			context.add(new Bytecode.Store(freeRegister, toJvmType(rt.element())));
+			translateInvariantTest(falseTarget, rt.element(), freeRegister, freeRegister + 1, context);
+		} else if (type instanceof Type.EffectiveArray) {
+			Type.EffectiveArray ts = (Type.EffectiveArray) type;
+			Triple<String, String, String> loopLabels = translateLoopBegin(variableRegister, freeRegister, context);
+			context.addReadConversion(ts.element());
+			context.add(new Bytecode.Store(freeRegister + 1, toJvmType(ts.element())));
+			translateInvariantTest(falseTarget, ts.element(), freeRegister + 1, freeRegister + 2, context);
+			translateLoopEnd(loopLabels, context);
+		} else if (type instanceof Type.Record) {
+			Type.Record tt = (Type.Record) type;
+			HashMap<String, Type> fields = tt.fields();
+			ArrayList<String> fieldNames = new ArrayList<String>(fields.keySet());
+			Collections.sort(fieldNames);
+			for (int i = 0; i != fieldNames.size(); ++i) {
+				String field = fieldNames.get(i);
+				Type fieldType = fields.get(field);
+				JvmType underlyingFieldType = toJvmType(fieldType);
+				context.add(new Bytecode.Load(variableRegister, underlyingType));
+				context.add(new Bytecode.LoadConst(field));
+				JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_STRING);
+				context.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.VIRTUAL));
+				context.addReadConversion(fieldType);
+				context.add(new Bytecode.Store(freeRegister, underlyingFieldType));
+				translateInvariantTest(falseTarget, fieldType, freeRegister, freeRegister + 1, context);
+			}
+		} else if (type instanceof Type.FunctionOrMethod) {
+			// FIXME: this is clearly a bug. However, it's not completely
+			// straightforward to fix, since there is currently no way to get
+			// runtime type information about a function or method reference. In
+			// principle, this could be encoded in the WyLambda in some way.
+		} else if (type instanceof Type.Negation) {
+			Type.Reference rt = (Type.Reference) type;
+			String trueTarget = freshLabel();
+			translateInvariantTest(trueTarget, rt.element(), variableRegister, freeRegister, context);
+			context.add(new Bytecode.Goto(falseTarget));
+			context.add(new Bytecode.Label(trueTarget));
+		} else if (type instanceof Type.Union) {
+			Type.Union ut = (Type.Union) type;
+			String trueLabel = freshLabel();
+			for (Type bound : ut.bounds()) {
+				try {
+					Type underlyingBound = typeSystem.getUnderlyingType(bound);
+					String nextLabel = freshLabel();
+					context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
+					translateTypeTest(nextLabel, underlyingBound, context);
+					context.add(new Bytecode.Load(variableRegister, toJvmType(type)));
+					context.addReadConversion(bound);
+					context.add(new Bytecode.Store(freeRegister, toJvmType(bound)));
+					translateInvariantTest(nextLabel, bound, freeRegister, freeRegister + 1, context);
+					context.add(new Bytecode.Goto(trueLabel));
+					context.add(new Bytecode.Label(nextLabel));
+				} catch (ResolveError e) {
+					throw new InternalFailure(e.getMessage(), file.getEntry(), null, e);
+				}
+			}
+			context.add(new Bytecode.Goto(falseTarget));
+			context.add(new Bytecode.Label(trueLabel));
+		} else {
+			throw new InternalFailure("unknown type encountered: " + type, file.getEntry(), null);
+		}
+	}
+
+	/**
+	 * Construct generic code for iterating over a collection (e.g. a Whiley
+	 * List or Set). This code will not leave anything on the stack and will
+	 * store the iterator variable in a given slot. This means that things can
+	 * be passed on the stack from before the loop into the loop body.
+	 * 
+	 * @param freeSlot
+	 *            The variable slot into which the iterator variable should be
+	 *            stored.
+	 * @param exitLabel
+	 *            The label which will represents after the end of the loop.
+	 * @param context
+	 *            The enclosing context
+	 */
+	private Triple<String, String, String> translateLoopBegin(
+			int sourceSlot, int freeSlot, Context context) {
+		String loopHeader = freshLabel();
+		String loopFooter = freshLabel();
+		String loopExit = freshLabel();
+
+		// First, call Collection.iterator() on the source collection and write
+		// it into the free slot.
+		context.add(new Bytecode.Load(sourceSlot, JAVA_LANG_ITERABLE));
+		context.add(new Bytecode.Invoke(JAVA_LANG_ITERABLE, "iterator",
+				new JvmType.Function(JAVA_UTIL_ITERATOR),Bytecode.InvokeMode.INTERFACE));
+		context.add(new Bytecode.Store(freeSlot, JAVA_UTIL_ITERATOR));
+
+		// Second, construct the loop header, which consists of the test to
+		// check whether or not there are any elements left in the collection to
+		// visit.
+		context.add(new Bytecode.Label(loopHeader));
+		context.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
+		context.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "hasNext",
+				new JvmType.Function(T_BOOL), Bytecode.InvokeMode.INTERFACE));
+		context.add(new Bytecode.If(Bytecode.IfMode.EQ, loopExit));
+
+		// Finally, get the current element out of the iterator by invoking
+		// Iterator.next();
+		context.add(new Bytecode.Load(freeSlot, JAVA_UTIL_ITERATOR));
+		context.add(new Bytecode.Invoke(JAVA_UTIL_ITERATOR, "next",
+				new JvmType.Function(JAVA_LANG_OBJECT),
+				Bytecode.InvokeMode.INTERFACE));
+
+		// Done
+		return new Triple<String,String,String>(loopHeader, loopFooter, loopExit);
+	}
+
+	private void translateLoopEnd(Triple<String, String, String> labels, Context context) {
+		context.add(new Bytecode.Label(labels.second()));
+		context.add(new Bytecode.Goto(labels.first()));
+		context.add(new Bytecode.Label(labels.third()));
+	}
+	
+	/**
+	 * The purpose of this method is to translate a type test. We're testing to
+	 * see whether what's on the top of the stack (the value) is a subtype of
+	 * the type being tested. Note, constants must be provided as a parameter
+	 * 
+	 * @param falseLabel
+	 *            Destination to branch if not true
+	 * @param type
+	 *            Type being tested
+	 * @param context
+	 *            Enclosing context
+	 */
+	protected void translateTypeTest(String falseLabel, Type test, Context context) {
+		// First, try for the easy cases
+		if (test instanceof Type.Null) {
+			// Easy case
+			context.add(new Bytecode.If(Bytecode.IfMode.NONNULL, falseLabel));
+		} else if (test instanceof Type.Bool) {
+			context.add(new Bytecode.InstanceOf(WHILEYBOOL));
+			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+		} else if (test instanceof Type.Int) {
+			context.add(new Bytecode.InstanceOf(WHILEYINT));
+			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+		} else {
+			// Fall-back to an external (recursive) check
+			Constant constant = new Constant.Type(test);
+			int id = JvmValue.get(constant, constants);
+			String name = "constant$" + id;
+			context.add(new Bytecode.GetField(owner, name, WHILEYTYPE, Bytecode.FieldMode.STATIC));
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Swap());
+			context.add(new Bytecode.Invoke(WHILEYTYPE, "is", ftype, Bytecode.InvokeMode.VIRTUAL));
+			JvmType.Function ft = new JvmType.Function(JvmTypes.T_BOOL);
+			context.add(new Bytecode.Invoke(WHILEYBOOL, "value", ft, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.If(Bytecode.IfMode.EQ, falseLabel));
+		}
+	}
+	// ===============================================================================
+	// Expressions
+	// ===============================================================================
+
+	/**
+	 * Translate one or more operands into JVM Bytecodes. Execution follows the
+	 * order of operands given, with the first operand being evaluated before
+	 * the others. Likewise, the results are pushed on the stack in the order of
+	 * operands given. So, the result of the first operand is pushed onto the
+	 * stack first, etc.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return The set of JVM types representing the actual operands pushed on
+	 *         the stack. This maybe be larger than the number of operands
+	 *         provided in the case that one or more of those operands had
+	 *         multiple return values.
+	 */
+	public List<JvmType> translateExpressions(Location<?>[] operands, Context enclosing) {
+		ArrayList<JvmType> types = new ArrayList<JvmType>();
+		for (int i = 0; i != operands.length; ++i) {
+			Location<?> operand = operands[i];
+			// Translate operand
+			translateExpression(operand, enclosing);
+			// Determine type(s) for operand
+			for (int j = 0; j != operand.numberOfTypes(); ++j) {
+				types.add(toJvmType(operand.getType(j)));
+			}
+		}
+		return types;
+	}
+	
+	/**
+	 * Translate one or more operands into JVM Bytecodes and store them in an
+	 * object array. Execution follows the order of operands given, with the
+	 * first operand being evaluated before the others. Likewise, the results
+	 * are pushed on the stack in the order of operands given. So, the result of
+	 * the first operand is pushed onto the stack first, etc.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param freeRegister
+	 *            First free JVM register slot which can be used by this method
+	 * @param context
+	 *            The enclosing context for this operand.
+	 */
+	private void translateExpressionsToArray(Location<?>[] operands, int freeRegister, Context context) {
+		int size = countLocationTypes(operands);
+		ArrayList<Type> types = new ArrayList<Type>();
+		// Translate every operand giving size elements on stack
+		for (int i = 0; i < operands.length; i = i + 1) {
+			Location<?> operand = operands[i];
+			// Translate expression itself
+			translateExpression(operand, context);
+			// record the types now loaded on the stack
+			for (int j = 0; j != operand.numberOfTypes(); ++j) {
+				types.add(operand.getType(j));
+			}
+		}
+		// Construct the target array
+		context.add(new Bytecode.LoadConst(size));
+		context.add(new Bytecode.New(JAVA_LANG_OBJECT_ARRAY));
+		context.add(new Bytecode.Store(freeRegister, JAVA_LANG_OBJECT_ARRAY));
+		// Process each stack element in turn. This has to be done in reverse
+		// order since that's how they're laid out on the stack
+		for (int i = size - 1; i >= 0; i = i - 1) {
+			context.add(new Bytecode.Load(freeRegister, JAVA_LANG_OBJECT_ARRAY));
+			context.add(new Bytecode.Swap());
+			context.add(new Bytecode.LoadConst(i));
+			context.add(new Bytecode.Swap());
+			context.addWriteConversion(types.get(i));
+			context.add(new Bytecode.ArrayStore(JAVA_LANG_OBJECT_ARRAY));
+		}
+		// Done
+		context.add(new Bytecode.Load(freeRegister, JAVA_LANG_OBJECT_ARRAY));
+	}
+
+	private int countLocationTypes(Location<?>...locations) {
+		int count = 0 ;
+		for(int i=0;i!=locations.length;++i) {
+			count += locations[i].numberOfTypes();
+		}
+		return count;
+	}
+	
+	/**
+	 * Translate an operand into one or more JVM Bytecodes. The result of this
+	 * operand will be pushed onto the stack at the end.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateExpression(Location<?> expr, Context context) {
+		try {
+			switch (expr.getOpcode()) {
+			case OPCODE_convert:
+				translateConvert((Location<Convert>) expr, context);
+				break;
+			case OPCODE_const:
+				translateConst((Location<Const>) expr, context);
+				break;
+			case OPCODE_fieldload:
+				translateFieldLoad((Location<FieldLoad>) expr, context);
+				break;
+			case OPCODE_all:
+			case OPCODE_some:
+				translateQuantifier((Location<Quantifier>) expr, context);
+				break;
+			case OPCODE_indirectinvoke:
+				translateIndirectInvoke((Location<IndirectInvoke>) expr, context);
+				break;
+			case OPCODE_invoke:
+				translateInvoke((Location<Invoke>) expr, context);
+				break;
+			case OPCODE_lambda:
+				translateLambda((Location<Lambda>) expr, context);
+				break;
+			case OPCODE_varaccess:
+				translateVariableAccess((Location<VariableAccess>) expr, context);
+				break;
+			default:				
+				translateOperator((Location<Operator>) expr, context);				
+			}
+		} catch(InternalFailure ex) {
+			throw ex;
+		} catch (Exception ex) {
+			throw new InternalFailure(ex.getMessage(), file.getEntry(), expr, ex);
+		}
+	}
+
+	/**
+	 * Translate a constant into JVM bytecodes and load it onto the stack. In
+	 * some cases, this can be done directly. For example, <code>null</code> can
+	 * be loaded onto the stack using the <code>aconst_null</code> bytecode. In
+	 * other cases (e.g. for array constants), we have to construct one or more
+	 * objects to represent the constant. To avoid doing this everytime such a
+	 * constant is encountered, we create the constants in the static
+	 * initialiser of this class, and store them in static fields for later
+	 * recall.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateConst(Location<Const> c, Context context) throws ResolveError {
+		Constant constant = c.getBytecode().constant();
+		// At this point, we need to normalise the constant. This is because the
+		// constant may involve one or more nominal types. These types don't
+		// make sense at runtime, and we want to get rid of them where possible.
+		constant = normalise(constant);		
+		JvmType jt = toJvmType(constant.type());
+		// Check whether this constant can be translated as a primitive, and
+		// encoded directly within a bytecode.
+		if (constant instanceof Constant.Bool || constant instanceof Constant.Null
+				|| constant instanceof Constant.Byte) {
+			// Yes, it can.
+			translateConstant(constant, context);
+		} else {
+			// No, this needs to be constructed elsewhere as a static field.
+			// Then, we can load it onto the stack here.
+			int id = JvmValue.get(constant, constants);
+			String name = "constant$" + id;
+			context.add(new Bytecode.GetField(owner, name, jt, Bytecode.FieldMode.STATIC));
+		}
+	}
+
+	/**
+	 * Make sure any type constants are fully expanded. This is to ensure that
+	 * nominal types are not present at runtime (unless they are specifically
+	 * protected in some way).
+	 * 
+	 * @param constant
+	 * @return
+	 */
+	private Constant normalise(Constant constant) throws ResolveError {		
+		if(constant instanceof Constant.Type) {
+			Constant.Type ct = (Constant.Type) constant;
+			Type type = ct.value();
+			Type underlyingType;			
+			underlyingType = typeSystem.getUnderlyingType(type);			
+			return new Constant.Type(underlyingType);
+		} else {
+			return constant;
+		}		
+	}
+	
+	/**
+	 * Coerce one data value into another. In what situations do we actually
+	 * have to do work?
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateConvert(Location<Convert> c, Context context) {
+		// Translate the operand
+		translateExpression(c.getOperand(0), context);
+		// Do nothing :)
+	}
+
+	/**
+	 * Load the value of a given field from a record.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateFieldLoad(Location<FieldLoad> c, Context context) throws ResolveError {
+		Location<?> srcOperand = c.getOperand(0);
+		Type.EffectiveRecord type = typeSystem.expandAsEffectiveRecord(srcOperand.getType());
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYRECORD, JAVA_LANG_STRING);
+		// Translate the source operand
+		translateExpression(srcOperand, context);
+		context.add(new Bytecode.LoadConst(c.getBytecode().fieldName()));
+		// Load the field out of the resulting record
+		context.add(new Bytecode.Invoke(WHILEYRECORD, "get", ftype, Bytecode.InvokeMode.STATIC));
+		// Add a read conversion (if necessary) to unbox the value
+		context.addReadConversion(type.field(c.getBytecode().fieldName()));
+	}
+
+	/**
+	 * Apply a unary, binary or ternary operator to a given set of operands.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateOperator(Location<Operator> c, Context context) throws ResolveError {
+		// First, translate each operand and load its value onto the stack
+		switch (c.getOpcode()) {
+		case OPCODE_logicaland:
+		case OPCODE_logicalor:
+			// These two operators need to be handled specially because they
+			// require short-circuiting semantics.
+			translateExpressionAsCondition(c,context);
+			break;
+		case OPCODE_record:
+			translateRecordConstructor(c, context);
+			break;
+		case OPCODE_array:
+			translateArrayConstructor(c, context);
+			break;
+		default:			
+			translateExpressions(c.getOperands(), context);
+			// Second, dispatch to a specific translator for this opcode kind.
+			generators[c.getOpcode()].translate(c, context);
+		}
+	}
+
+	public void translateExpressionAsCondition(Location<Operator> bytecode, Context context) throws ResolveError {
+		String trueLabel = freshLabel();
+		String exitLabel = freshLabel();
+		translateCondition(bytecode,trueLabel,null,context);
+		context.add(new Bytecode.GetField(WHILEYBOOL, "FALSE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
+		context.add(new Bytecode.Goto(exitLabel));
+		context.add(new Bytecode.Label(trueLabel));
+		context.add(new Bytecode.GetField(WHILEYBOOL, "TRUE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
+		context.add(new Bytecode.Label(exitLabel));
+	}
+	
+	/**
+	 * Translate a RecordConstructor operand.
+	 * 
+	 * @param bytecode
+	 * @param context
+	 */
+	public void translateRecordConstructor(Location<Operator> bytecode, Context context) throws ResolveError {
+		Type.EffectiveRecord recType = typeSystem.expandAsEffectiveRecord(bytecode.getType());
+		JvmType.Function ftype = new JvmType.Function(WHILEYRECORD, WHILEYRECORD, JAVA_LANG_STRING, JAVA_LANG_OBJECT);
+
+		context.construct(WHILEYRECORD);
+
+		ArrayList<String> keys = new ArrayList<String>(recType.fields().keySet());
+		Collections.sort(keys);
+		for (int i = 0; i != bytecode.getOperands().length; i++) {
+			String key = keys.get(i);
+			Type fieldType = recType.field(key);
+			context.add(new Bytecode.LoadConst(key));
+			translateExpression(bytecode.getOperand(i), context);
+			context.addWriteConversion(fieldType);
+			context.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.STATIC));
+		}
+	}
+
+	/**
+	 * Translate an ArrayConstructor operand
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateArrayConstructor(Location<Operator> code, Context context) throws ResolveError {
+		Type.EffectiveArray arrType = typeSystem.expandAsEffectiveArray(code.getType());
+		JvmType.Function initJvmType = new JvmType.Function(T_VOID, T_INT);
+		JvmType.Function ftype = new JvmType.Function(WHILEYARRAY, WHILEYARRAY, JAVA_LANG_OBJECT);
+
+		context.add(new Bytecode.New(WHILEYARRAY));
+		context.add(new Bytecode.Dup(WHILEYARRAY));
+		context.add(new Bytecode.LoadConst(code.getOperands().length));
+		context.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", initJvmType, Bytecode.InvokeMode.SPECIAL));
+
+		for (int i = 0; i != code.getOperands().length; ++i) {
+			translateExpression(code.getOperand(i), context);
+			context.addWriteConversion(arrType.element());
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "internal_add", ftype, Bytecode.InvokeMode.STATIC));
+		}
+	}
+
+	/**
+	 * Translate a lambda expression into a sequence of JVM bytecodes. This is
+	 * done by constructing a separate class extending WyLambda. This class
+	 * contains as fields any local variables from the current method/function
+	 * which are accessed within the body of the lambda (the so-called
+	 * "binding").
+	 * 
+	 * @param c
+	 * @param context
+	 */
+	private void translateLambda(Location<Lambda> c, Context context) {
+		Lambda bytecode = c.getBytecode();
+		Location<?>[] environment = c.getOperandGroup(1);
+		int lambda_id = lambdaClasses.size();
+		String lambdaMethod = "$lambda" + lambda_id;
+		JvmType[] jvmEnvironment = buildLambdaEnvironment(environment);
+		// First, we construct and instantiate the lambda
+		ClassFile lambda = buildLambda(owner, lambdaMethod, bytecode.type(), jvmEnvironment);
+		lambdaClasses.add(lambda);
+		//
+		context.add(new Bytecode.New(lambda.type()));
+		context.add(new Bytecode.Dup(lambda.type()));
+		for (int i = 0; i != environment.length; ++i) {
+			Location<?> e = environment[i];
+			context.add(new Bytecode.Load(e.getIndex(), jvmEnvironment[i]));
+		}
+		JvmType.Function ftype = new JvmType.Function(T_VOID, jvmEnvironment);
+		context.add(new Bytecode.Invoke(lambda.type(), "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+
+		// Second, we translate the body of the lambda and construct a new
+		// method to represent it. This method will then be called from the
+		// lambda class created above.
+		ClassFile.Method method = buildLambdaMethod(c, lambdaMethod, context);
+		//
+		lambdaMethods.add(method);
+	}
+
+	/**
+	 * Perform a direct method or function invocation.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateInvoke(Location<Invoke> c, Context context) {
+		Invoke bytecode = c.getBytecode();
+		// Translate each operand and load its value onto the stack
+		translateExpressions(c.getOperands(), context);
+		// Construct the invocation bytecode
+		context.add(createMethodInvocation(bytecode.name(), bytecode.type()));
+		// 
+		List<Type> returnTypes = bytecode.type().returns();
+		if(returnTypes.size() > 1) {
+			decodeOperandArray(returnTypes,context);
+		}
+	}
+
+	/**
+	 * Perform an indirect method or function invocation.
+	 * 
+	 * @param code
+	 *            The WyIL operand being translated.
+	 * @param enclosing
+	 *            The enclosing context for this operand.
+	 * @return
+	 */
+	private void translateIndirectInvoke(Location<IndirectInvoke> c, Context context) {
+		IndirectInvoke bytecode = c.getBytecode();
+		Type.FunctionOrMethod ft = bytecode.type();
+		JvmType.Clazz owner = (JvmType.Clazz) toJvmType(ft);
+		// First, translate reference operand which returns the function/method
+		// object we will dispatch upon. This extends the WyLambda class.
+		translateExpression(c.getOperand(0), context);
+		// Second, translate each argument and store it into an object array
+		int freeRegister = getFirstFreeRegister(c.getEnclosingTree());
+		translateExpressionsToArray(c.getOperandGroup(0), freeRegister, context);
+		// Third, make the indirect method or function call. This is done by
+		// invoking the "call" method on the function / method object returned
+		// from the reference operand.
+		JvmType.Function type = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
+		context.add(new Bytecode.Invoke(owner, "call", type, Bytecode.InvokeMode.VIRTUAL));
+		// Cast return value to expected type
+		List<Type> returnTypes = bytecode.type().returns();
+		if (returnTypes.size() == 1) {
+			JvmType returnType = toJvmType(ft.returns().get(0));
+			context.addCheckCast(returnType);
+		} else if (returnTypes.size() > 1) {
+			decodeOperandArray(returnTypes, context);
+		}
+	}
+
+	/**
+	 * Translate a quantifier into a set of nested loops with the condition
+	 * itself located in the innermost position.
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false 
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateQuantifier(Location<Quantifier> condition, Context context) {
+		String trueLabel = freshLabel();
+		String exitLabel = freshLabel();
+		translateQuantifierCondition(condition, trueLabel, null, context);
+		context.add(new Bytecode.GetField(WHILEYBOOL, "FALSE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
+		context.add(new Bytecode.Goto(exitLabel));
+		context.add(new Bytecode.Label(trueLabel));
+		context.add(new Bytecode.GetField(WHILEYBOOL, "TRUE", WHILEYBOOL, Bytecode.FieldMode.STATIC));
+		context.add(new Bytecode.Label(exitLabel));
+	}
+	
+	/**
+	 * Translate a variable access into a simple variable load instruction
+	 * 
+	 * @param condition
+	 *            Operand to evaluate to see whether it is true or false
+	 * @param enclosing
+	 *            Enclosing context
+	 */
+	private void translateVariableAccess(Location<VariableAccess> expr, Context context) {		
+		JvmType type = context.toJvmType(expr.getType());
+		Location<VariableDeclaration> decl = getVariableDeclaration(expr);
+		context.add(new Bytecode.Load(decl.getIndex(), type));
+	}
+		
+	// ===============================================================================
+	// Constants
+	// ===============================================================================
+
+	/**
+	 * Translate a give constant value and load it onto the stack. Some of the
+	 * translations are more expensive that others. Primitive types (e.g. null,
+	 * bool, integer) can be loaded directly. Others require constructing
+	 * objects and should, ideally, be done only once.
+	 * 
+	 * @param v
+	 * @param context
+	 */
+	private void translateConstant(Constant v, Context context) {
+		if (v instanceof Constant.Null) {
+			translateConstant((Constant.Null) v, context);
+		} else if (v instanceof Constant.Bool) {
+			translateConstant((Constant.Bool) v, context);
+		} else if (v instanceof Constant.Byte) {
+			translateConstant((Constant.Byte) v, context);
+		} else if (v instanceof Constant.Integer) {
+			translateConstant((Constant.Integer) v, context);
+		} else if (v instanceof Constant.Type) {
+			translateConstant((Constant.Type) v, context);
+		} else if (v instanceof Constant.Array) {
+			translateConstant((Constant.Array) v, context);
+		} else if (v instanceof Constant.Record) {
+			translateConstant((Constant.Record) v, context);
+		} else if (v instanceof Constant.FunctionOrMethod) {
+			translateConstant((Constant.FunctionOrMethod) v, context);
+		} else if (v instanceof Constant.Type) {
+			translateConstant((Constant.Type) v, context);
+		} else {
+			throw new IllegalArgumentException("unknown value encountered:" + v);
+		}
+	}
+
+	protected void translateConstant(Constant.Null e, Context context) {
+		context.add(new Bytecode.LoadConst(null));
+	}
+
+	protected void translateConstant(Constant.Bool e, Context context) {
+		context.add(new Bytecode.LoadConst(e.value()));
+		JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, T_BOOL);
+		context.add(new Bytecode.Invoke(WHILEYBOOL, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
+	}
+
+	protected void translateConstant(Constant.Type e, Context context) {
+		JavaIdentifierOutputStream jout = new JavaIdentifierOutputStream();
+		BinaryOutputStream bout = new BinaryOutputStream(jout);
+		Type.BinaryWriter writer = new Type.BinaryWriter(bout);
+		try {
+			writer.write(e.value());
+			writer.close();
+		} catch (IOException ex) {
+			throw new RuntimeException(ex.getMessage(), ex);
+		}
+
+		context.add(new Bytecode.LoadConst(jout.toString()));
+		JvmType.Function ftype = new JvmType.Function(WHILEYTYPE, JAVA_LANG_STRING);
+		context.add(new Bytecode.Invoke(WHILEYTYPE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
+	}
+
+	protected void translateConstant(Constant.Byte e, Context context) {
+		context.add(new Bytecode.LoadConst(e.value()));
+		JvmType.Function ftype = new JvmType.Function(WHILEYBYTE, T_BYTE);
+		context.add(new Bytecode.Invoke(WHILEYBYTE, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
+	}
+
+	protected void translateConstant(Constant.Integer e, Context context) {
+		BigInteger num = e.value();
+
+		if (num.bitLength() < 32) {
+			context.add(new Bytecode.LoadConst(num.intValue()));
+			context.add(new Bytecode.Conversion(T_INT, T_LONG));
+			JvmType.Function ftype = new JvmType.Function(WHILEYINT, T_LONG);
+			context.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
+		} else if (num.bitLength() < 64) {
+			context.add(new Bytecode.LoadConst(num.longValue()));
+			JvmType.Function ftype = new JvmType.Function(WHILEYINT, T_LONG);
+			context.add(new Bytecode.Invoke(WHILEYINT, "valueOf", ftype, Bytecode.InvokeMode.STATIC));
+		} else {
+			// in this context, we need to use a byte array to construct the
+			// integer object.
+			byte[] bytes = num.toByteArray();
+			JvmType.Array bat = new JvmType.Array(JvmTypes.T_BYTE);
+
+			context.add(new Bytecode.New(WHILEYINT));
+			context.add(new Bytecode.Dup(WHILEYINT));
+			context.add(new Bytecode.LoadConst(bytes.length));
+			context.add(new Bytecode.New(bat));
+			for (int i = 0; i != bytes.length; ++i) {
+				context.add(new Bytecode.Dup(bat));
+				context.add(new Bytecode.LoadConst(i));
+				context.add(new Bytecode.LoadConst(bytes[i]));
+				context.add(new Bytecode.ArrayStore(bat));
+			}
+
+			JvmType.Function ftype = new JvmType.Function(T_VOID, bat);
+			context.add(new Bytecode.Invoke(WHILEYINT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+		}
+
+	}
+
+	protected void translateConstant(Constant.Array lv, Context context) {
+		context.add(new Bytecode.New(WHILEYARRAY));
+		context.add(new Bytecode.Dup(WHILEYARRAY));
+		context.add(new Bytecode.LoadConst(lv.values().size()));
+		JvmType.Function ftype = new JvmType.Function(T_VOID, T_INT);
+		context.add(new Bytecode.Invoke(WHILEYARRAY, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+
+		ftype = new JvmType.Function(T_BOOL, JAVA_LANG_OBJECT);
+		for (Constant e : lv.values()) {
+			context.add(new Bytecode.Dup(WHILEYARRAY));
+			translateConstant(e, context);
+			context.addWriteConversion(e.type());
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.Pop(T_BOOL));
+		}
+	}
+
+	protected void translateConstant(Constant.Record expr, Context context) {
+		JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+		context.construct(WHILEYRECORD);
+		for (Map.Entry<String, Constant> e : expr.values().entrySet()) {
+			Type et = e.getValue().type();
+			context.add(new Bytecode.Dup(WHILEYRECORD));
+			context.add(new Bytecode.LoadConst(e.getKey()));
+			translateConstant(e.getValue(), context);
+			context.addWriteConversion(et);
+			context.add(new Bytecode.Invoke(WHILEYRECORD, "put", ftype, Bytecode.InvokeMode.VIRTUAL));
+			context.add(new Bytecode.Pop(JAVA_LANG_OBJECT));
+		}
+	}
+
+	/**
+	 * Translate a constant representing a given function or method into an
+	 * instance of a special lambda class. The lambda class extends WyLambda and
+	 * looks just like any other lambda function. However, when invoked, it will
+	 * call the function or method determined by the class directly.
+	 */
+	protected void translateConstant(Constant.FunctionOrMethod c, Context context) {
+		// First, build the lambda
+		NameID target = c.name();
+		ClassFile lambda = buildLambda(getModuleClass(target.module()), target.name(), c.type());
+		lambdaClasses.add(lambda);
+		// Finally, construct an instance of the class itself
+		context.construct(lambda.type());
+	}
+
+	// ===============================================================================
+	// Lambdas
+	// ===============================================================================
+
+
+	/**
+	 * Create a method representing the body of a lambda. This will then be
+	 * called by the lambda class created from the LambdaTemplate. Creating a
+	 * method like this is not necessarily optimal, but it allows me to simplify
+	 * the translation process (e.g. as locations still correspond to register
+	 * numbers, etc).
+	 * 
+	 * @param type
+	 * @param lambdaMethod
+	 * @param context
+	 * @return
+	 */
+	public ClassFile.Method buildLambdaMethod(Location<Lambda> e, String lambdaMethod, Context context) {
+		Lambda l = e.getBytecode();
+		JvmType.Function type = buildLambdaMethodType(l.type(), e.getOperandGroup(1));
+		Context bodyContext = new Context();
+		// Move environment into correct register slots. First, push them all
+		// onto the stack
+		shiftLambdaMethodParameters(e.getOperandGroup(0), e.getOperandGroup(1), bodyContext);
+		// Translate the body of the lambda expression
+		translateExpression(e.getOperand(0), bodyContext);
+		// Add the return value (if applicable)
+		if (type.returnType() instanceof JvmType.Void) {
+			bodyContext.add(new Bytecode.Return(null));
+		} else {
+			bodyContext.add(new Bytecode.Return(type.returnType()));
+		}
+		// Create the method itself
+		String lambdaMethodMangled = nameMangle(lambdaMethod, l.type());
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_STATIC, ACC_FINAL);
+		ClassFile.Method method = new ClassFile.Method(lambdaMethodMangled, type, modifiers);
+		// Add the code attribute
+		jasm.attributes.Code code = new jasm.attributes.Code(bodyContext.getBytecodes(), Collections.EMPTY_LIST,
+				method);
+		method.attributes().add(code);
+		//
+		return method;
+	}
+
+	/**
+	 * Shift the parameters passed into this lambda method into the desired
+	 * target registers.
+	 * 
+	 * @param parameters
+	 *            Actual parameter of the lambda itself
+	 * @param environment
+	 *            Environment variables used from the enclosing scope within the
+	 *            lambda body
+	 * @param bodyContext
+	 */
+	private void shiftLambdaMethodParameters(Location<?>[] parameters, Location<?>[] environment, Context bodyContext) {
+		parameters = append(parameters,environment);
+		for(int i=0;i!=parameters.length;++i) {
+			Location<?> p = parameters[i];
+			int slot = p.getIndex();
+			if(slot != i) {
+				bodyContext.add(new Bytecode.Load(i, toJvmType(p.getType())));
+			}
+		}
+		// Second, pop them all into the right register
+		for(int i=parameters.length-1;i>=0;--i) {
+			Location<?> p = parameters[i];
+			int slot = p.getIndex();
+			if(slot != i) {
+				bodyContext.add(new Bytecode.Store(slot, toJvmType(p.getType())));
+			}
+		}
+	}
+	
+	/**
+	 * Construct the true method type for a lambda body. This is the type of the
+	 * lambda itself, along with the types for any environment variables which
+	 * are required.
+	 * 
+	 * @param type
+	 * @param environment
+	 * @param context
+	 * @return
+	 */
+	public JvmType.Function buildLambdaMethodType(Type.FunctionOrMethod type, Location<?>[] environment) {
+		JvmType.Function jvmType = convertFunType(type);
+		ArrayList<JvmType> actualParameterTypes = new ArrayList<JvmType>(jvmType.parameterTypes());
+		for (int i = 0; i != environment.length; ++i) {
+			Location<?> loc = environment[i];
+			actualParameterTypes.add(toJvmType(loc.getType()));
+		}
+		//
+		return new JvmType.Function(jvmType.returnType(), actualParameterTypes);
+	}
+	
+	/**
+	 * Determine the types for the environment variables of a lambda expression.
+	 * 
+	 * @param environment
+	 * @param context
+	 * @return
+	 */
+	public JvmType[] buildLambdaEnvironment(Location<?>[] environment) {
+		JvmType[] envTypes = new JvmType[environment.length];
+		for (int i = 0; i != environment.length; ++i) {
+			Location<?> loc = environment[i];
+			envTypes[i] = toJvmType(loc.getType());
+		}
+		return envTypes;
+	}
+	
+	public ClassFile buildLambda(JvmType.Clazz targetClass, String targetMethod, Type.FunctionOrMethod type,
+			JvmType... environment) {
+		int lambda_id = lambdaClasses.size();
+		// Determine name of the lambda class. This class will extend class
+		// wyjc.runtime.WyLambda.
+		JvmType.Clazz lambdaClass = new JvmType.Clazz(owner.pkg(), owner.lastComponent().first(),
+				Integer.toString(lambda_id));
+		// Determine mangled name of function or method
+		String targetMethodMangled = nameMangle(targetMethod, type);
+		// Determine JvmType of function or method
+		JvmType.Function jvmType = convertFunType(type);
+		// Determine the Jvm types for the environment		
+		// Create the lambda template
+		LambdaTemplate template = new LambdaTemplate(CLASS_VERSION, lambdaClass, targetClass, targetMethodMangled,
+				jvmType, environment);
+		// Instantiate the template to generate the lambda class
+		return template.generateClass();
+	}
+
+	// ===============================================================================
+	// Helpers
+	// ===============================================================================
+
+
+	public Location<VariableDeclaration> getVariableDeclaration(Location<?> decl) {
+		switch (decl.getOpcode()) {
+		case OPCODE_aliasdecl:
+		case OPCODE_varaccess:
+			return getVariableDeclaration(decl.getOperand(0));
+		case OPCODE_vardecl:
+		case OPCODE_vardeclinit:
+			return (Location<VariableDeclaration>) decl;
+		default:
+			throw new RuntimeException("internal failure --- dead code reached");
+		}
+	}
+	
+	/**
+	 * Create an invocation bytecode for a given WyIL function or method. This
+	 * is just a convenience method which takes care of name mangling, etc.
+	 * 
+	 * @param name
+	 *            Name and module of function or method to be invoked
+	 * @param type
+	 *            Type of function or method to be invoked
+	 * @return
+	 */
+	public Bytecode.Invoke createMethodInvocation(NameID name, Type.FunctionOrMethod type) {
+		// Determine name of class corresponding to the given module
+		JvmType.Clazz owner = getModuleClass(name.module());
+		// Determine mangled name for function/method being invoked
+		String mangled = nameMangle(name.name(), type);
+		// Convert the type of the function/method being invoked
+		JvmType.Function fnType = convertFunType(type);
+		// Create the invocation!
+		return new Bytecode.Invoke(owner, mangled, fnType, Bytecode.InvokeMode.STATIC);
+	}
+
+	/**
+	 * Given an object array on the stack, take everything out of it an leave it
+	 * on the stack. This is needed to help handle multiple returns which are
+	 * packaged into object arrays.
+	 * 
+	 * @param types
+	 *            The list of types which are stored in the object array
+	 * @param context
+	 */
+	private void decodeOperandArray(List<Type> types, Context context) {
+		for (int i = 0; i != types.size(); ++i) {
+			Type type = types.get(i);
+			context.add(new Bytecode.Dup(JAVA_LANG_OBJECT_ARRAY));
+			context.add(new Bytecode.LoadConst(i));
+			context.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));
+			context.addReadConversion(type);
+			// At this point, we have the value on top of the stack and then the
+			// array reference. So, we can just swap them to get the desired
+			// order. 
+			context.add(new Bytecode.Swap());			
+		}
+		context.add(new Bytecode.Pop(JAVA_LANG_OBJECT_ARRAY));
+	}
+
+	public final static Type WHILEY_SYSTEM_T = Type
+			.Nominal(new NameID(Trie.fromString("whiley/lang/System"), "Console"));
+
+	public final static JvmType.Clazz WHILEYUTIL = new JvmType.Clazz("wyjc.runtime", "Util");
+	public final static JvmType.Clazz WHILEYARRAY = new JvmType.Clazz("wyjc.runtime", "WyArray");
+	public final static JvmType.Clazz WHILEYTYPE = new JvmType.Clazz("wyjc.runtime", "WyType");
+	public final static JvmType.Clazz WHILEYRECORD = new JvmType.Clazz("wyjc.runtime", "WyRecord");
+	public final static JvmType.Clazz WHILEYOBJECT = new JvmType.Clazz("wyjc.runtime", "WyObject");
+	public final static JvmType.Clazz WHILEYBOOL = new JvmType.Clazz("wyjc.runtime", "WyBool");
+	public final static JvmType.Clazz WHILEYBYTE = new JvmType.Clazz("wyjc.runtime", "WyByte");
+	public final static JvmType.Clazz WHILEYINT = new JvmType.Clazz("java.math", "BigInteger");
+	public final static JvmType.Clazz WHILEYLAMBDA = new JvmType.Clazz("wyjc.runtime", "WyLambda");
+
+	private static final JvmType.Clazz JAVA_LANG_CHARACTER = new JvmType.Clazz("java.lang", "Character");
+	private static final JvmType.Clazz JAVA_LANG_SYSTEM = new JvmType.Clazz("java.lang", "System");
+	private static final JvmType.Clazz JAVA_LANG_ITERABLE = new JvmType.Clazz("java.lang", "Iterable");
+	public static final JvmType.Array JAVA_LANG_OBJECT_ARRAY = new JvmType.Array(JAVA_LANG_OBJECT);
+	private static final JvmType.Clazz JAVA_UTIL_LIST = new JvmType.Clazz("java.util", "List");
+	private static final JvmType.Clazz JAVA_UTIL_SET = new JvmType.Clazz("java.util", "Set");
+	// private static final JvmType.Clazz JAVA_LANG_REFLECT_METHOD = new
+	// JvmType.Clazz("java.lang.reflect","Method");
+	private static final JvmType.Clazz JAVA_IO_PRINTSTREAM = new JvmType.Clazz("java.io", "PrintStream");
+	private static final JvmType.Clazz JAVA_LANG_RUNTIMEEXCEPTION = new JvmType.Clazz("java.lang", "RuntimeException");
+	private static final JvmType.Clazz JAVA_LANG_ASSERTIONERROR = new JvmType.Clazz("java.lang", "AssertionError");
+	private static final JvmType.Clazz JAVA_UTIL_COLLECTION = new JvmType.Clazz("java.util", "Collection");
+
+	private JvmType.Function convertFunType(Type.FunctionOrMethod ft) {
+		ArrayList<JvmType> paramTypes = new ArrayList<JvmType>();
+		for (Type pt : ft.params()) {
+			paramTypes.add(toJvmType(pt));
+		}
+		JvmType rt;
+		switch (ft.returns().size()) {
+		case 0:
+			rt = T_VOID;
+			break;
+		case 1:
+			// Single return value
+			rt = toJvmType(ft.returns().get(0));
+			break;
+		default:
+			// Multiple return value
+			rt = JAVA_LANG_OBJECT_ARRAY;
+		}
+
+		return new JvmType.Function(rt, paramTypes);
+	}
+
+	/**
+	 * Convert a given WyIL type into a JVM type by expanding it into its
+	 * underlying form as far as possible.
+	 * 
+	 * @param t
+	 *            the type to be expanded.
+	 * @return
+	 */
+	private JvmType toJvmType(Type t) {
+		if (t == Type.T_VOID) {
+			return T_VOID;
+		} else if (t == Type.T_ANY) {
+			return JAVA_LANG_OBJECT;
+		} else if (t == Type.T_NULL) {
+			return JAVA_LANG_OBJECT;
+		} else if (t instanceof Type.Bool) {
+			return WHILEYBOOL;
+		} else if (t instanceof Type.Byte) {
+			return WHILEYBYTE;
+		} else if (t instanceof Type.Int) {
+			return WHILEYINT;
+		} else if (t instanceof Type.Meta) {
+			return WHILEYTYPE;
+		} else if (t instanceof Type.EffectiveArray) {
+			return WHILEYARRAY;
+		} else if (t instanceof Type.EffectiveRecord) {
+			return WHILEYRECORD;
+		} else if (t instanceof Type.Reference) {
+			return WHILEYOBJECT;
+		} else if (t instanceof Type.Negation) {
+			// can we do any better?
+			return JAVA_LANG_OBJECT;
+		} else if (t instanceof Type.Union) {
+			// What we need to do here, is determine whether or not a common
+			// specific type exists to all bounds. For example, if all bounds
+			// are records then the true result is WHILEYRECORD. However, in the
+			// general case we just return object.
+			Type.Union ut = (Type.Union) t;
+			JvmType result = null;
+			for (Type bound : ut.bounds()) {
+				JvmType r = toJvmType(bound);
+				if (result == null) {
+					result = r;
+				} else if (!r.equals(result)) {
+					result = JAVA_LANG_OBJECT;
+				}
+			}
+			return result;
+		} else if (t instanceof Type.Meta) {
+			return JAVA_LANG_OBJECT;
+		} else if (t instanceof Type.FunctionOrMethod) {
+			return WHILEYLAMBDA;
+		} else if (t instanceof Type.Nominal) {
+			try {
+				Type expanded = typeSystem.getUnderlyingType(t);
+				return toJvmType(expanded);
+			} catch (InternalFailure ex) {
+				throw ex;
+			} catch (Exception e) {
+				throw new InternalFailure("error expanding type: " + t, file.getEntry(), null);
+			}
+		} else {
+			throw new RuntimeException("unknown type encountered: " + t);
+		}
+	}
+
+	/**
+	 * Get the JvmType.Clazz associated with a given WyIL module.
+	 * 
+	 * @param mid
+	 * @return
+	 */
+	private JvmType.Clazz getModuleClass(Path.ID mid) {
+		return new JvmType.Clazz(mid.parent().toString().replace('/', '.'), mid.last());
+	}
+
+	/**
+	 * Construct a list of modifiers from an array of (potentially null)
+	 * modifiers.
+	 * 
+	 * @param mods
+	 * @return
+	 */
+	private static List<Modifier> modifiers(Modifier... mods) {
+		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
+		for (Modifier m : mods) {
+			if (m != null) {
+				modifiers.add(m);
+			}
+		}
+		return modifiers;
+	}
+
+	protected int label = 0;
+
+	protected String freshLabel() {
+		return "cfblab" + label++;
+	}
+
+	private static String nameMangle(String name, Type.FunctionOrMethod ft) {
+		try {
+			return name + "$" + typeMangle(ft);
+		} catch (IOException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	private static String typeMangle(Type.FunctionOrMethod ft) throws IOException {
+		JavaIdentifierOutputStream jout = new JavaIdentifierOutputStream();
+		BinaryOutputStream binout = new BinaryOutputStream(jout);
+		Type.BinaryWriter tm = new Type.BinaryWriter(binout);
+		tm.write(ft);
+		binout.close(); // force flush
+		return jout.toString();
+	}
+
+	private static <T> T[] append(T[] lhs, T... rhs) {
+		T[] noperands = Arrays.copyOf(lhs,lhs.length+rhs.length);		
+		System.arraycopy(rhs, 0, noperands, lhs.length, rhs.length);
+		return noperands;
+	}
+	
+	private static int getFirstFreeRegister(SyntaxTree tree) {
+		return tree.getLocations().size();
+	}
+
+	/**
+	 * A constant is some kind of auxillary functionality used in generated
+	 * code, which can be reused at multiple sites. This includes value
+	 * constants, and coercion functions.
+	 * 
+	 * @author David J. Pearce
+	 *
+	 */
+	private abstract static class JvmConstant {
+	}
+
+	private static final class JvmValue extends JvmConstant {
+		public final Constant value;
+
+		public JvmValue(Constant v) {
+			value = v;
+		}
+
+		public boolean equals(Object o) {
+			if (o instanceof JvmValue) {
+				JvmValue vc = (JvmValue) o;
+				return value.equals(vc.value);
+			}
+			return false;
+		}
+
+		public int hashCode() {
+			return value.hashCode();
+		}
+
+		public static int get(Constant value, HashMap<JvmConstant, Integer> constants) {
+			JvmValue vc = new JvmValue(value);
+			Integer r = constants.get(vc);
+			if (r != null) {
+				return r;
+			} else {
+				int x = constants.size();
+				constants.put(vc, x);
+				return x;
+			}
+		}
+	}
+
+	public class Context {
+		/**
+		 * The list of bytecodes that have been generated so far
+		 */
+		private final ArrayList<Bytecode> bytecodes;
+
+		/**
+		 * Determine the branch target for a break statement
+		 */
+		private final String breakLabel;
+		
+		/**
+		 * Determine the branch target for a continue statement
+		 */
+		private final String continueLabel;
+
+		public Context() {
+			this(new ArrayList<Bytecode>(),null,null);
+		}
+
+		public Context(ArrayList<Bytecode> bytecodes, String breakLabel, String continueLabel) {
+			this.bytecodes = bytecodes;
+			this.breakLabel = breakLabel;
+			this.continueLabel = continueLabel;
+		}
+	
+		public List<Bytecode> getBytecodes() {
+			return bytecodes;
+		}
+
+		public String getBreakLabel() {
+			return breakLabel;
+		}
+
+		public String getContinueLabel() {
+			return continueLabel;
+		}
+		
+		public Context newLoopBlock(String breakLabel, String continueLabel) {
+			return new Context(bytecodes, breakLabel, continueLabel);
+		}
+
+		/**
+		 * The write conversion is necessary in situations where we're write a value
+		 * from the stack into a collection (e.g. WhileyList, WhileySet, etc). In
+		 * such case, we need to convert boolean values from bool primitives to
+		 * Boolean objects.
+		 */
+		public void addWriteConversion(Type type) {
+			// This currently does nothing since there are currently no data types
+			// implemented as primitives.
+		}
+		
+		/**
+		 * The read conversion is necessary in situations where we're reading a
+		 * value from a collection (e.g. WhileyList, WhileySet, etc) and then
+		 * putting it on the stack. In such case, we need to convert boolean values
+		 * from Boolean objects to bool primitives.
+		 */
+		public void addReadConversion(Type type) {
+			// This doesn't do anything extra since there are currently no data
+			// types implemented as primitives.
+			addCheckCast(toJvmType(type));
+		}
+		
+		private void addCheckCast(JvmType type) {
+			// The following can happen in situations where a variable has type
+			// void. In principle, we could remove this as obvious dead-code, but
+			// for now I just avoid it.
+			if (type instanceof JvmType.Void) {
+				return;
+			} else if (!type.equals(JAVA_LANG_OBJECT)) {
+				// pointless to add a cast for object
+				add(new Bytecode.CheckCast(type));
+			}
+		}
+		
+		/**
+		 * The construct method provides a generic way to construct a Java object.
+		 *
+		 * @param owner
+		 * @param context
+		 * @param params
+		 */
+		private void construct(JvmType.Clazz owner) {
+			add(new Bytecode.New(owner));
+			add(new Bytecode.Dup(owner));
+			ArrayList<JvmType> paramTypes = new ArrayList<JvmType>();
+			JvmType.Function ftype = new JvmType.Function(T_VOID, paramTypes);
+			add(new Bytecode.Invoke(owner, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+		}
+
+		public JvmType toJvmType(Type type) {
+			return Wyil2JavaBuilder.this.toJvmType(type);
+		}
+		
+		public Type.EffectiveArray expandAsEffectiveArray(Type type) throws ResolveError {
+			return typeSystem.expandAsEffectiveArray(type);
+		}
+
+		public Type.EffectiveRecord expandAsEffectiveRecord(Type type) throws ResolveError {
+			return typeSystem.expandAsEffectiveRecord(type);
+		}
+
+		public Type.Reference expandAsReference(Type type) throws ResolveError {
+			return typeSystem.expandAsReference(type);
+		}
+
+		public void add(Bytecode bytecode) {
+			bytecodes.add(bytecode);
+		}
+	}
+
+	/**
+	 * Provides a simple interface for translating individual bytecodes.
+	 * 
+	 * @author David J. Pearce
+	 *
+	 */
+	public interface BytecodeTranslator {
+		void translate(Location<Operator> bytecode, Context context) throws ResolveError;
+	}
+}
diff --git a/modules/wyjc/src/wyjc/WyjcMain.java b/modules/wyjc/src/wyjc/WyjcMain.java
new file mode 100755
index 0000000000..b0b3591133
--- /dev/null
+++ b/modules/wyjc/src/wyjc/WyjcMain.java
@@ -0,0 +1,85 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Map;
+
+import wyc.WycMain;
+import wyc.util.WycBuildTask;
+import wycc.util.OptArg;
+import wyjc.util.WyjcBuildTask;
+
+/**
+ * The main class provides all of the necessary plumbing to process command-line
+ * options, construct an appropriate pipeline and then instantiate the Whiley
+ * Compiler to generate class files.
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WyjcMain extends WycMain {
+
+	public static final OptArg[] EXTRA_OPTIONS = {
+		new OptArg("classdir", "cd", OptArg.FILEDIR, "Specify where to place generated class files",
+			new File("."))
+	};
+
+	public static OptArg[] DEFAULT_OPTIONS;
+
+	static {
+		// first append options
+		OptArg[] options = new OptArg[WycMain.DEFAULT_OPTIONS.length
+				+ EXTRA_OPTIONS.length];
+		System.arraycopy(WycMain.DEFAULT_OPTIONS, 0, options, 0,
+				WycMain.DEFAULT_OPTIONS.length);
+		System.arraycopy(EXTRA_OPTIONS, 0, options,
+				WycMain.DEFAULT_OPTIONS.length, EXTRA_OPTIONS.length);
+		WyjcMain.DEFAULT_OPTIONS = options;
+	}
+
+	public WyjcMain(WyjcBuildTask builder, OptArg[] options) {
+		super(builder, options);
+	}
+
+	@Override
+	public void configure(Map<String, Object> values) throws IOException {
+		super.configure(values);
+
+		File classDir = (File) values.get("classdir");
+		if (classDir != null) {
+			((WyjcBuildTask) builder).setClassDir(classDir);
+		}
+	}
+
+	public static void main(String[] args) {
+
+		// now, run wyjc build task
+		System.exit(new WyjcMain(new WyjcBuildTask(), DEFAULT_OPTIONS).run(args));
+	}
+}
diff --git a/modules/wyjc/src/wyjc/runtime/Util.java b/modules/wyjc/src/wyjc/runtime/Util.java
new file mode 100755
index 0000000000..2fb8ec8b64
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/Util.java
@@ -0,0 +1,262 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+import java.lang.reflect.Method;
+import java.math.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Map;
+
+import static wyil.lang.Type.*;
+
+public class Util {
+
+	/**
+	 * This method is used to convert the arguments supplied to main (which have
+	 * type <code>String[]</code>) into an appropriate Whiley List.
+	 *
+	 * @param args
+	 * @return
+	 */
+	public static WyArray fromStringList(String[] args) {
+		WyArray r = new WyArray(args.length);
+		for(int i=0;i!=args.length;++i) {
+			r.add(str2il(args[i]));
+		}
+		return r;
+	}
+
+	/**
+	 * Coerce a string into a Whiley int list.
+	 * @param str
+	 * @return
+	 */
+	public static WyArray str2il(String str) {
+		WyArray r = new WyArray(str.length());
+		for(int i=0;i!=str.length();++i) {
+			r.add(BigInteger.valueOf(str.charAt(i)));
+		}
+		return r;
+	}
+
+	public static String il2str(WyArray argument) {
+		String r = "";
+		for(int i=0;i!=argument.size();++i) {
+			BigInteger c = (BigInteger) argument.get(i);
+			r = r + ((char) c.intValue());
+		}
+		return r;
+	}
+	
+	/**
+	 * This method is used for the special case when the left-hand side of an
+	 * equality operation may be null.
+	 *
+	 * @param o1
+	 * @param o2
+	 * @return
+	 */
+	public static boolean equals(Object o1, Object o2) {
+		return (o1 != null && o1.equals(o2)) || (o1 == o2);
+	}
+
+	public static WyBool equal(Object o1, Object o2) {
+		return WyBool.valueOf(equals(o1,o2));
+	}
+		
+	public static WyBool notEqual(Object o1, Object o2) {
+		return WyBool.valueOf(!equals(o1,o2));
+	}
+	
+	public static WyBool lessThan(BigInteger i1, BigInteger i2) {
+		return WyBool.valueOf(i1.compareTo(i2) < 0);
+	}
+	
+	public static WyBool lessThanEqual(BigInteger i1, BigInteger i2) {
+		return WyBool.valueOf(i1.compareTo(i2) <= 0);
+	}
+	
+	public static WyBool greaterThan(BigInteger i1, BigInteger i2) {
+		return WyBool.valueOf(i1.compareTo(i2) > 0);
+	}
+	
+	public static WyBool greaterThanEqual(BigInteger i1, BigInteger i2) {
+		return WyBool.valueOf(i1.compareTo(i2) >= 0);
+	}
+		
+	public static final Comparator COMPARATOR = new Comparator();
+
+	public static final class Comparator implements java.util.Comparator {
+		private Comparator() {}
+
+		public final int compare(Object o1, Object o2) {
+			return Util.compare(o1,o2);
+		}
+	}
+
+	public static int compare(Object o1, Object o2) {
+		if(o1 == null) {
+			return o2 == null ? 0 : -1;
+		} else if(o1 instanceof BigInteger) {
+			return compare((BigInteger)o1,o2);
+		} else if(o1 instanceof WyArray) {
+			return compare((WyArray)o1,o2);
+		} else if(o1 instanceof WyRecord) {
+			return compare((WyRecord)o1,o2);
+		} else {
+			throw new IllegalArgumentException("Invalid object passed to comparator: " + o1);
+		}
+	}
+
+	public static int compare(BigInteger o1, Object o2) {
+		if(o2 == null || o2 instanceof Boolean) {
+			return 1;
+		} else if(o2 instanceof BigInteger) {
+			BigInteger b2 = (BigInteger) o2;
+			return o1.compareTo(b2);
+		} else {
+			return -1;
+		}
+	}
+
+	public static int compare(WyArray o1, Object o2) {
+		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger) {
+			return 1;
+		} else if (o2 instanceof WyArray) {
+			return compare(o1, (WyArray) o2);
+		} else {
+			return -1;
+		}
+	}
+
+	public static int compare(WyArray o1, WyArray o2) {
+		int s1_size = o1.size();
+		int s2_size = o2.size();
+		if(s1_size < s2_size) {
+			return -1;
+		} else if(s1_size > s2_size) {
+			return 1;
+		} else {
+			for(int i=0;i!=s1_size;++i) {
+				Object e1 = o1.get(i);
+				Object e2 = o2.get(i);
+				int c = compare(e1,e2);
+				if(c != 0) {
+					return c;
+				}
+			}
+			return 0;
+		}
+	}
+
+	public static int compare(WyRecord o1, Object o2) {
+		if (o2 == null || o2 instanceof Boolean || o2 instanceof BigInteger) {
+			return 1;
+		} else if (o2 instanceof WyRecord) {
+			return compare(o1, (WyRecord) o2);
+		} else {
+			return -1;
+		}
+	}
+
+	public static int compare(WyRecord o1, WyRecord o2) {
+		ArrayList<String> mKeys = new ArrayList<String>(o1.keySet());
+		ArrayList<String> tKeys = new ArrayList<String>(o2.keySet());
+		Collections.sort(mKeys);
+		Collections.sort(tKeys);
+
+		for(int i=0;i!=Math.min(mKeys.size(),tKeys.size());++i) {
+			String mk = mKeys.get(i);
+			String tk = tKeys.get(i);
+			int c = mk.compareTo(tk);
+			if(c != 0) {
+				return c;
+			}
+			String mv = o1.get(mk).toString();
+			String tv = o2.get(tk).toString();
+			c = mv.compareTo(tv);
+			if(c != 0) {
+				return c;
+			}
+		}
+
+		if(mKeys.size() < tKeys.size()) {
+			return -1;
+		} else if(mKeys.size() > tKeys.size()) {
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+
+	public static void print(WyArray argument) {
+		for(int i=0;i!=argument.size();++i) {
+			BigInteger c = (BigInteger) argument.get(i);
+			System.out.print((char) c.intValue());
+		}
+	}
+	
+	public static void println(WyArray argument) {
+		print(argument);
+		System.out.println();
+	}
+
+	public static WyRecord systemConsole(String[] args) {
+		WyRecord sysout = new WyRecord();
+
+		sysout.put("print_s", new WyLambda() {
+			public Object call(Object[] arguments) {
+				print((WyArray) arguments[0]);						
+				return null;
+			}
+		});
+		sysout.put("println_s", new WyLambda() {
+			public Object call(Object[] arguments) {
+				println((WyArray) arguments[0]);								
+				return null;
+			}
+		});
+		sysout.put("print", new WyLambda() {
+			public Object call(Object[] arguments) {
+				System.out.print(arguments[0]);					
+				return null;
+			}
+		});
+		sysout.put("println", new WyLambda() {
+			public Object call(Object[] arguments) {
+				System.out.println(arguments[0]);								
+				return null;
+			}
+		});
+		
+		WyRecord console = new WyRecord();
+		console.put("out", sysout);
+		console.put("args",fromStringList(args));
+		return console;
+	}
+
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyArray.java b/modules/wyjc/src/wyjc/runtime/WyArray.java
new file mode 100755
index 0000000000..25c52190de
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyArray.java
@@ -0,0 +1,180 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+import java.math.BigInteger;
+import java.util.Collections;
+import java.util.Map;
+
+public final class WyArray extends java.util.ArrayList {
+
+	// ================================================================================
+	// Generic Operations
+	// ================================================================================
+
+	public WyArray() {
+		super();
+	}
+
+	public WyArray(int size) {
+		super(size);
+	}
+
+	WyArray(java.util.Collection items) {
+		super(items);		
+	}
+
+	public String toString() {
+		String r = "[";
+		boolean firstTime=true;
+		for(Object o : this) {
+			if(!firstTime) {
+				r += ", ";
+			}
+			firstTime=false;
+			r += whiley.lang.Any$native.toRealString(o);
+		}
+		return r + "]";
+	}
+
+	// ================================================================================
+	// List Operations
+	// ================================================================================
+
+	public static Object get(WyArray list, BigInteger index) {
+		return list.get(index.intValue());
+	}
+
+	public static WyArray set(WyArray list, final BigInteger index, final Object value) {		
+		// Clone the list to be safe.
+		list = new WyArray(list);		
+		list.set(index.intValue(),value);
+		return list;
+	}
+
+	public BigInteger length() {
+		return BigInteger.valueOf(size());
+	}
+
+	public static WyArray append(WyArray lhs, WyArray rhs) {				
+		lhs = new WyArray(lhs);
+		lhs.addAll(rhs);
+		return lhs;
+	}
+
+	public static WyArray append(WyArray list, final Object item) {			
+		list = new WyArray(list);
+		list.add(item);
+		return list;
+	}
+
+	public static WyArray append(final Object item, WyArray list) {
+		list = new WyArray(list);
+		list.add(0,item);
+		return list;
+	}
+
+	public static int size(final WyArray list) {
+		return list.size();
+	}
+
+	/**
+	 * Return a list constructed from the range of two integers.
+	 * 
+	 * @param start
+	 * @param end
+	 * @return
+	 */
+	public static WyArray range(BigInteger start, BigInteger end) {
+		WyArray l = new WyArray();
+
+		long st = start.longValue();
+		long en = start.longValue();
+		if (BigInteger.valueOf(st).equals(start)
+				&& BigInteger.valueOf(en).equals(end)) {
+			int dir = st < en ? 1 : -1;
+			while(st != en) {
+				l.add(BigInteger.valueOf(st));
+				st = st + dir;
+			}
+		} else {
+			BigInteger dir;
+			if(start.compareTo(end) < 0) {
+				dir = BigInteger.ONE;
+			} else {
+				dir = BigInteger.valueOf(-1);
+			}
+			while(!start.equals(end)) {
+				l.add(start);
+				start = start.add(dir);
+			}
+		}
+
+		return l;
+	}
+	
+	public static WyArray generate(final BigInteger count, final Object element) {
+		int n = count.intValue();
+		WyArray list = new WyArray();
+		for(int i=0;i<n;++i) {
+			list.add(element);
+		}
+		return list;
+	}
+	
+	// ========================================================
+	// Helpers
+	// ========================================================
+	
+	/**
+	 * This method is not intended for public consumption. It is used internally
+	 * by the compiler during object construction only.
+	 *
+	 * @param list
+	 * @param item
+	 * @return
+	 */
+	public static WyArray internal_add(WyArray list, final Object item) {
+		list.add(item);
+		return list;
+	}
+
+	/**
+	 * This method is not intended for public consumption. It is used internally
+	 * by the compiler during imperative updates only.
+	 *
+	 * @param list
+	 * @param item
+	 * @return
+	 */
+	public static Object internal_get(WyArray list, BigInteger index) {
+		return list.get(index.intValue());		
+	}
+
+	public static java.util.Iterator iterator(WyArray list) {
+		return list.iterator();
+	}
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyBool.java b/modules/wyjc/src/wyjc/runtime/WyBool.java
new file mode 100755
index 0000000000..657c012790
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyBool.java
@@ -0,0 +1,52 @@
+package wyjc.runtime;
+
+public class WyBool {
+	private boolean value;
+
+	private WyBool(boolean value) {
+		this.value = value;
+	}
+
+	public boolean value() {
+		return value;
+	}
+	
+	public WyBool not() {
+		return new WyBool(!value);
+	}
+	
+	public WyBool and(WyBool b) {
+		return new WyBool(value & b.value);
+	}
+	
+	public WyBool or(WyBool b) {
+		return new WyBool(value | b.value);
+	}
+	
+	public boolean equals(Object o) {
+		if (o instanceof WyBool) {
+			WyBool b = (WyBool) o;
+			return value == b.value;
+		}
+		return false;
+	}
+
+	public int hashCode() {
+		return value ? 0 : 1;
+	}
+	
+	public String toString() {
+		return value ? "true" : "false";
+	}
+
+	public static WyBool valueOf(boolean b) {
+		if (b) {
+			return TRUE;
+		} else {
+			return FALSE;
+		}
+	}
+
+	public final static WyBool TRUE = new WyBool(true);
+	public final static WyBool FALSE = new WyBool(false);
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyByte.java b/modules/wyjc/src/wyjc/runtime/WyByte.java
new file mode 100755
index 0000000000..77d76a8d0b
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyByte.java
@@ -0,0 +1,85 @@
+package wyjc.runtime;
+
+import java.math.BigInteger;
+
+public class WyByte implements Comparable<WyByte> {
+	private byte value;
+
+	private WyByte(byte value) {		
+		this.value = value;
+	}
+
+	public byte value() {
+		return value;
+	}
+	
+	public WyByte and(WyByte b) {
+		return WyByte.valueOf((byte) (value & b.value));
+	}
+	
+	public WyByte or(WyByte b) {
+		return WyByte.valueOf((byte) (value | b.value));
+	}
+	
+	public WyByte xor(WyByte b) {
+		return WyByte.valueOf((byte) (value ^ b.value));
+	}
+
+	public WyByte leftShift(BigInteger i) {
+		byte b = (byte) ((value&0xFF) << i.intValue());
+		return WyByte.valueOf(b);
+	}
+	
+	public WyByte rightShift(BigInteger i) {
+		byte b = (byte) ((value&0xFF) >>> i.intValue());
+		return WyByte.valueOf(b);
+	}
+	
+	
+	
+	public WyByte compliment() {
+		return valueOf((byte) ~value);
+	}
+
+	
+	@Override
+	public int compareTo(WyByte o) {
+		if(value < o.value) { 
+			return -1;
+		} else if(value > o.value) {
+			return 1;
+		} else {
+			return 0;
+		}
+	}
+	
+	public boolean equals(Object o) {
+		if (o instanceof WyByte) {
+			WyByte b = (WyByte) o;
+			return value == b.value;
+		}
+		return false;
+	}
+
+	public int hashCode() {
+		return value;
+	}
+	
+	public String toString() {
+		String r = "b";
+		byte v = (byte) value;
+		for(int i=0;i!=8;++i) {
+			if((v&0x1) == 1) {
+				r = "1" + r;
+			} else {
+				r = "0" + r;
+			}
+			v = (byte) (v >>> 1);
+		}
+		return r;
+	}
+
+	public static WyByte valueOf(byte val) {
+		return new WyByte(val);
+	}
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyLambda.java b/modules/wyjc/src/wyjc/runtime/WyLambda.java
new file mode 100755
index 0000000000..877b9552b2
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyLambda.java
@@ -0,0 +1,34 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+import java.util.Arrays;
+
+public abstract class WyLambda {
+	
+	public abstract Object call(Object[] parameters);
+	
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyObject.java b/modules/wyjc/src/wyjc/runtime/WyObject.java
new file mode 100755
index 0000000000..1f4f3ad3ec
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyObject.java
@@ -0,0 +1,43 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+public final class WyObject {
+	private Object state;
+
+	public WyObject(Object c) {
+		state = c;
+	}
+
+	public Object state() {
+		return state;
+	}
+
+	public WyObject setState(Object nstate) {
+		this.state = nstate;
+		return this;
+	}
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyRecord.java b/modules/wyjc/src/wyjc/runtime/WyRecord.java
new file mode 100755
index 0000000000..49ed740828
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyRecord.java
@@ -0,0 +1,79 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+import java.util.*;
+
+public final class WyRecord extends HashMap<String,Object> {
+	
+	public WyRecord() {}
+
+	WyRecord(HashMap<String,Object> r) {
+		super(r);		
+	}
+
+	// ================================================================================
+	// Generic Operations
+	// ================================================================================
+
+	public String toString() {
+		String r = "{";
+		boolean firstTime = true;
+
+		ArrayList<String> ss = new ArrayList<String>(keySet());
+		Collections.sort(ss);
+		for (String s : ss) {
+			if (!firstTime) {
+				r = r + ",";
+			}
+			firstTime = false;
+			r = r + s + ":" + whiley.lang.Any$native.toRealString(get(s));
+		}
+		return r + "}";
+	}
+
+	// ================================================================================
+	// Record Operations
+	// ================================================================================
+
+	public Object get(final String field) {
+		return super.get(field);
+	}
+	
+	public static Object get(final WyRecord record, final String field) {
+		return record.get(field);
+	}
+
+	public static WyRecord put(WyRecord record, final String field, final Object value) {
+		record = new WyRecord(record);
+		record.put(field, value);		
+		return record;
+	}
+
+	public static Object internal_get(final WyRecord record, final String field) {
+		return record.get(field);		
+	}
+}
diff --git a/modules/wyjc/src/wyjc/runtime/WyType.java b/modules/wyjc/src/wyjc/runtime/WyType.java
new file mode 100755
index 0000000000..328d22ad81
--- /dev/null
+++ b/modules/wyjc/src/wyjc/runtime/WyType.java
@@ -0,0 +1,665 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.runtime;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.*;
+
+import wyfs.io.BinaryInputStream;
+import wyrl.io.JavaIdentifierInputStream;
+import static wyil.lang.Type.K_VOID;
+import static wyil.lang.Type.K_ANY;
+import static wyil.lang.Type.K_META;
+import static wyil.lang.Type.K_NULL;
+import static wyil.lang.Type.K_BOOL;
+import static wyil.lang.Type.K_BYTE;
+import static wyil.lang.Type.K_INT;
+import static wyil.lang.Type.K_LIST;
+import static wyil.lang.Type.K_REFERENCE;
+import static wyil.lang.Type.K_RECORD;
+import static wyil.lang.Type.K_UNION;
+import static wyil.lang.Type.K_NEGATION;
+import static wyil.lang.Type.K_FUNCTION;
+import static wyil.lang.Type.K_METHOD;
+import static wyil.lang.Type.K_NOMINAL;
+
+public abstract class WyType {
+
+	public final int kind;
+
+	private WyType(int kind) {
+		this.kind = kind;
+	}
+
+	public WyBool is(Object o) {
+		boolean r = instanceOf(o);
+		return r ? WyBool.TRUE : WyBool.FALSE;
+	}
+	
+	public abstract boolean instanceOf(Object o);
+	
+	public static final Void VOID = new Void();
+	public static final Any ANY = new Any();
+	public static final Meta META = new Meta();
+	public static final Null NULL = new Null();
+	public static final Bool BOOL = new Bool();
+	public static final Byte BYTE = new Byte();
+	public static final Integer INT = new Integer();
+	
+	private static final class Void extends WyType {
+		Void() {
+			super(K_VOID);
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return false;
+		}
+	}
+
+	private static final class Any extends WyType {
+		Any() {
+			super(K_ANY);
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return true;
+		}
+	}
+
+	private static final class Meta extends WyType {
+		Meta() {
+			super(K_META);
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return false;
+		}
+	}
+
+	private static final class Null extends WyType {
+		Null() {
+			super(K_NULL);
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return o == null;
+		}
+	}
+
+	private static final class Bool extends WyType {
+		Bool() {
+			super(K_BOOL);
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return o instanceof WyBool;
+		}
+	}
+
+	private static final class Byte extends WyType {
+		Byte() {
+			super(K_BYTE);
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			return o instanceof WyByte;
+		}
+	}
+
+	private static final class Integer extends WyType {
+		Integer() {
+			super(K_INT);
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			return o instanceof BigInteger;
+		}
+	}
+
+	public static final class Reference extends WyType {
+		public WyType element;
+
+		public Reference(WyType element) {
+			super(K_REFERENCE);
+			this.element = element;
+		}
+
+		@Override
+		public boolean instanceOf(Object obj) {
+			if(obj instanceof WyObject) {
+				WyObject ol = (WyObject) obj;
+				return element.instanceOf(ol.state());
+			}
+			return false;
+		}
+	}
+
+	public static final class Array extends WyType {
+		public WyType element;
+		public final boolean nonEmpty;
+
+		public Array(WyType element, boolean nonEmpty) {
+			super(K_LIST);
+			this.element = element;
+			this.nonEmpty = nonEmpty;
+		}
+
+		@Override
+		public boolean instanceOf(Object obj) {
+			if(obj instanceof WyArray) {
+				WyArray ol = (WyArray) obj;
+				if(nonEmpty && ol.isEmpty()) {
+					return false;
+				}
+				if(element.kind == K_ANY) {
+					return true;
+				} else if(element.kind == K_VOID) {
+					return ol.isEmpty();
+				} else {
+					for(Object elem : ol) {
+						if(!element.instanceOf(elem)) {
+							return false;
+						}
+					}
+					return true;
+				}
+			}
+			return false;
+		}
+	}
+
+	public static final class Record extends WyType {
+		public final String[] names;
+		public final WyType[] types;
+		public final boolean isOpen;
+		public Record(String[] names, WyType[] types, boolean open) {
+			super(K_RECORD);
+			this.names = names;
+			this.types = types;
+			this.isOpen = open;
+		}
+		@Override
+		public boolean instanceOf(Object obj) {
+			if(obj instanceof WyRecord) {
+				WyRecord ol = (WyRecord) obj;
+				if(!isOpen && names.length != ol.size()) {
+					return false;
+				}
+				for(int i=0;i!=names.length;++i) {
+					String name = names[i];
+					if(ol.containsKey(name)) {
+						WyType type = types[i];
+						Object val = ol.get(name);
+						if(!type.instanceOf(val)) {
+							return false;
+						}
+					} else {
+						return false;
+					}
+				}
+				return true;
+			}
+			return false;
+		}
+	}
+
+	public static final class Union extends WyType {
+		public final WyType[] bounds;
+		public Union(WyType... bounds) {
+			super(K_UNION);
+			this.bounds = bounds;
+		}
+		@Override
+		public boolean instanceOf(Object obj) {
+			for(WyType bound : bounds) {
+				if(bound.instanceOf(obj)) {
+					return true;
+				}
+			}
+			return false;
+		}
+	}
+
+	private static final class Nominal extends WyType {
+		public final String name;
+		public Nominal(String name) {
+			super(K_NOMINAL);
+			this.name = name;
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			return false;
+		}
+	}
+
+	public static final class Negation extends WyType {
+		public WyType element;
+
+		public Negation(WyType element) {
+			super(K_NEGATION);
+			this.element = element;
+		}
+
+		@Override
+		public boolean instanceOf(Object o) {
+			return !element.instanceOf(o);
+		}
+	}
+
+	public static final class Function extends WyType {
+		public final WyType[] returns;
+		public final WyType[] parameters;
+		public Function(WyType[] returns, WyType[] parameters) {
+			super(K_FUNCTION);
+			this.parameters = parameters;
+			this.returns = returns;
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			// FIXME: this is fundamentally broken, since it does not consider
+			// the parameter types of the underlying function. See #552
+			return o instanceof WyLambda;
+		}
+	}
+	
+	public static final class Method extends WyType {
+		public final WyType[] returns;
+		public final WyType[] parameters;
+		public Method(WyType[] returns, WyType[] parameters) {
+			super(K_METHOD);
+			this.parameters = parameters;
+			this.returns = returns;
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			// FIXME: this is fundamentally broken, since it does not consider
+			// the parameter types of the underlying function. See #552
+			return o instanceof WyLambda;
+		}
+	}
+	
+	public static final class Label extends WyType {
+		public final int label;
+		public Label(int label) {
+			super(-1);
+			this.label = label;
+		}
+		@Override
+		public boolean instanceOf(Object o) {
+			return false;
+		}
+	}
+
+	public static WyType valueOf(String str) throws IOException {
+		JavaIdentifierInputStream jin = new JavaIdentifierInputStream(str);
+		BinaryInputStream bin = new BinaryInputStream(jin);
+		ArrayList<WyType> nodes = new ArrayList<WyType>();
+		int size = bin.read_uv();
+		for(int i=0;i!=size;++i) {
+			nodes.add(readNode(bin, nodes));
+		}
+		for(int i=0;i!=size;++i) {
+			substitute(nodes.get(i),nodes);
+		}
+		return nodes.get(0);
+	}
+
+	private static WyType readNode(BinaryInputStream reader, ArrayList<WyType> nodes) throws IOException {
+		int kind = reader.read_uv();
+		boolean deterministic = reader.read_bit();
+		int nchildren = reader.read_uv();
+		WyType[] children = new WyType[nchildren];
+		for (int i=0;i!=nchildren;++i) {
+			children[i]=new Label(reader.read_uv());
+		}
+		switch(kind) {
+		case K_VOID:
+			return VOID;
+		case K_ANY:
+			return ANY;
+		case K_META:
+			return META;
+		case K_NULL:
+			return NULL;
+		case K_BOOL:
+			return BOOL;
+		case K_BYTE:
+			return BYTE;		
+		case K_INT:
+			return INT;
+		case K_LIST: {
+			boolean nonEmpty = reader.read_bit();
+			return new Array(children[0],nonEmpty);
+		}
+		case K_REFERENCE: {
+			return new Reference(children[0]);
+		}
+		case K_RECORD: {
+			boolean isOpen = reader.read_bit();
+			int nfields = reader.read_uv();
+			String[] fields = new String[nfields];
+			for(int i=0;i!=nfields;++i) {
+				fields[i] = readString(reader);
+			}
+			return new Record(fields,children,isOpen);
+		}
+		case K_UNION: {
+			return new Union(children);
+		}
+		case K_NEGATION: {
+			return new Negation(children[0]);
+		}
+		case K_NOMINAL: {
+			String module = readString(reader);
+			String name = readString(reader);
+			return new WyType.Nominal(module + ":" + name);
+		}
+		case K_FUNCTION: {
+			int numParams = reader.read_uv();
+			return new WyType.Function(Arrays.copyOfRange(children, numParams, children.length),
+					Arrays.copyOfRange(children, 0, numParams));
+		}
+		case K_METHOD: {
+			int numParams = reader.read_uv();
+			return new WyType.Method(Arrays.copyOfRange(children, numParams, children.length),
+					Arrays.copyOfRange(children, 0, numParams));
+		}
+		}
+
+		throw new RuntimeException("unknow type encountered (kind: " + kind + ")");
+	}
+
+	private static String readString(BinaryInputStream reader) throws IOException {
+		String r = "";
+		int nchars = reader.read_uv();
+		for(int i=0;i!=nchars;++i) {
+			char c = (char) reader.read_u16();
+			r = r + c;
+		}
+		return r;
+	}
+
+	private static void substitute(WyType type, ArrayList<WyType> nodes) {
+		switch(type.kind) {
+		case K_VOID:
+		case K_ANY:
+		case K_META:
+		case K_NULL:
+		case K_BOOL:
+		case K_BYTE:
+		case K_INT:
+		case K_NOMINAL:
+			return;
+		case K_LIST: {
+			Array t = (Array) type;
+			t.element = substitute((Label)t.element,nodes);
+			return;
+		}
+		case K_REFERENCE: {
+			Reference t = (Reference) type;
+			t.element = substitute((Label)t.element,nodes);
+			return;
+		}
+		case K_RECORD:  {
+			Record t = (Record) type;
+			substitute(t.types,nodes);
+			return;
+		}
+		case K_UNION: {
+			Union t = (Union) type;
+			substitute(t.bounds,nodes);
+			return;
+		}
+		case K_NEGATION: {
+			Negation t = (Negation) type;
+			t.element = substitute((Label)t.element,nodes);
+			return;
+		}
+		case K_FUNCTION: {
+			Function t = (Function) type;
+			substitute(t.returns,nodes);
+			substitute(t.parameters,nodes);
+			return;
+		}
+		case K_METHOD: {
+			Method t = (Method) type;
+			substitute(t.returns,nodes);
+			substitute(t.parameters,nodes);
+			return;
+		}
+		}
+		throw new RuntimeException("unknow type encountered (kind: " + type.kind + ")");
+	}
+
+	private static void substitute(WyType[] types, ArrayList<WyType> nodes) {
+		for(int i=0;i!=types.length;++i) {
+			Label type = (Label) types[i];
+			types[i] = nodes.get(type.label);
+		}
+	}
+
+	private static WyType substitute(Label type, ArrayList<WyType> nodes) {
+		return nodes.get(type.label);
+	}
+
+	/**
+	 * <p>
+	 * This method connects up recursive links in a given type. In particular,
+	 * it replaces all occurrences of variable <code>var</code> with
+	 * <code>root</code>.
+	 * </p>
+	 *
+	 * <b>NOTE:</b> the resulting type may contain a cycle. For this reason, the
+	 * visited relation is required to ensure termination in the presence of
+	 * such cycles.
+	 *
+	 * @param type
+	 *            - The type currently be explored
+	 * @param label
+	 *            - The label to substitute for
+	 * @param root
+	 *            - The root of the recursive type. Variable <code>var</code>
+	 *            will be replaced with this.
+	 * @param visited
+	 *            - contains all of the visited nodes. This is needed to ensure
+	 *            termination in the presence of cycles.
+	 * @return
+	 */
+	private static WyType substitute(WyType type, String label, WyType root, HashSet<WyType> visited) {
+		if(visited.contains(type)) {
+			return type;
+		} else {
+			visited.add(type);
+		}
+		switch(type.kind) {
+			case K_ANY:
+			case K_VOID:
+			case K_NULL:
+			case K_INT:
+				break;
+			case K_NOMINAL:
+			{
+				WyType.Nominal leaf = (WyType.Nominal) type;
+				if(leaf.name.equals(label)) {
+					return root;
+				} else {
+					return leaf;
+				}
+			}
+			case K_LIST:
+			{
+				WyType.Array list = (WyType.Array) type;
+				list.element = substitute(list.element,label,root,visited);
+				break;
+			}
+			case K_RECORD:
+			{
+				WyType.Record rec = (WyType.Record) type;
+				WyType[] types = rec.types;
+				for(int i=0;i!=types.length;++i) {
+					types[i] = substitute(types[i],label,root,visited);
+				}
+				break;
+			}
+			case K_NEGATION:
+			{
+				WyType.Negation not = (WyType.Negation) type;
+				not.element = substitute(not.element,label,root,visited);
+				break;
+			}
+			case K_UNION:
+			{
+				WyType.Union un = (WyType.Union) type;
+				WyType[] types = un.bounds;
+				for(int i=0;i!=types.length;++i) {
+					types[i] = substitute(types[i],label,root,visited);
+				}
+				break;
+			}
+			case K_FUNCTION:
+			{
+				WyType.Function ft = (WyType.Function) type;
+				WyType[] paramTypes = ft.parameters;
+				for(int i=0;i!=paramTypes.length;++i) {
+					paramTypes[i] = substitute(paramTypes[i],label,root,visited);
+				}
+				WyType[] returnTypes = ft.returns;
+				for(int i=0;i!=returnTypes.length;++i) {
+					returnTypes[i] = substitute(returnTypes[i],label,root,visited);
+				}
+				break;
+			}
+			case K_METHOD:
+			{
+				WyType.Method ft = (WyType.Method) type;
+				WyType[] types = ft.parameters;
+				for(int i=0;i!=types.length;++i) {
+					types[i] = substitute(types[i],label,root,visited);
+				}
+				WyType[] returnTypes = ft.returns;
+				for(int i=0;i!=returnTypes.length;++i) {
+					returnTypes[i] = substitute(returnTypes[i],label,root,visited);
+				}
+				break;
+			}
+		}
+		return type;
+	}
+	
+	private static String toString(WyType t) {
+		return toString(t, new HashSet<WyType>());
+	}
+	
+	private static String toString(WyType t, HashSet<WyType> visited) {
+		if(visited.contains(t)) {
+			return "...";
+		} else {
+			visited.add(t);
+		}
+		switch (t.kind) {
+		case K_ANY:
+			return "any";
+		case K_VOID:
+			return "void";
+		case K_NULL:
+			return "null";
+		case K_INT:
+			return "int";
+		case K_NOMINAL: {
+			WyType.Nominal leaf = (WyType.Nominal) t;
+			return leaf.name;
+		}
+		case K_LIST: {
+			WyType.Array list = (WyType.Array) t;
+			return toString(list.element,visited) + "[]";
+		}
+		case K_RECORD: {
+			WyType.Record rec = (WyType.Record) t;
+			WyType[] types = rec.types;
+			String r = "";
+			for (int i = 0; i != types.length; ++i) {
+				if (i != 0) {
+					r = r + ",";
+				}
+				r += toString(types[i],visited) + " " + rec.names[i];
+			}
+			return "{" + r + "}";
+		}
+		case K_NEGATION: {
+			WyType.Negation not = (WyType.Negation) t;
+			return "!" + toString(not.element,visited);
+		}
+		case K_UNION: {
+			WyType.Union un = (WyType.Union) t;
+			WyType[] types = un.bounds;
+			String r = "";
+			for (int i = 0; i != types.length; ++i) {
+				if (i != 0) {
+					r = r + "|";
+				}
+				r += toString(types[i],visited);
+			}
+			return r;
+		}
+		case K_FUNCTION: {
+			WyType.Function ft = (WyType.Function) t;
+			WyType[] types = ft.parameters;
+			String r = "function(";
+			for (int i = 0; i != types.length; ++i) {
+				if (i != 0) {
+					r = r + ",";
+				}
+				r += toString(types[i],visited);
+			}
+			return r + ")->(" + toString(ft.returns,visited) + ")";
+		}
+		case K_METHOD: {
+			WyType.Method ft = (WyType.Method) t;
+			WyType[] types = ft.parameters;
+			return "function" + toString(ft.parameters, visited) + "->" + toString(ft.returns, visited);
+		}
+		}
+
+		throw new RuntimeException("unknow type encountered (kind: " + t.kind + ")");
+	}
+	
+	private static String toString(WyType[] types, HashSet<WyType> visited) {
+		String r = "(";
+		for (int i = 0; i != types.length; ++i) {
+			if (i != 0) {
+				r = r + ",";
+			}
+			r += toString(types[i],visited);
+		}
+		return r + ")";
+	}
+}
diff --git a/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java b/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java
new file mode 100755
index 0000000000..6b2e2aa62c
--- /dev/null
+++ b/modules/wyjc/src/wyjc/testing/RuntimeValidTests.java
@@ -0,0 +1,296 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.testing;
+
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.junit.*;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import wybs.lang.Build;
+import wybs.util.StdProject;
+import wyc.WycMain;
+import wyc.testing.TestUtils;
+import wyc.util.WycBuildTask;
+import wycc.util.Pair;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.util.DirectoryRoot;
+import wyfs.util.Trie;
+import wyil.Main.Registry;
+import wyjc.WyjcMain;
+import wyjc.util.WyjcBuildTask;
+
+/**
+ * Run through all valid test cases with verification enabled. Since every test
+ * file is valid, a successful test occurs when the compiler succeeds and, when
+ * executed, the compiled file produces the expected output. Note that an
+ * internal failure does not count as a valid pass, and indicates the test
+ * exposed some kind of compiler bug.
+ *
+ * @author David J. Pearce
+ *
+ */
+@RunWith(Parameterized.class)
+public class RuntimeValidTests {
+	
+	/**
+	 * Ignored tests and a reason why we ignore them.
+	 */
+	public final static Map<String, String> IGNORED = new HashMap<String, String>();
+
+	static {
+		IGNORED.put("Complex_Valid_3", "Issue ???");
+		IGNORED.put("Complex_Valid_4", "#663");
+		IGNORED.put("ConstrainedIntersection_Valid_1", "unknown");
+		IGNORED.put("ConstrainedNegation_Valid_1", "#342");
+		IGNORED.put("ConstrainedNegation_Valid_2", "#342");
+		IGNORED.put("FunctionRef_Valid_10", "#663");
+		IGNORED.put("FunctionRef_Valid_11", "#663");
+		IGNORED.put("FunctionRef_Valid_13", "#555");
+		IGNORED.put("IfElse_Valid_4", "#663");
+		IGNORED.put("Import_Valid_4", "#492");
+		IGNORED.put("Import_Valid_5", "#492");
+		IGNORED.put("Intersection_Valid_2", "Issue ???");
+		IGNORED.put("ListAccess_Valid_6", "Issue ???");
+		IGNORED.put("OpenRecord_Valid_5", "#663");
+		IGNORED.put("OpenRecord_Valid_6", "#664");
+		IGNORED.put("OpenRecord_Valid_11", "#585");
+		IGNORED.put("RecordSubtype_Valid_1", "Issue ???");
+		IGNORED.put("RecordSubtype_Valid_2", "Issue ???");
+		IGNORED.put("RecursiveType_Valid_2", "#663");		
+		IGNORED.put("RecursiveType_Valid_12", "#339");
+		IGNORED.put("RecursiveType_Valid_21", "#663");
+		IGNORED.put("RecursiveType_Valid_22", "#339");
+		IGNORED.put("RecursiveType_Valid_26", "unknown");
+		IGNORED.put("RecursiveType_Valid_28", "#364");
+		IGNORED.put("RecursiveType_Valid_3", "#406");
+		IGNORED.put("RecursiveType_Valid_4", "#406");
+		IGNORED.put("RecursiveType_Valid_5", "#18");
+		IGNORED.put("TypeEquals_Valid_23", "Issue ???");
+		IGNORED.put("TypeEquals_Valid_36", "Issue ???");
+		IGNORED.put("TypeEquals_Valid_37", "Issue ???");
+		IGNORED.put("TypeEquals_Valid_38", "Issue ???");
+		IGNORED.put("TypeEquals_Valid_41", "Issue ???");
+		IGNORED.put("While_Valid_15", "unknown");
+		IGNORED.put("While_Valid_20", "unknown");
+		
+		// Fails and was not listed as test case before parameterizing
+		IGNORED.put("Function_Valid_11", "unknown");
+		IGNORED.put("Function_Valid_15", "unknown");
+	
+		// Fails for reasons unknown
+		IGNORED.put("ConstrainedReference_Valid_1", "unknown");
+		IGNORED.put("FunctionRef_Valid_12", "unknown");
+		IGNORED.put("Lifetime_Lambda_Valid_4", "unknown");
+	}
+
+	/**
+	 * The directory containing the source files for each test case. Every test
+	 * corresponds to a file in this directory.
+	 */
+	public final static String WHILEY_SRC_DIR = "../../tests/valid".replace('/', File.separatorChar);
+
+	/**
+	 * The path to the Whiley-2-Java class files. These are needed so we can
+	 * access the JVM compiled version of the Whiley standard library, along
+	 * with additional runtime support classes.
+	 */
+ 	private static final String WYJC_CLASS_DIR="../../modules/wyjc/src/".replace('/', File.separatorChar);
+
+	private static final String WYBS_CLASS_DIR="../../modules/wybs/src/".replace('/', File.separatorChar);
+	
+ 	private static final String WYRL_CLASS_DIR="../../lib/wyrl-v0.4.4.jar".replace('/', File.separatorChar);
+
+	/**
+	 * The directory where compiler libraries are stored. This is necessary
+	 * since it will contain the Whiley Runtime.
+	 */
+	public final static String WYC_LIB_DIR = "../../lib/".replace('/', File.separatorChar);
+
+	/**
+	 * The path to the Whiley RunTime (WyRT) library. This contains the Whiley
+	 * standard library, which includes various helper functions, etc.
+	 */
+	private static String WYRT_PATH;
+
+	static {
+
+		// The purpose of this is to figure out what the proper name for the
+		// wyrt file is. Since there can be multiple versions of this file,
+		// we're not sure which one to pick.
+
+		File file = new File(WYC_LIB_DIR);
+		for(String f : file.list()) {
+			if(f.startsWith("wyrt-v")) {
+				WYRT_PATH = WYC_LIB_DIR + f;
+			}
+		}
+	}
+
+	// ======================================================================
+	// Test Harness
+	// ======================================================================
+
+	/**
+ 	 * Compile a syntactically invalid test case with verification enabled. The
+ 	 * expectation is that compilation should fail with an error and, hence, the
+ 	 * test fails if compilation does not.
+ 	 *
+ 	 * @param name
+ 	 *            Name of the test to run. This must correspond to a whiley
+ 	 *            source file in the <code>WHILEY_SRC_DIR</code> directory.
+ 	 */
+ 	protected void runTest(String name) {
+ 		// this will need to turn on verification at some point.
+ 		String filename = WHILEY_SRC_DIR + File.separatorChar + name + ".whiley";
+
+ 		int r = compile(
+ 				"-wd", WHILEY_SRC_DIR,      // location of source directory
+ 				"-cd", WHILEY_SRC_DIR,      // location where to place class files
+ 				"-wp", WYRT_PATH,           // add wyrt to whileypath
+ 				filename);             // name of test to compile
+
+ 		if (r != WycMain.SUCCESS) {
+ 			fail("Test failed to compile!");
+ 		} else if (r == WycMain.INTERNAL_FAILURE) {
+ 			fail("Test caused internal failure!");
+ 		}
+
+		String CLASSPATH = CLASSPATH(WHILEY_SRC_DIR, WYJC_CLASS_DIR,
+				WYRL_CLASS_DIR, WYBS_CLASS_DIR);
+
+ 		// Second, execute the generated Java Program.
+ 		String output = TestUtils.execClass(CLASSPATH,WHILEY_SRC_DIR,"wyjc.testing.RuntimeValidTests",name);
+ 		if(!output.equals("")) {
+ 			System.out.println(output);
+ 			fail("unexpected output!");
+ 		}
+ 	}
+
+ 	/**
+	 * This is the entry point for each test. The argument provided is the name
+	 * of the test class. The special method "test" is then invoked on this
+	 * class with no arguments provided. The method should execute without
+	 * producing output (success), or report some kind of runtime fault
+	 * (failure).
+	 * 
+	 * @param args
+	 */
+ 	public static void main(String[] args) {
+ 		String testClassName = args[0]; 		
+ 		try {
+ 			Class testClass = Class.forName(testClassName);
+ 			Method testMethod = testClass.getMethod("test");
+ 			testMethod.invoke(null);
+ 		} catch(ClassNotFoundException e) {
+ 			e.printStackTrace(System.out);
+ 		} catch(NoSuchMethodException e) {
+ 			e.printStackTrace(System.out);
+ 		} catch(InvocationTargetException e) {
+ 			e.printStackTrace(System.out);
+ 		} catch (IllegalAccessException e) {
+			e.printStackTrace(System.out);
+		} 
+ 	}
+ 	
+ 	/**
+	 * Run the Whiley Compiler with the given list of arguments.
+	 *
+	 * @param args
+	 *            --- list of command-line arguments to provide to the Whiley
+	 *            Compiler.
+	 * @return
+	 */
+	public static int compile(String... args) {
+		return new WyjcMain(new WyjcBuildTask(), WyjcMain.DEFAULT_OPTIONS)
+				.run(args);
+	}
+
+	/**
+	 * Construct a classpath string from a sequence of path components. Each
+	 * classpath component is separated by ':' (note that
+	 * <code>TestUtils.exec</code> takes care of platform dependent path
+	 * separators).
+	 *
+	 * @param components
+	 * @return
+	 */
+	public String CLASSPATH(String... components) {
+		String r = "";
+		boolean firstTime = true;
+		for (String c : components) {
+			if (!firstTime) {
+				r = r + ":";
+			}
+			firstTime = false;
+			r = r + c;
+		}
+		return r;
+	}
+	
+	// ======================================================================
+	// Tests
+	// ======================================================================
+
+	// Parameter to test case is the name of the current test.
+	// It will be passed to the constructor by JUnit.
+	private final String testName;
+	public RuntimeValidTests(String testName) {
+		this.testName = testName;
+	}
+
+	// Here we enumerate all available test cases.
+	@Parameters(name = "{0}")
+	public static Collection<Object[]> data() {
+		return TestUtils.findTestNames(WHILEY_SRC_DIR);
+	}
+
+	// Skip ignored tests
+	@Before
+	public void beforeMethod() {
+		String ignored = IGNORED.get(this.testName);
+		Assume.assumeTrue("Test " + this.testName + " skipped: " + ignored, ignored == null);
+	}
+
+	@Test
+	public void valid() throws IOException {
+		runTest(this.testName);
+	}
+}
diff --git a/modules/wyjc/src/wyjc/util/BytecodeTranslators.java b/modules/wyjc/src/wyjc/util/BytecodeTranslators.java
new file mode 100755
index 0000000000..34de509f8f
--- /dev/null
+++ b/modules/wyjc/src/wyjc/util/BytecodeTranslators.java
@@ -0,0 +1,313 @@
+package wyjc.util;
+
+import static jasm.lang.JvmTypes.*;
+import static wyjc.Wyil2JavaBuilder.*;
+import static wyil.lang.Bytecode.*;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import jasm.lang.Bytecode;
+import jasm.lang.JvmType;
+import wycc.util.ResolveError;
+import wyil.lang.SyntaxTree;
+import wyil.lang.SyntaxTree.Location;
+import wyil.lang.Type;
+import wyjc.Wyil2JavaBuilder.BytecodeTranslator;
+import wyjc.Wyil2JavaBuilder.Context;
+
+/**
+ * Provides implementations for the standard internal functions
+ * 
+ * @author David J. Pearce
+ *
+ */
+public class BytecodeTranslators {
+	/**
+	 * The standard functions for use with the interpreter.
+	 */
+	public static final BytecodeTranslator[] standardFunctions = new BytecodeTranslator[255];
+	
+	static {		
+		standardFunctions[OPCODE_neg] = new Negate();
+		standardFunctions[OPCODE_add ] = new Add();
+		standardFunctions[OPCODE_sub ] = new Subtract();
+		standardFunctions[OPCODE_mul ] = new Multiply();
+		standardFunctions[OPCODE_div ] = new Divide();
+		standardFunctions[OPCODE_rem ] = new Remainder();
+		standardFunctions[OPCODE_eq ] = new Equal();
+		standardFunctions[OPCODE_ne ] = new NotEqual();
+		standardFunctions[OPCODE_lt ] = new LessThan();
+		standardFunctions[OPCODE_le ] = new LessThanEqual();
+		standardFunctions[OPCODE_gt ] = new GreaterThan();
+		standardFunctions[OPCODE_ge ] = new GreaterThanEqual();
+		
+		standardFunctions[OPCODE_logicalnot] = new LogicalNot();		
+		standardFunctions[OPCODE_logicalor] = new LogicalOr();
+		standardFunctions[OPCODE_logicaland] = new LogicalAnd();
+		
+		standardFunctions[OPCODE_bitwiseinvert] = new Invert();			
+		standardFunctions[OPCODE_bitwiseor] = new BitwiseOr();
+		standardFunctions[OPCODE_bitwisexor] = new BitwiseXor();
+		standardFunctions[OPCODE_bitwiseand] = new BitwiseAnd();
+		standardFunctions[OPCODE_shl] = new LeftShift();
+		standardFunctions[OPCODE_shr] = new RightShift();
+		
+		standardFunctions[OPCODE_arraylength] = new ArrayLength();			
+		standardFunctions[OPCODE_arrayindex] = new ArrayIndex();	
+		standardFunctions[OPCODE_arraygen] = new ArrayGenerator();
+		
+		standardFunctions[OPCODE_dereference] = new Dereference();		
+		standardFunctions[OPCODE_newobject] = new New();
+		standardFunctions[OPCODE_is] = new Is();	
+	};
+		
+	// ====================================================================================
+	// References
+	// ====================================================================================
+
+	private static final class Dereference implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) throws ResolveError {
+			Location<?> srcOperand = expr.getOperand(0);
+			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Invoke(WHILEYOBJECT, "state", ftype, Bytecode.InvokeMode.VIRTUAL));
+			// finally, we need to cast the object we got back appropriately.
+			Type.Reference pt = context.expandAsReference(srcOperand.getType());
+			context.addReadConversion(pt.element());
+		}		
+	}
+	
+	private static final class New implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) throws ResolveError {
+			Type.Reference refType = context.expandAsReference(expr.getType()); 
+			JvmType elementType = context.toJvmType(refType.element());
+			JvmType.Function ftype = new JvmType.Function(T_VOID, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.New(WHILEYOBJECT));
+			context.add(new Bytecode.DupX1());
+			context.add(new Bytecode.Swap());
+			context.addWriteConversion(refType.element());
+			context.add(new Bytecode.Invoke(WHILEYOBJECT, "<init>", ftype, Bytecode.InvokeMode.SPECIAL));
+		}		
+	}
+	// ====================================================================================
+	// Logical
+	// ====================================================================================
+
+	private static final class LogicalNot implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz) context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type);
+			context.add(new Bytecode.Invoke(type, "not", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class LogicalOr implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke(WHILEYBOOL, "or", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class LogicalAnd implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke(WHILEYBOOL, "and", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	// ====================================================================================
+	// Arithmetic
+	// ====================================================================================
+	
+	private static final class Negate implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz) context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type);
+			context.add(new Bytecode.Invoke(type, "negate", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class Add implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke((JvmType.Clazz) type, "add", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class Subtract implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke((JvmType.Clazz) type, "subtract", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class Multiply implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke((JvmType.Clazz) type, "multiply", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class Divide implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke((JvmType.Clazz) type, "divide", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class Remainder implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke((JvmType.Clazz) type, "remainder", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+
+	private static final class Equal implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "equal", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	private static final class NotEqual implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "notEqual", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	private static final class LessThan implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, WHILEYINT, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "lessThan", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	private static final class LessThanEqual implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, WHILEYINT, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "lessThanEqual", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	private static final class GreaterThan implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, WHILEYINT, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "greaterThan", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	private static final class GreaterThanEqual implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, WHILEYINT, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYUTIL, "greaterThanEqual", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}
+	// ====================================================================================
+	// Bytes
+	// ====================================================================================
+	private static final class Invert implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "compliment", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class BitwiseOr implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "or", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class BitwiseXor implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "xor", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class BitwiseAnd implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, type);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "and", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class LeftShift implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "leftShift", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class RightShift implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Clazz type = (JvmType.Clazz)  context.toJvmType(expr.getType());
+			JvmType.Function ftype = new JvmType.Function(type, WHILEYINT);
+			context.add(new Bytecode.Invoke(WHILEYBYTE, "rightShift", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	// ====================================================================================
+	// Arrays
+	// ====================================================================================
+	private static final class ArrayLength implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYINT);	
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "length", ftype, Bytecode.InvokeMode.VIRTUAL));
+		}		
+	}
+	private static final class ArrayIndex implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) throws ResolveError {
+			Location<?> srcOperand = expr.getOperand(0);
+			Type.EffectiveArray arrType = context.expandAsEffectiveArray(srcOperand.getType());
+			JvmType.Function ftype = new JvmType.Function(JAVA_LANG_OBJECT, WHILEYARRAY, WHILEYINT);	
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "get", ftype, Bytecode.InvokeMode.STATIC));
+			context.addReadConversion(arrType.element());			
+		}		
+	}
+	private static final class ArrayGenerator implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) throws ResolveError {
+			Type.EffectiveArray sourceType = context.expandAsEffectiveArray(expr.getType());
+			Type elementType = sourceType.element();			
+			JvmType.Function ftype = new JvmType.Function(WHILEYARRAY, WHILEYINT, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Swap());
+			context.addWriteConversion(elementType);
+			context.add(new Bytecode.Invoke(WHILEYARRAY, "generate", ftype, Bytecode.InvokeMode.STATIC));
+		}		
+	}	
+	
+	// ====================================================================================
+	// Other
+	// ====================================================================================
+
+	private static final class Is implements BytecodeTranslator {
+		@Override
+		public void translate(Location<Operator> expr, Context context) {
+			JvmType.Function ftype = new JvmType.Function(WHILEYBOOL, JAVA_LANG_OBJECT);
+			context.add(new Bytecode.Swap());
+			context.add(new Bytecode.Invoke(WHILEYTYPE, "is", ftype, Bytecode.InvokeMode.VIRTUAL));		
+		}		
+	}
+	
+}
diff --git a/modules/wyjc/src/wyjc/util/LambdaTemplate.java b/modules/wyjc/src/wyjc/util/LambdaTemplate.java
new file mode 100755
index 0000000000..7cedf9355e
--- /dev/null
+++ b/modules/wyjc/src/wyjc/util/LambdaTemplate.java
@@ -0,0 +1,283 @@
+package wyjc.util;
+
+import static jasm.lang.JvmTypes.JAVA_LANG_OBJECT;
+import static jasm.lang.Modifier.*;
+
+import static wyjc.Wyil2JavaBuilder.JAVA_LANG_OBJECT_ARRAY;
+import static wyjc.Wyil2JavaBuilder.WHILEYLAMBDA;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import jasm.attributes.Code.Handler;
+import jasm.lang.Bytecode;
+import jasm.lang.ClassFile;
+import jasm.lang.JvmType;
+import jasm.lang.JvmTypes;
+import jasm.lang.Modifier;
+import wyjc.Wyil2JavaBuilder;
+
+/**
+ * This is a template for generating a "lambda class", which is used to
+ * represent lambda's in Whiley. The basic form of the generated class is:
+ * 
+ * <pre>
+ * final class NN extends WyLambda {
+ *    private final T1 r1;
+ *    ...
+ *    private final Tn rn;
+ *    
+ *    public NN(T1 r1, ... Tn rn) {
+ *       super();
+ *       this.r1 = r1;
+ *       ...
+ *       this.rn = rn;
+ *    }
+ *    
+ *    public Object call(Object... params) {
+ *      return C.m(params[0], ... params[m], r1, ..., rn);
+ *    }
+ * }
+ * </pre>
+ * 
+ * Here, the fields <code>r1</code> to <code>rn</code> correspond to the
+ * "environment". Those are variables from the enclosing scope which are passed
+ * through to the lambda body. In this case, the body always consists of a
+ * static method call to a given method.
+ * 
+ * @author David J. Pearce
+ *
+ */
+public class LambdaTemplate {
+
+	/**
+	 * JVM Class version number to use (e.g. 49)
+	 */
+	private final int version;
+	
+	/**
+	 * The class that this template will generate
+	 */
+	private final JvmType.Clazz thisClass;	
+	
+	/**
+	 * The enclosing class of the target method. That is the static method which
+	 * will be invoked by this lambda.
+	 */
+	private final JvmType.Clazz targetClass;
+	
+	/**
+	 * The name of the target method.  That is the static method which
+	 * will be invoked by this lambda.
+	 */ 
+	private final String targetMethod;
+	
+	/**
+	 * The type of the target function. This excludes the "environment" which
+	 * will extend the set of concrete parameter types.
+	 */
+	private final JvmType.Function type;
+	
+	/**
+	 * The set of environment variables which will be stored as fields
+	 */
+	private final JvmType[] environment;
+	
+	/**
+	 * Create a given LambdaTemplate with which a special lambda class can be
+	 * constructed.
+	 * 
+	 * @param version
+	 *            JVM Class version number to use (e.g. 49)
+	 * @param thisClass
+	 *            The class that this template will generate
+	 * @param targetClass
+	 *            The enclosing class of the target method. That is the static
+	 *            method which will be invoked by this lambda.
+	 * @param targetMethod
+	 *            The name of the target method. That is the static method which
+	 *            will be invoked by this lambda.
+	 * @param type
+	 *            The type of the target function. This excludes the
+	 *            "environment" which will extend the set of concrete parameter
+	 *            types.
+	 * @param environment
+	 *            The set of environment variables which will be stored as
+	 *            fields
+	 */
+	public LambdaTemplate(int version, JvmType.Clazz thisClass, JvmType.Clazz targetClass, String targetMethod,
+			JvmType.Function type, JvmType... environment) {
+		this.version = version;
+		this.thisClass = thisClass;
+		this.targetClass = targetClass;
+		this.targetMethod = targetMethod;
+		this.type = type;
+		this.environment = environment;
+	}
+	
+	/**
+	 * Generate the lambda class.
+	 * 
+	 * @return
+	 */
+	public ClassFile generateClass() {
+		// Construct empty class
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);
+		ClassFile cf = new ClassFile(version, thisClass, WHILEYLAMBDA, new ArrayList<JvmType.Clazz>(),
+				modifiers);
+		// Add Fields
+		for(int i=0;i!=environment.length;++i) {
+			String name = "r" + i;
+			cf.fields().add(generateField(name,environment[i]));
+		}		
+		// Add Constructor
+		cf.methods().add(generateConstructor());
+		// Add implementation of WyLambda.call(Object[]) ===
+		cf.methods().add(generateCallMethod());
+		// Done
+		return cf;
+	}
+	
+
+	/**
+	 * Build a constructor for a lambda expression. This constructor accepts
+	 * zero or more parameters which constitute the "environment". That is,
+	 * variables from the enclosing scope of the lambda which will be passed
+	 * through and stored in the lambda class itself.
+	 * 
+	 * @return
+	 */
+	private ClassFile.Method generateConstructor() {
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC);
+		JvmType.Function superConstructorType = new JvmType.Function(JvmTypes.T_VOID);
+		JvmType.Function constructorType = new JvmType.Function(JvmTypes.T_VOID, environment);
+		// Create constructor method
+		ClassFile.Method constructor = new ClassFile.Method("<init>", constructorType, modifiers);
+		// Create body of constructor which called super-class constructor, and
+		// assigns each environment parameter to a corresponding field.
+		ArrayList<Bytecode> bytecodes = new ArrayList<Bytecode>();
+		// Call superclass constructor
+		bytecodes.add(new Bytecode.Load(0, thisClass));
+		bytecodes.add(new Bytecode.Invoke(Wyil2JavaBuilder.WHILEYLAMBDA, "<init>", superConstructorType,
+				Bytecode.InvokeMode.SPECIAL));
+		// Assign each parameter to a corresponding named field.
+		for (int i = 0; i != environment.length; ++i) {
+			JvmType fieldType = environment[i];
+			bytecodes.add(new Bytecode.Load(0, thisClass));
+			bytecodes.add(new Bytecode.Load(i + 1, fieldType));
+			bytecodes.add(new Bytecode.PutField(thisClass, "r" + i, fieldType, Bytecode.FieldMode.NONSTATIC));
+		}
+		bytecodes.add(new Bytecode.Return(null));
+		// Add code attribute to constructor
+		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), constructor);
+		constructor.attributes().add(code);
+		//
+		return constructor;
+	}
+	
+
+	/**
+	 * Build a method implementing the body of this lambda. In this case, the
+	 * body consists of invoking a given method in the target class. The
+	 * parameters for the invocation are formed from two sources. First, the
+	 * parameters which are passed in to the call itself as an object array;
+	 * Second, the parameters originally passed to the constructor and now
+	 * stored as fields.
+	 * 
+	 * @param lambdaClassType
+	 * @return
+	 */
+	private ClassFile.Method generateCallMethod() {
+		List<Modifier> modifiers = modifiers(ACC_PUBLIC, ACC_FINAL);		
+		// Create constructor method
+		JvmType.Function callType = new JvmType.Function(JAVA_LANG_OBJECT, JAVA_LANG_OBJECT_ARRAY);
+		ClassFile.Method method = new ClassFile.Method("call", callType, modifiers);
+		// Create body of call method
+		List<Bytecode> bytecodes = new ArrayList<Bytecode>();
+		// Load parameters onto stack from the parameters array
+		decodeLambdaParameterArray(1,type.parameterTypes(),bytecodes);
+		// Load environment onto stack
+		loadEnvironment(bytecodes);
+		// Construct the actual target type
+		ArrayList<JvmType> actualParameterTypes = new ArrayList<JvmType>(type.parameterTypes());
+		actualParameterTypes.addAll(Arrays.asList(environment));
+		JvmType.Function actualType = new JvmType.Function(type.returnType(), actualParameterTypes);
+		// Now, invoke the target method
+		bytecodes.add(new Bytecode.Invoke(targetClass, targetMethod, actualType, Bytecode.InvokeMode.STATIC));
+		// Deal with return values (if applicable)
+		if (type.returnType() instanceof JvmType.Void) {
+			// Called function doesn't return anything, but we have to as the
+			// type of WyLambda.call dictates this. Therefore, push on dummy
+			// null value.
+			bytecodes.add(new Bytecode.LoadConst(null));
+		} 
+		bytecodes.add(new Bytecode.Return(JAVA_LANG_OBJECT));		
+		// Add code attribute to call method
+		jasm.attributes.Code code = new jasm.attributes.Code(bytecodes, new ArrayList<Handler>(), method);
+		method.attributes().add(code);
+		// Done
+		return method;
+	}
+	
+	/**
+	 * Generate a field in which the given environment variable can be stored.
+	 * 
+	 * @param name
+	 * @param type
+	 * @return
+	 */
+	private ClassFile.Field generateField(String name, JvmType type) {
+		List<Modifier> modifiers = modifiers(ACC_PRIVATE, ACC_FINAL);
+		return new ClassFile.Field(name, type, modifiers);
+	}
+	
+	/**
+	 * Given an array of objects, load each element onto the stack in order of
+	 * occurrence and convert them into the appropriate form.
+	 * 
+	 * @param source
+	 *            Source register containing the array
+	 * @param types
+	 *            the target type of each element
+	 * @param bytecodes
+	 */
+	private void decodeLambdaParameterArray(int source, List<JvmType> types, List<Bytecode> bytecodes) {
+		for (int i = 0; i != types.size(); ++i) {
+			bytecodes.add(new Bytecode.Load(source, JAVA_LANG_OBJECT_ARRAY));
+			bytecodes.add(new Bytecode.LoadConst(i));
+			bytecodes.add(new Bytecode.ArrayLoad(JAVA_LANG_OBJECT_ARRAY));
+			bytecodes.add(new Bytecode.CheckCast(types.get(i)));
+		}
+	}
+	
+	/**
+	 * Load each environment variable onto the stack
+	 * 
+	 * @param bytecodes
+	 */
+	private void loadEnvironment(List<Bytecode> bytecodes) {
+		for (int i = 0; i != environment.length; ++i) {
+			String name = "r" + i;
+			bytecodes.add(new Bytecode.Load(0,thisClass));
+			bytecodes.add(new Bytecode.GetField(thisClass, name, environment[i], Bytecode.FieldMode.NONSTATIC));
+		}
+	}
+	
+	/**
+	 * Construct a list of modifiers from an array of (potentially null)
+	 * modifiers.
+	 * 
+	 * @param mods
+	 * @return
+	 */
+	private static List<Modifier> modifiers(Modifier... mods) {
+		ArrayList<Modifier> modifiers = new ArrayList<Modifier>();
+		for (Modifier m : mods) {
+			if (m != null) {
+				modifiers.add(m);
+			}
+		}
+		return modifiers;
+	}
+}
diff --git a/modules/wyjc/src/wyjc/util/WyjcAntTask.java b/modules/wyjc/src/wyjc/util/WyjcAntTask.java
new file mode 100755
index 0000000000..8b609f8324
--- /dev/null
+++ b/modules/wyjc/src/wyjc/util/WyjcAntTask.java
@@ -0,0 +1,62 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package wyjc.util;
+
+import java.io.*;
+import wyc.util.WycAntTask;
+
+/**
+ * An AntTask for compiling JVM Class files from Whiley source files or Wyil
+ * binary files. The following illustrates how this task can be used in a
+ * <code>build.xml</code> file:
+ *
+ * <pre>
+ *  <taskdef name="wyjc" classname="wyjc.util.AntTask" classpath="src/"/>
+ * <wyjc verbose="true" wyildir="stdlib" classdir="src\/" includes="whiley\/**\/*.wyil"/>
+ * </pre>
+ *
+ * <p>
+ * The first line defines the new task, and requires the <code>src/</code>
+ * directory (which contains this class) to be on the classpath; The second
+ * invokes the task to compile all wyil files rooted in the <code>stdlib/</code>
+ * directory which are in the <code>whiley/</code> package.
+ * </p>
+ *
+ * @author David J. Pearce
+ *
+ */
+public class WyjcAntTask extends WycAntTask {
+	private final WyjcBuildTask myBuilder;
+
+	public void setClassdir(File dir) throws IOException {
+		myBuilder.setClassDir(dir);
+	}
+
+	public WyjcAntTask() {
+		super(new WyjcBuildTask());
+		this.myBuilder = (WyjcBuildTask) builder;
+	}
+}
diff --git a/modules/wyjc/src/wyjc/util/WyjcBuildTask.java b/modules/wyjc/src/wyjc/util/WyjcBuildTask.java
new file mode 100755
index 0000000000..7d4e9bcc8f
--- /dev/null
+++ b/modules/wyjc/src/wyjc/util/WyjcBuildTask.java
@@ -0,0 +1,165 @@
+package wyjc.util;
+
+import java.io.*;
+import java.util.List;
+
+import wybs.util.StdBuildRule;
+import wybs.util.StdProject;
+import wycc.util.Logger;
+import wyfs.lang.Content;
+import wyfs.lang.Path;
+import wyfs.util.DirectoryRoot;
+import wyfs.util.VirtualRoot;
+import wyil.lang.WyilFile;
+import wyjc.Wyil2JavaBuilder;
+import jasm.io.ClassFileReader;
+import jasm.io.ClassFileWriter;
+import jasm.io.JasmFileWriter;
+import jasm.lang.ClassFile;
+import jasm.io.ClassFileWriter;
+
+public class WyjcBuildTask extends wyc.util.WycBuildTask {
+
+	// =========================================================================
+	// Content Type
+	// =========================================================================
+
+	public static final Content.Type<ClassFile> ContentType = new Content.Type<ClassFile>() {
+		public Path.Entry<ClassFile> accept(Path.Entry<?> e) {
+			if (e.contentType() == this) {
+				return (Path.Entry<ClassFile>) e;
+			}
+			return null;
+		}
+
+		public ClassFile read(Path.Entry<ClassFile> e, InputStream input)
+				throws IOException {
+			ClassFileReader reader = new ClassFileReader(input);
+			return reader.readClass();
+		}
+
+		public void write(OutputStream output, ClassFile module)
+				throws IOException {
+			ClassFileWriter writer = new ClassFileWriter(output);	
+			writer.write(module);
+		}
+
+		public String toString() {
+			return "Content-Type: class";
+		}
+	};
+
+	// =========================================================================
+	// Registry
+	// =========================================================================
+
+
+	public static class Registry extends wyc.util.WycBuildTask.Registry {
+		public void associate(Path.Entry e) {
+			String suffix = e.suffix();
+
+			if(suffix.equals("class")) {
+				e.associate(ContentType, null);
+			} else {
+				super.associate(e);
+			}
+		}
+
+		public String suffix(Content.Type<?> t) {
+			if(t == ContentType) {
+				return "class";
+			} else {
+				return super.suffix(t);
+			}
+		}
+	}
+
+	/**
+	 * The purpose of the class file filter is simply to ensure only binary
+	 * files are loaded in a given directory root. It is not strictly necessary
+	 * for correct operation, although hopefully it offers some performance
+	 * benefits.
+	 */
+	public static final FileFilter classFileFilter = new FileFilter() {
+		public boolean accept(File f) {
+			String name = f.getName();
+			return name.endsWith(".class") || f.isDirectory();
+		}
+	};
+
+	/**
+	 * The class directory is the filesystem directory where all generated jvm
+	 * class files are stored.
+	 */
+	protected DirectoryRoot classDir;
+
+	public WyjcBuildTask() {
+		super(new Registry());
+	}
+
+	@Override
+	public void setWhileyDir(File dir) throws IOException {
+		// Note, we don't call super.setWhileyDir here as might be expected.
+		// This is because that would set the wyilDir to a matching directory
+		// root. However, for this builder, we don't want to write wyil files by
+		// default.
+		this.whileyDir = new DirectoryRoot(dir, whileyFileFilter, registry);
+		if (classDir == null) {
+			this.classDir = new DirectoryRoot(dir, classFileFilter,
+					registry);
+		}
+	}
+
+	@Override
+	public void setWyilDir(File dir) throws IOException {
+		super.setWyilDir(dir);
+		if (classDir == null) {
+			this.classDir = new DirectoryRoot(dir, classFileFilter,
+					registry);
+		}
+	}
+
+	public void setClassDir(File classdir) throws IOException {
+		this.classDir = new DirectoryRoot(classdir, classFileFilter,
+				registry);
+	}
+
+	@Override
+	protected void addBuildRules(StdProject project) {
+		// Add default build rule for converting whiley files into wyil files.
+		super.addBuildRules(project);
+
+		// Now, add build rule for converting wyil files into class files using
+		// the Wyil2JavaBuilder.
+
+		Wyil2JavaBuilder jbuilder = new Wyil2JavaBuilder(project);
+
+		if (verbose) {
+			jbuilder.setLogger(new Logger.Default(System.err));
+		}
+
+		project.add(new StdBuildRule(jbuilder, wyilDir, wyilIncludes,
+				wyilExcludes, classDir));
+	}
+
+	@Override
+	protected List<Path.Entry<?>> getModifiedSourceFiles() throws IOException {
+		// First, determine all whiley source files which are out-of-date with
+		// respect to their wyil files.
+		List<Path.Entry<?>> sources = super.getModifiedSourceFiles();
+
+		// Second, determine all wyil source files which are out-of-date with
+		// respect to their class files.
+		sources.addAll(super.getModifiedSourceFiles(wyilDir, wyilIncludes,
+				classDir, ContentType));
+
+		return sources;
+	}
+
+	@Override
+	protected void flush() throws IOException {
+		super.flush();
+		classDir.flush();
+	}
+}
+
diff --git a/modules/wyrt/README b/modules/wyrt/README
new file mode 100755
index 0000000000..9812208c05
--- /dev/null
+++ b/modules/wyrt/README
@@ -0,0 +1,39 @@
+======================================================================
+Package Summary
+======================================================================
+
+wyc/ ---- The compiler front-end, including all code for the lexer,
+          the parser, the raw AST, and various tools for instantiating
+          and configuring a Whiley Compiler.
+
+wyil/ --- The Whiley Intermediate Language (wyil).  The Whiley
+          Compiler (wyc) converts Whiley programs into this
+          intermediate language, and then various transforms are
+          applied.  The wyil constitutes a bytecode (similar, in some
+          ways, to Java Bytecode) which can be interpreted and
+          executed on its own (if desired).  This package includes
+          code for performing type checking, constant propagation, and
+          various other manipulations.  Furthermore, all the necessary
+          code for manipulating structural types in Whiley is included
+          here.  In short, this package constitutes the bulk of the
+          compiler.
+
+wyjc/ --- The Whiley-to-Java Compiler.  This extends the Whiley
+          Compiler (wyc) with additional transforms for converting
+          wyil code into Java bytecode.
+
+wyjvm/ -- The Whiley JVM library.  This library is used for generating
+          valid Java bytecode.  It abstracts the various bytecodes and
+          their different forms and takes care of their optimal
+          translation into actual JVM bytecodes.  In addition, it
+          handles various annoying aspects of Java bytecode, such as
+          ensuring wide branches are used when necessary.  Finally,
+          passes are provided for eliminating dead-code and santity
+          checking the generated bytecode.
+
+wyautl/ - The Whiley Automata Library.  This library is used for
+          representing and manipulating finite tree automata.  These
+          automata are used as the underlying representation of types
+          in Whiley, and there are a number of relatively complex
+          algorithms required to manipulate them.  For example, for
+          representing automatas in canonical form.
diff --git a/modules/wyrt/build.xml b/modules/wyrt/build.xml
new file mode 100755
index 0000000000..cae035d071
--- /dev/null
+++ b/modules/wyrt/build.xml
@@ -0,0 +1,72 @@
+<project name="wyrt" default="build">
+
+  <!-- ================================================================== -->
+  <!-- Configuration -->
+  <!-- ================================================================== -->
+  <import file="../../config.xml"/>
+
+  <path id="wyrt.classpath">
+    <pathelement path="${WYBS_DIR}/src"/>
+    <pathelement path="${WYC_DIR}/src"/>
+    <pathelement path="${WYIL_DIR}/src"/>
+    <pathelement path="${WYCS_DIR}/src"/>
+    <pathelement path="{$WYRL_JAR}"/>
+    <path refid="junit.classpath"/>
+  </path>
+
+  <!-- ================================================================== -->
+  <!-- Compile -->
+  <!-- ================================================================== -->
+
+  <target name="compile-wyrt">
+    <taskdef name="wyc" classname="wyc.util.WycAntTask">
+      <classpath>
+	<path refid="wyrt.classpath"/>
+      </classpath>
+    </taskdef>
+    <wyc verbose="false" verificationConditions="false" bootpath="${WYCS_DIR}/stdlib/" whileydir="src" wycsdir="src" includes="whiley/**/*.whiley"/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Test -->
+  <!-- ================================================================== -->
+
+  <target name="test"/>
+
+  <!-- ================================================================== -->
+  <!-- Build -->
+  <!-- ================================================================== -->
+
+  <target name="build" depends="compile-wyrt">
+    <jar destfile="${LIB_DIR}/wyrt-v${version}.jar">
+      <fileset dir="src" includes="*/**/*.wyil"/>
+      <fileset dir="src" includes="*/**/*.wycs"/>
+      <fileset dir="${WYCS_DIR}/stdlib" includes="*/**/*.wycs"/>
+    </jar>
+    <echo message="============================================="/>
+    <echo message="BUILT: lib/${ant.project.name}-v${version}.jar"/>
+    <echo message="============================================="/>
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Dist-->
+  <!-- ================================================================== -->
+  
+  <target name="dist">
+    <!-- this module has no distribution -->
+  </target>
+
+  <!-- ================================================================== -->
+  <!-- Clean -->
+  <!-- ================================================================== -->
+
+  <target name="clean">
+    <delete includeEmptyDirs="true" failonerror="false">
+      <fileset dir="." includes="**/*.wyil,**/*.wyasm"/>
+    </delete>
+    <echo message="============================================="/>
+    <echo message="CLEANED: ${ant.project.name}"/>
+    <echo message="============================================="/>
+  </target>
+  
+</project>
diff --git a/modules/wyrt/src/whiley/io/File.whiley b/modules/wyrt/src/whiley/io/File.whiley
new file mode 100755
index 0000000000..33fe027032
--- /dev/null
+++ b/modules/wyrt/src/whiley/io/File.whiley
@@ -0,0 +1,110 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+package whiley.io
+
+import whiley.io.Reader
+import uint from whiley.lang.Int
+import string from whiley.lang.ASCII
+
+// ====================================================
+// File Reader
+// ====================================================
+public type Reader is  {
+
+    // Read all bytes of this file in one go.
+    method readAll() -> byte[],
+
+    // Reads at most a given number of bytes from the file.  This
+    // operation may block if the number requested is greater than that
+    // available.
+    method read(uint) -> byte[],
+
+    // Check whether the end-of-stream has been reached and, hence,
+    // that there are no further bytes which can be read.
+    method hasMore() -> bool,
+
+    // Closes this file reader thereby releasin any resources
+    // associated with it.
+    method close(),
+
+    // Return the number of bytes which can be safely read without
+    // blocking.
+    method available() -> uint
+}
+
+public method Reader(string fileName) -> Reader:
+    NativeFile reader = NativeFileReader(fileName)
+    return {
+        readAll: &( -> read(reader)),
+        read: &(uint n -> read(reader,n)),
+        hasMore: &( -> hasMore(reader)),
+        close: &( -> close(reader)),
+        available: &( -> available(reader))
+    }
+
+// ====================================================
+// File Writer
+// ====================================================
+type Writer is whiley.io.Writer.Writer
+
+public method Writer(string fileName) -> Writer:
+    NativeFile reader = NativeFileWriter(fileName)
+    return {
+        write: &(byte[] data -> write(reader,data)),
+        close: &( -> close(reader)),
+        flush: &( -> flush(reader))
+    }
+
+// ====================================================
+// Native Implementation
+// ====================================================
+
+// Represents an unknown underlying data structure
+type NativeFile is &any
+
+private native method NativeFileReader(string filename) -> NativeFile
+
+private native method NativeFileWriter(string filename) -> NativeFile
+
+// flush native file
+private native method flush(NativeFile f)
+
+// close native file
+private native method close(NativeFile f)
+
+// determine how many bytes can be read without blocking
+private native method available(NativeFile f) -> uint
+
+// determine whether or not we've reached the end-of-file
+private native method hasMore(NativeFile f) -> bool
+
+// read at most max bytes from native file
+private native method read(NativeFile f, int max) -> byte[]
+
+// read as many bytes as possible from native file
+private native method read(NativeFile f) -> byte[]
+
+// write entire contents of native file
+private native method write(NativeFile f, byte[] data) -> uint
diff --git a/modules/wyrt/src/whiley/io/Reader.whiley b/modules/wyrt/src/whiley/io/Reader.whiley
new file mode 100755
index 0000000000..d4b444e7a5
--- /dev/null
+++ b/modules/wyrt/src/whiley/io/Reader.whiley
@@ -0,0 +1,62 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.io
+
+import uint from whiley.lang.Int
+import string from whiley.lang.ASCII
+
+
+// =================================================================
+// Generic Reader
+// =================================================================
+
+// A generic reader represents an input stream of items (e.g. bytes or
+// characters), such as from a file, network socket, or a memory buffer.
+
+public type Reader is {
+
+    // Reads at most a given number of bytes from the stream.  This
+    // operation may block if the number requested is greater than that
+    // available.
+    method read(uint) -> byte[],
+
+    // Check whether the end-of-stream has been reached and, hence,
+    // that there are no further bytes which can be read.
+    method hasMore() -> bool,
+
+    // Closes this input stream thereby releasin any resources
+    // associated with it.
+    method close(),
+
+    // Return the number of bytes which can be safely read without
+    // blocking.
+    method available() -> uint,
+
+    // Space for additional operations defined by refinements of
+    // Reader
+    ...
+}
+
diff --git a/modules/wyrt/src/whiley/io/Writer.whiley b/modules/wyrt/src/whiley/io/Writer.whiley
new file mode 100755
index 0000000000..d393765d1c
--- /dev/null
+++ b/modules/wyrt/src/whiley/io/Writer.whiley
@@ -0,0 +1,59 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.io
+
+import uint from whiley.lang.Int
+import string from whiley.lang.ASCII
+
+// =================================================================
+// Generic Writer
+// =================================================================
+
+// A generic writer represents an output stream of data items
+// (e.g. bytes or characters), such as being written a file, socket or
+// console.
+public type Writer is {
+
+    // Writes a given list of bytes to the output stream.
+    method write(byte[]) -> uint,
+
+    // Flush this output stream thereby forcing those items written
+    // thus far to the output device.
+    method flush(),
+
+    // Closes this output stream thereby releasin any resources
+    // associated with it.
+    method close(),
+
+    // Space for additional operations defined by refinements of
+    // InputStream
+    ...
+}
+
+
+
+
+
diff --git a/modules/wyrt/src/whiley/lang/ASCII.whiley b/modules/wyrt/src/whiley/lang/ASCII.whiley
new file mode 100755
index 0000000000..55fbb4eeb2
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/ASCII.whiley
@@ -0,0 +1,93 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+// Define the 8bit ASCII character
+public type char is (int x) where 0 <= x && x <= 255
+
+// Define string as sequence of ASCII characters
+public type string is char[]
+
+// Convert an ASCII character into a byte.
+public function toByte(char v) -> byte:
+    //
+    byte mask = 00000001b
+    byte r = 0b
+    int i = 0
+    while i < 8:
+        if (v % 2) == 1:
+            r = r | mask
+        v = v / 2
+        mask = mask << 1
+        i = i + 1
+    return r
+
+// Convert an ASCII string into a list of bytes
+public function toBytes(string s) -> byte[]:
+    byte[] r = [0b; |s|]
+    int i = 0
+    while i < |s| where i >= 0:
+        r[i] = toByte(s[i])
+        i = i + 1
+    return r
+
+// Convert a list of bytes into an ASCII string
+public function fromBytes(byte[] data) -> string:
+    string r = [0; |data|]
+    int i = 0
+    while i < |data| where i >= 0:
+        r[i] = Byte.toInt(data[i])
+        i = i + 1
+    return r
+
+public function append(string s1, string s2) -> string:
+    string s3 = [0; |s1| + |s2|]
+    int i = 0
+    while i < |s3|:
+       if i < |s1|:
+          s3[i] = s1[i]
+       else:
+          s3[i] = s2[i-|s1|]
+       i = i + 1
+    return s3
+
+public function isUpperCase(char c) -> bool:
+    return 'A' <= c && c <= 'Z'
+
+public function isLowerCase(char c) -> bool:
+    return 'a' <= c && c <= 'z'
+
+public function isLetter(char c) -> bool:
+    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
+
+public function isDigit(char c) -> bool:
+    return '0' <= c && c <= '9'
+
+public function isWhiteSpace(char c) -> bool:
+    return c == ' ' || c == '\t' || c == '\n' || c == '\r'
+
+
+
diff --git a/modules/wyrt/src/whiley/lang/Any.whiley b/modules/wyrt/src/whiley/lang/Any.whiley
new file mode 100755
index 0000000000..be462e1c5e
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Any.whiley
@@ -0,0 +1,29 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+public native function toString(any item) -> ASCII.string
+
diff --git a/modules/wyrt/src/whiley/lang/Array.whiley b/modules/wyrt/src/whiley/lang/Array.whiley
new file mode 100755
index 0000000000..13d1f30a51
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Array.whiley
@@ -0,0 +1,274 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+// Resize an array to a given size
+public function resize(int[] items, int size, int element) -> (int[] result)
+// Required size cannot be negative
+requires size >= 0
+// Returned array is of specified size
+ensures |result| == size
+// If array is enlarged, the all elements up to new size match
+ensures all { i in 0 .. |items| | i >= size || result[i] == items[i] }
+// All new elements match given element
+ensures all { i in |items| .. size | result[i] == element}:
+    //
+    int[] nitems = [element; size]
+    int i = 0
+    while i < size && i < |items|
+    where i >= 0 && |nitems| == size
+    // All elements up to i match as before
+    where all { j in 0..i | nitems[j] == items[j] }
+    // All elements about size match element
+    where all { j in |items| .. size | nitems[j] == element}:
+        //
+        nitems[i] = items[i]
+        i = i + 1
+    //
+    return nitems
+
+// find first index in list which matches character.  If no match,
+// then return null.
+public function indexOf(int[] items, int item) -> (int|null index)
+// If int returned, element at this position matches item
+ensures index is int ==> items[index] == item
+// If int returned, element at this position is first match
+ensures index is int ==> all { i in 0 .. index | items[i] != item }
+// If null returned, no element in items matches item
+ensures index is null ==> all { i in 0 .. |items| | items[i] != item }:
+    //
+    return indexOf(items,item,0)
+
+// find first index after a given start point in list which matches character.
+// If no match, then return null.
+public function indexOf(int[] items, int item, int start) -> (int|null index)
+// Starting point cannot be negative
+requires start >= 0
+// If int returned, element at this position matches item
+ensures index is int ==> items[index] == item
+// If int returned, element at this position is first match
+ensures index is int ==> all { i in start .. index | items[i] != item }
+// If null returned, no element in items matches item
+ensures index is null ==> all { i in start .. |items| | items[i] != item }:
+    //
+    int i = start
+    //
+    while i < |items|
+    // i is positive
+    where i >= 0
+    // No element seen so far matches item
+    where all { j in start .. i | items[j] != item }:
+        //
+        if items[i] == item:
+            return i
+        i = i + 1
+    //
+    return null
+
+// find last index in list which matches character.  If no match,
+// then return null.
+public function lastIndexOf(int[] items, int item) -> (int|null index)
+// If int returned, element at this position matches item
+ensures index is int ==> items[index] == item
+// If int returned, element at this position is last match
+ensures index is int ==> all { i in (index+1) .. |items| | items[i] != item }
+// If null returned, no element in items matches item
+ensures index is null ==> all { i in 0 .. |items| | items[i] != item }:
+    //
+    int i = |items|
+    //
+    while i > 0
+    where i <= |items|
+    // No element seen so far matches item
+    where all { j in i..|items| | items[j] != item }:
+        //
+        i = i - 1
+        if items[i] == item:
+            return i
+    //
+    return null
+
+// replace all occurrences of "old" with "new" in list "items".
+public function replace(int[] items, int old, int n) -> (int[] r)
+// Every position in items matching old replaced with n
+ensures all { i in 0..|items| | (items[i] == old) ==> r[i] == n }
+// Every other position remains the same
+ensures all { i in 0..|items| | (items[i] != old) ==> r[i] == items[i] }
+// Size of resulting array remains the same
+ensures |items| == |r|:
+    //
+    int i = 0
+    int[] oldItems = items // ghost
+    //
+    while i < |items|
+    where i >= 0 && |items| == |oldItems|
+    where all { k in 0..i | (oldItems[k] == old) ==> (items[k] == n) }
+    where all { k in 0..|items| | (oldItems[k] != old) ==> (items[k] == oldItems[k]) }:
+        if oldItems[i] == old:
+            items[i] = n
+        i = i + 1
+    //
+    return items
+
+// Extract slice of items array between start and up to (but not including) end.
+public function slice(int[] items, int start, int end) -> (int[] r)
+// Given region to slice must make sense
+requires start >= 0 && start <= end && end <= |items|
+// Size of slice determined by difference between start and end
+ensures |r| == (end - start)
+// Items returned in slice match those in region from start
+ensures all { i in 0..|r| | items[i+start] == r[i] }:
+    //
+    int[] nitems = [0; end-start]
+    int i = 0
+    //
+    while i < |nitems|
+    where i >= 0 && |nitems| == (end-start)
+    where all { k in 0..i | nitems[k] == items[k+start] }:
+        nitems[i] = items[i+start]
+        i = i + 1
+    //
+    return nitems
+
+public function append(int[] lhs, int[] rhs) -> int[]:
+    int[] rs = [0; |lhs| + |rhs|]
+    int i = |lhs|
+    //
+    while i > 0:
+        i = i - 1
+        rs[i] = lhs[i]
+    //
+    while i < |rhs|:
+        rs[i+|lhs|] = rhs[i]
+        i = i + 1
+    //
+    return rs
+
+public function append(int[] items, int item) -> (int[] r)
+// Every item from original array is retained
+ensures all { k in 0..|items| | r[k] == items[k] }
+// Last item in result matches item appended
+ensures r[|items|] == item
+// Size of array is one larger than original
+ensures |r| == |items|+1:
+    //
+    int[] nitems = [0; |items| + 1]
+    int i = 0
+    //
+    while i < |items| 
+    where i >= 0 && i <= |items| && |nitems| == |items|+1
+    where all { k in 0..i | nitems[k] == items[k] }:
+        nitems[i] = items[i]
+        i = i + 1
+    //
+    nitems[i] = item    
+    //
+    return nitems
+
+public function append(int item, int[] items) -> (int[] r)
+// Every item from original array is retained
+ensures all { k in 0..|items| | r[k+1] == items[k] }
+// First item in result matches item appended
+ensures r[0] == item
+// Size of array is one larger than original
+ensures |r| == |items|+1:
+    //
+    int[] nitems = [0; |items| + 1]
+    int i = 0
+    //
+    while i < |items| 
+    where i >= 0 && i <= |items| && |nitems| == |items|+1
+    where all { k in 0..i | nitems[k+1] == items[k] }:
+        nitems[i+1] = items[i]
+        i = i + 1
+    //
+    nitems[0] = item    
+    //
+    return nitems
+
+public function append(bool[] lhs, bool[] rhs) -> bool[]:
+    bool[] rs = [false; |lhs| + |rhs|]
+    int i = |lhs|
+    //
+    while i > 0:
+        i = i - 1
+        rs[i] = lhs[i]
+    //
+    while i < |rhs|:
+        rs[i+|lhs|] = rhs[i]
+        i = i + 1
+    //
+    return rs
+
+public function append(bool[] items, bool item) -> bool[]:
+    bool[] nitems = [false; |items| + 1]
+    int i = 0
+    //
+    while i < |items|:
+        nitems[i] = items[i]
+        i = i + 1
+    //
+    nitems[i] = item    
+    //
+    return nitems
+
+public function append(bool item, bool[] items) -> bool[]:
+    bool[] nitems = [false; |items| + 1]
+    int i = 0
+    //
+    while i < |items|:
+        nitems[i+1] = items[i]
+        i = i + 1
+    //
+    nitems[0] = item    
+    //
+    return nitems
+
+public function copy(int[] src, int srcStart, int[] dest, int destStart, int length) -> (int[] result)
+// Source array must contain enough elements to be copied
+requires (srcStart + length) <= |src|
+// Destination array must have enough space for copied elements
+requires (destStart + length) <= |dest|
+// Result is same size as dest
+ensures |result| == |dest|
+// All elements before copied region are same
+ensures all { i in 0 .. destStart | dest[i] == result[i] }
+// All elements in copied region match src
+ensures all { i in 0 .. length | dest[i+destStart] == src[i+srcStart] }
+// All elements above copied region are same
+ensures all { i in (destStart+length) .. |dest| | dest[i] == result[i] }:
+    //
+    int i = srcStart
+    int j = destStart
+    int srcEnd = srcStart + length
+    //
+    while i < srcEnd:
+        dest[j] = src[i]
+        i = i + 1
+        j = j + 1
+    //
+    return dest
+
diff --git a/modules/wyrt/src/whiley/lang/Byte.whiley b/modules/wyrt/src/whiley/lang/Byte.whiley
new file mode 100755
index 0000000000..cb88327f24
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Byte.whiley
@@ -0,0 +1,100 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+import string from whiley.lang.ASCII
+import uint from whiley.lang.Int
+
+// convert a byte into a string
+public function toString(byte b) -> string:
+    string r = [0; 'b']
+    int i = 0
+    while i < 8:
+        if (b & 00000001b) == 00000001b:
+            r[7-i] = '1'
+        else:
+            r[7-i] = '0'
+        b = b >> 1
+        i = i + 1
+    return r
+
+// Convert a byte into an unsigned int.  This assumes a little endian
+// encoding.
+public function toUnsignedInt(byte b) -> uint:
+    int r = 0
+    int base = 1
+    while b != 0b:
+        if (b & 00000001b) == 00000001b:
+            r = r + base
+        b = b >> 1
+        base = base * 2
+    return r
+
+// Convert a byte array into an unsigned int assuming a little endian
+// form for both individual bytes, and the array as a whole
+public function toUnsignedInt(byte[] bytes) -> uint:
+    int val = 0
+    int base = 1
+    int i = 0
+    while i < |bytes|:
+        int v = toUnsignedInt(bytes[i]) * base
+        val = val + v
+        base = base * 256
+        i = i + 1
+    return val
+
+// Convert a byte into an unsigned int.  This assumes a little endian
+// encoding.
+public function toInt(byte b) -> int:
+    int r = 0
+    int base = 1
+    while b != 0b:
+        if (b & 00000001b) == 00000001b:
+            r = r + base
+        b = b >> 1
+        base = base * 2
+    // finally, add the sign
+    if r >= 128:
+        return -(256-r)
+    else:
+        return r
+
+// Convert a byte array into a signed int assuming a little endian
+// form for both individual bytes, and the array as a whole
+public function toInt(byte[] bytes) -> int:
+    int val = 0
+    int base = 1
+    int i = 0
+    while i < |bytes|:
+        int v = toUnsignedInt(bytes[i]) * base
+        val = val + v
+        base = base * 256
+        i = i + 1
+    // finally, add the sign
+    if val >= (base/2):
+        return -(base-val)
+    else:
+        return val
diff --git a/modules/wyrt/src/whiley/lang/Int.whiley b/modules/wyrt/src/whiley/lang/Int.whiley
new file mode 100755
index 0000000000..4d9dc7767f
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Int.whiley
@@ -0,0 +1,200 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+import string from whiley.lang.ASCII
+import char from whiley.lang.ASCII
+
+/**
+ * Represents all signed integers representable in 8bits
+ * of space in the two's complement representation.
+ */
+public type i8 is (int x)
+    where x >=-128 && x <= 127
+
+/**
+ * Represents all signed integers representable in 16bits
+ * of space in the two's complement representation.
+ */
+public type i16 is (int x)
+    where x >=-32768 && x <= 32768
+
+/**
+ * Represents all signed integers representable in 32bits
+ * of space in the two's complement representation.
+ */
+public type i32 is (int x)
+    where x >=-2147483648 && x <= 2147483647
+
+/**
+ * Represents all signed integers representable in 64bits
+ * of space in the two's complement representation.
+ */
+public type i64 is (int x)
+    where x >= -9223372036854775808 && x <= 9223372036854775807
+
+/**
+ * Represents all unsigned integers representable in 8bits
+ * of space.
+ */
+public type u8 is (int x)
+    where x >=0 && x <= 255
+
+/**
+ * Represents all unsigned integers representable in 16bits
+ * of space.
+ */
+public type u16 is (int x)
+    where x >= 0 && x <= 65535
+
+/**
+ * Represents all unsigned integers representable in 32bits
+ * of space.
+ */
+public type u32 is (int x)
+    where x >= 0 && x <= 4294967295
+
+/**
+ * Represents all unsigned integers representable in 64bits
+ * of space.
+ */
+public type u64 is (int x)
+    where x >= 0 && x <= 18446744073709551615
+
+/**
+ * Represents all possible unsigned integers.
+ */
+public type uint is (int x) where x >= 0
+
+public type nat is (int x) where x >= 0
+
+constant digits is [
+    '0','1','2','3','4','5','6','7','8','9',
+    'a','b','c','d','e','f','g','h'
+]
+
+public function toString(int item) -> string:
+    return Any.toString(item)
+
+// Convert an integer into a hex string
+public function toHexString(int item) -> string:
+    string r = ""
+    int count = 0
+    int i = item
+    while i > 0:
+        int v = i / 16
+        int w = i % 16
+        count = count + 1
+        i = v
+    //
+    i = count
+    while item > 0:
+        i = i - 1    
+        int v = item / 16
+        int w = item % 16
+        r[i] = digits[w]
+        item = v
+    //
+    return r
+
+// convert an integer into an unsigned byte
+public function toUnsignedByte(u8 v) -> byte:
+    //
+    byte mask = 00000001b
+    byte r = 0b
+    int i = 0
+    while i < 8:
+        if (v % 2) == 1:
+            r = r | mask
+        v = v / 2
+        mask = mask << 1
+        i = i + 1
+    return r
+
+// convert an arbitrary sized unsigned integer into a list of bytes in
+// little endian form.
+// public function toUnsignedBytes(uint v) -> [byte]:
+//     //
+//     [byte] bytes = []
+//     // do-while is needed here
+//     byte r = 0b
+//     byte mask = 00000001b
+//     int i = 0
+//     while i < 8:
+//         if (v % 2) == 1:
+//             r = r | mask
+//         v = v / 2
+//         mask = mask << 1
+//         i = i + 1
+//     bytes = bytes ++ [r]
+//     while v > 0:
+//         r = 0b
+//         mask = 00000001b
+//         int j = 0
+//         while j < 8:
+//             if (v % 2) == 1:
+//                 r = r | mask
+//             v = v / 2
+//             mask = mask << 1
+//             j = j + 1
+//         bytes = bytes ++ [r]
+//     return bytes
+
+// Convert a signed integer into a single byte
+public function toSignedByte(i8 v) -> byte:
+    //
+    if v < 0:
+        v = v + 256
+    return Int.toUnsignedByte(v)
+
+// parse a string representation of an integer value
+public function parse(string input) -> int|null:
+    //
+    // first, check for negative number
+    int start = 0
+    bool negative
+
+    if input[0] == '-':
+        negative = true
+        start = start + 1
+    else:
+        negative = false
+    // now, parse remaining digits
+    int r = 0
+    int i = start
+    while i < |input|:
+        char c = input[i]
+        r = r * 10
+        if !ASCII.isDigit(c):
+            return null
+        r = r + ((int) c - '0')
+        i = i + 1
+    // done
+    if negative:
+        return -r
+    else:
+        return r
+
diff --git a/modules/wyrt/src/whiley/lang/Math.whiley b/modules/wyrt/src/whiley/lang/Math.whiley
new file mode 100755
index 0000000000..950396e1e5
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Math.whiley
@@ -0,0 +1,95 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+/**
+ * Return absolute value of integer variable.
+ */
+public function abs(int x) -> (int r)
+// if input positive, then result equals input
+ensures x >= 0 ==> r == x
+// if input negative, then result equals negated input
+ensures x < 0 ==> r == -x:
+    //
+    if x < 0:
+        return -x
+    else:
+        return x
+
+/**
+ * Return maximum of two integer variables
+ */
+public function max(int a, int b) -> (int r)
+// Return cannot be smaller than either parameter
+ensures r >= a && r >= b
+// Return value must equal one parameter
+ensures r == a || r == b:
+    //
+    if a < b:
+        return b
+    else:
+        return a
+
+/**
+ * Return minimum of two integer variables
+ */
+public function min(int a, int b) -> (int r)
+// Return cannot be greater than either parameter
+ensures r <= a && r <= b
+// Return value must equal one parameter
+ensures r == a || r == b:
+    //
+    if a > b:
+        return b
+    else:
+        return a
+
+/**
+ * Return integer value raised to a given power.
+ */
+public function pow(int base, int exponent) -> int
+// Exponent cannot be negative
+requires exponent > 0:
+    //
+    int r = 1
+    int i = 0
+    while i < exponent:
+        r = r * base
+        i = i + 1
+    return r
+
+// Based on an excellent article entitled "Integer Square Roots"
+// by Jack W. Crenshaw, published in the eetimes, 1998.
+public function isqrt(int x) -> (int r)
+requires x >= 0
+ensures r >= 0:
+    //
+    int square = 1
+    int delta = 3
+    while square <= x:
+        square = square + delta
+        delta = delta + 2
+    return (delta/2) - 1
\ No newline at end of file
diff --git a/modules/wyrt/src/whiley/lang/Stack.whiley b/modules/wyrt/src/whiley/lang/Stack.whiley
new file mode 100755
index 0000000000..7351c97d88
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/Stack.whiley
@@ -0,0 +1,66 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+public type Stack is {
+    int[] items,
+    int length
+}
+
+public function create(int max) -> Stack:
+    return {
+        items: [0; max],
+        length: 0
+    }
+
+public function size(Stack stack) -> int:
+    return stack.length
+
+/**
+ * Return the top element of the "stack".
+ */
+public function top(Stack stack) -> int:
+    //
+    return stack.items[stack.length-1]
+
+
+/**
+ * Push an element onto the "stack".
+ */
+public function push(Stack stack, int element) -> (Stack r):
+    //
+    stack.items[stack.length] = element
+    stack.length = stack.length + 1
+    return stack
+
+/**
+ * Pop an element off the "stack".
+ */
+public function pop(Stack stack) -> (Stack r):
+    //
+    stack.length = stack.length - 1
+    //
+    return stack
diff --git a/modules/wyrt/src/whiley/lang/System.whiley b/modules/wyrt/src/whiley/lang/System.whiley
new file mode 100755
index 0000000000..eb8d75ae7d
--- /dev/null
+++ b/modules/wyrt/src/whiley/lang/System.whiley
@@ -0,0 +1,38 @@
+// Copyright (c) 2011, David J. Pearce (djp@ecs.vuw.ac.nz)
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//    * Redistributions of source code must retain the above copyright
+//      notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+//    * Neither the name of the <organization> nor the
+//      names of its contributors may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL DAVID J. PEARCE BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+package whiley.lang
+
+public type PrintWriter is {
+    method print(any),
+    method println(any),
+    method print_s(ASCII.string),
+    method println_s(ASCII.string)
+}
+
+public type Console is {
+    PrintWriter out,
+    ASCII.string[] args
+}
