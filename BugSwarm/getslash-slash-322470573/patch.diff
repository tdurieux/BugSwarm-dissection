diff --git a/.coveragerc b/.coveragerc
new file mode 100755
index 0000000000..bf2b9b77e5
--- /dev/null
+++ b/.coveragerc
@@ -0,0 +1,18 @@
+[run]
+source = slash
+
+[report]
+omit = 
+    slash/_compat.py
+    slash/utils/interactive.py
+    slash/plugins/builtin/notifications.py
+# Regexes for lines to exclude from consideration
+exclude_lines =
+    # Have to re-enable the standard pragma
+    pragma: no cover
+
+    # Don't complain about missing debug-only code:
+    def __repr__
+
+    # Don't complain if non-runnable code isn't run:
+    if __name__ == .__main__.:
diff --git a/.gitattributes b/.gitattributes
new file mode 100755
index 0000000000..22c0097c34
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1 @@
+/doc/changelog.rst merge=union
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
new file mode 100755
index 0000000000..f6273b9cac
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,17 @@
+*.pyc
+.vagrant
+*.egg-info
+.eggs
+build
+.tox
+flycheck-*
+flycheck_*
+dist
+.coverage
+.env
+htmlcov
+.DS_Store
+TAGS
+.envrc
+TAGS
+.cache
diff --git a/.pylintrc b/.pylintrc
new file mode 100755
index 0000000000..8790a2b916
--- /dev/null
+++ b/.pylintrc
@@ -0,0 +1,8 @@
+[MESSAGES CONTROL]
+disable= R,attribute-defined-outside-init,bad-continuation,bad-option-value,bare-except,invalid-name,locally-disabled,missing-docstring,redefined-builtin,ungrouped-imports,wrong-import-order,wrong-import-position
+
+[REPORTS]
+reports=no
+
+[FORMAT]
+max-line-length=150
diff --git a/.travis.yml b/.travis.yml
new file mode 100755
index 0000000000..6a4ab364e0
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,12 @@
+addons: {}
+after_failure: [.env/bin/pip freeze]
+after_success: [codecov]
+dist: trusty
+group: stable
+install: [pip install virtualenv==15.1.0, pip install codecov==2.0.10]
+language: python
+os: linux
+python: '3.5'
+script: [make env, make test, 'if [[ $TRAVIS_PYTHON_VERSION == ''3.6'' ]]; then make
+    pylint; fi']
+sudo: false
diff --git a/LICENSE b/LICENSE
new file mode 100755
index 0000000000..dca18e9d75
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,47 @@
+License
+=======
+Copyright (c) 2013, 2014, 2015, Rotem Yaari <vmalloc@gmail.com>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of organization nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY Rotem Yaari ''AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL Rotem Yaari BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Attributions
+============
+
+Bootstrap Theme for Sphinx
+--------------------------
+Licensed by Ryan Roemer (BSD-3). See https://github.com/ryan-roemer/sphinx-bootstrap-theme
+
+ipdb
+----
+ipdb is not a formal dependency of slash, and it can function without it. If it exists and is importable, it is used for debugging with the --pdb flag.
+
+ipdb is licensed under GPLv2 (https://github.com/gotcha/ipdb/blob/master/COPYING.txt)
+
+IPython
+-------
+IPython is not a formal dependency of slash. If it exists and is importable, it is used in the interactive mode as the interactive prompt.
+
+IPython is licensed under the revised BSD license (https://github.com/ipython/ipython/blob/master/COPYING.txt)
+
+
diff --git a/MANIFEST.in b/MANIFEST.in
new file mode 100755
index 0000000000..1412412804
--- /dev/null
+++ b/MANIFEST.in
@@ -0,0 +1 @@
+include MANIFEST.in tests/* tox.ini travis_build.py .pylintrc
\ No newline at end of file
diff --git a/Makefile b/Makefile
new file mode 100755
index 0000000000..a5fb536586
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,25 @@
+default: test
+
+detox-test:
+	detox
+
+test: env
+	.env/bin/py.test --cov=slash --cov-report=html tests
+
+pylint: env
+	.env/bin/pylint -j 4 --rcfile=.pylintrc slash tests setup.py
+
+env: .env/.up-to-date
+
+.env/.up-to-date: setup.py Makefile
+	python -m virtualenv .env
+	.env/bin/pip install -e .[testing] -r doc/pip_requirements.txt
+	touch .env/.up-to-date
+
+doc: env
+	.env/bin/sphinx-build -a -E doc build/sphinx/html
+
+.PHONY: doc
+
+release: test
+	python scripts/make_release.py
diff --git a/README.md b/README.md
new file mode 100755
index 0000000000..343aa27f8c
--- /dev/null
+++ b/README.md
@@ -0,0 +1,19 @@
+Slash
+=====
+
+
+|                       |                                                                                    |
+|-----------------------|------------------------------------------------------------------------------------|
+| Build Status          | ![Build Status](https://secure.travis-ci.org/getslash/slash.png?branch=master,dev) |
+| Supported Versions    | ![Supported Versions](https://img.shields.io/badge/python-2.7%2C3.3%2C3.4%2C3.5-green.svg)    |
+| Latest Version        | ![Latest Version](https://img.shields.io/pypi/v/slash.svg)                  |
+| Test Coverage         | ![Coverage Status](https://img.shields.io/coveralls/getslash/slash/develop.svg)   |
+
+
+
+
+Slash is a testing framework written in Python for testing complex projects. 
+
+* [Homepage](http://getslash.github.io/slash)
+
+* [Documentation](https://slash.readthedocs.org/)
diff --git a/doc/_static/slash-logo.png b/doc/_static/slash-logo.png
new file mode 100755
index 0000000000..ddb5bbacad
Binary files /dev/null and b/doc/_static/slash-logo.png differ
diff --git a/doc/advanced_usage.rst b/doc/advanced_usage.rst
new file mode 100755
index 0000000000..de36f4b41e
--- /dev/null
+++ b/doc/advanced_usage.rst
@@ -0,0 +1,116 @@
+.. _advanced:
+
+Advanced Use Cases
+==================
+
+Customizing via Setuptools Entry Points
+---------------------------------------
+
+Slash can be customized globally, meaning anyone who will run ``slash run`` or similar commands will automatically get a customized version of Slash. This is not always what you want, but it may still come in handy.
+
+To do this we write our own customization function (like we did in `the section about customization <customize>`):
+
+.. code-block:: python
+
+ def cool_customization_logic():
+     ... # install plugins here, change configuration, etc...
+
+
+To let slash load our customization on startup, we'll use a feature of ``setuptools`` called *entry points*. This lets us register specific functions in "slots", to be read by other packages. We'll append the following to our ``setup.py`` file:
+
+.. code-block:: python
+
+ # setup.py
+ 
+ ...
+ setup(...
+    # ...
+    entry_points = {
+        "slash.site.customize": [
+            "cool_customization_logic = my_package:cool_customization_logic"
+            ]
+        },
+    # ...
+ )
+
+.. note:: You can read more about setuptools entry points `here <http://stackoverflow.com/questions/774824/explain-python-entry-points>`_.
+
+Now Slash will call our customize function when loading.
+
+
+Loading and Running Tests in Code
+---------------------------------
+
+Sometimes you would like to run a sequence of tests that you control in fine detail, like checking various properties of a test before it is being loaded and run. This can be done in many ways, but the easiest is to use the test loader explicitly. 
+
+Running your Tests
+~~~~~~~~~~~~~~~~~~
+
+.. code-block:: python
+
+ import slash
+ from slash.loader import Loader
+
+ if __name__ == "__main__":
+     with slash.Session() as session:
+         tests = Loader().get_runnables(["/my_path", ...])
+         with session.get_started_context():
+             slash.run_tests(tests)
+
+The parameter given above to :func:`slash.runner.run_tests` is merely an iterator yielding runnable tests. You can interfere or skip specific tests quite easily:
+
+.. code-block:: python
+
+ import slash
+ ...
+ def _filter_tests(iterator):
+     for test in iterator:
+          if "forbidden" in test.__slash__.file_path:
+              continue
+          yield test
+
+ ...
+     slash.run_tests(_filter_tests(slash.loader.Loader().get_runnables(...)))
+
+
+Analyzing Results
+~~~~~~~~~~~~~~~~~
+
+Once you run your tests, you can examine the results through :class:`session.results <slash.core.result.SessionResults>`:
+
+.. code-block:: python
+       
+  if not session.results.is_success(allow_skips=False):
+      print('Some tests did not succeed')
+
+Iterating over test results can be done with :func:`slash.core.result.SessionResults.iter_test_results`:
+
+.. code-block:: python
+       
+  for result in session.results.iter_test_results():
+      print('Result for', result.test_metadata.name)
+      print(result.is_success())
+      for error in result.get_errors():
+          ...
+
+For errors and failures, you can examine each of them using the methods and properties offered by :class:`slash.core.error.Error`.
+
+
+.. seealso:: :ref:`Test Metadata <test_metadata>`
+
+.. seealso:: :ref:`customizing`
+
+Specifying Default Test Source for ``slash run``
+------------------------------------------------
+
+.. _default_test_source:
+
+
+If you use ``slash run`` for running your tests, it is often useful to specify a default for the test path to run. This is useful if you want to provide a sane default running environment for your users via a ``.slashrc`` file. This can be done with the :ref:`conf.run.default_sources` configuration option:
+
+.. code-block:: python
+
+    # ...
+    slash.config.root.run.default_sources = ["/my/default/path/to/tests"]
+
+
diff --git a/doc/api.rst b/doc/api.rst
new file mode 100755
index 0000000000..8b56788795
--- /dev/null
+++ b/doc/api.rst
@@ -0,0 +1,154 @@
+API Documentation
+=================
+
+Testing Utilities
+-----------------
+
+.. autoclass:: slash.Test
+  :members:
+
+.. autofunction:: slash.parametrize
+
+.. autofunction:: slash.core.fixtures.parameters.toggle
+
+.. autofunction:: slash.core.fixtures.parameters.iterate
+
+.. autofunction:: slash.abstract_test_class
+
+
+Assertions
+----------
+
+.. autofunction:: slash.assert_raises
+
+.. autofunction:: slash.assert_almost_equal
+
+Cleanups
+--------
+
+.. autofunction:: slash.add_cleanup
+
+.. autofunction:: slash.add_critical_cleanup
+
+.. autofunction:: slash.add_success_only_cleanup
+
+Skips
+-----
+
+.. autoclass:: slash.exceptions.SkipTest
+
+.. autofunction:: slash.skipped
+
+.. autofunction:: slash.skip_test
+
+.. autofunction:: slash.register_skip_exception
+
+Tags
+----
+
+.. autofunction:: slash.tag
+
+Fixtures
+--------
+
+.. autofunction:: slash.fixture
+
+.. autofunction:: slash.yield_fixture
+
+.. autofunction:: slash.generator_fixture
+
+.. autofunction:: slash.nofixtures()
+
+.. autofunction:: slash.use
+
+
+Requirements
+------------
+
+.. autofunction:: slash.requires
+
+Warnings
+--------
+
+
+.. autoclass:: slash.warnings.SessionWarnings
+  :members:
+  :special-members: 
+
+
+Hooks
+-----
+
+.. automodule:: slash.hooks
+  :members:
+
+
+Plugins
+-------
+
+
+.. autofunction:: slash.plugins.active
+
+.. autofunction:: slash.plugins.registers_on
+
+.. autofunction:: slash.plugins.register_if
+
+.. autoclass:: slash.plugins.PluginInterface
+  :members:
+
+.. autoclass:: slash.plugins.PluginManager
+  :members:
+
+
+Logging
+-------
+
+.. automodule:: slash.log
+  :members:
+
+Exceptions
+----------
+
+.. autofunction:: slash.exception_handling.handling_exceptions
+
+.. autofunction:: slash.allowing_exceptions
+
+.. autofunction:: slash.exception_handling.mark_exception
+.. autofunction:: slash.exception_handling.get_exception_mark
+
+
+.. autofunction:: slash.exception_handling.noswallow
+.. autofunction:: slash.exception_handling.mark_exception_fatal
+.. autofunction:: slash.exception_handling.get_exception_swallowing_context
+.. autofunction:: slash.exception_handling.inhibit_unhandled_exception_traceback
+
+
+Misc. Utilities
+---------------
+
+.. autofunction:: slash.repeat
+
+
+Internals
+---------
+
+.. automodule:: slash.core.session
+  :members:
+
+.. automodule:: slash.runner
+  :members:
+
+.. autoclass:: slash.core.metadata.Metadata
+  :members:
+
+.. autoclass:: slash.core.error.Error
+  :members:
+
+.. autoclass:: slash.core.result.Result
+  :members:
+
+.. autoclass:: slash.core.result.SessionResults
+  :members:
+
+.. autoclass:: slash.core.details.Details
+  :members:
diff --git a/doc/builtin_plugins.rst b/doc/builtin_plugins.rst
new file mode 100755
index 0000000000..37394be230
--- /dev/null
+++ b/doc/builtin_plugins.rst
@@ -0,0 +1,51 @@
+Built-in Plugins
+================
+
+Slash comes with pre-installed, built-in plugins that can be activated when needed.
+
+Coverage
+--------
+
+This plugins tracks and reports runtime code coverage during runs, and reports the results in various formats. It uses the Net Batchelder's `coverage package <https://coverage.readthedocs.io/en/>`_.
+
+To use it, run Slash with ``--with-coverage``, and optionally specify modules to cover::
+
+  $ slash run --with-coverage --cov mypackage --cov-report html
+
+Notifications
+-------------
+
+The notifications plugin allows users to be notified when sessions end in various methods, or notification mediums.
+
+To use it, run Slash with ``--with-notifications``. Please notice that each notification type requires additional configuration values. You will also have to enable your desired backend with ``--notify-<backend name>`` (e.g. ``--notify-email``)
+
+For e-mail notification, you'll need to configure your SMTP server, and pass the recipients using ``--email-to``::
+
+  $ slash run --notify-email --with-notifications -o plugin_config.notifications.email.smtp_server='my-smtp-server.com --email-to youremail@company.com'
+
+For using Slack notification, you should firstly configure `slack webhook integration <https://api.slack.com/incoming-webhooks>`_. And run slash::
+
+  $ slash run --with-notifications -o plugin_config.notifications.slack.url='your-webhook-ingetration-url' -o plugin_config.notifications.slack.channel='@myslackuser'
+
+Including Details in Notifications
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. index::
+   pair: notification; details
+
+You can include additional information in your notifications, which is then sent as a part of email messages you receive. This can be done with the ``prepare_notification`` hook:
+
+.. code-block:: python
+
+       @slash.hooks.prepare_notification.register
+       def prepare_notification(message):
+           message.details_dict['additional_information'] = 'some information included'
+
+XUnit
+-----
+
+The xUnit plugin outputs an XML file when sessions finish running. The XML conforms to the xunit format, and thus can be read and processed by third party tools (like CI services, for example)
+
+Use it by running with ``--with-xunit`` and by specifying the output filename with ``--xunit-filename``::
+
+  $ slash run --with-xunit --xunit-filename xunit.xml
diff --git a/doc/changelog.rst b/doc/changelog.rst
new file mode 100755
index 0000000000..46bcc616f7
--- /dev/null
+++ b/doc/changelog.rst
@@ -0,0 +1,326 @@
+Changelog
+=========
+
+* :feature:`-` Error objects now have their respective ``exc_info`` attribute containing the exception info for the current info (if available). This deprecates the use of the ``locals``/``globals`` attributes on traceback frames.
+* :feature:`-` During the execution of ``error_added`` hooks, traceback frame objects now have ``python_frame``, containing the original Pythonic frame that yielded them. Those are cleared soon after the hook is called.
+* :feature:`-` Suite files can now have a ``repeat: X`` marker to make the test run multiple times (Thanks @pierreluctg!)
+* :bug:`671 major` Help for ``slash resume`` is now more helpful
+* :feature:`685` use.X is now a shortcut for use('x') for fixture annotations
+* :feature:`692` Enhance errors summary log to session highlights log (configuration changed: ``log.errors_subpath`` -> ``log.highlights_subpath``)
+* :feature:`658` Deprecate ``PluginInterface.get_config()`` and rename it to ``PluginInterface.get_default_config()``
+* :bug:`- major` Fix tests loading order for some FS types
+* :feature:`689` Added a new hook, ``interruption_added``, for registering exceptions which cause test/session interruptions
+* :feature:`686` ``assert_raises`` raises ``ExpectedExceptionNotCaught`` if exception wasn't caught also allowing inspection of the expected exception object
+* :bug:`684 major` Optimize test loading with ``--repeat-each`` and ``--repeat-all``
+* :bug:`679 major` Fix coloring console for non TTY stdout
+* :feature:`675` Emit native python warnings for logbook warning level
+* :feature:`661` Support PDB notifications by notifications plugin
+* :feature:`660` Add configuration for notifications plugin ``--notify-only-on-failure``
+* :feature:`662` Change email notification icon based on session success status
+* :release:`1.4.6 <3-12-2017>`
+* :bug:`701` Fixed error in coverage reporter cleanup
+* :bug:`700` Fixed handling of non-exception errors in session scope
+* :release:`1.4.3 <14-9-2017>`
+* :bug:`670` Improve handling of interruption exceptions - custom interruption exceptions will now properly cause the session and test to trigger the ``session_interrupt`` and ``test_interrupt`` hooks. Unexpected exceptions like ``SystemExit`` from within tests are now also reported properly instead of silently ignored
+* :bug:`668` Properly initialize colorama under Windows
+* :bug:`665` Support overriding notifications plugin's ``from_email`` by configuration
+* :release:`1.4.2 <13-8-2017>`
+* :bug:`-` Add ``current_config`` property to plugins
+* :release:`1.4.1 <9-8-2017>`
+* :bug:`-` Add ability to include details in email notifications
+* :bug:`-` Restore default enabled state for Prowl/NMA/Pushbullet notifications
+* :release:`1.4.0 <8-8-2017>`
+* :feature:`-` Added new hook ``prepare_notification`` to process notifications before being sent by the notifications plugin
+* :feature:`662` Improve notifications plugin, add support for email notifications
+* :feature:`651` Add ``host_fqdn`` and ``host_name`` attributes to session
+* :feature:`647` Support internal plugins
+* :feature:`647` Support installing plugins as "internal" -- thus not letting users disable or enable them through the command line
+* :release:`1.3.0 <24-07-2017>`
+* :feature:`213` Added parallel execution capability (still considered experimental) - tests can be run in parallel by multiple subprocess "workers". See `the documentation <http://slash.readthedocs.io/en/master/parallel.html>`_ for more information
+* :feature:`596` Slash now supports a flag to disable assertion introspection on assertions containing messages (``run.message_assertion_introspection``)
+* :feature:`642` Support multiple registrations on the same plugin method with ``plugins.registers_on``
+* :feature:`617` Support ``inhibit_unhandled_exception_traceback``
+* :feature:`635` ``slash run`` now supports ``--force-color``/``--no-color`` flags.
+* :feature:`633` When using the `handling_exceptions`, it is now possible to obtain the exception object that was handled
+* :feature:`-` Added ``SLASH_USER_SETTINGS=x`` environment variable to give a possibility to override the user slashrc file
+* :feature:`592` Added ``exception_attributes`` dict to ``Error`` objects
+* :feature:`600` Use `vintage` package for deprecations
+* :feature:`595` Add `allowing_exceptions` context letting tests allow specific exceptions in selective context
+* :bug:`606 major` Swallow python warnings during ast.parse
+* :feature:`-` Added ``session.results.has_fatal_errors`` to check for fatal errors within a session
+* :feature:`-` Slash now detects test functions being redefined, hiding previous tests, and warns about it
+* :feature:`556` Long variable representations are now capped by default when distilling tracebacks
+* :feature:`-` Assertions coming from plugins and modules loaded from the project's ``.slashrc`` now also have assertion rewriting introspection enabled
+* :bug:`- major` Honor run.default_sources configuration when using slash list (thanks Pierre-Luc Tessier Gagné)
+* :bug:`- major` Several Windows-specific fixes (thanks Pierre-Luc Tessier Gagné)
+* :release:`1.2.5 <19-06-2017>`
+* :bug:`-` Add exception_str shortcut for future compatibility on error objects
+* :release:`1.2.4 <19-06-2017>`
+* :bug:`581` Fix ``slash.exclude`` to work across fixture namespaces
+* :bug:`580` ``tests_loaded`` hooks now get called with a list of tests including the interactive test if applicable
+* :release:`1.2.2 <29-05-2017>`
+* :bug:`564` Fix test collection bug causing tests to not be loaded with some plugins
+* :release:`1.2.0 <30-04-2017>`
+* :bug:`551 major` Fix stopping on error behavior when errors are reported on previous tests
+* :feature:`529` Switch to PBR
+* :feature:`508` Added optional ``end_message`` argument to ``notify_if_slow_context``, allowing better verbosity of long operations
+* :bug:`490 major` Fixed behavior of plugin dependencies in cases involving mixed usage of plugin-level and hook-level dependencies
+* :feature:`544` Added ``debug.debugger`` configuration to enable specifying preferred debugger. You can now pass ``-o debug.debugger=ipdb`` to prefer ipdb over pudb, for example
+* :feature:`476` ``slash resume`` was greatly improved, and can now also fetch resumed tests from a recorded session in Backslash, if its plugin is configured
+* :feature:`524` ``slash list``, ``slash list-config`` and ``slash list-plugins`` now supports ``--force-color``/``--no-color`` flags. The default changed from colored to colored only for tty
+* :bug:`516 major` Fire test_interrupt earlier and properly mark session as interrupted when a test is interrupted
+* :feature:`513` Add deep parametrization info (including nested fixtures) to the metadata variation info
+* :feature:`512` ``slash list-config`` now receives a path filter for config paths to display
+* :feature:`519` Add ``--no-output`` flag for ``slash list``
+* :feature:`497` Major overhaul of CLI mechanics -- improve help message and usage, as well as cleaner error exits during the session configuration phase
+* :feature:`467` Yield fixtures are now automatically detected by Slash -- using ``yield_fixture`` explicitly is no longer required
+* :feature:`507` Test id can now be obtained via ``slash.context.test.id``
+* :bug:`510 major` Explicitly fail fixtures which name is valid for tests (currently: ``test_`` prefix)
+* :feature:`511` Support adding external logs ``Result.add_extra_log_path`` which will be retrieved by ``Result.get_log_paths()``
+* :feature:`502` Added ``session_interrupt`` hook for when sessions are interrupted
+* :release:`1.1.0 <22-11-2016>`
+* :feature:`485` xunit plugin now saves the run results even when the session doesn't end gracefully (Thanks @eplaut)
+* :feature:`369` Add ``slash.exclude`` to only skip specific parametrizations of a specific test or a dependent fixture. See `the cookbook section <http://slash.readthedocs.io/en/master/parameters.html#excluding-parameter-values>`_ for more details
+* :bug:`483 major` Properly handle possible exceptions when examining traceback object attributes
+* :feature:`484` ``slash list`` now indicates fixtures that are overriding outer fixtures (e.g. from ``slashconf.py``)
+* :feature:`417` ``add_error``/``add_failure`` can now receive both message and exc_info information
+* :feature:`359` Add trace logging of fixture values, including dependent fixtures
+* :feature:`362` Add ability to intervene during test loading and change run order. This is done with a new ``tests_loaded`` hook and a new field in the test metadata controlling the sort order. See `the cookbook <http://slash.readthedocs.io/en/master/cookbook.html#controlling-test-execution-order>`_ for more details
+* :feature:`352` Suite files can now contain filters on specific items via a comment beginning with ``filter:``, e.g. ``/path/to/test.py # filter: x and not y``
+* :feature:`287` Add support for "facts" in test results, intended for coverage reports over relatively narrow sets of values (like OS, product configuration etc.)
+* :feature:`195` Added ``this.test_start`` and ``this.test_end`` to enable fixture-specific test start and end hooks while they're active
+* :feature:`384` Accumulate logs in the configuration phase of sessions and emit them to the session log. Until now this happened before logging gets configured so the logs would get lost
+* :feature:`400` ``slash.skipped`` decorator is now implemented through the requirements mechanism. This saves a lot of time in unnecessary setup, and allows multiple skips to be assigned to a single test
+* :feature:`462` Add ``log.errors_subpath`` to enable log files only recording added errors and failures.
+* :feature:`403` add ``slash list-plugins`` to show available plugins and related information
+* :feature:`461` ``yield_fixture`` now honors the ``scope`` argument
+* :feature:`468` Slash now detects tests that accidentally contain ``yield`` statements and fails accordingly
+* :bug:`479 major` When installing and activating plugins and activation fails due to incompatibility, the erroneous plugins are now automatically uninstalled
+* :bug:`477 major` Fix assert_raises with message for un-raised exceptions
+* :bug:`464 major` Fix exc_info leaks outside of ``assert_raises`` & ``handling_exceptions``
+* :feature:`-` Added the ``entering_debugger`` hook to be called before actually entering a debugger
+* :feature:`344` Exceptions recorded with ``handling_exceptions`` context now properly report the stack frames above the call
+* :feature:`466` Add --relative-paths flag to ``slash list``
+* :release:`1.0.2 <19-10-2016>`
+* :bug:`481` Fixed tuple parameters for fixtures
+* :release:`1.0.1 <07-08-2016>`
+* :bug:`464` Fix reraising behavior from handling_exceptions
+* :bug:`457` Fixed initialization order for *autouse* fixtures
+* :release:`1.0.0 <26-06-2016>`
+* :feature:`447` Added a more stable sorting logic for cartesian products of parametrizations
+* :feature:`446` Exception tracebacks now include instance attributes to make debugging easier
+* :feature:`397` Native Python warnings are now captured during testing sessions
+* :feature:`407` Added ``--repeat-all`` option for repeating the entire suite several times
+* :feature:`276` Added support for fixture aliases using ``slash.use``
+* :feature:`439` Added support ``yield_fixture``
+* :bug:`442 major` Prevent ``session_end`` from being called when ``session_start`` doesn't complete successfully
+* :feature:`441` ``variation`` in test metadata now contains both ``id`` and ``values``. The former is a unique identification of the test variation, whereas the latter contains the actual fixture/parameter values when the test is run
+* :feature:`401` session_end no longer called on plugins when session_start isn't called (e.g. due to errors with other plugins)
+* :feature:`423` Added support for generator fixtures
+* :feature:`437` Added ``test_avoided`` hook to be called when tests are completely skipped (e.g. requirements)
+* :feature:`424` slash internal app context can now be instructed to avoid reporting to console (use ``report=False``)
+* :feature:`436` ``slash list`` now fails by default if no tests are listed. This can be overriden by specifying ``--allow-empty``
+* :feature:`435` Added ``swallow_types`` argument to exception_handling context to enable selective swallowing of specific exceptions
+* :feature:`430` Added coverage plugin to generate code coverage report at the end of the run (``--with-coverage``)
+* :feature:`428` Requirements using functions can now have these functions return tuples of (fullfilled, requirement_message) specifying the requirement message to display
+* :feature:`427` Drop support for Python 2.6
+* :feature:`416` Add --no-params for "slash list"
+* :feature:`413` Test names inside files are now sorted
+* :feature:`412` Add is_in_test_code to traceback json
+* :release:`0.20.2 <03-04-2016>`
+* :bug:`434` Fixed a bug where class names were not deduced properly when loading tests
+* :bug:`432` Fixed a bug where session cleanups happened before ``test_end`` hooks are fired
+* :release:`0.20.1 <01-03-2016>`
+* :bug:`410` Fixed bug causing incorrect test frame highlighting in tracebacks
+* :bug:`409` Improve session startup/shutdown logic to avoid several potentially invalid states
+* :release:`0.20.0 <02-02-2016>`
+* :bug:`408 major` Fix handling of cleanups registered from within cleanups
+* :bug:`406 major` Fix error reporting for session scoped cleanups
+* :feature:`348` Color test code differently when displaying tracebacks
+* :bug:`402 major` TerminatedException now causes interactive sessions to terminate
+* :feature:`405` Add ``--show-tags`` flag to ``slash list``
+* :feature:`388` ``-k`` can now be specified multiple times, implying AND relationship
+* :feature:`381` ``handling_exceptions`` now doesn't handle exceptions which are currently expected by ``assert_raises``
+* :feature:`398` Allow specifying exc_info for add_error
+* :feature:`395` Add __slash__.variation, enabling investigation of exact parametrization of tests
+* :feature:`391` Add result.details, giving more options to adding/appending test details
+* :feature:`386` Make slash list support -f and other configuration parameters
+* :feature:`385` Add test details to xunit plugin output
+* :feature:`379` Allow exception marks to be used on both exception classes and exception values
+* :feature:`339` Errors in interactive session (but not ones originating from IPython input itself) are now recorded as test errors
+* :release:`0.19.6 <01-12-2015>`
+* :bug:`-` Minor fixes
+* :release:`0.19.5 <01-12-2015>`
+* :bug:`390` Fix handling of add_failure and add_error with message strings in xunit plugin
+* :release:`0.19.5 <25-11-2015>`
+* :bug:`389` Fix deduction of function names for parametrized tests
+* :release:`0.19.3 <05-11-2015>`
+* :bug:`383` Fix fixture passing to ``before`` and ``after``
+* :release:`0.19.2 <13-10-2015>`
+* :bug:`376` Fix xunit bug when using skip decorators without reasons
+* :release:`0.19.1 <01-10-2015>`
+* :bug:`374` Fix issue with xunit plugin
+* :release:`0.19.0 <30-09-2015>`
+* :bug:`373 major` Fix test collection progress when outputting to non-ttys
+* :feature:`361` Demote slash logs to TRACE level
+* :feature:`368` add slash list-config command
+* :feature:`366` Added ``activate_later`` and ``deactivate_later`` to the plugin manager, allowing plugins to be collected into a 'pending activation' set, later activated with ``activate_pending_plugins``
+* :feature:`366` ``--with-X`` and ``--without-X`` don't immediately activate plugins, but rather use ``activate_later`` / ``deactivate_later``
+* :feature:`366` Added ``configure`` hook which is called after command-line processing but before plugin activation
+* :feature:`371` Add warning_added hook
+* :feature:`349` Plugin configuration is now installed in the installation phase, not activation phase
+* :release:`0.18.2 <30-09-2015>`
+* :bug:`372` Fixed logbook compatibility issue
+* :release:`0.18.1 <11-08-2015>`
+* :bug:`350` Fixed scope mismatch bug when hooks raise exceptions
+* :release:`0.18.0 <02-08-2015>`
+* :feature:`347` Add slash.context.fixture to point at the 'this' variable of the currently computing fixture
+* :feature:`335` Add 'needs' and 'provides' to plugins, to provide fine-grained flow control over plugin calling
+* :feature:`321` add Error.mark_fatal() to enable calls to mark_fatal right after add_error
+* :feature:`295` SIGTERM handling for stopping sessions gracefully
+* :feature:`279` Add option to silence manual add_error tracebacks (``-o show_manual_errors_tb=no``)
+* :bug:`341 major` Make sure tests are garbage collected after running
+* :feature:`233` slash.parametrize: allow argument tuples to be specified
+* :feature:`337` Set tb level to 2 by default
+* :feature:`333` Allow customization of console colors
+* :feature:`332` Add ability to filter by test tags - you can now filter with ``-k tag:sometag``, ``-k sometag=2`` and ``-k "not sometag=3"``
+* :feature:`240` Add support for test tags
+* :feature:`324` Add test for cleanups with fatal exceptions
+* :bug:`329 major` handling_exceptions(swallow=True) now does not swallow SkipTest exceptions
+* :bug:`322 major` Refactored a great deal of the test running logic for easier maintenance and better solve some corner cases
+* :bug:`322 major` Fix behavior of skips thrown from cleanup callbacks
+* :bug:`320 major` Fix scope mechanism to allow cleanups to be added from test_start hooks
+* :feature:`319` Add class_name metadata property for method tests
+* :release:`0.17.0 <29-06-2015>`
+* :feature:`314` Added :func:`Session.get_total_num_tests <slash.core.session.Session.get_total_num_tests>` for returning the number of tests expected to run in a session
+* :feature:`312` Add before_session_start hook
+* :feature:`311` Support plugin methods avoiding hook registrations with ``registers_on(None)``
+* :feature:`308` Support registering private methods in plugins using ``registers_on``
+* :release:`0.16.1 <17-06-2015>`
+* :bug:`-` fix strict emport dependency
+* :release:`0.16.0 <20-05-2015>`
+* :feature:`307` Interactive test is now a first-class test and allows any operation that is allowed from within a regular test
+* :feature:`306` Allow class variables in plugins
+* :feature:`300` Add `log.unified_session_log` flag to make session log contain all logs from all tests
+* :release:`0.15.0 <28-04-2015>`
+* :feature:`289` Added ``get_config`` optional method to plugins, allowing them to supplement configuration to ``config.root.plugin_config.<plugin_name>``
+* :feature:`282` Better handling of fixture dependency cycles
+* :feature:`286` Better handling of unrun tests when using `x` or similar. Count of unrun tests is now reported instead of detailed console line for each unrun test.
+* :feature:`267` Scoped cleanups: associate errors in cleanups to their respective result object. This means that errors can be added to tests after they finish from now on.
+* :feature:`170` Add optional ``scope`` argument to ``add_cleanup``, controlling when the cleanup should take place
+* :feature:`280` Add optional message argument to ``assert_raises``
+* :feature:`274` Add optional separation between console log format and file log format
+* :feature:`275` Add get_no_deprecations_context to disable deprecation messages temporarily
+* :feature:`271` Add passthrough_types=TYPES parameter to handling_exceptions context
+* :release:`0.14.3 <31-03-2015>`
+* :bug:`288` Fixed accidental log file line truncation
+* :release:`0.14.2 <29-03-2015>`
+* :bug:`285` Fixed representation of fixture values that should not be printable (strings with slashes, for instance)
+* :release:`0.14.1 <04-03-2015>`
+* :bug:`270` Fixed handling of directory names and class/method names in suite files
+* :release:`0.14.0 <03-03-2015>`
+* :feature:`269` Add option to specify suite files within suite files
+* :feature:`268` Treat relative paths listed in suite files (-f) relative to the file's location
+* :feature:`-` start_interactive_shell now automatically adds the contents of slash.g to the interactive namespace
+* :feature:`257` ``slash fixtures`` is now ``slash list``, and learned the ability to list both fixtures and tests
+* :feature:`263` Support writing colors to log files
+* :feature:`264` Allow specifying location of .slashrc via configuration
+* :release:`0.13.0 <22-02-2015>`
+* :feature:`261` Added a traceback to manually added errors (throush ``slash.add_error`` and friends)
+* :feature:`258` Added ``hooks.error_added``, a hook that is called when an error is added to a test result or to a global result. Also works when errors are added after the test has ended.
+* :feature:`140` Added ``--repeat-each`` command line argument to repeat each test multiple times
+* :feature:`249` Added @slash.repeat decorator to repeat tests multiple times
+* :feature:`-` Slash now emits a console message when session_start handlers take too long
+* :release:`0.12.0 <01-02-2015>`
+* :feature:`177` Added 'slash fixtures' command line utility to list available fixtures
+* :feature:`-` Add ``slash.session.reporter.report_fancy_message``
+* :release:`0.11.0 <06-01-2015>`
+* :feature:`226` Implemented ``slash.hooks.before_test_cleanups``.
+* :feature:`220` ``slash.add_cleanup`` no longer receives arbitrary positional args or keyword args. The old form is still allowed for now but issues a deprecation warning.
+* :feature:`211` Added ``log.last_session_dir_symlink`` to create symlinks to log directory of the last run session
+* :release:`0.10.0 <15-12-2014>`
+* :feature:`214` Added ``slash.nofixtures`` decorator to opt out of automatic fixture deduction.
+* :feature:`16` Added ``slash.requires`` decorator to formally specify test requirements
+* :feature:`209` Test cleanups are now called before fixture cleanups
+* :feature:`203` Group result output by tests, not by error type
+* :feature:`199` A separate configuration for traceback verbosity level (``log.traceback_level``, also controlled via ``--tb=[0-5]``)
+* :feature:`196` Add 'slash version' to display current version
+* :feature:`189` add add_success_only_cleanup
+* :release:`0.9.3 <1-12-2014>`
+* :bug:`204` Fixed a console formatting issue causing empty lines to be emitted without reason
+* :release:`0.9.2 <24-11-2014>`
+* :bug:`198` fix test_methodname accidentally starting with a dot
+* :release:`0.9.1 <30-10-2014>`
+* :release:`0.9.0 <30-10-2014>`
+* :feature:`194` add assert_almost_equal
+* :feature:`190` Support __slash__.test_index0 and __slash__.test_index1 for easier enumeration in logs
+* :feature:`179` Documentation overhaul
+* :feature:`183` Add slash.parameters.toggle as a shortcut for iterating ``[True, False]``
+* :release:`0.8.0 <12-10-2014>`
+* :feature:`127` py.test style fixture support, major overhaul of tests and loading code.
+* :feature:`-` removed the test contexts facility introduced in earlier versions. The implementation was partial and had serious drawbacks, and is inferior to fixtures.
+* :feature:`167` Fixed erroneous behavior in which skipped tasks after using ``-x`` caused log symlinks to move
+* :feature:`159` Add optional 'last failed' symlink to point to last failed test log
+* :feature:`163` Added ``-k`` for selecting tests by substrings
+* :feature:`162` Test loading and other setup operations now happen before ``session_start``, causing faster failing on simple errors
+* :feature:`-` Log symlinks can now be relative paths (considrered relative to the logging root directory)
+* :feature:`160` Add option to serialize warnings to dicts
+* :release:`0.7.2 <21-08-2014>`
+* :feature:`171` Add error times to console reports
+* :release:`0.7.1 <14-07-2014>`
+* :bug:`-` Fixed error summary reporting
+* :release:`0.7.0 <07-07-2014>`
+* :feature:`153` Report warnings at the end of sessions
+* :feature:`152` Truncate long log lines in the console output
+* :feature:`148` Detailed tracebacks now emitted to log file
+* :feature:`-` Renamed ``debug_hooks`` to ``debug_hook_handlers``. Debugging hook handlers will only trigger for slash hooks.
+* :feature:`137` Fixed parameter iteration across inheritence trees
+* :feature:`150` Add log links to results when reporting to console
+* :feature:`145` Add option to save symlinks to the last session log and last test log
+* :feature:`146` Add test id and error/failure enumeration in test details
+* :feature:`149` Make console logs interact nicely with the console reporter non-log output
+* :feature:`144` Add option to colorize console logs in custom colors
+* :release:`0.6.1 <27-05-2014>`
+* :bug:`142` Allow registering plugin methods on custom hooks
+* :bug:`143` Use gossip's inernal handler exception hook to debug hook failures when ``--pdb`` is used
+* :release:`0.6.0 <21-05-2014>`
+* :feature:`-` Added assertion introspection via AST rewrite, borrowed from `pytest <http://pytest.org>`_.
+* :feature:`138` Move to `gossip <http://gossip.readthedocs.org>`_ as hook framework.
+* :feature:`141` Add slash.utils.deprecated to mark internal facilities bound for removal
+* :feature:`129` Overhaul rerunning logic (now called 'resume')
+* :feature:`128` Slash now loads tests eagerly, failing earlier for bad imports etc. This might change in the future to be an opt-out behavior (change back to lazy loading)
+* :feature:`-` Overhaul the reporting mechanism, make output more similar to py.test's, including better error reporting.
+* :release:`0.5.0 <09-04-2014>`
+* :feature:`132` Support for providing hook requirements to help resolving callback order (useful on initialization)
+* :release:`0.4.2 <19-01-2014>`
+* :release:`0.4.1 <19-01-2014>`
+* :release:`0.4.0 <15-12-2013>`
+* :feature:`114` Support for fatal exception marks
+* :feature:`116` Support '-f' to specify one or more files containing lists of files to run
+* :feature:`121` Support 'append' for CLI arguments deduced from config
+* :feature:`120` Support multiple exception types in should.raise_exception
+* :release:`0.3.1 <20-11-2013>`
+* :feature:`115` Add session.logging.extra_handlers to enable adding custom handlers to tests and the session itself
+* :release:`0.3.0 <18-11-2013>`
+* :feature:`113` Add option to debug hook exceptions (-o debug.debug_hooks=yes)
+* :release:`0.2.0 <20-10-2013>`
+* :feature:`103` Add context.test_filename, context.test_classname, context.test_methodname
+* :feature:`96` Add option to specify logging format
+* :feature:`19` Add ability to add non-exception errors and failures to test results
+* :release:`0.1.0 <3-9-2013>`
+* :feature:`45` Add option for specifying default tests to run
+* :feature:`74` Enable local .slashrc file
+* :feature:`72` Clarify errors in plugins section
+* :feature:`26` Support test rerunning via "slash rerun"
+* :feature:`-` Coverage via coveralls
+* :feature:`-` Documentation additions and enhancements
+* :feature:`69` Move slash.session to slash.core.session. slash.session is now the session context proxy, as documented
+* :feature:`-` Add should.be_empty, should.not_be_empty
+* :feature:`75` Support matching by parameters in FQN, Support running specific or partial tests via FQN
+* :release:`0.0.2 <7-7-2013>`
+* :feature:`46`: Added plugin.activate() to provide plugins with the ability to control what happens upon activation
+* :feature:`40`: Added test context support - you can now decorate tests to provide externally implemented contexts for more flexible setups
+* :feature:`-` Renamed slash.fixture to slash.g (fixture is an overloaded term that will maybe refer to test contexts down the road)
+* :feature:`48`, #54: handle import errors and improve captured exceptions
+* :feature:`3` Handle KeyboardInterrupts (quit fast), added the test_interrupt hook
+* :feature:`5` add_critical_cleanup for adding cleanups that are always called (even on interruptions)
diff --git a/doc/conf.py b/doc/conf.py
new file mode 100755
index 0000000000..d9027d88df
--- /dev/null
+++ b/doc/conf.py
@@ -0,0 +1,263 @@
+# -*- coding: utf-8 -*-
+#
+# Slash documentation build configuration file, created by
+# sphinx-quickstart on Fri Feb 22 23:34:56 2013.
+#
+# This file is execfile()d with the current directory set to its containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys, os, ast
+import pkg_resources
+
+nitpicky = True
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration -----------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be extensions
+# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
+sys.path.insert(0, os.path.dirname(__file__))
+extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode', 'config_doc', 'hook_list_doc', 'releases', 'alabaster']
+
+releases_issue_uri = "https://github.com/getslash/slash/issues/%s"
+releases_release_uri = "https://github.com/getslash/slash/tree/%s"
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix of source filenames.
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'Slash'
+copyright = u'2013, Rotem Yaari'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+
+version = release = pkg_resources.get_distribution('slash').version
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+
+# -- Options for HTML output ---------------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+import alabaster
+
+html_theme_path = [alabaster.get_path()]
+
+html_theme = 'alabaster'
+html_theme_options = {
+    'logo': 'slash-logo.png',
+    'github_user': 'getslash',
+    'github_repo': 'slash',
+    'github_button': True,
+    'github_banner': True,
+    'travis_button': 'getslash/slash',
+    'analytics_id': 'UA-62537825-1',
+    'extra_nav_links': {
+        'Slash Website': 'http://getslash.github.io',
+        'Slash@Github': 'https://github.com/getslash/slash',
+        'Slash@Pypi': 'https://pypi.python.org/pypi/slash',
+    }
+}
+html_sidebars = {
+   '**': [
+       'about.html', 'navigation.html', 'searchbox.html', 'donate.html',
+   ]
+}
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = [os.path.join(os.path.dirname(__file__), "_static")]
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'Slashdoc'
+
+
+# -- Options for LaTeX output --------------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass [howto/manual]).
+latex_documents = [
+  ('index', 'Slash.tex', u'Slash Documentation',
+   u'Rotem Yaari', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output --------------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    ('index', 'slash', u'Slash Documentation',
+     [u'Rotem Yaari'], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output ------------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  ('index', 'Slash', u'Slash Documentation',
+   u'Rotem Yaari', 'Slash', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
diff --git a/doc/config_doc.py b/doc/config_doc.py
new file mode 100755
index 0000000000..d18b324648
--- /dev/null
+++ b/doc/config_doc.py
@@ -0,0 +1,24 @@
+from docutils.parsers.rst import directives, Directive
+from docutils import nodes
+from slash.conf import config
+
+
+class ConfigDoc(Directive):
+    required_arguments = 0
+    optional_arguments = 0
+
+    def run(self):
+        returned = []
+        for path, leaf in config.traverse_leaves():
+            section = nodes.section(names=["conf." + path])
+            self.state.document.note_explicit_target(section)
+            section.append(nodes.title(text=path))
+            section.append(nodes.strong(text="Default: {0}".format(leaf.get_value())))
+            if leaf.metadata and "doc" in leaf.metadata:
+                section.append(nodes.paragraph(text=str(leaf.metadata["doc"])))
+            returned.append(section)
+        return returned
+
+
+def setup(app):                 # pylint: disable=unused-argument
+    directives.register_directive('config_doc', ConfigDoc)
diff --git a/doc/configuration.rst b/doc/configuration.rst
new file mode 100755
index 0000000000..3d563cec19
--- /dev/null
+++ b/doc/configuration.rst
@@ -0,0 +1,48 @@
+.. _configuration:
+
+Configuration
+=============
+
+Slash uses a hierarchical configuration structure provided by `Confetti <https://github.com/vmalloc/confetti>`_. The configuration values are addressed by their full path (e.g. ``debug.enabled``, meaning the value called 'enabled' under the branch 'debug').
+
+.. note:: You can inspect the current paths, defaults and docs for Slash's configuration via the ``slash list-config`` command from your shell
+
+Several ways exist to modify configuration values.
+
+Overriding Configuration Values via Command-Line
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+When running tests via ``slash run``, you can use the ``-o`` flag to override configuration values::
+
+    $ slash run -o hooks.swallow_exceptions=yes ...
+
+.. note:: Configuration values get automatically converted to their respective types. More specifically, boolean values also recognize ``yes`` and ``no`` as valid values.
+
+Customization Files
+~~~~~~~~~~~~~~~~~~~
+
+There are several locations in which you can store files that are to be automatically executed by Slash when it runs. These files can contain code that overrides configuration values:
+
+**slashrc file**
+  If the file ``~/.slash/slashrc`` (See :ref:`conf.run.user_customization_file_path`) exists, it is loaded and executed as a regular Python file by Slash on startup.
+
+**SLASH_USER_SETTINGS**
+  If an environment variable named ``SLASH_USER_SETTINGS`` exists, the file path it points to will be loaded *instead* of the slashrc file.
+
+**SLASH_SETTINGS**
+  If an environment variable named ``SLASH_SETTINGS`` exists, it is assumed to point at a file path or URL to load as a regular Python file on startup.
+
+Each of these files can contain code which, among other things, can modify Slash's configuration. The configuration object is located in ``slash.config``, and modified through ``slash.config.root`` as follows:
+
+.. code-block:: python
+
+		# ~/.slash/slashrc contents
+		import slash
+
+		slash.config.root.debug.enabled = False
+
+
+List of Available Configuration Values
+--------------------------------------
+
+.. config_doc::
diff --git a/doc/cookbook.rst b/doc/cookbook.rst
new file mode 100755
index 0000000000..9d861430e4
--- /dev/null
+++ b/doc/cookbook.rst
@@ -0,0 +1,63 @@
+Cookbook
+========
+
+Execution
+---------
+
+Controlling Test Execution Order
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Slash offers a hook called ``tests_loaded`` which can be used, among else, to control the test execution order. Tests are sorted by a dedicated key in their metadata (a.k.a the ``__slash__`` attribute), which defaults to the discovery order. You can set your hook registration to modify the tests as you see fit, for instance to reverse test order:
+
+.. code-block:: python
+
+       @slash.hooks.tests_loaded.register
+       def tests_loaded(tests):
+	   for index, test in enumerate(reversed(tests)):
+	       test.__slash__.set_sort_key(index)
+
+The above code is best placed in a ``slashconf.py`` file at the root of your test repository.
+
+
+Logging
+-------
+
+Adding Multiple Log Files to a Single Test Result
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Slash result objects contain the main path of the log file created by Slash (if logging is properly configured for the current run).
+
+In some cases it may be desirable to include multiple log files for the current test. This can be useful, for example, if the current test runs additional tools or processes emitting additional logs:
+
+
+.. code-block:: python
+       
+    import slash
+    import subprocess
+
+    def test_running_validation_tool():
+        log_dir = slash.context.result.get_log_dir()
+        log_file = os.path.join(log_dir, "tool.log")
+
+        slash.context.result.add_extra_log_path(log_file)
+
+        with open(os.path.join(log_dir, "tool.log"), "w") as logfile:
+            res = subprocess.run(f'/bin/validation_tool -l {log_dir}', shell=True, stdout=logfile)
+            res.check_returncode()
+
+You can also configure extre session paths, for example from plugins:
+
+.. code-block:: python
+
+    class MyPlugin(slash.plugins.PluginInterface):
+
+        def get_name(self):
+            return "my_plugin"
+
+        def get_default_config(self):
+            retrun {'extra_log_path': ''}
+
+        def session_start(self):
+            log_path = slash.config.root.plugin_config.my_plugin.extra_log_path
+            if log_path:
+                slash.context.session.results.global_result.add_extra_log_path(log_path)
diff --git a/doc/customizing_slash.rst b/doc/customizing_slash.rst
new file mode 100755
index 0000000000..c9f6e2d4d5
--- /dev/null
+++ b/doc/customizing_slash.rst
@@ -0,0 +1,246 @@
+.. _customizing:
+
+Customizing and Extending Slash
+===============================
+
+This section describes how to tailor Slash to your needs. We'll walk through the process in baby steps, each time adding a small piece of functionality. If you want to start by looking at the finished example, you can skip and see it :ref:`here <finished_example>`.
+
+Customization Basics
+--------------------
+
+``.slashrc``
+~~~~~~~~~~~~
+
+In order to customize Slash we have to write code that will be executed when Slash loads. Slash offers an easy way to do this -- by placing a file named ``.slashrc`` in your project's root directory. This file is loaded as a regular Python file, so we will write regular Python code in it.
+
+.. note:: The ``.slashrc`` file location is read from the configuration (:ref:`conf.run.project_customization_file_path`). However since it is ready before the command-line parsing phase, it cannot be specified using ``-o``.
+
+Hooks and Plugins
+~~~~~~~~~~~~~~~~~
+
+When our ``.slashrc`` file is loaded we have only one shot to install and configure all the customizations we need for the entire session. Slash supports two facilities that can be used together for this task, as we'll see shortly.
+
+*Hooks* are a collection of callbacks that any code can register, thus getting notified when certain events take place. They also support receiving arguments, often detailing what exactly happened.
+
+*Plugins* are a mechanism for loading pieces of code conditionally, and are :ref:`described in detail in the relevant section <plugins>`. For now it is sufficient to say that plugins are classes deriving from :class:`slash.plugins.PluginInterface`, and that can activated upon request. Once activated, methods defined on the plugin which correspond to names of known hooks get registered on those hooks automatically.
+
+1. Customizing Using Plain Hooks
+--------------------------------
+
+Our first step is customizing the logging facility to our needs. We are going to implement two requirements:
+
+1. Have logging always turned on in a fixed location (Say ``~/slash_logs``)
+2. Collect execution logs at the end of each session, and copy them to a central location (Say ``/remote/path``).
+
+The first requirement is simple - it is done by modifying the global Slash configuration:
+
+.. code-block:: python
+
+		# file: .slashrc
+		import os
+		import slash
+
+		slash.config.root.log.root = os.path.expanduser('~/slash_logs')
+
+.. note:: Don't be confused about ``slash.config.root.log.root`` above. ``slash.config.root`` is used to access the root of the configuration, while ``log.root`` is the name of the configuration value that controls the log location.
+
+.. seealso:: :ref:`configuration`
+
+The second requirement requires us to do something when the session ends. This is where **hooks** come in. It allows us to register a callback function to be called when the session ends. 
+
+Slash uses `gossip <http://gossip.readthedocs.org>`_ to implement hooks, so we can simply use *gossip.register* to register our callback:
+
+.. code-block:: python
+
+		import gossip
+		import shutil
+
+		...
+		@gossip.register('slash.session_end')
+		def collect_logs():
+		    shutil.copytree(...)
+
+Now we need to supply arguments to ``copytree``. We want to copy only the directory of the current session, into a destination directory also specific to this session. How do we do this? The important information can be extracted from :class:`slash.session <slash.core.session.Session>`, which is a proxy to the current object representing the session:
+
+.. code-block:: python
+
+		...
+		@gossip.register('slash.session_end')
+		def collect_logs():
+		    shutil.copytree(
+		        slash.session.logging.session_log_path, 
+			os.path.join('/remote/path', slash.session.id))
+
+.. seealso:: :ref:`hooks`, :ref:`internals`
+
+2. Organizing Customizations in Plugins
+---------------------------------------
+
+Suppose you want to make the log collection behavior optional. Our previous implementation registered the callback immediately, meaning you had no control over whether or not it takes place. Optional customizations are best made optional through organizing them in plugins.
+
+Information on plugins in Slash can be found in :ref:`plugins`, but for now it is enough to mention that plugins are classes deriving from :class:`slash.plugins.PluginInterface`. Plugins can be *installed* and *activated*. Installing a plugin makes it available for activation (but does little else), while activating it actually makes it kick into action. Let's write a plugin that performs the log collection for us:
+
+.. code-block:: python
+
+		...
+		class LogCollectionPlugin(slash.plugins.PluginInterface):
+
+		    def get_name(self):
+		        return 'logcollector'
+
+		    def session_end(self):
+		        shutil.copytree(
+		            slash.session.logging.session_log_path, 
+			    os.path.join('/remote/path', slash.session.id))
+
+		collector_plugin = LogCollectionPlugin()
+		plugins.manager.install(collector_plugin)
+		    
+The above class inherits from :class:`slash.plugins.PluginInterface` - this is the base class for implementing plugins. We then call :func:`slash.plugins.PluginManager.install` to *install* our plugin. Note that at this point the plugin is not activated.
+
+Once the plugin is installed, you can pass ``--with-logcollector`` to actually activate the plugin. More on that soon.
+
+The ``get_name`` method is required for any plugin you implement for slash, and it should return the name of the plugin. This is where the ``logcollector`` in ``--with-logcollector`` comes from.
+
+The second method, ``session_end``, is the heart of how the plugin works. When a plugin is activated, methods defined on it automatically get registered to the respective hooks with the same name. This means that upon activation of the plugin, our collection code will be called when the session ends..	    
+
+Activating by Default
+~~~~~~~~~~~~~~~~~~~~~
+
+In some cases you want to activate the plugin by default, which is easily done with the :func:`slash.plugins.PluginManager.activate`:
+
+.. code-block:: python
+
+		...
+		slash.plugins.manager.activate(collector_plugin)
+
+.. note:: You can also just pass ``activate=True`` in the call to ``install``
+
+Once the plugin is enabled by default, you can correspondingly disable it using ``--without-logcollector`` as a parameter to ``slash run``.
+
+.. seealso:: :ref:`plugins`
+
+
+3. Passing Command-Line Arguments to Plugins
+--------------------------------------------
+
+In the real world, you want to test integrated products. These are often physical devices or services running on external machines, sometimes even officially called *devices under test*. We would like to pass the target device IP address as a parameter to our test environment. The easiest way to do this is by writing a plugin that adds command-line options:
+
+
+.. code-block:: python
+
+		...
+		@slash.plugins.active
+		class ProductTestingPlugin(slash.plugins.PluginInterface):
+
+		    def get_name(self):
+		        return 'your-product'
+
+		    def configure_argument_parser(self, parser):
+		        parser.add_argument('-t', '--target', 
+			    help='ip address of the target to test')
+
+		    def configure_from_parsed_args(self, args):
+		        self.target_address = args.target
+			
+		    def session_start(self):
+		        slash.g.target = Target(self.target_address)
+
+
+First, we use :func:`slash.plugins.active` decorator here as a shorthand. See :ref:`plugins` for more information.
+
+Second, we use two new plugin methods here - `configure_argument_parser` and `configure_from_parsed_args`. These are called on every activated plugin to give it a chance to control how the commandline is processed. The parser and args passed are the same as if you were using **argparse** directly.
+
+Note that we separate the stages of obtaining the address from actually initializing the target object. This is to postpone the heavier code to the actual beginning of the testing session. The ``session_start`` hook helps us with that - it is called after the argument parsing part.
+
+Another thing to note here is the use of ``slash.g``. This is a convenient location for shared global state in your environment, and is documented in :ref:`global_state`. In short we can conclude with the fact that this object will be available to all test under ``slash.g.target``, as a global setup.
+
+4. Configuration Extensions
+---------------------------
+
+Slash supports a hierarchical configuration facility, described in :ref:`the relevant documentation section <configuration>`. In some cases you might want to parametrize your extensions to allow the user to control its behavior. For instance let's add an option to specify a timeout for the target's API:
+
+.. code-block:: python
+
+		...
+		@slash.plugins.active
+		class ProductTestingPlugin(slash.plugins.PluginInterface):
+		    ...
+		    def activate(self):
+		        slash.config.extend({
+			    'product': {
+			        'api_timeout_seconds': 50
+			    }
+			})
+
+		    ...
+		    def session_start(self):
+		        slash.g.target = Target(
+			    self.target_address, 
+			    timeout=slash.config.root.product.api_timeout_seconds)
+		    
+
+We use the :func:`slash.plugins.PluginInterface.activate` method to control what happens when our plugin is **activated**. Note that this happens very early in the execution phase - even before tests are loaded to be executed.
+
+In the ``activate`` method we use the **extend** capability of Slash's configuration to append configuration paths to it. Then in ``session_start`` we use the value off the configuration to initialize our target.
+
+The user can now easily modify these values from the command-line using the ``-o`` flag to ``slash run``::
+
+  $ slash run ... -o product.api_timeout_seconds=100 ./
+
+
+
+Complete Example
+----------------
+
+Below is the final code for the ``.slashrc`` file for our project:
+
+.. _finished_example:
+
+.. code-block:: python
+
+        import os
+        import shutil
+        
+        import slash
+        
+        slash.config.root.log.root = os.path.expanduser('~/slash_logs')
+        
+        
+        @slash.plugins.active
+        class LogCollectionPlugin(slash.plugins.PluginInterface):
+        
+            def get_name(self):
+                return 'logcollector'
+        
+            def session_end(self):
+                shutil.copytree(
+                    slash.session.logging.session_log_path,
+                    os.path.join('/remote/path', slash.session.id))
+        
+        
+        @slash.plugins.active
+        class ProductTestingPlugin(slash.plugins.PluginInterface):
+        
+            def get_name(self):
+                return 'your-product'
+        
+            def activate(self):
+                slash.config.extend({
+                    'product': {
+                        'api_timeout_seconds': 50
+                    }
+                })
+        
+            def configure_argument_parser(self, parser):
+                parser.add_argument('-t', '--target',
+                                    help='ip address of the target to test')
+        
+            def configure_from_parsed_args(self, args):
+                self.target_address = args.target
+        
+            def session_start(self):
+                slash.g.target = Target(
+                    self.target_address, timeout=slash.config.root.product.api_timeout_seconds)
+
+
diff --git a/doc/details.rst b/doc/details.rst
new file mode 100755
index 0000000000..8f49ad5143
--- /dev/null
+++ b/doc/details.rst
@@ -0,0 +1,37 @@
+Saving Test Details
+===================
+
+Slash supports saving additional data about test runs, by attaching this data to the global result object.
+
+Test Details
+------------
+
+Test details can be thought of as an arbitrary dictionary of values, keeping important information about the session that can be later browsed by reporting tools or plugins.
+
+To set a detail, just use ``result.details.set``, accessible through Slash's global context:
+
+.. code-block:: python
+
+       def test_steering_wheel(car):
+	   mileage = car.get_mileage()
+	   slash.context.result.details.set('mileage', mileage)
+
+
+Test Facts
+----------
+
+Facts are very similar to details but they are intended for a more strict set of values, serving as a basis for coverage matrices.
+
+For instance, a test reporting tool might want to aggregate many test results and see which ones succeeded on model A of the product, and which on model B.
+
+To set facts, use ``result.facts`` just like the details feature:
+
+.. code-block:: python
+
+       def test_steering_wheel(car):
+	   slash.context.result.facts.set('is_van', car.is_van())
+
+
+.. note:: facts also trigger the `fact_set <hooks.html#fact_set>`_ hook when set
+
+.. note:: The distinction of when to use details and when to use facts is up for the user and/or the plugins that consume that information
diff --git a/doc/development.rst b/doc/development.rst
new file mode 100755
index 0000000000..91dfc76d9c
--- /dev/null
+++ b/doc/development.rst
@@ -0,0 +1,20 @@
+Development
+===========
+
+Slash tries to bring a lot of features to the first releases. For starters, the very first usable version (0.0.1) aims at providing basic running support and most of the groundwork needed for the following milestones.
+
+All changes are checked against `Travis <http://travis-ci.org>`_. Before committing you should test against supported versions using ``tox``, as it runs the same job being run by travis. For more information on Slash's internal unit tests see :ref:`unit_testing`.
+
+Development takes place on `github <https://github.com/vmalloc/slash>`_. Feel free to open issues or pull requests, as a lot of the project's success depends on your feedback!
+
+I normally do my best to respond to issues and PRs as soon as possible (hopefully within one day). Don't hesitate to ping me if you don't hear from me - there's a good chance I missed a notification or something similar.
+
+Contributors
+============
+
+Special thanks go to these people for taking the time in improving Slash and providing feedback:
+
+* Alon Horev (@alonho)
+* Omer Gertel
+* Pierre-Luc Tessier Gagné
+
diff --git a/doc/errors.rst b/doc/errors.rst
new file mode 100755
index 0000000000..b89d596eac
--- /dev/null
+++ b/doc/errors.rst
@@ -0,0 +1,285 @@
+.. _errors:
+
+Assertions, Exceptions and Errors
+=================================
+
+Assertions
+----------
+
+Assertions are the bread and butter of tests. They ensure constraints are held and that conditions are met:
+
+.. code-block:: python
+
+		# test_addition.py
+
+		def test_addition(self):
+		    assert 2 + 2 == 4
+
+When assertions fail, the assertion rewriting code Slash uses will help you understand what exactly happened. This also applies for much more complex expressions:
+
+.. code-block:: python
+
+		...
+		assert f(g(x))  == g(f(x + 1))
+		...
+
+When the above assertion fails, for instance, you can expect an elaborate output like the following::
+
+        >        assert f(g(x)) == g(f(x + 1))
+        F        AssertionError: assert 1 == 2
+                 +  where 1 = <function f at 0x10b10f848>(1)
+                 +    where 1 = <function g at 0x10b10f8c0>(1)
+                 +  and   2 = <function g at 0x10b10f8c0>(2)
+                 +    where 2 = <function f at 0x10b10f848>((1 + 1))
+
+
+.. note:: The assertion rewriting code is provided by `dessert <https://github.com/vmalloc/dessert>`_, which is a direct port of the code that powers `pytest <http://pytest.org>`_. All credit goes to Holger Krekel and his fellow devs for this masterpiece.
+
+.. note:: By default, even asserts with accompanied messages will emit introspection information. This can be overriden through the ``run.message_assertion_introspection`` configuration flag.
+  
+  .. versionadded:: 1.3.0
+
+More Assertion Utilities
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+One case that is not easily covered by the assert statement is asserting Exception raises. This is easily done with :func:`slash.assert_raises`:
+
+.. code:: python
+
+	  with slash.assert_raises(SomeException) as caught:
+	      some_func()
+
+	  assert caught.exception.param == 'some_value'
+
+:func:`slash.assert_raises` will raise ``ExpectedExceptionNotCaught`` exception in case the expected exception was not raised:
+
+.. code:: python
+
+	 >>> with slash.assert_raises(Exception) as caught: # doctest: +IGNORE_EXCEPTION_DETAIL
+	 ...    pass
+	 Traceback (most recent call last):
+	     ...
+	 ExpectedExceptionNotCaught: ...
+
+In a case where the test author wants to allow a specific exception but not to enforce its propagation (e.g. allowing a timing issue to be present), :func:`slash.allowing_exceptions` can be used.
+
+.. code:: python
+
+	  >>> with slash.allowing_exceptions(Exception) as caught:
+	  ...    pass
+
+You also have :func:`slash.assert_almost_equal` to test for near equality:
+
+.. code:: python
+
+	  slash.assert_almost_equal(1.001, 1, max_delta=0.1)
+
+.. note:: :func:`slash.assert_raises` and :func:`slash.allowing_exceptions` interacts with :func:`.handling_exceptions` - exceptions anticipated by ``assert_raises`` or ``allowing_exceptions`` will be ignored by ``handling_exceptions``.
+
+Errors
+------
+
+.. index::
+   single: errors
+
+Any exception which is not an assertion is considered an 'error', or in other words, an unexpected error, failing the test. Like many other testing frameworks Slash distinguishes failures from errors, the first being anticipated while the latter being unpredictable. For most cases this distinction is not really important, but exists nontheless. 
+
+Any exceptions thrown from a test will be added to the test result as an error, thus marking the test as 'error'.
+
+.. _KeyboardInterrupt:
+
+Interruptions
+-------------
+
+.. index::
+   single: KeyboardInterrupt
+   single: interrupting
+
+Usually when a user hits Ctrl+C this means he wants to terminate the running program as quickly as possible without corruption or undefined state. Slash treats KeyboardInterrupt a bit differently than other exceptions, and tries to quit as quickly as possible when they are encountered.
+
+.. note:: ``KeyboardInterrupt`` also causes regular cleanups to be skipped. You can set critical cleanups to be carried out on both cases, as described in the :ref:`relevant section <cleanups>`.
+
+
+Explicitly Adding Errors and Failures
+-------------------------------------
+
+.. index::
+   single: add_error
+   single: add_failure
+   pair: errors; adding
+   pair: failures; adding
+
+Sometimes you would like to report errors and failures in mid-test without failing it immediately (letting it run to the end). This is good when you want to collect all possible failures before officially quitting, and this is more helpful for reporting.
+
+This is possible using the :func:`slash.add_error` and :func:`slash.add_failure` methods. They can accept strings (messages) or actual objects to be kept for reporting. It is also possible to add more than one failure or error for each test.
+
+.. code-block:: python
+
+ class MyTest(slash.Test):
+     
+    def test(self):
+        if not some_condition():
+            slash.add_error("Some condition is not met!")
+
+	# code keeps running here...
+
+.. autofunction:: slash.add_error
+
+.. autofunction:: slash.add_failure
+
+
+
+.. _exceptions:
+
+Handling and Debugging Exceptions
+---------------------------------
+
+.. index::
+   single: exceptions
+   single: debugging
+
+Exceptions are an important part of the testing workflow. They happen all the time -- whether they indicate a test lifetime event or an actual error condition. Exceptions need to be debugged, handled, responded to, and sometimes with delicate logic of what to do when.
+
+You can enter a debugger when exceptions occur via the ``--pdb`` flag. Slash will attempt to invoke ``pudb`` or ``ipdb`` if you have them installed, but will revert to the default ``pdb`` if they are not present.
+
+Note that the hooks named ``exception_caught_after_debugger``, and ``exception_caught_before_debugger`` handle exception cases. It is important to plan your hook callbacks and decide which of these two hooks should call them, since a debugger might stall for a long time until a user notices it.
+
+
+Exception Handling Context
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Exceptions can occur in many places, both in tests and in surrounding infrastructure. In many cases you want to give Slash the first oppurtunity to handle an exception before it propagates. For instance, assume you have the following code:
+
+.. code-block:: python
+
+    def test_function():
+        func1()
+
+    def func1():
+        with some_cleanup_context():
+	    func2()
+
+    def func2():
+        do_something_that_can_fail()
+
+In the above code, if ``do_something_that_can_fail`` raises an exception, and assuming you're running slash with ``--pdb``, you will indeed be thrown into a debugger. However, the end consequence will not be what you expect, since ``some_cleanup_context`` will have already been left, meaning any cleanups it performs on exit take place *before* the debugger is entered. This is because the exception handling code Slash uses kicks in only after the exception propagates out of the test function.
+
+In order to give Slash a chance to handle the exception closer to where it originates, Slash provices a special context, :func:`slash.exception_handling.handling_exceptions`. The purpose of this context is to give your infrastructure a chance to handle an erroneous case as close as possible to its occurrence:
+
+.. code-block:: python
+
+    def func1():
+        with some_cleanup_context(), slash.handle_exceptions_context():
+	    func2()
+
+
+the :func:`handling_exceptions <slash.exception_handling.handling_exceptions>` context can be safely nested -- once an exception is handled, it is appropriately marked, so the outer contexts will skip handling it:
+
+.. code-block:: python
+
+    from slash.exception_handling import handling_exceptions
+
+    def some_function():
+        with handling_exceptions():
+            do_something_that_might_fail()
+
+    with handling_exceptions():
+        some_function()
+
+.. note:: ``handling_exceptions`` will ignore exceptions currently anticipated by :func:`.assert_raises`. This is desired since these exceptions are an expected flow and not an actual error that needs to be handled. These exceptions will be simply propagated upward without any handling or marking of any kind.
+
+Exception Marks
+~~~~~~~~~~~~~~~
+
+The exception handling context relies on a convenience mechanism for marking exceptions. 
+
+
+
+Marks with Special Meanings
++++++++++++++++++++++++++++
+
+* :func:`.mark_exception_fatal`: See :ref:`below <fatal_exceptions>`.
+* :func:`.noswallow`: See :ref:`below <exception_swallowing>`.
+* :func:`.inhibit_unhandled_exception_traceback`: See :ref:`below <inhibit_traceback>`.
+
+
+.. _fatal_exceptions:
+
+Fatal Exceptions
+~~~~~~~~~~~~~~~~
+
+Slash supports marking special exceptions as *fatal*, causing the immediate stop of the session in which they occur. This is useful if your project has certain types of failures which are considered important enough to halt everything for investigation.
+
+Fatal exceptions can be added in two ways. Either via marking explicitly with :func:`.mark_exception_fatal`:
+
+.. code-block:: python
+       
+       ...
+       raise slash.exception_handling.mark_exception_fatal(Exception('something'))
+
+Or, when adding errors explicitly, via the ``mark_fatal`` method:
+
+.. code-block:: python
+       
+       slash.add_error("some error condition detected!").mark_fatal()
+
+.. note:: The second form, using ``add_error`` will not stop immediately since it does not raise an exception. It is your reponsibility to avoid any further actions which might tamper with your setup or your session state.
+
+
+.. _exception_swallowing:
+
+Exception Swallowing
+~~~~~~~~~~~~~~~~~~~~
+
+Slash provides a convenience context for swallowing exceptions in various places, :func:`.get_exception_swallowing_context`. This is useful in case you want to write infrastructure code that should not collapse your session execution if it fails. Use cases for this feature:
+
+1. Reporting results to external services, which might be unavailable at times
+2. Automatic issue reporting to bug trackers
+3. Experimental features that you want to test, but don't want to disrupt the general execution of your test suites.
+
+Swallowed exceptions get reported to log as debug logs, and assuming the :ref:`conf.sentry.dsn` configuration path is set, also get reported to `sentry <http://getsentry.com>`_:
+
+.. code-block:: python
+
+
+   def attempt_to_upload_logs():
+       with slash.get_exception_swallowing_context():
+            ...
+
+
+
+You can force certain exceptions through by using the :func:`.noswallow` or ``disable_exception_swallowing`` functions:
+
+.. code-block:: python
+
+   from slash.exception_handling import (
+       noswallow,
+       disable_exception_swallowing,
+       )
+
+   def func1():
+      raise noswallow(Exception("CRITICAL!"))
+
+   def func2():
+      e = Exception("CRITICAL!")
+      disable_exception_swallowing(e)
+      raise e
+
+   @disable_exception_swallowing
+   def func3():
+      raise Exception("CRITICAL!")
+
+.. _inhibit_traceback:
+
+Console Traceback of Unhandled Exceptions
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Exceptions thrown from hooks and plugins *outside of running tests* normally cause emitting full traceback to the console. In some cases, you would like to use these errors to denote usage errors or specific known erroneous conditions (e.g. missing configuration or conflicting usages). In these cases you can mark your exceptions to inhibit a full traceback:
+
+.. code-block:: python
+       
+       from slash.exception_handling import inhibit_unhandled_exception_traceback
+       ...
+       raise inhibit_unhandled_exception_traceback(Exception('Some Error'))
+
+.. versionadded:: 1.3.0
diff --git a/doc/faq.rst b/doc/faq.rst
new file mode 100755
index 0000000000..8541569a91
--- /dev/null
+++ b/doc/faq.rst
@@ -0,0 +1,19 @@
+FAQ
+---
+
+What is the Difference Between Slash and Pytest/Nose/Unittest?
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+We would first like to point out that both *Nose* and Python's built-in ``unittest`` were built for building and running unit tests. Unittest provides a decent runner, whereas *Nose* is more of an evolved runner that supports plugins. Both try not to get involved too much in your project's test code, and assume you are running unittest-based tests, or not far from it.
+
+*Pytest*, on the other hand, took the next step - it's not only a great test runner, but provides more utilities and infrastructure for your tests, like fixtures, parametrization etc. We personally love pytest, and use it to test Slash itself, as you can see from our code.
+
+However, the main difference is in the project's focus. Pytest was created as a successor to nose/unittest, and as such its primary focus tends to remain around unit tests. This implies certain defaults (like stdout/stderr capturing) and certain sets of features which are more likely to be implemented for it.
+
+The main project for which we wrote Slash involved testing an external product. As such, it was less about maintaining individual state for each test and setting it up again later, and more about building a consistent state for the entire test session -- syncing with the test "subject" before the first test, performing validations between tests, recycling objects and entities between tests etc. What was missing for us in Pytest became clear after a certain period of active development -- Pytest, being focused around the tests being written, lacks (some) facilities to deal with everything around and between the tests.
+
+One specific example for us was widely-scoped cleanups (like tests registering cleanups that are to happen at the end of the session or module) - in this case it was difficult to tie the error to the entity that created the cleanup logic. There are more examples of how Slash focuses on the testing session itself and its extensibility - the concept of session errors is much better defined in Slash, it includes mechanisms for controlling plugin dependencies, multiple levels of customizations and a hierarchical configuration mechanism. There are also features that Slash provides that Pytest does not, like better logging control, advanced fixture parametrization, early-catch exception handling and more - with even more yet to be shipped.
+
+Another difference is that while pytest can be loosely thought of as a tool, Slash can be thought of as a framework. It puts much more emphasis on letting you build on top of it, set up your environment and integrate with external services (we ourselves built Backslash as a centralized reporting solution for it, for instance). Slash eventually aims at helping you evolve your own testing solution with it.
+
+In the end, the distinction isn't clear-cut though, and different people might find different tools better suited for them. This is great - having choice when it comes to which tool to use is a good thing, and we embrace this fact.
diff --git a/doc/features.rst b/doc/features.rst
new file mode 100755
index 0000000000..79b3161b94
--- /dev/null
+++ b/doc/features.rst
@@ -0,0 +1,17 @@
+Misc. Features
+==============
+
+Notifications
+-------------
+
+Slash provides an optional plugin for sending notifications at end of runs, via ``--with-notifications``. It supports `NMA <http://www.notifymyandroid.com/>`_, `Prowl <http://www.prowlapp.com/>`_ and `Pushbullet <https://www.pushbullet.com>`_.
+
+To use it, specify either ``plugins.notifications.prowl_api_key``, ``plugins.notifications.nma_api_key`` or ``plugins.notifications.pushbullet_api_key`` when running. For example::
+
+  slash run my_test.py --with-notifications -o plugins.notifications.nma_api_key=XXXXXXXXXXXXXXX
+
+XUnit Export
+------------
+
+Pass ``--with-xunit``, ``--xunit-filenam=PATH`` to export results as xunit XMLs (useful for CI solutions and other consumers).
+
diff --git a/doc/fixtures.rst b/doc/fixtures.rst
new file mode 100755
index 0000000000..90b31c0b75
--- /dev/null
+++ b/doc/fixtures.rst
@@ -0,0 +1,318 @@
+.. _fixtures:
+
+Test Fixtures
+=============
+
+Slash includes a powerful mechanism for parametrizing and composing tests, called *fixtures*. This feature resembles, and was greatly inspired by, the feature of the same name in **py.test**.
+
+To demonstrate this feature we will use *test functions*, but it also applies to test methods just the same.
+
+What is a Fixture?
+------------------
+
+A *fixture* refers to a certain piece of setup or data that your test requires in order to run. It generally does not refer to the test itself, but the base on which the test builds to carry out its work.
+
+Slash represents fixtures in the form of arguments to your test function, thus denoting that your test function needs this fixture in order to run:
+
+.. code-block:: python
+
+		def test_microwave_turns_on(microwave):
+		    microwave.turn_on()
+		    assert microwave.get_state() == STATE_ON
+
+So far so good, but what exactly is *microwave*? Where does it come from? 
+
+The answer is that Slash is responsible of looking up needed fixtures for each test being run. Each function is examined, and telling by its arguments, Slash goes ahead and looks for a fixture definition called *microwave*.
+
+The Fixture Definition
+----------------------
+
+The fixture definition is where the logic of your fixture goes. Let's write the following somewhere in your file:
+
+.. code-block:: python
+
+		import slash
+
+		...
+
+		@slash.fixture
+		def microwave():
+		    # initialization of the actual microwave instance   
+		    return Microwave(...)  
+
+
+In addition to the test file itself, you can also put your fixtures in a file called `slashconf.py`, and put it in your test directory. Multiple such files can exist, and a test automatically "inherits" fixtures from the entire directory hierarchy above it.
+
+Fixture Cleanups
+----------------
+
+You can control what happens when the lifetime of your fixture ends. By default, this happens at the end of each test that requested your fixture. To do this, add an argument for your fixture called ``this``, and call its ``add_cleanup`` method with your cleanup callback:
+
+.. code-block:: python
+
+		@slash.fixture
+		def microwave(this):
+		    returned = Microwave()
+		    this.add_cleanup(returned.turn_off)
+		    return returned
+
+.. note:: Ths ``this`` variable is also available globally while computing each fixture as the ``slash.context.fixture`` global variable.
+
+
+Opting Out of Fixtures
+----------------------
+
+In some cases you may want to turn off Slash's automatic deduction of parameters as fixtures. For instance in the following case you want to explicitly call a version of a base class's ``before`` method:
+
+.. code-block:: python
+       
+       >>> class BaseTest(slash.Test):
+       ...     def before(self, param):
+       ...         self._construct_case_with(param)
+
+       >>> class DerivedTest(BaseTest):
+       ...     @slash.parametrize('x', [1, 2, 3])
+       ...     def before(self, x):
+       ...         param_value = self._compute_param(x)
+       ...         super(DerivedTest, self).before(x)
+
+This case would fail to load, since Slash will assume ``param`` is a fixture name and will not find such a fixture to use. The solution is to use :func:`slash.nofixtures` on the parent class's ``before`` method to mark that ``param`` is *not* a fixture name:
+
+.. code-block:: python
+       
+       >>> class BaseTest(slash.Test):
+       ...     @slash.nofixtures
+       ...     def before(self, param):
+       ...         self._construct_case_with(param)
+
+
+
+Fixture Needing Other Fixtures
+------------------------------
+
+A fixture can depend on other fixtures just like a test depends on the fixture itself, for instance, here is a fixture for a heating plate, which depends on the type of microwave we're testing:
+
+.. code-block:: python
+
+		@slash.fixture
+		def heating_plate(microwave):
+		    return get_appropriate_heating_plate_for(microwave)
+
+Slash takes care of spanning the fixture dependency graph and filling in the values in the proper order. If a certain fixture is needed in multiple places in a single test execution, it is guaranteed to return the same value:
+
+.. code-block:: python
+
+		def test_heating_plate_usage(microwave, heating_plate):
+		    # we can be sure that heating_plate matches the microwave,
+		    # since `microwave` will return the same value for the test
+		    # and for the fixture
+
+
+Fixture Parametrization
+-----------------------
+
+Fixtures become interesting when you parametrize them. This enables composing many variants of tests with a very little amount of effort. Let's say we have many kinds of microwaves, we can easily parametrize the microwave class:
+
+
+.. code-block:: python
+
+		@slash.fixture
+		@slash.parametrize('microwave_class', [SimpleMicrowave, AdvancedMicrowave]):
+		def microwave(microwave_class, this):
+		    returned = microwave_class()
+		    this.add_cleanup(returned.turn_off)
+		    return returned
+
+Now that we have a parametrized fixture, Slash takes care of multiplying the test cases that rely on it automatically. The single test we wrote in the beginning will now cause two actual test cases to be loaded and run -- one with a simple microwave and one with an advanced microwave.
+
+As you add more parametrizations into dependent fixtures in the dependency graph, the actual number of cases being run eventually multiples in a cartesian manner.
+
+Fixture Requirements
+--------------------
+
+.. index:: 
+   pair: fixtures; requirements
+
+It is possible to specify requirements for fixture functions, very much like :ref:`test requirements <requirements>`. Fixtures for which requirements are not met will prevent their dependent tests from being run, being skipped instead:
+
+.. code-block:: python
+
+                @slash.fixture
+                @slash.requires(condition, 'Requires a specific flag')
+                def some_fixture():
+                    ...
+
+.. seealso:: :ref:`requirements`
+                
+
+Fixture Scopes
+--------------
+
+By default, a fixture "lives" through only a single test at a time. This means that:
+
+1. The fixture function will be called again for each new test needing the fixture
+2. If any cleanups exist, they will be called at the end of each test needing the fixture.
+
+We say that fixtures, by default, have a **scope of a single test**, or *test scope*.
+
+Slash also supports *session* and *module* scoped fixtures. *Session fixtures* live from the moment of their activation until the end of the test session, while *module fixtures* live until the last test of the module that needed them finished execution. Specifying the scope is rather straightforward:
+
+.. code-block:: python
+
+		@slash.fixture(scope='session')
+		def some_session_fixture(this):
+		    @this.add_cleanup
+		    def cleanup():
+		        print('Hurray! the session has ended')
+		
+
+		@slash.fixture(scope='module')
+		def some_module_fixture(this):
+		    @this.add_cleanup
+		    def cleanup():
+		        print('Hurray! We are finished with this module')
+
+
+Test Start/End for Widely Scoped Fixtures
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+When a fixture is scoped wider than a single test, it is useful to add custom callbacks to the fixtures to be called when a test starts or ends. This is done via the ``this.test_start`` and ``this.test_end`` callbacks, which are specific to the current fixture.
+
+.. code-block:: python
+       
+    @slash.fixture(scope='module')
+    def background_process(this):
+        process = SomeComplexBackgroundProcess()
+	
+	@this.test_start
+	def on_test_start():
+	    process.make_sure_still_running()
+
+	@this.test_end
+	def on_test_end():
+	    process.make_sure_no_errors()
+
+	process.start()
+
+	this.add_cleanup(process.stop)
+
+
+.. note:: Exceptions propagating out of the ``test_start`` or ``test_end`` hooks will fail the test, possibly preventing it from starting properly
+		    
+
+Autouse Fixtures
+----------------
+
+You can also "force" a fixture to be used, even if it is not required by any function argument. For instance, this example creates a temporary directory that is deleted at the end of the session:
+
+.. code-block:: python
+
+		@slash.fixture(autouse=True, scope='session')
+		def temp_dir():
+		    """Create a temporary directory"""
+		    directory = '/some/directory'
+		    os.makedirs(directory)
+
+		    @this.add_cleanup
+		    def cleanup():
+		        shutil.rmtree(directory)
+
+Aliasing Fixtures
+-----------------
+
+In some cases you may want to name your fixtures descriptively, e.g.:
+
+.. code-block:: python
+       
+       @slash.fixture
+       def microwave_with_up_to_date_firmware(microwave):
+           microwave.update_firmware()
+	   return microwave
+
+Although this is a very nice practice, it makes tests clumsy and verbose:
+
+.. code-block:: python
+       
+       def test_turning_off(microwave_with_up_to_date_firmware):
+           microwave_with_up_to_date_firmware.turn_off()
+	   assert microwave_with_up_to_date_firmware.is_off()
+	   microwave_with_up_to_date_firmware.turn_on()
+
+Fortunately, Slash allows you to *alias* fixtures, using the :func:`slash.use` shortcut:
+
+.. code-block:: python
+       
+       def test_turning_off(m: slash.use('microwave_with_up_to_date_firmware')):
+           m.turn_off()
+	   assert m.is_off()
+	   m.turn_on()
+
+.. versionadded: 1.0
+
+
+.. note:: Fixture aliases require Python 3.x, as they rely on `function argument annotation <https://www.python.org/dev/peps/pep-3107/>`_
+
+
+Misc. Utilities
+---------------
+
+Yielding Fixtures
+~~~~~~~~~~~~~~~~~
+
+Fixtures defined as generators are automatically detected by Slash. In this mode, the fixture is run as a generator, with the yielded value acting as the fixture value. Code after the yield is treated as cleanup code (similar to using ``this.add_cleanup``):
+
+.. code-block:: python
+       
+       @slash.fixture
+       def microwave(model_name):
+           m = Microwave(model_name)
+	   yield m
+	   m.turn_off()
+
+.. versionadded: 1.2
+
+Generator Fixtures
+~~~~~~~~~~~~~~~~~~
+
+:func:`slash.generator_fixture` is a shortcut for a fixture returning a single parametrization:
+
+.. code-block:: python
+       
+       @slash.generator_fixture
+       def model_types():
+           for model_config in all_model_configs:
+               if model_config.supported:
+                   yield model_config.type
+
+
+In general, this form:
+
+.. code-block:: python
+       
+       @slash.generator_fixture
+       def fixture():
+           yield from x
+
+is equivalent to this form:
+
+.. code-block:: python
+       
+       @slash.fixture
+       @slash.parametrize('param', x)
+       def fixture(param):
+           return param
+
+.. versionadded: 1.0
+		    
+
+Listing Available Fixtures
+--------------------------
+
+Slash can be invoked with the ``list`` command and the ``--only-fixtures`` flag, which takes a path to a testing directory. This command gets the available fixtures for the specified testing directory:
+
+    $ slash list --only-fixtures path/to/tests
+
+    temp_dir
+        Create a temporary directory
+
+        Source: path/to/tests/utilities.py:8
diff --git a/doc/hook_list_doc.py b/doc/hook_list_doc.py
new file mode 100755
index 0000000000..c22e5a5ce4
--- /dev/null
+++ b/doc/hook_list_doc.py
@@ -0,0 +1,28 @@
+from docutils import nodes
+from docutils.parsers.rst import directives
+from slash import hooks
+import gossip
+
+from sphinx.util.compat import Directive
+
+class HookListDoc(Directive):
+    has_content = False
+    required_arguments = 0
+    optional_arguments = 0
+    def run(self):
+        returned = []
+        all_hooks = []
+        for hook in sorted(gossip.get_group("slash").get_hooks(), key=lambda hook:hook.name):
+            section = nodes.section(ids=[hook.name])
+            returned.append(section)
+            title = "slash.hooks.{0}".format(hook.name)
+            args = hook.get_argument_names()
+            if args:
+                title += "({0})".format(", ".join(args))
+            section.append(nodes.title(text=title))
+            section.append(nodes.paragraph(text=hook.doc))
+        return returned
+
+def setup(app):
+    directives.register_directive('hook_list_doc', HookListDoc)
+
diff --git a/doc/hooks.rst b/doc/hooks.rst
new file mode 100755
index 0000000000..38961ab034
--- /dev/null
+++ b/doc/hooks.rst
@@ -0,0 +1,68 @@
+.. _hooks: 
+
+Hooks
+=====
+
+Slash leverages the `gossip library <http://gossip.readthedocs.org>`_ to implement hooks. Hooks are endpoints to which you can register callbacks to be called in specific points in a test session lifetime.
+
+All built-in hooks are members of the ``slash`` gossip group. As a convenience, the hook objects are all kept as globals in the :mod:`slash.hooks` module.
+
+The ``slash`` gossip group is set to be both strict (See `Gossip strict registrations <http://gossip.readthedocs.org/en/latest/advanced.html#strict-registration>`_) and has exception policy set to ``RaiseDefer`` (See `Gossip error handling <http://gossip.readthedocs.org/en/latest/error_handling.html>`_).
+
+Registering Hooks
+-----------------
+
+Hooks can be registered through :mod:`slash.hooks`:
+
+.. code-block:: python
+
+    import slash
+    
+    @slash.hooks.session_start.register
+    def handler():
+        print("Session has started: ", slash.context.session)
+
+Which is roughly equivalent to:
+
+.. code-block:: python
+
+  import gossip
+
+  @gossip.register("slash.session_start")
+  def handler():
+        print("Session has started: ", slash.context.session)
+
+Hook Errors
+-----------
+
+.. index::
+   pair: hooks; errors in
+   pair: hooks; exceptions in
+   pair: debugging; hooks
+
+By default, exceptions propagate from hooks and on to the test, but first all hooks are attempted. In some cases though you may want to debug the exception close to its raising point. Setting :ref:`conf.debug.debug_hook_handlers` to ``True`` will cause the debugger to be triggered as soon as the hook dispatcher encounteres the exception. This is done via `gossip's error handling mechanism <http://gossip.readthedocs.org/en/latest/error_handling.html>`_.
+
+Hooks and Plugins
+-----------------
+
+Hooks are especially useful in conjunction with :ref:`plugins`. By default, plugin method names correspond to hook names on which they are automatically registered upon activation.
+
+.. seealso:: :ref:`plugins`
+
+Advanced Usage
+--------------
+
+You may want to further customize hook behavior in your project. Mose of these customizations are available through ``gossip``.
+
+.. seealso:: `Advanced Usage In Gossip <http://gossip.readthedocs.org/en/latest/advanced.html>`_
+
+.. seealso:: `Hook Dependencies <http://gossip.readthedocs.org/en/latest/hook_dependencies.html>`_
+
+
+Available Hooks
+---------------
+
+The following hooks are available from the ``slash.hooks`` module:
+
+.. hook_list_doc::
+
diff --git a/doc/index.rst b/doc/index.rst
new file mode 100755
index 0000000000..e0503f1953
--- /dev/null
+++ b/doc/index.rst
@@ -0,0 +1,67 @@
+The Slash Testing Framework
+===========================
+
+What is Slash?
+--------------
+
+Slash is a testing framework written in Python. Unlike many other testing frameworks out there, Slash focuses on building in-house testing solutions for large projects. It provides facilities and best practices for testing complete products, and not only unit tests for individual modules.
+
+Slash provides several key features:
+
+* A solid execution model based on fixtures, test factories and tests. This provides you with the flexibility you need to express your testing logic.
+* Easy ways for extending the core functionality, adding more to the global execution environment and controlling how your tests interact with it.
+* A rich configuration mechanism, helping you setting up your environment parameters and their various flavours.
+* A plugin architecture, greatly simplifying adding extra functionality to your framework.
+
+Diving in
+---------
+
+As a Test Author
+~~~~~~~~~~~~~~~~
+
+If you only want to write tests for running with Slash, you should head first to the :ref:`tour` section which should help you get started.
+
+As a Framework Developer
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+If you are looking to integrate Slash into your testing ecosystem, or want to learn how to extend its functionality and adapt it to specific purposes, head to the :ref:`customizing` section.
+
+Table Of Contents
+-----------------
+
+.. toctree::
+   :maxdepth: 2
+
+   tour
+   slash_run
+   parameters
+   tags
+   fixtures
+   errors
+   customizing_slash
+   configuration
+   logging
+   details
+   hooks
+   plugins
+   builtin_plugins
+   internals
+   features
+   advanced_usage
+   cookbook
+   faq
+   api
+   changelog
+   development
+   unit_testing
+   parallel
+
+
+
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
diff --git a/doc/internals.rst b/doc/internals.rst
new file mode 100755
index 0000000000..9a2cf588cf
--- /dev/null
+++ b/doc/internals.rst
@@ -0,0 +1,65 @@
+.. _internals:
+
+Slash Internals
+===============
+
+The Result Object
+-----------------
+
+Running tests store their results in :class:`slash.core.result.Result` objects, accessible through ``slash.context.result``.
+
+In normal scenarios, tests are not supposed to directly interact with result objects, but in some cases it may come in handy.
+
+A specific example of such cases is adding additional test details using ``details```. These details are later displayed in the summary and other integrations:
+
+.. code-block:: python
+       
+       def test_something(microwave):
+           slash.context.result.details.set('microwave_version', microwave.get_version())
+
+.. seealso:: `details_`
+
+
+The Session Object
+------------------
+
+Tests are always run in a context, called **a session**. A session is used to identify the test execution process, giving it a unique id and collecting the entire state of the run.
+
+The :class:`.Session` represents the current test execution session, and contains the various state elements needed to maintain it. Since sessions also contain test results and statuses, trying to run tests without an active session will fail.
+
+The currently active session is accessible through ``slash.session``:
+
+.. code-block:: python
+
+  from slash import session
+
+  print("The current session id is", session.id)
+
+.. note:: Normally, you don't have to create slash sessions programmatically. Slash creates them for you when running tests. However, it is always possible to create sessions in an interpreter:
+
+    .. code-block:: python
+
+        from slash import Session 
+
+        ...
+        with slash.Session() as s:
+             ... # <--- in this context, s is the active session
+
+.. _test_metadata:
+
+Test Metadata
+-------------
+
+.. index::
+   single: metadata
+   couple: test; metadata
+   couple: metadata; test
+
+Each test being run contains the ``__slash__`` attribute, meant to store metadata about the test being run. The attribute is an instance of :class:`slash.core.metadata.Metadata`.
+
+.. note:: Slash does not save the actual test instance being run. This is important because in most cases dead tests contain reference to whole object graphs that need to be released to conserve memory. The only thing that is saved is the test metadata structure.
+
+Test ID
+~~~~~~~
+
+Each test has a unique ID derived from the session id and the ordinal number of the test being run. This is saved as ``test.__slash__.id`` and can be used (through property) as ``test.id``.
diff --git a/doc/logging.rst b/doc/logging.rst
new file mode 100755
index 0000000000..67c73c8857
--- /dev/null
+++ b/doc/logging.rst
@@ -0,0 +1,86 @@
+.. _logging:
+
+Logging
+=======
+
+As mentioned in :ref:`the introductory section <tour>`, logging in Slash is done by Logbook. The path to which logs are written is controlled with the ``-l`` flag and console verbosity is controlled with ``-v``/``-q``. Below are some more advanced topics which may be relevant for extending Slash's behavior.
+
+Controlling Console Colors
+--------------------------
+
+Console logs are colorized according to their level by default. This is done using Logbook's colorizing handler. In some cases you might want logs from specific sources to get colored differently. This is done using :func:`slash.log.set_log_color`:
+
+.. code-block:: python
+
+    >>> import slash.log
+    >>> import logbook
+    >>> slash.log.set_log_color('my_logger_name', logbook.NOTICE, 'red')
+
+.. note:: Available colors are taken from **logbook**. Options are "black", "darkred", "darkgreen", "brown", "darkblue", "purple", "teal", "lightgray", "darkgray", "red", "green", "yellow", "blue", "fuchsia", "turquoise", "white"
+
+.. note:: You can also colorize log fiels by setting the :ref:`conf.log.colorize` configuration variable to ``True``
+
+Controlling the Log Subdir Template
+-----------------------------------
+
+The filenames created under the root are controlled with the :ref:`conf.log.subpath` config variable, which can be also a format string receiving the *context* variable from slash (e.g. ``sessions/{context.session.id}/{context.test.id}/logfile.log``).
+
+
+Test Ordinals
+~~~~~~~~~~~~~
+
+You can use :attr:`slash.core.metadata.Metadata.test_index0` to include an ordinal prefix in log directories, for example setting :ref:`conf.log.subpath` to:: 
+
+    {context.session.id}/{context.test.__slash__.test_index0:03}-{context.test.id}.log
+
+The Session Log
+~~~~~~~~~~~~~~~
+
+Another important config path is :ref:`conf.log.session_subpath`. In this subpath, a special log file will be kept logging all records that get emitted when there's no active test found. This can happen between tests or on session start/end.
+
+The session log, by default, does not contain logs from tests, as they are redirected to test log files. However, setting the :ref:`conf.log.unified_session_log` to ``True`` will cause the session log to contain *all* logs from all tests.
+
+The Highlights Log
+~~~~~~~~~~~~~~~~~~
+
+Slash allows you to configure a separate log file to receive "highlight" logs from your sessions. This isn't necessarily related to the log level, as any log emitted can be marked as a "highlight". This is particularly useful if you have infrequent operations that you'd like to track and skim occasionally.
+
+To configure a log location for your highlight logs, set the :ref:`conf.log.highlights_subpath` configuration path. To emit a highlight log, just pass ``{'highlight': True}`` to the required log's ``extra`` dict:
+
+.. code-block:: python
+       
+   slash.logger.info("hey", extra={"highlight": True})
+
+.. tip:: The :ref:`conf.log.highlights_subpath` configuration path is treated just like other logging subpaths, and thus supports all substitutions and formatting mentioned above
+
+.. note:: All errors emitted in a session are automatically added to the highlights log
+
+
+Last Log Symlinks
+-----------------
+
+Slash can be instructed to maintain a symlink to recent logs. This is useful to quickly find the last test executed and dive into its logs.
+
+ *  To make slash store a symlink to the last session log file, use :ref:`conf.log.last_session_symlink`
+ *  To make slash store a symlink to the last session log directory, use :ref:`conf.log.last_session_dir_symlink`
+ *  To make slash store a symlink to the last session log file, use :ref:`conf.log.last_test_symlink`
+ *  To make slash store a symlink to the last session log file, use :ref:`conf.log.last_failed_symlink`
+
+
+Both parameters are strings pointing to the symlink path. In case they are relative paths, they will be computed relative to the log root directory (see above).
+
+The symlinks are updated at the beginning of each test run to point at the recent log directory.
+
+Silencing Logs
+--------------
+
+In certain cases you can silence specific loggers from the logging output. This is done with the :ref:`conf.log.silence_loggers` config path::
+
+  slash run -i -o "log.silence_loggers=['a','b']"
+
+Changing Formats
+----------------
+
+The :ref:`conf.log.format` config path controls the log line format used by slash::
+
+    $ slash run -o log.format="[{record.time:%Y%m%d}]- {record.message}" ...
diff --git a/doc/parallel.rst b/doc/parallel.rst
new file mode 100755
index 0000000000..7ca7402c2f
--- /dev/null
+++ b/doc/parallel.rst
@@ -0,0 +1,69 @@
+.. _parallel:
+
+Parallel Test Execution
+=======================
+
+.. index::
+   single: parallel
+   double: parallel; test execution
+
+By default, Slash runs tests sequentially through a single session
+process. However, it is also possible to use Slash to run tests in
+parallel. In this mode, slash will run a 'parent' session process that will be
+used to distribute the tests, and a number of child session processes
+that will receive the distributed tests and run them.
+
+
+Running in Parallel Mode
+------------------------
+
+In order to run tests in parallel, just add ``--parallel`` and the number of workers you want to start. For example::
+
+  $ slash run /path/to/tests --parallel 4
+
+If, for instance, most of your tests are CPU-bound, it would make
+sense to run them like this::
+
+  $ slash run /path/to/tests --parallel $(nproc)
+
+to use a single worker per CPU core.
+
+.. note:: The parallel mechanism works by listening on a local TCP
+          socket, to which the worker session processes connect and
+          receive test descriptions via RPC. In case you want, you can
+          control the address and/or port settings via the
+          ``--parallel-addr`` and ``--parallel-port`` command-line arguments.
+
+By default, only the paerent session process outputs logs to the
+console. For a more controlled run you can use ``tmux`` to run your
+workers, so that you can examine their outputs::
+
+  $ slash run /path/to/tests --parallel 4 --tmux  [--tmux-panes]
+
+If ``--tmux-panes`` is specified, a new pane will be opened for every worker, letting it
+emit console output. Otherwise each worker will open a new window.
+
+
+The Parallel Execution Mechanism
+--------------------------------
+
+When running Slash in parallel mode, the main process starts a server and a number of workers as new processes.
+The server then waits until all the workers connect and start collecting tests.
+Only after all the workers connect and validate that all of them collected the same tests collection, the test execution will start:
+
+* Each worker asks the master process for a test.
+* The master process gives them one test to execute.
+* The worker executes the test and reports the test's results to the parent.
+* The worker asks for the next test and so on, until all tests are executed.
+* The worker processes disconnect from the server, and the server
+  terminates.
+
+Worker session ids
+-------------------
+
+Each worker will have a session_id that starts with the servers' session_id, and ends with it's client_id.
+
+For example, if the server's session_id is 496272f0-66dd-11e7-a4f0-00505699924f_0 and there are 2 workers, their session ids will be:
+
+* 496272f0-66dd-11e7-a4f0-00505699924f_1
+* 496272f0-66dd-11e7-a4f0-00505699924f_2
diff --git a/doc/parameters.rst b/doc/parameters.rst
new file mode 100755
index 0000000000..e2a315bd41
--- /dev/null
+++ b/doc/parameters.rst
@@ -0,0 +1,124 @@
+.. _parameters:
+
+Test Parametrization
+====================
+
+Using slash.parametrize
+-----------------------
+
+Use the :func:`slash.parametrize` decorator to multiply a test function for different parameter values:
+
+.. code-block:: python
+       
+       @slash.parametrize('x', [1, 2, 3])
+       def test_something(x):
+           pass
+
+The above example will yield 3 test cases, one for each value of ``x``. Slash also supports parametrizing the ``before`` and ``after`` methods of test classes, thus multiplying each case by several possible setups:
+
+.. code-block:: python
+
+    class SomeTest(Test):
+        @slash.parametrize('x', [1, 2, 3])
+	def before(self, x):
+            # ...
+
+        @slash.parametrize('y', [4, 5, 6])
+	def test(self, y):
+            # ...
+
+        @slash.parametrize('z', [7, 8, 9])
+	def after(self, z):
+            # ...
+
+The above will yield 27 different runnable tests, one for each cartesian product of the ``before``, ``test`` and ``after`` possible parameter values.
+
+This also works across inheritence. Each base class can parametrize its `before` or `after` methods, multiplying the number of variations actually run accordingly. Calls to `super` are handled automatically in this case:
+
+.. code-block:: python
+
+    class BaseTest(Test):
+
+        @slash.parametrize('base_parameter', [1, 2, 3])
+        def before(self, base_parameter):
+            # ....
+
+    class DerivedTest(BaseTest):
+        
+        @slash.parametrize('derived_parameter', [4, 5, 6])
+        def before(self, derived_parameter):
+            super(DerivedTest, self).before() # note that base parameters aren't specified here
+            # .....
+
+
+More Parametrization Shortcuts
+------------------------------
+
+In addition to :func:`slash.parametrize`, Slash also supports :func:`slash.parameters.toggle <slash.core.fixtures.parameters.toggle>` as a shortcut for toggling a boolean flag in two separate cases:
+
+.. code-block:: python
+
+		@slash.parameters.toggle('with_safety_switch')
+		def test_operation(with_safety_switch):
+		    ...
+
+Another useful shortcut is :func:`slash.parameters.iterate <slash.core.fixtures.parameters.iterate>`, which is an alternative way to specify parametrizations:
+
+.. code-block:: python
+       
+		@slash.parameters.iterate(x=[1, 2, 3], y=[4, 5, 6])
+		def test_something(x, y):
+		    ...
+
+
+
+Specifying Multiple Arguments at Once
+-------------------------------------
+
+You can specify dependent parameters in a way that forces them to receive related values, instead of a simple cartesian product:
+
+.. code-block:: python
+       
+       @slash.parametrize(('fruit', 'color'), [('apple', 'red'), ('apple', 'green'), ('banana', 'yellow')])
+       def test_fruits(fruit, color):
+           ... # <-- this never gets a yellow apple
+
+Excluding Parameter Values
+--------------------------
+
+.. index::
+   single: exclude
+   single: slash.exclude
+
+
+You can easily skip specific values from parametrizations in tests through ``slash.exclude``:
+
+.. code-block:: python
+       
+       import slash
+
+       SUPPORTED_SIZES = [10, 15, 20, 25]
+
+       @slash.parametrize('size', SUPPORTED_SIZES)
+       @slash.exclude('size', [10, 20])
+       def test_size(size): # <-- will be skipped for sizes 10 and 20
+           ...
+
+This also works for parameters of fixtures (for more information about fixtures see :ref:`the fixtures chapter <fixtures>`)
+
+.. code-block:: python
+       
+       import slash
+
+       SUPPORTED_SIZES = [10, 15, 20, 25]
+
+       @slash.exclude('car.size', [10, 20])
+       def test_car(car):
+           ...
+
+       @slash.parametrize('size', SUPPORTED_SIZES)
+       @slash.fixture
+       def car(size): # <-- will be skipped for sizes 10 and 20
+           ...
+
+
diff --git a/doc/pip_requirements.txt b/doc/pip_requirements.txt
new file mode 100755
index 0000000000..5a3296ced2
--- /dev/null
+++ b/doc/pip_requirements.txt
@@ -0,0 +1,5 @@
+# These are needed to build the documentation
+-e .
+releases
+alabaster
+Sphinx>1.4
diff --git a/doc/plugins.rst b/doc/plugins.rst
new file mode 100755
index 0000000000..b3a9f92690
--- /dev/null
+++ b/doc/plugins.rst
@@ -0,0 +1,244 @@
+.. _plugins:
+
+Plugins
+=======
+
+.. index::
+   single: plugins
+
+Plugins are a comfortable way of extending Slash's behavior. They are objects inheriting from a :class:`common base class <.PluginInterface>` that can be activated to modify or what happens in select point of the infrastructure. 
+
+The Plugin Interface
+--------------------
+
+Plugins have several special methods that can be overriden, like :func:`get_name <slash.plugins.PluginInterface.get_name>` or :func:`configure_argument_parser <slash.plugins.PluginInterface.configure_argument_parser>`. Except for these methods and the ones documented, each public method (i.e. a method not beginning with an underscore) must correspond to a :ref:`slash hook <hooks>` by name. 
+
+The name of the plugin should be returned by :func:`get_name <slash.plugins.PluginInterface.get_name>`. This name should be unique, and not shared by any other plugin.
+
+Plugin Discovery
+----------------
+
+Plugins can be loaded from multiple locations. 
+
+Search Paths
+~~~~~~~~~~~~
+
+First, the paths in ``plugins.search_paths`` are searched for python files. For each file, a function called ``install_plugins`` is called (assuming it exists), and this gives the file a chance to install its plugins.
+
+
+Plugin Installation
+-------------------
+
+To install a plugin, use the :func:`slash.plugins.manager.install <slash.plugins.PluginManager.install>` function, and pass it the plugin class that is being installed. Note that installed plugins are not active by default, and need to be explicitly activated (see below).
+
+Only plugins that are :class:`.PluginInterface` derivative instances are accepted.
+
+To uninstall plugins, you can use the :func:`slash.plugins.manager.uninstall <slash.plugins.PluginManager.uninstall>`. 
+
+.. note:: uninstalling plugins also deactivates them.
+
+
+Internal Plugins
+~~~~~~~~~~~~~~~~
+
+.. index::
+   pair: plugins; internal
+
+By default, plugins are considered "external", meaning they were
+loaded by the user (either directly or indirectly). External plugins
+can be activated and deactivated through the command-line using
+``--with-<plugin name>`` and ``--without-<plugin name>``.
+
+In some cases, though, you may want to install a plugin in a way that
+would not let the user disable it externally. Such plugins are
+considered "internal", and cannot be deactivated through the command
+line. 
+
+You can install a plugin as an internal plugin by passing ``internal=True`` to the install function.
+
+Plugin Activation
+-----------------
+
+Plugins are activated via :func:`slash.plugins.manager.activate <slash.plugins.PluginManager.activate>` and deactivated via :func:`slash.plugins.manager.deactivate <slash.plugins.PluginManager.deactivate>`.
+
+During the activation all hook methods get registered to their respective hooks, so any plugin containing an unknown hook will trigger an exception.
+
+.. note:: by default, all method names in a plugin are assumed to belong to the *slash* gossip group. This means that the method ``session_start`` will register on ``slash.session_start``. You can override this behavior by using :func:`slash.plugins.registers_on`:
+  
+  .. code-block:: python
+
+     from slash.plugins import registers_on
+     
+     class MyPlugin(PluginInterface):
+         @registers_on('some_hook')
+         def func(self):
+             ...
+
+
+``registers_on(None)`` has a special meaning - letting Slash know that this is not a hook entry point, but a private method belonging to the plugin class itself.
+
+.. seealso:: :ref:`hooks`
+
+
+Activating plugins from command-line is usually done with the ``--with-`` prefix. For example, to activate a plugin called ``test-plugin``, you can pass ``--with-test-plugin`` when running ``slash run``. 
+
+Also, since some plugins can be activated from other locations, you can also override and deactivate plugins using ``--without-X`` (e.g. ``--without-test-plugin``).
+
+Conditionally Registering Hooks
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+You can make the hook registration of a plugin *conditional*, meaning it should only happen if a boolean condition is ``True``.
+
+This can be used to create plugins that are compatible with multiple versions of Slash:
+
+.. code-block:: python
+       
+       class MyPlugin(PluginInterface):
+           ...
+           @slash.plugins.register_if(int(slash.__version__.split('.')[0]) >= 1)
+           def shiny_new_hook(self):
+	       ...
+
+.. seealso:: :func:`slash.plugins.register_if`
+
+Plugin Command-Line Interaction
+-------------------------------
+
+In many cases you would like to receive options from the command line. Plugins can implement the :func:`configure_argument_parser <slash.plugins.PluginInterface.configure_argument_parser>` and the :func:`configure_parsed_args <slash.plugins.PluginInterface.configure_from_parsed_args>` functions:
+
+.. code-block:: python
+
+ class ResultsReportingPlugin(PluginInterface):
+ 
+     def configure_argument_parser(self, parser):
+         parser.add_argument("--output-filename", help="File to write results to")
+ 
+     def configure_from_parsed_args(self, args):
+         self.output_filename = args.output_filename
+
+Plugin Configuration
+--------------------
+
+Plugins can override the :func:`config <slash.plugins.PluginInterface.get_default_config>` method to provide configuration to be placed under ``plugin_config.<plugin name>``:
+
+.. code-block:: python
+
+ class LogCollectionPlugin(PluginInterface):
+
+     def get_default_config(self):
+         return {
+             'log_destination': '/some/default/path'
+         }
+
+The configuration is then accessible with :func:`get_current_config <slash.plugins.PluginInterface.current_config>` property.
+
+Plugin Examples
+---------------
+
+An example of a functioning plugin can be found in the :ref:`customizing` section.
+
+Errors in Plugins
+-----------------
+
+As more logic is added into plugins it becomes more likely for exceptions to occur when running their logic. As seen above, most of what plugins do is done by registering callbacks onto hooks. Any exception that escapes these registered functions will be handled the same way any exception in a hook function is handled, and this depends on the current exception swallowing configuration.
+
+.. seealso:: 
+
+   * :ref:`exception swallowing <exception_swallowing>`
+   * :ref:`hooks documentation <hooks>`
+
+
+Plugin Dependencies
+-------------------
+
+Slash supports defining dependencies between plugins, in a mechanism closely related to to `gossip's hook dependencies <http://gossip.readthedocs.org/en/latest/hook_dependencies.html>`_. The purpose of these dependencies is to make sure a certain hook registration in a specific plugin (or all such hooks for that matter) is called before or after equivalent hooks on other plugins.
+
+Notable examples of why you might want this include, among many other cases:
+
+* Plugins reporting test status needing a state computed by other plugins
+* Error handling plugins wanting to be called first in certain events
+* Log collection plugins wanting to be called only after all interesting code paths are logged
+
+
+Defining Plugin Dependencies
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Defining dependencies is done primarily with two decorators Slash
+provides: ``@slash.plugins.needs`` and
+``@slash.plugins.provides``. Both of these decorators use string
+identifiers to denote the dependencies used. These identifiers are
+arbitrary, and can be basically any string, as long as it matches
+between the dependent plugin and the providing plugin.
+
+Several use cases exist:
+
+Hook-Level Dependencies
++++++++++++++++++++++++
+
+Adding the ``slash.plugins.needs`` or ``slash.plugins.provides``
+decorator to a specific hook method on a plugin indicates that we
+would like to depend on or be the dependency accordingly. For example:
+
+.. code-block:: python
+       
+       class TestIdentificationPlugin(PluginInterface):
+
+           @slash.plugins.provides('awesome_test_id')
+           def test_start(self):
+	       slash.context.test.awesome_test_id = awesome_id_allocation_service()
+
+       class TestIdentificationLoggingPlugin(PluginInterface):
+
+           @slash.plugins.needs('awesome_test_id')
+           def test_start(self):
+	       slash.logger.debug('Test has started with the awesome id of {!r}', slash.context.test.awesome_id)
+
+In the above example, the ``test_start`` hook on
+``TestIdentificationLoggingPlugin`` needs the ``test_start`` of
+``TestIdentificationPlugin`` to be called first, and thus **requires**
+the ``'awesome_test_id'`` identifier which is provided by the latter.
+
+
+Plugin-Level Dependencies
++++++++++++++++++++++++++
+
+Much like hook-level dependencies, you can decorate the entire plugin
+with the ``needs`` and ``provides`` decorators, creating a dependency
+on all hooks provided by the plugin:
+
+.. code-block:: python
+       
+       @slash.plugins.provides('awesome_test_id')
+       class TestIdentificationPlugin(PluginInterface):
+
+           def test_start(self):
+	       slash.context.test.awesome_test_id = awesome_id_allocation_service()
+
+       @slash.plugins.needs('awesome_test_id')
+       class TestIdentificationLoggingPlugin(PluginInterface):
+
+           def test_start(self):
+	       slash.logger.debug('Test has started with the awesome id of {!r}', slash.context.test.awesome_id)
+
+The above example is equivalent to the previous one, only now future
+hooks added to either of the plugins will automatically assume the
+same dependency specifications.
+
+.. note:: You can use ``provides`` and ``needs`` in more complex
+          cases, for example specifying ``needs`` on a specific hook
+          in one plugin, where the entire other plugin is decorated
+          with ``provides`` (at plugin-level). 
+
+.. note:: Plugin-level provides and needs also get transferred upon
+          inheritence, automatically adding the dependency
+          configuration to derived classes.
+
+
+Plugin Manager
+--------------
+
+As mentioned above, the Plugin Manager provides API to activate (or deacativate) and install (or uninstall) plugins.
+Additionally, it provides access to instances of registered plugins by their name via :func:`slash.plugins.manager.get_plugin <slash.plugins.PluginManager.get_plugin>`.
+This could be used to access plugin attributes whose modification (e.g. by fixtures) can alter the plugin's behavior.
+
+..  LocalWords:  plugins Plugin plugin inheritence
diff --git a/doc/slash_run.rst b/doc/slash_run.rst
new file mode 100755
index 0000000000..404728fd09
--- /dev/null
+++ b/doc/slash_run.rst
@@ -0,0 +1,98 @@
+.. _slash_run:
+
+A Closer Look at ``slash run``
+==============================
+
+The main front-end for Slash is the ``slash run`` utility, invoked from the command line. It has several interesting options worth mentioning.
+
+By default, it receives the path to load and run tests from::
+
+  $ slash run /path/to/tests
+
+Verbosity
+---------
+
+Verbosity is increased with ``-v`` and decreased with ``-q``. Those can be specified multiple times.
+
+In addition to the verbosity itself, tracebacks which are displayed at the session summary can be controlled via tha ``--tb`` flag, specifying the verbosity level of the tracebacks. ``0`` means no tracebacks, while ``5`` means the highest detail available.
+
+.. seealso:: :ref:`logging`
+
+Loading Tests from Files
+------------------------
+
+You can also read tests from file or files which contain paths to run. Whitespaces and lines beginning with a comment ``#`` will be ignored::
+
+  $ slash run -f file1.txt -f file2.txt
+
+Lines in suite files can optionally contain filters and repeat directive.
+
+Filter allows restricting the tests actually loaded from them::
+
+  # my_suite_file.txt
+  # this is the first test file
+  /path/to/tests.py
+  # when running the following file, tests with "dangerous" in their name will not be loaded
+  /path/to/other_tests.py # filter: not dangerous
+
+.. seealso:: The filter syntax is exactly like ``-k`` described below
+
+Repeat allows to repeat a line::
+
+  # my_suite_file.txt
+  # the next line will be repeated twice
+  /path/to/other_tests.py # repeat: 2
+  # you can use filter and repeat together
+  /path/to/other_tests.py # filter: not dangerous, repeat: 2
+
+
+Debugging & Failures
+--------------------
+
+Debugging is done with ``--pdb``, which invokes the best debugger available.
+
+Stopping at the first unsuccessful test is done with the ``-x`` flag.
+
+
+.. seealso:: :ref:`exceptions`
+
+
+
+Including and Excluding Tests
+-----------------------------
+
+The ``-k`` flag to ``slash run`` is a versatile way to include or exclude tests. Provide it with a substring to only run tests containing the substring in their names::
+
+  $ slash run -k substr /path/to/tests
+
+Use ``not X`` to exclude any test containing **X** in their names::
+
+  $ slash run -k 'not failing_' /path/to/tests
+
+Or use a more complex expression involving ``or`` and ``and``::
+
+  $ slash run -k 'not failing_ and components' /path/to/tests
+
+The above will run all tests with ``components`` in their name, but without ``failing_`` in it.
+
+Overriding Configuration
+------------------------
+
+The ``-o`` flag enables us to override specific paths in the configuration, properly converting their respective types::
+
+  $ slash run -o path.to.config.value=20 ...
+
+
+
+.. seealso:: configuration
+
+
+Resuming Previous Sessions
+--------------------------
+
+When you run a session that fails, Slash automatically saves the tests intended to be run for later reference. For quickly retrying a previously failed session, skipping tests which had already passed, you can use ``slash resume``::
+
+  $ slash resume -vv <session id>
+
+This command receives all flags which can be passed to ``slash run``, but receives an id of a previously run session for resuming.
+
diff --git a/doc/tags.rst b/doc/tags.rst
new file mode 100755
index 0000000000..14a627a910
--- /dev/null
+++ b/doc/tags.rst
@@ -0,0 +1,58 @@
+Test Tags
+=========
+
+
+Tagging Tests
+-------------
+
+Slash supports organizing tests by tagging them. This is done using the :func:`slash.tag` decorator:
+
+.. code-block:: python
+       
+       @slash.tag('dangerous')
+       def test_something():
+           ...
+
+You can also have tag decorators prepared in advance for simpler usage:
+
+.. code-block:: python
+       
+       dangerous = slash.tag('dangerous')
+
+       ...
+
+       @dangerous
+       def test_something():
+           ...
+
+Tags can also have values:
+
+.. code-block:: python
+       
+       @slash.tag('covers', 'requirement_1294')
+       def test_something():
+           ...
+
+
+Filtering Tests by Tags
+-----------------------
+
+When running tests you can select by tags using the ``-k`` flag. A simple case would be matching a tag substring (the same way the test name is matched::
+
+  $ slash run tests -k dangerous
+
+This would work, but will also select tests whose names contain the word 'dangerous'. Prefix the argument with ``tag:`` to only match tags::
+
+  $ slash run tests -k tag:dangerous
+
+Combined with the regular behavior of ``-k`` this yields a powrful filter::
+
+  $ slash run tests -k 'microwave and power and not tag:dangerous'
+
+Filtering by value is also supported::
+
+  $ slash run test -k covers=requirement_1294
+
+Or::
+
+  $ slash run test -k tag:covers=requirement_1294
diff --git a/doc/tour.rst b/doc/tour.rst
new file mode 100755
index 0000000000..636f40b57d
--- /dev/null
+++ b/doc/tour.rst
@@ -0,0 +1,264 @@
+Whirlwind Tour of Slash
+=======================
+
+.. _tour:
+
+Writing Tests
+-------------
+
+Slash loads and runs tests from Python files. To get started, let's create an example test file and name it ``test_addition.py``:
+
+.. code-block:: python
+
+		# test_addition.py
+
+		import slash
+
+		def test_addition():
+		    pass
+
+As you can see in the above example, Slash can load tests written as functions. Simlarly to ``unittest`` and ``py.test``, only functions starting with the prefix ``test_`` are assumed to be runnable tests.
+
+Running Tests
+-------------
+
+Once we have our file written, we can run it using ``slash run``::
+
+  $ slash run test_addition.py
+
+There's a lot to cover regarding ``slash run``, and we will get to it :ref:`soon enough <slash_run>`. For now all we have to know is that it finds, loads and runs the tests in the files or directories we provide, and reports the result.
+
+A single run of ``slash run`` is called a *session*. A session contains tests that were run in its duration.
+
+Debugging
+~~~~~~~~~
+
+You can debug failing tests using the ``--pdb`` flag, which automatically runs the best available debugger on exceptions. 
+
+.. seealso:: :ref:`exceptions`
+
+
+Assertions and Errors
+---------------------
+
+Tests don't do much without making sure things are like they expect. Slash borrows the awesome technology behind ``py.test``, allowing us to just write assert statements where we want to test conditions of all sorts:
+
+.. code-block:: python
+
+		# test_addition.py
+
+		def test_addition():
+		    assert 2 + 2 == 4
+
+Slash also analyzes assertions using assertion rewriting borrowed from the `pytest project <http://pytest.org>`_, so you can get more details as for what exactly failed.
+
+.. seealso:: errors
+
+Test Parameters
+---------------
+
+Slash tests can be easily parametrized, iterating parameter values and creating separate cases for each value:
+
+.. code-block:: python
+
+   @slash.parametrize('x', [1, 2, 3])
+   def test_something(x):
+       # use x here
+
+For boolean values, a shortcut exists for toggling between ``True`` and ``False``:
+
+.. code-block:: python
+       
+   @slash.parameters.toggle('with_power_operator')
+   def test_power_of_two(with_power_operator):
+       num = 2
+       if with_power_operator:
+           result = num ** 2
+       else:
+           result = num * num
+       assert result == 4
+
+.. seealso:: :ref:`parameters`
+
+Logging
+-------
+
+Testing complete products usually means you may not have a second chance to reproduce an issue. This is why Slash puts a strong emphasis on logging, managing log files and directories, and fine tuning your logging setup.
+
+Slash uses `Logbook <http://logbook.pocoo.org>`_ for logging. It has many advantages over Python's own ``logging`` package, and is much more flexible.
+
+Slash exposes a global logger intended for tests, which is recommended for use in simple logging tasks:
+
+.. code-block:: python
+
+ import slash
+
+ def test_1():
+     slash.logger.debug("Hello!")
+
+
+Console Log
+~~~~~~~~~~~
+
+.. index:: 
+   pair: console; log
+   pair: log; console
+   
+
+By default logs above **WARNING** get emitted to the console when ``slash run`` is executed. You can use **-v**/**-q** to increase/decrease console verbosity accordingly.
+
+Saving Logs to Files
+~~~~~~~~~~~~~~~~~~~~
+
+By default logs are not saved anywhere. This is easily changed with the *-l* flag to ``slash run``. Point this flag to a directory, and Slash will organize logs inside, in subdirectories according to the session and test run (e.g. ``/path/to/logdir/<session id>/<test id>/debug.log``). 
+
+.. seealso:: :ref:`logging`
+
+
+.. _cleanups:
+
+Cleanups
+--------
+
+Slash provides a facility for cleanups. These get called whenever a test finishes, successfully or not. Adding cleanups is done with :func:`slash.add_cleanup`:
+
+.. code-block:: python
+
+	    def test_product_power_on_sequence():
+	        product = ...
+		product.plug_to_outlet()
+		slash.add_cleanup(product.plug_out_of_outlet)
+		product.press_power()
+		slash.add_cleanup(product.wait_until_off)
+		slash.add_cleanup(product.press_power)
+		slash.add_cleanup(product.pack_for_shipping, success_only=True)
+		product.wait_until_on()
+
+.. note:: When a test is interrupted, most likely due to a ``KeyboardInterrupt``, cleanups are not called unless added with the ``critical`` keyword argument. This is in order to save time during interruption handling. See :ref:`interruptions <KeyboardInterrupt>`.
+
+.. note:: A cleanup added with ``success_only=True`` will be called only if the test ends successfully
+
+Cleanups also receive an optional ``scope`` parameter, which can be either ``'session'``, ``'module'`` or ``'test'`` (the default). The ``scope`` parameter controls *when* the cleanup should take place. *Session* cleanups happen at the end of the test session, *module* cleanups happen before Slash switches between test files during execution and *test* cleanups happen at the end of the test which added the cleanup callback.
+
+Skips
+-----
+
+.. index::
+   pair: tests; skipping
+   pair: skipping; tests
+
+In some case you want to skip certain methods. This is done by raising the :class:`.SkipTest` exception, or by simply calling :func:`slash.skip_test` function:
+
+.. code-block:: python
+
+   def test_microwave_has_supercool_feature():
+       if microwave.model() == "Microtech Shitbox":
+           slash.skip_test("Microwave model too old")
+
+Slash also provides :func:`slash.skipped`, which is a decorator to skip specific tests:
+
+.. code-block:: python
+
+     @slash.skipped("reason")
+     def test_1():
+         # ...
+
+     @slash.skipped # no reason
+     def test_2():
+         # ...
+
+In some cases you may want to register a custom exception to be recognized as a skip. You can do this by registering your exception type first with :func:`slash.register_skip_exception`.
+
+.. _requirements:
+
+Requirements
+------------
+
+.. index::
+   single: requirements
+
+In many cases you want to depend in our test on a certain precondition in order to run. Requirements provide an explicit way of stating those requirements. Use :func:`slash.requires` to specify requirements:
+
+.. code-block:: python
+
+
+  def is_some_condition_met():
+      return True
+		
+  @slash.requires(is_some_condition_met)
+  def test_something():
+      ...
+
+Requirements are stronger than skips, since they can be reported separately and imply a basic precondition that is not met in the current testing environment. 
+
+``slash.requires`` can receive either:
+
+1. A boolean value (useful for computing on import-time)
+2. A function returning a boolean value, to be called when loading tests
+3. A function returning a tuple of (boolean, message) - the message being the description of the unmet requirements when ``False`` is returned
+
+When a requirement fails, the test is skipped without even being started, and appears in the eventual console summary along with the unmet requirements. If you want to control the message shown if the requirement is not met, you can pass the ``message`` parameter:
+
+.. code-block:: python
+       
+  @slash.requires(is_some_condition_met, message='My condition is not met!')
+  def test_something():
+      ...
+
+
+.. note::
+   Requirements are evaluated during the load phase of the tests, so they are usually checked before any test started running. This means that if you're relying on a transient state that can be altered by other tests, you have to use skips instead. Requirements are useful for checking environmental constraints that are unlikely to change as a result of the session being run.
+
+Warnings
+--------
+
+In many cases test executions succeed, but warnings are emitted. These warnings can mean a lot of things, and in some cases even invalidate the success of the test completely.
+
+Slash collects warnings emitted throughout the session in the form of either *warning logs* or the *native warnings mechanism*. The warnings are recorded in the ``session.warnings`` (instance of :class:`.warnings.SessionWarnings`) component, and cause the ``warning_added`` hook to be fired.
+
+
+Storing Additional Test Details
+-------------------------------
+
+It is possible for a test to store some objects that may help investigation in cause of failure.
+
+This is possible using the :func:`slash.set_test_detail` method. This method accepts a hashable key object and a printable object. In case the test fails, the stored objects will be printed in the test summary:
+
+.. code-block:: python
+
+    def test_one():
+        slash.set_test_detail('log', '/var/log/foo.log')
+        slash.set_error("Some condition is not met!")
+
+    def test_two():
+        # Every test has its own unique storage, so it's possible to use the same key in multiple tests
+        slash.set_test_detail('log', '/var/log/bar.log')
+
+In this case we probably won't see the details of test_two, as it should finish successfully.
+
+.. autofunction:: slash.set_test_detail
+
+
+.. _global_state:
+
+Global State
+------------
+
+Slash maintains a set of globals for convenience. The most useful one is ``slash.g``, which is an attribute holder that can be used to hold environment objects set up by plugins or hooks for use in tests.
+
+
+Misc. Utilities
+---------------
+
+Repeating Tests
+~~~~~~~~~~~~~~~
+
+Use the :func:`slash.repeat` decorator to make a test repeat several times:
+
+.. code-block:: python
+       
+       @slash.repeat(5)
+       def test_probabilistic():
+           assert still_works()
+
+.. note:: You can also use the ``--repeat-each=X`` argument to `slash run`, causing it to repeat each test being loaded a specified amount of times, or ``--repeat-all=X`` to repeat the entire suite several times
diff --git a/doc/transparent.png b/doc/transparent.png
new file mode 100755
index 0000000000..427fb75b86
Binary files /dev/null and b/doc/transparent.png differ
diff --git a/doc/unit_testing.rst b/doc/unit_testing.rst
new file mode 100755
index 0000000000..ef87299294
--- /dev/null
+++ b/doc/unit_testing.rst
@@ -0,0 +1,134 @@
+.. _unit_testing:
+
+Unit Testing Slash
+==================
+
+The following information is intended for anyone interested in developing Slash or adding new features, explaining how to effectively use the unit testing facilities used to test Slash itself.
+
+
+The Suite Writer
+----------------
+
+The unit tests use a dedicated mechanism allowing creating a virtual test suite, and then easily writing it to a real directory, run it with Slash, and introspect the result.
+
+The suite writer is available from ``tests.utils.suite_writer``:
+
+.. code-block:: python
+       
+       >>> from tests.utils.suite_writer import Suite
+       >>> suite = Suite()
+
+
+Basic Usage
+~~~~~~~~~~~
+
+Add tests by calling ``add_test()``. By default, this will pick a different test type (function/method) every time.
+
+.. code-block:: python
+       
+       >>> for i in range(10):
+       ...     test = suite.add_test()
+
+The created **test object** is not an actual test that can be run by Slash -- it is an object representing a future test to be created. The test can later be manipulated to perform certain actions when run or to expect things when run.
+
+The simplest thing we can do is run the suite:
+
+.. code-block:: python
+       
+       >>> summary = suite.run()
+       >>> len(summary.session.results)
+       10
+       >>> summary.ok()
+       True
+
+We can, for example, make our test raise an exception, thus be considered an error:
+
+.. code-block:: python
+       
+       >>> test.when_run.raise_exception()
+
+Noe let's run the suite again (it will commit itself to a new path so we can completely diregard the older session):
+
+.. code-block:: python
+       
+       >>> summary = suite.run()
+       >>> summary.session.results.get_num_errors()
+       1
+       >>> summary.ok()
+       False
+
+The suite writer already takes care of verifying that the errored test is actually reported as error and fails the run.
+
+
+Adding Parameters
+~~~~~~~~~~~~~~~~~
+
+To test parametrization, the suite write supports adding parameters and fixtures to test. First we will look at parameters (translating into ``@slash.parametrize`` calls):
+
+.. code-block:: python
+
+       >>> suite.clear()
+       >>> test = suite.add_test()
+       >>> p = test.add_parameter()
+       >>> len(p.values)
+       3
+       >>> suite.run().ok()
+       True
+
+Adding Fixtures
+~~~~~~~~~~~~~~~
+
+Fixtures are slightly more complex, since they have to be added to a file first. You can create a fixture at the file level:
+
+.. code-block:: python
+
+       >>> suite.clear()
+       >>> test = suite.add_test()
+
+       >>> f = test.file.add_fixture()
+       >>> _ = test.depend_on_fixture(f)
+       >>> suite.run().ok()
+       True
+
+Fixtures can also be added to the ``slashconf`` file:
+
+.. code-block:: python
+       
+       >>> f = suite.slashconf.add_fixture()
+
+Fixtures can depend on each other and be parametrized:
+
+.. code-block:: python
+       
+       >>> suite.clear()
+       >>> f1 = suite.slashconf.add_fixture()
+       >>> test = suite.add_test()
+       >>> f2 = test.file.add_fixture()
+       >>> _ = f2.depend_on_fixture(f1)
+       >>> _ = test.depend_on_fixture(f2)
+       >>> p = f1.add_parameter()
+       >>> summary = suite.run()
+       >>> summary.ok()
+       True
+       >>> len(summary.session.results) == len(p.values)
+       True
+
+You can also control the fixture scope:
+
+.. code-block:: python
+       
+       >>> f = suite.slashconf.add_fixture(scope='module')
+       >>> _ = suite.add_test().depend_on_fixture(f)
+       >>> suite.run().ok()
+       True
+
+And specify autouse (or implicit) fixtures:
+
+.. code-block:: python
+       
+       >>> suite.clear()
+       >>> f = suite.slashconf.add_fixture(scope='module', autouse=True)
+       >>> t = suite.add_test()
+       >>> suite.run().ok()
+       True
+
diff --git a/pytest.ini b/pytest.ini
new file mode 100755
index 0000000000..1ffb27bbbd
--- /dev/null
+++ b/pytest.ini
@@ -0,0 +1,4 @@
+[pytest]
+#timeout = 20
+timeout_method = signal
+addopts = --disable-pytest-warnings
diff --git a/requirements.txt b/requirements.txt
new file mode 100755
index 0000000000..e7f8ea5267
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,24 @@
+ptyprocess; implementation_name=='pypy' and python_version<'2.7'
+
+arrow
+colorama
+confetti>=2.4.1
+dessert>=1.3.1
+emport>=1.1.3
+gossip>=2.2.0
+Jinja2
+Logbook>=1.1.0
+orderedset>=2.0.0
+requests>=1.1.0
+SQLAlchemy
+tmuxp
+raven
+py>=1.5.0
+pyparsing
+vintage>=0.4.0
+
+IPython==1.2.1; implementation_name=='pypy'
+IPython==5.*; implementation_name!='pypy' and python_version < '3.3'
+IPython; implementation_name!='pypy' and python_version >= '3.3'
+
+contextlib2; python_version<'3.3'
diff --git a/scripts/build_test_dir.py b/scripts/build_test_dir.py
new file mode 100755
index 0000000000..f8599039d7
--- /dev/null
+++ b/scripts/build_test_dir.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python
+import argparse
+import sys
+
+import random
+
+from tests.utils.suite_writer import Suite
+
+parser = argparse.ArgumentParser(usage="%(prog)s [options] args...")
+parser.add_argument('--fixtures', dest='use_fixtures', action='store_true', default=False)
+parser.add_argument('--parameters', dest='use_parameters', action='store_true', default=False)
+parser.add_argument('--debug-info', dest='debug_info', action='store_true', default=False)
+parser.add_argument("dir")
+parser.add_argument("summary")
+
+_FIXTURE_FREQ = 3
+_PARAM_FREQ = 4
+
+class Application(object):
+
+    _INDENT = " " * 4
+
+    def __init__(self, args):
+        self._args = args
+
+    def main(self):
+
+        s = Suite(path=self._args.dir, debug_info=self._args.debug_info)
+        if not self._args.summary:
+            parser.error("No summary given")
+        for index, element in enumerate(self._args.summary):
+            t = s.add_test()
+            if self._args.use_fixtures and index % _FIXTURE_FREQ == 0:
+                if index % 2 == 0:
+                    f = t.depend_on_fixture(t.file.add_fixture())
+                else:
+                    f = t.depend_on_fixture(s.slashconf.add_fixture())
+                #f.parametrize()
+
+            if self._args.use_parameters and index % _PARAM_FREQ == 0:
+                t.parametrize()
+
+            if element == '.':
+                pass
+            elif element == 'F':
+                t.when_run.fail()
+            elif element == 'E':
+                t.when_run.error()
+            elif element == 'S':
+                t.when_run.skip()
+            elif element == 'i':
+                t.when_run.interrupt()
+            else:
+                parser.error("Unknown marker: {0!r}".format(element))
+
+        s.commit()
+
+        return 0
+
+
+#### For use with entry_points/console_scripts
+def main_entry_point():
+    args = parser.parse_args()
+    app = Application(args)
+    sys.exit(app.main())
+
+
+if __name__ == "__main__":
+    main_entry_point()
diff --git a/scripts/make_release.py b/scripts/make_release.py
new file mode 100755
index 0000000000..fe959be38c
--- /dev/null
+++ b/scripts/make_release.py
@@ -0,0 +1,69 @@
+#!/usr/bin/env python
+import argparse
+import logging
+import os
+import sys
+import subprocess
+import time
+
+def _from_root(*p):
+    return os.path.abspath(os.path.join(os.path.dirname(__file__), "..", *p))
+
+_VERSION_FILE = _from_root("slash", "__version__.py")
+_CHANGELOG_FILE = _from_root("doc", "changelog.rst")
+
+parser = argparse.ArgumentParser(usage="%(prog)s [options] args...")
+parser.add_argument("-v", action="append_const", const=1, dest="verbosity", default=[],
+                    help="Be more verbose. Can be specified multiple times to increase verbosity further")
+
+
+def main(args):
+    default = _get_default_next_version()
+    version = raw_input("New version to release (default: {!r}): ".format(default)).strip()
+    if not version:
+        version = default
+    subprocess.check_call('git flow release start {}'.format(version), shell=True)
+    _write_new_version(version)
+    _write_changelog(version)
+    subprocess.check_call("git commit -a -m 'v{}'".format(version), shell=True)
+    subprocess.check_call('git flow release finish {}'.format(version), shell=True)
+    return 0
+
+def _get_default_next_version():
+    major, minor, bugfix = _get_current_version()
+    return "{}.{}.{}".format(major, minor, bugfix + 1)
+
+def _get_current_version():
+    d = {}
+    with open(_VERSION_FILE) as version_file:
+        exec(version_file.read(), d, d)
+
+    return [int(x) for x in d["__version__"].split(".")]
+
+def _write_new_version(version):
+    with open(_VERSION_FILE, "w") as version_file:
+        version_file.write("__version__ = {!r}\n".format(version))
+
+def _write_changelog(version):
+    temp_filename = "/tmp/__bump_version_changelog.rst"
+    with open(_CHANGELOG_FILE) as changelog_file:
+        with open(temp_filename, "w") as temp_file:
+            already_wrote = False
+            for line in changelog_file:
+                if line.startswith("* ") and not already_wrote:
+                    temp_file.write("* :release:`{} <{}>`\n".format(
+                        version,
+                        time.strftime("%d-%m-%Y"),
+                        ))
+                    already_wrote = True
+                temp_file.write(line)
+    os.rename(temp_filename, _CHANGELOG_FILE)
+
+#### For use with entry_points/console_scripts
+def main_entry_point():
+    args = parser.parse_args()
+    sys.exit(main(args))
+
+
+if __name__ == "__main__":
+    main_entry_point()
diff --git a/setup.cfg b/setup.cfg
new file mode 100755
index 0000000000..38f5af30dc
--- /dev/null
+++ b/setup.cfg
@@ -0,0 +1,37 @@
+[metadata]
+name = slash
+classifiers =
+    Programming Language :: Python :: 2.7
+    Programming Language :: Python :: 3.3
+    Programming Language :: Python :: 3.4
+    Programming Language :: Python :: 3.5
+    Programming Language :: Python :: 3.6
+description = A Testing Framework
+license = BSD
+author = Rotem Yaari
+author_email = vmalloc@gmail.com
+url = http://getslash.github.io/
+
+[files]
+package_data =
+    slash.plugins.builtin =
+        email_template.j2
+
+[entry_points]
+console_scripts =
+    slash  = slash.frontend.main:main_entry_point
+
+[extras]
+testing =
+    coverage
+    coveralls
+    munch
+    pytest
+    pytest-catchlog
+    pytest-cov
+    pytest-timeout
+    pyforge
+    pylint>=1.7
+
+[tool:pytest]
+testpaths = tests
diff --git a/setup.py b/setup.py
new file mode 100755
index 0000000000..8bee73956e
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,8 @@
+#!/usr/bin/env python
+from setuptools import setup
+
+
+setup(
+    setup_requires=['pbr>=3.0', 'setuptools>=17.1'],
+    pbr=True,
+)
diff --git a/slash/__init__.py b/slash/__init__.py
new file mode 100755
index 0000000000..4aa5c34395
--- /dev/null
+++ b/slash/__init__.py
@@ -0,0 +1,45 @@
+from .__version__ import __version__
+from .cleanups import add_cleanup, add_critical_cleanup, add_success_only_cleanup
+from .conf import config
+from .ctx import context
+from .ctx import g, session, test
+from .core.session import Session
+from .core.tagging import tag
+# assertions
+from . import assertions
+should = assertions
+from .assertions import (
+    allowing_exceptions,
+    assert_almost_equal,
+    assert_contains,
+    assert_equal,
+    assert_equals,
+    assert_false,
+    assert_in,
+    assert_is,
+    assert_is_none,
+    assert_empty,
+    assert_not_empty,
+    assert_is_not,
+    assert_is_not_none,
+    assert_isinstance,
+    assert_not_contain,
+    assert_not_contains,
+    assert_not_equal,
+    assert_not_equals,
+    assert_not_in,
+    assert_not_isinstance,
+    assert_raises,
+    assert_true,
+    )
+from .core.test import Test
+from .core.test import abstract_test_class
+from .core.exclusions import exclude
+from .core.fixtures import parametrize, parameters
+from .core.fixtures.utils import fixture, nofixtures, generator_fixture, yield_fixture, use
+from .core.requirements import requires
+from .utils import skip_test, skipped, add_error, add_failure, set_test_detail, repeat, register_skip_exception
+from .utils.interactive import start_interactive_shell
+from .runner import run_tests
+import logbook
+logger = logbook.Logger(__name__)
diff --git a/slash/__version__.py b/slash/__version__.py
new file mode 100755
index 0000000000..ccf60f73b8
--- /dev/null
+++ b/slash/__version__.py
@@ -0,0 +1,3 @@
+import pkg_resources
+
+__version__ = pkg_resources.get_distribution('slash').version
diff --git a/slash/_compat.py b/slash/_compat.py
new file mode 100755
index 0000000000..b395e545e0
--- /dev/null
+++ b/slash/_compat.py
@@ -0,0 +1,96 @@
+# -*- coding: utf-8 -*-
+
+# Based on logbook.helpers, licensed under BSD. See https://github.com/mitsuhiko/logbook/blob/0.4.2/logbook/compat.py for copyright information
+
+#pylint: disable=import-error
+#pylint: disable=maybe-no-member
+#pylint: disable=no-name-in-module
+#pylint: disable=undefined-variable
+#pylint: disable=unused-argument
+#pylint: disable=unused-import
+#pylint: disable=exec-used
+import sys
+from types import TracebackType
+
+PY2 = sys.version_info[0] == 2
+PYPY = hasattr(sys, 'pypy_version_info')
+
+if PY2:
+    from cStringIO import StringIO as cStringIO
+else:
+    from io import StringIO as cStringIO
+
+if PY2:
+    import __builtin__ as _builtins
+else:
+    import builtins as _builtins
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+
+if PY2:
+    from cStringIO import StringIO
+    iteritems = lambda d: d.iteritems() # not dict.iteritems!!! we support ordered dicts as well
+    itervalues = lambda d: d.itervalues()
+    from itertools import imap
+    reduce = _builtins.reduce
+    from itertools import izip
+    from itertools import izip_longest
+    xrange = _builtins.xrange
+else:
+    from io import StringIO
+    izip = _builtins.zip
+    imap = _builtins.map
+    from functools import reduce
+    xrange = range
+    iteritems = lambda d: iter(d.items()) # not dict.items!!! See above
+    itervalues = lambda d: iter(d.values())
+    from itertools import zip_longest as izip_longest
+
+_IDENTITY = lambda obj: obj
+
+if PY2:
+    integer_types = (int, long)
+    string_types = (basestring,)
+else:
+    integer_types = (int,)
+    string_types = (str,)
+
+if PY2:
+    #Yucky, but apparently that's the only way to do this
+    exec("""
+def reraise(tp, value, tb=None):
+    raise tp, value, tb
+""", locals(), globals())
+else:
+    def reraise(tp, value, tb=None):
+        # A hacky way to check, whether we have a TracebackProxy here. Can't check directly, as
+        # it would lead to circular import.
+        if value.__traceback__ is not tb:
+            if not isinstance(tb, TracebackType):
+                tb = tb._tb # pylint: disable=protected-access
+            raise value.with_traceback(tb)
+        raise value
+
+try:
+    from collections import OrderedDict # pylint: disable=E0611
+except ImportError: # python 2.6
+    from ordereddict import OrderedDict # pylint: disable=F0401
+
+try:
+    from contextlib import ExitStack #pylint: disable=E0611
+except ImportError:
+    from contextlib2 import ExitStack
+
+if sys.version_info < (2, 7):
+
+    def get_underlying_classmethod_function(func):
+        returned = func.__get__(True)
+        return getattr(returned, 'im_func', returned)
+
+else:
+
+    def get_underlying_classmethod_function(func):
+        return func.__func__
diff --git a/slash/app.py b/slash/app.py
new file mode 100755
index 0000000000..296c9963c5
--- /dev/null
+++ b/slash/app.py
@@ -0,0 +1,186 @@
+import logbook
+import signal
+import sys
+import dessert
+from contextlib import contextmanager
+
+from . import hooks as trigger_hook
+from . import log
+from . import site
+from . import plugins
+from ._compat import ExitStack
+from .conf import config
+from .core.session import Session
+from .reporting.console_reporter import ConsoleReporter
+from . import exceptions
+from .exceptions import TerminatedException, SlashException
+from .exception_handling import handling_exceptions, inhibit_unhandled_exception_traceback, should_inhibit_unhandled_exception_traceback
+from .loader import Loader
+from .log import ConsoleHandler
+from .utils import cli_utils
+from .utils.debug import debug_if_needed
+
+_logger = logbook.Logger(__name__)
+inhibit_unhandled_exception_traceback(SlashException)
+
+
+class Application(object):
+
+    def __init__(self):
+        super(Application, self).__init__()
+        self._test_loader = Loader()
+        self.set_report_stream(sys.stderr)
+        self._argv = None
+        self._reset_parser()
+        self._positional_args = None
+        self._parsed_args = None
+        self._reporter = None
+        self.test_loader = Loader()
+        self.session = None
+        self._working_directory = None
+        self._interrupted = False
+        self._exit_code = 0
+
+    def set_working_directory(self, path):
+        self._working_directory = path
+
+    @property
+    def exit_code(self):
+        return self._exit_code
+
+    def set_exit_code(self, exit_code):
+        self._exit_code = exit_code
+
+    @property
+    def interrupted(self):
+        return self._interrupted
+
+    @property
+    def positional_args(self):
+        return self._positional_args
+
+    @property
+    def parsed_args(self):
+        return self._parsed_args
+
+    def enable_interactive(self):
+        self.arg_parser.add_argument(
+            '-i', '--interactive', help='Enter an interactive shell',
+            action="store_true", default=False)
+
+    def _reset_parser(self):
+        self.arg_parser = cli_utils.SlashArgumentParser()
+
+    def set_argv(self, argv):
+        self._argv = list(argv)
+
+    def _get_argv(self):
+        if self._argv is None:
+            return sys.argv[1:]
+        return self._argv[:]
+
+    def set_report_stream(self, stream):
+        if stream is not None:
+            self._report_stream = stream
+            self._default_reporter = ConsoleReporter(level=logbook.ERROR, stream=stream)
+            self._console_handler = ConsoleHandler(stream=stream, level=logbook.ERROR)
+
+    def set_reporter(self, reporter):
+        self._reporter = reporter
+
+    def get_reporter(self):
+        returned = self._reporter
+        if returned is None:
+            returned = ConsoleReporter(
+                level=config.root.log.console_level,
+                stream=self._report_stream)
+
+        return returned
+
+    def __enter__(self):
+        self._exit_stack = ExitStack()
+        self._exit_stack.__enter__()
+        try:
+            self._exit_stack.enter_context(self._prelude_logging_context())
+            self._exit_stack.enter_context(self._sigterm_context())
+            with dessert.rewrite_assertions_context():
+                site.load(working_directory=self._working_directory)
+
+            cli_utils.configure_arg_parser_by_plugins(self.arg_parser)
+            cli_utils.configure_arg_parser_by_config(self.arg_parser)
+            argv = cli_utils.add_pending_plugins_from_commandline(self._get_argv())
+
+            self._parsed_args, self._positional_args = self.arg_parser.parse_known_args(argv)
+
+            self._exit_stack.enter_context(
+                cli_utils.get_modified_configuration_from_args_context(self.arg_parser, self._parsed_args)
+                )
+
+            self.session = Session(reporter=self.get_reporter(), console_stream=self._report_stream)
+
+            trigger_hook.configure() # pylint: disable=no-member
+            plugins.manager.activate_pending_plugins()
+            cli_utils.configure_plugins_from_args(self._parsed_args)
+
+
+            self._exit_stack.enter_context(self.session)
+            self._emit_prelude_logs()
+            return self
+
+        except:
+            self._emit_prelude_logs()
+            self.__exit__(*sys.exc_info())
+            raise
+
+    def __exit__(self, exc_type, exc_value, exc_tb):
+        exc_info = (exc_type, exc_value, exc_tb)
+        debug_if_needed(exc_info)
+        if exc_value is not None:
+            self._exit_code = exc_value.code if isinstance(exc_value, SystemExit) else -1
+
+            if should_inhibit_unhandled_exception_traceback(exc_value):
+                self.get_reporter().report_error_message(str(exc_value))
+
+            elif isinstance(exc_value, Exception):
+                _logger.error('Unexpected error occurred', exc_info=exc_info)
+                self.get_reporter().report_error_message('Unexpected error: {}'.format(exc_value))
+
+            if isinstance(exc_value, exceptions.INTERRUPTION_EXCEPTIONS):
+                self._interrupted = True
+
+        if exc_type is not None:
+            trigger_hook.result_summary() # pylint: disable=no-member
+        self._exit_stack.__exit__(exc_type, exc_value, exc_tb)
+        self._exit_stack = None
+        self._reset_parser()
+        return True
+
+    def _prelude_logging_context(self):
+        self._prelude_log_handler = log.RetainedLogHandler(bubble=True, level=logbook.TRACE)
+        return self._prelude_log_handler.applicationbound()
+
+    def _emit_prelude_logs(self):
+        self._prelude_log_handler.disable()
+        handler = None
+        if self.session is not None:
+            handler = self.session.logging.session_log_handler
+        if handler is None:
+            handler = self._console_handler
+        self._prelude_log_handler.flush_to_handler(handler)
+
+    @contextmanager
+    def _sigterm_context(self):
+        def handle_sigterm(*_):
+            with handling_exceptions():
+                raise TerminatedException('Terminated by signal')
+
+        prev = signal.signal(signal.SIGTERM, handle_sigterm)
+        try:
+            yield
+        finally:
+            try:
+                signal.signal(signal.SIGTERM, prev)
+            except TypeError as e:
+                #workaround for a strange issue on app cleanup. See https://bugs.python.org/issue23548
+                if 'signal handler must be signal.SIG_IGN' not in str(e):
+                    raise
diff --git a/slash/assertions.py b/slash/assertions.py
new file mode 100755
index 0000000000..5d6c21d367
--- /dev/null
+++ b/slash/assertions.py
@@ -0,0 +1,191 @@
+import operator
+import sys
+
+import logbook
+from vintage import deprecated
+
+from . import exception_handling
+from ._compat import PY2
+from .exceptions import TestFailed, ExpectedExceptionNotCaught
+from .utils import operator_information
+
+sys.modules["slash.should"] = sys.modules[__name__]
+_logger = logbook.Logger(__name__)
+
+def _deprecated(func, message=None):
+    return deprecated(since='0.19.0', what='slash.should.{0.__name__}'.format(func),
+                      message=message or 'Use plain assertions instead')(func)
+
+
+def _binary_assertion(name, operator_func):
+    op = operator_information.get_operator_by_func(operator_func)
+
+    def _assertion(a, b, msg=None):
+        if not op(a, b):
+            msg = _get_message(msg, operator_information.get_operator_by_func(
+                op.inverse_func).to_expression(a, b))
+            raise TestFailed(msg)
+    _assertion.__name__ = name
+    _assertion.__doc__ = "Asserts **{0}**".format(
+        op.to_expression("ARG1", "ARG2"))
+    _assertion = _deprecated(_assertion)
+    return _assertion
+
+
+def _unary_assertion(name, operator_func):
+    op = operator_information.get_operator_by_func(operator_func)
+
+    def _assertion(a, msg=None):
+        if not op(a):
+            msg = _get_message(msg, operator_information.get_operator_by_func(
+                op.inverse_func).to_expression(a))
+            raise TestFailed(msg)
+    _assertion.__name__ = name
+    _assertion.__doc__ = "Asserts **{0}**".format(op.to_expression("ARG"))
+    _assertion = _deprecated(_assertion)
+    return _assertion
+
+
+def _get_message(msg, description):
+    if msg is None:
+        return description
+    return "{0} ({1})".format(msg, description)
+
+equal = _binary_assertion("equal", operator.eq)
+assert_equal = assert_equals = equal = equal
+
+not_equal = _binary_assertion("not_equal", operator.ne)
+assert_not_equal = assert_not_equals = not_equals = not_equal
+
+be_a = _binary_assertion("be_a", operator_information.safe_isinstance)
+assert_isinstance = be_a
+
+not_be_a = _binary_assertion(
+    "not_be_a", operator_information.safe_not_isinstance)
+assert_not_isinstance = not_be_a
+
+be_none = _unary_assertion("be_none", operator_information.is_none)
+assert_is_none = be_none
+
+not_be_none = _unary_assertion("not_be_none", operator_information.is_not_none)
+assert_is_not_none = not_be_none
+
+be = _binary_assertion("be", operator.is_)
+assert_is = be
+
+not_be = _binary_assertion("not_be", operator.is_not)
+assert_is_not = not_be
+
+be_true = _unary_assertion("be_true", operator.truth)
+assert_true = be_true
+
+be_false = _unary_assertion("be_false", operator.not_)
+assert_false = be_false
+
+be_empty = _unary_assertion("be_empty", operator_information.is_empty)
+assert_empty = assert_is_empty = be_empty
+
+not_be_empty = _unary_assertion(
+    "not_be_empty", operator_information.is_not_empty)
+assert_not_empty = assert_is_not_empty = not_be_empty
+
+contain = _binary_assertion("contain", operator.contains)
+assert_contains = contains = contain
+
+not_contain = _binary_assertion(
+    "not_contain", operator_information.not_contains)
+assert_not_contains = assert_not_contain = not_contains = not_contain
+
+
+def be_in(a, b, msg=None):
+    """
+    Asserts **ARG1 in ARG2**
+    """
+    return contain(b, a, msg)
+assert_in = be_in
+
+
+def not_be_in(a, b, msg=None):
+    """
+    Asserts **ARG1 not in ARG2**
+    """
+    return not_contain(b, a, msg)
+assert_not_in = not_be_in
+
+
+class _CaughtContext(object):
+
+    def __init__(self, message, exc_types, ensure_caught):
+        if not isinstance(exc_types, tuple):
+            exc_types = (exc_types, )
+        self._expected_classes = exc_types
+        self._caught = _CaughtException()
+        self._ignore_ctx = None
+        self._msg = message
+        self._ensure_caught = ensure_caught
+
+    def __enter__(self):
+        self._ignore_ctx = exception_handling.thread_ignore_exception_context(self._expected_classes)
+        self._ignore_ctx.__enter__()  # pylint: disable=no-member
+        return self._caught
+
+    def __exit__(self, *exc_info):
+        if self._ignore_ctx:
+            self._ignore_ctx.__exit__(*exc_info)  # pylint: disable=no-member
+        if exc_info and exc_info != exception_handling.NO_EXC_INFO:
+            e = exc_info[1]
+            if isinstance(e, self._expected_classes):
+                self._caught.exception = e
+                if PY2:
+                    sys.exc_clear()  # pylint: disable=no-member
+                return True
+            return None
+        msg = self._msg
+        if self._msg is None:
+            expected_classes = self._expected_classes
+            if not isinstance(expected_classes, tuple):
+                expected_classes = (expected_classes, )
+            msg = "{0} not raised".format("/".join(e.__name__ for e in expected_classes))
+        if self._ensure_caught:
+            raise ExpectedExceptionNotCaught(msg, self._expected_classes)
+        _logger.debug(msg)
+        return True
+
+
+def assert_raises(exception_class, msg=None):
+    """
+    Ensures a subclass of **ARG1** leaves the wrapped context:
+
+    >>> with assert_raises(AttributeError):
+    ...     raise AttributeError()
+    """
+    return _CaughtContext(msg, exception_class, ensure_caught=True)
+
+
+def allowing_exceptions(exception_class, msg=None):
+    """
+    Allow subclass of **ARG1** to be raised during context:
+
+    >>> with allowing_exceptions(AttributeError):
+    ...     raise AttributeError()
+    >>> with allowing_exceptions(AttributeError):
+    ...     pass
+    """
+    return _CaughtContext(msg, exception_class, ensure_caught=False)
+
+
+@deprecated(since='0.19.0', what='slash.should.raise_exception', message='Use slash.assert_raises instead')
+def raise_exception(exception_class, msg=None):
+    return assert_raises(exception_class, msg=msg)
+
+raise_exception.__doc__ = assert_raises.__doc__.replace("assert_raises", "raise_exception")
+
+
+def assert_almost_equal(a, b, delta=0.00000001):
+    """Asserts that abs(a - b) <= delta
+    """
+    assert abs(a - b) <= delta
+
+
+class _CaughtException(object):
+    exception = None
diff --git a/slash/cleanups.py b/slash/cleanups.py
new file mode 100755
index 0000000000..afe736342e
--- /dev/null
+++ b/slash/cleanups.py
@@ -0,0 +1,25 @@
+import functools
+
+from .core import cleanup_manager
+from .ctx import context
+
+
+@functools.wraps(cleanup_manager.CleanupManager.add_cleanup)
+def add_cleanup(*args, **kwargs):
+    if context.session is None or context.session.cleanups is None:
+        raise RuntimeError('Adding cleanups requires an active session')
+    return context.session.cleanups.add_cleanup(*args, **kwargs)
+
+
+def add_critical_cleanup(_func, *args, **kwargs):
+    """
+    Same as :func:`.add_cleanup`, only the cleanup will be called even on interrupted tests
+    """
+    return add_cleanup(_func, critical=True, *args, **kwargs)
+
+
+def add_success_only_cleanup(_func, *args, **kwargs):
+    """
+    Same as :func:`.add_cleanup`, only the cleanup will be called only if the test succeeds
+    """
+    return add_cleanup(_func, success_only=True, *args, **kwargs)
diff --git a/slash/conf.py b/slash/conf.py
new file mode 100755
index 0000000000..22296b63d9
--- /dev/null
+++ b/slash/conf.py
@@ -0,0 +1,107 @@
+# pylint: disable=line-too-long
+import logbook
+from confetti import Config
+from .utils.conf_utils import Doc, Cmdline
+
+__all__ = ["config"]
+
+config = Config({
+    "debug": {
+        "debug_skips": False // Doc("Enter pdb also for SkipTest exceptions"),
+        "debug_hook_handlers": False // Doc("Enter pdb also for every exception encountered in a hook/callback. Only relevant when debugging is enabled"),
+        "enabled": False // Doc("Enter pdb on failures and errors") // Cmdline(on="--pdb"),
+        "debugger": None,
+    },
+
+    "log": {
+        "colorize": False // Doc("Emit log colors to files"),
+        "console_theme": {
+            'inline-file-end-fail': 'red',
+            'inline-file-end-skip': 'yellow',
+            'inline-file-end-success': 'green',
+            'inline-error': 'red',
+            'inline-test-interrupted': 'yellow',
+            'error-cause-marker': 'white/bold',
+            'fancy-message': 'yellow/bold',
+            'frame-local-varname': 'yellow/bold',
+            'session-summary-success': 'green/bold',
+            'session-summary-failure': 'red/bold',
+            'error-separator-dash': 'red',
+            'tb-error-message': 'red/bold',
+            'tb-error': 'red/bold',
+            'tb-frame-location': 'white/bold',
+            'test-additional-details-header': 'black/bold',
+            'test-additional-details': 'black/bold',
+            'test-error-header': 'white',
+            'test-skip-message': 'yellow',
+            'tb-line-cause': 'white',
+            'tb-test-line': 'red/bold',
+            'tb-line': 'black/bold',
+        },
+
+        "console_level": logbook.WARNING // Cmdline(decrease='-v',
+                                                    decrease_doc='Make console more verbose (can be specified multiple times)',
+                                                    increase='-q',
+                                                    increase_doc='Make console less verbose (can be specified multiple times)'),
+        "color_console": None // Cmdline(on='--force-color', off='--no-color'),
+        "traceback_level": 2 // Doc("Detail level of tracebacks") // Cmdline(arg="--tb"),
+        "truncate_console_lines": True // Doc("truncate long log lines on the console") // Cmdline(arg='--truncate-console-lines', metavar='yes/no'),
+        "truncate_console_errors": False // Doc("If truncate_console_lines is set, also truncate long log lines, including and above the \"error\" level, on the console"),
+        "root": None // Doc("Root directory for logs") // Cmdline(arg="-l", metavar="DIR"),
+        "subpath": "{context.session.id}/{context.test_id}/debug.log" // Doc("Path to write logs to under the root"),
+        "session_subpath": "{context.session.id}/session.log",
+        "errors_subpath": None // Doc("Depreacted - Use 'highlights_subpath' config instead"),
+        "highlights_subpath": None // Doc("If set, this path will be used to record highlights (eg. errors added) in the session and/or tests"),
+        "last_session_symlink": None // Doc("If set, specifies a symlink path to the last session log file in each run"),
+        "last_session_dir_symlink": None // Doc("If set, specifies a symlink path to the last session log directory"),
+        "last_test_symlink": None // Doc("If set, specifies a symlink path to the last test log file in each run"),
+        "last_failed_symlink": None // Doc("If set, specifies a symlink path to the last failed test log file"),
+        "show_manual_errors_tb": True // Doc("Show tracebacks for errors added via slash.add_error"),
+        "silence_loggers": [] // Doc("Logger names to silence"),
+        "format": None // Doc("Format of the log line, as passed on to logbook. None will use the default format"),
+        "console_format": None // Doc("Optional format to be used for console output. Defaults to the regular format"),
+        "localtime": False // Doc("Use local time for logging. If False, will use UTC"),
+        "unittest_mode": False // Doc("Used during unit testing. Emit all logs to stderr as well as the log files"),
+        "unified_session_log": False // Doc("Make the session log file contain all logs, including from tests"),
+    },
+    "run": {
+        "dump_variation": False // Doc("Output the full variation structure before each test is run (mainly used for internal debugging)"),
+        "default_sources": [] // Doc("Default tests to run assuming no other sources are given to the runner"),
+        "suite_files": [] // Doc("File(s) to be read for lists of tests to be run") // Cmdline(append="-f", metavar="FILENAME"),
+        "stop_on_error": False // Doc("Stop execution when a test doesn't succeed") // Cmdline(on="-x"),
+        "filter_strings": [] // Doc("A string filter, selecting specific tests by string matching against their name") // Cmdline(append='-k', metavar='FILTER'),
+        "repeat_each": 1 // Doc("Repeat each test a specified amount of times") // Cmdline(arg='--repeat-each', metavar="NUM_TIMES"),
+        "repeat_all": 1 // Doc("Repeat all suite a specified amount of times") // Cmdline(arg='--repeat-all', metavar="NUM_TIMES"),
+        "session_state_path": "~/.slash/last_session" // Doc("Where to keep last session serialized data"),
+        "project_customization_file_path": "./.slashrc",
+        "user_customization_file_path": "~/.slash/slashrc",
+        "message_assertion_introspection": True // Doc("When False, failing assertions which have messages attached will not emit introspection info"),
+    },
+    "parallel": {
+        "num_workers": 0 // Doc("Parallel execution") // Cmdline(arg='--parallel', metavar="NUM_WORKERS"),
+        "worker_id": None // Doc("Worker_id") // Cmdline(arg='--parallel-worker-id', metavar="WORKER_ID"),
+        "server_addr": "localhost" // Doc("Server address") // Cmdline(arg='--parallel-addr', metavar="PARALLEL_SERVER_ADDRESS"),
+        "server_port": 0 // Doc("Server port") // Cmdline(arg='--parallel-port', metavar="PARALLEL_SERVER_PORT"),
+        "parent_session_id": None // Doc("parent session id") // Cmdline(arg='--parallel-parent-session-id', metavar="MASTER_SESSION_ID"),
+        "communication_timeout_secs": 60 // Doc("timeout of worker in seconds"),
+        "worker_connect_timeout": 10 // Doc("timeout for each worker to connect"),
+        "no_request_timeout": 20 // Doc("timeout for server not getting requests"),
+        "worker_error_file": "errors-worker" // Doc("worker error filename template"),
+        "workers_error_dir": None // Doc("workers error directory") // Cmdline(arg='--workers-error-dir', metavar="WORKERS_ERROR_DIR"),
+    },
+    "tmux": {
+        "enabled": False // Doc("Run inside tmux") // Cmdline(on="--tmux"),
+        "use_panes": False // Doc("In parallel mode, run children inside panes and not windows") // Cmdline(on="--tmux-panes"),
+    },
+    "sentry": {
+        "dsn": None // Doc("Possible DSN for a sentry service to log swallowed exceptions. "
+                           "See http://getsentry.com for details"),
+    },
+    "plugins": {
+        "search_paths": [] // Doc("List of paths in which to search for plugin modules"),
+    },
+
+    "plugin_config": {
+        # DO NOT store configuration here. It is intended for dynamically loaded plugins
+    },
+})
diff --git a/slash/core/__init__.py b/slash/core/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/slash/core/cleanup_manager.py b/slash/core/cleanup_manager.py
new file mode 100755
index 0000000000..4d1a221c3b
--- /dev/null
+++ b/slash/core/cleanup_manager.py
@@ -0,0 +1,176 @@
+from contextlib import contextmanager
+
+import logbook
+from sentinels import Sentinel
+from vintage import warn_deprecation
+
+from .. import hooks
+from ..ctx import context
+from ..exception_handling import handling_exceptions
+from ..exceptions import CannotAddCleanup, IncorrectScope
+
+_logger = logbook.Logger(__name__)
+
+
+
+_LAST_SCOPE = Sentinel('LAST_SCOPE')
+_DEDUCE = Sentinel('DEDUCE')
+
+
+
+class CleanupManager(object):
+
+    def __init__(self):
+        super(CleanupManager, self).__init__()
+        self._scope_stack = []
+        self._scopes_by_name = {}
+        self._pending = []
+        self._allow_implicit_scopes = True
+
+    @contextmanager
+    def forbid_implicit_scoping_context(self):
+        prev = self._allow_implicit_scopes
+        self._allow_implicit_scopes = False
+        try:
+            yield
+        finally:
+            self._allow_implicit_scopes = prev
+
+    def add_cleanup(self, _func, *args, **kwargs):
+        """
+        Adds a cleanup function to the cleanup stack. Cleanups are executed in a LIFO order.
+
+        Positional arguments and keywords are passed to the cleanup function when called.
+
+        :param critical: If True, this cleanup will take place even when tests are interrupted by the user (Using Ctrl+C for instance)
+        :param success_only: If True, execute this cleanup only if no errors are encountered
+        :param scope: Scope at the end of which this cleanup will be executed
+        :param args: positional arguments to pass to the cleanup function
+        :param kwargs: keyword arguments to pass to the cleanup function
+        """
+
+        scope_name = kwargs.pop('scope', None)
+
+        critical = kwargs.pop('critical', False)
+        success_only = kwargs.pop('success_only', False)
+
+        new_kwargs = kwargs.pop('kwargs', {}).copy()
+        new_args = list(kwargs.pop('args', ()))
+        if args or kwargs:
+            warn_deprecation('Passing *args/**kwargs to slash.add_cleanup is deprecated. '
+                             'Use args=(...) and/or kwargs={...} instead', frame_correction=+2)
+            new_args.extend(args)
+            new_kwargs.update(kwargs)
+
+        added = _Cleanup(_func, new_args, new_kwargs, critical=critical, success_only=success_only)
+
+
+        if scope_name is None:
+            if not self._allow_implicit_scopes:
+                raise CannotAddCleanup('Cleanup added at a stage requiring explicit scoping')
+            scope = self._scope_stack[-1] if self._scope_stack else None
+        else:
+            if scope_name not in self._scopes_by_name:
+                raise IncorrectScope('Incorrect scope specified: {!r}'.format(scope_name))
+            scope = self._scopes_by_name[scope_name][-1]
+
+        if scope is None:
+            self._pending.append(added)
+        else:
+            scope.cleanups.append(added)
+        return _func
+
+    @contextmanager
+    def scope(self, scope):
+        self.push_scope(scope)
+        try:
+            yield
+        finally:
+            self.pop_scope(scope)
+
+    @property
+    def latest_scope(self):
+        return self._scope_stack[-1]
+
+    def push_scope(self, scope_name):
+        _logger.trace('CleanupManager: pushing scope {0!r}', scope_name)
+        scope = _Scope(scope_name)
+        self._scope_stack.append(scope)
+        self._scopes_by_name.setdefault(scope_name, []).append(scope)
+        for p in self._pending:
+            scope.cleanups.append(p)
+        del self._pending[:]
+
+    def pop_scope(self, scope_name):
+        if context.result is None:
+            in_failure = in_interruption = False
+        else:
+            in_failure = not context.result.is_success(allow_skips=True)
+            in_interruption = context.result.is_interrupted()
+
+        _logger.trace('CleanupManager: popping scope {0!r} (failure: {1}, interrupt: {2})', scope_name, in_failure, in_interruption)
+        scope = self._scope_stack[-1]
+        assert scope.name == scope_name, 'Attempted to pop scope {0!r}, but current scope is {1!r}'.format(scope_name, scope.name)
+        try:
+            self.call_cleanups(
+                scope=scope,
+                in_failure=in_failure, in_interruption=in_interruption)
+
+        finally:
+            self._scope_stack.pop()
+            self._scopes_by_name[scope_name].pop()
+
+    def call_cleanups(self, scope=_LAST_SCOPE, in_failure=False, in_interruption=False):
+
+        _logger.trace('Calling cleanups of scope {0.name!r} (failure={1}, interrupt={2})', scope, in_failure, in_interruption)
+
+        if scope is _LAST_SCOPE:
+            scope = self._scope_stack[-1]
+            _logger.trace('Deducing last scope={0.name!r}', scope)
+
+        if scope.name == 'test': # pylint: disable=no-member
+            with handling_exceptions():
+                hooks.before_test_cleanups()  # pylint: disable=no-member
+
+        stack = scope.cleanups # pylint: disable=no-member
+        while stack:
+            cleanup = stack.pop()
+            if in_interruption and not cleanup.critical:
+                continue
+            if (in_failure or in_interruption) and cleanup.success_only:
+                continue
+            with handling_exceptions(swallow=True):
+                _logger.trace("Calling cleanup: {0}", cleanup)
+                cleanup()
+
+
+
+class _Cleanup(object):
+
+    def __init__(self, func, args, kwargs, critical=False, success_only=False):
+        assert not (success_only and critical)
+        super(_Cleanup, self).__init__()
+        self.func = func
+        self.args = args
+        self.kwargs = kwargs
+        self.critical = critical
+        self.success_only = success_only
+        self.result = context.result
+
+    def __call__(self):
+        try:
+            return self.func(*self.args, **self.kwargs)
+        except Exception:
+            self.result.add_exception()
+            raise
+
+    def __repr__(self):
+        return "{0} ({1},{2})".format(self.func, self.args, self.kwargs)
+
+
+class _Scope(object):
+
+    def __init__(self, name):
+        super(_Scope, self).__init__()
+        self.name = name
+        self.cleanups = []
diff --git a/slash/core/details.py b/slash/core/details.py
new file mode 100755
index 0000000000..7fbb04eb4c
--- /dev/null
+++ b/slash/core/details.py
@@ -0,0 +1,34 @@
+class Details(object):
+
+    def __init__(self, set_callback=None):
+        super(Details, self).__init__()
+        self._details = {}
+        self._set_callback = set_callback
+
+    def set(self, key, value):
+        """Sets a specific detail (by name) to a specific value
+        """
+        if self._set_callback is not None:
+            self._set_callback(key, value)
+        self._details[key] = value
+
+    def append(self, key, value):
+        """Appends a value to a list key, or creates it if needed
+        """
+        lst = self._details.setdefault(key, [])
+        if not isinstance(lst, list):
+            raise TypeError('Cannot append value to a {0.__class__.__name__!r} value'.format(lst))
+        lst.append(value)
+        if self._set_callback is not None:
+            self._set_callback(key, lst)
+
+    def all(self):
+        return self._details.copy()
+
+    def __nonzero__(self):
+        return bool(self._details)
+
+    __bool__ = __nonzero__
+
+    def __contains__(self, key):
+        return key in self._details
diff --git a/slash/core/error.py b/slash/core/error.py
new file mode 100755
index 0000000000..11d69c87bb
--- /dev/null
+++ b/slash/core/error.py
@@ -0,0 +1,108 @@
+import sys
+import traceback
+
+import arrow
+from vintage import deprecated
+
+from .._compat import string_types
+from ..exception_handling import is_exception_fatal
+from ..exceptions import FAILURE_EXCEPTION_TYPES
+from ..utils.traceback_utils import distill_call_stack, distill_traceback
+
+
+class Error(object):
+
+    traceback = exception_type = arg = _cached_detailed_traceback_str = None
+
+    def __init__(self, msg=None, exc_info=None, frame_correction=0):
+        super(Error, self).__init__()
+        self.time = arrow.utcnow()
+        self._fatal = False
+        self._has_custom_message = (msg is not None)
+        if msg is None and exc_info is not None:
+            msg = traceback.format_exception_only(exc_info[0], exc_info[1])[0].strip()
+        if not isinstance(msg, string_types):
+            self.arg = msg
+            msg = repr(msg)
+        self.message = msg
+        #: A string representation of the exception caught, if exists
+        self.exception_str = exception = None
+        self.exc_info = exc_info
+        if exc_info is not None:
+            self.exception_type, exception, tb = exc_info  # pylint: disable=unpacking-non-sequence
+            self.exception_str = repr(exception)
+            self.traceback = distill_traceback(tb)
+        else:
+            self.traceback = distill_call_stack(frame_correction=frame_correction+4)
+        self._is_failure = False
+        self._fatal = exception is not None and is_exception_fatal(exception)
+        self._is_failure = isinstance(exception, FAILURE_EXCEPTION_TYPES)
+
+    def forget_exc_info(self):
+        assert hasattr(self, 'exc_info')
+        self.exc_info = None
+        for frame in self.traceback.frames:
+            frame.forget_python_frame()
+
+    def has_custom_message(self):
+        return self._has_custom_message
+
+    def mark_as_failure(self):
+        self._is_failure = True
+
+    def is_fatal(self):
+        return self._fatal
+
+    @property
+    @deprecated('Use error.exception_str', what='error.exception', since='1.2.3')
+    def exception(self):
+        return self.exception_str
+
+    def mark_fatal(self):
+        """Marks this error as fatal, causing session termination
+        """
+        self._fatal = True
+        return self
+
+    def is_failure(self):
+        return self._is_failure
+
+    @classmethod
+    def capture_exception(cls, exc_info=None):
+        if exc_info is None:
+            exc_info = sys.exc_info()
+        _, exc_value, _ = exc_info
+        if exc_value is None:
+            return None
+        cached = getattr(exc_value, "__slash_captured_error__", None)
+        if cached is not None:
+            return cached
+        returned = exc_value.__slash_captured_error__ = cls(exc_info=exc_info)
+        return returned
+
+    @property
+    def cause(self):
+        if self.traceback is not None:
+            return self.traceback.cause
+
+    @property
+    def filename(self):
+        if self.traceback is not None:
+            return self.traceback.cause.filename
+
+    @property
+    def lineno(self):
+        """Line number from which the error was raised
+        """
+        if self.traceback is not None:
+            return self.traceback.cause.lineno
+
+    @property
+    def func_name(self):
+        """Function name from which the error was raised
+        """
+        if self.traceback is not None:
+            return self.traceback.cause.func_name
+
+    def __repr__(self):
+        return self.message
diff --git a/slash/core/exclusions.py b/slash/core/exclusions.py
new file mode 100755
index 0000000000..767a15e3fd
--- /dev/null
+++ b/slash/core/exclusions.py
@@ -0,0 +1,35 @@
+from . import markers
+
+from ..ctx import context
+
+from .fixtures.parameters import Parametrization
+from ..exceptions import UnknownFixtures
+
+
+def exclude(name, values):
+    """
+    Excludes a specific parametrization of a test from running
+
+    :param name: can receive either a name of a parameter for this test, or a name of a fixture parameter
+    :param values: must be a list of values to exclude for the given parameter
+    """
+    return markers.exclude_marker((name, values))
+
+def is_excluded(test):
+    test_func = test.get_test_function()
+    exclusions = markers.exclude_marker.get_value(test_func, default=None)
+    if not exclusions:
+        return False
+    exclusions = dict(exclusions)
+    for parameter_name, values in exclusions.items():
+        param = context.session.fixture_store.resolve_name(parameter_name, start_point=test_func, namespace=test.get_fixture_namespace())
+        if not isinstance(param, Parametrization):
+            raise UnknownFixtures('{!r} is not a parameter, and therefore cannot be the base for value exclusions'.format(parameter_name))
+        try:
+            param_index = test.__slash__.variation.param_value_indices[param.info.id] #pylint: disable=no-member
+        except LookupError:
+            raise UnknownFixtures('{!r} cannot be excluded for {!r}'.format(parameter_name, test))
+        value = param.transform(param.values[param_index]) #pylint: disable=no-member
+        if value in values:
+            return True
+    return False
diff --git a/slash/core/fixtures/__init__.py b/slash/core/fixtures/__init__.py
new file mode 100755
index 0000000000..c3128f7a54
--- /dev/null
+++ b/slash/core/fixtures/__init__.py
@@ -0,0 +1,2 @@
+from .utils import fixture
+from .parameters import parametrize
diff --git a/slash/core/fixtures/active_fixture.py b/slash/core/fixtures/active_fixture.py
new file mode 100755
index 0000000000..3be6525470
--- /dev/null
+++ b/slash/core/fixtures/active_fixture.py
@@ -0,0 +1,42 @@
+from ...exception_handling import handling_exceptions
+
+class ActiveFixture(object):
+
+    def __init__(self, fixture):
+        super(ActiveFixture, self).__init__()
+        self.fixture = fixture
+        self.id = fixture.info.id
+        self.name = fixture.info.name
+        self._test_start_callbacks = []
+        self._test_end_callbacks = []
+        self._cleanups = []
+        self._test_start_called = False
+
+    def test_start(self, callback):
+        self._test_start_callbacks.append(callback)
+
+    def test_end(self, callback):
+        self._test_end_callbacks.append(callback)
+
+    def call_test_start(self):
+        if self._test_start_called:
+            return
+
+        self._test_start_called = True
+        with handling_exceptions():
+            for callback in self._test_start_callbacks:
+                callback()
+
+    def call_test_end(self):
+        self._test_start_called = False
+        with handling_exceptions():
+            for callback in self._test_end_callbacks:
+                callback()
+
+    def add_cleanup(self, cleanup):
+        self._cleanups.append(cleanup)
+
+    def do_cleanups(self):
+        while self._cleanups:
+            cleanup = self._cleanups.pop()
+            cleanup()
diff --git a/slash/core/fixtures/fixture.py b/slash/core/fixtures/fixture.py
new file mode 100755
index 0000000000..8151168d55
--- /dev/null
+++ b/slash/core/fixtures/fixture.py
@@ -0,0 +1,98 @@
+import itertools
+
+from collections import OrderedDict
+
+from orderedset import OrderedSet
+
+from ...exceptions import UnknownFixtures, InvalidFixtureScope, CyclicFixtureDependency
+
+from .namespace import Namespace
+from .parameters import iter_parametrization_fixtures
+from .fixture_base import FixtureBase
+from .utils import get_real_fixture_name_from_argument
+from ..requirements import get_requirements
+
+_fixture_id = itertools.count()
+
+
+
+class Fixture(FixtureBase):
+
+    def __init__(self, store, fixture_func):
+        super(Fixture, self).__init__()
+        self.fixture_func = fixture_func
+        self.info = self.fixture_func.__slash_fixture__
+        self.scope = self.info.scope
+        self.namespace = Namespace(store, store.get_current_namespace())
+
+    def is_parameter(self):
+        return False
+
+    def is_fixture(self):
+        return True
+
+    parametrization_ids = None
+
+    def __repr__(self):
+        return '<Function Fixture around {0}>'.format(self.fixture_func)
+
+    def is_override(self):
+        parent = self.namespace.get_parent()
+
+        while parent is not None:
+            f = parent.get_fixture_by_name(self.info.name, default=None)
+            if f is None:
+                return False
+
+            if f is not self:
+                return True
+
+            parent = parent.get_parent()
+        return False
+
+    def get_value(self, kwargs, active_fixture):
+        if self.info.needs_this:
+            assert 'this' not in kwargs
+            kwargs['this'] = active_fixture
+        return self.fixture_func(**kwargs)
+
+    def get_requirements(self, store):
+        fixture_requirements = get_requirements(self.fixture_func)
+        required_fixtures = store.get_required_fixture_objects(self.fixture_func, self.namespace)
+        while required_fixtures:
+            fixture_requirements.extend(required_fixtures.pop().get_requirements(store))
+        return fixture_requirements
+
+    def _resolve(self, store):
+        assert self.keyword_arguments is None
+        assert self.parametrization_ids is None
+        self.parametrization_ids = OrderedSet()
+        keyword_arguments = OrderedDict()
+
+        parametrized = set()
+
+        for name, param in iter_parametrization_fixtures(self.fixture_func):
+            store.register_fixture_id(param)
+            parametrized.add(name)
+            self.parametrization_ids.add(param.info.id)
+            keyword_arguments[name] = param
+
+        for param_name, arg in self.info.required_args.items():
+            if param_name in parametrized:
+                continue
+            try:
+                needed_fixture = self.namespace.get_fixture_by_name(get_real_fixture_name_from_argument(arg))
+
+                if needed_fixture.scope < self.scope: # pylint: disable=no-member
+                    raise InvalidFixtureScope('Fixture {0} is dependent on {1}, which has a smaller scope ({2} > {3})'.format(
+                        self.info.name, param_name, self.scope, needed_fixture.scope)) # pylint: disable=no-member
+
+                if needed_fixture is self:
+                    raise CyclicFixtureDependency('Cyclic fixture dependency detected in {0}: {1} depends on itself'.format(
+                        self.info.func.__code__.co_filename,
+                        self.info.name))
+                keyword_arguments[param_name] = needed_fixture
+            except LookupError:
+                raise UnknownFixtures(param_name)
+
+        return keyword_arguments
diff --git a/slash/core/fixtures/fixture_base.py b/slash/core/fixtures/fixture_base.py
new file mode 100755
index 0000000000..226af67ff5
--- /dev/null
+++ b/slash/core/fixtures/fixture_base.py
@@ -0,0 +1,19 @@
+class FixtureBase(object):
+
+    info = None
+    keyword_arguments = None
+    parametrization_ids = None
+    names = None
+
+    def get_value(self, kwargs, active_fixture):
+        raise NotImplementedError()  # pragma: no cover
+
+    def get_variations(self):
+        return None  # pragma: no cover
+
+    def resolve(self, store):
+        if self.keyword_arguments is None:
+            self.keyword_arguments = self._resolve(store)
+
+    def _resolve(self, store):
+        raise NotImplementedError()  # pragma: no cover
diff --git a/slash/core/fixtures/fixture_store.py b/slash/core/fixtures/fixture_store.py
new file mode 100755
index 0000000000..6f9886c5a1
--- /dev/null
+++ b/slash/core/fixtures/fixture_store.py
@@ -0,0 +1,374 @@
+import collections
+import sys
+from contextlib import contextmanager
+
+import logbook
+from orderedset import OrderedSet
+
+from ..._compat import OrderedDict, iteritems, itervalues, reraise
+from ...ctx import context as slash_context
+from ...exception_handling import handling_exceptions
+from ...exceptions import CyclicFixtureDependency, UnresolvedFixtureStore, UnknownFixtures, InvalidFixtureName
+from ...utils.python import get_arguments
+from ..variation_factory import VariationFactory
+from ..test import is_valid_test_name
+from .active_fixture import ActiveFixture
+from .fixture import Fixture
+from .namespace import Namespace
+from .parameters import Parametrization, iter_parametrization_fixtures
+from .utils import (get_real_fixture_name_from_argument, get_scope_by_name,
+                    nofixtures)
+
+_logger = logbook.Logger(__name__)
+
+class FixtureStore(object):
+
+    def __init__(self):
+        super(FixtureStore, self).__init__()
+        self._namespaces = [Namespace(self)]
+        self._unresolved_fixture_ids = set()
+        self._fixtures_by_id = {}
+        self._fixtures_by_fixture_info = {}
+        self._active_fixtures_by_scope = collections.defaultdict(OrderedDict)
+        self._computing = set()
+        self._all_needed_parametrization_ids_by_fixture_id = {}
+        self._known_fixture_ids = collections.defaultdict(dict) # maps fixture ids to known combinations
+
+    def get_active_fixture(self, fixture):
+        return self._active_fixtures_by_scope[fixture.info.scope].get(fixture.info.id)
+
+    def _compute_id(self, variation, p):
+        if isinstance(p, Parametrization):
+            return variation.param_value_indices[p.info.id]
+        combination = frozenset((f.info.id, self._compute_id(variation, f))
+                                for f in self.iter_all_needed_fixture_objects(p))
+        known = self._known_fixture_ids[p.info.id]
+        return known.setdefault(combination, len(known))
+
+    def iter_all_needed_fixture_objects(self, fixtureobj):
+        for fid in self.get_all_needed_fixture_ids(fixtureobj):
+            yield self.get_fixture_by_id(fid)
+
+    def iter_active_fixtures(self):
+        for _, fixtures in self._active_fixtures_by_scope.items():
+            for f in fixtures.values():
+                yield f
+
+    def call_with_fixtures(self, test_func, namespace, trigger_test_start=False, trigger_test_end=False):
+
+        if not nofixtures.is_marked(test_func):
+            fixture_names = self.get_required_fixture_names(test_func)
+            kwargs = self.get_fixture_dict(fixture_names, namespace)
+        else:
+            kwargs = {}
+
+        if trigger_test_start:
+            for fixture in self.iter_active_fixtures():
+                fixture.call_test_start()
+
+        returned = test_func(**kwargs)
+
+        if trigger_test_end:
+            for fixture in self.iter_active_fixtures():
+                fixture.call_test_end()
+
+        return returned
+
+    def get_required_fixture_names(self, test_func):
+        """Returns a list of fixture names needed by test_func.
+
+        Each element returned is either a string or a tuple of (required_name, real_name)
+        """
+        skip_names = {name for name, _ in iter_parametrization_fixtures(test_func)}
+        returned = []
+        for argument in get_arguments(test_func):
+            if argument.name in skip_names:
+                continue
+            real_name = get_real_fixture_name_from_argument(argument)
+            if real_name == argument.name:
+                returned.append(real_name)
+            else:
+                returned.append((argument.name, real_name))
+        return returned
+
+    def get_required_fixture_objects(self, test_func, namespace):
+        names = self.get_required_fixture_names(test_func)
+        assert isinstance(names, list)
+        return set(itervalues(self.get_fixture_dict(names, namespace=namespace, get_values=False)))
+
+    def resolve_name(self, parameter_name, start_point, namespace=None):
+
+        if namespace is None:
+            namespace = self.get_current_namespace()
+
+        parts = parameter_name.split('.')[::-1]
+
+        if not parts:
+            raise UnknownFixtures(parameter_name)
+
+        while parts:
+            current_name = parts.pop()
+            param_fixtures = dict(iter_parametrization_fixtures(start_point))
+            if current_name in param_fixtures:
+                if parts: # we cannot decend further than a parameter
+                    raise UnknownFixtures(parameter_name)
+                start_point = param_fixtures[current_name]
+            else:
+                start_point = self.get_fixture_by_name(current_name, namespace=namespace)
+                namespace = start_point.namespace
+        return start_point
+
+    def __iter__(self):
+        return itervalues(self._fixtures_by_id)
+
+    def push_namespace(self):
+        self._namespaces.append(Namespace(self, parent=self._namespaces[-1]))
+
+    def pop_namespace(self):
+        return self._namespaces.pop(-1)
+
+    @contextmanager
+    def new_namespace_context(self):
+        self.push_namespace()
+        try:
+            yield
+        finally:
+            self.pop_namespace()
+
+    def get_current_namespace(self):
+        return self._namespaces[-1]
+
+    def get_all_needed_fixture_ids(self, fixtureobj):
+        if self._unresolved_fixture_ids:
+            raise UnresolvedFixtureStore()
+        if isinstance(fixtureobj, Parametrization):
+            return frozenset([fixtureobj.info.id])
+        returned = self._all_needed_parametrization_ids_by_fixture_id.get(fixtureobj.info.id)
+        if returned is None:
+            returned = self._compute_all_needed_parametrization_ids(fixtureobj)
+            self._all_needed_parametrization_ids_by_fixture_id[fixtureobj.info.id] = returned
+        return returned
+
+    def iter_autouse_fixtures_in_namespace(self, namespace=None):
+        if namespace is None:
+            namespace = self.get_current_namespace()
+        for fixture in namespace.iter_fixtures():
+            if fixture.info.autouse:
+                yield fixture
+
+    def activate_autouse_fixtures_in_namespace(self, namespace):
+        for fixture in self.iter_autouse_fixtures_in_namespace(namespace):
+            _ = self.get_fixture_value(fixture)
+
+    def _compute_all_needed_parametrization_ids(self, fixtureobj):
+        stack = [(fixtureobj.info.id, [fixtureobj.info.id], set([fixtureobj.info.id]))]
+        returned = OrderedSet()
+        while stack:
+            fixture_id, path, visited = stack.pop()
+            if fixture_id in self._all_needed_parametrization_ids_by_fixture_id:
+                returned.update(self._all_needed_parametrization_ids_by_fixture_id[fixture_id])
+                continue
+            fixture = self._fixtures_by_id[fixture_id]
+            if fixture.parametrization_ids:
+                assert isinstance(fixture.parametrization_ids, OrderedSet)
+                returned.update(fixture.parametrization_ids)
+            if fixture.keyword_arguments:
+                for needed in itervalues(fixture.keyword_arguments):
+                    if needed.is_parameter():
+                        continue
+                    needed_id = needed.info.id
+                    if needed_id in visited:
+                        self._raise_cyclic_dependency_error(fixtureobj, path, needed_id)
+                    stack.append((needed_id, path + [needed_id], visited | set([needed_id])))
+        return returned
+
+    def _raise_cyclic_dependency_error(self, fixtureobj, path, new_id):
+        raise CyclicFixtureDependency(
+            'Cyclic fixture dependency detected in {0}: {1}'.format(
+                fixtureobj.info.func.__code__.co_filename,
+                ' -> '.join(self._fixtures_by_id[f_id].info.name
+                            for f_id in path + [new_id])))
+
+    def push_scope(self, scope):
+        scope = get_scope_by_name(scope)
+
+    def pop_scope(self, scope): # pylint: disable=unused-argument
+        if slash_context.result is not None and slash_context.result.is_interrupted():
+            return
+        scope = get_scope_by_name(scope)
+        for s, active_fixtures in iteritems(self._active_fixtures_by_scope):
+            if s <= scope:
+                for active_fixture in reversed(list(active_fixtures.values())):
+                    with handling_exceptions(swallow=True):
+                        self._deactivate_fixture(active_fixture.fixture)
+                assert not active_fixtures
+
+    def ensure_known_parametrization(self, parametrization):
+        if parametrization.info.id not in self._fixtures_by_id:
+            self._fixtures_by_id[parametrization.info.id] = parametrization
+
+    def add_fixtures_from_dict(self, d):
+        for thing in itervalues(d):
+            fixture_info = getattr(thing, '__slash_fixture__', None)
+            if fixture_info is None:
+                continue
+            assert self.get_current_namespace() is self._namespaces[-1]
+            fixture_info = self.add_fixture(thing).__slash_fixture__
+            self.get_current_namespace().add_name(
+                fixture_info.name, fixture_info.id)
+
+
+    def add_fixture(self, fixture_func):
+        fixture_info = fixture_func.__slash_fixture__
+        existing_fixture = self._fixtures_by_id.get(fixture_info.id)
+        if existing_fixture is not None:
+            return existing_fixture.fixture_func
+        if is_valid_test_name(fixture_info.name):
+            raise InvalidFixtureName('Invalid fixture name: {0.name}'.format(fixture_info))
+        fixture_object = Fixture(self, fixture_func)
+        current_namespace = self._namespaces[-1]
+        current_namespace.add_name(fixture_info.name, fixture_info.id)
+        self.register_fixture_id(fixture_object)
+        return fixture_func
+
+    def register_fixture_id(self, f):
+        if f.info.id in self._fixtures_by_id:
+            return
+        self._fixtures_by_id[f.info.id] = f
+        self._unresolved_fixture_ids.add(f.info.id)
+
+    def get_fixture_by_name(self, name, namespace=None):
+        if namespace is None:
+            namespace = self._namespaces[-1]
+        return namespace.get_fixture_by_name(name)
+
+    def get_fixture_by_argument(self, arg):
+        return self.get_fixture_by_name(get_real_fixture_name_from_argument(arg))
+
+    def get_fixture_by_id(self, fixture_id):
+        return self._fixtures_by_id[fixture_id]
+
+    def get_fixture_dict(self, fixture_names, namespace=None, get_values=True, skip_names=frozenset()):
+        returned = {}
+
+        if namespace is None:
+            namespace = self.get_current_namespace()
+
+        for element in fixture_names:
+            if isinstance(element, tuple):
+                required_name, real_name = element
+            else:
+                required_name = real_name = element
+
+            if required_name in skip_names:
+                continue
+            if element == 'this':
+                continue
+            fixture = namespace.get_fixture_by_name(real_name)
+            if get_values:
+                fixture = self.get_fixture_value(fixture, name=required_name)
+            returned[required_name] = fixture
+        return returned
+
+    def get_fixture_value(self, fixture, name=None):
+        if name is None:
+            name = fixture.info.name
+
+        value = self._compute_fixture_value(name, fixture)
+        return value
+
+    def get_value(self, variation, parameter_or_fixture):
+        fixture_id = parameter_or_fixture.info.id
+
+        fixtureobj = self.get_fixture_by_id(parameter_or_fixture.info.id)
+        if isinstance(fixtureobj, Parametrization):
+            value = parameter_or_fixture.values[variation.param_value_indices[fixture_id]]
+        else:
+            value = self.get_fixture_value(parameter_or_fixture)
+
+        if isinstance(parameter_or_fixture, Parametrization):
+            value = parameter_or_fixture.transform(value)
+        return value
+
+    def iter_parametrization_variations(self, fixture_ids=(), funcs=(), methods=()):
+
+        if self._unresolved_fixture_ids:
+            raise UnresolvedFixtureStore()
+
+        variation_factory = VariationFactory(self)
+        for fixture_id in fixture_ids:
+            variation_factory.add_needed_fixture_id(fixture_id)
+
+        for func in funcs:
+            variation_factory.add_needed_fixtures_from_function(func)
+
+        for method in methods:
+            variation_factory.add_needed_fixtures_from_method(method)
+
+        return variation_factory.iter_variations()
+
+    def _compute_fixture_value(self, name, fixture, relative_name=None):
+        if relative_name is None:
+            relative_name = name
+
+        assert not fixture.is_parameter()
+
+        if fixture.info.id in self._computing:
+            raise CyclicFixtureDependency(
+                'Fixture {0!r} is a part of a dependency cycle!'.format(name))
+
+        active_fixture = self.get_active_fixture(fixture)
+
+        if active_fixture is not None:
+            return active_fixture.value
+
+        self._computing.add(fixture.info.id)
+        try:
+            fixture_value = self._call_fixture(fixture, relative_name=relative_name)
+        except:
+            exc_info = sys.exc_info()
+            self._deactivate_fixture(fixture)
+            reraise(*exc_info)
+        finally:
+            self._computing.discard(fixture.info.id)
+
+        return fixture_value
+
+    def _call_fixture(self, fixture, relative_name):
+        assert relative_name
+        active_fixture = ActiveFixture(fixture)
+
+        kwargs = {}
+
+        if fixture.keyword_arguments is None:
+            raise UnresolvedFixtureStore('Fixture {0} is unresolved!'.format(fixture.info.name))
+
+        for required_name, needed_fixture in iteritems(fixture.keyword_arguments):
+            if needed_fixture.is_parameter():
+                continue
+            kwargs[required_name] = self._compute_fixture_value(
+                required_name, needed_fixture,
+                relative_name='{} -> {}'.format(relative_name, required_name))
+
+
+        assert fixture.info.id not in self._active_fixtures_by_scope[fixture.info.scope]
+        self._active_fixtures_by_scope[fixture.info.scope][fixture.info.id] = active_fixture
+        prev_context_fixture = slash_context.fixture
+        slash_context.fixture = active_fixture
+        try:
+            returned = active_fixture.value = fixture.get_value(kwargs, active_fixture)
+        finally:
+            slash_context.fixture = prev_context_fixture
+        _logger.trace(' -- {} = {!r}', relative_name, returned)
+        return returned
+
+    def _deactivate_fixture(self, fixture):
+        # in most cases it will be the last active fixture in its scope
+        active = self._active_fixtures_by_scope[fixture.info.scope].pop(fixture.info.id, None)
+        if active is not None:
+            active.do_cleanups()
+
+    def resolve(self):
+        while self._unresolved_fixture_ids:
+            fixture = self._fixtures_by_id[self._unresolved_fixture_ids.pop()]
+            fixture.resolve(self)
diff --git a/slash/core/fixtures/namespace.py b/slash/core/fixtures/namespace.py
new file mode 100755
index 0000000000..0fd7d06dc4
--- /dev/null
+++ b/slash/core/fixtures/namespace.py
@@ -0,0 +1,55 @@
+from sentinels import NOTHING
+from numbers import Number
+
+from ..._compat import itervalues
+from ...exceptions import UnknownFixtures
+
+
+class Namespace(object):
+
+    def __init__(self, store, parent=None):
+        super(Namespace, self).__init__()
+        self._level = 0 if parent is None else parent.get_level() + 1
+        self._store = store
+        self._parent = parent
+        self._fixture_names = {}
+
+    def get_level(self):
+        return self._level
+
+    def get_parent(self):
+        return self._parent
+
+    def iter_fixtures(self):
+        while self is not None:
+            for fixture_id in itervalues(self._fixture_names):
+                yield self._store.get_fixture_by_id(fixture_id)
+            self = self._parent
+
+    def __repr__(self):
+        return 'Fixture NS#{}: {}'.format(self.get_level(), ', '.join(self._iter_fixture_names()) or '**None**')
+
+    def _iter_fixture_names(self):
+        while self is not None:
+            for k in self._fixture_names:
+                yield k
+            self = self._parent
+
+    def get_fixture_by_name(self, name, default=NOTHING):
+        while self is not None:
+            fixture_id = self._fixture_names.get(name, NOTHING)
+            if fixture_id is NOTHING:
+                self = self._parent
+                continue
+            return self._store.get_fixture_by_id(fixture_id)
+
+        if default is not NOTHING:
+            return default
+
+        raise UnknownFixtures('Fixture {0!r} not found!'.format(name))
+
+    def add_name(self, name, fixture_id):
+        assert isinstance(fixture_id, Number)
+        assert name not in self._fixture_names or self._fixture_names[
+            name] == fixture_id
+        self._fixture_names[name] = fixture_id
diff --git a/slash/core/fixtures/parameters.py b/slash/core/fixtures/parameters.py
new file mode 100755
index 0000000000..76d3327ed5
--- /dev/null
+++ b/slash/core/fixtures/parameters.py
@@ -0,0 +1,161 @@
+import operator
+from contextlib import contextmanager
+
+from ..._compat import iteritems
+from ...utils.python import wraps, get_argument_names
+from .fixture_base import FixtureBase
+from .utils import FixtureInfo, get_scope_by_name
+
+_PARAM_INFO_ATTR_NAME = '__slash_parametrize__'
+
+
+def parametrize(parameter_name, values):
+    """Decorator to create multiple test cases out of a single function or module, where the cases vary by the value of ``parameter_name``,
+    as iterated through ``values``.
+    """
+
+    def decorator(func):
+
+        params = getattr(func, _PARAM_INFO_ATTR_NAME, None)
+        if params is None:
+            params = ParameterizationInfo(func)
+
+            @wraps(func, preserve=['__slash_fixture__'])
+            def new_func(*args, **kwargs):
+                # for better debugging. _current_variation gets set to None on context exit
+                variation = _current_variation
+                for name, param in params.iter_parametrization_fixtures():
+                    value = variation.get_param_value(param)
+                    if name not in kwargs:
+                        kwargs[name] = value
+                return func(*args, **kwargs)
+            setattr(new_func, _PARAM_INFO_ATTR_NAME, params)
+            returned = new_func
+        else:
+            returned = func
+
+        params.add_options(parameter_name, values)
+        return returned
+
+    return decorator
+
+
+def iterate(**kwargs):
+
+    def decorator(func):
+        for name, options in iteritems(kwargs):
+            func = parametrize(name, options)(func)
+        return func
+    return decorator
+
+
+def toggle(param_name):
+    """A shortcut for :func:`slash.parametrize(param_name, [True, False]) <slash.parametrize>`
+
+    .. note:: Also available for import as slash.parameters.toggle
+    """
+    return parametrize(param_name, (True, False))
+
+
+_current_variation = None
+
+
+@contextmanager
+def bound_parametrizations_context(variation, fixture_store, fixture_namespace):
+    global _current_variation  # pylint: disable=global-statement
+    assert _current_variation is None
+    _current_variation = variation
+    try:
+        fixture_store.activate_autouse_fixtures_in_namespace(fixture_namespace)
+        yield
+    finally:
+        _current_variation = None
+
+
+def iter_parametrization_fixtures(func):
+    if isinstance(func, FixtureBase):
+        func = func.fixture_func
+    param_info = getattr(func, _PARAM_INFO_ATTR_NAME, None)
+    if param_info is None:
+        return []
+    return param_info.iter_parametrization_fixtures()
+
+
+class ParameterizationInfo(object):
+
+    def __init__(self, func):
+        super(ParameterizationInfo, self).__init__()
+        self._argument_names = get_argument_names(func)
+        self._argument_name_set = frozenset(self._argument_names)
+        self._params = {}
+        self._extra_params = {}
+        self.path = '{}:{}'.format(func.__module__, func.__name__)
+
+    def add_options(self, param_name, values):
+        assert param_name not in self._params
+
+        if not isinstance(param_name, (list, tuple)):
+            names = (param_name,)
+            values = [[v] for v in values]
+        else:
+            names = param_name
+            values = list(values)
+            for value_set in values:
+                if not isinstance(value_set, (tuple, list)):
+                    raise RuntimeError('Invalid parametrization value (expected sequence): {0!r}'.format(value_set))
+                if len(value_set) != len(names):
+                    raise RuntimeError('Invalid parametrization value (invalid length): {0!r}'.format(value_set))
+
+        p = Parametrization(values=values, path='{}.{}'.format(self.path, param_name))
+        for index, name in enumerate(names):
+            if name in self._argument_name_set:
+                params_dict = self._params
+            else:
+                params_dict = self._extra_params
+            params_dict[name] = p.as_transform(operator.itemgetter(index))
+
+    def iter_parametrization_fixtures(self):
+        for name in self._argument_names:
+            values = self._params.get(name)
+            if values is not None:
+                yield name, values
+        for name, values in self._extra_params.items():
+            yield name, values
+
+
+def _id(obj):
+    return obj
+
+
+class Parametrization(FixtureBase):
+
+    def __init__(self, path, values, info=None, transform=_id):
+        super(Parametrization, self).__init__()
+        self.path = path
+        self.values = list(values)
+        if info is None:
+            info = FixtureInfo(path=path)
+        self.info = info
+        self.scope = get_scope_by_name('test')
+        self.transform = transform
+
+    def get_value_by_index(self, index):
+        return self.transform(self.values[index])
+
+    def is_parameter(self):
+        return True
+
+    def is_fixture(self):
+        return False
+
+    def get_value(self, kwargs, active_fixture):
+        raise NotImplementedError()  # pragma: no cover
+
+    def get_variations(self):
+        raise NotImplementedError()  # pragma: no cover
+
+    def _resolve(self, store):
+        return {}
+
+    def as_transform(self, transform):
+        return Parametrization(values=self.values, info=self.info, transform=transform, path=self.path)
diff --git a/slash/core/fixtures/utils.py b/slash/core/fixtures/utils.py
new file mode 100755
index 0000000000..423294f100
--- /dev/null
+++ b/slash/core/fixtures/utils.py
@@ -0,0 +1,162 @@
+import functools
+import itertools
+import inspect
+
+from sentinels import NOTHING
+import six
+
+from ...ctx import context
+from ..._compat import izip, iteritems
+from ...utils.python import get_arguments_dict, wraps
+from ...utils.function_marker import function_marker
+
+_id_gen = itertools.count(1000)
+
+
+def _ensure_fixture_info(func, **kwargs):
+    if not hasattr(func, '__slash_fixture__'):
+        func.__slash_fixture__ = FixtureInfo(func, **kwargs)
+    return func
+
+def fixture(func=None, name=None, scope=None, autouse=False):
+    if func is None:
+        return functools.partial(fixture, name=name, scope=scope, autouse=autouse)
+
+    if inspect.isgeneratorfunction(func):
+        return yield_fixture(func=func, name=name, scope=scope, autouse=autouse)
+    return _ensure_fixture_info(func=func, name=name, scope=scope, autouse=autouse)
+
+nofixtures = function_marker('__slash_nofixtures__')
+nofixtures.__doc__ = 'Marks the decorated function as opting out of automatic fixture deduction. ' + \
+                     'Slash will not attempt to parse needed fixtures from its argument list'
+
+
+class FixtureInfo(object):
+
+    def __init__(self, func=None, name=None, scope=None, autouse=False, path=None):
+        super(FixtureInfo, self).__init__()
+        self.path = path
+        self.id = next(_id_gen)
+        if name is None:
+            if func is None:
+                name = '__unnamed_{0}'.format(self.id)
+            else:
+                name = func.__name__
+        if scope is None:
+            scope = 'test'
+        self.name = name
+        self.func = func
+        self.autouse = autouse
+        self.scope = _SCOPES[scope]
+        if self.func is not None:
+
+            self.required_args = get_arguments_dict(self.func)
+        else:
+            self.required_args = {}
+        if 'this' in self.required_args:
+            self.required_args.pop('this')
+            self.needs_this = True
+        else:
+            self.needs_this = False
+
+def get_scope_by_name(scope_name):
+    return _SCOPES[scope_name]
+
+def get_scope_name_by_scope(scope_id):
+    return _SCOPES_BY_ID[scope_id]
+
+_SCOPES = dict(
+    izip(('test', 'module', 'session'), itertools.count()))
+
+_SCOPES_BY_ID = dict((id, name) for (name, id) in iteritems(_SCOPES))
+
+
+def generator_fixture(func):
+    """A utility for generating parametrization values from a generator:
+
+    >>> @slash.generator_fixture
+    ... def some_parameter():
+    ...     yield first_value
+    ...     yield second_value
+
+    .. note:: A generator parameter is a shortcut for a simple parametrized fixture, so the entire iteration is exhausted during test load time
+    """
+    from .parameters import parametrize
+
+    @parametrize('param', list(func()))
+    def new_func(param):
+        return param
+
+    new_func.__name__ = func.__name__
+    return _ensure_fixture_info(func=new_func)
+
+
+def yield_fixture(func=None, **kw):
+    """Builds a fixture out of a generator. The pre-yield part of the generator is used as the setup, where the
+    yielded value becomes the fixture value. The post-yield part is added as a cleanup:
+
+    >>> @slash.yield_fixture
+    ... def some_fixture(arg1, arg2):
+    ...     m = Microwave()
+    ...     m.turn_on(wait=True)
+    ...     yield m
+    ...     m.turn_off()
+    """
+
+    if func is None:
+        return functools.partial(yield_fixture, **kw)
+
+    func = _ensure_fixture_info(func=func, **kw)
+
+    @wraps(func)
+    def new_func(**kwargs):
+        f = func(**kwargs)
+        value = next(f)
+        @context.fixture.add_cleanup
+        def cleanup(): # pylint: disable=unused-variable
+            try:
+                next(f)
+            except StopIteration:
+                pass
+            else:
+                raise RuntimeError('Yielded fixture did not stop at cleanup')
+        return value
+    return new_func
+
+
+
+class _use_type(type):
+
+    def __getattr__(cls, attr):
+        if attr.startswith('_'):
+            raise AttributeError(attr)
+        return cls(attr)
+
+
+class use(six.with_metaclass(_use_type)): # pylint: disable=no-init
+    """
+    Allows tests to use fixtures under different names:
+
+    >>> def test_something(m: use('microwave')):
+    ...    ...
+
+    For cosmetic purposes, you can also use ``use`` with attribute access:
+
+    >>> def test_something(m: use.microwave):
+    ...    ...
+
+    """
+    def __init__(self, real_fixture_name):
+        self.real_fixture_name = real_fixture_name
+
+    def __repr__(self):
+        return '<slash.use({!r})>'.format(self.real_fixture_name)
+
+
+def get_real_fixture_name_from_argument(argument):
+    if argument.annotation is not NOTHING and isinstance(argument.annotation, use):
+        return argument.annotation.real_fixture_name
+    return argument.name
+
+
+__all__ = ['fixture', 'nofixtures', 'generator_fixture', 'yield_fixture', 'use']
diff --git a/slash/core/function_test.py b/slash/core/function_test.py
new file mode 100755
index 0000000000..ce0177dae5
--- /dev/null
+++ b/slash/core/function_test.py
@@ -0,0 +1,55 @@
+from types import GeneratorType
+from ..exceptions import InvalidTest
+
+from .fixtures.parameters import bound_parametrizations_context
+from .fixtures.utils import nofixtures
+from .requirements import get_requirements
+from .runnable_test import RunnableTest
+from .runnable_test_factory import RunnableTestFactory
+from .tagging import get_tags
+
+
+class FunctionTest(RunnableTest):
+
+    def __init__(self, function, fixture_store, fixture_namespace, variation):
+        super(FunctionTest, self).__init__(fixture_store, fixture_namespace, variation)
+        self._func = function
+
+    def get_tags(self):
+        return get_tags(self._func)
+
+    def get_address_in_factory(self):
+        return ''
+
+    def run(self):
+        with bound_parametrizations_context(self._variation, self._fixture_store, self._fixture_namespace):
+            result = self._fixture_store.call_with_fixtures(
+                self._func, namespace=self._fixture_namespace,
+                trigger_test_start=True, trigger_test_end=True,
+            )
+            if isinstance(result, GeneratorType):
+                raise InvalidTest('{} is a generator. Running generators is not supported'.format(self._func))
+
+    def get_test_function(self):
+        return self._func
+
+    def get_requirements(self):
+        test_requirements = get_requirements(self._func)
+        if nofixtures.is_marked(self._func):
+            return test_requirements
+        return list(set(test_requirements + self._get_fixtures_requirements()))
+
+    def get_required_fixture_objects(self):
+        return self._fixture_store.get_required_fixture_objects(self._func, namespace=self._fixture_namespace)
+
+
+class FunctionTestFactory(RunnableTestFactory):
+
+    def __init__(self, func):
+        super(FunctionTestFactory, self).__init__(func)
+        self.func = func
+
+    def _generate_tests(self, fixture_store):
+        namespace = fixture_store.get_current_namespace()
+        for variation in fixture_store.iter_parametrization_variations(funcs=[self.func]):
+            yield FunctionTest(self.func, fixture_store, namespace, variation)
diff --git a/slash/core/local_config.py b/slash/core/local_config.py
new file mode 100755
index 0000000000..53e0989e9f
--- /dev/null
+++ b/slash/core/local_config.py
@@ -0,0 +1,57 @@
+import os
+import dessert
+from emport import import_file
+from ..utils.python import check_duplicate_functions
+
+class LocalConfig(object):
+
+    def __init__(self):
+        super(LocalConfig, self).__init__()
+        self._slashconf_vars_cache = {}
+        self._configs = []
+        self.duplicate_funcs = set()
+
+    def push_path(self, path):
+        self._configs.append(self._build_config(path))
+
+    def pop_path(self):
+        self._configs.pop(-1)
+
+    def get_dict(self):
+        return self._configs[-1]
+
+    def _build_config(self, path):
+        confstack = []
+        for dir_path in self._traverse_upwards(path):
+            slashconf_vars = self._slashconf_vars_cache.get(dir_path)
+            if slashconf_vars is None:
+                slashconf_path = os.path.join(dir_path, 'slashconf.py')
+                if os.path.isfile(slashconf_path):
+                    self.duplicate_funcs |= check_duplicate_functions(slashconf_path)
+                    with dessert.rewrite_assertions_context():
+                        slashconf_vars = self._slashconf_vars_cache[dir_path] = vars(import_file(slashconf_path))
+
+            if slashconf_vars is not None:
+                confstack.append(slashconf_vars)
+
+        returned = {}
+        # start loading from the parent so that vars are properly overriden
+        for slashconf_vars in reversed(confstack):
+            returned.update(slashconf_vars)
+        return returned
+
+    def _traverse_upwards(self, path):
+        path = os.path.abspath(path)
+        if not os.path.exists(path):
+            raise RuntimeError("Path doesn't exist: {0}".format(path))
+
+        if os.path.isfile(path):
+            path = os.path.dirname(path)
+
+        while True:
+            yield path
+            if os.path.normcase(path) == os.path.normcase(os.path.abspath(os.path.sep)):
+                break
+            new_path = os.path.dirname(path)
+            assert new_path != path
+            path = new_path
diff --git a/slash/core/markers.py b/slash/core/markers.py
new file mode 100755
index 0000000000..fa357be38e
--- /dev/null
+++ b/slash/core/markers.py
@@ -0,0 +1,5 @@
+from ..utils.function_marker import function_marker, append_function_marker
+
+
+repeat_marker = function_marker('repeat')
+exclude_marker = append_function_marker('exclude')
diff --git a/slash/core/metadata.py b/slash/core/metadata.py
new file mode 100755
index 0000000000..6976b51628
--- /dev/null
+++ b/slash/core/metadata.py
@@ -0,0 +1,122 @@
+import itertools
+import sys
+
+from ..ctx import context
+
+_sort_key_generator = itertools.count(1)
+
+class Metadata(object):
+
+    """Class representing the metadata associated with a test object. Generally available
+    as test.__slash__
+    """
+
+    #: The index of the test in the current execution, 0-based
+    test_index0 = None
+
+    def __init__(self, factory, test):
+        super(Metadata, self).__init__()
+        #: The test's unique id
+        self.id = None
+        self.tags = test.get_tags()
+        self._sort_key = next(_sort_key_generator)
+        if factory is not None:
+            #: The path to the file from which this test was loaded
+            self.module_name = factory.get_module_name()
+            assert self.module_name, 'Could not find module for {0}'.format(test)
+            self.file_path = factory.get_filename()
+            self.factory_name = factory.get_factory_name()
+        else:
+            self.module_name = type(test).__module__
+            self.file_path = sys.modules[self.module_name].__file__
+            self.factory_name = '?'
+        self.variation = test.get_variation()
+        assert self.variation is not None
+
+        #: Address string to identify the test inside the file from which it was loaded
+        self.address_in_file = self.factory_name
+        self.address_in_factory = test.get_address_in_factory()
+        if self.address_in_factory is not None:
+            self.address_in_file += self.address_in_factory
+        #: String identifying the test, to be used when logging or displaying results in the console
+        #: generally it is composed of the file path and the address inside the file
+        self.address = '{0}:{1}'.format(self.file_path, self.address_in_file)
+        if self.variation:
+            self.address += '({})'.format(self.variation.safe_repr)
+        if factory is not None:
+            self._class_name = factory.get_class_name()
+        else:
+            testfunc = test.get_test_function()
+            if hasattr(testfunc, '__self__'):
+                self._class_name = testfunc.__self__.__class__.__name__
+            else:
+                self._class_name = None
+
+        self._interactive = False
+
+    def allocate_id(self):
+        assert self.id is None
+        self.id = context.session.id_space.allocate()
+
+
+    def set_sort_key(self, key):
+        self._sort_key = key
+
+    def get_sort_key(self):
+        return self._sort_key
+
+    def set_test_full_name(self, name):
+        assert hasattr(self, 'address')
+        self.address = name
+
+    def is_interactive(self):
+        return self._interactive
+
+    def mark_interactive(self):
+        self._interactive = True
+        assert hasattr(self, 'file_path')
+        self.file_path = '<Interactive>'
+        self.factory_name = self.address = 'Interactive'
+        self.set_sort_key(0)
+
+    @property
+    def class_name(self):
+        return self._class_name
+
+    @property
+    def function_name(self):
+        returned = self.address_in_file
+        if self._class_name:
+            prefix = self._class_name + '.'
+            assert returned.startswith(prefix)
+            returned = returned[len(prefix):]
+
+        return returned.split('(')[0]
+
+    @property
+    def test_index1(self):
+        """Same as ``test_index0``, only 1-based
+        """
+        if self.test_index0 is None:
+            return None
+        return self.test_index0 + 1
+
+    def __repr__(self):
+        return '<{0}>'.format(self.address)
+
+    def __eq__(self, other):
+        if isinstance(other, self.__class__):
+            return self.address == other.address
+        return False
+
+    def __ne__(self, other):
+        return not (self == other)  # pylint: disable=superfluous-parens,unneeded-not
+
+    def __hash__(self):
+        return self.address.__hash__()
+
+def ensure_test_metadata(test):
+    returned = getattr(test, "__slash__", None)
+    if returned is None:
+        returned = test.__slash__ = Metadata(None, test)
+    return returned
diff --git a/slash/core/requirements.py b/slash/core/requirements.py
new file mode 100755
index 0000000000..f677e8fcf6
--- /dev/null
+++ b/slash/core/requirements.py
@@ -0,0 +1,60 @@
+_SLASH_REQUIRES_KEY_NAME = '__slash_requirements__'
+
+
+def requires(req, message=None):
+    """A decorator specifying that the decorated tests requires a certain precondition in order to run
+
+    :param req: Either a function receiving no arguments and returning a boolean, or a boolean specifying whether or not
+       the requirement is met
+    """
+    if not isinstance(req, Requirement):
+        req = Requirement(req, message)
+    else:
+        assert message is None, 'Cannot specify message when passing Requirement objects to slash.requires'
+
+    def decorator(func):
+        reqs = getattr(func, _SLASH_REQUIRES_KEY_NAME, None)
+        if reqs is None:
+            reqs = []
+            setattr(func, _SLASH_REQUIRES_KEY_NAME, reqs)
+        reqs.append(req)
+        return func
+    return decorator
+
+
+def get_requirements(test):
+    return list(getattr(test, _SLASH_REQUIRES_KEY_NAME, []))
+
+
+class Requirement(object):
+
+    def __init__(self, req, message=None):
+        super(Requirement, self).__init__()
+        self._req = req
+        self._message = message
+
+    def __repr__(self):
+        if self._message is not None:
+            return self._message
+        if isinstance(self._req, bool):
+            return '?'
+        if hasattr(self._req, '__name__'):
+            return '<{0.__name__}>'.format(self._req)
+        return repr(self._req)
+
+    def is_met(self):
+        if isinstance(self._req, bool):
+            return self._req, self._message
+        returned = self._req()
+        if not isinstance(returned, tuple):
+            returned = (returned, self._message)
+        return returned
+
+
+class Skip(Requirement):
+    """
+    A special requirement used for implementing @slash.skipped
+    """
+    def __init__(self, reason=None):
+        super(Skip, self).__init__(False, reason)
+        self.reason = reason
diff --git a/slash/core/result.py b/slash/core/result.py
new file mode 100755
index 0000000000..e32033ed8c
--- /dev/null
+++ b/slash/core/result.py
@@ -0,0 +1,434 @@
+import functools
+import itertools
+import os
+import pickle
+import sys
+from numbers import Number
+
+import gossip
+import logbook
+from vintage import deprecated
+
+from .. import hooks
+from .._compat import OrderedDict, itervalues
+from ..ctx import context
+from ..exception_handling import capture_sentry_exception
+from .. import exceptions
+from ..utils.exception_mark import ExceptionMarker
+from ..utils.interactive import notify_if_slow_context
+from ..utils.python import unpickle
+from .details import Details
+from .error import Error
+
+_logger = logbook.Logger(__name__)
+
+_ADDED_TO_RESULT = ExceptionMarker('added_to_result')
+
+
+class Result(object):
+    """Represents a single result for a test which was run
+    """
+    pickle_key_blacklist = {'test_metadata', 'facts'}
+
+    def __init__(self, test_metadata=None):
+        super(Result, self).__init__()
+        self.test_metadata = test_metadata
+        #: dictionary to be use by tests and plugins to store result-related information for later analysis
+        self.data = {}
+        self._errors = []
+        self._failures = []
+        self._skips = []
+        #: a :class:`slash.core.details.Details` instance for storing additional test details
+        self.details = Details()
+        self.facts = Details(set_callback=self._fact_set_callback)
+        self._started = False
+        self._finished = False
+        self._interrupted = False
+        self._log_path = None
+        self._extra_logs = []
+
+    def _fact_set_callback(self, fact_name, fact_value):
+        gossip.trigger('slash.fact_set', name=fact_name, value=fact_value)
+
+    def is_global_result(self):
+        return False
+
+    def serialize(self):
+        serialized_object = {}
+        for key, value in vars(self).items():
+            if key not in Result.pickle_key_blacklist:
+                try:
+                    serialized_object[key] = pickle.dumps(value)
+                except (pickle.PicklingError, TypeError):
+                    _logger.debug('Failed serializing result, skipping this value. key = {}'.format(key))
+                    capture_sentry_exception()
+        return serialized_object
+
+    def deserialize(self, result_dict):
+        for key, value in result_dict.items():
+            try:
+                self.__dict__[key] = unpickle(value)
+            except TypeError:
+                _logger.error('Error when deserialize reult, skipping this value. key = {}'.format(key))
+        for failure in self._failures:
+            self.add_failure(failure, append=False)
+        for error in self._errors:
+            self.add_error(error, append=False)
+        for skip in self._skips:
+            self.add_skip(skip, append=False)
+
+    def add_exception(self, exc_info=None):
+        """Adds the currently active exception, assuming it wasn't already added to a result
+        """
+        if exc_info is None:
+            exc_info = sys.exc_info()
+        _, exc_value, _ = exc_info  # pylint: disable=unpacking-non-sequence
+
+        if _ADDED_TO_RESULT.is_exception_marked(exc_value):
+            return
+
+        _ADDED_TO_RESULT.mark_exception(exc_value)
+        if isinstance(exc_value, exceptions.FAILURE_EXCEPTION_TYPES):
+            self.add_failure()
+        elif isinstance(exc_value, context.session.get_skip_exception_types()):
+            self.add_skip(getattr(exc_value, 'reason', str(exc_value)))
+        elif isinstance(exc_value, exceptions.INTERRUPTION_EXCEPTIONS):
+            err = Error.capture_exception(exc_info=exc_info)
+            hooks.interruption_added(result=self, exception=err) # pylint: disable=no-member
+            session_result = context.session.results.global_result
+            interrupted_test = self.is_interrupted()
+            interrupted_session = session_result.is_interrupted()
+            if not self.is_global_result():
+                self.mark_interrupted()
+                if not interrupted_test and not context.session.has_children():
+                    with notify_if_slow_context(message="Cleaning up test due to interrupt. Please wait..."):
+                        hooks.test_interrupt() # pylint: disable=no-member
+            if not interrupted_session:
+                session_result.mark_interrupted()
+
+        elif not isinstance(exc_value, GeneratorExit):
+            #skip keyboardinterrupt and system exit
+            self.add_error(exc_info=exc_info)
+        else:
+            _logger.trace('Ignoring GeneratorExit exception')
+
+    def has_errors_or_failures(self):
+        return bool(self._failures or self._errors)
+
+    def get_log_path(self):
+        """Returns log path
+        """
+        return self._log_path
+
+    def set_log_path(self, path):
+        """Set log path
+        """
+        self._log_path = path
+
+    def get_log_dir(self):
+        """Returns log's directory.
+        """
+        if self._log_path is None:
+            return None
+        return os.path.dirname(self._log_path)
+
+    def add_extra_log_path(self, path):
+        """Add additional log path. This path will be added to the list returns by get_log_paths
+        """
+        self._extra_logs.append(path)
+
+    def get_log_paths(self):
+        """Returns a list of all log paths
+        """
+        logs = []
+        if self._log_path:
+            logs.append(self._log_path)
+        return logs + list(self._extra_logs)
+
+    def is_started(self):
+        return self._started
+
+    def is_not_run(self):
+        return not self._started
+
+    def mark_started(self):
+        self._started = True
+
+    def is_error(self):
+        return bool(self._errors)
+
+    @property
+    def test_id(self):
+        return self.test_metadata.id
+
+    def is_failure(self):
+        return bool(self._failures)
+
+    def is_just_failure(self):
+        """Indicates this is a pure failure, without errors involved"""
+        return self.is_failure() and not self.is_error()
+
+    def is_skip(self):
+        return bool(self._skips)
+
+    def is_run_and_skip(self):
+        return self.is_started() and self.is_skip()
+
+    def is_success(self, allow_skips=False):
+        if not self.is_started():
+            return allow_skips
+        returned = not self._errors and not self._failures and not self._interrupted
+        if not allow_skips:
+            returned &= not self._skips
+        return returned
+
+    def is_success_finished(self):
+        return self.is_success() and self.is_finished()
+
+    def is_finished(self):
+        return self._finished
+
+    def mark_finished(self):
+        self._finished = True
+
+    def mark_interrupted(self):
+        self._interrupted = True
+
+    def is_interrupted(self):
+        return self._interrupted
+
+    def add_error(self, e=None, frame_correction=0, exc_info=None, append=True):
+        """Adds a failure to the result
+        """
+        err = self._add_error(self._errors, e, frame_correction=frame_correction + 1, exc_info=exc_info, append=append)
+        context.reporter.report_test_error_added(context.test, err)
+        return err
+
+    def add_failure(self, e=None, frame_correction=0, exc_info=None, append=True):
+        """Adds a failure to the result
+        """
+        err = self._add_error(self._failures, e, frame_correction=frame_correction + 1, exc_info=exc_info, is_failure=True, append=append)
+        context.reporter.report_test_failure_added(context.test, err)
+        return err
+
+    def set_test_detail(self, key, value):
+        """Adds a generic detail to this test result, which can be later inspected or used
+        """
+        self.details.set(key, value)
+
+    def _add_error(self, error_list, error=None, frame_correction=0, exc_info=None, is_failure=False, append=True):
+        try:
+            if error is None:
+                error = Error.capture_exception(exc_info=exc_info)
+                if error is None:
+                    raise RuntimeError('add_error() must be called with either an argument or in an active exception')
+            if not isinstance(error, Error):
+                error = Error(error, frame_correction=frame_correction + 1, exc_info=exc_info)
+            if is_failure:
+                # force the error object to be marked as failure
+                error.mark_as_failure()
+            _logger.debug('Error added: {0}\n{0.traceback}', error, extra={'highlight': True})
+            if append:
+                error_list.append(error)
+            if not context.session or not context.session.has_children():
+                hooks.error_added(result=self, error=error)  # pylint: disable=no-member
+            error.forget_exc_info()
+            return error
+        except Exception:
+            _logger.error("Failed to add error to result", exc_info=True)
+            raise
+
+    def add_skip(self, reason, append=True):
+        if append:
+            self._skips.append(reason)
+        context.reporter.report_test_skip_added(context.test, reason)
+
+    def get_errors(self):
+        """Returns the list of errors recorded for this result
+
+        :return: a list of :class:`slash.core.error.Error` objects
+        """
+        return self._errors
+
+    def get_failures(self):
+        """Returns the list of failures recorded for this result
+
+        :return: a list of :class:`slash.core.error.Error` objects
+        """
+        return self._failures
+
+    @deprecated('Use result.details.all()', since='0.20.0')
+    def get_additional_details(self):
+        return self.details.all()
+
+    def get_skips(self):
+        return self._skips
+
+    def has_skips(self):
+        return bool(self._skips)
+
+    def has_fatal_errors(self):
+        return any(e.is_fatal() for e in
+                   itertools.chain(self._errors, self._failures))
+
+    has_fatal_exception = has_fatal_errors
+
+    def __repr__(self):
+        return "< Result ({0})>".format(
+            ", ".join(
+                attr
+                for attr in ("success", "error", "failure", "skip", "finished", "interrupted")
+                if getattr(self, "is_{0}".format(attr))()
+            )
+        )
+
+
+class GlobalResult(Result):
+
+    def is_global_result(self):
+        return True
+
+
+
+class SessionResults(object):
+
+    def __init__(self, session):
+        super(SessionResults, self).__init__()
+        self.session = session
+        self.global_result = GlobalResult()
+        self._results_dict = OrderedDict()
+        self._iterator = functools.partial(itervalues, self._results_dict)
+
+    def __len__(self):
+        return len(self._results_dict)
+
+    def __repr__(self):
+        return '<Results: {0} successful, {1} errors, {2} failures, {3} skips>'.format(
+            self.get_num_successful(),
+            self.get_num_errors(),
+            self.get_num_failures(),
+            self.get_num_skipped())
+
+    def iter_all_additional_details(self):
+        for result in self.iter_all_results():
+            if result.details:
+                yield result, result.get_additional_details()
+
+    def iter_all_failures(self):
+        """Iterates over all results which have failures
+
+        yields tuples of the form (result, failure_list)
+        """
+        for result in self.iter_all_results():
+            if result.get_failures():
+                yield result, result.get_failures()
+
+    def iter_all_errors(self):
+        """Iterates over all results which have errors
+
+        yields tuples of the form (result, errors_list)
+        """
+        for result in self.iter_all_results():
+            if result.get_errors():
+                yield result, result.get_errors()
+
+    @property
+    def current(self):
+        """Obtains the currently running result, if exists
+
+        Otherwise, returns the global result object
+        """
+        test_id = context.test_id
+        if test_id is None:
+            return self.global_result
+        return self._results_dict[test_id]
+
+    def __iter__(self):
+        return self._iterator()
+
+    def is_success(self, allow_skips=False):
+        """Indicates whether this run is successful
+
+        :param allow_skips: Whether to consider skips as unsuccessful
+        """
+        if not self.global_result.is_success():
+            return False
+        for result in self._iterator():
+            if not result.is_finished() and not result.is_skip():
+                return False
+            if not result.is_success(allow_skips=allow_skips):
+                return False
+        return True
+
+    def is_interrupted(self):
+        """Indicates if this session was interrupted
+        """
+        return any(result.is_interrupted() for result in self._iterator())
+
+    def get_num_results(self):
+        return len(self._results_dict)
+
+    def get_num_started(self):
+        return self._count(Result.is_started, include_global=False)
+
+    def get_num_successful(self):
+        return self._count(Result.is_success_finished, include_global=False)
+
+    def get_num_errors(self):
+        return self._count(Result.is_error)
+
+    def get_num_failures(self):
+        return self._count(Result.is_just_failure)
+
+    def get_num_skipped(self, include_not_run=True):
+        if include_not_run:
+            return self._count(Result.is_skip)
+        return self._count(Result.is_run_and_skip)
+
+    def get_num_not_run(self):
+        return self._count(Result.is_not_run, include_global=False)
+
+    def has_fatal_errors(self):
+        """Indicates whether any result has an error marked as fatal (causing the session to terminate)
+        """
+        return bool(self._count(Result.has_fatal_errors))
+
+    def _count(self, pred, include_global=True):
+        returned = 0
+        iterator = self.iter_all_results(
+        ) if include_global else self.iter_test_results()
+        for result in iterator:
+            if pred(result):
+                returned += 1
+        return returned
+
+    def iter_test_results(self):
+        """Iterates over results belonging to tests
+        """
+        return iter(self)
+
+    def iter_all_results(self):
+        """Iterates over all results, ending with the global result object
+        """
+        return itertools.chain(self.iter_test_results(), [self.global_result])
+
+    def create_result(self, test):
+        assert test.__slash__.id not in self._results_dict
+        returned = Result(test.__slash__)
+        self._results_dict[test.__slash__.id] = returned
+        return returned
+
+    def get_result(self, test):
+        """Returns the result stored belonging to a given test
+        """
+        if test.__slash__ is None:
+            raise LookupError("Could not find result for {0}".format(test))
+        return self._results_dict[test.__slash__.id]
+
+    def __getitem__(self, test):
+        if isinstance(test, Number):
+            try:
+                return next(itertools.islice(itervalues(self._results_dict), test, test + 1))
+            except StopIteration:
+                raise IndexError()
+        return self.get_result(test)
diff --git a/slash/core/runnable_test.py b/slash/core/runnable_test.py
new file mode 100755
index 0000000000..f12b7aa75c
--- /dev/null
+++ b/slash/core/runnable_test.py
@@ -0,0 +1,71 @@
+import copy
+from .tagging import NO_TAGS
+
+class RunnableTest(object):
+
+    """
+    This class is meant to serve as a base class to any test that can
+    actually be executed by the Slash runner.
+    """
+    __slash__ = None
+
+    def __init__(self, fixture_store, fixture_namespace, variation):
+        super(RunnableTest, self).__init__()
+        self._fixture_store = fixture_store
+        self._fixture_namespace = fixture_namespace
+        self._variation = variation
+
+    def clone(self):
+        returned = copy.copy(self)
+        for copied_attr in ('_variation', '__slash__'):
+            setattr(returned, copied_attr, copy.copy(getattr(returned, copied_attr)))
+        return returned
+
+    @property
+    def id(self):
+        return self.__slash__.id
+
+    def get_variation(self):
+        return self._variation
+
+    def get_address_in_factory(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def run(self):
+        """
+        This method is meant to be overriden by derived classes to actually
+        perform the test logic
+        """
+        raise NotImplementedError()  # pragma: no cover
+
+    def get_tags(self):
+        return NO_TAGS
+
+    def get_test_function(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def get_unmet_requirements(self):
+        returned = []
+        for req in self.get_requirements():
+            is_met, reason = req.is_met()
+            if not is_met:
+                returned.append((req, reason))
+        return returned
+
+    def _get_fixtures_requirements(self):
+        fixture_requirements = [item for fixture in self.get_required_fixture_objects() for item in fixture.get_requirements(self._fixture_store)]
+        autouse_fixture_requirements = [item for fixture in self._fixture_store.iter_autouse_fixtures_in_namespace(self.get_fixture_namespace()) \
+                            for item in fixture.get_requirements(self._fixture_store)]
+        return list(set(fixture_requirements + autouse_fixture_requirements))
+
+    def get_requirements(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def get_required_fixture_objects(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def get_fixture_namespace(self):
+        return self._fixture_namespace
+
+    def __repr__(self):
+        return '<Runnable test {0!r}>'.format(self.__slash__)
diff --git a/slash/core/runnable_test_factory.py b/slash/core/runnable_test_factory.py
new file mode 100755
index 0000000000..2f4c2b5722
--- /dev/null
+++ b/slash/core/runnable_test_factory.py
@@ -0,0 +1,60 @@
+import sys
+
+from .metadata import Metadata
+
+
+class RunnableTestFactory(object):
+
+    def __init__(self, param=None):
+        super(RunnableTestFactory, self).__init__()
+        self._param = param
+        self._factory_name = self._filename = self._module_name = None
+
+    def set_factory_name(self, name):
+        self._factory_name = name
+
+    def get_factory_name(self):
+        returned = self._factory_name
+        if returned is None:
+            returned = self._param.__name__
+        assert returned
+        return returned
+
+    def get_class_name(self):
+        return None
+
+    def set_module_name(self, module_name):
+        self._module_name = module_name
+
+    def get_module_name(self):
+        returned = self._module_name
+        if returned is None:
+            returned = self._param.__module__
+        assert returned
+        return returned
+
+    def set_filename(self, filename):
+        self._filename = filename
+
+    def get_filename(self):
+        returned = self._filename
+        if returned is None:
+            returned = sys.modules[self._param.__module__].__file__
+        if returned.endswith('.pyc'):
+            returned = returned[:-1]
+        assert returned
+        return returned
+
+    def generate_tests(self, fixture_store):
+        """
+        Generates :class:`.RunnableTest` instances to run
+
+        Do not override this method directly. Use :func:`.RunnableTestFactory._generate_tests` instead.
+        """
+        for test in self._generate_tests(fixture_store):
+            assert test.__slash__ is None
+            test.__slash__ = Metadata(self, test)
+            yield test
+
+    def _generate_tests(self, fixture_store):
+        raise NotImplementedError()  # pragma: no cover
diff --git a/slash/core/scope_manager.py b/slash/core/scope_manager.py
new file mode 100755
index 0000000000..7f7a8a08f6
--- /dev/null
+++ b/slash/core/scope_manager.py
@@ -0,0 +1,58 @@
+import functools
+
+import logbook
+
+from ..utils.python import call_all_raise_first
+
+_logger = logbook.Logger(__name__)
+
+class ScopeManager(object):
+
+    def __init__(self, session):
+        super(ScopeManager, self).__init__()
+        self._session = session
+        self._scopes = []
+        self._last_module = self._last_test = None
+
+    def begin_test(self, test):
+        test_module = test.__slash__.module_name
+        assert test_module
+
+        if self._last_module is None:
+            self._push_scope('session')
+
+
+        if self._last_module != test_module:
+            if self._last_module is not None:
+                _logger.trace('Module scope has changed. Popping previous module scope')
+                self._pop_scope('module')
+            assert self._scopes[-1] != 'module'
+            self._push_scope('module')
+        self._last_module = test_module
+        self._push_scope('test')
+        self._last_test = test
+
+    def end_test(self, test):
+        assert test == self._last_test
+        self._pop_scope('test')
+
+    def get_current_stack(self):
+        return self._scopes[:]
+
+    def _push_scope(self, scope):
+        self._scopes.append(scope)
+        _logger.trace('Pushed scope {0}', scope)
+        self._session.fixture_store.push_scope(scope)
+        self._session.cleanups.push_scope(scope)
+
+    def _pop_scope(self, scope):
+        popped = self._scopes.pop()
+        _logger.trace('Popping scope {0} (expected {1})', popped, scope)
+        assert popped == scope
+        call_all_raise_first([self._session.cleanups.pop_scope, self._session.fixture_store.pop_scope],
+                             scope)
+        _logger.trace('Popped scope {0}', popped)
+
+    def flush_remaining_scopes(self):
+        call_all_raise_first([functools.partial(self._pop_scope, s)
+                              for s in self._scopes[::-1]])
diff --git a/slash/core/session.py b/slash/core/session.py
new file mode 100755
index 0000000000..2d1effdbcb
--- /dev/null
+++ b/slash/core/session.py
@@ -0,0 +1,150 @@
+import itertools
+import sys
+import socket
+import time
+import uuid
+from contextlib import contextmanager
+from ..conf import config
+from .. import ctx, hooks, log, exceptions
+from .cleanup_manager import CleanupManager
+from ..exception_handling import handling_exceptions
+from ..interfaces import Activatable
+from ..reporting.null_reporter import NullReporter
+from ..utils.id_space import IDSpace
+from ..utils.interactive import notify_if_slow_context
+from ..warnings import SessionWarnings
+from .fixtures.fixture_store import FixtureStore
+from .result import SessionResults
+from .scope_manager import ScopeManager
+
+
+class Session(Activatable):
+    """ Represents a slash session
+    """
+
+    start_time = end_time = host_fqdn = host_name = None
+
+    def __init__(self, reporter=None, console_stream=None):
+        super(Session, self).__init__()
+        self.parent_session_id = config.root.parallel.parent_session_id
+        self.id = "{0}_0".format(uuid.uuid1()) if not self.parent_session_id else \
+                    "{}_{}".format(self.parent_session_id.split('_')[0], config.root.parallel.worker_id)
+        self.id_space = IDSpace(self.id)
+        self.test_index_counter = itertools.count()
+        self.scope_manager = ScopeManager(self)
+        self._started = False
+        self._complete = False
+        self._active = False
+        self._active_context = None
+        self.parallel_manager = None
+        self.fixture_store = FixtureStore()
+        self.warnings = SessionWarnings()
+        self.logging = log.SessionLogging(self, console_stream=console_stream)
+        self.current_parallel_test_index = None
+        #: an aggregate result summing all test results and the global result
+        self.results = SessionResults(self)
+        if reporter is None:
+            reporter = NullReporter()
+        self.reporter = reporter
+        self.cleanups = CleanupManager()
+
+        self._skip_exc_types = (exceptions.SkipTest,)
+
+    def register_skip_exception(self, exc_type):
+        self._skip_exc_types += (exc_type,)
+
+    def get_skip_exception_types(self):
+        return self._skip_exc_types
+
+    def has_children(self):
+        return not self.parallel_manager is None
+
+    @property
+    def started(self):
+        return self._started
+
+    def activate(self):
+        assert not self._active, 'Attempted to activate an already-active session'
+        with handling_exceptions():
+            ctx.push_context()
+            assert ctx.context.session is None
+            assert ctx.context.result is None
+            ctx.context.session = self
+            ctx.context.result = self.results.global_result
+            self._logging_context = self.logging.get_session_logging_context()
+            self._logging_context.__enter__()
+
+            self._warning_capture_context = self.warnings.capture_context()
+            self._warning_capture_context.__enter__()
+        self._active = True
+
+    def deactivate(self):
+        assert self._active, 'Session not active'
+        self._active = False
+        self.results.global_result.mark_finished()
+
+        exc_info = sys.exc_info()
+
+        self._warning_capture_context.__exit__(*exc_info) # pylint: disable=no-member
+        self._warning_capture_context = None
+
+        self._logging_context.__exit__(*exc_info) # pylint: disable=no-member
+        self._logging_context = None
+        ctx.pop_context()
+
+    @property
+    def duration(self):
+        if self.end_time is not None:
+            return self.end_time - self.start_time
+        curr_time = time.time()
+        return (self.end_time or curr_time) - (self.start_time or curr_time)
+
+    @contextmanager
+    def get_started_context(self):
+        if self.host_fqdn is None:
+            type(self).host_fqdn = socket.getfqdn()
+        self.host_name = self.host_fqdn.split('.')[0]
+        self.start_time = time.time()
+        self.results.global_result.mark_started()
+        self.cleanups.push_scope('session-global')
+        session_start_called = False
+        try:
+            with handling_exceptions():
+                with notify_if_slow_context("Initializing session..."):
+                    hooks.before_session_start()  # pylint: disable=no-member
+                    hooks.session_start()  # pylint: disable=no-member
+                    session_start_called = True
+                    hooks.after_session_start()  # pylint: disable=no-member
+            self._started = True
+            yield
+        except exceptions.INTERRUPTION_EXCEPTIONS:
+            hooks.session_interrupt() # pylint: disable=no-member
+            raise
+        finally:
+            self._started = False
+            self.results.global_result.mark_finished()
+            self.end_time = time.time()
+
+            with handling_exceptions():
+                self.cleanups.pop_scope('session-global')
+
+            if session_start_called:
+                with handling_exceptions():
+                    hooks.session_end()  # pylint: disable=no-member
+            self.reporter.report_session_end(self)
+
+    def mark_complete(self):
+        self._complete = True
+
+    def is_complete(self):
+        return self._complete
+
+    _total_num_tests = 0
+
+    def get_total_num_tests(self):
+        """Returns the total number of tests expected to run in this session
+        """
+        return self._total_num_tests
+
+    def increment_total_num_tests(self, increment):
+        self._total_num_tests += increment
diff --git a/slash/core/tagging.py b/slash/core/tagging.py
new file mode 100755
index 0000000000..4d9c0d28aa
--- /dev/null
+++ b/slash/core/tagging.py
@@ -0,0 +1,87 @@
+import functools
+
+from sentinels import NOTHING
+
+from .._compat import iteritems
+
+_TAGS_NAME = '__slash_tags__'
+
+
+def tag_test(test, tag_name, tag_value):
+    tags = get_tags(test)
+    if tags is NO_TAGS:
+        tags = Tags()
+        setattr(test, _TAGS_NAME, tags)
+    assert tag_name not in tags
+    tags[tag_name] = tag_value
+    return test
+
+
+def tag(tag_name, tag_value=NOTHING):
+    """Decorator for tagging tests
+    """
+    return functools.partial(tag_test, tag_name=tag_name, tag_value=tag_value)
+
+
+def get_tags(test):
+    return getattr(test, _TAGS_NAME, NO_TAGS)
+
+
+class Tags(object):
+
+    def __init__(self, tags=None):
+        super(Tags, self).__init__()
+        if tags is None:
+            tags = {}
+        self._tags = tags
+
+    def __setitem__(self, tag_name, value):
+        self._tags[tag_name] = value
+
+    def __getitem__(self, tag_name):
+        return self._tags[tag_name]
+
+    def __contains__(self, tag_name):
+        return tag_name in self._tags
+
+    has_tag = __contains__
+
+    def __add__(self, other):
+        if other is NO_TAGS:
+            return self
+        new_tags = self._tags.copy()
+        new_tags.update(other._tags) # pylint: disable=protected-access
+        return Tags(new_tags)
+
+    def matches_pattern(self, pattern):
+        if '=' in pattern:
+            key, predicate = pattern.split('=', 1)
+            value = self._tags.get(key, NOTHING)
+            return value is not NOTHING and str(value) == predicate
+
+        for key, value in iteritems(self._tags):
+            if pattern in key:
+                return True
+        return False
+
+    def __iter__(self):
+        return iter(self._tags)
+
+
+class _NoTags(object):
+
+    def __contains__(self, tag_name):
+        return False
+
+    def __add__(self, other):
+        return other
+
+    has_tag = __contains__
+
+    def matches_pattern(self, pattern): # pylint: disable=unused-argument
+        return False
+
+    def __iter__(self):
+        return iter([])
+
+NO_TAGS = _NoTags()
diff --git a/slash/core/test.py b/slash/core/test.py
new file mode 100755
index 0000000000..7732a1c2ed
--- /dev/null
+++ b/slash/core/test.py
@@ -0,0 +1,162 @@
+import functools
+import itertools
+from types import GeneratorType
+
+from .._compat import iteritems, izip
+from ..exception_handling import handling_exceptions
+from ..exceptions import SkipTest, InvalidTest
+from .fixtures.parameters import bound_parametrizations_context
+from .runnable_test import RunnableTest
+from .runnable_test_factory import RunnableTestFactory
+from .requirements import get_requirements
+from .tagging import get_tags
+from .fixtures.utils import nofixtures
+
+class TestTestFactory(RunnableTestFactory):
+
+    def __init__(self, testclass):
+        super(TestTestFactory, self).__init__(testclass)
+        self.testclass = testclass
+
+    def get_class_name(self):
+        return self.testclass.__name__
+
+    def _generate_tests(self, fixture_store):
+        if is_abstract_base_class(self.testclass):
+            return
+
+        for test_method_name in dir(self.testclass):
+            if not test_method_name.startswith("test"):
+                continue
+
+            for fixture_variation in self._iter_parametrization_variations(test_method_name, fixture_store):
+                case = self.testclass(
+                    test_method_name,
+                    fixture_store=fixture_store,
+                    fixture_namespace=fixture_store.get_current_namespace(),
+                    variation=fixture_variation,
+                )
+                if self.testclass.__slash_skipped__:
+                    case.run = functools.partial(SkipTest.throw, self.testclass.__slash_skipped_reason__)
+                yield case  # pylint: disable=protected-access
+
+    def _iter_parametrization_variations(self, test_method_name, fixture_store):
+        return fixture_store.iter_parametrization_variations(methods=itertools.chain(
+            izip(itertools.repeat('before'), self._get_all_before_methods()),
+            izip(itertools.repeat('after'), self._get_all_after_methods()),
+            [getattr(self.testclass, test_method_name)],
+        ))
+
+    def _get_all_before_methods(self):
+        return self._iter_inherited_methods('before')
+
+    def _get_all_after_methods(self):
+        return self._iter_inherited_methods('after')
+
+    def _iter_inherited_methods(self, name):
+
+        for cls in self.testclass.__mro__:
+            if hasattr(cls, name):
+                yield getattr(cls, name)
+
+    def get_unmet_requirements(self):
+        raise NotImplementedError() # pragma: no cover
+
+
+class Test(RunnableTest):
+    """
+    This is a base class for implementing unittest-style test classes.
+    """
+    def __init__(self, test_method_name, fixture_store, fixture_namespace, variation):
+        super(Test, self).__init__(fixture_store, fixture_namespace, variation)
+        self._test_method_name = test_method_name
+
+    def get_test_function(self):
+        return getattr(self, self._test_method_name)
+
+    def get_tags(self):
+        return get_tags(type(self)) + get_tags(getattr(type(self), self._test_method_name))
+
+    __slash_skipped__ = False
+    __slash_skipped_reason__ = None
+    __slash_needed_contexts__ = None
+
+
+    @classmethod
+    def skip_all(cls, reason=None):
+        cls.__slash_skipped__ = True
+        cls.__slash_skipped_reason__ = reason
+
+    def get_required_fixture_objects(self):
+        method = self.get_test_function()
+        return self._fixture_store.get_required_fixture_objects(method, namespace=self._fixture_namespace)
+
+    def get_address_in_factory(self):
+        returned = ''
+        if self._test_method_name is not None:
+            returned += ".{0}".format(self._test_method_name)
+        return returned
+
+    def _get_call_string(self, kwargs):
+        if not kwargs:
+            return ""
+        return "({0})".format(", ".join("{0}={1!r}".format(k, v) for k, v in iteritems(kwargs)))
+
+    def get_requirements(self):
+        test_requirements = get_requirements(type(self)) + get_requirements(self.get_test_function())
+        if nofixtures.is_marked(self.get_test_function()):
+            return test_requirements
+        return list(set(test_requirements + self._get_fixtures_requirements()))
+
+    def run(self):  # pylint: disable=E0202
+        """
+        .. warning:: Not to be overriden
+        """
+        method = self.get_test_function()
+        with bound_parametrizations_context(self._variation, self._fixture_store, self._fixture_namespace):
+            _call_with_fixtures = functools.partial(self._fixture_store.call_with_fixtures, namespace=self._fixture_namespace)
+            _call_with_fixtures(self.before, trigger_test_start=True)
+            try:
+                with handling_exceptions():
+                    result = _call_with_fixtures(method, trigger_test_start=True)
+                    if isinstance(result, GeneratorType):
+                        raise InvalidTest('{} is a generator. Running generators is not supported'.format(method))
+
+            finally:
+                with handling_exceptions():
+                    _call_with_fixtures(self.after, trigger_test_end=True)
+
+    def before(self):
+        """
+        Gets called before each separate case generated from this test class
+        """
+        pass
+    def after(self):
+        """
+        Gets called after each separate case from this test class executed, assuming :meth:`.before` was successful.
+        """
+        pass
+
+    def _format_kwargs(self, kwargs):
+        return ", ".join("{0}={1!r}".format(x, y) for x, y in iteritems(kwargs))
+
+def abstract_test_class(cls):
+    """
+    Marks a class as **abstract**, thus meaning it is not to be run
+    directly, but rather via a subclass.
+    """
+    assert issubclass(cls, Test), "abstract_test_class only operates on slash.Test subclasses"
+    cls.__slash_abstract__ = True
+    return cls
+
+def is_abstract_base_class(cls):
+    """
+    Checks if a given class is abstract.
+
+    .. seealso:: :func:`abstract_test_class`
+    """
+    return bool(cls.__dict__.get("__slash_abstract__", False))
+
+
+def is_valid_test_name(name):
+    return name.startswith('test_')
diff --git a/slash/core/variation.py b/slash/core/variation.py
new file mode 100755
index 0000000000..53107f5528
--- /dev/null
+++ b/slash/core/variation.py
@@ -0,0 +1,70 @@
+from numbers import Number
+import string
+
+from .._compat import string_types
+
+_PRINTABLE_TYPES = (Number,) + string_types
+_PRINTABLE_CHARS = set(string.ascii_letters) | set(string.digits) | set("-_")
+
+
+class Variation(object):
+
+    """Represents a single variation of parameter points. A variation is merely a mapping of fixture ids to their values.
+    This mostly applies for parametrization fixtures. The other fixtures follow since they are either constant
+    or indirectly depend on parametrization"""
+
+    def __init__(self, store, param_value_indices, param_name_bindings):
+        """
+        :param name_bindings: dictionary mapping parameter name to its id
+        """
+        super(Variation, self).__init__()
+        self._store = store
+        self.param_value_indices = param_value_indices
+        self.id = {}
+        self.values = {}
+        for param_name, param in param_name_bindings.items():
+            value_index = self.id[param_name] = param_value_indices[param.info.id]
+            self.values[param_name] = param.get_value_by_index(value_index)
+        self.safe_repr = self._get_safe_repr()
+
+    def _get_safe_repr(self):
+        returned = {}
+        for name, value in self.values.items():
+            returned[name] = self._format_parameter_value_safe(name, value)
+        return ','.join('{}={}'.format(key, returned[key]) for key in sorted(returned))
+
+    def _format_parameter_value_safe(self, name, value):
+        value = str(value)
+        if self._is_printable(value):
+            return str(value)
+        param_index = self.id[name]
+        return '{}{}'.format(name, param_index)
+
+    def _is_printable(self, value):
+        if not isinstance(value, _PRINTABLE_TYPES):
+            return False
+        return _PRINTABLE_CHARS.issuperset(value)
+
+    def has_value_for_parameter(self, param_id):
+        return param_id in self.param_value_indices
+
+    def get_param_value(self, param):
+        return self._store.get_value(self, param)
+
+    def __eq__(self, other):
+        if isinstance(other, Variation):
+            other = other.param_value_indices
+        if not isinstance(other, dict):
+            return NotImplemented
+        return self.param_value_indices == other
+
+    def __ne__(self, other):
+        return not (self == other)  # pylint: disable=superfluous-parens,unneeded-not
+
+    def __repr__(self):
+        return 'Variation({0})'.format(', '.join('{0}={1}'.format(key, value) for key, value in self.param_value_indices.items()))
+
+    def __nonzero__(self):
+        return bool(self.param_value_indices)
+
+    __bool__ = __nonzero__
diff --git a/slash/core/variation_factory.py b/slash/core/variation_factory.py
new file mode 100755
index 0000000000..c1a447beb5
--- /dev/null
+++ b/slash/core/variation_factory.py
@@ -0,0 +1,115 @@
+import collections
+import itertools
+
+from orderedset import OrderedSet
+
+from .variation import Variation
+from .._compat import OrderedDict, izip, xrange
+from ..exceptions import FixtureException
+from ..utils.python import get_arguments
+from .fixtures.parameters import iter_parametrization_fixtures
+from .fixtures.fixture import Fixture
+from .fixtures.parameters import Parametrization
+from .fixtures.utils import nofixtures
+
+
+class VariationFactory(object):
+
+    """Helper class to produce variations, while properly naming the needed fixtures to help identifying tests
+    """
+
+    def __init__(self, fixture_store):
+        super(VariationFactory, self).__init__()
+        self._store = fixture_store
+        self._autouse_fixtures = list(fixture_store.iter_autouse_fixtures_in_namespace())
+        self._needed_fixtures = list(self._autouse_fixtures)
+
+        self._arg_name_bindings = OrderedDict()
+        self._param_name_bindings = OrderedDict()
+        self._known_value_strings = collections.defaultdict(dict)
+
+    def add_needed_fixture_id(self, fixture_id):
+        self._needed_fixtures.append(self._store.get_fixture_by_id(fixture_id))
+
+    def add_needed_fixtures_from_method(self, method):
+        self._add_needed_fixtures_from_function(method)
+
+    def add_needed_fixtures_from_function(self, func):
+        self._add_needed_fixtures_from_function(func)
+
+    def _add_needed_fixtures_from_function(self, func):
+
+        if isinstance(func, tuple):
+            namespace, func = func
+        else:
+            namespace = None
+
+        if nofixtures.is_marked(func):
+            return
+
+        args = get_arguments(func)
+
+        parametrizations = {}
+        for name, param in iter_parametrization_fixtures(func):
+            # make sure the parametrization is in the store
+            self._store.ensure_known_parametrization(param)
+            parametrizations[name] = param
+
+            self._needed_fixtures.append(param)
+
+        for argument in args:
+            fixture = parametrizations.get(argument.name, None)
+            if fixture is None:
+                try:
+                    fixture = self._store.get_fixture_by_argument(argument)
+                except FixtureException as e:
+                    raise type(e)('Loading {0.__code__.co_filename}:{0.__name__}: {1}'.format(func, e))
+
+
+            self._needed_fixtures.append(fixture)
+
+            arg_name = argument.name
+            if namespace is not None:
+                arg_name = '{0}:{1}'.format(namespace, arg_name)
+
+            self._populate_param_name_bindings(arg_name, fixture)
+            self._arg_name_bindings[arg_name] = fixture
+
+        for fixture in self._autouse_fixtures:
+            self._populate_param_name_bindings(fixture.info.name, fixture, prefix='::')
+
+    def _populate_param_name_bindings(self, arg_name, fixture_or_param, prefix=''):
+        visited = {fixture_or_param.info.id}
+        stack = [(prefix + arg_name, fixture_or_param)]
+        while stack:
+            name, fixture = stack.pop()
+            if isinstance(fixture, Fixture):
+                for sub_name, obj in fixture.keyword_arguments.items():
+                    if obj.info.id in visited:
+                        continue
+                    visited.add(obj.info.id)
+                    stack.append(('{}.{}'.format(name, sub_name), obj))
+            elif isinstance(fixture, Parametrization):
+                self._param_name_bindings[name] = fixture
+            else:
+                raise NotImplementedError() # pragma: no cover
+
+    def iter_variations(self):
+        needed_ids = OrderedSet()
+
+        for fixture in self._needed_fixtures:
+            needed_ids.update(self._store.get_all_needed_fixture_ids(fixture))
+
+        parametrizations = [self._store.get_fixture_by_id(param_id) for param_id in needed_ids]
+        if not needed_ids:
+            yield Variation(self._store, {}, {})
+            return
+        for value_indices in itertools.product(*(xrange(len(p.values)) for p in parametrizations)):
+            yield self._build_variation(parametrizations, value_indices)
+
+    def _build_variation(self, parametrizations, value_indices):
+        value_index_by_id = {}
+        for param, param_index in izip(parametrizations, value_indices):
+            value_index_by_id[param.info.id] = param_index
+
+        return Variation(self._store, value_index_by_id, self._param_name_bindings)
diff --git a/slash/ctx.py b/slash/ctx.py
new file mode 100755
index 0000000000..f531be6a2b
--- /dev/null
+++ b/slash/ctx.py
@@ -0,0 +1,141 @@
+from .reporting.null_reporter import NullReporter
+
+__all__ = ["context", "session", "test", "test_id", "g", "internal_globals"]
+
+
+class GlobalStorage(object):
+    pass
+
+
+class Context(object):
+    session = test = test_id = result = fixture = None
+
+    def __init__(self):
+        super(Context, self).__init__()
+        self.g = GlobalStorage()
+        self.internal_globals = GlobalStorage()
+
+    @property
+    def test_filename(self):
+        return self._get_test_address_field("file_path")
+
+    @property
+    def session_id(self):
+        s = self.session
+        if s is None:
+            return None
+        return s.id
+
+    @property
+    def reporter(self):
+        if self.session is None:
+            return NullReporter()
+        return self.session.reporter
+
+    def _get_test_address_field(self, field_name):
+        current_test = self.test
+        if current_test is None:
+            return None
+        return getattr(current_test.__slash__, field_name)
+
+
+class NullContext(object):
+
+    def __setattr__(self, attr, value):
+        raise AttributeError(
+            "Cannot set attribute {0!r} on null context".format(attr))
+
+    @property
+    def _always_none(self):
+        pass
+
+    session = test = test_id = g = internal_globals = \
+        test_filename = test_classname = test_methodname = result = fixture = _always_none
+
+    reporter = NullReporter()
+
+
+class _ContextStack(object):
+
+    def __init__(self):
+        super(_ContextStack, self).__init__()
+        self._stack = [NullContext()]
+
+    def __getattr__(self, attr):
+        assert self._stack
+        return getattr(self._stack[-1], attr)
+
+    def __dir__(self):
+        assert self._stack
+        return dir(self._stack[-1])
+
+    def __setattr__(self, attr, value):
+        if attr.startswith("_"):
+            return super(_ContextStack, self).__setattr__(attr, value)
+        setattr(self._stack[-1], attr, value)
+
+    def push(self, ctx):
+        self._stack.append(ctx)
+        return ctx
+
+    def pop(self):
+        assert self._stack
+        if len(self._stack) == 1:
+            raise RuntimeError("No more contexts to pop")
+        return self._stack.pop(-1)
+
+context = _ContextStack()
+
+
+class ContextAttributeProxy(object):
+
+    def __init__(self, name):
+        super(ContextAttributeProxy, self).__init__()
+        self._proxy__name = name
+
+    @property
+    def _obj(self):
+        return getattr(context, self._proxy__name)
+
+    def __getattr__(self, attr):
+        return getattr(self._obj, attr)
+
+    def __setattr__(self, attr, value):
+        if attr == "_proxy__name":
+            return super(ContextAttributeProxy, self).__setattr__(attr, value)
+        setattr(self._obj, attr, value)
+
+    def __eq__(self, other):
+        return self._obj == other
+
+    def __ne__(self, other):
+        return self._obj != other
+
+    def __call__(self, *args, **kwargs):
+        return self._obj(*args, **kwargs)  # pylint: disable=not-callable
+
+    def __repr__(self):
+        return repr(self._obj)
+
+    def __dir__(self):
+        return dir(self._obj)
+
+    __members__ = __dir__
+
+    def __str__(self):
+        return str(self._obj)
+
+
+session = ContextAttributeProxy("session")
+test = ContextAttributeProxy("test")
+test_id = ContextAttributeProxy("test_id")
+g = ContextAttributeProxy("g")
+internal_globals = ContextAttributeProxy("internal_globals")
+reporter = ContextAttributeProxy("reporter")
+
+
+def push_context():
+    context.push(Context())
+
+def pop_context():
+    context.pop()
diff --git a/slash/exception_handling.py b/slash/exception_handling.py
new file mode 100755
index 0000000000..2f372a852f
--- /dev/null
+++ b/slash/exception_handling.py
@@ -0,0 +1,255 @@
+from contextlib import contextmanager
+from .utils.debug import debug_if_needed
+from .utils.exception_mark import mark_exception, get_exception_mark
+from .utils.traceback_proxy import create_traceback_proxy
+from . import hooks as trigger_hook
+from . import exceptions
+from ._compat import PY2, PYPY
+from .ctx import context as slash_context
+from .conf import config
+
+import functools
+import threading
+import logbook
+try:
+    import raven  # pylint: disable=F0401
+except ImportError:
+    raven = None
+import sys
+
+_logger = logbook.Logger(__name__)
+NO_EXC_INFO = (None, None, None)
+
+
+def update_current_result(exc_info):  # pylint: disable=unused-argument
+    if slash_context.session is None:
+        return
+    if slash_context.test is not None:
+        current_result = slash_context.session.results.get_result(slash_context.test)
+    else:
+        current_result = slash_context.session.results.global_result
+
+    current_result.add_exception(exc_info)
+
+
+def trigger_hooks_before_debugger(_):
+    trigger_hook.exception_caught_before_debugger()  # pylint: disable=no-member
+
+
+def trigger_hooks_after_debugger(_):
+    trigger_hook.exception_caught_after_debugger()  # pylint: disable=no-member
+
+
+_EXCEPTION_HANDLERS = [
+    update_current_result,
+    trigger_hooks_before_debugger,
+    debug_if_needed,
+    trigger_hooks_after_debugger,
+]
+
+
+class _IgnoredState(threading.local):
+    ignored_exception_types = ()
+
+_ignored_state = _IgnoredState()
+
+
+class thread_ignore_exception_context(object):
+
+    def __init__(self, exc_type):
+        super(thread_ignore_exception_context, self).__init__()
+        self._exc_type = exc_type
+        self._prev = None
+
+    def __enter__(self):
+        self._prev = _ignored_state.ignored_exception_types
+        _ignored_state.ignored_exception_types = list(_ignored_state.ignored_exception_types) + [self._exc_type]
+
+    def __exit__(self, *_):
+        _ignored_state.ignored_exception_types = self._prev
+        self._prev = None
+
+
+def handling_exceptions(fake_traceback=True, **kwargs):
+    """Context manager handling exceptions that are raised within it
+
+    :param passthrough_types: a tuple specifying exception types to avoid handling, raising them immediately onward
+    :param swallow: causes this context to swallow exceptions
+    :param swallow_types: causes the context to swallow exceptions of, or derived from, the specified types
+    :param context: An optional string describing the operation being wrapped. This will be emitted to the logs to simplify readability
+
+    .. note:: certain exceptions are never swallowed - most notably KeyboardInterrupt, SystemExit, and SkipTest
+    """
+
+    if not PYPY and fake_traceback:
+        # Only in CPython we're able to fake the original, full traceback
+        try:
+            fake_tbs = create_traceback_proxy(frame_correction=2)
+        except (KeyError, IndexError):
+            _logger.warn("Could not extract full traceback for exceptions handling")
+            fake_tbs = tuple()
+    else:
+        fake_tbs = tuple()
+    swallow = kwargs.pop("swallow", False)
+    swallow_types = kwargs.pop('swallow_types', ())
+    if swallow:
+        swallow_types = swallow_types + (Exception, )
+    assert isinstance(swallow_types, (list, tuple)), 'swallow_types must be either a list or a tuple'
+    passthrough_types = kwargs.pop('passthrough_types', ()) + tuple(_ignored_state.ignored_exception_types)
+    return _HandlingException(fake_tbs, swallow_types, passthrough_types, kwargs)
+
+
+class _HandledException(object):
+    exception = None
+
+class _HandlingException(object):
+
+    def __init__(self, fake_tbs, swallow_types, passthrough_types, handling_kwargs):
+        self._fake_traceback = fake_tbs
+        self._kwargs = handling_kwargs
+        self._passthrough_types = passthrough_types
+        self._swallow_types = swallow_types
+        self._handled = _HandledException()
+
+    def __enter__(self):
+        return self._handled
+
+    def __exit__(self, *exc_info):
+        if not exc_info or exc_info == NO_EXC_INFO:
+            return
+        exc_value = exc_info[1]
+
+        if isinstance(exc_value, self._passthrough_types):
+            return None
+
+        if self._fake_traceback:
+            (first_tb, last_tb) = self._fake_traceback
+            (second_tb, _) = create_traceback_proxy(exc_info[2])
+            last_tb.tb_next = second_tb
+            exc_info = (exc_info[0], exc_info[1], first_tb._tb) # pylint: disable=protected-access
+        handle_exception(exc_info, **self._kwargs)
+        self._handled.exception = exc_info[1]
+        skip_types = () if slash_context.session is None else slash_context.session.get_skip_exception_types()
+        if isinstance(exc_value, skip_types) or isinstance(exc_value, exceptions.INTERRUPTION_EXCEPTIONS):
+            return None
+        if self._swallow_types and isinstance(exc_value, self._swallow_types):
+            if PY2:
+                sys.exc_clear()  # pylint: disable=no-member
+            _logger.trace('Swallowing {!r}', exc_value)
+            return True
+        return None
+
+
+def handle_exception(exc_info, context=None):
+    """
+    Call any handlers or debugging code before propagating an exception onwards.
+
+    This makes sure that the exception can be handled as close as possible to its originating point.
+
+    It also adds the exception to its correct place in the current result, be it a failure, an error or a skip
+
+    """
+    already_handled = is_exception_handled(exc_info[1])
+    msg = "Handling exception"
+    if context is not None:
+        msg += " (Context: {0})"
+    if already_handled:
+        msg += " (already handled)"
+    _logger.debug(msg, context, exc_info=exc_info if not already_handled else None)
+
+    if not already_handled:
+        mark_exception_handled(exc_info[1])
+        for handler in _EXCEPTION_HANDLERS:
+            handler(exc_info)
+
+
+def mark_exception_handled(e):
+    mark_exception(e, "handled", True)
+
+
+def is_exception_handled(e):
+    """
+    Checks if the exception ``e`` already passed through the exception handling logic
+    """
+    return bool(get_exception_mark(e, "handled", False))
+
+
+@contextmanager
+def get_exception_swallowing_context(report_to_sentry=True):
+    """
+    Returns a context under which all exceptions are swallowed (ignored)
+    """
+    try:
+        yield
+    except:
+        if not get_exception_mark(sys.exc_info()[1], "swallow", True):
+            raise
+        if report_to_sentry:
+            capture_sentry_exception()
+        _logger.debug("Ignoring exception", exc_info=sys.exc_info())
+
+
+def noswallow(exception):
+    """
+    Marks an exception to prevent swallowing by :func:`slash.exception_handling.get_exception_swallowing_context`,
+    and returns it
+    """
+    mark_exception(exception, "swallow", False)
+    return exception
+
+
+def mark_exception_fatal(exception):
+    """
+    Causes this exception to halt the execution of the entire run.
+
+    This is useful when detecting errors that need careful examination, thus preventing further tests from
+    altering the test subject's state
+    """
+    mark_exception(exception, "fatal", True)
+    return exception
+
+
+def is_exception_fatal(exception):
+    return bool(get_exception_mark(exception, "fatal", False))
+
+
+def inhibit_unhandled_exception_traceback(exception):
+    """
+    Causes this exception to inhibit console tracback
+    """
+    mark_exception(exception, "inhibit_console_tb", True)
+    return exception
+
+
+def should_inhibit_unhandled_exception_traceback(exception):
+    return bool(get_exception_mark(exception, "inhibit_console_tb", False))
+
+
+def disable_exception_swallowing(func_or_exception):
+    """
+    Marks an exception to prevent swallowing. Can also be used as a decorator around a function to mark all escaped
+    exceptions
+    """
+    if isinstance(func_or_exception, BaseException):
+        return noswallow(func_or_exception)
+
+    @functools.wraps(func_or_exception)
+    def func(*args, **kwargs):
+        try:
+            return func_or_exception(*args, **kwargs)
+        except BaseException as e:
+            disable_exception_swallowing(e)
+            raise
+    return func
+
+
+def capture_sentry_exception():
+    client = get_sentry_client()
+    if client is not None:
+        client.captureException()
+
+
+def get_sentry_client():
+    if raven is not None and config.root.sentry.dsn:
+        return raven.Client(config.root.sentry.dsn)
+    return None
diff --git a/slash/exceptions.py b/slash/exceptions.py
new file mode 100755
index 0000000000..d81af95d66
--- /dev/null
+++ b/slash/exceptions.py
@@ -0,0 +1,111 @@
+
+class SlashException(Exception):
+
+    @classmethod
+    def throw(cls, *args, **kwargs):
+        raise cls(*args, **kwargs)
+
+
+class TerminatedException(BaseException):
+    pass
+
+INTERRUPTION_EXCEPTIONS = (KeyboardInterrupt, TerminatedException)
+
+
+class NoActiveSession(SlashException):
+    pass
+
+
+class ParallelServerIsDown(SlashException):
+    pass
+
+
+class ParallelTimeout(SlashException):
+    pass
+
+
+class InteractiveParallelNotAllowed(SlashException):
+    pass
+
+
+class CannotLoadTests(SlashException):
+    pass
+
+CLI_ABORT_EXCEPTIONS = (CannotLoadTests, )
+
+
+class FixtureException(CannotLoadTests):
+    pass
+
+
+class CyclicFixtureDependency(FixtureException):
+    pass
+
+
+class UnresolvedFixtureStore(FixtureException):
+    pass
+
+
+class UnknownFixtures(FixtureException):
+    pass
+
+
+class InvalidFixtureScope(FixtureException):
+    pass
+
+
+class InvalidFixtureName(FixtureException):
+    pass
+
+
+class IncorrectScope(SlashException):
+    pass
+
+
+class InvalidTest(SlashException):
+    pass
+
+
+class CannotAddCleanup(SlashException):
+    pass
+
+
+class TmuxSessionNotExist(SlashException):
+    pass
+
+
+class TmuxExecutableNotFound(SlashException):
+    pass
+
+
+class TestFailed(AssertionError):
+
+    """
+    This exception class distinguishes actual test failures (mostly assertion errors,
+    but possibly other conditions as well) from regular asserts.
+
+    This is important, since regular code that is tested can use asserts, and that
+    should not be considered a test failure (but rather a code failure)
+    """
+    pass
+
+
+class ExpectedExceptionNotCaught(TestFailed):
+    def __init__(self, msg, expected_types):
+        self.expected_types = expected_types
+        super(ExpectedExceptionNotCaught, self).__init__(msg)
+
+
+FAILURE_EXCEPTION_TYPES = (TestFailed, AssertionError, ExpectedExceptionNotCaught)
+
+
+class SkipTest(SlashException):
+
+    """
+    This exception should be raised in order to interrupt the execution of the currently running test, marking
+    it as skipped
+    """
+
+    def __init__(self, reason="Test skipped"):
+        super(SkipTest, self).__init__(reason)
+        self.reason = reason
diff --git a/slash/ext/__init__.py b/slash/ext/__init__.py
new file mode 100755
index 0000000000..e43ae0ba58
--- /dev/null
+++ b/slash/ext/__init__.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+"""
+slash.ext
+~~~~~~~~~
+
+Redirect imports from slash.ext.X to slash_X.
+
+This code is an adaptation of flask.ext, copyright 2011 Armin Ronacher, licensed under BSD
+"""
+
+
+def setup():
+    from ..exthook import ExtensionImporter
+    importer = ExtensionImporter(['slash_%s'], __name__)
+    importer.install()
+
+setup()
+del setup
diff --git a/slash/exthook.py b/slash/exthook.py
new file mode 100755
index 0000000000..6a69d94d95
--- /dev/null
+++ b/slash/exthook.py
@@ -0,0 +1,105 @@
+# -*- coding: utf-8 -*-
+"""
+slash.exthook
+~~~~~~~~~~~~~
+
+Mechanism behind slash.ext imports. Adopted from flask.ext, copyright 2011 by Armin Ronacher, Licensed under BSD.
+"""
+import sys
+import os
+from ._compat import reraise
+
+
+class ExtensionImporter(object):
+    """This importer redirects imports from this submodule to other locations.
+    """
+
+    def __init__(self, module_choices, wrapper_module):
+        super(ExtensionImporter, self).__init__()
+        self.module_choices = module_choices
+        self.wrapper_module = wrapper_module
+        self.prefix = wrapper_module + '.'
+        self.prefix_cutoff = wrapper_module.count('.') + 1
+
+    def __eq__(self, other):
+        return self.__class__.__module__ == other.__class__.__module__ and \
+               self.__class__.__name__ == other.__class__.__name__ and \
+               self.wrapper_module == other.wrapper_module and \
+               self.module_choices == other.module_choices
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def install(self):
+        sys.meta_path[:] = [x for x in sys.meta_path if self != x] + [self]
+
+    def find_module(self, fullname, path=None): # pylint: disable=W0613
+        if fullname.startswith(self.prefix):
+            return self
+
+    def load_module(self, fullname):
+        if fullname in sys.modules:
+            return sys.modules[fullname]
+        modname = fullname.split('.', self.prefix_cutoff)[self.prefix_cutoff]
+        for path in self.module_choices:
+            realname = path % modname
+            try:
+                __import__(realname)
+            except ImportError:
+                exc_type, exc_value, tb = sys.exc_info()
+                # since we only establish the entry in sys.modules at the
+                # very this seems to be redundant, but if recursive imports
+                # happen we will call into the move import a second time.
+                # On the second invocation we still don't have an entry for
+                # fullname in sys.modules, but we will end up with the same
+                # fake module name and that import will succeed since this
+                # one already has a temporary entry in the modules dict.
+                # Since this one "succeeded" temporarily that second
+                # invocation now will have created a fullname entry in
+                # sys.modules which we have to kill.
+                sys.modules.pop(fullname, None)
+
+                # If it's an important traceback we reraise it, otherwise
+                # we swallow it and try the next choice.  The skipped frame
+                # is the one from __import__ above which we don't care about
+                if self.is_important_traceback(realname, tb):
+                    reraise(exc_type, exc_value, tb.tb_next)
+                continue
+            module = sys.modules[fullname] = sys.modules[realname]
+            if '.' not in modname:
+                setattr(sys.modules[self.wrapper_module], modname, module)
+            return module
+        raise ImportError('No module named %s' % fullname)
+
+    def is_important_traceback(self, important_module, tb):
+        """Walks a traceback's frames and checks if any of the frames
+        originated in the given important module.  If that is the case then we
+        were able to import the module itself but apparently something went
+        wrong when the module was imported.  (Eg: import of an import failed).
+        """
+        while tb is not None:
+            if self.is_important_frame(important_module, tb):
+                return True
+            tb = tb.tb_next
+        return False
+
+    def is_important_frame(self, important_module, tb):
+        """Checks a single frame if it's important."""
+        g = tb.tb_frame.f_globals
+        if '__name__' not in g:
+            return False
+
+        module_name = g['__name__']
+
+        # Python 2.7 Behavior.  Modules are cleaned up late so the
+        # name shows up properly here.  Success!
+        if module_name == important_module:
+            return True
+
+        # Some python versions will will clean up modules so early that the
+        # module name at that point is no longer set.  Try guessing from
+        # the filename then.
+        filename = os.path.abspath(tb.tb_frame.f_code.co_filename)
+        test_string = os.path.sep + important_module.replace('.', os.path.sep)
+        return test_string + '.py' in filename or \
+               test_string + os.path.sep + '__init__.py' in filename
diff --git a/slash/frontend/__init__.py b/slash/frontend/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/slash/frontend/list_config.py b/slash/frontend/list_config.py
new file mode 100755
index 0000000000..6411f44386
--- /dev/null
+++ b/slash/frontend/list_config.py
@@ -0,0 +1,59 @@
+import argparse
+import sys
+
+import colorama
+import slash
+import slash.site
+from slash.utils.cli_utils import make_styler, Printer
+
+_config_name_style = make_styler(colorama.Fore.WHITE + colorama.Style.BRIGHT) # pylint: disable=no-member
+_default_style = make_styler(colorama.Fore.GREEN + colorama.Style.BRIGHT) # pylint: disable=no-member
+_INDENT = ' ' * 4
+
+def _parse_args(args):
+    parser = argparse.ArgumentParser(prog='slash list-config')
+    parser.add_argument('paths', nargs='*', default=[])
+    parser.add_argument('--force-color', dest='force_color', action='store_true', default=False)
+    parser.add_argument('--no-color', dest='enable_color', action='store_false', default=True)
+    return parser.parse_args(args)
+
+
+def list_config(args, report_stream=sys.stdout):
+
+    args = _parse_args(args)
+    _print = Printer(report_stream, force_color=args.force_color, enable_color=args.enable_color)
+
+    filters = _parse_filters(args.paths)
+
+    with slash.Session():
+        slash.site.load()
+
+        for name, value in sorted(slash.config.traverse_leaves()):
+            if not _is_included(name, filters):
+                continue
+            _print(_config_name_style(name), '--')
+            _print(_INDENT, 'default:', _default_style(value.get_value()))
+            if value.metadata and 'doc' in value.metadata:
+                _print(_INDENT, value.metadata['doc'])
+    return 0
+
+
+def _parse_filters(paths):
+    returned = set()
+    for p in paths:
+        returned.update(_iter_subpaths(p))
+    return returned
+
+def _iter_subpaths(p):
+    p = p.split('.')
+    for i in range(len(p)):
+        yield '.'.join(p[:i+1])
+
+
+def _is_included(name, filters):
+    if not filters:
+        return True
+    for subpath in _iter_subpaths(name):
+        if subpath in filters:
+            return True
+    return False
diff --git a/slash/frontend/main.py b/slash/frontend/main.py
new file mode 100755
index 0000000000..87bcc75cbb
--- /dev/null
+++ b/slash/frontend/main.py
@@ -0,0 +1,76 @@
+#!/usr/bin/env python
+from __future__ import print_function
+import argparse
+import contextlib
+
+import colorama
+import logbook # pylint: disable=F0401
+import sys
+import os
+
+from ..__version__ import __version__
+
+_COMMANDS = {
+    "run": "slash.frontend.slash_run:slash_run",
+    "resume": "slash.frontend.slash_run:slash_resume",
+    "version": "slash.frontend.main:slash_version",
+    "list": "slash.frontend.slash_list:slash_list",
+    "list-config": "slash.frontend.list_config:list_config",
+    "list-plugins": "slash.frontend.slash_list_plugins:slash_list_plugins",
+}
+
+
+def _get_parser():
+    parser = argparse.ArgumentParser(
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+        epilog="Available commands:\n\t{0}".format("\n\t".join(sorted(_COMMANDS))),
+        usage="%(prog)s command...",
+    )
+
+    parser.add_argument("-v", action="append_const", const=1, dest="verbosity", default=[],
+                        help="Be more verbose. Can be specified multiple times to increase verbosity further")
+    parser.add_argument("cmd")
+    parser.add_argument("argv", nargs=argparse.REMAINDER)
+    return parser
+
+def main():
+    parser = _get_parser()
+    args = parser.parse_args()
+    with _setup_logging_context(args):
+        module_name = _COMMANDS.get(args.cmd)
+        if not module_name:
+            parser.error("No such command: {0}".format(args.cmd))
+        module_name, func_name = module_name.split(":")
+        module = __import__(module_name, fromlist=[""])
+        func = getattr(module, func_name)
+        returned = func(args.argv)
+        if not isinstance(returned, int):
+            returned = returned.exit_code
+    return returned
+
+def slash_version(_):
+    print('Slash v{0}'.format(__version__))
+    return 0
+
+################################## Boilerplate ################################
+_DEFAULT_LOG_LEVEL = logbook.WARNING
+@contextlib.contextmanager
+def _setup_logging_context(args):
+    log_level = max(logbook.DEBUG, _DEFAULT_LOG_LEVEL - len(args.verbosity))
+    with logbook.NullHandler().applicationbound():
+        with logbook.StderrHandler(level=log_level, bubble=False).applicationbound():
+            yield
+
+#### For use with entry_points/console_scripts
+def main_entry_point():
+    is_windows = os.name == 'nt'
+    if is_windows:
+        colorama.init()
+    try:
+        sys.exit(main())
+    finally:
+        if is_windows:
+            colorama.deinit()
+
+if __name__ == "__main__":
+    main_entry_point()
diff --git a/slash/frontend/slash_list.py b/slash/frontend/slash_list.py
new file mode 100755
index 0000000000..9277031746
--- /dev/null
+++ b/slash/frontend/slash_list.py
@@ -0,0 +1,137 @@
+from __future__ import print_function
+
+import argparse
+import inspect
+import itertools
+import os
+import sys
+from functools import partial
+
+import colorama
+import slash
+import slash.site
+import slash.loader
+from slash import config
+from slash.exceptions import CannotLoadTests
+from slash.utils.cli_utils import UNDERLINED, make_styler, Printer
+from slash.utils.python import get_underlying_func
+from slash.utils.suite_files import iter_suite_file_paths
+
+_heading_style = make_styler(colorama.Fore.MAGENTA + colorama.Style.BRIGHT + UNDERLINED)  # pylint: disable=no-member
+_title_style = make_styler(colorama.Fore.WHITE + colorama.Style.BRIGHT)  # pylint: disable=no-member
+_unused_style = make_styler(colorama.Fore.YELLOW)  # pylint: disable=no-member
+_doc_style = make_styler(colorama.Fore.GREEN + colorama.Style.BRIGHT)  # pylint: disable=no-member
+_override_style = make_styler(colorama.Fore.YELLOW + colorama.Style.BRIGHT)  # pylint: disable=no-member
+
+
+def _get_parser():
+    parser = argparse.ArgumentParser('slash list [options] PATH...')
+    parser.add_argument('-f', '--suite-file', dest='suite_files', action='append', default=[])
+    parser.add_argument('--only-fixtures', dest='only', action='store_const', const='fixtures', default=None)
+    parser.add_argument('--only-tests', dest='only', action='store_const', const='tests', default=None)
+    parser.add_argument('--show-tags', dest='show_tags', action='store_true', default=False)
+    parser.add_argument('--no-params', dest='show_params', action='store_false', default=True)
+    parser.add_argument('--allow-empty', dest='allow_empty', action='store_true', default=False)
+    parser.add_argument('-r', '--relative-paths', action='store_true', default=False)
+    parser.add_argument('--no-output', dest='show_output', action='store_false', default=True)
+    parser.add_argument('--force-color', dest='force_color', action='store_true', default=False)
+    parser.add_argument('--no-color', dest='enable_color', action='store_false', default=True)
+
+    parser.add_argument('paths', nargs='*', default=[], metavar='PATH')
+    return parser
+
+
+def slash_list(args, report_stream=sys.stdout, error_stream=sys.stderr):
+    _print = partial(print, file=report_stream)
+
+    parser = _get_parser()
+    parsed_args = parser.parse_args(args)
+
+    _print = Printer(report_stream, enable_output=parsed_args.show_output, force_color=parsed_args.force_color,
+                     enable_color=parsed_args.enable_color)
+    try:
+        with slash.Session() as session:
+            slash.site.load()
+
+            if not parsed_args.paths and not parsed_args.suite_files:
+                parsed_args.paths = config.root.run.default_sources
+
+            if not parsed_args.paths and not parsed_args.suite_files:
+                parser.error('Neither test paths nor suite files were specified')
+
+            loader = slash.loader.Loader()
+            runnables = loader.get_runnables(itertools.chain(parsed_args.paths, iter_suite_file_paths(parsed_args.suite_files)))
+            used_fixtures = set()
+            for test in runnables:
+                used_fixtures.update(test.get_required_fixture_objects())
+
+            if parsed_args.only in (None, 'fixtures'):
+                _report_fixtures(parsed_args, session, _print, used_fixtures)
+
+            if parsed_args.only in (None, 'tests'):
+                _report_tests(parsed_args, runnables, _print)
+
+        if len(runnables):  # pylint: disable=len-as-condition
+            return 0
+    except CannotLoadTests as e:
+        print('Could not load tests ({})'.format(e), file=error_stream)
+        return -1
+    print('No tests were found!', file=sys.stderr)
+    return not int(parsed_args.allow_empty)
+
+
+def _report_tests(args, runnables, printer):
+    if not args.only:
+        printer(_heading_style('Tests'))
+
+    visited = set()
+
+    for runnable in runnables:
+        extra = "" if not args.show_tags else "  Tags: {0}".format(list(runnable.get_tags()))
+        address = runnable.__slash__.address
+        if not args.show_params:
+            address = address.split('(')[0]
+        if args.relative_paths:
+            address = _convert_address_to_relpath(address)
+        if address in visited:
+            continue
+        visited.add(address)
+        printer("{0}{1}".format(_title_style(address), extra))
+
+
+def _convert_address_to_relpath(address):
+    filename, remainder = address.split(':', 1)
+    if os.path.isabs(filename):
+        filename = os.path.relpath(filename)
+    return '{}:{}'.format(filename, remainder)
+
+
+def _report_fixtures(args, session, printer, used_fixtures):
+    if not args.only:
+        printer(_heading_style('Fixtures'))
+    for fixture in session.fixture_store:
+        if not hasattr(fixture, 'fixture_func'):
+            continue
+
+        fixture_func = get_underlying_func(fixture.fixture_func)
+        doc = inspect.cleandoc(fixture_func.__doc__) if fixture_func.__doc__ else ''
+
+        if fixture.info.autouse:
+            additional_info = ' (Autouse)'
+        elif fixture not in used_fixtures:
+            additional_info = ' (Unused)'
+        else:
+            additional_info = ''
+
+        if fixture.is_override():
+            additional_info += ' -- ' + _override_style('Override')
+
+        printer(_title_style('{0}{1}'.format(fixture.info.name, additional_info)))
+        if doc:
+            for line in (_doc_style(doc)).split('\n'):
+                printer('    {0}'.format(line))
+
+        printer('    Source: {0}:{1}'.format(
+            os.path.relpath(inspect.getsourcefile(fixture_func), args.paths[0] if args.paths else '.'),
+            inspect.getsourcelines(fixture_func)[1]))
+        printer('\n')
diff --git a/slash/frontend/slash_list_plugins.py b/slash/frontend/slash_list_plugins.py
new file mode 100755
index 0000000000..ad32353316
--- /dev/null
+++ b/slash/frontend/slash_list_plugins.py
@@ -0,0 +1,46 @@
+import argparse
+import sys
+
+import colorama
+from slash.utils.cli_utils import make_styler, Printer
+
+from slash import site
+from slash.plugins import manager
+
+_title_style = make_styler(colorama.Fore.WHITE + colorama.Style.BRIGHT)  # pylint: disable=no-member
+_disabled_style = make_styler(colorama.Fore.BLACK + colorama.Style.BRIGHT)  # pylint: disable=no-member
+_enabled_style = make_styler(colorama.Fore.GREEN)  # pylint: disable=no-member
+
+_link_style = make_styler(colorama.Fore.CYAN)  # pylint: disable=no-member
+
+
+def _get_parser():
+    parser = argparse.ArgumentParser('slash list-plugins [options]')
+    parser.add_argument('--force-color', dest='force_color', action='store_true', default=False)
+    parser.add_argument('--no-color', dest='enable_color', action='store_false', default=True)
+    return parser
+
+
+def slash_list_plugins(args, report_stream=sys.stdout):
+    parser = _get_parser()
+    parsed_args = parser.parse_args(args)
+
+    _print = Printer(report_stream, force_color=parsed_args.force_color, enable_color=parsed_args.enable_color)
+
+    site.load()
+
+    active = manager.get_future_active_plugins()
+
+    for plugin in sorted(manager.get_installed_plugins(include_internals=False).values(), key=lambda p: p.get_name()):
+        name = plugin.get_name()
+        _print(_title_style(name), end=' ')
+        if name in active:
+            _print(_enabled_style('active (use --without-{} to deactivate'.format(name)))
+        else:
+            _print(_disabled_style('inactive (use --with-{} to activate)'.format(name)))
+        if plugin.__doc__:
+            for line in plugin.__doc__.splitlines():
+                if line.strip():
+                    _print('\t', line.strip())
+
+    return 0
diff --git a/slash/frontend/slash_run.py b/slash/frontend/slash_run.py
new file mode 100755
index 0000000000..116517ed7e
--- /dev/null
+++ b/slash/frontend/slash_run.py
@@ -0,0 +1,121 @@
+import functools
+import sys
+import logbook
+from ..app import Application
+from ..conf import config
+from ..exception_handling import handling_exceptions
+from ..exceptions import CannotLoadTests, InteractiveParallelNotAllowed
+from ..resuming import (get_last_resumeable_session_id, get_tests_to_resume, save_resume_state, clean_old_entries)
+from ..runner import run_tests
+from ..utils.suite_files import iter_suite_file_paths
+from ..utils.tmux_utils import run_slash_in_tmux
+from ..plugins import manager
+from ..parallel.parallel_manager import ParallelManager
+from ..parallel.worker import Worker
+
+_logger = logbook.Logger(__name__)
+
+def slash_run(args, report_stream=None, resume=False, app_callback=None, working_directory=None):
+
+    if report_stream is None:
+        report_stream = sys.stderr
+    app = Application()
+    if resume:
+        app.arg_parser.set_positional_metavar('SESSION-ID', plural=False)
+        app.arg_parser.set_description('Resumes a previously run session by running only unsuccessful on unfinished tests')
+    else:
+        app.arg_parser.set_positional_metavar('TEST')
+    if working_directory is not None:
+        app.set_working_directory(working_directory)
+    app.set_argv(args)
+    app.set_report_stream(report_stream)
+    app.enable_interactive()
+    collected = []
+    try:
+        with app:
+            if app_callback is not None:
+                app_callback(app)
+            try:
+                with handling_exceptions():
+                    if is_parallel() and app.parsed_args.interactive:
+                        raise InteractiveParallelNotAllowed("Cannot run interactive mode in parallel")
+                    if config.root.tmux.enabled and not is_child():
+                        _logger.notice("About to start slash in new tmux session...")
+                        run_slash_in_tmux(args)
+                    if is_child():
+                        worker = Worker(config.root.parallel.worker_id, app.session.id)
+                        worker.connect_to_server()
+                    if resume:
+                        session_ids = app.positional_args
+                        if not session_ids:
+                            session_ids = [get_last_resumeable_session_id()]
+                        to_resume = [x for session_id in session_ids for x in get_tests_to_resume(session_id)]
+                        collected = app.test_loader.get_runnables(to_resume, prepend_interactive=app.parsed_args.interactive)
+                    else:
+                        collected = _collect_tests(app, args)
+
+                collected = list(collected)
+                if is_child():
+                    worker.start_execution(app, collected)
+                else:
+                    with app.session.get_started_context():
+                        report_tests_to_backslash(collected)
+                        if is_parent():
+                            app.session.parallel_manager = ParallelManager(args)
+                            app.session.parallel_manager.start_server_in_thread(collected)
+                            app.session.parallel_manager.start()
+                        else:
+                            run_tests(collected)
+
+            finally:
+                save_resume_state(app.session.results, collected)
+                clean_old_entries()
+            if app.exit_code == 0 and not app.session.results.is_success(allow_skips=True):
+                app.set_exit_code(-1)
+    except Exception:         # pylint: disable=broad-except
+        # Error reporting happens in app context
+        assert app.exit_code != 0
+
+    return app
+
+slash_resume = functools.partial(slash_run, resume=True)
+
+def is_parallel():
+    return config.root.parallel.num_workers
+
+def is_child():
+    return config.root.parallel.worker_id is not None
+
+def is_parent():
+    return is_parallel() and not is_child()
+
+def report_tests_to_backslash(tests):
+    active_plugins = manager.get_active_plugins()
+    backslash_plugin = active_plugins.get('backslash', None)
+    if backslash_plugin and hasattr(backslash_plugin, 'report_planned_tests'):
+        backslash_plugin.report_planned_tests(tests)
+
+def _collect_tests(app, args):  # pylint: disable=unused-argument
+    paths = app.positional_args
+
+    paths = _extend_paths_from_suite_files(paths)
+
+    if not paths and not app.parsed_args.interactive:
+        paths = config.root.run.default_sources
+
+    if not paths and not app.parsed_args.interactive:
+        raise CannotLoadTests("No tests specified")
+
+    collected = app.test_loader.get_runnables(paths, prepend_interactive=app.parsed_args.interactive)
+    if not collected:
+        raise CannotLoadTests("No tests could be collected")
+
+    return collected
+
+def _extend_paths_from_suite_files(paths):
+    suite_files = config.root.run.suite_files
+    if not suite_files:
+        return paths
+    paths = list(paths)
+    paths.extend(iter_suite_file_paths(suite_files))
+    return paths
diff --git a/slash/hooks.py b/slash/hooks.py
new file mode 100755
index 0000000000..0535565eee
--- /dev/null
+++ b/slash/hooks.py
@@ -0,0 +1,118 @@
+import gossip
+from vintage import deprecated
+
+from .conf import config
+
+
+def register(func):
+    """A shortcut for registering hook functions by their names
+    """
+    return gossip.register('slash.{0}'.format(func.__name__))(func)
+
+
+def _deprecated_to_gossip(func):
+    return deprecated(since="0.6.0", message="Use gossip instead")(func)
+
+def _define(hook_name, **kwargs):
+    hook = gossip.define("slash.{0}".format(hook_name), **kwargs)
+    globals()[hook_name] = hook
+    return hook
+
+_define('session_start', doc="Called right after session starts")
+_define('session_end', doc="Called right before the session ends, regardless of the reason for termination")
+_define('session_interrupt', doc='Called when the session is interrupted unexpectedly')
+
+_define('tests_loaded', doc='Called when Slash finishes loading a batch of tests for execution (not necessarily al tests)', arg_names=('tests',))
+
+_define('before_session_start', doc="Entry point which is called before session_start, useful for configuring plugins and other global resources")
+_define('after_session_start', doc="Second entry point for session start, useful for plugins relying on other plugins' session_start routine")
+
+_define('configure', doc='Configuration hook that happens during commandline parsing, and before plugins are activated. It is a convenient point to override plugin activation settings')  # pylint: disable=line-too-long
+
+_define('test_interrupt', doc="Called when a test is interrupted by a KeyboardInterrupt or other similar means")
+_define('test_avoided', doc="Called when a test is skipped completely (not even started)", arg_names=('reason',))
+_define('test_start', doc="Called right after a test starts")
+_define('test_distributed', doc="Called in parallel mode, after the parent sent a test to child)", arg_names=('test_logical_id', 'worker_session_id',)) # pylint: disable=line-too-long
+_define('test_end', doc="Called right before a test ends, regardless of the reason for termination")
+_define('before_test_cleanups', doc="Called right before a test cleanups are executed")
+_define('test_success', doc="Called on test success")
+_define('test_error', doc="Called on test error")
+_define('test_failure', doc="Called on test failure")
+_define('test_skip', doc="Called on test skip", arg_names=("reason",))
+_define('worker_connected', doc="Called on new worker startup", arg_names=("session_id",))
+
+_define('error_added', doc='Called when an error is added to a result (either test result or global)', arg_names=('error', 'result'))
+_define('interruption_added', doc='Called when an exception is encountered that triggers test or session interruption',
+        arg_names=('result', 'exception'))
+_define('fact_set', doc='Called when a fact is set for a test', arg_names=['name', 'value'])
+_define('warning_added', doc='Called when a warning is captured by Slash', arg_names=('warning',))
+
+_define('result_summary', doc="Called at the end of the execution, when printing results")
+
+_define('exception_caught_before_debugger',
+        doc="Called whenever an exception is caught, but a debugger hasn't been entered yet")
+_define('entering_debugger', doc='Called right before entering debugger', arg_names=('exc_info',))
+
+_define('exception_caught_after_debugger',
+        doc="Called whenever an exception is caught, and a debugger has already been run")
+_define('before_worker_start', doc="Called in parallel execution mode, before the parent starts the child worker",
+        arg_names=("worker_config",))
+
+_define('prepare_notification', doc='Called with a message object prior to it being sent via the notifications plugin (if enabled)',
+        arg_names=("message",))
+
+_slash_group = gossip.get_group('slash')
+_slash_group.set_strict()
+_slash_group.set_exception_policy(gossip.RaiseDefer())
+
+@gossip.register('gossip.on_handler_exception') # pylint: disable=unused-argument
+def debugger(handler, exception, hook): # pylint: disable=unused-argument
+    from .exception_handling import handle_exception
+
+    if hook.group is _slash_group and config.root.debug.debug_hook_handlers:
+        handle_exception(exception)
+
+@_deprecated_to_gossip
+def add_custom_hook(hook_name):
+    """
+    Adds an additional hook to the set of available hooks
+    """
+    return _define(hook_name)
+
+@_deprecated_to_gossip
+def ensure_custom_hook(hook_name):
+    """
+    Like :func:`.add_custom_hook`, only forgives if the hook already exists
+    """
+    try:
+        return gossip.get_hook("slash.{0}".format(hook_name))
+    except LookupError:
+        return _define(hook_name)
+
+@_deprecated_to_gossip
+def remove_custom_hook(hook_name):
+    """
+    Removes a hook from the set of available hooks
+    """
+    gossip.get_hook("slash.{0}".format(hook_name)).undefine()
+    globals().pop(hook_name)
+
+@_deprecated_to_gossip
+def get_custom_hook_names():
+    """
+    Retrieves the names of all custom hooks currently installed
+    """
+    raise NotImplementedError()  # pragma: no cover
+
+@_deprecated_to_gossip
+def get_all_hooks():
+    return [
+        (hook.name, hook)
+        for hook in gossip.get_group('slash').get_hooks()]
+
+@_deprecated_to_gossip
+def get_hook_by_name(hook_name):
+    """
+    Returns a hook (if exists) by its name, otherwise returns None
+    """
+    return gossip.get_hook('slash.{0}'.format(hook_name))
diff --git a/slash/interfaces.py b/slash/interfaces.py
new file mode 100755
index 0000000000..3594caad27
--- /dev/null
+++ b/slash/interfaces.py
@@ -0,0 +1,10 @@
+class Activatable(object):
+    def activate(self):
+        raise NotImplementedError() # pragma: no cover
+    def deactivate(self):
+        raise NotImplementedError() # pragma: no cover
+    def __enter__(self):
+        self.activate()
+        return self
+    def __exit__(self, *_, **__):
+        self.deactivate()
diff --git a/slash/loader.py b/slash/loader.py
new file mode 100755
index 0000000000..4a419fe8aa
--- /dev/null
+++ b/slash/loader.py
@@ -0,0 +1,265 @@
+import itertools
+import traceback
+import os
+import sys
+from types import FunctionType, GeneratorType
+from contextlib import contextmanager
+
+import dessert
+from emport import import_file
+from logbook import Logger
+from sentinels import NOTHING
+
+
+from .conf import config
+from ._compat import string_types
+from .ctx import context
+from .core.local_config import LocalConfig
+from .core.markers import repeat_marker
+from . import hooks
+from .core.runnable_test import RunnableTest
+from .core.test import Test, TestTestFactory, is_valid_test_name
+from .core.function_test import FunctionTestFactory
+from .exception_handling import handling_exceptions
+from .exceptions import CannotLoadTests
+from .core.runnable_test_factory import RunnableTestFactory
+from .utils.pattern_matching import Matcher
+from .utils.python import check_duplicate_functions
+from .resuming import ResumedTestData
+from .utils.interactive import generate_interactive_test
+
+_logger = Logger(__name__)
+
+
+class Loader(object):
+
+    """
+    Provides iteration interfaces to load runnable tests from various places
+    """
+
+    def __init__(self):
+        super(Loader, self).__init__()
+        self._local_config = LocalConfig()
+        self._duplicate_funcs = set()
+
+    _cached_matchers = NOTHING
+
+    def _get_matchers(self):
+        if self._cached_matchers is NOTHING:
+            if config.root.run.filter_strings:
+                self._cached_matchers = [Matcher(s) for s in config.root.run.filter_strings]
+            else:
+                self._cached_matchers = None
+        return self._cached_matchers
+
+
+    def get_runnables(self, paths, prepend_interactive=False):
+        assert context.session is not None
+        sources = self._generate_repeats(self._generate_test_sources(paths))
+        returned = self._collect(sources)
+        self._duplicate_funcs |= self._local_config.duplicate_funcs
+        for (path, name, line) in sorted(self._duplicate_funcs):
+            _logger.warning('Duplicate function definition, File: {}, Name: {}, Line: {}'.format(path, name, line))
+
+        if prepend_interactive:
+            returned.insert(0, generate_interactive_test())
+
+        hooks.tests_loaded(tests=returned) # pylint: disable=no-member
+        returned.sort(key=lambda test: test.__slash__.get_sort_key())
+        return returned
+
+
+    def _generate_repeats(self, tests):
+        returned = []
+        repeat_each = config.root.run.repeat_each
+        for test in tests:
+            for i in range(repeat_each * repeat_marker.get_value(test.get_test_function(), 1)):
+                returned.append(test.clone() if i else test)
+        num_tests = len(returned)
+        for i in range(config.root.run.repeat_all - 1):
+            for test in itertools.islice(returned, 0, num_tests):
+                returned.append(test.clone())
+        return returned
+
+
+    def _collect(self, iterator):
+        returned = []
+        context.reporter.report_collection_start()
+        try:
+            for x in iterator:
+                assert x.__slash__.id is None
+                x.__slash__.allocate_id()
+                returned.append(x)
+                context.reporter.report_test_collected(returned, x)
+        finally:
+            context.reporter.report_collection_end(returned)
+        context.session.increment_total_num_tests(len(returned))
+        return returned
+
+    def _generate_test_sources(self, thing, matcher=None):
+
+        if isinstance(thing, tuple):
+            assert len(thing) == 2, '_generate_test_sources on tuples requires a tuple of (loadable_obj, matcher)'
+            iterator = self._generate_test_sources(thing[0], matcher=thing[1])
+
+        elif isinstance(thing, (list, GeneratorType, itertools.chain)):
+            iterator = itertools.chain.from_iterable(self._generate_test_sources(x) for x in thing)
+        elif isinstance(thing, string_types):
+            iterator = self._iter_test_address(thing)
+        elif isinstance(thing, RunnableTest):
+            iterator = [thing]
+        elif isinstance(thing, ResumedTestData):
+            iterator = self._iter_test_resume(thing)
+        elif not isinstance(thing, RunnableTestFactory):
+            thing = self._get_runnable_test_factory(thing)
+            iterator = thing.generate_tests(fixture_store=context.session.fixture_store)
+
+        return (t for t in iterator if matcher is None or matcher.matches(t.__slash__))
+
+    def _iter_test_resume(self, resume_state):
+        for test in self._iter_path(resume_state.file_name):
+            if resume_state.function_name == test.__slash__.address_in_file:
+                if resume_state.variation:
+                    if not resume_state.variation == test.get_variation().id:
+                        continue
+                yield test
+
+    def _iter_test_address(self, address):
+        drive, address = os.path.splitdrive(address)
+        if ':' in address:
+            path, address_in_file = address.split(':', 1)
+        else:
+            path = address
+            address_in_file = None
+        path = os.path.join(drive, path)
+
+
+        tests = list(self._iter_path(path))
+
+        # special case for directories where we couldn't load any tests (without filter)
+        if not tests and address_in_file is None:
+            return
+
+        matched = False
+        for test in tests:
+
+            if address_in_file is not None:
+                if not self._address_in_file_matches(address_in_file, test):
+                    continue
+            matched = True
+            yield test
+        if not matched:
+            raise CannotLoadTests('Cannot find test(s) for {!r}'.format(address))
+
+    def _address_in_file_matches(self, address_in_file, test):
+        if address_in_file == test.__slash__.factory_name:
+            return True
+        test_address_in_file = test.__slash__.address_in_file
+        if address_in_file == test_address_in_file:
+            return True
+        if '(' in test_address_in_file:
+            if address_in_file == test_address_in_file[:test_address_in_file.index('(')]:
+                return True
+        return False
+
+    def _iter_path(self, path):
+        return self._iter_paths([path])
+
+    def _iter_paths(self, paths):
+
+        paths = list(paths)
+        for path in paths:
+            if not os.path.exists(path):
+                msg = "Path {!r} could not be found".format(path)
+                with handling_exceptions():
+                    raise CannotLoadTests(msg)
+        for path in paths:
+            for file_path in _walk(path):
+                _logger.debug("Checking {0}", file_path)
+                if not self._is_file_wanted(file_path):
+                    _logger.debug("{0} is not wanted. Skipping...", file_path)
+                    continue
+                module = None
+                try:
+                    with handling_exceptions(context="during import"):
+                        if not config.root.run.message_assertion_introspection:
+                            dessert.disable_message_introspection()
+                        with dessert.rewrite_assertions_context():
+                            module = import_file(file_path)
+                except Exception as e:
+                    tb_file, tb_lineno, _, _ = traceback.extract_tb(sys.exc_info()[2])[-1]
+                    raise CannotLoadTests(
+                        "Could not load {0!r} ({1}:{2} - {3})".format(file_path, tb_file, tb_lineno, e))
+                if module is not None:
+                    self._duplicate_funcs |= check_duplicate_functions(file_path)
+                    with self._adding_local_fixtures(file_path, module):
+                        for runnable in self._iter_runnable_tests_in_module(file_path, module):
+                            if self._is_excluded(runnable):
+                                continue
+                            yield runnable
+
+    @contextmanager
+    def _adding_local_fixtures(self, file_path, module):
+        with context.session.fixture_store.new_namespace_context():
+            self._local_config.push_path(os.path.dirname(file_path))
+            try:
+                context.session.fixture_store.add_fixtures_from_dict(
+                    self._local_config.get_dict())
+                with context.session.fixture_store.new_namespace_context():
+                    context.session.fixture_store.add_fixtures_from_dict(
+                        vars(module))
+                    context.session.fixture_store.resolve()
+                    yield
+            finally:
+                self._local_config.pop_path()
+
+
+    def _is_excluded(self, test):
+        matchers = self._get_matchers()
+        if matchers is None:
+            return False
+        return not all(m.matches(test.__slash__) for m in matchers)
+
+    def _is_file_wanted(self, filename):
+        return filename.endswith(".py")
+
+    def _iter_runnable_tests_in_module(self, file_path, module):
+        for thing_name in sorted(dir(module)):
+            thing = getattr(module, thing_name)
+            if thing is RunnableTestFactory:  # probably imported directly
+                continue
+
+            factory = self._get_runnable_test_factory(thing)
+
+            if factory is None:
+                continue
+
+            factory.set_factory_name(thing_name)
+            factory.set_module_name(module.__name__)
+            factory.set_filename(file_path)
+
+            for test in factory.generate_tests(fixture_store=context.session.fixture_store):
+                assert test.__slash__ is not None
+                yield test
+
+    def _get_runnable_test_factory(self, thing):
+
+        if isinstance(thing, type) and issubclass(thing, Test):
+            return TestTestFactory(thing)
+
+        if isinstance(thing, FunctionType):
+            if is_valid_test_name(thing.__name__):
+                return FunctionTestFactory(thing)
+
+        return None
+
+
+def _walk(p):
+    if os.path.isfile(p):
+        yield p
+        return
+
+    for path, dirnames, filenames in os.walk(p):
+        dirnames[:] = sorted(dirname for dirname in dirnames if not dirname.startswith('.'))
+        for filename in sorted(filenames):
+            yield os.path.join(path, filename)
diff --git a/slash/log.py b/slash/log.py
new file mode 100755
index 0000000000..f3bb87e5de
--- /dev/null
+++ b/slash/log.py
@@ -0,0 +1,329 @@
+import numbers
+import os
+import sys
+from contextlib import contextmanager
+
+import logbook  # pylint: disable=F0401
+import logbook.more
+from vintage import warn_deprecation
+
+from . import context
+from ._compat import ExitStack
+from .conf import config
+from .utils.path import ensure_containing_directory
+from .warnings import WarnHandler
+
+_logger = logbook.Logger(__name__)
+
+_custom_colors = {}
+
+
+class _NormalizedObject(object):
+    def __init__(self, obj):
+        self._obj = obj
+
+    def __getattr__(self, name):
+        obj = getattr(self._obj, name)
+        return obj if isinstance(obj, numbers.Number) else _NormalizedObject(obj)
+
+    @staticmethod
+    def _escape(s):
+        return s.replace('\\', '_').replace('/', '_')
+
+    def __str__(self):
+        return self._escape(str(self._obj))
+
+    def __repr__(self):
+        return self._escape(repr(self._obj))
+
+
+def set_log_color(logger_name, level, color):
+    """Sets the color displayed in the console, according to the logger name and level
+    """
+    _custom_colors[logger_name, level] = color
+
+class ColorizedHandlerMixin(logbook.more.ColorizingStreamHandlerMixin):
+
+    def get_color(self, record):
+        returned = _custom_colors.get((record.channel, record.level))
+        if returned is not None:
+            return returned
+
+        if record.level >= logbook.ERROR:
+            return 'red'
+        elif record.level >= logbook.WARNING:
+            return 'yellow'
+        elif record.level >= logbook.NOTICE:
+            return 'white'
+        return None # default
+
+class ColorizedFileHandler(ColorizedHandlerMixin, logbook.FileHandler):
+
+    def should_colorize(self, record):
+        return True
+
+
+class ConsoleHandler(ColorizedHandlerMixin, logbook.StreamHandler):
+
+    MAX_LINE_LENGTH = 160
+
+    default_format_string = '[{record.time:%Y-%m-%d %H:%M:%S}] {record.message}'
+
+    def __init__(self, **kw):
+        stream = kw.pop('stream', sys.stderr)
+        logbook.StreamHandler.__init__(self, stream=stream, **kw)
+        self._truncate_lines = config.root.log.truncate_console_lines
+        self._truncate_errors = config.root.log.truncate_console_errors
+        if config.root.log.color_console is not None:
+            if config.root.log.color_console:
+                self.force_color()
+            else:
+                self.forbid_color()
+
+    def format(self, record):
+        orig_message = record.message
+        should_truncate = self._truncate_errors or record.level < logbook.ERROR
+        if self._truncate_lines and len(str(orig_message)) > self.MAX_LINE_LENGTH and should_truncate:
+            record.message = "\n".join(self._truncate(line) for line in orig_message.splitlines())
+        try:
+            returned = super(ConsoleHandler, self).format(record)
+        finally:
+            # we back up the original message to avoid propagating truncated lines into the file log
+            record.message = orig_message
+        return returned
+
+    def _truncate(self, line):
+        if len(line) > self.MAX_LINE_LENGTH:
+            line = line[:self.MAX_LINE_LENGTH - 3] + "..."
+        return line
+
+    def emit(self, record):
+        reporter = None if context.session is None else context.session.reporter
+        if reporter is not None:
+            reporter.notify_before_console_output()
+        returned = super(ConsoleHandler, self).emit(record)
+        if reporter is not None:
+            reporter.notify_after_console_output()
+        return returned
+
+class SessionLogging(object):
+    """
+    A context creator for logging within a session and its tests
+    """
+    def __init__(self, session, console_stream=None):
+        super(SessionLogging, self).__init__()
+        if console_stream is None:
+            console_stream = sys.stderr
+        self.session = session
+        self.warnings_handler = WarnHandler(session.warnings)
+        self.console_handler = ConsoleHandler(bubble=True, level=config.root.log.console_level, stream=console_stream)
+        #: contains the path for the session logs
+        self.session_log_path = None
+        self.session_log_handler = None
+        #: contains the path for the current test logs
+        self.test_log_path = None
+        self._set_formatting(self.console_handler, config.root.log.console_format or config.root.log.format)
+
+    @contextmanager
+    def get_test_logging_context(self):
+        with self._get_file_logging_context(config.root.log.subpath, config.root.log.last_test_symlink) as (_, path):
+            self.test_log_path = path
+            context.result.set_log_path(path)
+            try:
+                yield path
+            finally:
+                self._create_last_failed_symlink_if_needed()
+
+    def _create_last_failed_symlink_if_needed(self):
+        result = context.result
+        assert result
+        if result.is_error() or result.is_failure():
+            self._try_create_symlink(result.get_log_path(), config.root.log.last_failed_symlink)
+
+    @contextmanager
+    def get_session_logging_context(self):
+        assert self.session_log_handler is None
+        with self._get_file_logging_context(
+            config.root.log.session_subpath, config.root.log.last_session_symlink) as (handler, path):
+            self.session_log_handler = handler
+            self.session_log_path = path
+            self.session.results.global_result.set_log_path(path)
+            if config.root.log.last_session_dir_symlink is not None and self.session_log_path is not None:
+                self._try_create_symlink(os.path.dirname(self.session_log_path), config.root.log.last_session_dir_symlink)
+            yield path
+
+    @contextmanager
+    def _get_file_logging_context(self, filename_template, symlink):
+        with ExitStack() as stack:
+            handler, path = self._get_file_log_handler(filename_template, symlink)
+            stack.enter_context(handler.applicationbound())
+            stack.enter_context(self.console_handler.applicationbound())
+            stack.enter_context(self.warnings_handler.applicationbound())
+            stack.enter_context(self._get_error_logging_context())
+            stack.enter_context(self._get_silenced_logs_context())
+            if config.root.log.unittest_mode:
+                stack.enter_context(logbook.StreamHandler(sys.stderr, bubble=True, level=logbook.TRACE))
+            for extra_handler in _extra_handlers:
+                stack.enter_context(extra_handler.applicationbound())
+            if config.root.log.unified_session_log and self.session_log_handler is not None:
+                stack.enter_context(_make_bubbling_handler(self.session_log_handler))
+
+            yield handler, path
+
+    def _get_error_logging_context(self):
+        path = config.root.log.errors_subpath
+        if path:
+            warn_deprecation('log.errors_subpath configuration is deprecated since 1.5.0. '
+                             'Please use log.highlights_subpath instead')
+        else:
+            path = config.root.log.highlights_subpath
+        def _error_added_filter(record, handler): # pylint: disable=unused-argument
+            return record.extra.get('highlight')
+
+        handler, log_path = self._get_file_log_handler(path, symlink=None, bubble=True, filter=_error_added_filter)
+        if log_path and self.session.results.current is self.session.results.global_result:
+            self.session.results.global_result.add_extra_log_path(log_path)
+        return handler.applicationbound()
+
+    def _get_silenced_logs_context(self):
+        if not config.root.log.silence_loggers:
+            return ExitStack()
+        return SilencedLoggersHandler(config.root.log.silence_loggers).applicationbound()
+
+    def _get_file_log_handler(self, subpath, symlink, bubble=False, filter=None):
+        root_path = config.root.log.root
+        if root_path is None or subpath is None:
+            log_path = None
+            if bubble:
+                handler = NoopHandler()
+            else:
+                handler = logbook.NullHandler(filter=filter)
+        else:
+            log_path = self._normalize_path(os.path.join(root_path, _format_log_path(subpath)))
+            ensure_containing_directory(log_path)
+            handler = self._get_file_handler_class()(log_path, bubble=bubble, filter=filter)
+            if symlink:
+                self._try_create_symlink(log_path, symlink)
+            self._set_formatting(handler, config.root.log.format)
+        return handler, log_path
+
+    def _get_file_handler_class(self):
+        if config.root.log.colorize:
+            return ColorizedFileHandler
+        return logbook.FileHandler
+
+    def _normalize_path(self, p):
+        return os.path.expanduser(p)
+
+    def create_worker_symlink(self, worker_name, worker_session_id):
+        if config.root.log.root is None:
+            return
+        symlink = os.path.join(self.session.id, worker_name)
+        worker_dir = os.path.join(self._normalize_path(config.root.log.root), worker_session_id)
+        self._try_create_symlink(worker_dir, symlink)
+
+    def _try_create_symlink(self, path, symlink):
+        if symlink is None or config.root.log.root is None or config.root.parallel.worker_id is not None:
+            return
+
+        symlink = self._normalize_path(symlink)
+
+        if not os.path.isabs(symlink):
+            symlink = os.path.join(self._normalize_path(config.root.log.root), symlink)
+
+        try:
+            ensure_containing_directory(symlink)
+
+            if os.path.exists(symlink) or os.path.islink(symlink):
+                os.unlink(symlink)
+            os.symlink(path, symlink)
+
+        except Exception:  # pylint: disable=broad-except
+            _logger.debug("Failed to create symlink {0} --> {1}", path, symlink, exc_info=True)
+
+    def _set_formatting(self, handler, fmt):
+        if config.root.log.localtime:
+            logbook.set_datetime_format("local")
+        if fmt is not None:
+            handler.format_string = fmt
+
+class SilencedLoggersHandler(logbook.Handler):
+    def __init__(self, silence_logger_names):
+        super(SilencedLoggersHandler, self).__init__(bubble=False)
+        self._silenced_names = set(silence_logger_names)
+    def should_handle(self, record):
+        return record.channel in self._silenced_names
+
+class NoopHandler(object):
+
+    # Logbook's NullHandler does not bubble by default. This is dummy handler that
+    # does not interfere with the stack at all
+    def applicationbound(self):
+        return ExitStack()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, *_):
+        pass
+
+def add_log_handler(handler):
+    """
+    Adds a log handler to be entered for sessions and for tests
+    """
+    _extra_handlers.append(handler)
+
+def remove_all_extra_handlers():
+    del _extra_handlers[:]
+
+_extra_handlers = []
+
+class VERBOSITIES(object):
+
+    DEBUG = logbook.DEBUG
+    INFO = logbook.INFO
+    NOTICE = logbook.NOTICE
+    WARNING = logbook.WARNING
+    ERROR = logbook.ERROR
+    CRITICAL = logbook.CRITICAL
+
+
+def _make_bubbling_handler(handler):
+    return _BubblingWrapper(handler)
+
+class _BubblingWrapper(logbook.Handler):
+
+    def __init__(self, handler):
+        super(_BubblingWrapper, self).__init__(bubble=True)
+        self._handler = handler
+        self.should_handle = self._handler.should_handle
+        self.handle = self._handler.handle
+
+
+def _format_log_path(p):
+    return p.format(context=_NormalizedObject(context))
+
+
+class RetainedLogHandler(logbook.TestHandler):
+    """A logbook handler that retains the emitted logs in order to
+    flush them later to a handler.
+
+    This is useful to keep logs that are emitted during session configuration phase, and not lose
+    them from the session log
+    """
+    def __init__(self, *args, **kwargs):
+        super(RetainedLogHandler, self).__init__(*args, **kwargs)
+        self._enabled = True
+
+    def emit(self, record):
+        if self._enabled:
+            return super(RetainedLogHandler, self).emit(record)
+
+    def flush_to_handler(self, handler):
+        for r in self.records:
+            if handler.should_handle(r):
+                handler.emit(r)
+        del self.records[:]
+
+    def disable(self):
+        self._enabled = False
diff --git a/slash/parallel/__init__.py b/slash/parallel/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/slash/parallel/parallel_manager.py b/slash/parallel/parallel_manager.py
new file mode 100755
index 0000000000..a070f83893
--- /dev/null
+++ b/slash/parallel/parallel_manager.py
@@ -0,0 +1,175 @@
+import sys
+import errno
+import os
+import signal
+import subprocess
+import time
+import logbook
+import threading
+from tempfile import mkdtemp
+from  six.moves import xmlrpc_client
+from .. import log
+from ..exceptions import INTERRUPTION_EXCEPTIONS, ParallelServerIsDown, ParallelTimeout
+from ..conf import config
+from ..ctx import context
+from .server import Server, ServerStates
+from ..utils.tmux_utils import create_new_window, create_new_pane
+from .worker_configuration import WorkerConfiguration
+from .._compat import iteritems
+from .. import hooks
+
+_logger = logbook.Logger(__name__)
+log.set_log_color(_logger.name, logbook.NOTICE, 'blue')
+
+TIME_BETWEEN_CHECKS = 2
+MAX_CONNECTION_RETRIES = 200
+
+class ParallelManager(object):
+    def __init__(self, args):
+        super(ParallelManager, self).__init__()
+        self.server = None
+        self.workers_error_dircetory = mkdtemp()
+        self.args = [sys.executable, '-m', 'slash.frontend.main', 'run', '--parallel-parent-session-id', context.session.id, \
+                    '--workers-error-dir', self.workers_error_dircetory] + args
+        self.workers_num = config.root.parallel.num_workers
+        self.workers = {}
+        self.max_worker_id = 1
+        self.server_thread = None
+
+    def try_connect(self):
+        num_retries = 0
+        while self.server.state == ServerStates.NOT_INITIALIZED:
+            time.sleep(0.1)
+            if num_retries == MAX_CONNECTION_RETRIES:
+                raise ParallelServerIsDown("Cannot connect to XML_RPC server")
+            num_retries += 1
+
+    def start_worker(self):
+        worker_id = str(self.max_worker_id)
+        _logger.notice("Starting worker number {}".format(worker_id))
+        new_args = self.args[:] + ["--parallel-worker-id", worker_id]
+        worker_config = WorkerConfiguration(new_args)
+        hooks.before_worker_start(worker_config=worker_config) # pylint: disable=no-member
+        if config.root.tmux.enabled:
+            worker_config.argv.append(';$SHELL')
+            command = ' '.join(worker_config.argv)
+            if config.root.tmux.use_panes:
+                self.workers[worker_id] = create_new_pane(command)
+            else:
+                self.workers[worker_id] = create_new_window("worker {}".format(worker_id), command)
+        else:
+            with open(os.devnull, 'w') as devnull:
+                proc = subprocess.Popen(worker_config.argv, stdin=devnull, stdout=devnull, stderr=devnull)
+                self.workers[worker_id] = proc
+        self.max_worker_id += 1
+
+
+    def start_server_in_thread(self, collected):
+        self.server = Server(collected)
+        self.server_thread = threading.Thread(target=self.server.serve, args=())
+        self.server_thread.setDaemon(True)
+        self.server_thread.start()
+
+    def get_proxy(self):
+        return xmlrpc_client.ServerProxy('http://{0}:{1}'.format(config.root.parallel.server_addr, self.server.port))
+
+    def kill_workers(self):
+        if config.root.tmux.enabled:
+            for worker_pid in self.server.worker_pids:
+                try:
+                    os.kill(worker_pid, signal.SIGINT)
+                except OSError as err:
+                    if err.errno != errno.ESRCH:
+                        raise
+        else:
+            for worker in self.workers.values():
+                worker.send_signal(signal.SIGINT)
+
+    def report_worker_error_logs(self):
+        found_worker_errors_file = False
+        for file_name in os.listdir(self.workers_error_dircetory):
+            if file_name.startswith(config.root.parallel.worker_error_file):
+                found_worker_errors_file = True
+                with open(os.path.join(self.workers_error_dircetory, file_name)) as worker_file:
+                    content = worker_file.readlines()
+                    for line in content:
+                        _logger.error("{}: {}", file_name, line)
+        if not found_worker_errors_file:
+            _logger.error("No worker error files were found")
+
+
+    def wait_all_workers_to_connect(self):
+        while self.server.state == ServerStates.WAIT_FOR_CLIENTS:
+            if time.time() - self.server.start_time > config.root.parallel.worker_connect_timeout * self.workers_num:
+                _logger.error("Timeout: Not all clients connected to server, terminating")
+                _logger.error("Clients connected: {}".format(self.server.clients_last_communication_time.keys()))
+                self.kill_workers()
+                self.report_worker_error_logs()
+                raise ParallelTimeout("Not all clients connected")
+            time.sleep(TIME_BETWEEN_CHECKS)
+
+    def check_worker_timed_out(self):
+        for worker_id, last_connection_time in iteritems(self.server.get_workers_last_connection_time()):
+            if time.time() - last_connection_time > config.root.parallel.communication_timeout_secs:
+                _logger.error("Worker {} is down, terminating session".format(worker_id))
+                self.report_worker_error_logs()
+                if not config.root.tmux.enabled:
+                    if self.workers[worker_id].poll() is None:
+                        self.workers[worker_id].kill()
+                elif not config.root.tmux.use_panes:
+                    self.workers[worker_id].rename_window('stopped_client_{}'.format(worker_id))
+                self.get_proxy().report_client_failure(worker_id)
+
+    def check_no_requests_timeout(self):
+        if time.time() - self.server.last_request_time > config.root.parallel.no_request_timeout:
+            _logger.error("No request sent to server for {} seconds, terminating".format(config.root.parallel.no_request_timeout))
+            if self.server.has_connected_clients():
+                _logger.error("Clients that are still connected to server: {}".format(self.server.clients_last_communication_time.keys()))
+            if self.server.has_more_tests():
+                _logger.error("Number of unstarted tests: {}".format(self.server.unstarted_tests.qsize()))
+            if self.server.executing_tests:
+                _logger.error("Currently executed tests indexes: {}".format(self.server.executing_tests.values()))
+            self.kill_workers()
+            self.report_worker_error_logs()
+            raise ParallelTimeout("No request sent to server for {} seconds".format(config.root.parallel.no_request_timeout))
+
+    def is_process_running(self, pid):
+        try:
+            os.kill(pid, 0)
+        except OSError as err:
+            if err.errno == errno.ESRCH:
+                return False
+            else:
+                raise
+        return True
+
+    def start(self):
+        self.try_connect()
+        if not config.root.parallel.server_port:
+            self.args.extend(['--parallel-port', str(self.server.port)])
+        try:
+            for _ in range(self.workers_num):
+                self.start_worker()
+            self.wait_all_workers_to_connect()
+            while self.server.should_wait_for_request():
+                self.check_worker_timed_out()
+                self.check_no_requests_timeout()
+                time.sleep(TIME_BETWEEN_CHECKS)
+        except INTERRUPTION_EXCEPTIONS:
+            _logger.error("Server interrupted, stopping workers and terminating")
+            self.get_proxy().session_interrupted()
+            self.kill_workers()
+            raise
+        finally:
+            if not config.root.tmux.enabled:
+                for worker in self.workers.values():
+                    worker.wait()
+            else:
+                for worker_pid in self.server.worker_pids:
+                    for _ in range(10):
+                        if not self.is_process_running(worker_pid):
+                            break
+                        else:
+                            time.sleep(0.5)
+            self.get_proxy().stop_serve()
+            self.server_thread.join()
diff --git a/slash/parallel/server.py b/slash/parallel/server.py
new file mode 100755
index 0000000000..7bc69521d8
--- /dev/null
+++ b/slash/parallel/server.py
@@ -0,0 +1,202 @@
+import copy
+import logbook
+import functools
+import time
+from enum import Enum
+from six.moves import queue
+from six.moves import xmlrpc_server
+from ..utils.python import unpickle
+from .. import log
+from ..ctx import context
+from ..runner import _get_test_context
+from .. import hooks
+from ..conf import config
+_logger = logbook.Logger(__name__)
+log.set_log_color(_logger.name, logbook.NOTICE, 'blue')
+
+NO_MORE_TESTS = "NO_MORE_TESTS"
+PROTOCOL_ERROR = "PROTOCOL_ERROR"
+WAITING_FOR_CLIENTS = "WAITING_FOR_CLIENTS"
+
+class ServerStates(Enum):
+    NOT_INITIALIZED = 1
+    WAIT_FOR_CLIENTS = 2
+    WAIT_FOR_COLLECTION_VALIDATION = 3
+    SERVE_TESTS = 4
+    STOP_TESTS_SERVING = 5
+    STOP_SERVE = 6
+
+def server_func(func):
+    @functools.wraps(func)
+    def wrapper(*args, **kwargs):
+        self = args[0]
+        client_id = kwargs.pop('client_id', args[1])
+        self.clients_last_communication_time[client_id] = self.last_request_time = time.time()
+        return func(*args)  # pylint: disable=not-callable
+    return wrapper
+
+class Server(object):
+    def __init__(self, tests):
+        super(Server, self).__init__()
+        self.host = config.root.parallel.server_addr
+        self.interrupted = False
+        self.state = ServerStates.NOT_INITIALIZED
+        self.port = None
+        self.tests = tests
+        self.worker_session_ids = []
+        self.executing_tests = {}
+        self.finished_tests = []
+        self.unstarted_tests = queue.Queue()
+        self.last_request_time = time.time()
+        self.num_collections_validated = 0
+        self.start_time = time.time()
+        self.worker_pids = []
+        for i in range(len(tests)):
+            self.unstarted_tests.put(i)
+        self.clients_last_communication_time = {}
+        self.collection = [[test.__slash__.file_path, test.__slash__.function_name, test.__slash__.variation.id] for test in self.tests]
+
+    def get_workers_last_connection_time(self):
+        return copy.deepcopy(self.clients_last_communication_time)
+
+    def _has_unstarted_tests(self):
+        return not self.unstarted_tests.empty()
+
+    def has_connected_clients(self):
+        return len(self.clients_last_communication_time) > 0
+
+    def has_more_tests(self):
+        return len(self.finished_tests) < len(self.tests)
+
+    def report_client_failure(self, client_id):
+        self.clients_last_communication_time.pop(client_id)
+        test_index = self.executing_tests.get(client_id, None)
+        if test_index is not None:
+            _logger.error("Worker {} interrupted while executing test {}".format(client_id, self.tests[test_index].__slash__.address))
+            with _get_test_context(self.tests[test_index], logging=False) as result:
+                result.mark_interrupted()
+                self.finished_tests.append(test_index)
+        self.state = ServerStates.STOP_TESTS_SERVING
+        self._mark_unrun_tests()
+
+    def _mark_unrun_tests(self):
+        while self._has_unstarted_tests():
+            test_index = self.unstarted_tests.get()
+            with _get_test_context(self.tests[test_index], logging=False):
+                pass
+            self.finished_tests.append(test_index)
+
+    def _get_worker_session_id(self, client_id):
+        return "worker_{}".format(client_id)
+
+    @server_func
+    def keep_alive(self, client_id):
+        _logger.debug("Client_id {} sent keep_alive".format(client_id))
+
+    @server_func
+    def connect(self, client_id, client_pid):
+        _logger.notice("Client_id {} connected".format(client_id))
+        client_session_id = '{}_{}'.format(context.session.id.split('_')[0], client_id)
+        context.session.logging.create_worker_symlink(self._get_worker_session_id(client_id), client_session_id)
+        hooks.worker_connected(session_id=client_session_id)  # pylint: disable=no-member
+        self.worker_session_ids.append(client_session_id)
+        self.worker_pids.append(client_pid)
+        self.executing_tests[client_id] = None
+        if len(self.clients_last_communication_time) >= config.root.parallel.num_workers:
+            _logger.notice("All workers connected to server")
+            self.state = ServerStates.WAIT_FOR_COLLECTION_VALIDATION
+
+    @server_func
+    def validate_collection(self, client_id, client_collection):
+        if not self.collection == client_collection:
+            _logger.error("Client_id {} sent wrong collection".format(client_id))
+            return False
+        self.num_collections_validated += 1
+        _logger.debug("Worker {} validated tests successfully".format(client_id))
+        if self.num_collections_validated >= config.root.parallel.num_workers and self.state == ServerStates.WAIT_FOR_COLLECTION_VALIDATION:
+            _logger.notice("All workers collected tests successfully, start serving tests")
+            self.state = ServerStates.SERVE_TESTS
+        return True
+
+    @server_func
+    def disconnect(self, client_id):
+        _logger.notice("Client {} sent disconnect".format(client_id))
+        self.clients_last_communication_time.pop(client_id)
+        self.state = ServerStates.STOP_TESTS_SERVING
+
+    @server_func
+    def get_test(self, client_id):
+        if not self.executing_tests[client_id] is None:
+            _logger.error("Client_id {} requested new test without sending former result".format(client_id))
+            return PROTOCOL_ERROR
+        if self.state == ServerStates.STOP_TESTS_SERVING:
+            return NO_MORE_TESTS
+        elif self.state in [ServerStates.WAIT_FOR_CLIENTS, ServerStates.WAIT_FOR_COLLECTION_VALIDATION]:
+            return WAITING_FOR_CLIENTS
+        elif self.state == ServerStates.SERVE_TESTS and self._has_unstarted_tests():
+            test_index = self.unstarted_tests.get()
+            test = self.tests[test_index]
+            self.executing_tests[client_id] = test_index
+            hooks.test_distributed(test_logical_id=test.__slash__.id, worker_session_id=self._get_worker_session_id(client_id)) # pylint: disable=no-member
+            _logger.notice("#{}: {}, Client_id: {}", test_index + 1, test.__slash__.address, client_id, extra={'highlights': 1})
+            return test_index
+        else:
+            _logger.debug("No unstarted tests, sending end to client_id {}".format(client_id))
+            self.state = ServerStates.STOP_TESTS_SERVING
+            return NO_MORE_TESTS
+
+    @server_func
+    def finished_test(self, client_id, result_dict):
+        _logger.debug("Client_id {} finished_test".format(client_id))
+        test_index = self.executing_tests.get(client_id, None)
+        if test_index is not None:
+            self.finished_tests.append(test_index)
+            self.executing_tests[client_id] = None
+            with _get_test_context(self.tests[test_index], logging=False) as result:
+                result.deserialize(result_dict)
+                context.session.reporter.report_test_end(self.tests[test_index], result)
+                if not result.is_success(allow_skips=True) and config.root.run.stop_on_error:
+                    _logger.debug("Stopping (run.stop_on_error==True)")
+                    self.state = ServerStates.STOP_TESTS_SERVING
+                    self._mark_unrun_tests()
+        else:
+            _logger.error(
+                "finished_test request from client_id {} with index {}, but no test is mapped to this worker".format(client_id, test_index))
+            return PROTOCOL_ERROR
+
+    def stop_serve(self):
+        self.state = ServerStates.STOP_SERVE
+
+    def session_interrupted(self):
+        self.interrupted = True
+        if self.state != ServerStates.STOP_SERVE:
+            self.state = ServerStates.STOP_TESTS_SERVING
+
+    @server_func
+    def report_warning(self, client_id, pickled_warning):
+        _logger.notice("Client_id {} sent warning".format(client_id))
+        try:
+            warning = unpickle(pickled_warning)
+            context.session.warnings.add(warning)
+        except TypeError:
+            _logger.error('Error when deserializing warning, not adding it')
+
+    def should_wait_for_request(self):
+        return self.has_connected_clients() or self.has_more_tests()
+
+    def serve(self):
+        server = xmlrpc_server.SimpleXMLRPCServer((self.host, config.root.parallel.server_port), allow_none=True, logRequests=False)
+        try:
+            self.port = server.server_address[1]
+            self.state = ServerStates.WAIT_FOR_CLIENTS
+            server.register_instance(self)
+            _logger.debug("Starting server loop")
+            while self.state != ServerStates.STOP_SERVE:
+                server.handle_request()
+            if not self.interrupted:
+                context.session.mark_complete()
+            _logger.trace('Session finished. is_success={0} has_skips={1}',
+                          context.session.results.is_success(allow_skips=True), bool(context.session.results.get_num_skipped()))
+            _logger.debug("Exiting server loop")
+        finally:
+            server.server_close()
diff --git a/slash/parallel/worker.py b/slash/parallel/worker.py
new file mode 100755
index 0000000000..3cc39e8993
--- /dev/null
+++ b/slash/parallel/worker.py
@@ -0,0 +1,107 @@
+import threading
+import logbook
+import os
+import pickle
+import time
+from six.moves import xmlrpc_client
+from .server import NO_MORE_TESTS, PROTOCOL_ERROR, WAITING_FOR_CLIENTS
+from ..exceptions import INTERRUPTION_EXCEPTIONS
+from ..hooks import register
+from ..ctx import context
+from ..runner import run_tests
+from ..conf import config
+
+_logger = logbook.Logger(__name__)
+
+class Worker(object):
+    def __init__(self, client_id, session_id):
+        super(Worker, self).__init__()
+        self.client_id = client_id
+        self.session_id = session_id
+        self.server_addr = 'http://{0}:{1}'.format(config.root.parallel.server_addr, config.root.parallel.server_port)
+
+    def keep_alive(self, stop_event):
+        proxy = xmlrpc_client.ServerProxy(self.server_addr)
+        while not stop_event.is_set():
+            proxy.keep_alive(self.client_id)
+            stop_event.wait(1)
+
+    def warning_added(self, warning):
+        try:
+            warning = pickle.dumps(warning)
+            self.client.report_warning(self.client_id, warning)
+        except (pickle.PicklingError, TypeError):
+            _logger.error("Failed to pickle warning. Message: {}, File: {}, Line: {}".format(warning.message, warning.filename, warning.lineno))
+
+    def write_to_error_file(self, msg):
+        try:
+            file_name = "{}-{}.log".format(config.root.parallel.worker_error_file, self.client_id)
+            worker_error_file = os.path.join(config.root.parallel.workers_error_dir, file_name)
+            with open(worker_error_file, 'a') as error_file:
+                error_file.write(msg)
+        except OSError as err:
+            _logger.error("Failed to write to worker error file, error: {}".format(str(err)))
+
+    def connect_to_server(self):
+        try:
+            self.client = xmlrpc_client.ServerProxy(self.server_addr, allow_none=True)
+            self.client.connect(self.client_id, os.getpid())
+        except OSError as err:
+            self.write_to_error_file("Failed to connect to server, error: {}".format(str(err)))
+
+    def start_execution(self, app, collected_tests):
+        if os.getpid() != os.getpgid(0):
+            os.setsid()
+        register(self.warning_added)
+        collection = [(test.__slash__.file_path, test.__slash__.function_name, test.__slash__.variation.id) for test in collected_tests]
+
+        if not self.client.validate_collection(self.client_id, collection):
+            _logger.error("Collections of worker id {0} and master don't match, worker terminates".format(self.client_id))
+            self.client.disconnect(self.client_id)
+            return
+
+        stop_event = threading.Event()
+        tr = threading.Thread(target=self.keep_alive, args=(stop_event,))
+        tr.setDaemon(True)
+        tr.start()
+        should_stop = False
+        with app.session.get_started_context():
+            try:
+                while not should_stop:
+                    test_index = self.client.get_test(self.client_id)
+                    if test_index == WAITING_FOR_CLIENTS:
+                        _logger.debug("Worker_id {} recieved waiting_for_clients, sleeping".format(self.client_id))
+                        time.sleep(0.05)
+                    elif test_index == PROTOCOL_ERROR:
+                        _logger.error("Worker_id {} recieved protocol error message, terminating".format(self.client_id))
+                        break
+                    elif test_index == NO_MORE_TESTS:
+                        _logger.debug("Got NO_MORE_TESTS, Client {} disconnecting".format(self.client_id))
+                        break
+                    else:
+                        test = collected_tests[test_index]
+                        context.session.current_parallel_test_index = test_index
+                        run_tests([test])
+                        result = context.session.results[test]
+                        _logger.debug("Client {} finished test, sending results".format(self.client_id))
+                        ret = self.client.finished_test(self.client_id, result.serialize())
+                        if ret == PROTOCOL_ERROR:
+                            _logger.error("Worker_id {} recieved protocol error message, terminating".format(self.client_id))
+                            should_stop = True
+            except INTERRUPTION_EXCEPTIONS:
+                self.write_to_error_file("Worker interrupted while executing test")
+                _logger.error("Worker interrupted while executing test")
+                raise
+            except Exception as err:
+                self.write_to_error_file(str(err))
+                raise
+            else:
+                context.session.mark_complete()
+                stop_event.set()
+                tr.join()
+                self.client.disconnect(self.client_id)
+            finally:
+                context.session.scope_manager.flush_remaining_scopes()
+                if not stop_event.is_set():
+                    stop_event.set()
+                    tr.join()
diff --git a/slash/parallel/worker_configuration.py b/slash/parallel/worker_configuration.py
new file mode 100755
index 0000000000..933193ed82
--- /dev/null
+++ b/slash/parallel/worker_configuration.py
@@ -0,0 +1,3 @@
+class WorkerConfiguration(object):
+    def __init__(self, argv):
+        self.argv = argv
diff --git a/slash/plugins/__init__.py b/slash/plugins/__init__.py
new file mode 100755
index 0000000000..9001599121
--- /dev/null
+++ b/slash/plugins/__init__.py
@@ -0,0 +1,384 @@
+import collections
+from contextlib import contextmanager
+import os
+import sys
+
+from emport import import_file
+from sentinels import NOTHING
+from vintage import warn_deprecation
+
+import gossip
+import gossip.hooks
+
+from .. import hooks
+from .._compat import itervalues, reraise
+from ..conf import config
+from ..utils.marks import mark, try_get_mark
+from .interface import PluginInterface
+
+
+_SKIPPED_PLUGIN_METHOD_NAMES = set(dir(PluginInterface))
+RegistrationInfo = collections.namedtuple("RegistrationInfo", ("hook_name", "expect_exists"))
+PluginInfo = collections.namedtuple("PluginInfo", ("plugin_instance", "is_internal"))
+
+class IncompatiblePlugin(ValueError):
+    pass
+
+class UnknownPlugin(ValueError):
+    pass
+
+class PluginManager(object):
+    def __init__(self):
+        super(PluginManager, self).__init__()
+        self._installed = {}
+        self._pending_activation = set()
+        self._pending_deactivation = set()
+        self._active = set()
+        self.install_builtin_plugins()
+
+    @contextmanager
+    def restoring_state_context(self):
+        previous = self._installed.copy()
+        try:
+            yield
+        finally:
+            for plugin_name in set(previous) - set(self._installed):
+                self.install(previous[plugin_name].plugin_instance)
+            for plugin_name in set(self._installed) - set(previous):
+                self.uninstall(plugin_name)
+
+
+    def discover(self):
+        """
+        Iterates over all search paths and loads plugins
+        """
+        for search_path in config.root.plugins.search_paths:
+            for path, _, filenames in os.walk(search_path):
+                for filename in filenames:
+                    if not filename.endswith(".py"):
+                        continue
+                    module = import_file(os.path.join(path, filename))
+                    install_func = getattr(module, "install_plugins", None)
+                    if install_func is None:
+                        continue
+                    install_func()
+
+    def get_installed_plugins(self, include_internals=True):
+        """
+        Returns a dict mapping plugin names to currently installed plugins
+        """
+        return {plugin_name: plugin_info.plugin_instance
+                for plugin_name, plugin_info in self._installed.items()
+                if include_internals or (not plugin_info.is_internal)}
+
+    def get_active_plugins(self):
+        """
+        Returns a dict mapping plugin names to currently active plugins
+        """
+        return dict(self._iterate_active_plugins())
+
+    def _iterate_active_plugins(self):
+        for active_name in self._active:
+            yield (active_name, self._get_installed_plugin_instance_by_name(active_name))
+
+    def get_future_active_plugins(self):
+        """
+        Returns a dictionary of plugins intended to be active once the 'pending activation' mechanism
+        is finished
+        """
+        returned = self.get_active_plugins()
+        for name in self._pending_activation:
+            returned[name] = self.get_plugin(name)
+        for name in self._pending_deactivation:
+            returned.pop(name, None)
+        return returned
+
+    def get_plugin(self, plugin_name):
+        """
+        Retrieves a registered plugin by name, or raises a LookupError
+        """
+        return self._installed[plugin_name].plugin_instance
+
+    def is_internal_plugin(self, plugin):
+        """
+        Returns rather installed plugin is internal plugin
+        """
+        plugin_name = plugin if isinstance(plugin, str) else plugin.get_name()
+        return self._installed[plugin_name].is_internal
+
+    def install(self, plugin, activate=False, activate_later=False, is_internal=False):
+        """
+        Installs a plugin object to the plugin mechanism. ``plugin`` must be an object deriving from
+        :class:`slash.plugins.PluginInterface`.
+        """
+        if not isinstance(plugin, PluginInterface):
+            raise IncompatiblePlugin("Invalid plugin type: {0!r}".format(type(plugin)))
+        plugin_name = plugin.get_name()
+        self._configure(plugin)
+        self._installed[plugin_name] = PluginInfo(plugin, is_internal)
+        if not hasattr(plugin, '__toggles__'):
+            plugin.__toggles__ = {
+                'session': gossip.Toggle(),
+            }
+        if activate:
+            try:
+                self.activate(plugin_name)
+            except IncompatiblePlugin:
+                exc_info = sys.exc_info()
+                self.uninstall(plugin)
+                reraise(*exc_info)
+        if activate_later:
+            self.activate_later(plugin_name)
+
+    def install_builtin_plugins(self):
+        for builtin_plugin_module in self._iter_builtin_plugin_modules():
+            module = __import__(
+                "slash.plugins.builtin.{0}".format(builtin_plugin_module),
+                fromlist=[""]
+            )
+            self.install(module.Plugin())
+
+    def _iter_builtin_plugin_modules(self):
+        builtin_dir = os.path.join(os.path.dirname(__file__), "builtin")
+        for filename in os.listdir(builtin_dir):
+            if filename.startswith("_") or filename.startswith(".") or not filename.endswith(".py"):
+                continue
+            yield filename[:-3]
+
+    def uninstall(self, plugin):
+        """
+        Uninstalls a plugin
+        """
+        plugin = self._get_installed_plugin(plugin)
+        try:
+            self.deactivate(plugin)
+        except IncompatiblePlugin:
+            pass
+        self._unconfigure(plugin)
+        self._installed.pop(plugin.get_name())
+
+    def uninstall_all(self):
+        """
+        Uninstalls all installed plugins
+        """
+        for plugin_info in list(itervalues(self._installed)):
+            self.uninstall(plugin_info.plugin_instance)
+        assert not self._installed
+
+    def activate(self, plugin):
+        """
+        Activates a plugin, registering its hook callbacks to their respective hooks.
+
+        :param plugin: either a plugin object or a plugin name
+        """
+        plugin = self._get_installed_plugin(plugin)
+        plugin_name = plugin.get_name()
+        plugin.activate()
+        for hook, callback, kwargs in self._get_plugin_registrations(plugin):
+            hook.register(callback, **kwargs)
+        self._active.add(plugin_name)
+
+    def activate_later(self, plugin):
+        """
+        Adds a plugin to the set of plugins pending activation. It can be remvoed from the queue with :meth:`.deactivate_later`
+
+        .. seealso:: :meth:`.activate_pending_plugins`
+        """
+        self._pending_activation.add(self._get_installed_plugin(plugin).get_name())
+
+    def deactivate_later(self, plugin):
+        """
+        Removes a plugin from the set of plugins pending activation.
+
+        .. seealso:: :meth:`.activate_pending_plugins`
+        """
+
+        self._pending_deactivation.add(self._get_installed_plugin(plugin).get_name())
+
+    def activate_pending_plugins(self):
+        """
+        Activates all plugins queued with :meth:`.activate_later`
+        """
+        while self._pending_activation:
+            plugin_name = self._pending_activation.pop()
+            if plugin_name not in self._pending_deactivation:
+                self.activate(plugin_name)
+
+        while self._pending_deactivation:
+            plugin_name = self._pending_deactivation.pop()
+            if plugin_name in self._active:
+                self.deactivate(plugin_name)
+
+    def deactivate(self, plugin):
+        """
+        Deactivates a plugin, unregistering all of its hook callbacks
+
+        :param plugin: either a plugin object or a plugin name
+        """
+        plugin = self._get_installed_plugin(plugin)
+        plugin_name = plugin.get_name()
+        token = self._get_token(plugin_name)
+
+        if plugin_name in self._active:
+            gossip.get_global_group().unregister_token(token)
+            self._active.discard(plugin_name)
+            plugin.deactivate()
+
+    def _configure(self, plugin):
+        cfg = plugin.get_config()
+        if cfg is not None:
+            warn_deprecation('PluginInterface.get_config() is deprecated. '
+                             'Please use PluginInterface.get_default_config() instead')
+        else:
+            cfg = plugin.get_default_config()
+        if cfg is not None:
+            config['plugin_config'].extend({plugin.get_name(): cfg})
+
+    def _unconfigure(self, plugin):
+        plugin_config = config['plugin_config']
+        if plugin.get_name() in plugin_config:
+            plugin_config.pop(plugin.get_name())
+
+    def _get_token(self, plugin_name):
+        return "slash.plugins.{0}".format(plugin_name)
+
+    def _get_installed_plugin_instance_by_name(self, plugin_name):
+        plugin_info = self._installed.get(plugin_name)
+        if plugin_info is None:
+            return None
+        return plugin_info.plugin_instance
+
+    def _get_installed_plugin_instance_by_type(self, plugin_class):
+        for plugin in self._installed.values():
+            if type(plugin.plugin_instance) is plugin_class: # pylint: disable=unidiomatic-typecheck
+                return plugin.plugin_instance
+        return None
+
+    def _get_installed_plugin(self, plugin):
+        if isinstance(plugin, str):
+            plugin_name = plugin
+            plugin_instance = self._get_installed_plugin_instance_by_name(plugin_name)
+        elif isinstance(plugin, type):
+            plugin_instance = self._get_installed_plugin_instance_by_type(plugin)
+            plugin_name = plugin_instance.get_name() if plugin_instance is not None else repr(plugin)
+        else:
+            plugin_instance = plugin
+            plugin_name = plugin.get_name()
+        if plugin_instance is None or self._get_installed_plugin_instance_by_name(plugin_name) is not plugin_instance:
+            raise UnknownPlugin("Unknown plugin: {0}".format(plugin_name))
+        return plugin_instance
+
+    def _get_plugin_registrations(self, plugin):
+        plugin_name = plugin.get_name()
+        returned = []
+        unknown = []
+        global_needs = try_get_mark(plugin, 'plugin_needs', [])
+        global_provides = try_get_mark(plugin, 'plugin_provides', [])
+
+        has_session_end = has_session_start = False
+
+        register_no_op_hooks = set()
+        if global_provides:
+            register_no_op_hooks.update(hook.full_name for hook in gossip.get_group('slash').get_hooks())
+
+        for method_name in dir(type(plugin)):
+            if method_name in _SKIPPED_PLUGIN_METHOD_NAMES:
+                continue
+
+            method = getattr(plugin, method_name)
+
+            if not hasattr(method, '__call__'):
+                continue
+
+            registration_list = try_get_mark(method, 'register_on', NOTHING)
+
+            if registration_list is not NOTHING:
+                registration_list = [RegistrationInfo(hook_name, False) for hook_name in registration_list]
+            else:
+                if method_name.startswith('_'):
+                    continue
+                registration_list = [RegistrationInfo("slash.{0}".format(method_name), True)]
+
+            for registration_info in registration_list:
+                if registration_info.hook_name is None:
+                    # asked not to register for nothing
+                    continue
+
+                if not try_get_mark(method, 'register_if', True):
+                    continue
+
+                plugin_needs = try_get_mark(method, 'plugin_needs', []) + global_needs
+                plugin_provides = try_get_mark(method, 'plugin_provides', []) + global_provides
+
+                try:
+                    if registration_info.expect_exists:
+                        hook = gossip.get_hook(registration_info.hook_name)
+                    else:
+                        hook = gossip.hooks.get_or_create_hook(registration_info.hook_name)
+                        if not hook.is_defined() and hook.group.is_strict():
+                            raise LookupError()
+                except LookupError:
+                    unknown.append(registration_info.hook_name)
+                    continue
+
+                assert hook is not None
+                register_no_op_hooks.discard(registration_info.hook_name)
+
+                kwargs = {
+                    'needs': plugin_needs,
+                    'provides': plugin_provides,
+                    'token': self._get_token(plugin_name),
+                }
+                if registration_info.hook_name == 'slash.session_start':
+                    has_session_start = True
+                    kwargs['toggles_on'] = plugin.__toggles__['session']
+                elif registration_info.hook_name == 'slash.session_end':
+                    has_session_end = True
+                    kwargs['toggles_off'] = plugin.__toggles__['session']
+
+                returned.append((hook, method, kwargs))
+
+        if has_session_end and not has_session_start:
+            hook = gossip.get_hook('slash.session_start')
+            returned.append((hook, lambda: None, {'toggles_on': plugin.__toggles__['session']}))
+            register_no_op_hooks.discard(hook.full_name)
+
+        for hook_name in register_no_op_hooks:
+            hook = gossip.get_hook(hook_name)
+            hook.register_no_op(provides=global_provides, token=self._get_token(plugin_name))
+
+        if unknown:
+            raise IncompatiblePlugin("Unknown hooks: {0}".format(", ".join(unknown)))
+        return returned
+
+
+manager = PluginManager()
+
+def registers_on(hook_name):
+    """Marks the decorated plugin method to register on a custom hook, rather than
+    the method name in the 'slash' group, which is the default behavior for plugins
+
+    Specifying ``registers_on(None)`` means that this is not a hook entry point at all.
+    """
+    return mark("register_on", hook_name, append=True)
+
+def register_if(condition):
+    """Marks the decorated plugins method to only be registered if *condition* is ``True``
+    """
+    return mark("register_if", condition)
+
+def active(plugin_class):
+    """Decorator for automatically installing and activating a plugin upon definition
+    """
+    plugin = plugin_class()
+    manager.install(plugin)
+    manager.activate(plugin)
+
+    return plugin_class
+
+def needs(what):
+    return mark("plugin_needs", what, append=True)
+
+
+def provides(what):
+    return mark("plugin_provides", what, append=True)
diff --git a/slash/plugins/builtin/__init__.py b/slash/plugins/builtin/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/slash/plugins/builtin/coverage.py b/slash/plugins/builtin/coverage.py
new file mode 100755
index 0000000000..f82eb31e9f
--- /dev/null
+++ b/slash/plugins/builtin/coverage.py
@@ -0,0 +1,64 @@
+from __future__ import absolute_import
+
+from slash import config as slash_config
+
+from ...utils.conf_utils import Cmdline, Doc
+from ..interface import PluginInterface
+
+_DATA_FILENAME = '.coverage'
+
+class Plugin(PluginInterface):
+
+    """Enables saving coverage information for test runs
+    For more information see https://slash.readthedocs.org/en/master/builtin_plugins.html#coverage
+    """
+
+    def get_name(self):
+        return "coverage"
+
+    def get_default_config(self):
+        return {
+            'config_filename': False // Cmdline(arg='--cov-config') // Doc('Coverage configuration file'),
+            'report_type': 'html' // Cmdline(arg='--cov-report') // Doc('Coverage report format'),
+            'report': True,
+            'append': False // Cmdline(on='--cov-append') // Doc('Append coverage data to existing file'),
+            'sources': [] // Cmdline(append='--cov') // Doc('Modules or packages for which to track coverage'),
+        }
+
+    def activate(self):
+        try:
+            import coverage
+        except ImportError: # pragma: no cover
+            raise RuntimeError('The coverage plugin requires the coverage package to be installed. Please run `pip install coverage` to install it')
+
+        sources = slash_config.root.plugin_config.coverage.sources or None
+
+        self._cov = coverage.Coverage(
+            data_file=_DATA_FILENAME,
+            config_file=slash_config.root.plugin_config.coverage.config_filename,
+            source=sources,
+        )
+        if slash_config.root.plugin_config.coverage.append:
+            self._cov.load()
+        self._reporters = []
+        for report_type_name in slash_config.root.plugin_config.coverage.report_type.split(','):
+            if report_type_name == 'html':
+                self._reporters.append(self._cov.html_report)
+            elif report_type_name == 'xml':
+                self._reporters.append(self._cov.xml_report)
+            else:
+                raise RuntimeError('Unknown report type: {!r}'.format(report_type_name))
+        self._cov.start()
+
+
+    def session_end(self):
+        from coverage import CoverageException
+        self._cov.stop()
+        self._cov.save()
+        if slash_config.root.plugin_config.coverage.report:
+            for reporter in self._reporters:
+                try:
+                    reporter()
+                except CoverageException as e:
+                    if 'no data' not in str(e).lower():
+                        raise
diff --git a/slash/plugins/builtin/email_template.j2 b/slash/plugins/builtin/email_template.j2
new file mode 100755
index 0000000000..f937a48133
--- /dev/null
+++ b/slash/plugins/builtin/email_template.j2
@@ -0,0 +1,189 @@
+<!doctype html>
+<html xmlns="http://www.w3.org/1999/xhtml" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office">
+
+<head>
+  <title></title>
+  <!--[if !mso]><!-- -->
+  <meta http-equiv="X-UA-Compatible" content="IE=edge">
+  <!--<![endif]-->
+  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <style type="text/css">
+    #outlook a {
+      padding: 0;
+    }
+
+    .ReadMsgBody {
+      width: 100%;
+    }
+
+    .ExternalClass {
+      width: 100%;
+    }
+
+    .ExternalClass * {
+      line-height: 100%;
+    }
+
+    body {
+      margin: 0;
+      padding: 0;
+      -webkit-text-size-adjust: 100%;
+      -ms-text-size-adjust: 100%;
+    }
+
+    table,
+    td {
+      border-collapse: collapse;
+      mso-table-lspace: 0pt;
+      mso-table-rspace: 0pt;
+    }
+
+    img {
+      border: 0;
+      height: auto;
+      line-height: 100%;
+      outline: none;
+      text-decoration: none;
+      -ms-interpolation-mode: bicubic;
+    }
+
+    p {
+      display: block;
+      margin: 13px 0;
+    }
+  </style>
+  <!--[if !mso]><!-->
+  <style type="text/css">
+    @media only screen and (max-width:480px) {
+      @-ms-viewport {
+        width: 320px;
+      }
+      @viewport {
+        width: 320px;
+      }
+    }
+  </style>
+  <!--<![endif]-->
+  <!--[if mso]>
+<xml>
+  <o:OfficeDocumentSettings>
+    <o:AllowPNG/>
+    <o:PixelsPerInch>96</o:PixelsPerInch>
+  </o:OfficeDocumentSettings>
+</xml>
+<![endif]-->
+  <!--[if lte mso 11]>
+<style type="text/css">
+  .outlook-group-fix {
+    width:100% !important;
+  }
+</style>
+<![endif]-->
+
+  <!--[if !mso]><!-->
+  <link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700" rel="stylesheet" type="text/css">
+  <style type="text/css">
+    @import url(https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,700);
+  </style>
+  <!--<![endif]-->
+  <style type="text/css">
+    @media only screen and (min-width:480px) {
+      .mj-column-per-100 {
+        width: 100%!important;
+      }
+    }
+  </style>
+</head>
+
+<body>
+
+  <div class="mj-container">
+    <!--[if mso | IE]>
+      <table role="presentation" border="0" cellpadding="0" cellspacing="0" width="600" align="center" style="width:600px;">
+        <tr>
+          <td style="line-height:0px;font-size:0px;mso-line-height-rule:exactly;">
+      <![endif]-->
+    <div style="margin:0px auto;max-width:600px;">
+      <table role="presentation" cellpadding="0" cellspacing="0" style="font-size:0px;width:100%;" align="center" border="0">
+        <tbody>
+          <tr>
+            <td style="text-align:center;vertical-align:top;direction:ltr;font-size:0px;padding:20px 0px;">
+              <!--[if mso | IE]>
+      <table role="presentation" border="0" cellpadding="0" cellspacing="0">
+        <tr>
+          <td style="vertical-align:top;width:600px;">
+      <![endif]-->
+              <div class="mj-column-per-100 outlook-group-fix" style="vertical-align:top;display:inline-block;direction:ltr;font-size:13px;text-align:left;width:100%;">
+                <table role="presentation" cellpadding="0" cellspacing="0" width="100%" border="0">
+                  <tbody>
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="center">
+                        <table role="presentation" cellpadding="0" cellspacing="0" style="border-collapse:collapse;border-spacing:0px;" align="center" border="0">
+                          <tbody>
+                            <tr>
+                              <td style="width:80px;"><img alt="" title="" height="auto" src="{% if success %}http://res.cloudinary.com/dfqg24lcc/image/upload/v1503292900/slash/slash-success.png{% else %}http://res.cloudinary.com/dfqg24lcc/image/upload/v1503292814/slash/slash-failed.png{% endif %}" style="border:none;border-radius:0px;display:block;font-size:13px;outline:none;text-decoration:none;width:100%;height:auto;" width="80"></td>
+                            </tr>
+                          </tbody>
+                        </table>
+                      </td>
+                    </tr>
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;">
+                        <p style="font-size:1px;margin:0px auto;border-top:4px solid #000000;width:100%;"></p>
+                        <!--[if mso | IE]><table role="presentation" align="center" border="0" cellpadding="0" cellspacing="0" style="font-size:1px;margin:0px auto;border-top:4px solid #000000;width:100%;" width="600"><tr><td style="height:0;line-height:0;"> </td></tr></table><![endif]-->
+                      </td>
+                    </tr>
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                        <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:20px;line-height:22px;text-align:left;">{{title}}</div>
+                      </td>
+                    </tr>
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                        <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:13px;line-height:22px;text-align:left;">Session <a href="{{backslash_link}}">{{session_id}}</a>, running on <strong>{{host_name}}</strong> has finished {{result}}
+                          after {{duration}}</div>
+                      </td>
+                    </tr>
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                        <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:13px;line-height:22px;text-align:left;">{{result_summary}}</div>
+                      </td>
+                    </tr>
+                    
+                    {% for key, value in message.details_dict.items() %}
+                      {% if loop.first %}
+                        <tr>
+                          <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                            <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:13px;line-height:22px;text-align:left;"><strong>Additional Details</strong></div>
+                          </td>
+                        </tr>
+                      {% endif %}
+
+                    <tr>
+                      <td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                        <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:13px;line-height:22px;text-align:left;">{{key}}</div>
+                      </td>
+<td style="word-wrap:break-word;font-size:0px;padding:10px 25px;" align="left">
+                        <div style="cursor:auto;color:#000000;font-family:Ubuntu, Helvetica, Arial, sans-serif;font-size:13px;line-height:22px;text-align:left;">{{value}}</div>
+                      </td>
+                    </tr>
+                    {% endfor %}
+                  </tbody>
+                </table>
+              </div>
+              <!--[if mso | IE]>
+      </td></tr></table>
+      <![endif]-->
+            </td>
+          </tr>
+        </tbody>
+      </table>
+    </div>
+    <!--[if mso | IE]>
+      </td></tr></table>
+      <![endif]-->
+  </div>
+</body>
+
+</html>
diff --git a/slash/plugins/builtin/notifications.py b/slash/plugins/builtin/notifications.py
new file mode 100755
index 0000000000..95aec59c04
--- /dev/null
+++ b/slash/plugins/builtin/notifications.py
@@ -0,0 +1,245 @@
+from ..interface import PluginInterface
+from ... import hooks
+from ...conf import config
+from ...ctx import session
+from ...exception_handling import handling_exceptions
+from ...utils.conf_utils import Cmdline
+
+from email.mime.multipart import MIMEMultipart
+from email.mime.text import MIMEText
+from vintage import warn_deprecation
+import datetime
+from pkg_resources import resource_string
+import requests
+import slash
+import smtplib
+import jinja2
+
+
+_SLASH_ICON = "http://slash.readthedocs.org/en/latest/_static/slash-logo.png"
+
+def _post_request(url, **kwargs):
+    response = requests.post(url, **kwargs)
+    response.raise_for_status()
+    return response
+
+
+def _send_email(smtp_server, subject, body, from_email, to_list, cc_list):
+    """Send an email.
+
+    :param str smtp_server: The smtp_server uri
+    :param str subject: The email subject.
+    :param str body: The email body.
+    :param str from_email: The from address.
+    :param list to_list: A list of email addresses to send to.
+    :param list cc_list: A list of email addresses to send to as cc.
+    """
+    msg = MIMEMultipart('alternative')
+    msg.attach(MIMEText(body, 'html'))
+
+    if not to_list:
+        to_list = []
+
+    if not cc_list:
+        cc_list = []
+
+    msg['Subject'] = subject
+    msg['From'] = from_email
+    msg['To'] = ', '.join(to_list)
+    msg['Cc'] = ', '.join(cc_list)
+    smtp = smtplib.SMTP(smtp_server)
+    try:
+        smtp.sendmail(from_email, to_list + cc_list, msg.as_string())
+    finally:
+        smtp.quit()
+
+
+class Message(object):
+    def __init__(self, title, body_template, kwargs, is_pdb):
+        self.title = title
+        self.body = body_template
+        self.kwargs = kwargs
+        self.details_dict = {}
+        self.is_pdb = is_pdb
+
+    def get_title(self):
+        return self.title.format(**self.kwargs)
+
+    def get_short_message(self):
+        return self.body.format(**self.kwargs)
+
+    _email_template = None
+
+    def _get_html_template(self):
+        returned = self._email_template
+        if returned is None:
+            source = resource_string('slash.plugins.builtin', 'email_template.j2').decode('utf-8')
+            returned = type(self)._email_template = jinja2.Template(source)
+        return returned
+
+    def get_html_message(self):
+        return self._get_html_template().render(message=self, **self.kwargs)
+
+
+
+class Plugin(PluginInterface):
+    """Enables notifications for successful and failed test runs through various providers (NMA, Prowl, Pushover etc.)
+    For more information see https://slash.readthedocs.org/en/master/builtin_plugins.html#notifications
+    """
+
+    def __init__(self, *args, **kwargs):
+        super(Plugin, self).__init__(*args, **kwargs)
+        self._notifiers = {}
+        self._basic_config = {
+            "prowl_api_key" : None,
+            "nma_api_key" : None,
+            "pushbullet_api_key": None,
+            "notification_threshold": 5,
+            "notify_only_on_failures": False // Cmdline(on='--notify-only-on-failures'),
+            "notify_on_pdb": True,
+        }
+        self._add_notifier(self._prowl_notifier, 'prowl', {'api_key': None, 'enabled': True})
+        self._add_notifier(self._nma_notifier, 'nma', {'api_key': None, 'enabled': True})
+        self._add_notifier(self._pushbullet_notifier, 'pushbullet', {'api_key': None, 'enabled': True})
+        self._add_notifier(self._email_notifier, 'email', {
+            'from_email': 'Slash <noreply@getslash.github.io>',
+            'smtp_server': None,
+            'to_list': [] // Cmdline(append='--email-to', metavar='ADDRESS'),
+            'cc_list': []
+        })
+        self._add_notifier(self._slack_notifier, 'slack', {'url': None, 'channel': None, 'from_user': 'slash-bot'})
+
+    def get_name(self):
+        return 'notifications'
+
+    def get_default_config(self):
+        return self._basic_config
+
+    def _add_notifier(self, func, name, conf_dict=None):
+        self._notifiers[name] = func
+        if not conf_dict:
+            conf_dict = {}
+        assert isinstance(conf_dict, dict)
+        conf_dict.setdefault('enabled', False)
+        conf_dict['enabled'] //= Cmdline(on='--notify-{}'.format(name))
+        self._basic_config[name] = conf_dict
+
+    def _get_from_config_with_legacy(self, notifier_name, legacy_name, new_name):
+        this_config = config.get_path('plugin_config.notifications')
+        value = this_config[legacy_name]
+        if value:
+            warn_deprecation('{} is depreacted. use {}.{} instead'.format(legacy_name, notifier_name, new_name))
+        else:
+            value = this_config[notifier_name][new_name]
+        return value
+
+    @staticmethod
+    def _os_post_notification(url, api_key, message):
+        if api_key:
+            data = {
+                "apikey": api_key,
+                "application": "slash",
+                "event": message.get_title(),
+                "description": message.get_short_message(),
+            }
+            _post_request(url, data=data)
+
+    def _prowl_notifier(self, message):
+        api_key = self._get_from_config_with_legacy('prowl', 'prowl_api_key', 'api_key')
+        self._os_post_notification("https://prowl.weks.net/publicapi/add", api_key, message)
+
+    def _nma_notifier(self, message):
+        api_key = self._get_from_config_with_legacy('nma', 'nma_api_key', 'api_key')
+        self._os_post_notification("https://www.notifymyandroid.com/publicapi/notify", api_key, message)
+
+    def _pushbullet_notifier(self, message):
+        api_key = self._get_from_config_with_legacy('pushbullet', 'pushbullet_api_key', 'api_key')
+        if api_key:
+            data = {"type": "note", "title": message.get_title(), "body": message.get_short_message()}
+            _post_request("https://api.pushbullet.com/api/pushes", data=data, auth=(api_key, ""))
+
+    def _email_notifier(self, message):
+        email_config = config.root.plugin_config.notifications.email
+        email_kwargs = {
+            'from_email': email_config.from_email,
+            'subject': message.get_title(),
+            'body': message.get_html_message(),
+            'smtp_server': email_config.smtp_server,
+            'to_list': email_config.to_list or None,
+            'cc_list': email_config.cc_list,
+        }
+        if all(value is not None for value in email_kwargs.values()):
+            _send_email(**email_kwargs)
+
+    def _slack_notifier(self, message):
+        slack_config = config.root.plugin_config.notifications.slack
+        if (slack_config.url is None) or (slack_config.channel is None):
+            return
+
+        color = '#439FE0' if message.is_pdb else ('good' if self._finished_successfully() else 'danger')
+        kwargs = {
+            'attachments': [{
+                'title': message.get_title(),
+                'fallback': 'Session {session_id} {result}'.format(**message.kwargs),
+                'text': message.get_short_message(),
+                'color': color,
+                }],
+            'channel': slack_config.channel,
+            'username': slack_config.from_user,
+            'icon_url': _SLASH_ICON,
+            }
+        _post_request(slack_config.url, json=kwargs)
+
+    def _finished_successfully(self):
+        return session.results.is_success(allow_skips=True)
+
+    def _get_message(self, short_message, is_pdb):
+        result_str = 'entered PDB' if is_pdb else ("Succeeded" if self._finished_successfully() else "Failed")
+        kwargs = {
+            'session_id': session.id,
+            'host_name': session.host_name,
+            'full_name': 'N/A',
+            'duration': str(datetime.timedelta(seconds=session.duration)).partition('.')[0],
+            'result': result_str,
+            'success': self._finished_successfully(),
+            'results_summary': repr(session.results).replace('<', '').replace('>', ''),
+            'total_num_tests': session.results.get_num_results(),
+            'non_successful_tests': session.results.get_num_errors() + session.results.get_num_failures(),
+        }
+        backslash_plugin = slash.plugins.manager.get_active_plugins().get('backslash')
+        if backslash_plugin:
+            config.root.plugin_config.notifications.email.to_list.append(backslash_plugin.session.user_email)
+            url = backslash_plugin.webapp_url + 'sessions/{}'.format(session.id)
+            kwargs['backslash_link'] = url
+            kwargs['full_name'] = backslash_plugin.session.user_display_name
+            session_info = 'Backslash: {backslash_link}'
+        else:
+            session_info = 'Session ID: {session_id}'
+        short_message += "\n\n" + session_info
+        title = "Slash Session on {host_name} has {result}".format(**kwargs)
+        kwargs['title'] = title
+        return Message(title, short_message, kwargs, is_pdb)
+
+    def entering_debugger(self, exc_info):
+        if not self.current_config.notify_on_pdb:
+            return
+        self._notify_all(short_message=repr(exc_info[1]), is_pdb=True)
+
+    def session_end(self):
+        if session.duration < self.current_config.notification_threshold:
+            return
+        if self._finished_successfully() and self.current_config.notify_only_on_failures:
+            return
+        self._notify_all(short_message='{results_summary}', is_pdb=False)
+
+
+    def _notify_all(self, short_message, is_pdb):
+        message = self._get_message(short_message, is_pdb)
+        hooks.prepare_notification(message=message) # pylint: disable=no-member
+        this_config = config.get_path('plugin_config.notifications')
+
+        for notifier_name, notifier_func in self._notifiers.items():
+            if not this_config[notifier_name]['enabled']:
+                continue
+            with handling_exceptions(swallow=True):
+                notifier_func(message)
diff --git a/slash/plugins/builtin/xunit.py b/slash/plugins/builtin/xunit.py
new file mode 100755
index 0000000000..5860212c55
--- /dev/null
+++ b/slash/plugins/builtin/xunit.py
@@ -0,0 +1,96 @@
+import datetime
+import socket
+import sys
+from ..interface import PluginInterface
+from ...ctx import context
+from ...utils.traceback_utils import get_traceback_string
+from ...utils.conf_utils import Cmdline, Doc
+from slash import config as slash_config
+from slash import context
+from xml.etree.ElementTree import (
+    tostring as xml_to_string,
+    Element as E,
+    )
+
+class Plugin(PluginInterface):
+    """
+    For more information see https://slash.readthedocs.org/en/master/builtin_plugins.html#xunit
+    """
+
+    _xunit_elements = None
+    _start_time = datetime.datetime.now()
+
+    def _get_xunit_elements_list(self):
+        returned = self._xunit_elements
+        if returned is None:
+            returned = self._xunit_elements = []
+        return returned
+
+    def get_name(self):
+        return "xunit"
+
+    def get_default_config(self):
+        return {
+            "filename": "testsuite.xml" // Cmdline(arg="--xunit-filename") // Doc('Name of XML xUnit file to create'),
+        }
+
+    def session_start(self):
+        self._start_time = datetime.datetime.now()
+
+    def test_start(self):
+        self._get_xunit_elements_list().append(E("testcase", {
+            "name": context.test.__slash__.address,
+            "classname": context.test.__slash__.class_name or '',
+            "time": "0"
+        }))
+
+    def test_success(self):
+        pass
+
+    def test_end(self):
+        for detail_name, detail_value in context.result.details.all().items():
+            self._add_element('detail', {'name': detail_name, 'value': detail_value})
+
+    def error_added(self, result, error): # pylint: disable=unused-argument
+        if error.is_failure():
+            self._add_error("failure", error)
+        else:
+            self._add_error("error", error)
+
+    def _add_error(self, errortype, error):
+        exc_type, exc_value, _ = exc_info = sys.exc_info()
+        self._add_element(errortype,
+                          {'type': exc_type.__name__ if exc_type else errortype, 'message': error.message},
+                          text=get_traceback_string(exc_info) if exc_value is not None else None)
+
+    def _add_element(self, tag, attrib, text=None):
+        if not context.test:
+            return
+        test_element = self._get_xunit_elements_list()[-1]
+        element = E(tag, attrib)
+        if text is not None:
+            element.text = text
+        test_element.append(element)
+
+    def _get_test_case_element(self, test):
+        return E('testcase', dict(name=str(test), classname="{}.{}".format(test.__class__.__module__, test.__class__.__name__), time="0"))
+
+    def test_skip(self, reason):
+        test_element = self._get_xunit_elements_list()[-1]
+        test_element.append(E('skipped', type=reason or ''))
+
+    def session_end(self):
+        e = E('testsuite', {
+            "name": "slash-suite",
+            "hostname": socket.getfqdn(),
+            "timestamp": self._start_time.isoformat().rsplit(".", 1)[0],
+            "time": "0",
+            "tests": str(context.session.results.get_num_results()),
+            "errors": str(context.session.results.get_num_errors()),
+            "failures": str(context.session.results.get_num_failures()),
+            "skipped": str(context.session.results.get_num_skipped()),
+        })
+        for element in self._get_xunit_elements_list():
+            e.append(element)
+        with open(slash_config.root.plugin_config.xunit.filename, "wb") as outfile:
+            outfile.write(xml_to_string(e))
diff --git a/slash/plugins/interface.py b/slash/plugins/interface.py
new file mode 100755
index 0000000000..0c1f486b2e
--- /dev/null
+++ b/slash/plugins/interface.py
@@ -0,0 +1,77 @@
+import abc
+from ..conf import config
+
+
+class PluginInterface(object):
+    """
+    This class represents the base interface needed from plugin classes.
+    """
+    __metaclass__ = abc.ABCMeta
+
+    def activate(self):
+        """
+        Called when the plugin is activated
+        """
+        pass
+
+    def get_default_config(self):
+        """
+        Optional: should return a dictionary or a confetti object which will be placed under
+        ``slash.config.plugin_config.<plugin_name>``
+        """
+        pass
+
+    def get_config(self):
+        """
+        Use :meth:`.get_default_config()` instead.
+
+        .. deprecated:: 1.5.0
+        """
+        pass
+
+    @property
+    def current_config(self):
+        """
+        Returns configuration object for plugin
+        """
+        return getattr(config.root.plugin_config, self.get_name())
+
+    def deactivate(self):
+        """
+        Called when the plugin is deactivated
+
+        .. note:: this method might not be called in practice, since it is not guaranteed that plugins are always
+          deactivated upon process termination. The intention here is to make plugins friendlier to cases
+          in which multiple sessions get established one after another, each with a different set of plugins.
+        """
+        pass
+
+    def configure_argument_parser(self, parser):
+        """
+        Gives a chance to the plugin to add options received from command-line
+        """
+        pass
+
+    def configure_from_parsed_args(self, args):
+        """
+        Called after successful parsing of command-line arguments
+        """
+        pass
+
+    def get_description(self):
+        """
+        Retrieves a quick description for this plugin, mostly used in command-line help or online documentation.
+        It is not mandatory to override this method.
+        """
+        return None
+
+    def get_name(self):
+        """
+        Returns the name of the plugin class. This name is used to register, disable and address
+        the plugin during runtime.
+
+        Note that the command-line switches (``--with-...``) are derived from this name.
+
+        Any implemented plugin must override this method.
+        """
+        raise NotImplementedError() # pragma: no cover
diff --git a/slash/reporting/__init__.py b/slash/reporting/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/slash/reporting/console_reporter.py b/slash/reporting/console_reporter.py
new file mode 100755
index 0000000000..b8b98974f5
--- /dev/null
+++ b/slash/reporting/console_reporter.py
@@ -0,0 +1,422 @@
+# pylint: disable=import-error,no-name-in-module
+from __future__ import division
+import itertools
+import os
+import sys
+
+from py.io import TerminalWriter
+from textwrap import wrap
+
+from .._compat import iteritems, izip, OrderedDict
+from ..conf import config
+from ..exceptions import CLI_ABORT_EXCEPTIONS
+from ..log import VERBOSITIES
+from ..utils.iteration import iteration
+from ..utils.python import wraps
+from .reporter_interface import ReporterInterface
+
+# traceback levels
+NO_TRACEBACK, SINGLE_FRAME, ALL_FRAMES, ALL_FRAMES_WITH_CONTEXT, ALL_FRAMES_WITH_CONTEXT_AND_VARS = range(
+    5)
+
+
+def theme(name):
+    return dict((x, True) for x in config['log']['console_theme'][name].split('/'))
+
+
+def from_verbosity(level):
+    def decorator(func):
+        @wraps(func)
+        def new_func(self, *args, **kwargs):
+            if self._verobsity_allows(level):  # pylint: disable=protected-access
+                return func(self, *args, **kwargs)
+
+        return new_func
+    return decorator
+
+
+class TerminalWriterWrapper(object):
+
+    def __init__(self, file):
+        super(TerminalWriterWrapper, self).__init__()
+        if config.root.log.color_console is not None:
+            os.environ['PY_COLORS'] = '1' if config.root.log.color_console else '0'
+        self._writer = TerminalWriter(file=file)
+        self._isatty = file.isatty()
+        self._line = ''
+
+    def isatty(self):
+        return self._isatty
+
+    def _get_full_width(self):
+        fullwidth = self._writer.fullwidth
+        if sys.platform == "win32":
+            # see py.io documentation for an explanation
+            fullwidth -= 1  # pragma: no cover
+
+        return fullwidth
+
+    def lsep(self, sep, msg, **kw):
+        """Write a left-justified line filled with the separator until the end of the line"""
+
+        self._do_write(
+            '{0} {1}\n'.format(msg, sep * ((self._get_full_width() - 1 - len(msg)) // len(sep))), **kw)
+
+    def write_box(self, headline, msg, **kw):
+        box_width = min(self._get_full_width(), 60)
+        line_width = box_width - 4
+
+        max_headline_length = box_width - 6
+        if len(headline) > max_headline_length:
+            headline = headline[max_headline_length:]
+
+        def write_line(line_to_write):
+            eol_padding = box_width - (len(line_to_write) + 3)
+            self._do_write('* {0}{1}*\n'.format(line_to_write, ' ' * eol_padding), **kw)
+
+        self._do_write('\n** {0} {1}\n'.format(headline, '*' * (box_width - (len(headline) + 4))), **kw)
+        for line in msg.split('\n'):
+            if not line:
+                write_line('')
+            else:
+                for sub_line in wrap(line, line_width):
+                    write_line(sub_line)
+        self._do_write('{0}\n\n'.format('*' * box_width), **kw)
+
+    def sep(self, *args, **kw):
+        self._line = ''
+        return self._writer.sep(*args, **kw)
+
+    def write(self, line, **kw):
+        line = str(line)
+        self._do_write(line, **kw)
+        self._line = self._get_line_remainder(self._line + line)
+
+    def _get_line_remainder(self, line):
+        return line.rsplit('\r', 1)[-1].rsplit('\n', 1)[-1]
+
+    def line(self, *args, **kw):
+        self._writer.line(*args, **kw)
+        self._line = ''
+
+    def clear_line_in_progress(self):
+        if self._line and self._writer.hasmarkup:
+            self._do_write('\r')
+            self._do_write(' ' * (len(self._line) % self._writer.fullwidth))
+            self._do_write('\r')
+
+    def restore_line_in_progress(self):
+        if self._writer.hasmarkup:
+            idx = len(self._line) - (len(self._line) % self._writer.fullwidth)
+            self._do_write(self._line[idx:])
+
+    def _do_write(self, *args, **kwargs):
+        return self._writer.write(*args, **kwargs)
+
+
+class ConsoleReporter(ReporterInterface):
+
+    def __init__(self, level, stream=sys.stderr):
+        super(ConsoleReporter, self).__init__()
+        self._level = level
+        self._stream = stream
+        self._terminal = TerminalWriterWrapper(file=stream)
+
+    def notify_before_console_output(self):
+        self._terminal.clear_line_in_progress()
+
+    def notify_after_console_output(self):
+        self._terminal.restore_line_in_progress()
+
+    def report_before_debugger(self, exc_info):
+        self.notify_before_console_output()
+        self._terminal.write('Exception caught in debugger: {0} {1}\n'.format(
+            exc_info[0], exc_info[1]), **theme('inline-error'))
+        self.notify_after_console_output()
+
+    def report_collection_start(self):
+        self._report_num_collected([], stillworking=True)
+
+    def report_test_collected(self, all_tests, test):
+        self._report_num_collected(all_tests, stillworking=True)
+
+    def report_collection_end(self, collected):
+        self._report_num_collected(collected, stillworking=False)
+
+    def _report_num_collected(self, collected, stillworking):
+        if self._terminal.isatty():
+            self._terminal.write('\r')
+
+        elif stillworking:
+            return
+
+        self._terminal.write('{0} tests collected{1}'.format(
+            len(collected), '...' if stillworking else '   \n'), white=True, bold=True)
+
+    def _is_verbose(self, level):
+        return self._level <= level
+
+    @from_verbosity(VERBOSITIES.ERROR)
+    def report_session_start(self, session):
+        self._terminal.sep('=', 'Session starts', white=True, bold=True)
+
+    def report_session_end(self, session):
+
+        if not self._verobsity_allows(VERBOSITIES.WARNING):
+            # for concise outputs we need to break the sequence of dots...
+            self._terminal.write('\n')
+
+        header_format = self._get_session_summary_header_format(session)
+
+        for index, (test_index, test_result, infos) in enumerate(self._iter_reported_results(session)):
+            if index == 0:
+                self._terminal.sep('=', 'Session Summary', **header_format)
+            self._report_test_summary_header(test_index, test_result)
+            self._report_additional_test_details(test_result)
+            for info_reporter in infos:
+                info_reporter(test_result)
+
+        if self._verobsity_allows(VERBOSITIES.WARNING):
+            self._report_result_warning_summary(session)
+
+        msg = 'Session ended.'
+        msg += ' {0} successful, {1} skipped, {2} failures, {3} errors.'.format(
+            session.results.get_num_successful(
+            ), session.results.get_num_skipped(include_not_run=False),
+            session.results.get_num_failures(), session.results.get_num_errors())
+
+        not_run = session.results.get_num_not_run()
+        if not_run:
+            msg += ' {0} not run.'.format(not_run)
+
+        msg += ' Total duration: {0}'.format(
+            self._format_duration(session.duration))
+        self._terminal.sep('=', msg, **header_format)
+
+    def _get_session_summary_header_format(self, session):
+        if session.results.is_success(allow_skips=True):
+            return theme('session-summary-success')
+        return theme('session-summary-failure')
+
+    def _iter_reported_results(self, session):
+        for test_index, test_result in enumerate(session.results.iter_test_results()):
+            infos = self._get_result_info_generators(test_result)
+            if not infos:
+                continue
+            yield test_index, test_result, infos
+
+    def _report_test_summary_header(self, index, test_result):
+        self._terminal.lsep(
+            "=", '== #{0}: {1}'.format(index + 1, test_result.test_metadata.address), **theme('test-error-header'))
+
+    def _get_result_info_generators(self, test_result):
+        returned = []
+        if self._verobsity_allows(VERBOSITIES.ERROR) and test_result.has_errors_or_failures():
+            returned.append(self._report_result_errors_failures)
+        if self._verobsity_allows(VERBOSITIES.INFO) and test_result.has_skips():
+            returned.append(self._report_result_skip_summary)
+
+        return returned
+
+    def _report_result_warning_summary(self, session):
+        warnings_by_key = OrderedDict()
+        for warning in session.warnings:
+            warnings_by_key.setdefault(warning.key, []).append(warning)
+        for i, (_, warnings) in iteration(iteritems(warnings_by_key)):
+            if i.first:
+                self._terminal.sep(
+                    '=', 'Warnings ({0} total)'.format(len(session.warnings)), yellow=True)
+            self._terminal.write(
+                ' * {d[filename]}:{d[lineno]:03} -- '.format(d=warnings[0].details), yellow=True)
+            self._terminal.write(
+                warnings[0].details['message'], yellow=True, bold=True)
+            self._terminal.write(
+                ' (Repeated {0} times)\n'.format(len(warnings)), yellow=True)
+
+    def _verobsity_allows(self, level):
+        return self._level <= level
+
+    def _report_result_errors_failures(self, test_result):
+        all_errs = list(
+            itertools.chain(izip(itertools.repeat("E"), test_result.get_errors()),
+                            izip(itertools.repeat("F"), test_result.get_failures())))
+        for index, (err_type, err) in enumerate(all_errs):
+            if err.exception_type is None and not config.root.log.show_manual_errors_tb:
+                self._terminal.write(err.message, **theme('tb-error'))
+                self._terminal.write('\n')
+                continue
+            err_header = ' - {0}/{1} {2} ({3:YYYY-MM-DD HH:mm:ss ZZ}): {4}'.format(
+                index + 1,
+                len(all_errs),
+                err_type,
+                err.time.to('local'),
+                ' - {0}'.format(err.message) if not err.traceback else '')
+            self._terminal.lsep(' -', err_header, **theme('error-separator-dash'))
+            if err.has_custom_message():
+                self._terminal.write(' {0}\n'.format(err.message), **theme('tb-error-message'))
+            self._report_traceback(err_type, err)
+
+    def _report_traceback(self, err_type, err):
+        traceback_level = config.root.log.traceback_level
+        if not err.traceback or traceback_level == NO_TRACEBACK:
+            frames = []
+        elif traceback_level == SINGLE_FRAME:
+            frames = [err.traceback.frames[-1]]
+        else:
+            frames = err.traceback.frames
+        for frame_iteration, frame in iteration(frames):
+            if traceback_level >= ALL_FRAMES_WITH_CONTEXT_AND_VARS:
+
+                if not frame_iteration.first:
+                    self._terminal.sep('- ')
+            self._terminal.write(
+                ' {0}:{1}\n'.format(frame.filename, frame.lineno), **theme('tb-frame-location'))
+
+            if traceback_level >= ALL_FRAMES_WITH_CONTEXT_AND_VARS:
+                self._write_frame_locals(frame)
+
+            self._write_frame_code(
+                frame, include_context=(traceback_level >= ALL_FRAMES_WITH_CONTEXT))
+            if frame_iteration.last:
+                self._terminal.write(err_type, **theme('tb-error'))
+                self._terminal.write(
+                    self._indent_with(err.message, 4), **theme('tb-error'))
+                self._terminal.write('\n')
+
+    def _report_additional_test_details(self, result):
+        if result.is_success():
+            return
+        detail_items = iteritems(result.details.all())
+
+        log_path = result.get_log_path()
+        if log_path is not None:
+            detail_items = itertools.chain(detail_items, [('Log', log_path)])
+
+        for index, (key, value) in enumerate(detail_items):
+            if index == 0:
+                self._terminal.write(' - Additional Details:\n', **theme('test-additional-details-header'))
+            self._terminal.write('    > {0}: {1!r}\n'.format(key, value), **theme('test-additional-details'))
+
+    def _indent_with(self, text, indent):
+        if isinstance(indent, int):
+            indent = ' ' * indent
+        return '\n'.join(indent + line for line in text.splitlines())
+
+    def _report_result_skip_summary(self, result):
+        msg = '\tSkipped'
+        skip_reasons = [r for r in result.get_skips() if r is not None]
+        if skip_reasons:
+            msg += ' ({0})'.format(', '.join(skip_reasons))
+        msg += '\n'
+
+        self._terminal.write(msg, **theme('test-skip-message'))
+
+    def _write_frame_locals(self, frame):
+        if not frame.locals and not frame.globals:
+            return
+        for index, (name, value) in enumerate(itertools.chain(iteritems(frame.locals), iteritems(frame.globals))):
+            if index > 0:
+                self._terminal.write(', ')
+            self._terminal.write(
+                '    {0}: '.format(name), **theme('frame-local-varname'))
+            self._terminal.write(value['value'])
+        self._terminal.write('\n\n')
+
+    def _write_frame_code(self, frame, include_context):
+        if frame.code_string:
+            if include_context:
+                code_lines = frame.code_string.splitlines()
+            else:
+                code_lines = [frame.code_line]
+            line = ''
+            for line_iteration, line in iteration(code_lines):
+                if line_iteration.last:
+                    self._terminal.write('>', **theme('error-cause-marker'))
+                else:
+                    self._terminal.write(' ')
+                if frame.is_in_test_code():
+                    theme_name = 'tb-test-line'
+                elif line_iteration.last:
+                    theme_name = 'tb-line-cause'
+                else:
+                    theme_name = 'tb-line'
+                self._terminal.write(line, **theme(theme_name))
+                self._terminal.write('\n')
+            return code_lines
+
+    @from_verbosity(VERBOSITIES.WARNING)
+    def report_file_start(self, filename):
+        self._file_failed = False
+        self._file_has_skips = False
+        if not self._verobsity_allows(VERBOSITIES.NOTICE):
+            self._terminal.write(filename)
+            self._terminal.write(' ')
+
+    @from_verbosity(VERBOSITIES.WARNING)
+    def report_file_end(self, filename):
+        if self._verobsity_allows(VERBOSITIES.NOTICE):
+            return
+        self._terminal.write('  ')
+        if self._file_failed:
+            self._terminal.line('FAIL', **theme('inline-file-end-fail'))
+        elif self._file_has_skips:
+            self._terminal.line('PASS', **theme('inline-file-end-skip'))
+        else:
+            self._terminal.line('PASS', **theme('inline-file-end-success'))
+
+    def report_test_success(self, test, result):
+        if not self._verobsity_allows(VERBOSITIES.NOTICE):
+            self._terminal.write('.')
+
+    def report_test_skip_added(self, test, reason):
+        self._file_has_skips = True
+        if self._verobsity_allows(VERBOSITIES.NOTICE):
+            self._terminal.write('Skipped: {}, Test: {}\n'.format(reason, test.__slash__), **theme('test-skip-message'))
+        else:
+            self._terminal.write('s', yellow=True)
+
+    def report_test_interrupted(self, test, result):
+        if self._verobsity_allows(VERBOSITIES.NOTICE):
+            self._terminal.write('Interrupted\n', **theme('inline-test-interrupted'))
+        else:
+            self._terminal.write('I', **theme('inline-test-interrupted'))
+
+    def report_test_error_added(self, test, error):
+        self._report_test_error_failure_added(test, error, 'E')
+
+    def report_test_failure_added(self, test, error):
+        self._report_test_error_failure_added(test, error, 'F')
+
+    def _report_test_error_failure_added(self, test, e, errtype):  # pylint: disable=unused-argument
+        if test is None:
+            if e.exception_type is None or not issubclass(e.exception_type, CLI_ABORT_EXCEPTIONS):
+                self._terminal.line('Session error caught -- {0}\n'.format(e), **theme('inline-error'))
+        else:
+            self._file_failed = True
+            if not self._verobsity_allows(VERBOSITIES.NOTICE):
+                self._terminal.write(errtype, red=True)
+            else:
+                self._terminal.write('{}: {}, Test: {}\n'.format(errtype, e, test.__slash__), **theme('inline-error'))
+
+    def report_fancy_message(self, headline, message):
+        if self._verobsity_allows(VERBOSITIES.INFO):
+            self._terminal.write_box(headline, message, **theme('fancy-message'))
+
+    def report_message(self, message):
+        self.notify_before_console_output()
+        self._terminal.write(message)
+        self._terminal.write('\n')
+        self.notify_after_console_output()
+
+    def report_error_message(self, message):
+        self.notify_before_console_output()
+        self._terminal.write('ERROR: {0}'.format(message), **theme('inline-error'))
+        self._terminal.write('\n')
+        self.notify_after_console_output()
+
+    def _format_duration(self, duration):
+        seconds = duration % 60
+        duration /= 60
+        minutes = duration % 60
+        hours = duration / 60
+        return '{0:02}:{1:02}:{2:02}'.format(int(hours), int(minutes), int(seconds))
diff --git a/slash/reporting/null_reporter.py b/slash/reporting/null_reporter.py
new file mode 100755
index 0000000000..345133ddec
--- /dev/null
+++ b/slash/reporting/null_reporter.py
@@ -0,0 +1,5 @@
+from .reporter_interface import ReporterInterface
+
+
+class NullReporter(ReporterInterface):
+    pass
diff --git a/slash/reporting/reporter_interface.py b/slash/reporting/reporter_interface.py
new file mode 100755
index 0000000000..fbefa63377
--- /dev/null
+++ b/slash/reporting/reporter_interface.py
@@ -0,0 +1,80 @@
+class ReporterInterface(object):
+
+    def notify_before_console_output(self):
+        pass
+
+    def notify_after_console_output(self):
+        pass
+
+    def report_before_debugger(self, exc_info):
+        pass
+
+    def report_session_start(self, session):
+        pass
+
+    def report_session_end(self, session):
+        pass
+
+    def report_file_start(self, filename):
+        pass
+
+    def report_file_end(self, filename):
+        pass
+
+    def report_collection_start(self):
+        pass
+
+    def report_test_collected(self, all_tests, test):
+        pass
+
+    def report_collection_end(self, collected):
+        pass
+
+    def report_test_start(self, test):
+        pass
+
+    def report_test_end(self, test, result):
+        if result.is_success():
+            self.report_test_success(test, result)
+        elif result.is_skip():
+            self.report_test_skip(test, result)
+        elif result.is_error():
+            self.report_test_error(test, result)
+        elif result.is_interrupted():
+            self.report_test_interrupted(test, result)
+        else:
+            assert result.is_failure()
+            self.report_test_failure(test, result)
+
+    def report_test_success(self, test, result):
+        pass
+
+    def report_test_skip(self, test, result):
+        pass
+
+    def report_test_error(self, test, result):
+        pass
+
+    def report_test_failure(self, test, result):
+        pass
+
+    def report_test_interrupted(self, test, result):
+        pass
+
+    def report_test_error_added(self, test, error):
+        pass
+
+    def report_test_failure_added(self, test, error):
+        pass
+
+    def report_test_skip_added(self, test, reason):
+        pass
+
+    def report_fancy_message(self, headline, message):
+        pass
+
+    def report_message(self, message):
+        pass
+
+    def report_error_message(self, message):
+        pass
diff --git a/slash/resuming.py b/slash/resuming.py
new file mode 100755
index 0000000000..27b8251c57
--- /dev/null
+++ b/slash/resuming.py
@@ -0,0 +1,155 @@
+import os
+import logbook
+from sqlalchemy import Column, DateTime, String, Integer
+from sqlalchemy.ext.declarative import declarative_base
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+from sqlalchemy.exc import OperationalError
+from contextlib import contextmanager, closing
+from datetime import datetime, timedelta
+from slash.plugins import manager
+from ast import literal_eval
+from .utils.path import ensure_directory
+
+_RESUME_DIR = os.path.expanduser("~/.slash/session_states")
+_DB_NAME = 'resume_state.db'
+_MAX_DAYS_SAVED_SESSIONS = 10
+_logger = logbook.Logger(__name__)
+Base = declarative_base()
+_session = sessionmaker()
+_db_initialized = False
+
+
+class ResumeState(Base):
+    __tablename__ = 'resume_state'
+    id = Column(Integer, primary_key=True)
+    session_id = Column(String, nullable=False, index=True)
+    file_name = Column(String, nullable=False, index=True)
+    function_name = Column(String, nullable=False, index=True)
+    variation = Column(String, index=True)
+
+
+class SessionMetadata(Base):
+    __tablename__ = 'session_metadata'
+    session_id = Column(String, primary_key=True)
+    src_folder = Column(String, nullable=False, index=True)
+    created_at = Column(DateTime, nullable=False, index=True)
+
+
+class ResumedTestData(object):
+
+    def __init__(self, file_name, function_name, variation=None):
+        self.file_name = file_name
+        self.function_name = function_name
+        self.variation = variation
+
+    def __repr__(self):
+        return '<ResumedTestData({!r}, {!r}, {!r})>'.format(self.file_name, self.function_name, self.variation)
+
+
+def _init_db():
+    ensure_directory(_RESUME_DIR)
+    engine = create_engine('sqlite:///{0}/{1}'.format(_RESUME_DIR, _DB_NAME))
+    _session.configure(bind=engine)
+    Base.metadata.create_all(engine)
+
+
+@contextmanager
+def connecting_to_db():
+    global _db_initialized  # pylint: disable=global-statement
+    if not _db_initialized:
+        _init_db()
+        _db_initialized = True
+    with closing(_session()) as new_session:
+        yield new_session
+        max_retries = 3
+        for i in range(max_retries):
+            try:
+                new_session.commit() # pylint: disable=no-member
+            except OperationalError:
+                if i == max_retries - 1:
+                    raise
+
+
+def clean_old_entries():
+    # pylint: disable=no-member
+    with connecting_to_db() as conn:
+        old_sessions_query = conn.query(SessionMetadata).filter \
+            (SessionMetadata.created_at < datetime.now() - timedelta(days=_MAX_DAYS_SAVED_SESSIONS))
+        old_sessions_ids = [session.session_id for session in old_sessions_query.all()]
+        if old_sessions_ids:
+            conn.query(ResumeState).filter(ResumeState.session_id.in_(old_sessions_ids)).delete(synchronize_session=False)
+        old_sessions_query.delete(synchronize_session=False)
+
+
+def save_resume_state(session_result, collected):
+    session_metadata = SessionMetadata(
+        session_id=session_result.session.id,
+        src_folder=os.path.abspath(os.getcwd()),
+        created_at=datetime.now())
+
+    passed_tests_names = [result.test_metadata for result in session_result.iter_test_results() if result.is_success_finished()]
+    collected_test_names = [test.__slash__ for test in collected]
+    failed_metadata = list(set(collected_test_names) - set(passed_tests_names))
+
+    tests_to_resume = []
+    for metadata in failed_metadata:
+        test_to_resume = ResumeState(session_id=session_result.session.id, file_name=metadata.file_path, function_name=metadata.function_name)
+        if metadata.variation:
+            test_to_resume.variation = str(metadata.variation.id)
+        tests_to_resume.append(test_to_resume)
+
+    with connecting_to_db() as conn:
+        conn.add(session_metadata) # pylint: disable=no-member
+        conn.add_all(tests_to_resume) # pylint: disable=no-member
+    _logger.debug('Saved resume state to DB')
+
+
+def get_last_resumeable_session_id():
+    current_folder = os.path.abspath(os.getcwd())
+    with connecting_to_db() as conn:
+         # pylint: disable=no-member
+        session_id = conn.query(SessionMetadata).filter(SessionMetadata.src_folder == current_folder) \
+                                                .order_by(SessionMetadata.created_at.desc()).first()
+        if not session_id:
+            raise CannotResume("No sessions found for folder {0}".format(current_folder))
+        return session_id.session_id
+
+
+def get_tests_to_resume(session_id):
+    returned = []
+    with connecting_to_db() as conn:
+         # pylint: disable=no-member
+        session_metadata = conn.query(SessionMetadata).filter(SessionMetadata.session_id == session_id).first()
+        if session_metadata:
+            session_tests = conn.query(ResumeState).filter(ResumeState.session_id == session_id).all()
+            if not session_tests:
+                _logger.debug('Found session {0} locally, but no failed tests exist'.format(session_id))
+                return returned
+            for test in session_tests:
+                new_entry = ResumedTestData(test.file_name, test.function_name)
+                if test.variation:
+                    new_entry.variation = literal_eval(test.variation)
+                returned.append(new_entry)
+    if not returned:
+        _logger.debug('No local entry for session {0}, searching remote session'.format(session_id))
+        returned = resume_remote_session(session_id)
+    return returned
+
+
+def resume_remote_session(session_id):
+    active_plugins = manager.get_active_plugins()
+    backslash_plugin = active_plugins.get('backslash', None)
+    if not backslash_plugin:
+        raise CannotResume("Could not find backslash plugin")
+    if not hasattr(backslash_plugin, 'is_session_exist') or not hasattr(backslash_plugin, 'get_tests_to_resume'):
+        raise CannotResume("Backslash plugin doesn't support remote resuming")
+    if not backslash_plugin.is_session_exist(session_id):
+        raise CannotResume("Could not find resume data for session {0}".format(session_id))
+    remote_tests = backslash_plugin.get_tests_to_resume(session_id)
+    returned = [ResumedTestData(test.info['file_name'], test.info['name'], test.variation) for test in remote_tests]
+    return returned
+
+
+class CannotResume(Exception):
+    pass
diff --git a/slash/runner.py b/slash/runner.py
new file mode 100755
index 0000000000..073af0c25f
--- /dev/null
+++ b/slash/runner.py
@@ -0,0 +1,237 @@
+from contextlib import contextmanager
+
+import logbook
+
+from . import hooks
+from . import log
+from ._compat import ExitStack
+from .conf import config
+from .ctx import context
+from .exception_handling import handling_exceptions
+from .exceptions import NoActiveSession
+from .core.function_test import FunctionTest
+from .core.metadata import ensure_test_metadata
+from .core.exclusions import is_excluded
+from .core import requirements
+from .utils.iteration import PeekableIterator
+
+
+_logger = logbook.Logger(__name__)
+log.set_log_color(_logger.name, logbook.NOTICE, 'blue')
+
+
+def run_tests(iterable, stop_on_error=None):
+    """
+    Runs tests from an iterable using the current session
+    """
+    # pylint: disable=maybe-no-member
+    def should_stop_on_error():
+        if stop_on_error is None:
+            return config.root.run.stop_on_error
+        return stop_on_error
+
+    if context.session is None or not context.session.started:
+        raise NoActiveSession("A session is not currently started")
+
+    test_iterator = PeekableIterator(iterable)
+    last_filename = None
+    complete = False
+    try:
+        for test in test_iterator:
+            if config.root.run.dump_variation:
+                _dump_variation(test)
+            _set_test_metadata(test)
+            test_filename = test.__slash__.file_path
+            if last_filename != test_filename:
+                context.session.reporter.report_file_start(test_filename)
+                last_filename = test_filename
+            context.session.reporter.report_test_start(test)
+            _logger.notice("#{}: {}", test.__slash__.test_index1, test.__slash__.address, extra={'highlights': 1})
+
+            _run_single_test(test, test_iterator)
+
+
+            result = context.session.results[test]
+            context.session.reporter.report_test_end(test, result)
+            if not test_iterator.has_next() or ensure_test_metadata(test_iterator.peek()).file_path != last_filename:
+                context.session.reporter.report_file_end(last_filename)
+            if result.has_fatal_exception():
+                _logger.debug("Stopping on fatal exception")
+                break
+            if should_stop_on_error() and not context.session.results.is_success(allow_skips=True):
+                _logger.debug("Stopping (run.stop_on_error==True)")
+                break
+        else:
+            complete = True
+    finally:
+        if config.root.parallel.worker_id is None:
+            context.session.scope_manager.flush_remaining_scopes()
+
+    if config.root.parallel.worker_id is None:
+        _mark_unrun_tests(test_iterator)
+        if complete:
+            context.session.mark_complete()
+        elif last_filename is not None:
+            context.session.reporter.report_file_end(last_filename)
+        _logger.trace('Session finished. is_success={0} has_skips={1}',
+                  context.session.results.is_success(allow_skips=True), bool(context.session.results.get_num_skipped()))
+
+
+def _dump_variation(test):
+    _logger.trace('Variation information:\n{}',
+                  '\n'.join('\t{}: {!r}'.format(k, v) for k, v in sorted(test.get_variation().id.items())))
+
+
+def _run_single_test(test, test_iterator):
+    next_test = test_iterator.peek_or_none()
+    with ExitStack() as exit_stack:
+
+        # sets the current result, test id etc.
+        result = exit_stack.enter_context(_get_test_context(test))
+
+        with handling_exceptions():
+
+
+            should_run = _process_requirements_and_exclusions(test)
+            if not should_run:
+                return
+
+            result.mark_started()
+            with TestStartEndController(result) as controller:
+                try:
+                    try:
+                        with handling_exceptions(swallow=True):
+                            context.session.scope_manager.begin_test(test)
+                            try:
+                                controller.start()
+                                with handling_exceptions(swallow=True):
+                                    test.run()
+                            finally:
+                                context.session.scope_manager.end_test(test)
+                    except context.session.get_skip_exception_types():
+                        pass
+
+                    _fire_test_summary_hooks(test, result)
+                    if next_test is None and config.root.parallel.worker_id is None:
+                        controller.end()
+
+                        with handling_exceptions(swallow=True):
+                            context.session.scope_manager.flush_remaining_scopes()
+
+                except context.session.get_skip_exception_types():
+                    pass
+
+def _process_requirements_and_exclusions(test):
+    """Returns whether or not a test should run based on requirements and exclusions, also triggers skips and relevant hooks
+    """
+    unmet_reqs = test.get_unmet_requirements()
+    if not unmet_reqs:
+        return _process_exclusions(test)
+
+
+    messages = set()
+    for req, message in unmet_reqs:
+        if isinstance(req, requirements.Skip):
+            context.result.add_skip(req.reason)
+            msg = 'Skipped' if not req.reason else req.reason
+        else:
+            msg = 'Unmet requirement: {}'.format(message or req)
+            context.result.add_skip(msg)
+        messages.add(msg)
+
+    hooks.test_avoided(reason=', '.join(messages)) # pylint: disable=no-member
+    return False
+
+def _process_exclusions(test):
+    if is_excluded(test):
+        context.result.add_skip('Excluded')
+        hooks.test_avoided(reason='Excluded') # pylint: disable=no-member
+        return False
+    return True
+
+
+class TestStartEndController(object):
+
+    def __init__(self, result):
+        self._result = result
+        self._started = False
+
+    def __enter__(self):
+        return self
+
+    def start(self):
+        if not self._started:
+            self._started = True
+            self._result.mark_started()
+            hooks.test_start() # pylint: disable=no-member
+
+    def end(self):
+        if self._started:
+            self._started = False
+            with context.session.cleanups.forbid_implicit_scoping_context():
+                hooks.test_end() # pylint: disable=no-member
+            self._result.mark_finished()
+
+    def __exit__(self, *args):
+        self.end()
+
+
+def _fire_test_summary_hooks(test, result): # pylint: disable=unused-argument
+    with handling_exceptions():
+        if result.is_just_failure():
+            hooks.test_failure()  # pylint: disable=no-member
+        elif result.is_skip():
+            hooks.test_skip(reason=result.get_skips()[0]) # pylint: disable=no-member
+        elif result.is_success():
+            hooks.test_success()  # pylint: disable=no-member
+        else:
+            _logger.debug('Firing test_error hook for {0} (result: {1})', test, result)
+            hooks.test_error()  # pylint: disable=no-member
+
+
+def _set_test_metadata(test):
+    ensure_test_metadata(test)
+    assert test.__slash__.test_index0 is None
+    test.__slash__.test_index0 = next(context.session.test_index_counter) if config.root.parallel.worker_id is None \
+                                 else context.session.current_parallel_test_index
+
+
+def _mark_unrun_tests(test_iterator):
+    remaining = list(test_iterator)
+    for test in remaining:
+        with _get_test_context(test, logging=False):
+            pass
+
+@contextmanager
+def _get_test_context(test, logging=True):
+    ensure_test_metadata(test)
+
+    with _set_current_test_context(test):
+        result = context.session.results.create_result(test)
+        prev_result = context.result
+        context.result = result
+        try:
+            with (context.session.logging.get_test_logging_context() if logging else ExitStack()):
+                _logger.debug("Started test #{0.__slash__.test_index1}: {0}", test)
+                yield result
+        finally:
+            context.result = prev_result
+
+@contextmanager
+def _set_current_test_context(test):
+    prev_test = context.test
+    prev_test_id = context.test_id
+    context.test = test
+    context.test_id = test.__slash__.id
+    if isinstance(test, FunctionTest):
+        context.test_classname = None
+        context.test_methodname = test.__slash__.factory_name
+    else:
+        context.test_classname = test.__slash__.factory_name
+        # this includes a dot (.), so it has to be truncated
+        context.test_methodname = test.__slash__.address_in_factory[1:]
+    try:
+        yield
+    finally:
+        context.test = prev_test
+        context.test_id = prev_test_id
diff --git a/slash/site.py b/slash/site.py
new file mode 100755
index 0000000000..c4a1165192
--- /dev/null
+++ b/slash/site.py
@@ -0,0 +1,73 @@
+import os
+import sys
+
+import requests
+
+from .conf import config
+
+def load(thing=None, working_directory=None):
+    """
+    Loads site files (customization files) from various locations.
+
+    Without an argument, loads all default site customization options.
+
+    With a specific argument, load that argument as a customization file (real file or URL).
+    """
+    if thing is None:
+        return _load_defaults(working_directory=working_directory)
+    _load_filename_or_url(thing)
+
+def _load_defaults(working_directory=None):
+    _load_slashrc()
+    _load_local_slashrc(working_directory=working_directory)
+    _load_environment()
+    _load_entry_points()
+
+def _load_slashrc():
+    user_customization_file = os.environ.get("SLASH_USER_SETTINGS", os.path.expanduser(config.root.run.user_customization_file_path))
+    _load_file_if_exists(user_customization_file)
+
+def _load_local_slashrc(working_directory=None):
+    path = os.path.expanduser(config.root.run.project_customization_file_path)
+    if not os.path.isabs(path) and working_directory is not None:
+        path = os.path.join(working_directory, path)
+    _load_file_if_exists(os.path.abspath(path))
+
+def _load_file_if_exists(path):
+    if os.path.isfile(path):
+        old_sys_path = sys.path[:]
+        sys.path.insert(0, os.path.dirname(path))
+        try:
+            _load_filename(path)
+        finally:
+            sys.path[:] = old_sys_path
+
+def _load_environment():
+    loaded_url_or_file = os.environ.get("SLASH_SETTINGS")
+    if loaded_url_or_file:
+        load(loaded_url_or_file)
+
+def _load_entry_points():
+    import pkg_resources
+    for customize_function_loader in pkg_resources.iter_entry_points("slash.site.customize"): # pylint: disable=no-member
+        func = customize_function_loader.load()
+        func()
+
+def _load_filename_or_url(filename_or_url):
+    if os.path.isfile(filename_or_url):
+        _load_filename(filename_or_url)
+    else:
+        _load_url(filename_or_url)
+
+def _load_filename(filename):
+    with open(filename, "r") as f:
+        _load_source(f.read(), filename)
+
+def _load_url(url):
+    response = requests.get(url)
+    response.raise_for_status()
+    _load_source(response.content, url)
+
+def _load_source(source, filename):
+    code = compile(source, os.path.abspath(filename), 'exec')
+    exec(code, {"__file__" : filename}) # pylint: disable=W0122
diff --git a/slash/utils/__init__.py b/slash/utils/__init__.py
new file mode 100755
index 0000000000..2d0be59b7b
--- /dev/null
+++ b/slash/utils/__init__.py
@@ -0,0 +1,76 @@
+import functools
+
+from ..ctx import context
+from ..core.markers import repeat_marker
+from ..core import requirements
+from ..exceptions import SkipTest
+
+
+def skip_test(*args):
+    """
+    Skips the current test execution by raising a :class:`slash.exceptions.SkipTest`
+    exception. It can optionally receive a reason argument.
+    """
+    raise SkipTest(*args)
+
+def repeat(num_repetitions):
+    """
+    Marks a test to be repeated multiple times when run
+    """
+    return repeat_marker(num_repetitions)
+
+
+def skipped(thing, reason=None):
+    """
+    A decorator for skipping methods and classes
+    """
+    if isinstance(thing, str):
+        return functools.partial(skipped, reason=thing)
+
+    return requirements.requires(requirements.Skip(reason))(thing)
+
+def register_skip_exception(exception_type):
+    """
+    Registers a custom exception type to be recognized a test skip. This makes the exception
+    behave just as if the test called ``skip_test``
+
+    .. note:: this must be called within an active session
+    """
+    context.session.register_skip_exception(exception_type)
+
+
+def add_error(msg=None, frame_correction=0, exc_info=None):
+    """
+    Adds an error to the current test result
+
+    :param msg: can be either an object or a string representing a message
+    :param frame_correction: when delegating add_error from another function, specifies
+      the amount of frames to skip to reach the actual cause of the added error
+    :param exc_info: (optional) - the exc_info tuple of the exception being recorded
+    """
+    if context.session is not None:
+        return context.session.results.current.add_error(msg, frame_correction=frame_correction+1, exc_info=exc_info)
+
+
+def add_failure(msg=None, frame_correction=0, exc_info=None):
+    """
+    Adds a failure to the current test result
+
+    :param msg: can be either an object or a string representing a message
+    :param frame_correction: when delegating add_failure from another function, specifies
+      the amount of frames to skip to reach the actual cause of the added failure
+    """
+    if context.session is not None:
+        return context.session.results.current.add_failure(msg, frame_correction=frame_correction+1, exc_info=exc_info)
+
+
+def set_test_detail(key, value):
+    """
+    Store an object providing additional information about the current running test in a certain key.
+    Each test has its own storage.
+
+    :param key: a hashable object
+    :param value: can be either an object or a string representing additional details
+    """
+    if context.session is not None:
+        context.session.results.current.set_test_detail(key, value)
diff --git a/slash/utils/cli_utils.py b/slash/utils/cli_utils.py
new file mode 100755
index 0000000000..ad2f4b0474
--- /dev/null
+++ b/slash/utils/cli_utils.py
@@ -0,0 +1,171 @@
+from __future__ import print_function
+import argparse
+import os
+import sys
+from contextlib import contextmanager
+
+import colorama
+
+from .. import conf, plugins
+from .._compat import itervalues
+
+
+_PLUGIN_ACTIVATION_PREFIX = "--with-"
+_PLUGIN_DEACTIVATION_PREFIX = "--without-"
+
+def add_pending_plugins_from_commandline(argv):
+    returned_argv = []
+    for arg in argv:
+        if arg.startswith(_PLUGIN_DEACTIVATION_PREFIX):
+            plugin_name = arg[len(_PLUGIN_DEACTIVATION_PREFIX):]
+            plugins.manager.deactivate_later(plugin_name)
+        elif arg.startswith(_PLUGIN_ACTIVATION_PREFIX):
+            plugin_name = arg[len(_PLUGIN_ACTIVATION_PREFIX):]
+            plugins.manager.activate_later(plugin_name)
+        else:
+            returned_argv.append(arg)
+    return returned_argv
+
+def configure_arg_parser_by_plugins(parser):
+    for plugin in itervalues(plugins.manager.get_installed_plugins()):
+        group = parser.add_argument_group('Options for {}{}'.format(
+            '' if plugins.manager.is_internal_plugin(plugin) else '--with-',
+            plugin.get_name()))
+        plugin.configure_argument_parser(group)
+
+def configure_arg_parser_by_config(parser, config=None):
+    if config is None:
+        config = conf.config
+
+    plugin_groups = {}
+
+    parser.add_argument(
+        "-o", dest="config_overrides", metavar="PATH=VALUE", action="append",
+        default=[],
+        help="Provide overrides for configuration"
+    )
+    for path, node, cmdline in _iter_cmdline_config(config):
+        if path.startswith('plugin_config.'):
+            plugin_name = path.split('.')[1]
+            subparser = plugin_groups.get(plugin_name)
+            if subparser is None:
+                subparser = plugin_groups[plugin_name] = parser.add_argument_group(
+                    'options for the {0} plugin (--with-{0})'.format(plugin_name))
+        else:
+            subparser = parser
+        cmdline.configure_parser(subparser, path, node)
+
+def configure_plugins_from_args(args):
+    for plugin in itervalues(plugins.manager.get_active_plugins()):
+        plugin.configure_from_parsed_args(args)
+
+def _iter_cmdline_config(config):
+    for path, cfg in config.traverse_leaves():
+        cmdline = (cfg.metadata or {}).get("cmdline")
+        if cmdline is None:
+            continue
+        yield path, cfg, cmdline
+
+@contextmanager
+def get_modified_configuration_from_args_context(parser, args, config=None):
+    if config is None:
+        config = conf.config
+    to_restore = []
+    try:
+        for path, cfg, cmdline in _iter_cmdline_config(config):
+            old_value = cfg.get_value()
+            new_value = cmdline.update_value(old_value, args)
+            if new_value != old_value:
+                to_restore.append((path, cfg.get_value()))
+                config.assign_path(path, new_value, deduce_type=True, default_type=str)
+        for override in args.config_overrides:
+            if "=" not in override:
+                parser.error("Invalid config override: {0}".format(override))
+            path, _ = override.split("=", 1)
+            to_restore.append((path, config.get_path(path)))
+            try:
+                config.assign_path_expression(override, deduce_type=True, default_type=str)
+            except ValueError:
+                parser.error("Invalid value for config override: {0}".format(override))
+        yield
+    finally:
+        for path, prev_value in reversed(to_restore):
+            config.assign_path(path, prev_value)
+
+class SlashArgumentParser(argparse.ArgumentParser):
+
+    def __init__(self, *args, **kwargs):
+        super(SlashArgumentParser, self).__init__(
+            prog=self._deduce_program_name(),
+            usage='{} [options]'.format(self._deduce_program_name()),
+            *args, **kwargs)
+
+        self._positionals_metavar = None
+
+    def _deduce_program_name(self):
+        returned = os.path.basename(sys.argv[0])
+        if len(sys.argv) > 1:
+            returned += " {}".format(sys.argv[1])
+        return returned
+
+    def set_positional_metavar(self, metavar, plural=True):
+        self._positionals_metavar = metavar
+        if plural:
+            self.usage += ' {0} [{0} [...]]'.format(metavar)
+        else:
+            self.usage += ' {}'.format(metavar)
+
+    def set_description(self, description):
+        self.description = description
+
+
+COLOR_RESET = colorama.Fore.RESET + colorama.Back.RESET + colorama.Style.RESET_ALL  # pylint: disable=no-member
+
+
+class ColorizedString(str):
+
+    def __new__(cls, *args, **kwargs):
+        style = kwargs.pop('style', None)
+        returned = str.__new__(cls, *args, **kwargs)
+        returned.style = style
+        return returned
+
+    def colorize(self):
+        if self.style:
+            return '{}{}{}'.format(self.style, self, COLOR_RESET)
+        return str(self)
+
+def make_styler(style):
+    return lambda string: ColorizedString(string, style=style)
+
+UNDERLINED = '\x1b[4m'
+
+
+class Printer(object):
+
+    def __init__(self, report_stread, enable_output=True, force_color=False, enable_color=True):
+        self._stream = report_stread
+        self._output_enabled = enable_output
+        self._force_color = force_color
+        self._color_enabled = enable_color
+
+    def _colored_print(self, *args, **print_kwargs):
+        self._print(*(getattr(arg, 'colorize', arg.__str__)() for arg in args), **print_kwargs)
+
+    def _print(self, *args, **print_kwargs):
+        print(*args, file=self._stream, **print_kwargs)
+
+    def __call__(self, *args, **print_kwargs):
+        if self._output_enabled:
+            should_color = self._force_color or (self._color_enabled and self._stream.isatty())
+            print_func = self._colored_print if should_color else self._print
+            print_func(*args, **print_kwargs)
+
+
+def error_abort(message, *args, **kwargs):
+    stream = kwargs.pop('stream', sys.stderr)
+    assert not kwargs
+    if args:
+        message = message.format(*args)
+    print(message, file=stream)
+    sys.exit(-1)
diff --git a/slash/utils/color_string.py b/slash/utils/color_string.py
new file mode 100755
index 0000000000..6bd21065e9
--- /dev/null
+++ b/slash/utils/color_string.py
@@ -0,0 +1,59 @@
+import colorama
+import functools
+
+class ColorStringBase(object):
+
+    def get_colored(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def __repr__(self):
+        return repr(str(self))
+
+    def __add__(self, other):
+        return ColorCompoundString(self, other)
+
+    def __radd__(self, other):
+        return ColorCompoundString(other, self)
+
+class ColorString(ColorStringBase):
+    def __init__(self, string, color):
+        super(ColorString, self).__init__()
+        self._string = string
+        self._color = color
+
+    def __len__(self):
+        return len(self._string)
+
+    def ljust(self, *args):
+        return ColorString(self._string.ljust(*args), self._color)
+
+    @classmethod
+    def get_formatter(cls, color):
+        return functools.partial(cls, color=color)
+
+    def __mod__(self, values):
+        return ColorString(self._string % values, self._color)
+
+    def __str__(self):
+        return str(self._string)
+
+    def get_colored(self):
+        return "{0}{1}{2}".format(getattr(colorama.Fore, self._color.upper()), self._string, colorama.Fore.RESET) # pylint: disable=no-member
+
+class ColorCompoundString(ColorStringBase):
+
+    def __init__(self, *strings):
+        super(ColorCompoundString, self).__init__()
+        self._strings = strings
+
+    def __str__(self):
+        return ''.join(str(x) for x in  self._strings)
+
+    def __len__(self):
+        return sum(len(s) for s in self._strings)
+
+    def ljust(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def get_colored(self):
+        return ''.join(s.get_colored() if isinstance(s, ColorStringBase) else s for s in self._strings)
diff --git a/slash/utils/conf_utils.py b/slash/utils/conf_utils.py
new file mode 100755
index 0000000000..3c30a1c1ee
--- /dev/null
+++ b/slash/utils/conf_utils.py
@@ -0,0 +1,91 @@
+import itertools
+from confetti import Metadata
+
+_dest_generator = ("dest_{0}".format(i) for i in itertools.count())
+
+# for use with callbacks
+def _set_true(_):
+    return True
+
+def _set_false(_):
+    return False
+
+def _increase(value):
+    return value + 1
+
+def _decrease(value):
+    return value - 1
+
+class _Cmdline(object):
+    def __init__(self, arg=None, on=None, off=None, increase=None, decrease=None, metavar="PARAM", required=False, append=None,
+                 increase_doc=None, decrease_doc=None):
+        super(_Cmdline, self).__init__()
+        dest = next(_dest_generator)
+        self.callback_dest = dest + ":callbacks"
+        self.arg_dest = dest + ":arg"
+        self.arg = arg
+        self.on = on
+        self.off = off
+        self.required = required
+        self.increase = increase
+        self.decrease = decrease
+        self.increase_doc = increase_doc
+        self.decrease_doc = decrease_doc
+        self.metavar = metavar
+        self.append = append
+
+    def configure_parser(self, parser, path, node):
+        """
+        Add all required flags to a parser to support updating the config value from commandline
+        """
+        description = node.metadata.get('doc', '(Config: {})'.format(path))
+        if self.arg is not None:
+            parser.add_argument(self.arg,
+                                dest=self.arg_dest,
+                                metavar=self.metavar,
+                                default=None,
+                                required=self.required,
+                                help=description)
+        if self.append is not None:
+            parser.add_argument(self.append,
+                                dest=self.arg_dest,
+                                action="append",
+                                metavar=self.metavar,
+                                default=None,
+                                help=description)
+
+        self._add_arg(parser, self.on, callback=_set_true,
+                      description="Turn on " + description)
+        self._add_arg(parser, self.off, callback=_set_false,
+                      description="Turn off " + description)
+        self._add_arg(parser, self.increase, callback=_increase,
+                      description=self.increase_doc or ("Increase " + description))
+        self._add_arg(parser, self.decrease, callback=_decrease,
+                      description=self.decrease_doc or ("Decrease " + description))
+
+    def _add_arg(self, parser, flag, callback, description):
+        if flag is None:
+            return
+        parser.add_argument(flag, dest=self.callback_dest, action="append_const", const=callback, help=description)
+
+    def update_value(self, value, args):
+        """
+        given a previous configuration value and the parsed args, return the new value
+        """
+        arg_value = getattr(args, self.arg_dest, None)
+        if arg_value is not None:
+            if self.append:
+                value = list(value) + (arg_value or [])
+            else:
+                value = arg_value
+        callbacks = getattr(args, self.callback_dest, None)
+        if callbacks:
+            for callback in callbacks:
+                value = callback(value)
+        return value
+
+def Cmdline(**kwargs):
+    return Metadata(cmdline=_Cmdline(**kwargs))
+
+def Doc(msg):
+    return Metadata(doc=msg)
diff --git a/slash/utils/debug.py b/slash/utils/debug.py
new file mode 100755
index 0000000000..fb1bb5ad3d
--- /dev/null
+++ b/slash/utils/debug.py
@@ -0,0 +1,90 @@
+from __future__ import print_function
+
+import sys
+import traceback
+
+from .. import hooks as trigger_hook
+from ..conf import config
+from ..ctx import context
+from .. import exceptions
+
+import warnings
+
+
+def _debugger(debug_function_str, exc_info_transform=None, name=None):  # pragma: no cover
+    module_name, function_name = debug_function_str.rsplit(".", 1)
+    def debugger(exc_info):
+        try:
+            module = __import__(module_name, fromlist=[''])
+        except ImportError:
+            raise NotImplementedError() # pragma: no cover
+        func = getattr(module, function_name)
+        orig_exc_info = exc_info
+        if exc_info_transform is not None:
+            exc_info = exc_info_transform(exc_info)
+        _notify_going_into_debugger(orig_exc_info)
+        func(*exc_info)
+    debugger.__name__ = debug_function_str
+    debugger.__external_name__ = name
+    return debugger
+
+def _notify_going_into_debugger(exc_info):
+    if context.session is not None:
+        context.session.reporter.report_before_debugger(exc_info)
+    else:
+        print('\nException caught in debugger: {0}'.format(traceback.format_exception_only(exc_info[0], exc_info[1])[0].strip()))
+
+def _only_tb(exc_info):  # pragma: no cover
+    return (exc_info[2],)
+
+def _tb_type_value(exc_info):  # pragma: no cover
+    return (exc_info[2], exc_info[0], exc_info[1])
+
+_KNOWN_DEBUGGERS = [
+    # order is important here!
+    _debugger("pudb.post_mortem", _tb_type_value, name='pudb'),
+    _debugger("ipdb.post_mortem", _only_tb, name='ipdb'),
+    _debugger("pdb.post_mortem", _only_tb, name='pdb'),
+    ]
+
+
+def debug_if_needed(exc_info=None):
+
+    if not config.root.debug.enabled:
+        return
+    if exc_info is None:
+        exc_info = sys.exc_info()
+    if exc_info[0] is None:
+        return
+    if isinstance(exc_info[1], context.session.get_skip_exception_types()) and not config.root.debug.debug_skips:
+        return
+    if isinstance(exc_info[1], (SystemExit,) + exceptions.INTERRUPTION_EXCEPTIONS):
+        return
+
+    launch_debugger(exc_info)
+
+def launch_debugger(exc_info):
+    trigger_hook.entering_debugger(exc_info=exc_info) # pylint: disable=no-member
+
+    debugger_name = config.root.debug.debugger
+
+    debuggers = list(_KNOWN_DEBUGGERS)
+    if debugger_name is not None:
+        for index, debugger in enumerate(debuggers):
+            if debugger_name == debugger.__external_name__:
+                debuggers.insert(0, debuggers.pop(index))
+                break
+        else:
+            warnings.warn('Specified debugger {!r} is not a known debugger name'.format(debugger_name))
+
+    for debug_func in debuggers:
+        try:
+            debug_func(exc_info)
+        except NotImplementedError:   # pragma: no cover
+            if debug_func.__external_name__ == debugger_name:
+                warnings.warn('Specified debugger {!r} is not available'.format(debugger_name))
+            continue
+        else:
+            break
+    else:
+        raise NotImplementedError("No debug function available")  # pragma: no cover
diff --git a/slash/utils/exception_mark.py b/slash/utils/exception_mark.py
new file mode 100755
index 0000000000..e61ff88569
--- /dev/null
+++ b/slash/utils/exception_mark.py
@@ -0,0 +1,41 @@
+import copy
+
+
+def mark_exception(e, name, value):
+    """
+    Associates a mark with a given value to the exception ``e``
+    """
+    _ensure_exception_marks(e)[name] = value
+
+
+def get_exception_mark(e, name, default=None):
+    """
+    Given an exception and a label name, get the value associated with that mark label.
+    If the label does not exist on the specified exception, ``default`` is returned.
+    """
+    return _ensure_exception_marks(e).get(name, default)
+
+_EXCEPTION_MARKS_NAME = '__slash_exc_marks__'
+
+def _ensure_exception_marks(e):
+    returned = getattr(e, _EXCEPTION_MARKS_NAME, None)
+    if returned is not None and not isinstance(e, type) and returned is getattr(type(e), _EXCEPTION_MARKS_NAME, None):
+        returned = copy.deepcopy(returned)
+        setattr(e, _EXCEPTION_MARKS_NAME, returned)
+    if returned is None:
+        returned = {}
+        setattr(e, _EXCEPTION_MARKS_NAME, returned)
+    return returned
+
+class ExceptionMarker(object):
+
+    def __init__(self, name):
+        super(ExceptionMarker, self).__init__()
+        self.name = name
+
+    def mark_exception(self, e):
+        mark_exception(e, self.name, True)
+        return e
+
+    def is_exception_marked(self, e):
+        return bool(get_exception_mark(e, self.name, False))
diff --git a/slash/utils/formatter.py b/slash/utils/formatter.py
new file mode 100755
index 0000000000..c9ef20bd5f
--- /dev/null
+++ b/slash/utils/formatter.py
@@ -0,0 +1,82 @@
+from __future__ import print_function
+from contextlib import contextmanager
+import errno
+
+from .color_string import ColorString
+
+
+class Formatter(object):
+
+    def __init__(self, stream, indentation_string=" "):
+        super(Formatter, self).__init__()
+        self._indentation_string = indentation_string
+        self._indentation_list = []
+        self._indentation = ""
+        self._stream = LineTracker(stream)
+        self._isatty = stream.isatty()
+
+    def write_separator(self, length=80):
+        self.writeln("-" * length)
+
+    def writeln(self, *args, **kwargs):
+        self.write(end="\n", *args, **kwargs)
+
+    def write(self, *args, **kwargs):
+        try:
+            end = kwargs.pop('end', '')
+            for arg in args:
+                if isinstance(arg, ColorString):
+                    if self._isatty:
+                        arg = arg.get_colored()
+                    else:
+                        arg = str(arg)
+                lines = str(arg).splitlines()
+                for index, line in enumerate(lines):
+                    if self._stream.is_line_empty():
+                        self._stream.write(self._indentation)
+                    self._stream.write(line)
+                    if index != len(lines) - 1:
+                        self._stream.write("\n")
+            self._stream.write(end)
+        except IOError as e:
+            if e.errno not in (errno.EIO, errno.EPIPE):
+                raise
+
+    def indent(self):
+        self._indent(1)
+
+    def dedent(self):
+        self._indent(-1)
+
+    def _indent(self, increment, string=None):
+        if string is None:
+            string = self._indentation_string
+        if increment < 0:
+            del self._indentation_list[increment:]
+        else:
+            self._indentation_list.extend(string for x in range(increment))
+        self._indentation = ''.join(self._indentation_list)
+
+    @contextmanager
+    def indented(self, increment=1, string=None):
+        self._indent(increment=increment, string=string)
+        try:
+            yield
+        finally:
+            self._indent(increment=-increment)
+
+
+class LineTracker(object):
+
+    def __init__(self, stream):
+        super(LineTracker, self).__init__()
+        self._stream = stream
+        self._empty_line = True
+
+    def write(self, output):
+        self._stream.write(output)
+        if output:
+            self._empty_line = output.endswith('\n')
+
+    def is_line_empty(self):
+        return self._empty_line
diff --git a/slash/utils/function_marker.py b/slash/utils/function_marker.py
new file mode 100755
index 0000000000..1020bfe6ed
--- /dev/null
+++ b/slash/utils/function_marker.py
@@ -0,0 +1,48 @@
+from sentinels import NOTHING
+
+from .._compat import get_underlying_classmethod_function
+
+
+def function_marker(name):
+    return Marker(name)
+
+def append_function_marker(name):
+    return Marker(name, append=True)
+
+class Marker(object):
+
+    def __init__(self, name, value=True, append=False):
+        super(Marker, self).__init__()
+        self._name = name
+        self._value = value
+        self._mark = '__marked_{0}__'.format(self._name)
+        self._append = append
+
+    def __call__(self, func):
+        if not hasattr(func, '__call__') and not isinstance(func, (classmethod, staticmethod)):
+            return Marker(self._name, func, append=self._append)
+
+        func = self._normalize(func)
+
+        if self._append:
+            value = list(getattr(func, self._mark, [])) + [self._value]
+        else:
+            value = self._value
+
+        setattr(func, self._mark, value)
+        return func
+
+    def is_marked(self, func):
+        return hasattr(self._normalize(func), self._mark)
+
+    def get_value(self, func, default=NOTHING):
+        returned = getattr(self._normalize(func), self._mark, default)
+        if returned is NOTHING:
+            raise LookupError()
+        return returned
+
+    @staticmethod
+    def _normalize(func):
+        if isinstance(func, (classmethod, staticmethod)):
+            return get_underlying_classmethod_function(func)
+        return func
diff --git a/slash/utils/id_space.py b/slash/utils/id_space.py
new file mode 100755
index 0000000000..37f77a1b86
--- /dev/null
+++ b/slash/utils/id_space.py
@@ -0,0 +1,12 @@
+import itertools
+
+_ID_SEPARATOR = "_"
+
+class IDSpace(object):
+    def __init__(self, base):
+        super(IDSpace, self).__init__()
+        if not base.endswith(_ID_SEPARATOR):
+            base += _ID_SEPARATOR
+        self._allocator = (base + str(i) for i in itertools.count(1))
+    def allocate(self):
+        return next(self._allocator)
diff --git a/slash/utils/interactive.py b/slash/utils/interactive.py
new file mode 100755
index 0000000000..c8b97a3866
--- /dev/null
+++ b/slash/utils/interactive.py
@@ -0,0 +1,78 @@
+from __future__ import print_function
+
+import threading
+import time
+import datetime
+from contextlib import contextmanager
+from ..ctx import context
+from ..core import metadata
+from ..core.function_test import FunctionTestFactory
+from ..exceptions import TerminatedException
+from ..exception_handling import handle_exception
+
+from IPython.terminal.embed import embed  # pylint: disable=F0401
+
+def _interact(ns):
+    def _handle_exception(shell, exc_type, exc_value, exc_tb, tb_offset):
+        exc_info = (exc_type, exc_value, exc_tb)
+        shell.showtraceback(exc_info, tb_offset)
+        if not _is_exception_in_ipython_eval(exc_tb):
+            handle_exception(exc_info)
+        if isinstance(exc_value, TerminatedException):
+            context.result.add_error('Terminated')
+            shell.exit_now = True
+
+    embed(user_ns=ns, display_banner=False, custom_exceptions=((Exception, TerminatedException), _handle_exception))
+
+
+def _is_exception_in_ipython_eval(exc_tb):
+    while exc_tb.tb_next is not None:
+        exc_tb = exc_tb.tb_next
+    return exc_tb.tb_frame.f_code.co_filename.startswith('<')
+
+def start_interactive_shell(**namespace):
+    """
+    Starts an interactive shell. Uses IPython if available, else fall back
+    to the native Python interpreter.
+
+    Any keyword argument specified will be available in the shell ``globals``.
+    """
+    if context.g is not None:
+        namespace.update(context.g.__dict__)
+
+    _interact(namespace)
+
+def _start_interactive_test():
+    return start_interactive_shell()
+
+def generate_interactive_test():
+    [returned] = FunctionTestFactory(_start_interactive_test).generate_tests(context.session.fixture_store)
+    returned.__slash__ = metadata.Metadata(None, returned)
+    returned.__slash__.allocate_id()
+    returned.__slash__.mark_interactive()
+    return returned
+
+def _humanize_time_delta(seconds):
+    return str(datetime.timedelta(seconds=seconds)).partition('.')[0]
+
+@contextmanager
+def notify_if_slow_context(message, slow_seconds=1, end_message=None, show_duration=True):
+    evt = threading.Event()
+    evt.should_report_end_msg = False
+    def notifier():
+        if not evt.wait(timeout=slow_seconds) and context.session is not None:
+            context.session.reporter.report_message(message)
+            evt.should_report_end_msg = True
+    thread = threading.Thread(target=notifier)
+    start_time = time.time()
+    thread.start()
+
+    try:
+        yield
+    finally:
+        evt.set()
+        thread.join()
+        if evt.should_report_end_msg and end_message is not None:
+            if show_duration:
+                end_message += ' (took {})'.format(_humanize_time_delta(time.time() - start_time))
+            context.session.reporter.report_message(end_message)
diff --git a/slash/utils/iteration.py b/slash/utils/iteration.py
new file mode 100755
index 0000000000..0bb08eec24
--- /dev/null
+++ b/slash/utils/iteration.py
@@ -0,0 +1,88 @@
+import itertools
+
+from .._compat import itervalues
+
+_NOTHING = object()
+_END = object()
+
+
+class PeekableIterator(object):
+
+    """An iterator wrapper which allows peeking into the next element"""
+
+    def __init__(self, iterator):
+        super(PeekableIterator, self).__init__()
+        self._iterator = iter(iterator)
+        self._peeked = _NOTHING
+
+    def __iter__(self):
+        return self
+
+    def next(self):
+        if self._peeked is not _NOTHING:
+            returned = self._peeked
+            self._peeked = _NOTHING
+            if returned is _END:
+                raise StopIteration()
+            return returned
+        return next(self._iterator)
+    __next__ = next
+
+    def peek_or_none(self):
+        if self.has_next():
+            return self.peek()
+        return None
+
+    def peek(self):
+        if self._peeked is _NOTHING:
+            self._peeked = next(self._iterator, _END)
+        if self._peeked is _END:
+            raise StopIteration()
+        return self._peeked
+
+    def has_next(self):
+        try:
+            self.peek()
+        except StopIteration:
+            return False
+        return True
+
+
+def iteration(iterable):
+    try:
+        last_counter0 = len(iterable) - 1
+    except (ValueError, TypeError):
+        last_counter0 = None
+
+    for index, element in enumerate(iterable):
+
+        yield Iteration(element, counter0=index, counter1=index + 1, first=(index == 0), last_counter0=last_counter0)
+
+
+class Iteration(object):
+
+    def __init__(self, element, counter0, counter1, first, last_counter0=None):
+        super(Iteration, self).__init__()
+        self.element = element
+        self.counter0 = counter0
+        self.counter1 = counter1
+        self.first = first
+        self.last_counter0 = last_counter0
+        self.last_counter1 = self.total = None if self.last_counter0 is None else self.last_counter0 + 1
+
+    def __iter__(self):
+        return iter((self, self.element))
+
+    @property
+    def last(self):
+        if self.last_counter0 is None:
+            raise NotImplementedError("Iterator does not support getting size")
+        return self.counter0 == self.last_counter0
+
+
+def iter_cartesian_dicts(d):
+    """Given a dictionary of the form {name: values}, yields dictionaries corresponding to the cartesian
+    product of the values, assigned to their respective names"""
+    keys = list(d)  # save keys order to prevent dictionary order changes
+    for combination in itertools.product(*itervalues(d)):
+        yield dict(zip(keys, combination))
diff --git a/slash/utils/marks.py b/slash/utils/marks.py
new file mode 100755
index 0000000000..caac9c6c6a
--- /dev/null
+++ b/slash/utils/marks.py
@@ -0,0 +1,40 @@
+import functools
+
+
+def mark(name, value, append=False):
+    """Marks an object with a given mark (name/value pair)
+    """
+    return functools.partial(_mark, name=name, value=value, append=append)
+
+def get_marks(obj):
+    returned = _get_marks(obj)
+    if returned is not None:
+        returned = returned.copy()
+    return returned
+
+def try_get_mark(obj, mark_name, default=None):
+    """Tries getting a specific mark by name from an object, returning None if no such mark is found
+    """
+    marks = get_marks(obj)
+    if marks is None:
+        return default
+    return marks.get(mark_name, default)
+
+def _get_marks(obj):
+    return getattr(obj, _MARKS_CONTAINER_ATTR, None)
+
+def _set_marks(obj, marks):
+    setattr(obj, _MARKS_CONTAINER_ATTR, marks)
+    return marks
+
+def _mark(obj, name, value, append):
+    marks = _get_marks(obj)
+    if marks is None:
+        marks = _set_marks(obj, {})
+    if append:
+        marks.setdefault(name, []).append(value)
+    else:
+        marks[name] = value
+    return obj
+
+_MARKS_CONTAINER_ATTR = "__slashmarks__"
diff --git a/slash/utils/operator_information.py b/slash/utils/operator_information.py
new file mode 100755
index 0000000000..9f76ba5ea3
--- /dev/null
+++ b/slash/utils/operator_information.py
@@ -0,0 +1,62 @@
+import operator
+
+## utility operators
+
+def safe_isinstance(a, b):
+    try:
+        return isinstance(a, b)
+    except TypeError:
+        return False
+
+def safe_not_isinstance(a, b):
+    return not safe_isinstance(a, b)
+
+def is_none(x):
+    return x is None
+
+def is_not_none(x):
+    return x is not None
+
+def not_contains(x, y):
+    """
+    Python's operator module does not have a function for the ``not in`` operator. That's a shame.
+    """
+    return y not in x
+
+def is_empty(x):
+    return len(x) == 0
+
+def is_not_empty(x):
+    return not is_empty(x)
+
+### Operator information
+_OPERATORS = {}
+
+def _op(operator_func, operator_token, inverse_func, inverse_token):
+    _OPERATORS[operator_func] = Operator(operator_token, operator_func, inverse_func)
+    _OPERATORS[inverse_func] = Operator(inverse_token, inverse_func, operator_func)
+
+class Operator(object):
+    def __init__(self, template, func, inverse_func):
+        super(Operator, self).__init__()
+        self.template = template
+        self.func = func
+        self.inverse_func = inverse_func
+
+    def __call__(self, *args, **kwargs):
+        return self.func(*args, **kwargs)
+
+    def to_expression(self, *args, **kwargs):
+        return self.template.format(*args, **kwargs)
+
+def get_operator_by_func(operator_func):
+    return _OPERATORS[operator_func]
+
+### operator declarations
+_op(operator.eq, "{0} == {1}", operator.ne, "{0} != {1}")
+_op(safe_isinstance, "{0} is instance of {1}", safe_not_isinstance, "{0} is not instance of {1}")
+_op(is_none, "{0} is None", is_not_none, "{0} is not None")
+_op(operator.is_, "{0} is {1}", operator.is_not, "{0} is not {1}")
+_op(operator.truth, "{0} is not false", operator.not_, "{0} is not true")
+_op(operator.contains, "{1} in {0}", not_contains, "{1} not in {0}")
+_op(is_empty, "{0} is empty", is_not_empty, "{0} is not empty")
diff --git a/slash/utils/path.py b/slash/utils/path.py
new file mode 100755
index 0000000000..9ad1c9fc25
--- /dev/null
+++ b/slash/utils/path.py
@@ -0,0 +1,8 @@
+import os
+
+def ensure_containing_directory(path):
+    ensure_directory(os.path.dirname(path))
+
+def ensure_directory(directory):
+    if not os.path.isdir(directory):
+        os.makedirs(directory)
diff --git a/slash/utils/pattern_matching.py b/slash/utils/pattern_matching.py
new file mode 100755
index 0000000000..8d023b05f7
--- /dev/null
+++ b/slash/utils/pattern_matching.py
@@ -0,0 +1,83 @@
+from pyparsing import infixNotation, opAssoc, Word, alphanums
+
+
+class Include(object):
+
+    def __init__(self, t):
+        super(Include, self).__init__()
+        self.only_tags = False
+        self.pattern = t[0]
+        if self.pattern.startswith('tag:'):
+            self.only_tags = True
+            self.pattern = self.pattern.split(':', 1)[1]
+
+    def matches(self, metadata):
+        if isinstance(metadata, str):
+            return self.pattern in metadata
+
+        if metadata.tags.matches_pattern(self.pattern):
+            return True
+        if self.only_tags:
+            return False
+        return self.pattern in metadata.address
+
+    def __repr__(self):
+        return '<{0}{1}>'.format(self.pattern, ' (only tags)' if self.only_tags else '')
+
+
+class BinaryMatching(object):
+
+    aggregator = None
+
+    def __init__(self, matchers):
+        super(BinaryMatching, self).__init__()
+        self.matchers = matchers
+
+    @classmethod
+    def from_tokens(cls, t):
+        return cls(t[0][0::2])
+
+
+    def matches(self, metadata):
+        return self.aggregator(matcher.matches(metadata) for matcher in self.matchers)  # pylint: disable=not-callable
+
+
+class AndMatching(BinaryMatching):
+    aggregator = all
+
+
+class OrMatching(BinaryMatching):
+    aggregator = any
+
+
+class Exclude(object):
+
+    def __init__(self, t):
+        super(Exclude, self).__init__()
+        self.matcher = t[0][1]
+
+    def matches(self, metadata):
+        return not self.matcher.matches(metadata)
+
+
+matcher = Word(alphanums + '._,-=:/')
+matcher.setParseAction(Include)
+
+boolExpr = infixNotation(matcher, [
+    ("not", 1, opAssoc.RIGHT, Exclude),
+    ("and", 2, opAssoc.LEFT, AndMatching.from_tokens),
+    ("or", 2, opAssoc.LEFT, OrMatching.from_tokens),
+])
+
+
+class Matcher(object):
+
+    def __init__(self, pattern):
+        super(Matcher, self).__init__()
+        self._matcher = boolExpr.parseString(pattern)[0]
+
+    def __repr__(self):
+        return repr(self._matcher)
+
+    def matches(self, metadata):
+        return self._matcher.matches(metadata)
diff --git a/slash/utils/python.py b/slash/utils/python.py
new file mode 100755
index 0000000000..ff945729f1
--- /dev/null
+++ b/slash/utils/python.py
@@ -0,0 +1,107 @@
+from collections import OrderedDict
+import functools
+import warnings
+import inspect
+import sys
+import ast
+import pickle
+
+from sentinels import NOTHING
+
+from .._compat import reraise, PY2, PYPY
+
+def check_duplicate_functions(path):
+    code = None
+    with open(path) as f:
+        code = f.read()
+    with warnings.catch_warnings():
+        warnings.simplefilter('ignore')
+        root = ast.parse(code)
+    func_names = set()
+    duplicates = set()
+    for node in root.body:
+        if isinstance(node, ast.FunctionDef):
+            if node.name in func_names:
+                duplicates.add((path, node.name, node.lineno))
+            else:
+                func_names.add(node.name)
+    return duplicates
+
+
+def wraps(func, preserve=()):
+    def decorator(new_func):
+        returned = functools.wraps(func)(new_func)
+        returned.__wraps__ = func
+        return returned
+    for p in preserve:
+        orig = getattr(func, p, NOTHING)
+        if orig is not NOTHING:
+            setattr(decorator, p, orig)
+    return decorator
+
+def unpickle(thing):
+    if not thing:
+        return thing
+    if PY2:
+        return pickle.loads(thing)
+    else:
+        return pickle.loads(thing.data)
+
+def get_underlying_func(func):
+    while True:
+        underlying = getattr(func, "__wraps__", None)
+        if underlying is None:
+            return func
+        func = underlying
+
+
+def get_argument_names(func):
+    return [arg.name for arg in get_arguments(func)]
+
+
+def get_arguments_dict(func):
+    returned = OrderedDict()
+    for arg in get_arguments(func):
+        returned[arg.name] = arg
+    return returned
+
+
+def get_arguments(func):
+    if PY2 or PYPY:
+        func = get_underlying_func(func)
+        spec = inspect.getargspec(func)  # pylint: disable=deprecated-method
+        returned = [FunctionArgument(name=name) for name in spec.args]
+    else:
+        if getattr(func, '__self__', None) is not None:
+            func = func.__func__ # signature() doesn't work on bound methods
+        returned = [FunctionArgument.from_parameter(p) for name, p in inspect.signature(func).parameters.items()] # pylint: disable=no-member
+
+    if returned and returned[0].name == 'self':
+        returned = returned[1:]
+    return returned
+
+
+class FunctionArgument(object):
+
+    def __init__(self, name, annotation=NOTHING):
+        super(FunctionArgument, self).__init__()
+        self.name = name
+        self.annotation = annotation
+
+    @classmethod
+    def from_parameter(cls, parameter):
+        annotation = parameter.annotation
+        if annotation is parameter.empty:
+            annotation = NOTHING
+        return cls(name=parameter.name, annotation=parameter.annotation)
+
+
+def call_all_raise_first(_funcs, *args, **kwargs):
+    exc_info = None
+    for func in _funcs:
+        try:
+            func(*args, **kwargs)
+        except Exception:  # pylint: disable=broad-except
+            exc_info = sys.exc_info()
+    if exc_info is not None:
+        reraise(*exc_info)
diff --git a/slash/utils/suite_files.py b/slash/utils/suite_files.py
new file mode 100755
index 0000000000..a56957bbae
--- /dev/null
+++ b/slash/utils/suite_files.py
@@ -0,0 +1,58 @@
+import os
+from collections import namedtuple
+
+from . import pattern_matching
+
+SuiteEntry = namedtuple('SuiteEntry', 'path, matcher, repeat')
+
+
+def iter_suite_file_paths(suite_files):
+    for filename in suite_files:
+
+        dirname = os.path.abspath(os.path.dirname(filename))
+        with open(filename) as suite_file:
+            for path in suite_file:
+                path = path.strip()
+                if not path or path.startswith("#"):
+                    continue
+
+                suite_entry = _parse_path_filter_and_repeat(path)
+                path = suite_entry.path
+
+                if not os.path.isabs(path):
+                    path = os.path.abspath(os.path.join(dirname, path))
+
+                if not path.endswith('.py') and '.py:' not in path and not os.path.isdir(path):
+                    for p, other_filter in iter_suite_file_paths([path]):
+                        yield p, _and_matchers(suite_entry.matcher, other_filter)
+                    continue
+
+                for _ in range(suite_entry.repeat):
+                    yield path, suite_entry.matcher
+
+
+def _and_matchers(a, b):
+    if a is None:
+        return b
+    if b is None:
+        return a
+    return pattern_matching.AndMatching([a, b])
+
+
+def _parse_path_filter_and_repeat(line):
+    if '#' not in line:
+        return SuiteEntry(line, None, 1)
+
+    line, remainders = line.split('#', 1)
+    line = line.strip()
+    remainders = remainders.split(',')
+
+    matcher = None
+    repeat = 1
+    for remainder in remainders:
+        remainder = remainder.strip()
+        if remainder.startswith('filter:'):
+            matcher = pattern_matching.Matcher(remainder.split(':', 1)[1])
+        if remainder.startswith('repeat:'):
+            repeat = int(remainder.split(':', 1)[1])
+    return SuiteEntry(line, matcher, repeat)
diff --git a/slash/utils/tmux_utils.py b/slash/utils/tmux_utils.py
new file mode 100755
index 0000000000..a8cb438f6a
--- /dev/null
+++ b/slash/utils/tmux_utils.py
@@ -0,0 +1,71 @@
+import sys
+import os
+import libtmux
+import logbook
+from ..exceptions import TmuxSessionNotExist, TmuxExecutableNotFound
+from ..ctx import context
+
+DEFAULT_SESSION_NAME = 'slash_session'
+TMUX_EXECUTABLE_NAME = 'tmux'
+MASTER_WINDOW_NAME = 'master'
+
+_logger = logbook.Logger(__name__)
+
+def which(program):
+    def is_exe(fpath):
+        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)
+
+    fpath, _ = os.path.split(program)
+    if fpath:
+        if is_exe(program):
+            return program
+    else:
+        for path in os.environ["PATH"].split(os.pathsep):
+            path = path.strip('"')
+            exe_file = os.path.join(path, program)
+            if is_exe(exe_file):
+                return exe_file
+    return None
+
+def is_in_tmux():
+    return os.environ.get('TMUX') is not None
+
+def get_slash_tmux_session(session_name):
+    try:
+        tmux_server = libtmux.Server()
+        return tmux_server.find_where({"session_name":session_name})
+    except libtmux.exc.LibTmuxException:
+        _logger.debug('No tmux server is running')
+        return
+
+def create_new_window(window_name, command):
+    slash_session = get_slash_tmux_session(context.session.id)
+    if not slash_session:
+        raise TmuxSessionNotExist("Slash tmux session not found, can't create new window")
+    return slash_session.new_window(attach=False, window_name=window_name, window_shell=command)
+
+def create_new_pane(command):
+    slash_session = get_slash_tmux_session(context.session.id)
+    if not slash_session:
+        raise TmuxSessionNotExist("Slash tmux session not found, can't create new window")
+    new_pane = slash_session.attached_window.split_window(attach=False)
+    new_pane.send_keys(command)
+    return new_pane
+
+def run_slash_in_tmux(command):
+    tmux_session = get_slash_tmux_session(DEFAULT_SESSION_NAME)
+    if tmux_session:
+        tmux_session.set_option('remain-on-exit', True)
+        libtmux.Server().switch_client(DEFAULT_SESSION_NAME)
+        tmux_session.rename_session(context.session.id)
+    else:
+        path_to_tmux = which(TMUX_EXECUTABLE_NAME)
+        if not path_to_tmux:
+            _logger.error("Tmux executable not found")
+            raise TmuxExecutableNotFound("Tmux executable not found")
+        command = ' '.join([sys.executable, '-m', 'slash.frontend.main', 'run'] + command)
+        tmux_args = [path_to_tmux, 'new-session', '-s', DEFAULT_SESSION_NAME, '-n', MASTER_WINDOW_NAME]
+        if is_in_tmux():
+            tmux_args.append('-Ad')
+        tmux_args.append(command)
+        os.execve(path_to_tmux, tmux_args, dict(os.environ))
diff --git a/slash/utils/traceback_proxy.py b/slash/utils/traceback_proxy.py
new file mode 100755
index 0000000000..b43a81b9b7
--- /dev/null
+++ b/slash/utils/traceback_proxy.py
@@ -0,0 +1,184 @@
+"""
+This module contains the implementation of a traceback.traceback object proxy.
+It is needed in order to make creation and modification of these objects possible,
+which is not supported in Python by default, as they are quite internal types.
+It lets us concatenate and fake tracebacks in case of handling an exception.
+The manipulation of tracebacks is done using ctypes hacks and casting pointers to structs,
+and works only with CPython.
+"""
+
+import sys
+import traceback
+import types
+import ctypes
+import inspect
+
+from .._compat import PY2, PYPY
+
+__all__ = ["create_traceback_proxy"]
+
+if PYPY:
+    def create_traceback_proxy(tb=None, frame_correction=0): # pylint: disable=unused-argument
+        raise NotImplementedError("Tracebacks manipulation is not possible in PyPy")
+
+else:
+    class TracebackProxy(object):
+        """
+        Wraps the builtin traceback.traceback object.
+        Exports exactly the same interface, making these types interchangable
+        """
+
+        if PY2:
+            if hasattr(ctypes.pythonapi, 'Py_InitModule4_64'):
+                _Py_ssize_t = ctypes.c_int64
+            else:
+                _Py_ssize_t = ctypes.c_int
+        else:
+            _Py_ssize_t = ctypes.c_ssize_t
+
+        class _PyObject(ctypes.Structure):
+            pass
+
+        # Python build with "--with-pydebug"
+        if hasattr(sys, 'getobjects'):
+            _PyObject._fields_ = [ # pylint: disable=protected-access
+                ('_ob_next', ctypes.POINTER(_PyObject)),
+                ('_ob_prev', ctypes.POINTER(_PyObject)),
+                ('ob_refcnt', _Py_ssize_t),
+                ('ob_type', ctypes.POINTER(_PyObject))
+            ]
+        else:
+            _PyObject._fields_ = [ # pylint: disable=protected-access
+                ('ob_refcnt', _Py_ssize_t),
+                ('ob_type', ctypes.POINTER(_PyObject))
+            ]
+
+        class _Frame(_PyObject):
+            """
+            Represents a traceback.frame object
+            """
+            pass
+
+        class _Traceback(_PyObject):
+            """
+            Represents a traceback.traceback object
+            """
+            pass
+
+        _Traceback._fields_ = [ # pylint: disable=protected-access
+            ('tb_next', ctypes.POINTER(_Traceback)),
+            ('tb_frame', ctypes.POINTER(_Frame)),
+            ('tb_lasti', ctypes.c_int),
+            ('tb_lineno', ctypes.c_int)
+        ]
+
+        def __init__(self, tb=None, frame=None):
+            assert tb is not None or frame is not None
+            self._tb = TracebackProxy.create_traceback()
+            self._obj = TracebackProxy._Traceback.from_address(id(self._tb)) # pylint: disable=no-member
+            self.tb_next = None
+            if tb:
+                self.tb_frame = tb.tb_frame
+                self.tb_lasti = tb.tb_lasti
+                self.tb_lineno = tb.tb_lineno
+            else:
+                self.tb_frame = frame
+                self.tb_lasti = frame.f_lasti
+                self.tb_lineno = frame.f_lineno
+
+        def print_tb(self):
+            traceback.print_tb(self._tb)
+
+        @property
+        def tb_next(self):
+            return self._tb.tb_next
+
+        @tb_next.setter
+        def tb_next(self, tb):
+            if self._tb.tb_next:
+                old = TracebackProxy._Traceback.from_address(id(self._tb.tb_next)) # pylint: disable=no-member
+                old.ob_refcnt -= 1
+
+            assert tb is None or isinstance(tb, types.TracebackType) or isinstance(tb, TracebackProxy)
+            if tb:
+                obj = TracebackProxy._Traceback.from_address(id(tb)) # pylint: disable=no-member
+                obj.ob_refcnt += 1
+                self._obj.tb_next = ctypes.pointer(obj)
+            else:
+                self._obj.tb_next = ctypes.POINTER(TracebackProxy._Traceback)()
+
+        @property
+        def tb_frame(self):
+            return self._tb.tb_frame
+
+        @tb_frame.setter
+        def tb_frame(self, frame):
+            if self._tb.tb_frame:
+                old = TracebackProxy._Frame.from_address(id(self._tb.tb_frame)) # pylint: disable=no-member
+                old.ob_refcnt -= 1
+            if frame:
+                assert isinstance(frame, types.FrameType)
+                frame = TracebackProxy._Frame.from_address(id(frame)) # pylint: disable=no-member
+                frame.ob_refcnt += 1
+                self._obj.tb_frame = ctypes.pointer(frame)
+            else:
+                self._obj.tb_frame = ctypes.POINTER(TracebackProxy._Frame)()
+
+        @property
+        def tb_lasti(self):
+            return self._tb.tb_lasti
+
+        @tb_lasti.setter
+        def tb_lasti(self, lasti):
+            self._obj.tb_lasti = lasti
+
+        @property
+        def tb_lineno(self):
+            return self._tb.tb_lineno
+
+        @tb_lineno.setter
+        def tb_lineno(self, lineno):
+            self._obj.tb_lineno = lineno
+
+        def __eq__(self, other):
+            return self._tb == other._tb # pylint: disable=protected-access
+
+        def __ne__(self, other):
+            return self._tb != other._tb # pylint: disable=protected-access
+
+        @staticmethod
+        def create_traceback():
+            try:
+                1 / 0
+            except:
+                tb = sys.exc_info()[2]
+            return tb
+
+
+    def create_traceback_proxy(tb=None, frame_correction=0):
+        """
+        Builds a TracebackProxy object, using a given traceback, or current context if None.
+        Returns a tuple with the first and the last tracebacks.
+        Works only on CPython (Both Python 2 and 3 are supported)
+        :param tb: traceback.traceback object to extract frames from
+        :param frame_correction: Specifies the amount of frames to skip
+        """
+        assert frame_correction >= 0
+        if isinstance(tb, types.TracebackType):
+            for i in range(frame_correction + 1): # pylint: disable=unused-variable
+                first = current = TracebackProxy(tb=tb)
+                tb = tb.tb_next
+            while tb:
+                current.tb_next = TracebackProxy(tb=tb)
+                tb = tb.tb_next
+                current = current.tb_next
+        else:
+            frame_correction += 1 # Compensate this call frame
+            frames = [frame_info[0] for frame_info in inspect.stack()[frame_correction:]]
+            frames.reverse()
+            first = current = TracebackProxy(frame=frames[0])
+            for frame in frames[1:]:
+                current.tb_next = TracebackProxy(frame=frame)
+                current = current.tb_next
+
+        return (first, current)
diff --git a/slash/utils/traceback_utils.py b/slash/utils/traceback_utils.py
new file mode 100755
index 0000000000..a2c2d75a2e
--- /dev/null
+++ b/slash/utils/traceback_utils.py
@@ -0,0 +1,178 @@
+from __future__ import absolute_import
+
+import inspect
+import linecache
+import os
+import sys
+import traceback
+import types
+
+from .._compat import PY2
+from .. import context
+from .python import get_underlying_func
+
+
+_MAX_VARIABLE_VALUE_LENGTH = 100
+
+_FILTERED_MEMBER_TYPES = [types.MethodType, types.FunctionType, type]
+if PY2:
+    _FILTERED_MEMBER_TYPES.append(types.UnboundMethodType) # pylint: disable=no-member
+    _FILTERED_MEMBER_TYPES.append(types.ClassType) # pylint: disable=no-member
+_FILTERED_MEMBER_TYPES = tuple(_FILTERED_MEMBER_TYPES)
+
+_ALLOWED_ATTRIBUTE_TYPES = [int, str, float]
+if PY2:
+    _ALLOWED_ATTRIBUTE_TYPES.append(long) # pylint: disable=undefined-variable
+_ALLOWED_ATTRIBUTE_TYPES = tuple(_ALLOWED_ATTRIBUTE_TYPES)
+
+
+def get_traceback_string(exc_info=None):
+    if exc_info is None:
+        exc_info = sys.exc_info()
+    exc_type, exc_value, exc_tb = exc_info  # pylint: disable=unpacking-non-sequence
+    return "".join(traceback.format_exception(exc_type, exc_value, exc_tb))
+
+
+def distill_traceback(tb, **kw):
+    return _distill_frames(_get_tb_frames(tb), **kw)
+
+
+def distill_call_stack(**kw):
+    return _distill_frames(_get_sys_trace_frames(), **kw)
+
+
+def _distill_frames(frames, frame_correction=0):
+    returned = DistilledTraceback()
+    frames = frames[:len(frames)-frame_correction+1]
+    for frame in frames:
+        if isinstance(frame, tuple):
+            frame, lineno = frame
+        else:
+            lineno = None
+        if _is_frame_and_below_muted(frame):
+            break
+        if not _is_frame_muted(frame):
+            returned.frames.append(DistilledFrame(frame, lineno))
+    return returned
+
+
+def _get_tb_frames(tb):
+    returned = []
+    while tb is not None:
+        returned.append((tb.tb_frame, tb.tb_lineno))
+        tb = tb.tb_next
+    return returned
+
+def _get_sys_trace_frames():
+    return [f[0] for f in reversed(inspect.stack()[:-1])]
+
+def _is_frame_muted(frame):
+    try:
+        return _deduce_frame_function(frame) in _MUTED_LOCATIONS
+    finally:
+        del frame
+
+
+def _deduce_frame_function(frame):
+    try:
+        frame_module = _deduce_frame_module(frame)
+        if frame_module is None:
+            return None
+
+        return (frame_module, frame.f_code.co_name)
+    finally:
+        del frame
+
+
+def _deduce_frame_module(frame):
+    return frame.f_globals.get("__name__")
+
+
+_MUTED_LOCATIONS = set([
+    ("slash.core.function_test", "run"),
+    ("slash.core.test", "run"),
+    ("slash.exception_handling", "handling_exceptions"),
+    ("slash.core.fixtures.fixture_store", "call_with_fixtures"),
+    ("slash.frontend.main", "__main__"),
+    ("slash.frontend.main", "main"),
+    ("slash.frontend.main", "main_entry_point"),
+    ("slash.frontend.slash_run", "slash_run"),
+    ("slash.runner", "run_tests"),
+    ("slash.runner", "_run_single_test"),
+    ("slash.core.cleanup_manager", "call_cleanups"),
+    ("slash.core.cleanup_manager", "__call__"),
+])
+
+
+def _is_frame_and_below_muted(frame):
+    return frame.f_globals.get("__name__") in _MUTE_BELOW_MODULES
+
+_MUTE_BELOW_MODULES = set([
+    "slash.assertions"
+])
+
+
+class DistilledTraceback(object):
+
+    def __init__(self):
+        super(DistilledTraceback, self).__init__()
+        self.frames = []
+
+    def to_list(self):
+        return [frame.to_dict() for frame in self.frames]
+
+    @property
+    def cause(self):
+        if self.frames:
+            return self.frames[-1]
+
+    def __repr__(self):
+        return '\n'.join(str(frame) for frame in self.frames)
+
+
+class DistilledFrame(object):
+
+    def __init__(self, frame, lineno=None):
+        super(DistilledFrame, self).__init__()
+        self.python_frame = frame
+        self.filename = os.path.abspath(frame.f_code.co_filename)
+        if lineno is None:
+            lineno = frame.f_lineno
+        self.lineno = lineno
+        self.func_name = frame.f_code.co_name
+        self.code_line = linecache.getline(self.filename, self.lineno).rstrip()
+        self.code_string = "".join(
+            linecache.getline(self.filename, lineno)
+            for lineno in range(frame.f_code.co_firstlineno, self.lineno + 1)) or None
+        if context.test is not None:
+            test_function = get_underlying_func(context.test.get_test_function())
+            self._is_in_test_code = frame.f_code is test_function.__code__
+        else:
+            self._is_in_test_code = False
+
+    def forget_python_frame(self):
+        self.python_frame = None
+
+    def is_in_test_code(self):
+        return self._is_in_test_code
+
+    def to_dict(self):
+        serialized = {}
+        for attr in ['filename', 'lineno', 'func_name', 'code_line', 'code_string']:
+            serialized[attr] = getattr(self, attr)
+        serialized['is_in_test_code'] = self._is_in_test_code
+        return serialized
+
+    def __repr__(self):
+        return '{0.filename}, line {0.lineno}:\n    {0.code_line}'.format(self)
+
+
+def _safe_repr(value, truncate=True):
+    try:
+        returned = repr(value)
+    except Exception:  # pylint: disable=broad-except
+        return "[Unprintable {0!r} object]".format(type(value).__name__)
+
+    if truncate and len(returned) > _MAX_VARIABLE_VALUE_LENGTH:
+        returned = returned[:_MAX_VARIABLE_VALUE_LENGTH - 3] + '...'
+    return returned
diff --git a/slash/utils/warning_capture.py b/slash/utils/warning_capture.py
new file mode 100755
index 0000000000..45d4094931
--- /dev/null
+++ b/slash/utils/warning_capture.py
@@ -0,0 +1,26 @@
+import sys
+
+
+class warning_callback_context(object):
+
+    """A context for installing callbacks for handling warnings.
+
+    Code adopted from the built-in catch_warnings handler
+    """
+
+    def __init__(self, callback):
+        self._callback = callback
+        self._module = sys.modules['warnings']
+        self._entered = False
+
+    def __enter__(self):
+        if self._entered:
+            raise RuntimeError("Cannot enter %r twice" % self)
+        self._entered = True
+        self._showwarning = self._module.showwarning
+        self._module.showwarning = self._callback
+
+    def __exit__(self, *exc_info):
+        if not self._entered:
+            raise RuntimeError("Cannot exit %r without entering first" % self)
+        self._module.showwarning = self._showwarning
diff --git a/slash/warnings.py b/slash/warnings.py
new file mode 100755
index 0000000000..9fce6c64b3
--- /dev/null
+++ b/slash/warnings.py
@@ -0,0 +1,127 @@
+from __future__ import absolute_import
+
+import collections
+
+import logbook
+import warnings
+
+from . import hooks
+from .utils.warning_capture import warning_callback_context
+from .ctx import context
+from contextlib import contextmanager
+
+_native_logger = logbook.Logger('slash.native_warnings')
+
+class LogbookWarning(UserWarning):
+    pass
+
+class SessionWarnings(object):
+    """
+    Holds all warnings emitted during the session
+    """
+    def __init__(self):
+        super(SessionWarnings, self).__init__()
+        self.warnings = []
+
+    @contextmanager
+    def capture_context(self):
+        warnings.simplefilter('always')
+        warnings.filterwarnings('ignore', category=ImportWarning)
+        with warning_callback_context(self._capture_native_warning):
+            yield
+
+    def _capture_native_warning(self, message, category, filename, lineno, file=None, line=None): # pylint: disable=unused-argument
+        warning = RecordedWarning.from_native_warning(message, category, filename, lineno)
+        self.add(warning)
+        if not issubclass(category, LogbookWarning):
+            _native_logger.warning('{!r}', warning)
+
+    def add(self, warning):
+        hooks.warning_added(warning=warning) # pylint: disable=no-member
+        self.warnings.append(warning)
+
+    def __iter__(self):
+        "Iterates through stored warnings"
+        return iter(self.warnings)
+
+    def __len__(self):
+        return len(self.warnings)
+
+    def __nonzero__(self):
+        return bool(self.warnings)
+
+    __bool__ = __nonzero__
+
+
+class WarnHandler(logbook.Handler, logbook.StringFormatterHandlerMixin):
+    """
+    Like a stream handler but keeps the values in memory.
+    This logger provides some ways to store warnings to log again at the end of the session.
+    """
+    default_format_string = (u'[{record.time:%Y-%m-%d %H:%M}] '
+      '{record.level_name}: {record.extra[source]}: {record.message}')
+    def __init__(self, session_warnings, format_string=None, filter=None, bubble=True):
+        logbook.Handler.__init__(self, logbook.WARNING, filter, bubble)
+        logbook.StringFormatterHandlerMixin.__init__(self, format_string)
+        self.session_warnings = session_warnings
+
+    def should_handle(self, record):
+        """Returns `True` if this record is a warning """
+        if record.channel == _native_logger.name:
+            return False
+        return record.level == self.level
+
+    def emit(self, record):
+        warnings.warn_explicit(message=record.message, category=LogbookWarning, filename=record.filename,
+                               lineno=record.lineno, module=record.module)
+
+
+WarningKey = collections.namedtuple("WarningKey", ("filename", "lineno"))
+
+class RecordedWarning(object):
+
+    def __init__(self, details, message):
+        super(RecordedWarning, self).__init__()
+        self.details = details
+        self.details['session_id'] = context.session_id
+        self.details['test_id'] = context.test_id
+        self.details.setdefault('func_name', None)
+        self.key = WarningKey(filename=self.details['filename'], lineno=self.details['lineno'])
+        self._repr = message
+
+    @classmethod
+    def from_log_record(cls, record, handler):
+        details = record.to_dict()
+        return cls(details, handler.format(record))
+
+
+    @classmethod
+    def from_native_warning(cls, message, category, filename, lineno):
+        if isinstance(message, Warning):
+            message = message.args[0]
+
+        return cls({
+            'message': message,
+            'type': category.__name__,
+            'filename': filename,
+            'lineno': lineno,
+            }, message=message)
+
+    @property
+    def message(self):
+        return self.details.get('message')
+
+    @property
+    def lineno(self):
+        return self.details.get('lineno')
+
+    @property
+    def filename(self):
+        return self.details.get('filename')
+
+
+    def to_dict(self):
+        return self.details.copy()
+
+    def __repr__(self):
+        return self._repr
diff --git a/tests/__init__.py b/tests/__init__.py
new file mode 100755
index 0000000000..e69de29bb2
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100755
index 0000000000..2710ae9122
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,309 @@
+# pylint: disable=redefined-outer-name
+import itertools
+import os
+import random
+import tempfile
+from uuid import uuid4
+
+from forge import Forge
+
+import gossip
+import pytest
+import slash
+import slash.plugins
+from slash.loader import Loader
+from slash.core.result import GlobalResult, Result
+
+from .utils.cartesian import Cartesian
+from .utils.suite_writer import Suite
+from .utils.garbage_collection import GarbageCollectionMarker
+
+
+@pytest.fixture(scope='session', autouse=True)
+def unittest_mode_logging():
+    slash.config.root.log.unittest_mode = True
+
+
+@pytest.fixture(scope='session', autouse=True)
+def random_seed():
+    random.seed(0xdeadface)
+
+
+@pytest.fixture(scope='session', autouse=True)
+def no_user_config(request):
+    tmpdir = tempfile.mkdtemp()
+    slash.conf.config.root.run.user_customization_file_path = os.path.join(
+        tmpdir, 'slashrc')
+
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        os.rmdir(tmpdir)
+
+
+@pytest.fixture
+def no_plugins(request):
+    slash.plugins.manager.uninstall_all()
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        slash.plugins.manager.uninstall_all()
+        slash.plugins.manager.install_builtin_plugins()
+
+
+@pytest.fixture
+def forge(request):
+
+    returned = Forge()
+
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        returned.verify()
+        returned.restore_all_replacements()
+
+    return returned
+
+
+@pytest.fixture
+def config_override(request):
+
+    def _override(path, value):
+        prev_value = slash.config.get_config(path).get_value()
+
+        @request.addfinalizer
+        def restore():  # pylint: disable=unused-variable
+            slash.config.assign_path(path, prev_value)
+        slash.config.assign_path(path, value)
+    return _override
+
+
+@pytest.fixture
+def cartesian():
+    return Cartesian()
+
+
+@pytest.fixture(scope="function", autouse=True)
+def cleanup_hook_registrations(request):
+    @request.addfinalizer
+    def _cleanup():
+        for hook in gossip.get_group("slash").get_hooks():
+            hook.unregister_all()
+        assert not gossip.get_group("slash").get_subgroups()
+
+
+@pytest.fixture
+def checkpoint():
+    return Checkpoint()
+
+@pytest.fixture
+def checkpoint1():
+    return Checkpoint()
+
+@pytest.fixture
+def checkpoint2():
+    return Checkpoint()
+
+
+_timestamp = itertools.count(1000000)
+
+
+class Checkpoint(object):
+
+    called_count = 0
+    args = kwargs = timestamp = None
+
+    def __call__(self, *args, **kwargs):
+        self.called_count += 1
+        self.args = args
+        self.kwargs = kwargs
+        self.timestamp = next(_timestamp)
+
+    @property
+    def called(self):
+        return self.called_count > 0
+
+@pytest.fixture
+def suite_test(suite, test_type, is_last_test):
+    returned = suite.add_test(type=test_type)
+    if not is_last_test:
+        _ = suite.add_test(type=test_type)
+
+    return returned
+
+@pytest.fixture
+def last_suite_test(suite, test_type):
+    return suite.add_test(type=test_type)
+
+@pytest.fixture(params=[GlobalResult, Result])
+def result(request):
+    return request.param()
+
+
+@pytest.fixture(params=[True, False])
+def is_last_test(request):
+    return request.param
+
+
+@pytest.fixture(params=['method', 'function'])
+def test_type(request):
+    return request.param
+
+
+@pytest.fixture
+def suite():
+    returned = Suite()
+    returned.populate()
+    return returned
+
+@pytest.fixture
+def parallel_suite_test(parallel_suite, test_type, is_last_test):
+    returned = parallel_suite.add_test(type=test_type)
+    if not is_last_test:
+        _ = parallel_suite.add_test(type=test_type)
+
+    return returned
+
+@pytest.fixture
+def parallel_suite():
+    returned = Suite(debug_info=False, is_parallel=True)
+    returned.populate()
+    return returned
+
+@pytest.fixture
+def runnable_test_dir(tmpdir):
+    tests_dir = tmpdir.join(str(uuid4()))
+    filename = str(uuid4()).replace('-', '') + '.py'
+    with tests_dir.join(filename).open('w', ensure=True) as f:
+        f.write('def test_something():\n    pass')
+    return tests_dir
+
+@pytest.fixture
+def slash_session():
+    return slash.Session()
+
+@pytest.fixture
+def test_loader():
+    return Loader()
+
+
+@pytest.fixture
+def active_slash_session(request):
+    returned = slash.Session()
+    returned.__enter__()
+
+    @request.addfinalizer
+    def finalize():  # pylint: disable=unused-variable
+        returned.__exit__(None, None, None)
+
+    return returned
+
+
+@pytest.fixture(params=["slashconf", "module"])
+def defined_fixture(request, suite, suite_test):
+    if request.param == 'slashconf':
+        return suite.slashconf.add_fixture()
+    elif request.param == 'module':
+        return suite_test.file.add_fixture()
+
+    raise NotImplementedError()  # pragma: no cover
+
+
+@pytest.fixture
+def gc_marker():
+    return GarbageCollectionMarker()
+
+
+@pytest.fixture(autouse=True, scope="function")
+def reset_gossip(request):
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        for group in list(gossip.get_groups()):
+            if group.name == 'slash':
+                continue
+            group.undefine()
+
+        for hook in gossip.get_all_hooks():
+            if hook.group.name != 'slash':
+                hook.undefine()
+            else:
+                hook.unregister_all()
+
+
+@pytest.fixture  # pylint: disable=unused-argument
+def plugin(no_plugins):  # pylint: disable=unused-argument
+
+    class StartSessionPlugin(slash.plugins.PluginInterface):
+        _activate_called = False
+        _deactivate_called = False
+
+        def __init__(self):
+            super(StartSessionPlugin, self).__init__()
+            self.session_start_call_count = 0
+
+        def get_name(self):
+            return "start-session"
+
+        def session_start(self):
+            self.session_start_call_count += 1
+
+        def activate(self):
+            self._activate_called = True
+
+        def deactivate(self):
+            self._deactivate_called = True
+    return StartSessionPlugin()
+
+
+@pytest.fixture(params=['slashconf', 'file'])
+def get_fixture_location(request):
+
+    def getter(test):
+        if request.param == 'slashconf':
+            return test.suite.slashconf
+        elif request.param == 'file':
+            return test.file
+        else:
+            raise NotImplementedError() # pragma: no cover
+    return getter
+
+@pytest.fixture
+def restore_plugins_on_cleanup(request):
+    request.addfinalizer(slash.plugins.manager.install_builtin_plugins)
+    request.addfinalizer(slash.plugins.manager.uninstall_all)
+
+
+@pytest.fixture
+def logs_dir(config_override, tmpdir, relative_symlinks):
+    returned = tmpdir.join('logs')
+    config_override("log.root", str(returned.join("files")))
+    config_override("log.last_session_symlink",
+                    str("../links/last-session" if relative_symlinks else returned.join("links", "last-session")))
+    config_override("log.last_session_dir_symlink",
+                    str("../links/last-session-dir" if relative_symlinks else returned.join("links", "last-session-dir")))
+    config_override("log.last_test_symlink",
+                    str("../links/last-test" if relative_symlinks else returned.join("links", "last-test")))
+    config_override("log.last_failed_symlink",
+                    str("../links/last-failed" if relative_symlinks else returned.join("links", "last-failed")))
+
+    return returned
+
+
+@pytest.fixture(params=[True, False])
+def relative_symlinks(request):
+    return request.param
+
+
+@pytest.fixture
+def session_log(logs_dir):
+    return logs_dir.join('links').join('last-session')
+
+
+@pytest.fixture
+def unique_string1():
+    return str(uuid4())
+
+
+@pytest.fixture(params=[True, False])
+def yield_fixture_decorator(request):
+    should_use_explicitly = request.param
+    if should_use_explicitly:
+        return slash.yield_fixture
+    return slash.fixture
diff --git a/tests/test_add_error.py b/tests/test_add_error.py
new file mode 100755
index 0000000000..cc1fb11680
--- /dev/null
+++ b/tests/test_add_error.py
@@ -0,0 +1,75 @@
+from uuid import uuid4
+import pytest
+
+
+@pytest.mark.parametrize('failure_type', ['failure', 'error'])
+@pytest.mark.parametrize('use_custom_message', [True, False])
+def test_add_error_custom_exc_info(suite, suite_test, failure_type, use_custom_message):
+    message = str(uuid4())
+
+    if use_custom_message:
+        add_error_args = '{!r}, '.format(message)
+    else:
+        add_error_args = ''
+
+    add_error_args += 'exc_info=exc_info'
+
+    code = """
+import sys
+try:
+    1/0
+except ZeroDivisionError:
+    exc_info = sys.exc_info()
+    try:
+        None.a = 2
+    except AttributeError:
+        slash.add_{0}({1})
+    """.format(failure_type, add_error_args)
+
+    for line in code.strip().splitlines():
+        suite_test.append_line(line)
+
+    if failure_type == 'error':
+        suite_test.expect_error()
+    else:
+        suite_test.expect_failure()
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+
+    if failure_type == 'error':
+        [err] = result.get_errors()
+    else:
+        [err] = result.get_failures()
+
+    assert err.has_custom_message() == use_custom_message
+    if use_custom_message:
+        assert err.message == message
+    assert err.exception_type is ZeroDivisionError
+    assert err.traceback.frames
+
+
+def test_add_fatal_error(suite, suite_test):
+
+    @suite_test.append_body
+    def __code__():             # pylint: disable=unused-variable
+        slash.add_error('bla').mark_fatal() # pylint: disable=undefined-variable
+
+    suite_test.expect_error()
+    for test in suite.iter_all_after(suite_test):
+        test.expect_not_run()
+
+    session = suite.run().session
+    assert session.results.has_fatal_errors()
+
+
+def test_session_level_add_error_message(suite, suite_test):
+    @suite_test.file.append_body
+    def __code__():                       # pylint: disable=unused-variable
+        @slash.hooks.session_end.register # pylint: disable=undefined-variable
+        def _callback():
+            slash.add_error('session: add_error') # pylint: disable=undefined-variable
+    res = suite.run(expect_session_errors=True)
+    errors = res.session.results.global_result.get_errors()
+    assert len(errors) == 1
+    [err] = errors
+    assert err.message == 'session: add_error'
diff --git a/tests/test_app_context.py b/tests/test_app_context.py
new file mode 100755
index 0000000000..993a81b01b
--- /dev/null
+++ b/tests/test_app_context.py
@@ -0,0 +1,20 @@
+from slash.app import Application
+
+from slash.reporting.console_reporter import ConsoleReporter
+
+
+def test_app_reporter():
+    with Application() as app:
+        assert isinstance(app.session.reporter, ConsoleReporter)
+
+def test_custom_reporter():
+
+    class DummyReporter(object):
+        pass
+
+    dummy_reporter = DummyReporter()
+
+    app = Application()
+    app.set_reporter(dummy_reporter)
+    with app:
+        assert app.session.reporter is dummy_reporter
diff --git a/tests/test_assertions.py b/tests/test_assertions.py
new file mode 100755
index 0000000000..1cc17656bc
--- /dev/null
+++ b/tests/test_assertions.py
@@ -0,0 +1,216 @@
+from .utils import (
+    CustomException,
+)
+from contextlib import contextmanager
+
+import pytest
+
+import slash
+from slash import should
+from slash.exceptions import TestFailed, ExpectedExceptionNotCaught
+
+
+@pytest.mark.parametrize('pair', [
+    (1, 1),
+    (1, 1.00000001),
+])
+def test_assert_almost_equal_positive(pair):
+    a, b = pair
+    slash.assert_almost_equal(a, b)
+
+
+@pytest.mark.parametrize('combination', [
+    (1, 1, 0),
+    (1, 1, 0.1),
+    (1, 1.1, 0.5),
+    (1.0001, 1.00009, 0.00002),
+])
+def test_assert_almost_equal_positive_with_delta(combination):
+    a, b, delta = combination
+    slash.assert_almost_equal(a, b, delta)
+
+
+@pytest.mark.parametrize('combination', [
+    (1, 12, 0),
+    (1, 1.1, 0.00001),
+    (1.0001, 1.00009, 0.000001),
+])
+def test_assert_almost_equal_negative_with_delta(combination):
+    a, b, delta = combination
+    with pytest.raises(AssertionError):
+        slash.assert_almost_equal(a, b, delta)
+
+
+def test_assert_equals():
+    with checking(should.equal, should.not_equal):
+        good(1, 1)
+        bad(1, 2)
+
+
+def test_assert_empty():
+    with checking(should.be_empty, should.not_be_empty):
+        good([])
+        good({})
+        good(set())
+        bad([1, 2, 3])
+        bad({1: 2})
+        bad(set([1, 2, 3]))
+
+
+def test_assert_isinstance():
+    with checking(should.be_a, should.not_be_a):
+        good(1, int)
+        good("a", str)
+        good({}, dict)
+        bad(1, 1)
+        bad(1, str)
+        bad(None, str)
+
+
+def test_is_none():
+    with checking(should.be_none, should.not_be_none):
+        good(None)
+        bad("None")
+
+
+def test_is():
+    obj = object()
+    with checking(should.be, should.not_be):
+        good(obj, obj)
+        bad(obj, object())
+        bad({}, {})
+
+
+def test_truth():
+    with checking(should.be_true, should.be_false):
+        good(True)
+        good("hello")
+        bad(False)
+        bad("")
+        bad({})
+
+
+def test_in():
+    with checking(should.be_in, should.not_be_in):
+        good(1, [1, 2, 3])
+        good("e", "hello")
+        bad(1, [])
+        bad("e", "fdfd")
+    with checking(should.contain, should.not_contain):
+        good([1, 2, 3], 1)
+        good("hello", "e")
+        bad("fdfdfd", "e")
+
+
+
+@pytest.mark.parametrize('func', [should.raise_exception, slash.assert_raises])
+def test_assert_raises(func):
+    thrown = CustomException()
+    with func(CustomException) as caught:
+        raise thrown
+    assert caught.exception is thrown
+    try:
+        with func(CustomException):
+            raise OtherException()
+    except OtherException:
+        pass
+    else:
+        assert False, "func allowed a different type of exception to be raised"
+    try:
+        with func(CustomException):
+            pass
+    except ExpectedExceptionNotCaught as e:
+        assert " not raised" in str(e)
+        assert e.expected_types == (CustomException,)
+    else:
+        assert False, "should.raise_exception allowed success"
+
+
+@pytest.mark.parametrize('func', [should.raise_exception, slash.assert_raises])
+def test_assert_raises_multiple_exceptions(func):
+    class CustomException1(Exception):
+        pass
+
+    class CustomException2(Exception):
+        pass
+
+    class CustomException3(Exception):
+        pass
+
+    exception_types = (CustomException1, CustomException2)
+
+    for exc_type in exception_types:
+        with func(exception_types) as caught:
+            value = exc_type('!')
+            raise value
+        assert caught.exception is value
+
+    value = CustomException3('!')
+    with pytest.raises(CustomException3) as caught:
+        with func(exception_types):
+            raise value
+    assert caught.value is value
+
+
+
+
+def test_raises_exception_multiple_classes():
+    possible_exception_types = (CustomException, OtherException)
+    for x in possible_exception_types:
+        with should.raise_exception(possible_exception_types):
+            raise x()
+
+    with pytest.raises(ExpectedExceptionNotCaught):
+        with should.raise_exception((CustomException,)):
+            pass
+
+# boilerplate
+
+
+class OtherException(BaseException):
+    pass
+
+_MESSAGE = "SOME MESSAGE HERE"
+
+
+def good(*args):
+    _test_assertion(args, positive=True)
+
+
+def bad(*args):
+    _test_assertion(args, positive=False)
+
+
+def _test_assertion(args, positive):
+    positive_assertion = _current_positive_assertion
+    negative_assertion = _current_negative_assertion
+    if not positive:
+        positive_assertion, negative_assertion = negative_assertion, positive_assertion
+    positive_assertion(*args)
+    positive_assertion(*(args + (_MESSAGE,)))
+    for msg in (None, _MESSAGE):
+        try:
+            negative_assertion(*(args + (msg,)))
+        except TestFailed as e:
+            if msg is not None:
+                assert msg in str(e)
+        else:
+            assert False, "Assertion did not fail"
+
+
+_current_positive_assertion = None
+_current_negative_assertion = None
+
+
+@contextmanager
+def checking(assertion, negative_assertion):
+    global _current_positive_assertion # pylint: disable=global-statement
+    global _current_negative_assertion # pylint: disable=global-statement
+    assert _current_positive_assertion is None
+    _current_positive_assertion = assertion
+    _current_negative_assertion = negative_assertion
+    try:
+        yield
+    finally:
+        _current_positive_assertion = None
+        _current_negative_assertion = None
diff --git a/tests/test_autouse_fixtures.py b/tests/test_autouse_fixtures.py
new file mode 100755
index 0000000000..b0c3218b7f
--- /dev/null
+++ b/tests/test_autouse_fixtures.py
@@ -0,0 +1,57 @@
+# pylint: disable=len-as-condition,redefined-outer-name
+import pytest
+
+from .utils.suite_writer import Suite
+
+
+def test_autouse_fixtures_global(tracked_suite):
+
+    fixture = tracked_suite.slashconf.add_fixture(autouse=True)
+
+    results = tracked_suite.run().session.results
+    assert len(results) > 0
+    for result in results:
+        assert fixture.id in result.data['active_fixtures']
+
+def test_autouse_fixtures_specific_module(tracked_suite, suite_test):
+
+    fixture = suite_test.file.add_fixture(autouse=True)
+    summary = tracked_suite.run()
+    assert len(summary.session.results) > 0
+    assert len(tracked_suite.files) > 1
+
+    for test in tracked_suite:
+        for result in summary.get_all_results_for_test(test):
+            if test.file is suite_test.file:
+                assert fixture.id in result.data['active_fixtures']
+            else:
+                assert fixture.id not in result.data['active_fixtures']
+
+@pytest.mark.parametrize('scope', ['test', 'session', 'module'])
+@pytest.mark.parametrize('depend_explicitly', [True, False])
+def test_autouse_called_first(scope, test_type, depend_explicitly):
+    suite = Suite()
+    suite_test = suite.add_test(type=test_type)
+
+    autouse_fixture = suite.slashconf.add_fixture(autouse=True, scope=scope)
+    autouse_fixture_called = autouse_fixture.add_event()
+
+    regular_fixture = suite.slashconf.add_fixture()
+    regular_fixture_called = regular_fixture.add_event()
+    suite_test.depend_on_fixture(regular_fixture)
+
+    if depend_explicitly:
+        suite_test.depend_on_fixture(autouse_fixture)
+
+    test_called = suite_test.add_event()
+    events = suite.run().events
+    assert events[regular_fixture_called].timestamp < events[test_called].timestamp
+    assert events[autouse_fixture_called].timestamp < events[regular_fixture_called].timestamp
+
+
+@pytest.fixture  # pylint: disable=unused-argument
+def tracked_suite(suite, suite_test):  # pylint: disable=unused-argument
+    assert len(suite)
+    for test in suite:
+        test.prepend_line('slash.context.result.data["active_fixtures"] = __ut__.get_fixture_memento()')
+    return suite
diff --git a/tests/test_cleanup_manager.py b/tests/test_cleanup_manager.py
new file mode 100755
index 0000000000..afca6c29df
--- /dev/null
+++ b/tests/test_cleanup_manager.py
@@ -0,0 +1,48 @@
+# pylint: disable=redefined-outer-name
+import pytest
+from slash.core.cleanup_manager import CleanupManager
+
+from .conftest import Checkpoint
+
+
+@pytest.mark.parametrize('in_failure', [True, False])
+@pytest.mark.parametrize('in_interruption', [True, False])
+def test_cleanup_default_scope(cleanup_manager, cleanup, in_failure, in_interruption):
+    cleanup_manager.add_cleanup(cleanup)
+    assert not cleanup.called
+    cleanup_manager.call_cleanups(scope=cleanup_manager.latest_scope, in_failure=in_failure, in_interruption=in_interruption)
+
+    assert cleanup.called == (not in_interruption)
+
+def test_default_scope(cleanup_manager):
+    cleanup1 = cleanup_manager.add_cleanup(Checkpoint())
+
+    with cleanup_manager.scope('session'):
+
+        cleanup2 = cleanup_manager.add_cleanup(Checkpoint())
+
+        with cleanup_manager.scope('module'):
+
+            cleanup3 = cleanup_manager.add_cleanup(Checkpoint())
+
+            assert not cleanup3.called
+        assert not cleanup2.called
+
+    assert not cleanup1.called
+    cleanup_manager.call_cleanups(scope=cleanup_manager.latest_scope, in_failure=False, in_interruption=False)
+    assert cleanup1.called
+    assert cleanup2.called
+    assert cleanup3.called
+    assert cleanup3.timestamp < cleanup2.timestamp < cleanup1.timestamp
+
+
+@pytest.fixture
+def cleanup_manager():
+    returned = CleanupManager()
+    returned.push_scope(None)
+    return returned
+
+
+@pytest.fixture
+def cleanup(checkpoint):
+    return checkpoint
diff --git a/tests/test_cleanups.py b/tests/test_cleanups.py
new file mode 100755
index 0000000000..fda027c171
--- /dev/null
+++ b/tests/test_cleanups.py
@@ -0,0 +1,193 @@
+# pylint: disable=unused-argument,unused-variable
+import gossip
+import pytest
+import slash
+import slash.runner
+from slash.exceptions import CannotAddCleanup, IncorrectScope
+
+
+def test_session_cleanup(suite, suite_test):
+
+    @suite.slashconf.append_body
+    def __code__():
+        @slash.add_cleanup
+        def session_cleanup():
+            1 / 0 # pylint: disable=pointless-statement
+
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.session.results.is_success()
+    [err] = summary.session.results.global_result.get_errors()
+    assert err.exception_type is ZeroDivisionError
+    assert 'Session error' in summary.get_console_output()
+
+
+def test_cleanups_within_cleanups(suite, suite_test):
+
+    @suite_test.append_body
+    def __code__():
+        @slash.add_cleanup
+        def cleanup1():
+            slash.context.result.data['cleanup1'] = True
+
+            @slash.add_cleanup
+            def cleanup2():
+                slash.context.result.data['cleanup2'] = True
+
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    assert result.data['cleanup1']
+    assert result.data['cleanup2']
+
+
+@pytest.mark.parametrize('other_error', ['error', 'failure', None])
+def test_success_only_cleanups_with_skips(suite, suite_test, other_error):
+
+    if other_error == 'error':
+        suite_test.append_line('slash.add_error("error")')
+        suite_test.expect_error()
+    elif other_error == 'failure':
+        suite_test.append_line('slash.add_failure("failure")')
+        suite_test.expect_failure()
+    elif other_error is not None:
+        raise NotImplementedError()  # pragma: no cover
+
+    @suite_test.append_body
+    def __code__():
+        def callback():
+            __ut__.events.add('success_only_cleanup_called') # pylint: disable=undefined-variable
+        slash.add_cleanup(callback, success_only=True)
+        slash.skip_test()
+
+    if other_error is None:
+        suite_test.expect_skip()
+
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    assert result.has_skips()
+    assert ('success_only_cleanup_called' in summary.events) == (other_error is None)
+
+
+def test_fatal_exceptions_from_cleanup(suite, suite_test, is_last_test):
+
+    @suite_test.append_body
+    def __code__():
+        @slash.add_cleanup
+        def cleanup():
+            from slash.exception_handling import mark_exception_fatal
+            raise mark_exception_fatal(Exception())
+
+    suite_test.expect_error()
+
+    for t in suite.iter_all_after(suite_test, assert_has_more=not is_last_test):
+        t.expect_not_run()
+
+    suite.run()
+
+
+def test_add_skip_from_test_cleanup(suite, suite_test):
+    cleanup = suite_test.add_deferred_event(decorator='slash.add_cleanup', extra_code=['slash.skip_test()'])
+    suite_test.expect_skip()
+    summary = suite.run()
+    assert summary.events[cleanup].timestamp
+
+
+@pytest.mark.parametrize('cleanup_mechanism', ['this', 'slash'])
+def test_add_skip_from_fixture_cleanup(suite, suite_test, cleanup_mechanism):
+    suite_test.expect_skip()
+    fixture = suite.slashconf.add_fixture()
+    suite_test.depend_on_fixture(fixture)
+    cleanup = fixture.add_deferred_event(decorator='{0}.add_cleanup'.format(cleanup_mechanism), extra_code=['slash.skip_test()'])
+    summary = suite.run()
+    assert summary.events[cleanup].timestamp
+
+
+def test_test_cleanups_happen_before_fixture_cleanups(suite, suite_test):
+    fixture = suite.slashconf.add_fixture()
+    suite_test.depend_on_fixture(fixture)
+    fixture_cleanup = fixture.add_cleanup()
+    test_cleanup = suite_test.add_cleanup()
+    events = suite.run().events
+
+    assert events[fixture_cleanup].timestamp > events[test_cleanup].timestamp
+
+
+def test_cannot_add_cleanup_without_active_session():
+    with pytest.raises(RuntimeError):
+        slash.add_cleanup(lambda: None)
+
+
+def test_cleanups(suite, suite_test):
+
+    cleanup = suite_test.add_cleanup()
+
+    summary = suite.run()
+
+    assert summary.events[cleanup]
+
+
+def test_cleanup_args_kwargs_deprecated():
+    with slash.Session() as s:
+        slash.add_cleanup(lambda: None, "arg1", arg2=1)
+    [w] = s.warnings
+    assert 'deprecated' in str(w).lower()
+
+
+def test_cleanup_ordering(suite, suite_test):
+    cleanup1 = suite_test.add_cleanup()
+    cleanup2 = suite_test.add_cleanup()
+    events = suite.run().events
+
+    assert events[cleanup1].timestamp > events[cleanup2].timestamp
+
+
+@pytest.mark.parametrize('fail_test', [True, False])
+def test_errors_in_cleanup(suite, suite_test, fail_test):
+    cleanup1 = suite_test.add_cleanup()
+    cleanup2 = suite_test.add_cleanup(extra_code=['None.a = 2'])
+
+    if fail_test:
+        suite_test.when_run.raise_exception()
+    else:
+        suite_test.expect_error()
+
+    summary = suite.run()
+
+    assert summary.events[cleanup1].timestamp > summary.events[cleanup2].timestamp
+
+    [result] = summary.get_all_results_for_test(suite_test)
+
+    assert len(result.get_errors()) == 2 if fail_test else 1
+    cleanup_error = result.get_errors()[-1]
+    assert 'AttributeError' in str(cleanup_error)
+    assert 'NoneType' in str(cleanup_error)
+
+
+def test_add_test_cleanup_from_session_scope_forbidden(checkpoint):
+
+    with slash.Session():
+        with pytest.raises(IncorrectScope):
+            slash.add_cleanup(checkpoint, scope='test')
+
+    assert not checkpoint.called
+
+
+def test_adding_implicit_scoped_cleanups_from_test_end_forbidden(suite, suite_test, checkpoint):
+
+    @gossip.register('slash.test_end')
+    def test_end():
+
+        with pytest.raises(CannotAddCleanup):
+            slash.add_cleanup(checkpoint)
+
+    suite.run()
+    assert not checkpoint.called
+
+
+def test_adding_session_scoped_cleanups_from_test_end_allowed(suite, suite_test, checkpoint):
+
+    @gossip.register('slash.test_end')
+    def test_end():
+        slash.add_cleanup(checkpoint, scope='session')
+
+    suite.run()
+    assert checkpoint.called_count == len(suite)
diff --git a/tests/test_cli_environment.py b/tests/test_cli_environment.py
new file mode 100755
index 0000000000..36cd1d7b4c
--- /dev/null
+++ b/tests/test_cli_environment.py
@@ -0,0 +1,162 @@
+import sys
+
+from confetti import Config
+from slash import plugins
+from slash._compat import cStringIO
+from slash.plugins import PluginInterface
+from slash.utils import cli_utils, conf_utils
+
+from .utils import TestCase
+
+
+class OutputCaptureTest(TestCase):
+
+    def setUp(self):
+        super(OutputCaptureTest, self).setUp()
+        self.stderr = cStringIO()
+        self.forge.replace_with(sys, "stderr", self.stderr)
+        self.stdout = cStringIO()
+        self.forge.replace_with(sys, "stdout", self.stdout)
+
+
+class ArgumentParsingTest(OutputCaptureTest):
+
+    def setUp(self):
+        super(ArgumentParsingTest, self).setUp()
+        self.config = Config({
+            "a": {"a1": {"flag1": True // conf_utils.Cmdline(off="--no-flag1")}},
+            "b": {"b1": {"flag2": False // conf_utils.Cmdline(on="--flag2")}},
+            "string_value": "",
+            "int_value": 0 // conf_utils.Cmdline(increase="--increase", decrease="--decrease"),
+            "arg_value": "" // conf_utils.Cmdline(arg="--arg-value"),
+            "list": ["existing_item"] // conf_utils.Cmdline(append="--append"),
+        })
+        self._parser = cli_utils.SlashArgumentParser()
+        cli_utils.configure_arg_parser_by_config(self._parser, self.config)
+
+    def _cli(self, argv):
+        parsed_args, _ = self._parser.parse_known_args(argv)
+        return cli_utils.get_modified_configuration_from_args_context(self._parser, parsed_args, config=self.config)
+
+    def test_config_arg_flag(self):
+        with self._cli(["--arg-value=x"]):
+            self.assertEqual(self.config["arg_value"], "x")
+
+    def test_config_increase(self):
+        with self._cli(["--increase"]):
+            self.assertEqual(self.config["int_value"], 1)
+
+    def test_config_decrease(self):
+        with self._cli(["--decrease"]):
+            self.assertEqual(self.config["int_value"], -1)
+
+    def test_config_off_flag(self):
+        with self._cli(["--no-flag1"]):
+            self.assertFalse(self.config["a"]["a1"]["flag1"])
+        self.assertTrue(self.config["a"]["a1"]["flag1"])
+
+    def test_config_on_flag(self):
+        with self._cli(["--flag2"]):
+            self.assertTrue(self.config["b"]["b1"]["flag2"])
+        self.assertFalse(self.config["b"]["b1"]["flag2"])
+
+    def test_config_append_flag(self):
+        with self._cli(["--append", "a", "--append=b"]):
+            self.assertEqual(self.config["list"], ["existing_item", "a", "b"])
+
+    def test_config_assign_flag(self):
+        with self._cli(["-o", "string_value=hello", "-o", "int_value=666"]):
+            self.assertEqual(self.config.root.string_value, "hello")
+            self.assertEqual(self.config.root.int_value, 666)
+
+    def test_config_assign_wrong_path_restores_config(self):
+        "Given a bad override, the get_parsed_config_args_context() should leave the configuration untouched"
+        with self.assertRaises(SystemExit) as caught:
+            with self._cli(["-o", "string_value=bla", "-o", "int_value=hello"]):
+                pass
+        self.assertNotEqual(caught.exception.code, 0)
+        self.assertEqual(self.config.root.int_value, 0)
+        self.assertEqual(self.config.root.string_value, "")
+
+    def test_config_assign_missing_assignment(self):
+        with self.assertRaises(SystemExit) as caught:
+            with self._cli(['-o', 'blap']):
+                pass
+        self.assertNotEqual(caught.exception.code, 0)
+
+
+class PluginCommandLineArgumentsTest(OutputCaptureTest):
+
+    def setUp(self):
+        super(PluginCommandLineArgumentsTest, self).setUp()
+        self.plugin = SampleCommandLinePlugin()
+        plugins.manager.install(self.plugin)
+        self.addCleanup(plugins.manager.uninstall, self.plugin)
+        self.internal_plugin = InternalPlugin()
+        plugins.manager.install(self.internal_plugin, is_internal=True)
+        self.addCleanup(plugins.manager.uninstall, self.internal_plugin)
+        self._parser = cli_utils.SlashArgumentParser()
+
+    def test_arguments_are_not_parsed_if_not_activated(self):
+        args = ["--start-session-option", "2"]
+        with self.assertRaises(SystemExit) as caught:
+            self._parser.parse_args(args)
+        assert caught.exception.code != 0
+
+    def test_activation(self):
+        cli_utils.add_pending_plugins_from_commandline(["--with-sample-plugin"])
+        self.assertIn(self.plugin.get_name(), plugins.manager.get_future_active_plugins(), "plugin was not activated")
+
+    def test_deactivation(self):
+        argv = ["--without-sample-plugin"]
+        plugins.manager.activate(self.plugin)
+        argv = cli_utils.add_pending_plugins_from_commandline(argv)
+        self.assertIn(self.plugin.get_name(), plugins.manager.get_active_plugins())
+        assert argv == []
+        plugins.manager.activate_pending_plugins()
+        self.assertNotIn(self.plugin.get_name(), plugins.manager.get_future_active_plugins())
+        self.assertNotIn(self.plugin.get_name(), plugins.manager.get_active_plugins())
+
+    def test_argument_passing(self):
+        argv = ["--with-sample-plugin", "--plugin-option", "value"]
+        cli_utils.configure_arg_parser_by_plugins(self._parser)
+        argv = cli_utils.add_pending_plugins_from_commandline(argv)
+        parsed_args = self._parser.parse_args(argv)
+        plugins.manager.activate_pending_plugins()
+        cli_utils.configure_plugins_from_args(parsed_args)
+        self.assertEqual(self.plugin.cmdline_param, "value")
+
+    def test_help_shows_available_plugins(self):
+        cli_utils.configure_arg_parser_by_plugins(self._parser)
+        with self.assertRaises(SystemExit):
+            self._parser.parse_args(['-h'])
+        output = self.stdout.getvalue()
+        self.assertIn("--with-sample-plugin", output)
+        self.assertIn("--plugin-option", output)
+        self.assertIn("internal-plugin", output)
+        self.assertNotIn("--with-internal-plugin", output)
+        self.assertIn("--internal-plugin-option", output)
+
+
+class SampleCommandLinePlugin(PluginInterface):
+
+    def get_name(self):
+        return "sample-plugin"
+
+    def configure_argument_parser(self, parser):
+        parser.add_argument("--plugin-option")
+
+    def configure_from_parsed_args(self, args):
+        self.cmdline_param = args.plugin_option
+
+
+class InternalPlugin(PluginInterface):
+
+    def get_name(self):
+        return "internal-plugin"
+
+    def configure_argument_parser(self, parser):
+        parser.add_argument("--internal-plugin-option")
+
+    def configure_from_parsed_args(self, args):
+        self.cmdline_param = args.plugin_option
diff --git a/tests/test_cli_utils.py b/tests/test_cli_utils.py
new file mode 100755
index 0000000000..1f6bf037f2
--- /dev/null
+++ b/tests/test_cli_utils.py
@@ -0,0 +1,45 @@
+import colorama
+import pytest
+from slash._compat import StringIO
+from slash.utils.cli_utils import Printer, make_styler, UNDERLINED
+
+_style_1 = colorama.Fore.MAGENTA + colorama.Style.BRIGHT + UNDERLINED  # pylint: disable=no-member
+_style_2 = colorama.Fore.GREEN + colorama.Style.BRIGHT  # pylint: disable=no-member
+
+def _toggle(toggle_name):
+    return pytest.mark.parametrize(toggle_name, [True, False])
+
+def _colorized(string, style=None):
+    if not style:
+        return string
+    return make_styler(style)(string)
+
+@_toggle('force_color')
+@_toggle('enable_color')
+def test_printer_with_output_disabled(force_color, enable_color):
+    report_stream = StringIO()
+    printer = Printer(report_stream, enable_output=False, force_color=force_color, enable_color=enable_color)
+    printer(_colorized('A', _style_1))
+    printer(_colorized('B', _style_2))
+    printer('C')
+    assert not report_stream.getvalue()
+
+
+def test_printer_with_forced_colored():
+    report_stream = StringIO()
+    printer = Printer(report_stream, force_color=True)
+    expected_lines = []
+    for string, style in [('A', _style_1), ('B', _style_2), ('C', None)]:
+        colored_string = _colorized(string, style)
+        printer(colored_string)
+        expected_lines.append(colored_string.colorize() if style else str(colored_string))
+    assert report_stream.getvalue().splitlines() == expected_lines
+
+
+def test_printer_with_disalbed_colored():
+    report_stream = StringIO()
+    printer = Printer(report_stream, enable_color=True)
+    printer(_colorized('A', _style_1))
+    printer(_colorized('B', _style_2))
+    printer('C')
+    assert report_stream.getvalue().splitlines() == ['A', 'B', 'C']
diff --git a/tests/test_color_strings.py b/tests/test_color_strings.py
new file mode 100755
index 0000000000..52efdebfe6
--- /dev/null
+++ b/tests/test_color_strings.py
@@ -0,0 +1,76 @@
+import colorama
+from .utils import TestCase
+from slash.utils.color_string import ColorString, ColorStringBase
+
+
+class ColoredStringTest(TestCase):
+
+    def test_colored_string(self):
+        orig = "some string"
+        colored = ColorString(orig, 'red')
+        self.assertEqual(str(orig), str(colored))
+        self.assertEqual(repr(orig), repr(colored))
+        self.assertEqual(
+            colored.get_colored(), colorama.Fore.RED + orig + colorama.Fore.RESET)
+
+    def test_get_formatter(self):
+        f = ColorString.get_formatter("red")
+        self.assert_colored(
+            f("test"), colorama.Fore.RED + "test" + colorama.Fore.RESET, "test")
+
+    def test_transformations(self):
+        for modifier in [
+                (lambda s: s.ljust(20)),
+        ]:
+            self.assertEqual(modifier(ColorString("string", "red")).get_colored(),
+                              ColorString(modifier("string"), "red").get_colored())
+
+    def test_len(self):
+        for x in ["test", "me", "here!!!"]:
+            self.assertEqual(len(ColorString(x, "red")), len(x))
+
+        self.assertEqual(len("hello" + ColorString(" there", "red")), len("hello there"))
+
+    def test_formatting(self):
+        orig = "value1=%s, value2=%s"
+        values = (6, 7)
+        orig_formatted = orig % values
+        colored = ColorString(orig, 'red')
+        colored_formatted = colored % values
+        self.assert_colored(
+            colored_formatted,
+            colorama.Fore.RED + orig_formatted + colorama.Fore.RESET,
+            orig_formatted
+        )
+        self.assertIsInstance(colored_formatted, ColorString)
+        self.assertEqual(colored_formatted._color, 'red')  # pylint: disable=protected-access
+        self.assertEqual(colored_formatted._string, orig_formatted)  # pylint: disable=protected-access
+
+    def test_concatenation_postfix(self):
+        self.assert_colored(
+            ColorString('a', color='red') + 'b',
+            colorama.Fore.RED + 'a' + colorama.Fore.RESET + 'b',
+            'ab'
+        )
+
+    def test_concatenation_prefix(self):
+        self.assert_colored(
+            'a' + ColorString('b', color='red'),
+            'a' + colorama.Fore.RED + 'b' + colorama.Fore.RESET,
+            'ab'
+        )
+
+    def test_complex_concatenation(self):
+        self.assert_colored(
+            'this is ' +
+            ColorString('a message', color='red') + ' to be colored',
+            'this is ' + colorama.Fore.RED + 'a message' +
+            colorama.Fore.RESET + ' to be colored',
+            'this is a message to be colored'
+        )
+
+    def assert_colored(self, s, colored, uncolored):
+        self.assertIsInstance(s, ColorStringBase)
+        self.assertEqual(str(s), str(uncolored))
+        self.assertEqual(repr(s), repr(uncolored))
+        self.assertEqual(s.get_colored(), colored)
diff --git a/tests/test_console_log_truncation.py b/tests/test_console_log_truncation.py
new file mode 100755
index 0000000000..ce91fc2643
--- /dev/null
+++ b/tests/test_console_log_truncation.py
@@ -0,0 +1,29 @@
+# pylint: disable=redefined-outer-name
+import logbook
+
+import pytest
+import slash
+from slash._compat import StringIO
+
+
+@pytest.mark.parametrize('use_truncation', [True, False])
+def test_line_truncation(long_text, use_truncation, config_override):
+
+    config_override('log.truncate_console_lines', use_truncation)
+    config_override('log.console_level', logbook.DEBUG)
+
+    console = StringIO()
+
+    with slash.Session(console_stream=console):
+        logbook.debug(long_text)
+
+    if use_truncation:
+        assert long_text not in console.getvalue()
+        assert long_text[:20] in console.getvalue()
+    else:
+        assert long_text in console.getvalue()
+
+
+@pytest.fixture
+def long_text():
+    return 'a' * 200
diff --git a/tests/test_console_reporter.py b/tests/test_console_reporter.py
new file mode 100755
index 0000000000..80c5a7b82c
--- /dev/null
+++ b/tests/test_console_reporter.py
@@ -0,0 +1,67 @@
+import logbook
+import pytest
+
+from slash._compat import StringIO
+from slash.reporting.console_reporter import ConsoleReporter
+
+
+@pytest.mark.parametrize('console_level', [True, False])  # pylint: disable=redefined-outer-name
+def test_console_reporter(suite, level, config_override, console_level):  # pylint: disable=redefined-outer-name
+    config_override('log.color_console', console_level)
+    config_override('log.console_level', level)
+    summary = suite.run()
+    suite.add_test().when_run.raise_exception()
+    output = summary.get_console_output()
+    assert output
+    assert bool(console_level) == ('\x1b' in output)
+
+
+def test_silence_manual_errors(suite, suite_test, config_override):
+    suite_test.append_line('slash.add_error("msg")')
+    suite_test.expect_error()
+    config_override('log.show_manual_errors_tb', False)
+    output = suite.run().get_console_output()
+    assert 'slash.add_error' not in output
+
+
+def test_num_collected_printed_once(suite, suite_test):  # pylint: disable=unused-argument
+    assert len(suite) > 1
+    output = suite.run().get_console_output()
+    assert output.count('collected') == 1
+
+
+@pytest.mark.parametrize('long_headline', [True, False])
+@pytest.mark.parametrize('multiline', [True, False])
+def test_fancy_message(long_headline, multiline):
+    output = StringIO()
+    reporter = ConsoleReporter(logbook.TRACE, output)
+    headline = 'some headline here'
+    if long_headline:
+        headline *= 80
+    message = 'some message here'
+
+    repetitions = 5
+    if multiline:
+        message = "\n".join(message for i in range(repetitions))
+        message += '\n\n'
+
+    reporter.report_fancy_message(headline, message)
+    if long_headline:
+        assert headline[:80] in output.getvalue()
+    else:
+        assert headline in output.getvalue()
+
+    if multiline:
+        assert output.getvalue().count(message.splitlines()[0]) == repetitions
+    else:
+        assert output.getvalue().count(message) == 1
+
+
+@pytest.fixture(params=list(range(logbook.DEBUG, logbook.CRITICAL + 1)))
+def level(request):
+    return request.param
+
+
+@pytest.fixture
+def stream():
+    return StringIO()
diff --git a/tests/test_context.py b/tests/test_context.py
new file mode 100755
index 0000000000..ef69aca51c
--- /dev/null
+++ b/tests/test_context.py
@@ -0,0 +1,150 @@
+# pylint: disable=redefined-outer-name
+import pytest
+import slash
+from slash import ctx, context, Session
+from slash.ctx import Context, ContextAttributeProxy
+from slash.reporting.null_reporter import NullReporter
+
+
+@pytest.mark.parametrize('on_stack', [True, False])
+def test_context_dir_method_loaded_context(loaded_context, on_stack):
+    output = dir(context if on_stack else loaded_context)
+    assert 'test_id' in output
+
+
+def test_context_dir_no_context_loaded():
+    assert 'test_id' in dir(context)
+
+
+def test_null_context_cant_setattr():
+    with pytest.raises(AttributeError):
+        context.x = 2
+    assert not hasattr(context, 'x')
+
+
+def test_dir_object(loaded_context, queried_context):
+    class Object(object):
+        x = 2
+        y = 3
+    loaded_context.test_id = obj = Object()
+    assert dir(queried_context.test_id) == dir(obj)
+
+
+def test_call_object(loaded_context, queried_context):
+    value = 'some value'
+
+    def func():
+        return value
+    loaded_context.test_id = func
+
+    assert queried_context.test_id() == value
+
+
+def test_null_context():
+    assert context.test_id is None
+    assert context.result is None
+
+
+def test_no_session_session_id(loaded_context):
+    assert loaded_context.session_id is None
+
+
+def test_no_session_reporter(loaded_context):
+    assert isinstance(loaded_context.reporter, NullReporter)
+
+
+def test_no_test_test_filename(loaded_context):
+    assert loaded_context.test_filename is None
+
+
+def test_session_context_result():
+    with Session() as s:
+        assert context.session is s
+        assert context.result is s.results.global_result
+
+
+def test_context_test_filename(suite, suite_test):
+    suite_test.append_line('assert slash.context.test_filename == slash.context.test.__slash__.file_path')
+    suite.run()
+
+
+def test_test_context_result(suite):
+    for test in suite:
+        test.append_line('assert slash.context.result is slash.session.results[slash.context.test]')
+
+    @slash.hooks.result_summary.register  # pylint: disable=no-member
+    def assert_result_back_to_normal():  # pylint: disable=unused-variable
+        assert context.result is context.session.results.global_result
+
+    assert suite.run().ok()
+
+
+def test_cannot_pop_bottom():
+    assert len(context._stack) == 1  # pylint: disable=protected-access
+    with pytest.raises(RuntimeError):
+        context.pop()
+
+
+def test_push_context(loaded_context):
+    test_id = loaded_context.test_id = "some_test_id"
+    assert context.test_id == test_id
+
+
+def test_object_proxy_getattr(contextobj, realobj):
+    assert contextobj.attr is realobj.attr
+    assert contextobj.__attr__ is realobj.__attr__
+    assert not hasattr(contextobj, "nonexisting")
+    assert not hasattr(contextobj, "__nonexisting__")
+
+
+def test_object_proxy_eq(contextobj, realobj):
+    assert contextobj == realobj
+
+
+def test_object_proxy_ne(contextobj, realobj):
+    assert not (contextobj != realobj)  # pylint: disable=superfluous-parens
+
+
+def test_object_proxy_str_repr(contextobj, realobj):
+    assert str(contextobj) == str(realobj)
+    assert repr(contextobj) == repr(realobj)
+
+
+@pytest.fixture
+def contextobj(loaded_context, realobj):
+    setattr(loaded_context, "obj", realobj)
+    return ContextAttributeProxy("obj")
+
+
+@pytest.fixture
+def realobj():
+    class Object(object):
+
+        __attr__ = object()
+        attr = object()
+
+    return Object()
+
+
+@pytest.fixture
+def loaded_context():
+    returned = Context()
+    context.push(returned)
+    return returned
+
+
+@pytest.fixture(autouse=True, scope="function")
+def pop_all(request):
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        while len(context._stack) > 1:  # pylint: disable=protected-access
+            context.pop()
+
+@pytest.fixture(params=['global', 'proxy'])
+def queried_context(request):
+    if request.param == 'global':
+        return context
+    elif request.param == 'proxy':
+        return ctx
+    else:
+        raise NotImplementedError() # pragma: no cover
diff --git a/tests/test_coverage_plugin.py b/tests/test_coverage_plugin.py
new file mode 100755
index 0000000000..e7d1e42e7e
--- /dev/null
+++ b/tests/test_coverage_plugin.py
@@ -0,0 +1,51 @@
+# pylint: disable=redefined-outer-name,unused-argument
+import sys
+import pytest
+import coverage
+
+import slash.plugins
+
+
+@pytest.mark.skipif(hasattr(sys, 'pypy_version_info'), reason='Cannot run on pypy')
+def test_coverage_plugin(suite, enabled_coverage_plugin, config_override, report_type):
+    config_override('plugin_config.coverage.report', True)
+    config_override('plugin_config.coverage.report_type', report_type)
+    suite.run()
+
+def test_invalid_report_type(config_override):
+    config_override('plugin_config.coverage.report_type', 'bla')
+    with pytest.raises(RuntimeError) as exc:
+        slash.plugins.manager.activate('coverage')
+    assert 'Unknown report type' in str(exc.value)
+
+
+@pytest.fixture
+def enabled_coverage_plugin(request, patched_coverage, config_override, should_append, report_type):
+    config_override('plugin_config.coverage.report', False)
+    config_override('plugin_config.coverage.append', should_append)
+    config_override('plugin_config.coverage.report_type', report_type)
+    slash.plugins.manager.activate('coverage')
+
+    @request.addfinalizer
+    def deactivate():  # pylint: disable=unused-variable
+        slash.plugins.manager.deactivate('coverage')
+
+
+@pytest.fixture(params=[True, False])
+def should_append(request):
+    return request.param
+
+
+@pytest.fixture(params=['html', 'xml', 'html,xml'])
+def report_type(request):
+    return request.param
+
+
+@pytest.yield_fixture
+def patched_coverage(forge):
+    forge.replace_with(coverage.Coverage, 'start', lambda self: None)
+    forge.replay()
+    try:
+        yield
+    finally:
+        forge.restore_all_replacements()
diff --git a/tests/test_cyclic_fixture_detection.py b/tests/test_cyclic_fixture_detection.py
new file mode 100755
index 0000000000..ddf8a63846
--- /dev/null
+++ b/tests/test_cyclic_fixture_detection.py
@@ -0,0 +1,31 @@
+import re
+
+
+def test_cyclic_fixture_detection(suite, suite_test):
+    fixture1 = suite.slashconf.add_fixture()
+    fixture2 = suite.slashconf.add_fixture()
+    fixture1.depend_on_fixture(fixture2)
+    fixture2.depend_on_fixture(fixture1)
+
+    suite_test.depend_on_fixture(fixture1)
+    for test in suite:
+        test.expect_deselect() # no test should start at all....
+
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.session.results.global_result.is_success()
+    assert re.search(r'yclic fixture dependency detected in \S+: {0} -> {1} -> {0}'.format(fixture1.name, fixture2.name),
+                     summary.get_console_output())
+
+
+def test_cyclic_fixture_detection_depend_on_self(suite, suite_test):
+    fixture = suite.slashconf.add_fixture()
+    fixture.depend_on_fixture(fixture)
+
+    suite_test.depend_on_fixture(fixture)
+    for test in suite:
+        test.expect_deselect() # no test should start at all...
+
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.session.results.global_result.is_success()
+    assert re.search(r'yclic fixture dependency detected in \S+: {0} depends on itself'.format(fixture.name),
+                     summary.get_console_output())
diff --git a/tests/test_debugging.py b/tests/test_debugging.py
new file mode 100755
index 0000000000..d12c65c655
--- /dev/null
+++ b/tests/test_debugging.py
@@ -0,0 +1,44 @@
+# pylint: disable=redefined-outer-name
+import sys
+
+import pytest
+
+import slash
+from slash.exceptions import INTERRUPTION_EXCEPTIONS
+from slash.utils import debug
+
+
+def test_debug_if_needed_regular_exception(replaced_checkpoint, exc_info, debug_enabled):  # pylint: disable=unused-argument
+    with slash.Session():
+        debug.debug_if_needed(exc_info)
+    assert replaced_checkpoint.called
+
+def test_debug_if_needed_not_called(replaced_checkpoint, skipped_exc_info, debug_enabled):  # pylint: disable=unused-argument
+    with slash.Session():
+        debug.debug_if_needed(skipped_exc_info)
+    assert not replaced_checkpoint.called
+
+
+@pytest.fixture
+def debug_enabled(config_override):
+    config_override('debug.enabled', True)
+
+
+@pytest.fixture(params=(SystemExit,) + INTERRUPTION_EXCEPTIONS)
+def skipped_exc_info(request):
+    try:
+        raise request.param()
+    except:
+        return sys.exc_info()
+
+@pytest.fixture
+def exc_info():
+    try:
+        1/0
+    except:
+        return sys.exc_info()
+
+@pytest.fixture
+def replaced_checkpoint(checkpoint, forge):
+    forge.replace_with(debug, 'launch_debugger', checkpoint)
+    return checkpoint
diff --git a/tests/test_doctests.py b/tests/test_doctests.py
new file mode 100755
index 0000000000..bdb1e425c5
--- /dev/null
+++ b/tests/test_doctests.py
@@ -0,0 +1,28 @@
+from __future__ import print_function
+
+import doctest
+import os
+
+import pytest
+import slash
+
+_HERE = os.path.abspath(os.path.dirname(__file__))
+_DOCS_ROOT = os.path.abspath(os.path.join(_HERE, "..", "doc"))
+
+
+def test_sphinx_doctest(doctest_path):  # pylint: disable=redefined-outer-name
+    globs = {'print_function': print_function, 'slash': slash}
+    result = doctest.testfile(doctest_path, module_relative=False, globs=globs)
+    assert not result.failed
+
+assert os.path.exists(_DOCS_ROOT)
+_DOCTEST_PATHS = list(os.path.join(path, filename)
+                      for path, _, filenames in os.walk(_DOCS_ROOT)
+                      for filename in filenames
+                      if filename.endswith(".rst"))
+_README_PATH = os.path.join(_HERE, '..', 'README.md')
+
+
+@pytest.fixture(params=_DOCTEST_PATHS + [_README_PATH])
+def doctest_path(request):
+    return request.param
diff --git a/tests/test_error_object.py b/tests/test_error_object.py
new file mode 100755
index 0000000000..5752eee1e5
--- /dev/null
+++ b/tests/test_error_object.py
@@ -0,0 +1,169 @@
+# pylint: disable=redefined-outer-name,unused-variable
+import json
+import os
+import types
+
+import emport
+
+import dessert
+import pytest
+from slash.core.error import Error
+
+from .utils import without_pyc
+
+
+def test_error_exception_str_repr(error):
+    assert "NotImplementedError" in str(error)
+    assert "NotImplementedError" in repr(error)
+
+
+def test_error_filename(error):
+    assert error.filename == without_pyc(os.path.abspath(__file__))
+
+
+def test_error_func_name(error):
+    assert error.func_name == "func_3"
+
+
+def test_code_string(error):
+    assert error.cause.code_line == "    raise NotImplementedError()"
+    assert error.cause.code_string == """def func_3():
+
+    local_func_3 = global_func_3
+    raise NotImplementedError()\n"""
+
+
+def test_error_exc_info(error):
+    assert error.exc_info is not None
+    assert isinstance(error.exc_info, tuple)
+    assert error.exc_info[0] is NotImplementedError
+    assert isinstance(error.exc_info[1], NotImplementedError)
+    assert isinstance(error.exc_info[2], types.TracebackType)
+
+
+def test_error_forget_exc_info(error):
+    error.forget_exc_info()
+    assert error.exc_info is None
+
+
+def test_error_exc_info_forgotten_by_default(suite, suite_test):
+    suite_test.when_run.error()
+    res = suite.run()[suite_test]
+    [err] = res.get_errors()
+    assert err.exc_info is None
+
+
+def test_error_frame_objects(error):
+    assert error.traceback.frames
+    for f in error.traceback.frames:
+        assert isinstance(f.python_frame, types.FrameType)
+
+
+def test_error_frame_objects_forgotten_by_default(suite, suite_test):
+    suite_test.when_run.error()
+    res = suite.run()[suite_test]
+    [err] = res.get_errors()
+    assert err.traceback.frames
+    for frame in err.traceback.frames:
+        assert frame.python_frame is None
+
+
+def test_to_list(error):
+    serialized = error.traceback.to_list()
+    assert serialized[-3]['func_name'] == 'func_1'
+    # Just make sure that it's serializable
+    json.dumps(serialized)
+
+
+def test_capture_exception_twice_caches_object():
+    try:
+        try:
+            raise RuntimeError()
+        except RuntimeError:
+            err1 = Error.capture_exception()
+            raise
+    except RuntimeError:
+        err2 = Error.capture_exception()
+
+    assert err1 is err2
+
+
+def test_error_is_fatal(error):
+    assert not error.is_fatal()
+
+
+def test_error_mark_fatal(error):
+    rv = error.mark_fatal()
+    assert rv is error
+    assert error.is_fatal()
+
+####
+
+
+@pytest.fixture
+def error():
+    try:
+        func_1()
+    except:
+        return Error.capture_exception()
+    else:
+        assert False, "Did not fail"
+
+
+@pytest.fixture
+def non_exception_error():
+    def func1():
+        return func2()
+
+    def func2():
+        return Error('some_error')
+
+    err = func1()
+    return err
+
+
+global_func_1 = "global_func_1"
+global_func_2 = "global_func_2"
+global_func_3 = "global_func_3"
+
+
+def func_1():
+    local_func_1 = global_func_1
+
+    func_2()
+
+
+def func_2():
+    local_func_2 = global_func_2
+
+    func_3()
+
+
+def func_3():
+
+    local_func_3 = global_func_3
+    raise NotImplementedError()
+
+
+@pytest.fixture
+def assertion_error(tmpdir):
+    filename = tmpdir.join("file.py")
+    filename.write("""
+def f(x):
+    return x
+
+def g(x):
+    return x
+
+def func():
+    assert f(g(1)) == g(f(2))""")
+
+    with dessert.rewrite_assertions_context():
+        module = emport.import_file(str(filename))
+
+    try:
+        module.func()
+    except:
+        return Error.capture_exception()
+    else:
+        assert False, "Did not fail"
diff --git a/tests/test_error_object_stack_trace.py b/tests/test_error_object_stack_trace.py
new file mode 100755
index 0000000000..c5a64c4a5b
--- /dev/null
+++ b/tests/test_error_object_stack_trace.py
@@ -0,0 +1,59 @@
+# pylint: disable=pointless-statement,redefined-outer-name
+import pytest
+import slash
+
+
+def test_frame_order(error, use_exception):
+    code_line = error.traceback.frames[-1].code_line.strip()
+    if use_exception:
+        assert code_line == '1 / 0'
+    else:
+        assert code_line == 'get_error_adder()("error message")'
+
+
+@pytest.fixture
+def error(get_error_adder, use_exception):
+
+    def f1():
+        obj = ExampleObject()
+        try:
+            obj.method1()
+        except ZeroDivisionError:
+            assert use_exception
+            get_error_adder()()
+
+
+
+    class ExampleObject(object):
+
+        def __init__(self):
+            self.a = 1
+            self.b = 2
+
+        def method1(self):
+            g1()
+
+
+    def g1():
+        h1()
+
+    def h1():
+        if use_exception:
+            1 / 0
+        else:
+            get_error_adder()("error message")
+
+    with slash.Session() as s:
+        f1()
+    [err] = s.results.global_result.get_errors()
+    return err
+
+
+@pytest.fixture(params=[lambda: slash.add_error, lambda: slash.context.result.add_error])
+def get_error_adder(request):
+    return request.param
+
+
+@pytest.fixture(params=[True, False])
+def use_exception(request):
+    return request.param
diff --git a/tests/test_exception_attributes.py b/tests/test_exception_attributes.py
new file mode 100755
index 0000000000..1bcd85d089
--- /dev/null
+++ b/tests/test_exception_attributes.py
@@ -0,0 +1,38 @@
+import sys
+import pytest
+
+from slash.core.error import Error
+from .utils import Unprintable
+
+
+def test_exception_attributes(error):  # pylint: disable=redefined-outer-name, unused-argument
+    attrs = error.exception_attributes
+    assert attrs['x'] == 2
+    assert isinstance(attrs['y'], str)
+
+
+def test_exception_attributes_with_message():
+    assert Error('x').exception_attributes is None
+
+
+@pytest.fixture
+def error():
+
+    class MyException(Exception):
+
+        def __init__(self):
+            super(MyException, self).__init__()
+            self.x = 2
+            self.y = [str(i) for i in range(10)]
+            self.d = {'some': 'dict', 'here': 'too'}
+            self.unprintable = Unprintable()
+
+    def func():
+        raise MyException()
+
+    try:
+        func()
+    except MyException:
+        return Error(exc_info=sys.exc_info())
+    else:
+        assert False, 'Did not raise'
diff --git a/tests/test_exception_handling.py b/tests/test_exception_handling.py
new file mode 100755
index 0000000000..76be16a6fa
--- /dev/null
+++ b/tests/test_exception_handling.py
@@ -0,0 +1,291 @@
+import sys
+import gossip
+import pytest
+import inspect
+import traceback
+import slash
+import logbook
+from slash import exception_handling
+from slash._compat import ExitStack, PYPY
+from slash.exceptions import SkipTest, ExpectedExceptionNotCaught
+from slash.utils import debug
+
+from .utils import CustomException, TestCase
+
+
+def test_handling_exceptions_swallow_skip_test(suite, suite_test):
+
+    @suite_test.append_body
+    def __code__():             # pylint: disable=unused-variable
+        from slash.exception_handling import handling_exceptions
+        with handling_exceptions(swallow=True):
+            slash.skip_test()
+        __ut__.events.add('NEVER') # pylint: disable=undefined-variable
+
+    suite_test.expect_skip()
+
+    summary = suite.run()
+    assert not summary.events.has_event('NEVER')
+
+
+def test_handling_exceptions_skip_test_would_not_return_skip_test():
+    with pytest.raises(SkipTest) as caught:
+        with slash.Session():
+            with exception_handling.handling_exceptions() as handled:
+                raise SkipTest('Unittest')
+
+    assert isinstance(caught.value, SkipTest)
+    assert handled.exception is caught.value
+    assert exception_handling.is_exception_handled(caught.value)
+
+
+def test_passthrough_types():
+
+    value = CustomException()
+
+    with slash.Session():
+        with pytest.raises(CustomException) as caught:
+            with exception_handling.handling_exceptions(passthrough_types=(CustomException,)) as handled:
+                raise value
+    assert value is caught.value
+    assert handled.exception is None
+    assert not exception_handling.is_exception_handled(value)
+
+    with slash.Session():
+        with pytest.raises(CustomException) as caught:
+            with exception_handling.handling_exceptions(passthrough_types=(AttributeError,)) as handled:
+                raise value
+    assert value is caught.value
+    assert handled.exception is value
+    assert exception_handling.is_exception_handled(value)
+
+
+def test_swallow_types():
+    value = CustomException()
+
+    with slash.Session():
+        with exception_handling.handling_exceptions(swallow_types=(CustomException,)) as handled:
+            raise value
+    assert sys.exc_info() == exception_handling.NO_EXC_INFO
+    assert handled.exception is value
+
+
+class FakeTracebackTest(TestCase):
+    def setUp(self):
+        super(FakeTracebackTest, self).setUp()
+        self.override_config("debug.enabled", True)
+        self.forge.replace_with(debug, "launch_debugger", self.verify_fake_traceback_debugger)
+        self.debugger_called = False
+        self._tb_len = 0
+
+    @pytest.mark.skipif(PYPY, reason='Cannot run on PyPy')
+    def test_fake_traceback(self):
+        with slash.Session(), pytest.raises(ZeroDivisionError):
+            with exception_handling.handling_exceptions(fake_traceback=False):
+                self._expected_line_number = inspect.currentframe().f_lineno + 1
+                a = 1 / 0
+                return a
+
+        with slash.Session(), pytest.raises(ZeroDivisionError):
+            with exception_handling.handling_exceptions():
+                self._expected_line_number = inspect.currentframe().f_lineno + 1
+                a = 1 / 0
+                return a
+
+    def verify_fake_traceback_debugger(self, exc_info):
+        assert traceback.extract_tb(exc_info[2])[-1][1] == self._expected_line_number
+        if not self._tb_len:
+            # First attempt, no fake traceback
+            self._tb_len = self._get_tb_len(exc_info[2])
+            assert self._tb_len != 0
+        else:
+            # Second attempt, with fake traceback
+            assert self._tb_len < self._get_tb_len(exc_info[2])
+
+    def _get_tb_len(self, tb):
+        tb_len = 0
+        while tb:
+            tb_len += 1
+            tb = tb.tb_next
+        return tb_len
+
+
+def test_handling_exceptions():
+    value = CustomException()
+
+    with slash.Session(), pytest.raises(CustomException) as caught:
+        with exception_handling.handling_exceptions() as handled1:
+            with exception_handling.handling_exceptions() as handled2:
+                with exception_handling.handling_exceptions() as handled3:
+                    raise value
+
+    assert caught.value is value
+    assert handled1.exception is value
+    assert handled2.exception is value
+    assert handled3.exception is value
+
+
+@pytest.mark.skipif(sys.version_info >= (3, 0), reason='Cannot run on 3.x')
+def test_reraise_after_exc_info_reset():
+    @gossip.register('slash.exception_caught_before_debugger')
+    def exception_hook():       # pylint: disable=unused-variable
+        sys.exc_clear()  # pylint: disable=no-member
+
+    with slash.Session(), pytest.raises(CustomException):
+        with exception_handling.handling_exceptions():
+            raise CustomException()
+
+
+
+class DebuggingTest(TestCase):
+
+    def setUp(self):
+        super(DebuggingTest, self).setUp()
+        self.forge.replace_with(debug, "launch_debugger", self.dummy_debugger)
+        self.debugger_called = False
+
+    def dummy_debugger(self, *args, **kwargs):  # pylint: disable=unused-argument
+        self.debugger_called = True
+
+    def test_debugging_not_configured(self):
+        self._raise_exception_in_context(ZeroDivisionError)
+        self.assertFalse(self.debugger_called)
+
+    def test_debugging_configured_no_skips(self):
+        self.override_config("debug.debug_skips", False)
+        self.override_config("debug.enabled", True)
+        self._raise_exception_in_context(SkipTest)
+        self.assertFalse(self.debugger_called)
+
+    def test_debugging_skips(self):
+        self.override_config("debug.debug_skips", True)
+        self.override_config("debug.enabled", True)
+        self._raise_exception_in_context(SkipTest)
+        self.assertTrue(self.debugger_called)
+
+    def _raise_exception_in_context(self, exception_type):
+        with slash.Session(), self.assertRaises(exception_type):
+            with exception_handling.handling_exceptions():
+                raise exception_type()
+
+
+def test_swallow_exceptions():
+    with exception_handling.get_exception_swallowing_context():
+        raise CustomException("!!!")
+
+
+def test_no_swallow():
+    raised = CustomException()
+    with pytest.raises(CustomException) as caught:
+        with exception_handling.get_exception_swallowing_context():
+            raise exception_handling.noswallow(raised)
+    assert raised is caught.value
+
+
+def test_disable_exception_swallowing_function():
+    raised = CustomException()
+    with pytest.raises(CustomException) as caught:
+        with exception_handling.get_exception_swallowing_context():
+            exception_handling.disable_exception_swallowing(raised)
+            raise raised
+    assert caught.value is raised
+
+
+def test_disable_exception_swallowing_decorator():
+    raised = CustomException()
+    @exception_handling.disable_exception_swallowing
+    def func():
+        raise raised
+    with pytest.raises(CustomException) as caught:
+        with exception_handling.get_exception_swallowing_context():
+            func()
+    assert caught.value is raised
+
+
+@pytest.mark.parametrize('message', [None, 'My custom message'])
+@pytest.mark.parametrize('exc_types', [CustomException, (CustomException, ZeroDivisionError)])
+def test_assert_raises(exc_types, message):
+    raised = CustomException()
+    with slash.Session():
+        with slash.assert_raises(exc_types, msg=message) as caught:
+            raise raised
+    assert sys.exc_info() == exception_handling.NO_EXC_INFO
+    assert caught.exception is raised
+
+
+@pytest.mark.parametrize('message', [None, 'My custom message'])
+def test_assert_raises_that_not_raises(message):
+    expected_substring = message or 'not raised'
+    try:
+        with slash.assert_raises(CustomException, msg=message):
+            pass
+    except ExpectedExceptionNotCaught as e:
+        assert expected_substring in str(e)
+        assert e.expected_types == (CustomException,)
+    else:
+        raise Exception('ExpectedExceptionNotCaught exception was not raised :(')
+
+
+@pytest.mark.parametrize('with_session', [True, False])
+def test_handling_exceptions_inside_assert_raises_with_session(with_session):
+    value = CustomException()
+
+    with ExitStack() as ctx:
+
+        if with_session:
+            session = ctx.enter_context(slash.Session())
+            ctx.enter_context(session.get_started_context())
+        else:
+            session = None
+
+        with slash.assert_raises(CustomException):
+            with exception_handling.handling_exceptions():
+                raise value
+
+    assert not exception_handling.is_exception_handled(value)
+    if with_session:
+        assert session.results.get_num_errors() == 0
+
+
+@pytest.mark.parametrize('message', [None, 'My custom message'])
+@pytest.mark.parametrize('exc_types', [CustomException, (CustomException, ZeroDivisionError)])
+def test_allowing_exceptions(exc_types, message):
+    raised = CustomException()
+    with slash.Session():
+        with slash.allowing_exceptions(exc_types, msg=message) as caught:
+            with logbook.TestHandler() as handler:
+                raise raised
+    assert sys.exc_info() == exception_handling.NO_EXC_INFO
+    assert caught.exception is raised
+    assert len(handler.records) == 0  # pylint: disable=len-as-condition
+
+
+def test_allowing_exceptions_that_not_raises():
+    with logbook.TestHandler() as handler:
+        with slash.allowing_exceptions((Exception, CustomException)):
+            pass
+    assert len(handler.records) == 1
+    assert handler.records[0].message.startswith("Exception/CustomException not raised")
+
+
+@pytest.mark.parametrize('with_session', [True, False])
+def test_handling_exceptions_inside_allowing_exceptions_with_session(with_session):
+    value = CustomException()
+
+    with ExitStack() as ctx:
+
+        if with_session:
+            session = ctx.enter_context(slash.Session())
+            ctx.enter_context(session.get_started_context())
+        else:
+            session = None
+
+        with logbook.TestHandler() as handler:
+            with slash.allowing_exceptions(CustomException):
+                with exception_handling.handling_exceptions():
+                    raise value
+
+    assert not exception_handling.is_exception_handled(value)
+    if with_session:
+        assert session.results.get_num_errors() == 0
+    assert len(handler.records) == 0  # pylint: disable=len-as-condition
diff --git a/tests/test_exception_marks.py b/tests/test_exception_marks.py
new file mode 100755
index 0000000000..0efc83c572
--- /dev/null
+++ b/tests/test_exception_marks.py
@@ -0,0 +1,27 @@
+from slash.utils.exception_mark import ExceptionMarker, mark_exception, get_exception_mark
+
+def test_marker():
+    exc = AttributeError()
+    marker = ExceptionMarker('mark')
+    assert not marker.is_exception_marked(exc)
+    marker.mark_exception(exc)
+    assert marker.is_exception_marked(exc)
+
+
+def test_marker_mark_returns_exception():
+    exc = AttributeError()
+    assert ExceptionMarker('mark').mark_exception(exc) is exc
+    assert ExceptionMarker('mark').is_exception_marked(exc)
+
+def test_marker_class():
+
+    class CustomException(Exception):
+        pass
+    mark_exception(CustomException, 'a', 'b')
+    assert get_exception_mark(CustomException, 'a') == 'b'
+
+    e = CustomException()
+    mark_exception(e, 'c', 'd')
+    assert get_exception_mark(e, 'a') == 'b'
+    assert get_exception_mark(e, 'c') == 'd'
+    assert get_exception_mark(CustomException, 'c') is None
diff --git a/tests/test_ext_hook.py b/tests/test_ext_hook.py
new file mode 100755
index 0000000000..c27d512a34
--- /dev/null
+++ b/tests/test_ext_hook.py
@@ -0,0 +1,29 @@
+from .utils import TestCase
+import itertools
+import os
+import sys
+
+_module_name_generator = ("custom_module_{0}".format(x) for x in itertools.count())
+
+class ExtHookTest(TestCase):
+    def setUp(self):
+        super(ExtHookTest, self).setUp()
+        self.path = self.get_new_path()
+        self.addCleanup(setattr, sys, "path", list(sys.path))
+        sys.path.insert(0, self.path)
+        self.expected_value = 31337
+        self.module_name = next(_module_name_generator)
+
+        with open(os.path.join(self.path, "slash_{0}.py".format(self.module_name)), "w") as f:
+            f.write("value = {0!r}".format(self.expected_value))
+
+    def test_ext_hook_import(self):
+        module = __import__("slash.ext.{0}".format(self.module_name), fromlist=[''])
+        self.assertEqual(module.value, self.expected_value)
+
+    def test_slash_ext(self):
+        from slash import ext   # pylint: disable=unused-variable
+
+    def test_ext_hook_import_nonexistent(self):
+        with self.assertRaises(ImportError):
+            from slash.ext import nonexistent  # pylint: disable=unused-variable, no-name-in-module
diff --git a/tests/test_factory_information.py b/tests/test_factory_information.py
new file mode 100755
index 0000000000..84125aadbc
--- /dev/null
+++ b/tests/test_factory_information.py
@@ -0,0 +1,82 @@
+# pylint: disable=redefined-outer-name
+import pytest
+
+import slash
+from slash.core.function_test import FunctionTestFactory
+from slash.core.test import TestTestFactory
+
+
+def test_factory_name(factory, expected_factory_name):
+    assert factory.get_factory_name() == expected_factory_name
+
+def test_module_name(factory, expected_module_name):
+    assert factory.get_module_name() == expected_module_name
+
+def test_filename(factory, expected_filename):
+    assert factory.get_filename() == expected_filename
+
+################################################################################
+
+@pytest.fixture  # pylint: disable=unused-argument
+def factory(explicit, factory_class, factory_param):  # pylint: disable=unused-argument
+    returned = factory_class(factory_param)
+    return returned
+
+@pytest.fixture
+def expected_factory_name(factory, explicit, factory_param):
+    if explicit:
+        returned = 'SomeFactoryNameHere'
+        factory.set_factory_name(returned)
+        return returned
+    else:
+        return factory_param.__name__
+
+@pytest.fixture
+def expected_filename(factory, explicit):
+    if explicit:
+        returned = 'some_nonexisting_file.py'
+        factory.set_filename(returned)
+        return returned
+    else:
+        returned = __file__
+        if returned.endswith('.pyc'):
+            returned = returned[:-1]
+        return returned
+
+@pytest.fixture
+def expected_module_name(factory, explicit):
+    if explicit:
+        returned = 'some_module'
+        factory.set_module_name(returned)
+        return returned
+    else:
+        returned = __name__
+        return returned
+
+
+@pytest.fixture(params=[True, False])
+def explicit(request):
+    return request.param
+
+@pytest.fixture(params=[FunctionTestFactory, TestTestFactory])
+def factory_class(request):
+    return request.param
+
+@pytest.fixture
+def factory_param(factory_class):
+    if factory_class is FunctionTestFactory:
+        def test_something():
+            pass
+
+        return test_something
+    elif factory_class is TestTestFactory:
+
+        class ExampleTest(slash.Test):
+
+            def test_something(self):
+                pass
+
+        return ExampleTest
+
+    else:
+        raise NotImplementedError("Unknown factory class")
diff --git a/tests/test_facts.py b/tests/test_facts.py
new file mode 100755
index 0000000000..2da143d103
--- /dev/null
+++ b/tests/test_facts.py
@@ -0,0 +1,30 @@
+# pylint: disable=redefined-outer-name
+from uuid import uuid4
+
+import gossip
+
+import pytest
+
+
+def test_facts(suite, suite_test, fact_name, fact_value):
+
+    facts = []
+
+    @gossip.register('slash.fact_set')
+    def fact_set(name, value): # pylint: disable=unused-variable
+        facts.append((name, value))
+
+    suite_test.append_line('slash.context.result.facts.set({!r}, {!r})'.format(fact_name, fact_value))
+    res = suite.run()[suite_test]
+    assert res.facts.all() == {fact_name : fact_value}
+    assert facts == [(fact_name, fact_value)]
+
+
+@pytest.fixture
+def fact_name():
+    return 'some_fact'
+
+
+@pytest.fixture
+def fact_value():
+    return str(uuid4())
diff --git a/tests/test_failures.py b/tests/test_failures.py
new file mode 100755
index 0000000000..f7787e4802
--- /dev/null
+++ b/tests/test_failures.py
@@ -0,0 +1,70 @@
+import pytest
+
+import slash
+from .utils.suite_writer import Suite
+
+def test_failures_call_test_failure_hook(suite, suite_test, checkpoint):
+    suite_test.append_line('assert False')
+
+    @slash.hooks.test_failure.register  # pylint: disable=no-member
+    def callback(*_, **__):  # pylint: disable=unused-variable
+        checkpoint()
+
+    suite_test.expect_failure()
+    summary = suite.run()  # pylint: disable=unused-variable
+    assert checkpoint.called_count == 1
+
+@pytest.mark.parametrize('error_adder', ['add_error', 'add_failure'])
+def test_adding_errors(error_adder, test_type):
+
+    suite = Suite()
+    test = suite.add_test(type=test_type)
+
+    for i in range(2):
+        test.append_line('slash.{0}("msg{1}")'.format(error_adder, i))
+    test.append_line('slash.{0}(object())'.format(error_adder))
+
+    if error_adder == 'add_error':
+        test.expect_error()
+    else:
+        test.expect_failure()
+
+    results = suite.run().session.results
+
+    [test_result] = results.iter_test_results()
+
+    objs = test_result.get_errors() if error_adder == 'add_error' else test_result.get_failures()
+    assert len(objs) == 3
+
+    assert 'msg0' in objs[0].message
+    assert 'msg1' in objs[1].message
+    assert '<object object at 0x' in objs[2].message
+
+
+def test_add_failure_error_object_marked_as_failure():
+
+    with slash.Session() as s:
+        with s.get_started_context():
+            slash.add_failure('msg')
+        [failure] = slash.context.result.get_failures() # pylint: disable=unbalanced-tuple-unpacking
+    assert failure.is_failure()
+
+
+def test_manual_add_error_preserves_traceback(suite, suite_test):
+    suite_test.append_line('slash.add_error("error here")')
+    suite_test.expect_error()
+    summary = suite.run()
+
+    [result] = summary.get_all_results_for_test(suite_test)
+    [err] = result.get_errors()
+
+    assert err.traceback is not None
+
+def test_manual_add_error_requires_argument(suite, suite_test):
+    suite_test.append_line('slash.add_error()')
+    suite_test.expect_error()
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    [err] = result.get_errors()
+    assert 'RuntimeError' in str(err)
+    assert 'add_error() must be called' in str(err)
diff --git a/tests/test_fixture_annotations.py b/tests/test_fixture_annotations.py
new file mode 100755
index 0000000000..210fbee81b
--- /dev/null
+++ b/tests/test_fixture_annotations.py
@@ -0,0 +1,24 @@
+import pytest
+from .utils import skip_on_py2, skip_on_pypy
+
+@skip_on_py2
+@skip_on_pypy
+@pytest.mark.parametrize('alias_with_attribute', [True, False])
+def test_fixture_annotations(suite, suite_test, get_fixture_location, alias_with_attribute):
+
+    fixture = get_fixture_location(suite_test).add_fixture()
+    suite_test.depend_on_fixture(fixture, alias=True, alias_with_attribute=alias_with_attribute)
+
+    suite.run()
+
+@skip_on_py2
+@skip_on_pypy
+@pytest.mark.parametrize('alias_with_attribute', [True, False])
+def test_nested_fixture_annotations(suite, suite_test, get_fixture_location, alias_with_attribute):
+
+    fixture = get_fixture_location(suite_test).add_fixture()
+    fixture2 = get_fixture_location(suite_test).add_fixture()
+    fixture.depend_on_fixture(fixture2, alias=True, alias_with_attribute=alias_with_attribute)
+    suite_test.depend_on_fixture(fixture)
+
+    suite.run()
diff --git a/tests/test_fixture_exceptions.py b/tests/test_fixture_exceptions.py
new file mode 100755
index 0000000000..6589459ec2
--- /dev/null
+++ b/tests/test_fixture_exceptions.py
@@ -0,0 +1,24 @@
+import pytest
+
+
+@pytest.mark.parametrize('scope', ['test', 'session'])
+@pytest.mark.parametrize('use_skip', [True, False])
+def test_exceptions_in_fixture(suite, suite_test, scope, use_skip):
+    second_test = suite_test.file.add_function_test()
+
+    fixture = suite_test.file.add_fixture(scope=scope)
+    suite_test.depend_on_fixture(fixture)
+    second_test.depend_on_fixture(fixture)
+
+    if use_skip:
+        fixture.append_line('slash.skip_test()')
+    else:
+        fixture.append_line('assert False')
+
+    for test in suite_test, second_test:
+        if use_skip:
+            test.expect_skip()
+        else:
+            test.expect_failure()
+
+    suite.run()
diff --git a/tests/test_fixture_exclusion.py b/tests/test_fixture_exclusion.py
new file mode 100755
index 0000000000..a4fba8c47c
--- /dev/null
+++ b/tests/test_fixture_exclusion.py
@@ -0,0 +1,42 @@
+# pylint: disable=unused-variable, unused-argument
+import slash
+
+from .utils import resolve_and_run
+
+def test_fixture_exclusion():
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.parametrize('param', [1, 2])
+        @slash.fixture
+        def fixture(param):
+            return param * 10
+
+        @slash.exclude('fixture.param', [2])
+        def test_something(fixture):
+            slash.context.result.data['value'] = fixture
+
+        results = resolve_and_run(test_something)
+    assert len(results) == 2
+    assert results[0].is_success()
+    assert results[0].data['value'] == 10
+    assert results[1].is_skip()
+    assert not results[1].is_started()
+
+
+def test_fixture_exclusion_nested(suite, suite_test):
+
+    fixture = suite.slashconf.add_fixture()
+    param = fixture.add_parameter()
+    suite_test.depend_on_fixture(fixture)
+
+    param_value = param.values[0]
+
+    suite_test.add_decorator('slash.exclude("{fixture_name}.{param_name}", {values})'.format(
+        fixture_name=fixture.name,
+        param_name=param.name,
+        values=[param_value],
+    ))
+    suite_test.exclude_param_value(param.name, param_value)
+    suite.run()
diff --git a/tests/test_fixture_features.py b/tests/test_fixture_features.py
new file mode 100755
index 0000000000..0d1648bdc9
--- /dev/null
+++ b/tests/test_fixture_features.py
@@ -0,0 +1,18 @@
+import pytest
+
+
+def test_fixture_cleanup(suite, suite_test):
+    fixture = suite.slashconf.add_fixture()
+    for _ in range(3):
+        fixture.add_cleanup()
+    suite_test.depend_on_fixture(fixture)
+    suite.run()
+
+
+@pytest.mark.parametrize('scope', ['session', 'module'])
+def test_fixture_autouse_with_scoping(suite, suite_test, scope):
+
+    fixture = suite_test.file.add_fixture(autouse=True, scope=scope)
+    fixture.add_cleanup()
+
+    summary = suite.run()  # pylint: disable=unused-variable
diff --git a/tests/test_fixture_mechanism.py b/tests/test_fixture_mechanism.py
new file mode 100755
index 0000000000..9ced0c1078
--- /dev/null
+++ b/tests/test_fixture_mechanism.py
@@ -0,0 +1,552 @@
+# pylint: disable=unused-variable,redefined-outer-name,unused-argument
+import itertools
+from uuid import uuid1
+
+import pytest
+import slash
+from slash.exceptions import CyclicFixtureDependency, UnresolvedFixtureStore, UnknownFixtures, InvalidFixtureScope
+from slash.core.fixtures.parameters import bound_parametrizations_context, iter_parametrization_fixtures
+from slash.core.fixtures.fixture_store import FixtureStore
+from slash.utils.python import get_arguments
+
+
+def test_fixture_initialization_order_is_preserved(store):
+
+    _fixture = lambda f: store.add_fixture(slash.fixture(f))
+    generation = itertools.count(1)
+
+    @_fixture
+    def fixture1():
+        return next(generation)
+
+    @_fixture
+    def fixture2():
+        return next(generation)
+
+    @_fixture
+    def fixture3():
+        return next(generation)
+
+    store.resolve()
+    d = store.get_fixture_dict(['fixture1', 'fixture2', 'fixture3'])
+    for i in [1, 2, 3]:
+        assert d['fixture{0}'.format(i)] == i
+
+
+def test_fixture_id_remains_even_when_context_popped(store):
+
+    @slash.fixture
+    def fixture0():
+        pass
+
+    store.push_namespace()
+    store.add_fixture(fixture0)
+    store.resolve()
+
+    fixture_obj = store.get_fixture_by_name('fixture0')
+    assert fixture_obj.fixture_func is fixture0
+    fixture_id = fixture_obj.info.id
+    assert store.get_fixture_by_id(fixture_id) is fixture_obj
+
+    store.pop_namespace()
+
+    with pytest.raises(UnknownFixtures):
+        store.get_fixture_by_name('fixture0')
+
+    assert store.get_fixture_by_id(fixture_id) is fixture_obj
+
+
+def test_namespace_get_fixture_by_name_default(store):
+    obj = object()
+    assert store.get_current_namespace().get_fixture_by_name('nonexisting', default=obj) is obj
+
+
+def test_namespace_get_fixture_by_name_no_default(store):
+    ns = store.get_current_namespace()
+    with pytest.raises(UnknownFixtures):
+        ns.get_fixture_by_name('nonexisting')
+
+
+
+def test_variations_no_names(store):
+    assert list(store.iter_parametrization_variations([])) == [{}]
+
+
+def test_adding_fixture_twice_to_store(store):
+
+    @slash.fixture
+    def fixture0():
+        pass
+
+    store.add_fixture(fixture0)
+    fixtureobj = store.get_fixture_by_name('fixture0')
+    store.add_fixture(fixture0)
+    assert store.get_fixture_by_name('fixture0') is fixtureobj
+
+
+def test_fixture_store_namespace_repr(store):
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture0():
+        pass
+
+    ns = store.get_current_namespace()
+    assert str(ns) == repr(ns)
+    assert repr(ns) == 'Fixture NS#0: fixture0'
+
+
+def test_fixture_parameters(store):
+
+    @store.add_fixture
+    @slash.fixture
+    def value(x, a):
+        assert a == 'a', 'Fixture got unexpectedly overriden by parameter'
+        return x
+
+    @store.add_fixture
+    @slash.fixture
+    def a():
+        return 'a'
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('a', [1, 2, 3])
+    def x(a, b):
+        return (a, b)
+
+    @store.add_fixture
+    @slash.parametrize('b', [4, 5, 6])
+    @slash.fixture
+    def b(b):
+        return b
+
+    store.resolve()
+
+    variations = list(_get_all_values(store, 'value'))
+    assert set(variations) == set(itertools.product([1, 2, 3], [4, 5, 6]))
+
+
+def test_fixture_tuple_parameters(store):
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize(('a', 'b'), [(1, 2), (3, 4)])
+    def x(a, b):
+        return a + b
+
+    store.resolve()
+
+    variations = list(_get_all_values(store, 'x'))
+    assert variations == [3, 7]
+
+
+
+def test_variation_equality(store):
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('a', [1, 2, 3])
+    def fixture(a):
+        pass
+
+    store.resolve()
+
+    prev_variation = None
+    for variation in store.iter_parametrization_variations(fixture_ids=[store.get_fixture_by_name('fixture').info.id]):
+        assert variation == variation
+        assert not (variation != variation)  # pylint: disable=superfluous-parens
+        assert variation != prev_variation
+        assert not (variation == prev_variation)  # pylint: disable=superfluous-parens
+        prev_variation = variation
+
+
+def _get_all_values(store, fixture_name):
+    returned = []
+    for variation in store.iter_parametrization_variations(fixture_ids=[store.get_fixture_by_name(fixture_name).info.id]):
+        store.push_scope('test')
+        with bound_parametrizations_context(variation, store, store.get_current_namespace()):
+            returned.append(
+                store.get_fixture_dict([fixture_name])[fixture_name])
+        store.pop_scope('test')
+    return returned
+
+
+@pytest.mark.parametrize('scopes', [('module', 'test'), ('session', 'module'), ('session', 'test')])
+def test_wrong_scoping(store, scopes):
+
+    @store.add_fixture
+    @slash.fixture(scope=scopes[0])
+    def fixture1(fixture2):
+        pass
+
+    @store.add_fixture
+    @slash.fixture(scope=scopes[1])
+    def fixture2():
+        pass
+
+    with pytest.raises(InvalidFixtureScope):
+        store.resolve()
+
+
+def test_this_argument(store):
+
+    @store.add_fixture
+    @slash.fixture
+    def sample(this, other):
+        assert this.name == 'sample'
+        assert other == 'ok_other'
+        return 'ok_sample'
+
+    @store.add_fixture
+    @slash.fixture
+    def other(this):
+        assert this.name == 'other'
+        return 'ok_other'
+
+    store.resolve()
+
+    assert store.get_fixture_dict(['sample']) == {
+        'sample': 'ok_sample',
+    }
+
+
+def test_fixture_store_unresolved(store):
+
+    @store.add_fixture
+    @slash.fixture
+    def some_fixture(a, b, c):
+        return a + b + c
+
+    with pytest.raises(UnresolvedFixtureStore):
+        store.get_fixture_dict(['some_fixture'])
+
+
+def test_fixture_store_resolve_missing_fixtures(store):
+
+    @store.add_fixture
+    @slash.fixture
+    def some_fixture(a, b, c):
+        return a + b + c
+
+    with pytest.raises(UnknownFixtures):
+        store.resolve()
+
+
+def test_get_all_needed_fixture_ids(store):
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('param', [1, 2, 3])
+    def fixture1(param):  # pylint: disable=unused-argument
+        pass
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture2(fixture1):  # pylint: disable=unused-argument
+        pass
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('param', [4, 5, 6])
+    def fixture3(fixture2, param):  # pylint: disable=unused-argument
+        pass
+
+    fixtureobj = store.get_fixture_by_id(fixture3.__slash_fixture__.id)
+
+    with pytest.raises(UnresolvedFixtureStore):
+        store.get_all_needed_fixture_ids(fixtureobj)
+
+    store.resolve()
+
+    assert len(set(store.get_all_needed_fixture_ids(fixtureobj))) == 2
+
+
+def test_get_all_needed_fixture_ids_of_parametrization(store):
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('param', [1, 2, 3])
+    def fixture1(param):  # pylint: disable=unused-argument
+        pass
+
+    fixtureobj = store.get_fixture_by_id(fixture1.__slash_fixture__.id)
+    [(_, param_fixtureobj)] = iter_parametrization_fixtures(fixture1)
+
+    with pytest.raises(UnresolvedFixtureStore):
+        store.get_all_needed_fixture_ids(fixtureobj)
+
+    store.resolve()
+
+    needed = set(store.get_all_needed_fixture_ids(param_fixtureobj))
+    assert len(needed) == 1
+    assert needed == set([param_fixtureobj.info.id])
+
+
+
+def test_fixture_store_iter_parametrization_variations_missing_fixtures(store):
+
+    def test_func(needed_fixture):
+        pass
+
+    with pytest.raises(UnknownFixtures):
+        list(store.iter_parametrization_variations(funcs=[test_func]))
+
+
+def test_fixture_store_iter_parametrization_variations_unresolved(store):
+
+    @store.add_fixture
+    @slash.fixture
+    @slash.parametrize('x', [1, 2, 3])
+    def needed_fixture(x):
+        pass
+
+    def test_func(needed_fixture):
+        pass
+
+    with pytest.raises(UnresolvedFixtureStore):
+        list(store.iter_parametrization_variations(funcs=[test_func]))
+
+
+
+def test_fixture_dependency(store):
+    counter = itertools.count()
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture1(fixture2):
+        assert fixture2 == 'fixture2_value_0'
+        return 'fixture1_value_{0}'.format(next(counter))
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture2():
+        return 'fixture2_value_{0}'.format(next(counter))
+
+    store.resolve()
+
+    assert store.get_fixture_dict(['fixture1', 'fixture2']) == {
+        'fixture1': 'fixture1_value_1',
+        'fixture2': 'fixture2_value_0',
+    }
+
+
+def test_nested_store_resolution_activation(store):
+
+    store.push_namespace()
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture0():
+        return '0'
+
+    store.push_namespace()
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture1(fixture0):
+        assert fixture0 == '0'
+        return '1'
+
+    store.push_namespace()
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture2(fixture1, fixture0):
+        assert fixture0 == '0'
+        assert fixture1 == '1'
+        return '2'
+
+    store.resolve()
+
+    assert store.get_fixture_dict(['fixture2']) == {
+        'fixture2': '2'
+    }
+
+    store.pop_namespace()
+
+    with pytest.raises(UnknownFixtures):
+        store.get_fixture_dict(['fixture2'])
+
+
+def test_fixture_dependency_cycle():
+    store = FixtureStore()
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture1(fixture2):
+        return 1
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture2(fixture3):
+        return 2
+
+    @store.add_fixture
+    @slash.fixture
+    def fixture3(fixture1):
+        return 3
+
+    store.resolve()
+
+    with pytest.raises(CyclicFixtureDependency):
+        store.get_fixture_dict(['fixture1'])
+
+
+def test_fixture_decorator():
+
+    def func(a, b, c):
+        pass
+
+    assert not hasattr(func, '__slash_fixture__')
+
+    assert slash.fixture(func) is func
+
+    assert func.__slash_fixture__ is not None  # pylint: disable=no-member
+
+
+def test_fixture_decorator_multiple_calls(fixture_func):
+    fixture_info = fixture_func.__slash_fixture__
+    assert slash.fixture(slash.fixture(fixture_func)) is fixture_func
+
+    assert fixture_func.__slash_fixture__ is fixture_info
+
+
+def test_fixture_required_fixtures(fixture_func):
+    assert set(fixture_func.__slash_fixture__.required_args) == set(arg.name for arg in get_arguments(fixture_func))
+
+
+def test_fixture_name(fixture_func, fixture_func_name):
+    assert fixture_func.__slash_fixture__.name == fixture_func_name
+
+
+def test_fixture_store_add(fixture_func, fixture_func_name):
+    # pylint: disable=no-member
+    f = FixtureStore()
+    assert f.add_fixture(fixture_func) is fixture_func
+    assert f.get_fixture_by_name(
+        fixture_func_name).fixture_func is fixture_func
+
+def test_nofixtures_decorator(store):
+
+    @slash.nofixtures
+    def func1(a, b, c):
+        pass
+
+    [var] = store.iter_parametrization_variations(funcs=[func1])
+    assert var == {}
+
+def test_nofixtures_decorator_methods(store):
+
+    class TestClass(slash.Test):
+        @slash.nofixtures
+        def before(self, a, b, c):  # pylint: disable=arguments-differ
+            pass
+
+    [var] = store.iter_parametrization_variations(methods=[('before', TestClass.before)])
+    assert var == {}
+
+
+def test_parametrized_fixture(store):
+
+    _fixture = lambda f: store.add_fixture(slash.fixture(f))
+
+    @_fixture
+    @slash.parametrize('a', [1, 2, 3])
+    @slash.parametrize('b', [4, 5, 6])
+    def fixture(a, b):
+        pass
+
+    store.resolve()
+
+
+@pytest.mark.parametrize('use_dict', [True, False])
+def test_fixture_name_override(store, use_dict):
+    @slash.fixture(name='custom')
+    def some_fixture():
+        pass
+
+    if use_dict:
+        store.add_fixtures_from_dict({
+            'some_fixture': some_fixture,
+            'bla': None,
+            'unused': 2,
+        })
+    else:
+        store.add_fixture(some_fixture)
+
+    store.resolve()
+
+    assert store.get_fixture_by_name('custom').fixture_func == some_fixture
+    with pytest.raises(UnknownFixtures):
+        assert store.get_fixture_by_name('some_fixture')
+
+
+
+@pytest.fixture(params=[True, False])
+def fixture_func(request, fixture_func_name):
+
+    def func(a, b, c, d):
+        pass
+
+    use_function_name = request.param
+    if use_function_name:
+        func.__name__ = fixture_func_name
+        return slash.fixture(func)
+    return slash.fixture(name=fixture_func_name)(func)
+
+
+@pytest.fixture
+def fixture_func_name():
+    return str(uuid1()).replace('-', '_')
+
+
+@pytest.fixture
+def store():
+    return FixtureStore()
+
+@pytest.fixture(autouse=True)
+def non_null_ctx(request):
+    slash.ctx.push_context()
+    request.addfinalizer(slash.ctx.pop_context)
+
+
+
+@pytest.fixture
+def cleanup_map():
+    return {}
+
+
+@pytest.fixture
+def test_scoped_fixture(store, cleanup_map):
+
+    return _get_scoped_fixture('test', store, cleanup_map)
+
+
+@pytest.fixture
+def module_scoped_fixture(store, cleanup_map):
+
+    return _get_scoped_fixture('module', store, cleanup_map)
+
+
+@pytest.fixture
+def session_scoped_fixture(store, cleanup_map):
+
+    return _get_scoped_fixture('session', store, cleanup_map)
+
+
+def _get_scoped_fixture(scope, store, cleanup_map):
+    @store.add_fixture
+    @slash.fixture(scope=scope, name='{0}_scoped_fixture'.format(scope))
+    def fixture(this):
+
+        @this.add_cleanup
+        def cleanup():
+            cleanup_map[this.name] = True
+
+        return ok(this.name)
+    return fixture
+
+
+def ok(s):
+    return 'ok_{0}'.format(s)
diff --git a/tests/test_fixture_namespaces.py b/tests/test_fixture_namespaces.py
new file mode 100755
index 0000000000..098feaaab2
--- /dev/null
+++ b/tests/test_fixture_namespaces.py
@@ -0,0 +1,68 @@
+from __future__ import print_function
+
+import functools
+from contextlib import contextmanager
+
+import slash
+
+from .utils import run_tests_assert_success
+
+
+def test_fixture_is_override():
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        def fixture1():
+            pass
+
+        outer = fixture1
+
+        with s.fixture_store.new_namespace_context():
+
+            @s.fixture_store.add_fixture
+            @slash.fixture
+            def fixture1():     # pylint: disable=function-redefined
+                pass
+
+            inner = fixture1
+
+            s.fixture_store.resolve()
+
+        outer = s.fixture_store.get_fixture_by_id(outer.__slash_fixture__.id)
+        inner = s.fixture_store.get_fixture_by_id(inner.__slash_fixture__.id)
+
+        assert outer != inner
+
+        assert inner.is_override()
+        assert not outer.is_override()
+
+
+def test_fixture_namespaces(tmpdir):
+
+    root_dir = tmpdir.join('tests')
+
+    with _into(root_dir.join('slashconf.py')) as writeln:
+        _write_fixture1(writeln)
+
+    with _into(root_dir.join('test_something.py')) as writeln:
+        _write_fixture1(writeln)
+
+        writeln('def test_something(fixture1):')
+        writeln('    pass')
+
+    run_tests_assert_success([str(root_dir)])
+
+def _write_fixture1(writeln):
+    writeln('import slash')
+
+    writeln('@slash.fixture')
+    writeln('def fixture1():')
+    writeln('    pass')
+
+
+
+@contextmanager
+def _into(f):
+    with f.open('w', ensure=True) as f:
+        yield functools.partial(print, file=f)
diff --git a/tests/test_fixture_resolution.py b/tests/test_fixture_resolution.py
new file mode 100755
index 0000000000..59d1835d72
--- /dev/null
+++ b/tests/test_fixture_resolution.py
@@ -0,0 +1,94 @@
+# pylint: disable=unused-variable, unused-argument
+import functools
+
+import pytest
+
+import slash
+from slash.exceptions import UnknownFixtures
+
+from .utils import make_runnable_tests
+
+
+def test_resolve_fixture_object():
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.parametrize('x', [1, 2])
+        @slash.fixture
+        def fixture1(x):
+            pass
+
+        @s.fixture_store.add_fixture
+        @slash.parametrize('x', [3, 4])
+        @slash.fixture
+        def fixture2(fixture1, x):
+            pass
+
+        def test_something(fixture2):
+            pass
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            tests = make_runnable_tests(test_something)
+
+    _resolve = functools.partial(s.fixture_store.resolve_name, start_point=tests[0])
+
+    # check simple resolutions
+    assert _resolve('fixture2').info is fixture2.__slash_fixture__
+    assert _resolve('fixture2.fixture1').info is fixture1.__slash_fixture__
+
+    # check parameter resolution
+    assert _resolve('fixture2.fixture1.x').values == [[1], [2]]
+    assert _resolve('fixture2.x').values == [[3], [4]]
+
+    for invalid_name in ['fixture2.x.y']:
+        with pytest.raises(UnknownFixtures):
+            _resolve(invalid_name)
+
+def test_resolve_fixture_object_namespace_correctness():
+    with slash.Session() as s:
+
+        store = s.fixture_store
+
+        @store.add_fixture
+        @slash.fixture
+        def global_fixture_1(dependency_fixture):
+            pass
+
+        @store.add_fixture
+        @slash.fixture
+        def dependency_fixture():
+            pass
+
+        expected = dependency_fixture
+
+        store.push_namespace()
+
+        @store.add_fixture
+        @slash.fixture
+        def local_fixture(global_fixture_1):
+            pass
+
+        @store.add_fixture
+        @slash.fixture
+        def dependency_fixture():         # pylint: disable=function-redefined
+            pass
+
+        def test_something(local_fixture):
+            pass
+
+        store.resolve()
+
+        with s.get_started_context():
+            tests = make_runnable_tests(test_something)
+
+        test = tests[0]
+        resolved = store.resolve_name('local_fixture.global_fixture_1.dependency_fixture', test, namespace=test.get_fixture_namespace()).info
+        assert resolved is expected.__slash_fixture__
+
+
+def test_invalid_name():
+    with slash.Session() as s:
+        with pytest.raises(UnknownFixtures):
+            s.fixture_store.resolve_name('', start_point=object())
diff --git a/tests/test_fixture_scoping.py b/tests/test_fixture_scoping.py
new file mode 100755
index 0000000000..0fc57fc0a7
--- /dev/null
+++ b/tests/test_fixture_scoping.py
@@ -0,0 +1,194 @@
+# pylint: disable=redefined-outer-name
+import collections
+import itertools
+from contextlib import contextmanager
+from uuid import uuid1
+
+import pytest
+import slash
+from slash._compat import iteritems, StringIO
+from slash.core.fixtures.fixture_store import FixtureStore
+from slash.core.fixtures.utils import get_scope_by_name, get_scope_name_by_scope
+
+from .utils.code_formatter import CodeFormatter
+
+
+def test_fixture_scopes(fixture_tree):
+    with fixture_tree.testing_scope('session'):
+        for i in range(3):  # pylint: disable=unused-variable
+            with fixture_tree.testing_scope('module'):
+                for j in range(5):  # pylint: disable=unused-variable
+                    with fixture_tree.testing_scope('test'):
+                        fixture_tree.check_values()
+
+Structure = collections.namedtuple(
+    'Structure', ['required', 'graph', 'scopes'])
+
+_FLAT_STRUCTURE = Structure(
+    required=[1, 2, 3],
+    graph={1: [], 2: [], 3: []},
+    scopes={},
+)
+
+_FLAT_STRUCTURE_WITH_UNRELATED = Structure(
+    required=[1, 2, 3],
+    graph={1: [], 2: [], 3: [], 4: []},
+    scopes={},
+)
+
+_DEPENDENT_STRUCTURE = Structure(
+    required=[1, 2, 3],
+    graph={1: [3], 2: [1], 3: []},
+    scopes={},
+)
+
+_DEPENDENT_STRUCTURE_WITH_UNRELATED = Structure(
+    required=[1, 2, 3],
+    graph={1: [3], 2: [1], 3: [], 4: [2], 5: [1]},
+    scopes={},
+)
+
+_MODULE_SCOPED = Structure(
+    required=[1, 2, 3],
+    graph={1: [], 2: [], 3: []},
+    scopes={1: 'module', 2: 'module'},
+)
+
+_DEPENDENT_MIXED_SCOPES = Structure(
+    required=[1, 2, 3],
+    graph={1: [2], 2: [3], 3: []},
+    scopes={3: 'session', 2: 'module'},
+)
+
+
+@pytest.fixture(params=[
+    _FLAT_STRUCTURE,
+    _FLAT_STRUCTURE_WITH_UNRELATED,
+    _DEPENDENT_STRUCTURE,
+    _DEPENDENT_STRUCTURE_WITH_UNRELATED,
+    _MODULE_SCOPED,
+    _DEPENDENT_MIXED_SCOPES,
+])
+def structure(request):
+    return request.param
+
+
+@pytest.fixture
+def fixture_tree(fixture_store, structure):
+    returned = FixtureTree(fixture_store, structure)
+    return returned
+
+
+@pytest.fixture
+def fixture_store():
+    return FixtureStore()
+
+
+class FixtureTree(object):
+
+    def __init__(self, fixture_store, structure):
+        super(FixtureTree, self).__init__()
+        self._structure = structure
+        self._cleanups_made = set()
+        self._fixture_store = fixture_store
+        self._fixtures = {}
+        self._fixture_namegen = ('fixture_{0:05}'.format(x)
+                                 for x in itertools.count(1000))
+        self._required_names = []
+        self._populate_fixtures()
+        self._values = {}
+
+    def check_values(self):
+        values = self._fixture_store.get_fixture_dict(self._required_names)
+        for required_name in self._required_names:
+            assert values[required_name] is not None
+            expected_value = self._values[required_name]
+            assert values[required_name] == expected_value
+
+        assert not (set(self._fixtures) - set(self._required_names)
+                    ).intersection(self._values), 'Non-necessary fixtures unexpectedly initialized!'
+
+    def check_value(self, name, value):
+        assert self._values[name] == value
+
+    def make_value(self, name):
+        assert name not in self._values, 'Fixture generated more than once! (scope={0})'.format(
+            get_scope_name_by_scope(self._fixtures[name].__slash_fixture__.scope))
+        value = str(uuid1())
+        self._values[name] = value
+        return value
+
+    def cleanup(self, name):
+        assert name not in self._cleanups_made
+        self._cleanups_made.add(name)
+
+    @contextmanager
+    def testing_scope(self, scope):
+        self._fixture_store.push_scope(scope)
+        yield
+        self._fixture_store.pop_scope(scope)
+        scope_id = get_scope_by_name(scope)
+        for fixture_name, fixture in iteritems(self._fixtures):
+            if fixture.__slash_fixture__.scope <= scope_id:
+                if fixture_name in self._values:
+                    assert fixture_name in self._cleanups_made
+                    self._cleanups_made.remove(fixture_name)
+                    self._values.pop(fixture_name)
+        assert not self._cleanups_made, 'Unknown cleanups called'
+
+    def _populate_fixtures(self):
+        assert not self._fixtures
+
+        graph = self._structure.graph
+
+        key_to_fixture_name = dict((key, next(self._fixture_namegen))
+                                   for key in graph)
+
+        stack = list(self._structure.graph)
+
+        while stack:
+            fixture_key = stack.pop()
+            dependent_keys = graph[fixture_key]
+            unresolved = [k for k in dependent_keys if key_to_fixture_name[k]
+                          not in self._fixtures]
+            if unresolved:
+                stack.append(fixture_key)
+                stack.extend(unresolved)
+                continue
+
+            fixture_name = key_to_fixture_name[fixture_key]
+            if fixture_name in self._fixtures:
+                continue
+
+            fixture = self._fixtures[fixture_name] = self._construct_fixture(
+                fixture_name,
+                scope=self._structure.scopes.get(fixture_key, 'test'),
+                dependent_names=[key_to_fixture_name[k] for k in dependent_keys])
+            self._fixture_store.add_fixture(fixture)
+
+        self._fixture_store.resolve()
+        self._required_names.extend(key_to_fixture_name[k]
+                                    for k in self._structure.required)
+
+    def _construct_fixture(self, name, scope, dependent_names):
+        buff = StringIO()
+        code = CodeFormatter(buff)
+        code.writeln(
+            'def {0}(this, {1}):'.format(name, ', '.join(dependent_names)))
+        with code.indented():
+            for dependent_name in dependent_names:
+                code.writeln(
+                    'tree.check_value({0!r}, {0})'.format(dependent_name))
+            code.writeln('@this.add_cleanup')
+            code.writeln('def cleanup():')
+            with code.indented():
+                code.writeln('tree.cleanup({0!r})'.format(name))
+            code.writeln('return tree.make_value({0!r})'.format(name))
+        globs = {'tree': self}
+        exec(buff.getvalue(), globs)  # pylint: disable=exec-used
+        return slash.fixture(scope=scope)(globs[name])
+
+@pytest.fixture(autouse=True)
+def non_null_ctx(request):
+    slash.ctx.push_context()
+    request.addfinalizer(slash.ctx.pop_context)
diff --git a/tests/test_fixture_start_end_test.py b/tests/test_fixture_start_end_test.py
new file mode 100755
index 0000000000..6a9c6e5d05
--- /dev/null
+++ b/tests/test_fixture_start_end_test.py
@@ -0,0 +1,18 @@
+import pytest
+
+@pytest.mark.parametrize('scope', ['module', 'test'])
+def test_fixture_start_end_test(suite, suite_test, scope):
+
+    fixture = suite.slashconf.add_fixture(scope=scope)
+
+    start_event = fixture.add_deferred_event('this.test_start', name='fixture_test_start')
+    end_event = fixture.add_deferred_event('this.test_end', name='fixture_test_end')
+    test_event = suite_test.add_event()
+
+    suite_test.depend_on_fixture(fixture)
+    events = suite.run().events
+
+    if scope != 'module':
+        # for module scope, the event will get run over, resulting in later `test_start` events...
+        assert events[start_event].timestamp < events[test_event].timestamp
+    assert events[end_event].timestamp > events[test_event].timestamp
diff --git a/tests/test_fixture_string_representation.py b/tests/test_fixture_string_representation.py
new file mode 100755
index 0000000000..cebda2d51d
--- /dev/null
+++ b/tests/test_fixture_string_representation.py
@@ -0,0 +1,102 @@
+# pylint: disable=redefined-outer-name
+import functools
+import itertools
+import random
+
+import pytest
+import slash
+from slash._compat import StringIO
+from slash.utils.iteration import iter_cartesian_dicts
+from .utils.code_formatter import CodeFormatter
+
+
+def test_safe_repr_parameters(fixture_store, parametrized_func, params, param_names):
+
+    variations = list(
+        fixture_store.iter_parametrization_variations(funcs=[parametrized_func]))
+
+    cartesian_product = list(iter_cartesian_dicts(params))
+
+    assert len(variations) == len(cartesian_product)
+    variation_names = set(str(v.safe_repr) for v in variations)
+    assert len(variation_names) == len(cartesian_product)
+    assert variation_names == set(','.join('{0}={1}'.format(name, combination[name]) for name in sorted(param_names))
+                                  for combination in cartesian_product)
+
+def test_safe_repr_fixtures(fixture_store):
+
+    first_param_values = [1, 2, 3]
+    second_param_values = [4, 5, 6]
+
+    @fixture_store.add_fixture
+    @slash.fixture
+    @slash.parametrize('value', first_param_values)
+    def first_fixture(value):  # pylint: disable=unused-variable
+        return value
+
+    @fixture_store.add_fixture
+    @slash.fixture
+    @slash.parametrize('value', second_param_values)
+    def second_fixture(value):  # pylint: disable=unused-variable
+        return value
+
+    def test_func(first_fixture, second_fixture):  # pylint: disable=unused-argument
+        pass
+
+    fixture_store.resolve()
+
+    variations = list(
+        fixture_store.iter_parametrization_variations(funcs=[test_func]))
+
+    assert len(variations) == len(first_param_values) * len(second_param_values)
+
+    assert set(str(variation.safe_repr) for variation in variations) == {
+        'first_fixture.value={0},second_fixture.value={1}'.format(i, j)
+        for i, j in itertools.product(first_param_values, second_param_values)
+    }
+
+@pytest.fixture
+def parametrized_func(params, param_names):
+    buff = StringIO()
+    formatter = CodeFormatter(buff)
+    formatter.writeln('def f({0}):'.format(', '.join(param_names)))
+    with formatter.indented():
+        formatter.writeln('pass')
+    globs = {}
+    exec(buff.getvalue(), globs)  # pylint: disable=exec-used
+    returned = globs['f']
+    for param_name in param_names:
+        returned = slash.parametrize(
+            param_name, list(params[param_name]))(returned)
+    return returned
+
+
+@pytest.fixture(
+    params=[
+        sorted,
+        functools.partial(sorted, reverse=True),
+        functools.partial(sorted, key=lambda x: random.random()),
+    ])
+def param_names(request, params):
+    sorter = request.param
+    return sorter(params)
+
+
+@pytest.fixture
+def params():
+    return {
+        'a': [1, 2],
+        'b': [4, 5],
+        'c': [6, 7],
+        'd': [8, 9],
+    }
+
+
+@pytest.fixture
+def fixture_store():
+    return slash.core.fixtures.fixture_store.FixtureStore()
+
+
+@pytest.fixture(params=[str, repr])
+def stringify(request):
+    return request.param
diff --git a/tests/test_fixture_test_addresses.py b/tests/test_fixture_test_addresses.py
new file mode 100755
index 0000000000..ad9af200c9
--- /dev/null
+++ b/tests/test_fixture_test_addresses.py
@@ -0,0 +1,88 @@
+# pylint: disable=redefined-outer-name
+import itertools
+
+import pytest
+import slash
+from slash._compat import ExitStack
+
+from .utils import run_tests_assert_success, make_runnable_tests
+from .utils.code_formatter import CodeFormatter
+
+
+def test_fixtures_representation_strings(results, a_values, fixture_values, filename, is_class):
+    prefix = '{0}:'.format(filename)
+    if is_class:
+        prefix += 'Test.'
+    assert len(results) == len(a_values) * len(fixture_values)
+    assert set(result.test_metadata.address for result in results) == {
+        '{0}test_1(a={1},fixture.value={2})'.format(prefix, i, j) for i, j in itertools.product(a_values, fixture_values)
+    }
+
+
+@pytest.mark.parametrize('non_printable', ['string/with/slashes', object()])
+def test_fixtures_avoid_non_printable_reprs_strs(non_printable):
+    with slash.Session():
+
+        # pylint: disable=unused-argument
+        @slash.parametrize('param', [non_printable])
+        def test_something(param):
+            pass
+
+        [loaded_test] = make_runnable_tests([test_something])  # pylint: disable=unbalanced-tuple-unpacking
+
+    assert '/' not in loaded_test.__slash__.address_in_file
+    assert repr(non_printable) not in loaded_test.__slash__.address_in_file
+    assert str(non_printable) not in loaded_test.__slash__.address_in_file
+
+
+@pytest.fixture
+def results(filename):
+
+    with slash.Session() as s:
+        session = run_tests_assert_success(filename, session=s)
+    return list(session.results.iter_test_results())
+
+
+@pytest.fixture
+def filename(is_class, a_values, fixture_values, tmpdir):
+    returned = str(tmpdir.join('testfile.py'))
+
+    with open(returned, 'w') as f:
+        with ExitStack() as stack:
+            code = CodeFormatter(f)
+
+            code.writeln('import slash')
+            code.writeln('@slash.fixture')
+            code.writeln(
+                '@slash.parametrize("value", {0})'.format(fixture_values))
+            code.writeln('def fixture(value):')
+            with code.indented():
+                code.writeln('return value')
+
+            if is_class:
+                code.writeln('class Test(slash.Test):')
+                stack.enter_context(code.indented())
+
+            code.writeln('@slash.parametrize("a", {0})'.format(a_values))
+            code.write('def test_1(')
+            if is_class:
+                code.write('self, ')
+            code.writeln('a, fixture):')
+            with code.indented():
+                code.writeln('pass')
+    return returned
+
+
+@pytest.fixture
+def a_values():
+    return [1, 2, 3]
+
+
+@pytest.fixture
+def fixture_values():
+    return [4, 5, 6]
+
+
+@pytest.fixture(params=[True, False])
+def is_class(request):
+    return request.param
diff --git a/tests/test_fixtures.py b/tests/test_fixtures.py
new file mode 100755
index 0000000000..dfe632a93c
--- /dev/null
+++ b/tests/test_fixtures.py
@@ -0,0 +1,117 @@
+import pytest
+import operator
+
+from slash._compat import reduce
+
+
+def test_fixtures(suite, suite_test, defined_fixture):
+    suite_test.depend_on_fixture(defined_fixture)
+    suite.run()
+
+
+def test_fixture_cleanup_at_end_of_suite(suite):
+    fixture = suite.slashconf.add_fixture()
+    suite[-1].depend_on_fixture(fixture)
+    cleanup = fixture.add_cleanup()
+
+    summary = suite.run()
+    assert cleanup in summary.events
+
+
+def test_fixture_cleanup_failure_fails_test(suite, suite_test, defined_fixture):
+    suite_test.depend_on_fixture(defined_fixture)
+    defined_fixture.add_cleanup(extra_code=['raise Exception()'])
+    suite_test.expect_error()
+    suite.run()
+
+
+def test_fixture_parameters(suite, suite_test, defined_fixture):
+    defined_fixture.add_parameter()
+    suite_test.depend_on_fixture(defined_fixture)
+    summary = suite.run()
+    all_results = summary.get_all_results_for_test(suite_test)
+    num_combinations = reduce(operator.mul, (len(p.values) for p in defined_fixture.get_parameters()))
+    assert len(all_results) == num_combinations
+
+
+def test_fixture_dependency_chain(suite, suite_test):
+    fixture1 = suite.slashconf.add_fixture()
+    fixture1.add_parameter()
+    fixture2 = suite.slashconf.add_fixture()
+    fixture2.add_parameter()
+    fixture2.depend_on_fixture(fixture1)
+    suite_test.depend_on_fixture(fixture2)
+    suite.run()
+
+
+def test_fixture_dependency_both_directly_and_indirectly(suite, suite_test):
+
+    fixture1 = suite.slashconf.add_fixture()
+    num_values1 = 2
+    fixture1.add_parameter(num_values=num_values1)
+
+    fixture2 = suite.slashconf.add_fixture()
+    num_values2 = 3
+    fixture2.add_parameter(num_values=num_values2)
+    fixture2.depend_on_fixture(fixture1)
+
+    suite_test.depend_on_fixture(fixture1)
+    suite_test.depend_on_fixture(fixture2)
+
+    summary = suite.run()
+    results = summary.get_all_results_for_test(suite_test)
+    assert len(results) == num_values1 * num_values2
+
+
+def test_fixture_context(suite, suite_test):
+    fixture1 = suite.slashconf.add_fixture()
+    fixture1.append_line('assert this == slash.context.fixture')
+    fixture2 = suite.slashconf.add_fixture()
+    fixture2.append_line('assert this == slash.context.fixture')
+    fixture2.depend_on_fixture(fixture1)
+    suite_test.depend_on_fixture(fixture1)
+    suite.run()
+
+@pytest.mark.parametrize('where', [['before'], ['after'], ['before', 'after']])
+def test_fixtures_in_before_after(suite, where):
+    test_class = suite.files[-1].add_class()
+    suite_test = test_class.add_method_test()
+
+    fixture = suite.slashconf.add_fixture()
+    fixture_event = fixture.add_event(name='fixture')
+
+    assert len(suite_test.cls.tests) == 1
+
+    before = suite_test.cls.add_before_method()
+    evt1 = before.add_event(name='before')
+    after = suite_test.cls.add_after_method()
+    evt2 = after.add_event(name='after')
+
+    for func in before, after:
+        if func.name in where:
+            func.depend_on_fixture(fixture)
+            func.append_line('assert {0} == {1}'.format(fixture.name, fixture.get_value_string()))
+
+    summary = suite.run()
+
+    assert evt1 in summary.events
+    assert evt2 in summary.events
+    assert fixture_event in summary.events
+
+def test_fixture_and_parameter(suite, suite_test, get_fixture_location):
+    fixture = get_fixture_location(suite_test).add_fixture()
+    suite_test.add_parameter()
+    suite_test.depend_on_fixture(fixture)
+    suite.run()
+
+
+def test_fixture_which_name_startswith_test(suite):
+    fixture = suite.slashconf.add_fixture(name='test_my_fixture')
+    suite[-1].depend_on_fixture(fixture)
+    for test in suite:
+        test.expect_deselect()
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.ok()
+    for output in [summary.get_console_output(),
+                   str(summary.session.results.global_result.get_errors()[0])]:
+        assert 'Invalid fixture name' in output
diff --git a/tests/test_formatter.py b/tests/test_formatter.py
new file mode 100755
index 0000000000..e9a65932ed
--- /dev/null
+++ b/tests/test_formatter.py
@@ -0,0 +1,108 @@
+from slash._compat import cStringIO
+from slash.utils.formatter import Formatter
+from slash.utils.color_string import ColorString
+from .utils import TestCase
+
+
+class FormatterTest(TestCase):
+
+    def setUp(self):
+        super(FormatterTest, self).setUp()
+        self.buff = cStringIO()
+        self.f = Formatter(self.buff)
+
+    def assertOutput(self, v):
+        self.assertEqual(self.buff.getvalue(), v)
+
+    def test_write_non_strings(self):
+        class MyObject(object):
+
+            def __repr__(self):
+                return 'repr'
+
+            def __str__(self):
+                return 'str'
+        self.f.write("1:")
+        self.f.write(MyObject())
+        self.f.write("2:")
+        self.f.writeln(MyObject())
+        self.assertOutput("1:str2:str\n")
+
+    def test_write_writeln(self):
+        self.f.writeln("hello")
+        self.assertOutput("hello\n")
+        self.f.write("a")
+        self.f.write("bcd")
+        self.assertOutput("hello\nabcd")
+
+    def test_indent_write_writeln(self):
+        with self.f.indented():
+            self.f.writeln("hello")
+            self.assertOutput(" hello\n")
+            self.f.write("a")
+            self.f.write("bcd")
+            self.f.writeln()
+            self.assertOutput(" hello\n abcd\n")
+
+    def test_empty_writeln(self):
+        self.f.writeln('a')
+        self.f.writeln()
+        self.f.writeln()
+        self.f.writeln('b')
+        self.assertOutput('a\n\n\nb\n')
+
+    def test_multiline_write(self):
+        self.f.writeln('a\nb')
+        with self.f.indented(3, string='.'):
+            self.f.writeln('c\n d\ne')
+        self.f.writeln('f')
+        self.assertOutput("a\nb\n...c\n... d\n...e\nf\n")
+
+    def test_indentation(self):
+        self.f.writeln("begin")
+        with self.f.indented(3):
+            self.f.writeln("a")
+            self.f.writeln("b")
+        self.f.writeln("end")
+        self.assertOutput("begin\n   a\n   b\nend\n")
+
+    def test_indentation_different_char_through_ctor(self):
+        self._test__indentation_different_char(True)
+
+    def test_indentation_different_char_not_through_ctor(self):
+        self._test__indentation_different_char(False)
+
+    def _test__indentation_different_char(self, through_constructor):
+        if through_constructor:
+            self.f = Formatter(self.buff, indentation_string='*')
+            indenter = self.f.indented
+        else:
+            indenter = lambda indentation: self.f.indented(
+                indentation, string='*')
+        self.f.writeln("a")
+        with indenter(2):
+            self.f.writeln('b')
+        self.f.writeln('c')
+        self.assertOutput('a\n**b\nc\n')
+
+
+class FormatterColorTest(TestCase):
+
+    def setUp(self):
+        super(FormatterColorTest, self).setUp()
+        self.buff = self.forge.create_wildcard_mock()
+        self.buff.write("").whenever()  # indentation of 0
+
+    def test_color_string_tty(self):
+        self.buff.isatty().whenever().and_return(True)
+        s = ColorString("hello", "red")
+        self.buff.write(s.get_colored())
+        self.forge.replay()
+        Formatter(self.buff).write(s)
+
+    def test_color_string_not_tty(self):
+        self.buff.isatty().whenever().and_return(False)
+        s = ColorString("hello", "red")
+        self.buff.write("hello")
+        self.forge.replay()
+        Formatter(self.buff).write(s)
diff --git a/tests/test_function_marker.py b/tests/test_function_marker.py
new file mode 100755
index 0000000000..146a74e6ed
--- /dev/null
+++ b/tests/test_function_marker.py
@@ -0,0 +1,93 @@
+# pylint: disable=redefined-outer-name
+import pytest
+from slash.utils.function_marker import function_marker, append_function_marker
+
+
+def test_marked_func_identical_to_original(marker, func):
+    orig_func = func
+    new_func = marker(func)
+    assert orig_func is new_func
+
+def test_is_marked(marker, func):
+    assert not marker.is_marked(func)
+    marker(func)
+    assert marker.is_marked(func)
+
+@pytest.mark.parametrize('value', [True, False, 'value', 2.0])
+def test_marker_value(func, value):
+
+    marker = function_marker('bla')
+
+    func = marker(value)(func)
+
+    assert marker.is_marked(func)
+    assert marker.get_value(func) == value
+
+def test_marker_value_does_not_exist(func):
+    with pytest.raises(LookupError):
+        function_marker('bla').get_value(func)
+
+    assert function_marker('bla').get_value(func, 1) == 1
+
+def test_marker_on_methods(marker):
+
+    class Obj(object):
+
+        @marker
+        def marked_func(self):
+            pass
+
+        def unmarked_func(self):
+            pass
+
+        @classmethod
+        def unmarked_classmethod(cls):
+            pass
+
+        @staticmethod
+        def unmarked_staticmethod(param):
+            pass
+
+        @marker
+        @classmethod
+        def marked_classmethod(cls):
+            pass
+
+        @marker
+        @staticmethod
+        def marked_staticmethod():
+            pass
+
+
+    for subject in (Obj, Obj()):
+        for name in dir(subject):
+            if name.startswith('_'):
+                continue
+            method = getattr(subject, name)
+            assert 'marked' in name
+            if 'unmarked' in name:
+                assert not marker.is_marked(method)
+            else:
+                assert marker.is_marked(method)
+
+def test_append_marker(append_marker):
+
+    @append_marker(1)
+    def func():
+        pass
+
+    assert append_marker.get_value(func) == [1]
+
+@pytest.fixture
+def append_marker():
+    return append_function_marker('some_other_marker')
+
+@pytest.fixture
+def marker():
+    return function_marker('some_marker')
+
+@pytest.fixture
+def func():
+    def returned():
+        pass
+    return returned
diff --git a/tests/test_generator_fixture.py b/tests/test_generator_fixture.py
new file mode 100755
index 0000000000..f041c806b8
--- /dev/null
+++ b/tests/test_generator_fixture.py
@@ -0,0 +1,4 @@
+def test_generator_fixture(suite, suite_test, get_fixture_location):
+    fixture = get_fixture_location(suite_test).add_generator_fixture()
+    suite_test.depend_on_fixture(fixture)
+    suite.run()
diff --git a/tests/test_global_storage.py b/tests/test_global_storage.py
new file mode 100755
index 0000000000..5698a7b684
--- /dev/null
+++ b/tests/test_global_storage.py
@@ -0,0 +1,25 @@
+import gossip
+import slash
+
+from .utils import TestCase
+
+
+class GlobalStorageTest(TestCase):
+    hook_called = False
+    token = object()
+    def test_global_storage_exists_on_session_start(self):
+        @slash.exception_handling.disable_exception_swallowing
+        def _on_session_start():
+            self.assertIsNotNone(slash.g)
+            slash.g.value = "value"
+            self.assertEqual(slash.g.value, "value")
+            self.hook_called = True
+        slash.hooks.session_start.register(_on_session_start, token=self.token)  # pylint: disable=no-member
+        self.addCleanup(
+            gossip.unregister_token,
+            self.token
+        )
+        with slash.Session() as s:
+            with s.get_started_context():
+                pass
+        self.assertTrue(self.hook_called)
diff --git a/tests/test_globals.py b/tests/test_globals.py
new file mode 100755
index 0000000000..8c53b3e925
--- /dev/null
+++ b/tests/test_globals.py
@@ -0,0 +1,62 @@
+# pylint: disable=redefined-outer-name
+import pytest
+import slash
+from slash import context, Session
+from .utils import run_tests_assert_success
+from .utils.suite_writer import Suite
+
+
+def test_current_test():
+    suite = Suite()
+
+    suite.add_test(type='method').prepend_line(
+        'assert slash.test == self')
+    suite.add_test(type='method').prepend_line(
+        'assert slash.context.test == self')
+    suite.add_test(type='method').prepend_line(
+        'assert slash.context.test.__slash__.id == self.__slash__.id')
+    suite.add_test(type='method').prepend_line(
+        'assert slash.context.test_id == self.id')
+
+    suite.run()
+
+
+def test_get_current_session():
+    with Session() as s:
+        assert context.session is s
+        assert context.session is not slash.session
+        assert s == slash.session
+
+
+def test_test_methodname_has_no_dot(test_globals):
+    assert not test_globals['test_methodname'].startswith('.')
+
+
+def test_globals_dir():
+    with Session():
+        assert 'x' not in dir(slash.g)
+        slash.g.x = 2
+        assert 'x' in dir(slash.g)
+
+
+@pytest.fixture
+def test_globals(is_method):
+    returned = {}
+
+    def _distill():
+        returned['test_methodname'] = context.test_methodname
+    if is_method:
+        class test_something(slash.Test):
+
+            def test_something(self):
+                _distill()
+    else:
+        def test_something():
+            _distill()
+    run_tests_assert_success(test_something)
+    return returned
+
+
+@pytest.fixture(params=[True, False])
+def is_method(request):
+    return request.param
diff --git a/tests/test_hook_calling.py b/tests/test_hook_calling.py
new file mode 100755
index 0000000000..64cad17994
--- /dev/null
+++ b/tests/test_hook_calling.py
@@ -0,0 +1,281 @@
+# pylint: disable=unused-argument, unused-variable
+from slash._compat import ExitStack
+import slash
+from slash import plugins
+from slash.plugins import PluginInterface
+from slash import hooks
+import pytest
+import gossip
+
+from .utils import TestCase, make_runnable_tests, CustomException
+
+
+class SessionEndException(Exception):
+    pass
+
+
+class SessionStartException(Exception):
+    pass
+
+
+class TestEndException(Exception):
+    pass
+
+
+class BeforeTestCleanupException(Exception):
+    pass
+
+
+def test_test_skip_hook(suite, suite_test, checkpoint):
+    slash.hooks.test_skip.register(checkpoint)  # pylint: disable=no-member
+
+    suite_test.when_run.skip()
+
+    suite.run()
+    assert checkpoint.called_count == 1
+
+
+@pytest.mark.parametrize('autouse', [True, False])
+def test_test_start_before_fixture_start(suite, suite_test, defined_fixture, autouse):
+    if autouse:
+        assert not defined_fixture.autouse # make sure we're not obsolete code and that that's still where it is
+        defined_fixture.autouse = True
+    else:
+        suite_test.depend_on_fixture(defined_fixture)
+    event_code = suite.slashconf.add_hook_event('test_start', extra_args=['slash.context.test.__slash__.id'])
+
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    test_id = result.test_metadata.id
+
+    event = summary.events[event_code, test_id]
+
+    assert summary.events['fixture_start', defined_fixture.id].timestamp > event.timestamp
+
+
+def test_last_test_end_after_session_cleanup(suite, last_suite_test):
+    test = last_suite_test
+    @test.append_body
+    def __code__(): # pylint: disable=unused-variable
+        import gossip # pylint: disable=redefined-outer-name,reimported
+        # pylint: disable=undefined-variable,unused-variable
+        def session_cleanup_callback():
+            __ut__.events.add('session_cleanup')
+        slash.add_cleanup(session_cleanup_callback, scope='session')
+
+        @gossip.register('slash.test_end')
+        def test_end_callback():
+            __ut__.events.add('test_end')
+
+    events = suite.run().events
+
+    assert events['test_end'].timestamp < events['session_cleanup'].timestamp
+
+
+def test_no_error_hooks_called_on_success(suite):
+
+    called = []
+
+    for hook_name in ['test_error', 'test_failure', 'test_skip', 'error_added']:
+        gossip.register(lambda name=hook_name, **kw: called.append(name), 'slash.{0}'.format(hook_name))
+
+    suite.run()
+    assert not called
+
+
+def test_hook__error_added_during_test(suite, request, checkpoint, suite_test):
+
+    request.addfinalizer(
+        hooks.error_added.register(checkpoint)  # pylint: disable=no-member
+        .unregister)
+
+    suite_test.when_run.raise_exception()
+
+    summary = suite.run()
+    assert checkpoint.called
+    [result] = summary.get_all_results_for_test(suite_test)
+    assert checkpoint.kwargs['result'] is result
+
+
+def test_hook__error_added_after_test(suite, request, checkpoint, suite_test):
+
+    request.addfinalizer(
+        hooks.error_added.register(checkpoint)  # pylint: disable=no-member
+        .unregister)
+
+    summary = suite.run()
+    assert not checkpoint.called
+    [result] = summary.get_all_results_for_test(suite_test)
+    try:
+        1 / 0
+    except:
+        result.add_error()
+    assert checkpoint.called
+    assert checkpoint.kwargs['result'] is result
+    assert 'ZeroDivisionError' in str(checkpoint.kwargs['error'])
+
+
+def test_hook__test_interrupt(suite, request, checkpoint):
+    request.addfinalizer(
+        hooks.test_interrupt.register(checkpoint)  # pylint: disable=no-member
+        .unregister)
+
+    test_index = int(len(suite) / 2)
+    for index, test in enumerate(suite):
+        if index == test_index:
+            test.when_run.interrupt()
+        elif index > test_index:
+            test.expect_deselect()
+    suite.run(expect_interruption=True)
+    assert checkpoint.called
+
+
+def test_hook__test_failure_without_exception(suite, request, checkpoint, suite_test):
+    request.addfinalizer(
+        hooks.test_failure.register(checkpoint)  # pylint: disable=no-member
+        .unregister)
+
+    suite_test.append_line('slash.add_failure("failure")')
+    suite_test.expect_failure()
+
+    suite.run()
+    assert checkpoint.called
+
+
+@pytest.mark.parametrize(
+    'hook_exception', [
+        ('slash.session_start', SessionStartException, True),
+        ('slash.session_end', SessionEndException, True),
+        ('slash.test_end', TestEndException, True),
+        ('slash.before_test_cleanups', BeforeTestCleanupException, False)])
+@pytest.mark.parametrize('debug_enabled', [True, False])
+def test_debugger_called_on_hooks(hook_exception, request, forge, config_override, checkpoint, debug_enabled):
+    hook_name, exception_type, should_raise = hook_exception
+
+    @gossip.register(hook_name)
+    def raise_exc():
+        raise exception_type()
+
+    config_override("debug.enabled", debug_enabled)
+
+    def test_something():
+        pass
+
+    forge.replace_with(slash.utils.debug, 'launch_debugger', checkpoint)
+
+    with ExitStack() as exception_stack:
+        if should_raise:
+            exception_stack.enter_context(pytest.raises(exception_type))
+        with slash.Session() as s:
+            with s.get_started_context():
+                slash.runner.run_tests(make_runnable_tests(test_something))
+
+    assert checkpoint.called == debug_enabled
+    if debug_enabled:
+        assert checkpoint.args[0][0] is exception_type
+        assert type(checkpoint.args[0][1]) is exception_type  # pylint: disable=unidiomatic-typecheck
+
+
+def test_before_cleanup_hook(request, forge):
+    cleanup = forge.create_wildcard_function_stub(name='cleanup')
+    before_cleanup_hook = forge.create_wildcard_function_stub(name='before_test_cleanup')
+    test_end_hook = forge.create_wildcard_function_stub(name='test_end')
+    gossip.register(before_cleanup_hook, 'slash.before_test_cleanups')
+    gossip.register(test_end_hook, 'slash.test_end')
+
+    before_cleanup_hook()
+    cleanup()
+    test_end_hook()
+
+    forge.replay()
+
+    def test_something():
+        slash.add_cleanup(cleanup)
+
+    with slash.Session() as s:
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+
+
+def test_session_end_not_called_when_before_session_start_fails(checkpoint):
+
+    @gossip.register('slash.before_session_start')
+    def before_start_hook():
+        raise CustomException()
+
+    @gossip.register('slash.session_end')
+    def hook():
+        checkpoint()
+
+
+    with slash.Session() as s:
+        with pytest.raises(CustomException):
+            with s.get_started_context():
+                pass
+
+    [err] = s.results.global_result.get_errors()
+    assert 'CustomException' in str(err)
+    assert not checkpoint.called
+
+
+#### Older tests below, need modernizing ####
+
+class HookCallingTest(TestCase):
+
+    def setUp(self):
+        super(HookCallingTest, self).setUp()
+        self.plugin1 = make_custom_plugin("plugin1", self)
+        self.plugin2 = make_custom_plugin("plugin2", self, hook_names=["before_session_start", "session_start", "after_session_start"])
+        self.addCleanup(plugins.manager.uninstall, self.plugin1)
+        self.addCleanup(plugins.manager.uninstall, self.plugin2)
+
+    def test_hook_calling_order(self):
+        # pylint: disable=no-member
+        # expect:
+        with self.forge.any_order():
+            self.plugin1.activate()
+            self.plugin2.activate()
+
+        with self.forge.any_order():
+            self.plugin1.before_session_start()
+            self.plugin2.before_session_start()
+
+        with self.forge.any_order():
+            self.plugin1.session_start()
+            self.plugin2.session_start()
+
+        with self.forge.any_order():
+            self.plugin1.after_session_start()
+            self.plugin2.after_session_start()
+
+        self.plugin1.session_end()
+
+        self.forge.replay()
+        # get:
+
+        plugins.manager.install(self.plugin1, activate=True)
+        plugins.manager.install(self.plugin2, activate=True)
+
+        with slash.Session() as s:
+            with s.get_started_context():
+                pass
+
+
+def make_custom_plugin(name, test, hook_names=None):
+
+    class CustomPlugin(PluginInterface):
+
+        def get_name(self):
+            return name
+
+    CustomPlugin.__name__ = name
+
+    if hook_names is None:
+        hook_names = [name for name, _ in slash.hooks.get_all_hooks()]
+
+    for hook_name in hook_names:
+        setattr(CustomPlugin, hook_name, test.forge.create_wildcard_function_stub(name=hook_name))
+
+    setattr(CustomPlugin, "activate", test.forge.create_wildcard_function_stub(name="activate"))
+
+    return CustomPlugin()
diff --git a/tests/test_hook_errors.py b/tests/test_hook_errors.py
new file mode 100755
index 0000000000..f145de9c84
--- /dev/null
+++ b/tests/test_hook_errors.py
@@ -0,0 +1,40 @@
+import gossip
+import pytest
+import slash
+
+from .utils import CustomException, run_tests_in_session
+
+
+def test_scope_management_with_hook_error_test_start(suite, suite_test):  # pylint: disable=unused-argument
+    assert len(suite.files) > 1
+    assert len(suite) > 1
+
+    @gossip.register('slash.test_start')
+    def hook():  # pylint: disable=unused-variable
+        raise CustomException()
+
+    for test in suite:
+        test.expect_error()
+    summary = suite.run()
+    for res in summary.session.results.iter_test_results():
+        [err] = res.get_errors()
+        assert err.exception_type is CustomException
+
+def test_scope_management_with_hook_error_test_end():
+    """test_end errors are fatal, so the session abruptly stops. We just make sure we get the exception and that at least one test runs"""
+    events = []
+
+    gossip.register('slash.test_end')(CustomException.do_raise)
+
+    @slash.parametrize('param', range(10))  # pylint: disable=unused-argument
+    def test_something(param):  # pylint: disable=unused-argument
+        events.append('test is running!')
+
+    with slash.Session() as session:
+        tests = slash.loader.Loader().get_runnables(test_something)
+        assert tests
+        with pytest.raises(CustomException):
+            run_tests_in_session(test_something, session=session)
+
+    assert len(events) == 1
+    assert len(tests) > 1
diff --git a/tests/test_hooks.py b/tests/test_hooks.py
new file mode 100755
index 0000000000..161f6cfdcb
--- /dev/null
+++ b/tests/test_hooks.py
@@ -0,0 +1,40 @@
+import gossip.exceptions
+import gossip.hooks
+from slash import hooks
+
+from .utils import TestCase
+
+
+class CustomHooksTest(TestCase):
+
+    def setUp(self):
+        super(CustomHooksTest, self).setUp()
+        self.hook_name = "some_custom_hook"
+        self.hook = hooks.add_custom_hook(self.hook_name)
+
+    def tearDown(self):
+        hooks.remove_custom_hook(self.hook_name)
+        self.assertFalse(hasattr(hooks, self.hook_name))
+        super(CustomHooksTest, self).tearDown()
+
+    def test_hooks_are_globally_available_through_hooks_module(self):
+        self.assertIsInstance(hooks.some_custom_hook, gossip.hooks.Hook)  # pylint: disable=no-member
+        self.assertIs(hooks.some_custom_hook, self.hook)  # pylint: disable=no-member
+
+    def test_ensure_custom_hook(self):
+        self.assertIs(hooks.ensure_custom_hook(self.hook_name), self.hook)
+        new_hook = hooks.ensure_custom_hook("new_custom_hook")
+        self.addCleanup(hooks.remove_custom_hook, "new_custom_hook")
+        self.assertIs(new_hook, hooks.new_custom_hook)  # pylint: disable=no-member
+
+    def test_hooks_appear_in_get_all_hooks(self):
+        all_hooks = dict(hooks.get_all_hooks())
+        self.assertIs(all_hooks[self.hook_name], self.hook)
+
+    def test_cannot_reinstall_hook_twice(self):
+        with self.assertRaises(gossip.exceptions.NameAlreadyUsed):
+            hooks.add_custom_hook(self.hook_name)
+
+    def test_cannot_install_default_hooks(self):
+        with self.assertRaises(gossip.exceptions.NameAlreadyUsed):
+            hooks.add_custom_hook("test_start")
diff --git a/tests/test_id_space.py b/tests/test_id_space.py
new file mode 100755
index 0000000000..1f3e8c527c
--- /dev/null
+++ b/tests/test_id_space.py
@@ -0,0 +1,11 @@
+from .utils import TestCase
+from slash import Session
+
+class TestIDSpace(TestCase):
+    def test_ids_are_unique(self):
+        ids = []
+        for _ in range(2):
+            with Session() as session:
+                ids.append(session.id)
+                ids.append(session.id_space.allocate())
+        self.assertEqual(len(ids), len(set(ids)), "IDs are not unique")
diff --git a/tests/test_interactive.py b/tests/test_interactive.py
new file mode 100755
index 0000000000..8568ac0e14
--- /dev/null
+++ b/tests/test_interactive.py
@@ -0,0 +1,58 @@
+# pylint: disable=redefined-outer-name
+from munch import Munch
+import pytest
+import slash
+from slash.utils import interactive
+from slash import start_interactive_shell
+
+
+def test_interactive_test(suite, interactive_checkpoint):
+
+    summary = suite.run(additional_args=['-i'])
+    assert interactive_checkpoint.called
+
+    result = next(summary.session.results.iter_test_results())
+    assert repr(result.test_metadata) == '<Interactive>'
+    assert result.test_metadata.file_path == '<Interactive>'
+
+
+@pytest.mark.parametrize('with_session', [True, False])
+def test_interactive_scope(forge, with_session):
+    interact_mock = forge.replace(interactive, '_interact')
+
+    interact_mock({'x': 2, 'y': 3})
+    forge.replay()
+
+    if with_session:
+        with slash.Session():
+            slash.g.x = 2
+            start_interactive_shell(y=3)
+    else:
+        start_interactive_shell(x=2, y=3)
+
+
+def test_interactive_planned_tests(interactive_checkpoint, suite):
+
+    counts = Munch(original=len(suite), got=None)
+
+    @slash.hooks.register
+    def tests_loaded(tests):    # pylint: disable=unused-variable
+        counts.got = len(tests)
+
+    suite.run(additional_args=['-i'])
+    assert interactive_checkpoint.called
+    assert counts.got == counts.original + 1
+
+
+
+@pytest.fixture
+def interactive_checkpoint(checkpoint, forge):
+    def _interact(*_, **__):  # pylint: disable=unused-argument
+        assert slash.context.session.scope_manager.get_current_stack() == ['session', 'module', 'test']
+        assert slash.context.test.__slash__.is_interactive()
+        assert slash.context.test.__slash__.id
+        checkpoint()
+
+    forge.replace_with(interactive, '_interact', _interact)
+
+    return checkpoint
diff --git a/tests/test_interruptions.py b/tests/test_interruptions.py
new file mode 100755
index 0000000000..8feffcd0dc
--- /dev/null
+++ b/tests/test_interruptions.py
@@ -0,0 +1,193 @@
+# pylint: disable=unused-argument,unused-variable,redefined-outer-name
+import gossip
+import pytest
+
+import slash
+import slash.hooks
+
+from .conftest import Checkpoint
+
+
+def test_interruption(interrupted_suite, interrupted_index):
+    interrupted_suite.run(expect_interruption=True)
+
+
+def test_interruption_added_to_result(interrupted_suite, interrupted_index):
+    caught = []
+    @gossip.register('slash.interruption_added')
+    def interruption_added(result, exception):
+        caught.append(exception)
+
+    summary = interrupted_suite.run(expect_interruption=True)
+    assert len(caught) == 1
+    [err] = caught              # pylint: disable=unbalanced-tuple-unpacking
+    assert err.exception_type is KeyboardInterrupt
+
+
+def test_interruption_triggers_gossip(request, interrupted_suite, interrupted_test):
+    test_id = {'value': None}
+
+    @gossip.register('slash.test_interrupt')
+    def skip():
+        test_id['value'] = slash.test.__slash__.id
+
+    @request.addfinalizer
+    def cleanup():
+        skip.gossip.unregister()
+
+    summary = interrupted_suite.run(expect_interruption=True)
+    assert test_id['value'] is not None
+    for result in summary.get_all_results_for_test(interrupted_test):
+        assert result.test_metadata.id == test_id['value']
+
+
+def test_critical_cleanups_called(interrupted_suite, interrupted_test):
+    cleanup = interrupted_test.add_deferred_event(
+        'slash.add_critical_cleanup', 'critical_cleanup')
+    summary = interrupted_suite.run(expect_interruption=True)
+    assert cleanup in summary.events
+
+
+def test_non_critical_cleanups_not_called(interrupted_suite, interrupted_test):
+    cleanup = interrupted_test.add_cleanup()
+    summary = interrupted_suite.run(expect_interruption=True)
+    assert cleanup not in summary.events
+
+
+def test_sigterm_interrupt(suite, suite_test):
+    suite_test.append_line('raise slash.exceptions.TerminatedException()')
+    suite_test.expect_interruption()
+    for test in suite.iter_all_after(suite_test):
+        test.expect_deselect()
+    suite.run(expect_interruption=True)
+
+
+@pytest.mark.parametrize('hook_name', ['session_start', 'test_start'])
+def test_sigterm_on_hook(suite, hook_name):
+    @gossip.register('slash.{0}'.format(hook_name))
+    def session_start():  # pylint: disable=unused-variable
+        raise slash.exceptions.TerminatedException('Terminated by signal')
+
+    assert suite
+    for index, test in enumerate(suite):
+        if index == 0 and hook_name == 'test_start':
+            # first test should be interrupted...
+            test.expect_interruption()
+        else:
+            test.expect_deselect()
+
+    result = suite.run(expect_interruption=True)
+
+
+def test_test_end_called_for_interrupted_test(interrupted_suite, interrupted_test):
+    ended = []
+
+    @gossip.register('slash.test_end')
+    def test_end():
+        ended.append(slash.context.test.__slash__.id)
+
+    s = interrupted_suite.run(expect_interruption=True)
+    result = s[interrupted_test]
+
+    assert result.test_metadata.id in ended
+
+
+def test_session_interruption_in_start(suite, suite_test, session_interrupt):
+
+    @suite.slashconf.append_body
+    def __code__():
+        @slash.hooks.session_start.register # pylint: disable=no-member
+        def session_cleanup():
+            raise KeyboardInterrupt()
+
+    for test in suite:
+        test.expect_deselect()
+
+    suite.run(expect_interruption=True)
+
+    assert session_interrupt.called_count == 1
+
+
+def test_interrupt_hooks_should_be_called_once(suite, suite_test, is_last_test, session_interrupt, test_interrupt_callback):
+
+    @suite_test.append_body
+    def __code__():
+        @slash.add_critical_cleanup
+        def cleanup():
+            raise KeyboardInterrupt('A')
+        raise KeyboardInterrupt('B')
+
+    suite_test.expect_interruption()
+
+    for t in suite.iter_all_after(suite_test, assert_has_more=not is_last_test):
+        t.expect_deselect()
+
+    result = suite.run(expect_interruption=True)
+
+    assert test_interrupt_callback.called_count == 1
+    assert session_interrupt.called_count == 1
+    assert result.session.results.global_result.is_interrupted()
+
+
+def test_interrupted_with_custom_exception(suite, suite_test, request):
+
+    import test
+
+    class CustomException(Exception):
+        pass
+    test.__interruption_exception__ = CustomException
+
+    prev_interruption_exceptions = slash.exceptions.INTERRUPTION_EXCEPTIONS
+    slash.exceptions.INTERRUPTION_EXCEPTIONS += (CustomException,)
+
+    @request.addfinalizer
+    def cleanup():
+        del test.__interruption_exception__
+        slash.exceptions.INTERRUPTION_EXCEPTIONS = prev_interruption_exceptions
+
+
+    suite_test.append_line('import test')
+    suite_test.append_line('raise test.__interruption_exception__()')
+    suite_test.expect_interruption()
+
+    for t in suite.iter_all_after(suite_test):
+        t.expect_deselect()
+
+    results = suite.run(expect_interruption=True)
+
+
+
+@pytest.fixture
+def session_interrupt():
+    callback = Checkpoint()
+    slash.hooks.session_interrupt.register(callback) # pylint: disable=no-member
+    return callback
+
+
+@pytest.fixture
+def test_interrupt_callback():
+    callback = Checkpoint()
+    slash.hooks.test_interrupt.register(callback) # pylint: disable=no-member
+    return callback
+
+
+@pytest.fixture
+def interrupted_suite(suite, interrupted_index):
+    for index, test in enumerate(suite):
+        if index == interrupted_index:
+            test.append_line('raise KeyboardInterrupt()')
+            test.expect_interruption()
+        elif index > interrupted_index:
+            test.expect_deselect()
+
+    return suite
+
+
+@pytest.fixture
+def interrupted_test(interrupted_suite, interrupted_index):
+    return interrupted_suite[interrupted_index]
+
+
+@pytest.fixture
+def interrupted_index(suite):
+    return int(len(suite) // 2)
diff --git a/tests/test_invalid_test_detection.py b/tests/test_invalid_test_detection.py
new file mode 100755
index 0000000000..bc8fc5a0b2
--- /dev/null
+++ b/tests/test_invalid_test_detection.py
@@ -0,0 +1,9 @@
+from slash.exceptions import InvalidTest
+
+def test_accidental_generator(suite, suite_test):
+    suite_test.append_line('yield')
+    suite_test.expect_error()
+    res = suite.run()[suite_test]
+    [err] = res.get_errors()
+    assert err.exception_type is InvalidTest
+    assert 'is a generator' in err.message
diff --git a/tests/test_iteration.py b/tests/test_iteration.py
new file mode 100755
index 0000000000..8547ac15e1
--- /dev/null
+++ b/tests/test_iteration.py
@@ -0,0 +1,82 @@
+# pylint: disable=redefined-outer-name
+import itertools
+
+import pytest
+from slash.utils.iteration import iteration, PeekableIterator, iter_cartesian_dicts
+from slash._compat import iteritems
+
+
+def test_iteration(objects):
+    for index, i in enumerate(iteration(objects)):
+        assert i.last_counter0 + 1 == i.last_counter1 == i.total
+        assert i.counter0 == index
+        assert i.counter1 == index + 1
+        if index == 0:
+            assert i.first
+        else:
+            assert not i.first
+        assert i.element is objects[index]
+        assert index <= len(objects) - 1
+        if index == len(objects) - 1:
+            assert i.last
+        else:
+            assert not i.last
+
+
+def test_iteration_unpacking(objects):
+    for index, (i, obj) in enumerate(iteration(objects)):
+        assert index == i.counter0
+        assert obj is i.element
+        assert obj is objects[i.counter0]
+
+
+def test_iteration_unsupported_sizing():
+    for i in iteration(x for x in itertools.count()):
+        assert i.first
+        with pytest.raises(NotImplementedError):
+            i.last  # pylint: disable=pointless-statement
+        assert i.last_counter0 is None
+        assert i.last_counter1 is None
+        break
+
+
+def test_peekable_iterator(objects):
+    it = PeekableIterator(objects)
+    for i, x in enumerate(it):
+        assert x is objects[i]
+        # no matter how many times we peek, we get the same result
+        for _ in range(3):
+            if i == len(objects) - 1:
+                assert not it.has_next()
+                with pytest.raises(StopIteration):
+                    it.peek()
+                assert it.peek_or_none() is None
+            else:
+                assert it.has_next()
+                assert it.peek() is objects[(i + 1)]
+                assert it.peek_or_none() is objects[(i + 1)]
+
+
+def test_cartesian_dict():
+
+    params = {
+        'a': [1, 2, 3],
+        'b': [4, 5],
+        'c': [6, 7],
+    }
+
+    assert set(frozenset(iteritems(x)) for x in iter_cartesian_dicts(params)) == \
+        set(frozenset([('a', a_value), ('b', b_value), ('c', c_value)])
+            for a_value, b_value, c_value in itertools.product(params['a'], params['b'], params['c']))
+
+
+@pytest.fixture(params=[True, False])
+def use_iterator(request):
+    return request.param
+
+
+@pytest.fixture
+def objects(use_iterator):
+    if use_iterator:
+        return range(10)
+    return [object() for _ in range(10)]
diff --git a/tests/test_list_config.py b/tests/test_list_config.py
new file mode 100755
index 0000000000..415682b128
--- /dev/null
+++ b/tests/test_list_config.py
@@ -0,0 +1,13 @@
+from slash.frontend.list_config import list_config
+from slash._compat import StringIO
+
+
+def test_slash_list_config():
+    report_stream = StringIO()
+    list_config([], report_stream)
+    assert report_stream.getvalue()
+
+def test_slash_list_config_with_filters():
+    report_stream = StringIO()
+    list_config(['log'], report_stream)
+    assert 'log.root' in report_stream.getvalue()
diff --git a/tests/test_list_plugins.py b/tests/test_list_plugins.py
new file mode 100755
index 0000000000..e9de89f77d
--- /dev/null
+++ b/tests/test_list_plugins.py
@@ -0,0 +1,43 @@
+# pylint: disable=redefined-outer-name
+import pytest
+from slash._compat import StringIO
+from slash.frontend.slash_list_plugins import slash_list_plugins
+from slash.plugins import manager, PluginInterface
+
+
+def test_slash_list_plugins(report_stream):
+    slash_list_plugins([], report_stream=report_stream)
+    output = report_stream.getvalue()
+    assert output
+    installed = manager.get_installed_plugins()
+    for plugin_name in installed:
+        assert plugin_name in output
+
+
+def test_slash_list_plugins_for_internal_plugins(report_stream):
+    internal_plugin = InternalPlugin()
+    manager.install(internal_plugin, is_internal=True)
+    slash_list_plugins([], report_stream=report_stream)
+    output = report_stream.getvalue()
+    assert output
+
+    assert internal_plugin.get_name() in manager.get_installed_plugins()
+    assert internal_plugin.get_name() not in output
+    assert '--internal-plugin-option' not in output
+
+
+@pytest.fixture
+def report_stream():
+    return StringIO()
+
+
+class InternalPlugin(PluginInterface):
+
+    def get_name(self):
+        return "internal-plugin"
+
+    def configure_argument_parser(self, parser):
+        parser.add_argument("--internal-plugin-option")
+
+    def configure_from_parsed_args(self, args):
+        self.cmdline_param = args.plugin_option
diff --git a/tests/test_loader.py b/tests/test_loader.py
new file mode 100755
index 0000000000..fc7d6432cc
--- /dev/null
+++ b/tests/test_loader.py
@@ -0,0 +1,167 @@
+import os
+from uuid import uuid4
+
+import pytest
+
+from slash import Session
+from slash.exceptions import CannotLoadTests
+from slash.loader import Loader
+
+from .utils.suite_writer import Suite
+
+
+def test_total_num_tests(suite):
+    suite.debug_info = False
+
+    path = suite.commit()
+
+    with Session() as s:
+        Loader().get_runnables(path)
+        assert s.get_total_num_tests() == len(suite)
+
+
+def test_loader_sort_filenames(tmpdir):
+
+    tests_dir = tmpdir.join(str(uuid4()))
+
+    filenames = []
+
+    for _ in range(10):
+        filename = str(uuid4()).replace('-', '') + '.py'
+
+        with tests_dir.join(filename).open('w', ensure=True) as f:
+            f.write('def test_something():\n    pass')
+
+        filenames.append(filename)
+
+    with Session():
+        runnables = Loader().get_runnables(str(tests_dir))
+
+    assert [os.path.basename(runnable.__slash__.file_path) for runnable in runnables] == sorted(filenames)
+
+
+def test_loader_skips_empty_dirs(tmpdir):
+    tests_dir = tmpdir.join('tests')
+    with tests_dir.join('.dir').join('test_something.py').open('w', ensure=True) as f:
+        f.write('def test_something():\n    pass')
+
+    with Session():
+        runnables = Loader().get_runnables(str(tests_dir))
+
+    assert runnables == []
+
+
+def test_loader_warns_duplicate_test_funcs(tmpdir):
+    tests_dir = tmpdir.join('tests')
+    full_path = tests_dir.join('.dir').join('test_something.py')
+    test_name = 'test_something'
+    with full_path.open('w', ensure=True) as f:
+        f.write('def {0}():\n    assert True\n'.format(test_name))
+        f.write('def {0}():\n    assert True\n'.format(test_name))
+    with Session() as session:
+        Loader().get_runnables([str(full_path)])
+        assert len(session.warnings) == 1
+        assert 'Duplicate' in session.warnings.warnings[0].details['message']
+        assert test_name in session.warnings.warnings[0].details['message']
+
+
+def test_loader_warns_on_duplicate_fixtures(suite):
+    fixture_name = 'fixture_name'
+    fixture1 = suite.slashconf.add_fixture(name=fixture_name)
+    fixture1.append_line('assert this == slash.context.fixture')
+    fixture2 = suite.slashconf.add_fixture(name=fixture_name)
+    fixture2.append_line('assert this == slash.context.fixture')
+    summary = suite.run()
+    assert len(summary.session.warnings) == 1
+    assert 'Duplicate' in summary.session.warnings.warnings[0].details['message']
+    assert fixture_name in summary.session.warnings.warnings[0].details['message']
+
+
+@pytest.mark.parametrize('specific_method', [True, False])
+@pytest.mark.parametrize('with_parameters', [True, False])
+def test_iter_specific_factory(suite, suite_test, specific_method, with_parameters):
+
+    if suite_test.cls is not None and specific_method:
+        suite_test.cls.add_method_test()
+
+    if with_parameters:
+        suite_test.add_parameter()
+
+    for test in suite:
+        if suite_test.cls is None and test is not suite_test:
+            # we are selecting a specific function, and that's not it:
+            test.expect_deselect()
+        elif suite_test.cls is not None and test.cls is not suite_test.cls:
+            test.expect_deselect()
+        elif specific_method and suite_test.cls is test.cls and suite_test is not test:
+            test.expect_deselect()
+
+    path = suite.commit()
+    if suite_test.cls:
+        assert suite_test.cls.tests
+        factory_name = suite_test.cls.name
+    else:
+        factory_name = suite_test.name
+
+    pattern = '{0}:{1}'.format(os.path.join(path, suite_test.file.get_relative_path()), factory_name)
+    if suite_test.cls is not None and specific_method:
+        assert len(suite_test.cls.tests) > 1
+        pattern += '.{0}'.format(suite_test.name)
+    suite.run(args=[pattern])
+
+
+def test_import_error_registers_as_session_error(active_slash_session, test_loader):
+    with pytest.raises(CannotLoadTests):
+        test_loader.get_runnables(["/non/existent/path"])
+    errors = active_slash_session.results.global_result.get_errors()
+    assert len(errors) == 1
+    [error] = errors  # pylint: disable=unused-variable
+
+def test_no_traceback_for_slash_exception():
+    suite = Suite()
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.session.results.is_success()
+    [err] = summary.session.results.global_result.get_errors()
+    assert err.exception_type is CannotLoadTests
+    output = summary.get_console_output()
+    assert 'Traceback' not in output
+
+def test_no_traceback_for_marked_exceptions():
+    suite = Suite()
+
+    @suite.slashconf.append_body
+    def __code__():  # pylint: disable=unused-variable
+        from slash.exception_handling import inhibit_unhandled_exception_traceback
+        raise inhibit_unhandled_exception_traceback(Exception('Some Error'))
+
+    summary = suite.run(expect_session_errors=True)
+    assert not summary.session.results.is_success()
+    errors = summary.session.results.global_result.get_errors()
+    assert [err.exception_type for err in errors] == [Exception, CannotLoadTests]
+    assert 'Some Error' in errors[0].exception_str
+    output = summary.get_console_output()
+    assert 'Traceback' not in output
+
+def test_import_errors_with_session():
+
+    suite = Suite()
+
+    for _ in range(20):
+        suite.add_test()
+
+    problematic = suite.files[1]
+    problematic.prepend_line('from nonexistent import nonexistent')
+
+    for test in suite:
+        test.expect_deselect()
+
+    summary = suite.run(expect_session_errors=True)
+
+    assert summary.exit_code != 0
+
+    errs = summary.session.results.global_result.get_errors()
+    for err in errs:
+        assert 'No module named nonexistent' in err.message or "No module named 'nonexistent'" in err.message
+
+
+    return suite
diff --git a/tests/test_local_config.py b/tests/test_local_config.py
new file mode 100755
index 0000000000..f057ef7069
--- /dev/null
+++ b/tests/test_local_config.py
@@ -0,0 +1,55 @@
+# pylint: disable=redefined-outer-name
+from uuid import uuid1
+
+import pytest
+from slash._compat import iteritems, OrderedDict
+from slash.core.local_config import LocalConfig
+
+
+def test_local_conf(local_conf, expected_dict):
+    conf = local_conf.get_dict()
+    for key, value in iteritems(expected_dict):
+        assert [value] == conf[key]
+
+
+def test_local_conf_loading_multiple_times(local_conf_dir, expected_dict):
+    items = list(iteritems(expected_dict))
+    local_conf = LocalConfig()
+
+    local_conf.push_path(str(local_conf_dir.join('..')))
+    var_name, var_value = items[0]
+    var = local_conf.get_dict()[var_name]
+    assert var == [var_value]
+
+    local_conf.push_path(str(local_conf_dir))
+
+    assert var is local_conf.get_dict()[var_name]
+
+
+def test_local_conf_nonexistent_dir():
+    with pytest.raises(RuntimeError):
+        LocalConfig().push_path('/nonexistent/dir')
+
+
+@pytest.fixture
+def local_conf(local_conf_dir):
+    returned = LocalConfig()
+    returned.push_path(str(local_conf_dir))
+    return returned
+
+
+@pytest.fixture
+def local_conf_dir(tmpdir, expected_dict):
+    returned = tmpdir
+    for i, (key, value) in enumerate(iteritems(expected_dict)):
+        returned = returned.join('subdir{0}'.format(i))
+        returned.mkdir()
+
+        with returned.join('slashconf.py').open('w') as f:
+            f.write('{0} = [{1!r}]'.format(key, value))
+    return returned
+
+
+@pytest.fixture
+def expected_dict():
+    return OrderedDict(('key_{0}'.format(i), 'value_{0}_{1}'.format(i, uuid1())) for i in range(10))
diff --git a/tests/test_logging.py b/tests/test_logging.py
new file mode 100755
index 0000000000..429a074a2b
--- /dev/null
+++ b/tests/test_logging.py
@@ -0,0 +1,352 @@
+# pylint: disable=unused-argument,redefined-outer-name
+import functools
+import os
+
+import logbook
+
+import gossip
+import pytest
+import slash
+
+from .utils import run_tests_assert_success, run_tests_in_session, TestCase
+
+
+def test_console_format(suite, suite_test, config_override, tmpdir):
+    config_override('log.format', 'file: {record.message}')
+    config_override('log.console_format', 'console: {record.message}')
+    config_override('log.root', str(tmpdir))
+    suite_test.append_line('slash.logger.error("message here")')
+    summary = suite.run(additional_args=['-vvv'])
+
+    assert 'console: message here' in summary.get_console_output()
+
+    [result] = summary.get_all_results_for_test(suite_test)
+    with open(result.get_log_path()) as f:
+        assert 'file: message here' in f.read()
+
+
+def test_last_session_symlinks(files_dir, links_dir, session):
+
+    test_log_file = files_dir.join(
+        session.id, list(session.results.iter_test_results())[-1].test_metadata.id, "debug.log")
+    assert test_log_file.check()
+    session_log_file = files_dir.join(session.id, "session.log")
+    assert session_log_file.check()
+
+    assert links_dir.join("last-session").readlink() == session_log_file
+    assert links_dir.join("last-session-dir").readlink() == session_log_file.dirname
+    assert links_dir.join("last-test").readlink() == test_log_file
+
+
+def test_global_result_get_log_path(files_dir, suite):
+    summary = suite.run()
+    assert summary.session.results.global_result.get_log_path() is not None
+    assert summary.session.results.global_result.get_log_path().startswith(str(files_dir))
+
+
+def test_log_file_colorize(files_dir, config_override, suite, suite_test):
+    config_override('log.colorize', True)
+    suite_test.append_line('slash.logger.notice("hey")')
+    summary = suite.run()
+    logfiles = [
+        summary.session.results.global_result.get_log_path(),
+        summary.get_all_results_for_test(suite_test)[0].get_log_path(),
+    ]
+    for logfile in logfiles:
+        with open(logfile, 'rb') as f:
+            log_data = f.read()
+
+        assert b'\x1b[' in log_data
+
+
+@pytest.mark.parametrize('level', ['info', 'notice', 'warning'])
+def test_console_truncation_does_not_truncate_files(files_dir, suite, suite_test, config_override, level):
+    assert slash.config.root.log.truncate_console_lines
+
+    long_string = 'a' * 1000
+    suite_test.append_line('slash.logger.{level}({msg!r})'.format(msg=long_string, level=level))
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    with open(result.get_log_path()) as logfile:
+        logfile_data = logfile.read()
+        assert long_string in logfile_data
+
+
+@pytest.mark.parametrize('symlink_name', ['last_session_symlink', 'last_session_dir_symlink', 'last_failed_symlink'])
+def test_log_symlinks_without_root_path(suite, config_override, symlink_name):
+    config_override('log.{0}'.format(symlink_name), 'some/subdir')
+    assert suite.run().ok()
+
+
+def test_last_test_not_overriden_by_stop_on_error(links_dir, suite):
+    failed_test = suite[4]
+    failed_test.when_run.fail()
+    # we stop on error...
+    for test in suite[5:]:
+        test.expect_not_run()
+    summary = suite.run(additional_args=['-x'])
+
+    [failed_result] = summary.get_all_results_for_test(failed_test)
+
+    for link_name in ('last-test', 'last-failed'):
+        assert links_dir.join(link_name).readlink() == failed_result.get_log_path()
+
+
+def test_last_test_delete_log_file(links_dir, suite, suite_test):
+    os.makedirs(str(links_dir))
+    temp_file = os.path.abspath(str(links_dir.join('somepath')))
+    with open(temp_file, 'w'):
+        pass
+    os.symlink(temp_file, str(links_dir.join('last-test')))
+    os.unlink(temp_file)
+
+    assert not os.path.exists(str(links_dir.join('last-test')))
+    assert os.path.islink(str(links_dir.join('last-test')))
+
+    summary = suite.run()
+    with open(summary.session.results.global_result.get_log_path()) as f:
+        assert 'OSError: ' not in f.read()
+    # assert links_dir.join('last-test').readlink() == list(summary.session.results)[-1].get_log_path()
+
+
+def test_result_log_links(files_dir, session):
+
+    for result in session.results.iter_test_results():
+        assert result.get_log_path() is not None
+        assert result.get_log_path().startswith(str(files_dir))
+
+
+def test_last_failed(suite, links_dir):
+    suite[-5].when_run.fail()
+    last_failed = suite[-2]
+    last_failed.when_run.fail()
+    summary = suite.run()
+
+    [result] = summary.get_all_results_for_test(last_failed)
+    fail_log = result.get_log_path()
+    assert os.path.isfile(fail_log)
+    assert links_dir.join('last-failed').readlink() == fail_log
+
+
+def test_errors_log_for_test(suite, suite_test, errors_log_path, logs_dir):
+    suite_test.when_run.fail()
+    res = suite.run()[suite_test]
+    with errors_log_path.open() as f:
+        lines = [l for l in f.read().splitlines() if 'NOTICE' not in l]
+        error_line = lines[0]
+    assert 'Error added' in error_line
+    with open(res.get_log_path()) as f:
+        lines = f.read().splitlines()
+        assert error_line in lines
+
+
+def test_errors_log_for_session(suite, errors_log_path, request, logs_dir):
+    @gossip.register('slash.session_start')
+    def on_session_start():
+        try:
+            1/0                     # pylint: disable=pointless-statement
+        except ZeroDivisionError:
+            slash.add_error()
+
+    request.addfinalizer(on_session_start.gossip.unregister)
+    results = suite.run(expect_session_errors=True).session.results
+    assert len(results.global_result.get_errors()) == 1
+    with errors_log_path.open() as f:
+        lines = [l for l in f.read().splitlines() if 'NOTICE' not in l]
+        assert 'Error added' in lines[0]
+
+    with open(results.global_result.get_log_path()) as f:
+        assert lines[0] in f.read().splitlines()
+
+
+
+
+################################################################################
+## Fixtures
+
+@pytest.fixture
+def session():
+    session = run_tests_assert_success(SampleTest)
+    return session
+
+
+@pytest.fixture
+def errors_log_path(request, config_override, tmpdir, logs_dir):
+    subpath = 'subdir/errors.log'
+    config_override('log.highlights_subpath', subpath)
+    return logs_dir.join('files').join(subpath)
+
+
+@pytest.fixture
+def links_dir(logs_dir):
+    return logs_dir.join("links")
+
+
+@pytest.fixture
+def files_dir(logs_dir):
+    return logs_dir.join("files")
+
+
+_TOKEN = "logging-test"
+_SESSION_START_MARK = "session-start-mark"
+_SESSION_END_MARK = "session-end-mark"
+
+_silenced_logger = logbook.Logger("silenced_logger")
+
+
+################################################################################
+## Legacy Tests
+
+
+class LogFormattingTest(TestCase):
+
+    def setUp(self):
+        super(LogFormattingTest, self).setUp()
+        self.log_path = self.get_new_path()
+        self.override_config(
+            "log.root", self.log_path
+        )
+        self.override_config(
+            "log.format", "-- {record.message} --"
+        )
+        self.override_config("log.subpath", "debug.log")
+
+    def test(self):
+        self.session = run_tests_assert_success(SampleTest)
+        with open(os.path.join(self.log_path, "debug.log")) as logfile:
+            for line in logfile:
+                self.assertTrue(line.startswith("-- "))
+                self.assertTrue(line.endswith(" --\n"))
+
+
+class LoggingTest(TestCase):
+
+    def test(self):
+        self.log_path = self.get_new_path()
+        self.override_config(
+            "log.root",
+            self.log_path,
+        )
+        self.override_config(
+            "log.subpath",
+            os.path.join("{context.session.id}",
+                         "{context.test.__slash__.test_index0:03}-{context.test_id}", "debug.log")
+        )
+        self.override_config(
+            "log.session_subpath",
+            os.path.join("{context.session.id}", "debug.log")
+        )
+        self.override_config(
+            "log.silence_loggers",
+            [_silenced_logger.name]
+        )
+
+        self.addCleanup(gossip.unregister_token, _TOKEN)
+        slash.hooks.session_start.register(  # pylint: disable=no-member
+            functools.partial(_mark, _SESSION_START_MARK), token=_TOKEN)
+
+        slash.hooks.session_end.register(  # pylint: disable=no-member
+            functools.partial(_mark, _SESSION_END_MARK), token=_TOKEN)
+        self.addCleanup(gossip.unregister_token, _TOKEN)
+
+        self.session = run_tests_assert_success(SampleTest)
+        self.tests_metadata = [
+            result.test_metadata for result in self.session.results.iter_test_results()]
+        self._test_all_run()
+        self._test_test_logs_written()
+        self._test_session_logs()
+        self._test_no_silenced_logger_records()
+
+    def _test_all_run(self):
+        methods = [
+            method_name for method_name in dir(SampleTest)
+            if method_name.startswith("test")
+        ]
+        self.assertTrue(methods)
+        self.assertEqual(len(self.tests_metadata), len(methods))
+
+    def _test_test_logs_written(self):
+        for test_metadata in self.tests_metadata:
+            test_dir = "{0:03}-{1}".format(test_metadata.test_index0, test_metadata.id)
+            log_path = os.path.join(
+                self.log_path, self.session.id, test_dir, "debug.log")
+            with open(log_path) as f:
+                data = f.read()
+            for other_test in self.tests_metadata:
+                if other_test.id != test_metadata.id:
+                    self.assertNotIn(other_test.id, data)
+            self.assertNotIn(_SESSION_START_MARK, data)
+            self.assertNotIn(_SESSION_END_MARK, data)
+
+    def _test_session_logs(self):
+        with open(os.path.join(self.log_path, self.session.id, "debug.log")) as f:
+            data = f.read()
+        self.assertIn(_SESSION_START_MARK, data)
+        self.assertIn(_SESSION_END_MARK, data)
+        for test_id in (t.id for t in self.tests_metadata):
+            self.assertNotIn(test_id, data)
+
+    def _test_no_silenced_logger_records(self):
+        for path, _, filenames in os.walk(self.log_path):
+            for filename in filenames:
+                assert filename.endswith(".log")
+                filename = os.path.join(path, filename)
+                with open(filename) as f:
+                    assert _silenced_logger.name not in f.read(
+                    ), "Silenced logs appear in log file {0}".format(filename)
+
+
+class ExtraLoggersTest(TestCase):
+
+    def setUp(self):
+        super(ExtraLoggersTest, self).setUp()
+        self.session = slash.Session()
+        self.handler = logbook.TestHandler()
+        self.addCleanup(slash.log.remove_all_extra_handlers)
+        slash.log.add_log_handler(self.handler)
+
+    def test(self):
+        with self.session:
+            run_tests_in_session(SampleTest, session=self.session)
+        for test_result in self.session.results.iter_test_results():
+            for record in self.handler.records:
+                if test_result.test_id in record.message:
+                    break
+            else:
+                self.fail(
+                    "Test id {} does not appear in logger".format(test_result.test_id))
+
+
+class SampleTest(slash.Test):
+
+    def test_1(self):
+        _mark()
+
+    def test_2(self):
+        _silenced_logger.error("error")
+        _silenced_logger.info("info")
+        _silenced_logger.debug("debug")
+        _mark()
+
+
+def _mark(text=None):
+    if text is None:
+        text = slash.context.test_id
+    slash.logger.debug(text)
+
+
+class TestLocaltimeLogging(TestCase):
+
+    def setUp(self):
+        super(TestLocaltimeLogging, self).setUp()
+        self.assertFalse(slash.config.root.log.localtime)
+        self.path = self.get_new_path()
+        self.override_config(
+            "log.localtime", True)
+        self.override_config(
+            "log.root", self.path)
+
+    def test_local_time(self):
+        with slash.Session() as session:  # pylint: disable=unused-variable
+            slash.logger.info("Hello")
+        self.assertNotEqual(os.listdir(self.path), [])
diff --git a/tests/test_nofixtures.py b/tests/test_nofixtures.py
new file mode 100755
index 0000000000..a36e606cd1
--- /dev/null
+++ b/tests/test_nofixtures.py
@@ -0,0 +1,12 @@
+from .utils.suite_writer import Suite
+
+
+
+def test_nofixtures(test_type):
+    suite = Suite()
+    test = suite.add_test(type=test_type)
+    test.add_parameter_string('a=2, b=3')
+    test.append_line('assert a == 2')
+    test.append_line('assert b == 3')
+    test.add_decorator('slash.nofixtures')
+    assert suite.run().ok()
diff --git a/tests/test_object_marker.py b/tests/test_object_marker.py
new file mode 100755
index 0000000000..004236e58f
--- /dev/null
+++ b/tests/test_object_marker.py
@@ -0,0 +1,91 @@
+# pylint: disable=redefined-outer-name
+import pytest
+from slash.utils.marks import get_marks, mark, try_get_mark
+
+
+def test_mark(marked_obj, mark_name, mark_value):
+    assert get_marks(marked_obj) == {mark_name: mark_value}
+
+
+def test_mark_immutable(marked_obj, mark_name, mark_value):
+    marks = get_marks(marked_obj)
+    marks["1"] = ["2"]
+    assert get_marks(marked_obj) == {mark_name: mark_value}
+
+
+def test_try_get_mark(marked_obj, mark_name, mark_value):
+    assert try_get_mark(marked_obj, mark_name) == mark_value
+
+
+def test_try_get_mark_fail(marked_obj):
+    assert try_get_mark(marked_obj, "nonexistent") is None
+
+
+def test_try_get_mark_fail_with_default(marked_obj):
+    _default = object()
+    assert try_get_mark(marked_obj, "nonexistent", _default) is _default
+
+def test_mark_append():
+
+    class Obj(object):
+        pass
+
+    mark_name = 'some_mark'
+    assert try_get_mark(Obj, mark_name) is None
+    assert mark(mark_name, 'mark_value', append=True)(Obj) is Obj
+    assert get_marks(Obj) == {mark_name: ['mark_value']}
+
+@pytest.mark.parametrize('obj', [1, None, object(), type, "string"])
+def test_try_get_mark_fail_non_marked(obj):
+    assert try_get_mark(obj, "mark") is None
+
+### Boilerplate ###
+
+mark_factories = []
+
+markfactory = mark_factories.append
+
+
+@markfactory
+def markfactory_class(mark_name, mark_value):
+    @mark(mark_name, mark_value)
+    class Blap(object):
+        pass
+
+    return Blap
+
+
+@markfactory
+def markfactory_func(mark_name, mark_value):
+    @mark(mark_name, mark_value)
+    def func():
+        pass
+
+    return func
+
+
+@markfactory
+def method(mark_name, mark_value):
+    class Blap(object):
+
+        @mark(mark_name, mark_value)
+        def func(self):
+            pass
+
+    return Blap.func
+
+
+@pytest.fixture(params=mark_factories)
+def marked_obj(request, mark_name, mark_value):
+    returned = request.param(mark_name, mark_value)
+    return returned
+
+
+@pytest.fixture(params=['mark_name'])
+def mark_name(request):
+    return request.param
+
+
+@pytest.fixture(params=['mark_value', 1, True, 1.0])
+def mark_value(request):
+    return request.param
diff --git a/tests/test_parallel.py b/tests/test_parallel.py
new file mode 100755
index 0000000000..ba885cbeab
--- /dev/null
+++ b/tests/test_parallel.py
@@ -0,0 +1,324 @@
+import slash
+import os
+import signal
+from .utils.suite_writer import Suite
+from slash.resuming import get_tests_to_resume
+from slash.exceptions import InteractiveParallelNotAllowed, ParallelTimeout
+from slash.parallel.server import ServerStates
+from slash.parallel.parallel_manager import ParallelManager
+from slash import Session
+from slash.loader import Loader
+import time
+import tempfile
+import pytest
+
+@pytest.fixture(scope='module', autouse=True)
+def no_parallel_user_config(request):
+    tmpdir = tempfile.mkdtemp()
+    path = os.path.join(tmpdir, 'slashrc')
+    os.environ["SLASH_USER_SETTINGS"] = path
+
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        os.rmdir(tmpdir)
+        del os.environ["SLASH_USER_SETTINGS"]
+
+#basic features of parallel
+def run_specific_workers_and_tests_num(workers_num, tests_num=10):
+    suite = Suite(debug_info=False, is_parallel=True)
+    suite.populate(num_tests=tests_num)
+    summary = suite.run(num_workers=workers_num)
+    assert len(summary.session.parallel_manager.server.worker_session_ids) == workers_num
+    assert summary.session.results.get_num_successful() == tests_num
+    assert summary.session.results.is_success()
+    return summary
+
+def test_one_worker():
+    run_specific_workers_and_tests_num(workers_num=1)
+
+def test_many_workers():
+    run_specific_workers_and_tests_num(workers_num=3, tests_num=50)
+
+def test_zero_workers(parallel_suite):
+    summary = parallel_suite.run(num_workers=0) #should act like regular run of slash, not parallel
+    assert summary.session.results.is_success()
+    assert summary.session.parallel_manager is None
+
+def test_test_causes_worker_exit(parallel_suite, config_override):
+    config_override("parallel.communication_timeout_secs", 2)
+    parallel_suite[0].append_line("import os")
+    parallel_suite[0].append_line("os._exit(0)")
+    parallel_suite[0].expect_interruption()
+    workers_num = 1
+    summary = parallel_suite.run(num_workers=workers_num, verify=False)
+    assert len(summary.session.parallel_manager.server.worker_session_ids) == workers_num
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert result.is_interrupted()
+
+def test_keepalive_works(parallel_suite, config_override):
+    config_override("parallel.communication_timeout_secs", 2)
+    parallel_suite[0].append_line("import time")
+    parallel_suite[0].append_line("time.sleep(6)")
+    workers_num = 1
+    summary = parallel_suite.run(num_workers=workers_num)
+    assert len(summary.session.parallel_manager.server.worker_session_ids) == workers_num
+    assert summary.session.results.is_success()
+
+def test_server_fails(parallel_suite):
+
+    @slash.hooks.worker_connected.register  # pylint: disable=no-member, unused-argument
+    def simulate_ctrl_c(session_id):  # pylint: disable=unused-variable, unused-argument
+        pid = os.getpid()
+        os.kill(pid, signal.SIGINT)
+
+    @slash.hooks.session_interrupt.register  # pylint: disable=no-member
+    def check_workers_and_server_down():  # pylint: disable=unused-variable
+        for worker in slash.context.session.parallel_manager.workers.values():
+            ret = worker.poll()
+            assert not ret is None
+        assert slash.context.session.parallel_manager.server.interrupted
+        assert not slash.context.session.parallel_manager.server.finished_tests
+
+    for test in parallel_suite:
+        test.expect_deselect()
+    parallel_suite.run(expect_interruption=True)
+
+
+#test slash features with parallel
+def test_test_success(parallel_suite):
+    results = parallel_suite.run().session.results
+    assert results.is_success()
+    assert results.get_num_successful() == len(parallel_suite)
+
+def test_test_failure(parallel_suite):
+    parallel_suite[0].when_run.fail()
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    [failures] = result.get_failures()
+    assert 'AssertionError' in str(failures)
+    assert 'assert False' in str(failures)
+
+def test_stop_on_error(parallel_suite, parallel_suite_test):
+    parallel_suite_test.when_run.fail()
+    summary = parallel_suite.run(additional_args=['-x'], verify=False)
+    [result] = summary.get_all_results_for_test(parallel_suite_test)
+    assert result.is_failure()
+
+    found_failure = False
+    for result in summary.session.results:
+        if result.is_failure():
+            found_failure = True
+            continue
+        if found_failure:
+            assert result.is_not_run()
+    assert found_failure
+
+def test_pass_override_conf_flag(parallel_suite):
+    summary = parallel_suite.run(additional_args=['-o', 'parallel.server_port=8001'])
+    results = summary.session.results
+    assert results.is_success()
+    assert results.get_num_successful() == len(parallel_suite)
+    assert summary.session.parallel_manager.server.port == 8001
+
+def test_test_error(parallel_suite):
+    parallel_suite[0].append_line('slash.add_error()')
+    parallel_suite[0].expect_error()
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    [err] = result.get_errors()
+    assert 'RuntimeError' in str(err)
+    assert 'add_error() must be called' in str(err)
+
+def test_test_interruption_causes_communication_timeout(parallel_suite, config_override):
+    config_override("parallel.communication_timeout_secs", 2)
+    parallel_suite[0].when_run.interrupt()
+    summary = parallel_suite.run(num_workers=1, verify=False)
+    [interrupted_result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert interrupted_result.is_interrupted()
+    for result in summary.session.results:
+        if result != interrupted_result:
+            assert result.is_success() or result.is_not_run()
+
+def test_test_interruption_causes_no_requests(parallel_suite, config_override):
+    config_override("parallel.no_request_timeout", 2)
+    parallel_suite[0].when_run.interrupt()
+    summary = parallel_suite.run(num_workers=1, verify=False)
+    assert summary.get_all_results_for_test(parallel_suite[0]) == []
+
+def test_test_skips(parallel_suite):
+    parallel_suite[0].add_decorator('slash.skipped("reason")')
+    parallel_suite[0].expect_skip()
+    results = parallel_suite.run().session.results
+    assert results.is_success(allow_skips=True)
+    assert results.get_num_skipped() == 1
+    for result in results:
+        if result.is_skip():
+            assert 'reason' in result.get_skips()
+
+def test_session_warnings(parallel_suite):
+    parallel_suite[0].append_line("import warnings")
+    parallel_suite[0].append_line("warnings.warn('message')")
+    session_results = parallel_suite.run().session
+    assert len(session_results.warnings) == 1
+    [w] = session_results.warnings
+    assert w.message == 'message'
+
+def test_traceback_vars(parallel_suite):
+    #code to be inserted:
+        #     def test_traceback_frames():
+        #     num = 0
+        #     a()
+        #
+        # def a():
+        #     x=1
+        #     assert False
+    parallel_suite[0].append_line("def a():")
+    parallel_suite[0].append_line("   num = 0")
+    parallel_suite[0].append_line("   b()")
+    parallel_suite[0].append_line("def b():")
+    parallel_suite[0].append_line("   x=1")
+    parallel_suite[0].append_line("   assert False")
+    parallel_suite[0].append_line("a()")
+    parallel_suite[0].expect_failure()
+    summary = parallel_suite.run(num_workers=1)
+    results = summary.session.results
+    found_failure = 0
+    for result in results:
+        if result.is_failure():
+            found_failure += 1
+            assert len(result.get_failures()) == 1
+            assert len(result.get_failures()[0].traceback.frames) == 3
+    assert found_failure == 1
+
+def test_result_data_not_picklable(parallel_suite):
+    parallel_suite[0].append_line("import socket")
+    parallel_suite[0].append_line("s = socket.socket()")
+    parallel_suite[0].append_line("slash.context.result.data.setdefault('socket', s)")
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert result.data == {}
+
+def test_result_data_is_picklable(parallel_suite):
+    parallel_suite[0].append_line("slash.context.result.data.setdefault('num', 1)")
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert 'num' in result.data
+    assert result.data['num'] == 1
+
+def test_result_details_not_picklable(parallel_suite):
+    parallel_suite[0].append_line("import socket")
+    parallel_suite[0].append_line("s = socket.socket()")
+    parallel_suite[0].append_line("slash.context.result.details.append('socket', s)")
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert result.details.all() == {}
+
+def test_result_details_is_picklable(parallel_suite):
+    parallel_suite[0].append_line("slash.context.result.details.append('num', 1)")
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    details = result.details.all()
+    assert 'num' in details
+    assert details['num'] == [1]
+
+def test_parameters(parallel_suite):
+    parallel_suite[0].add_parameter(num_values=1)
+    summary = parallel_suite.run()
+    assert summary.session.results.is_success()
+
+def test_requirements(parallel_suite):
+    parallel_suite[0].add_decorator('slash.requires(False)')
+    parallel_suite[0].expect_skip()
+    results = parallel_suite.run().session.results
+    assert results.get_num_skipped() == 1
+    assert results.get_num_successful() == len(parallel_suite) - 1
+    assert results.is_success(allow_skips=True)
+
+def test_is_test_code(parallel_suite):
+    parallel_suite[0].when_run.error()
+    summary = parallel_suite.run()
+    [result] = summary.get_all_results_for_test(parallel_suite[0])
+    [err] = result.get_errors()
+    assert err.traceback.frames[-1].is_in_test_code()
+    error_json = err.traceback.to_list()
+    assert error_json[-1]['is_in_test_code']
+
+def test_parallel_resume(parallel_suite):
+    parallel_suite[0].when_run.fail()
+    result = parallel_suite.run()
+    resumed = get_tests_to_resume(result.session.id)
+    assert len(resumed) == 1
+
+def test_parallel_symlinks(parallel_suite, logs_dir):   # pylint: disable=unused-argument
+    files_dir = logs_dir.join("files")
+    links_dir = logs_dir.join("links")
+    session = parallel_suite.run(additional_args=['-l', str(files_dir)]).session
+    session_log_file = files_dir.join(session.id, "session.log")
+
+    assert session.results.is_success()
+    assert session_log_file.check()
+    assert links_dir.join("last-session").readlink() == session_log_file
+    assert links_dir.join("last-session-dir").readlink() == session_log_file.dirname
+
+    worker_session_ids = session.parallel_manager.server.worker_session_ids
+    file_names = [x.basename for x in links_dir.join("last-session-dir").listdir()]
+    assert 'worker_1' in file_names
+
+    for file_name in links_dir.join("last-session-dir").listdir():
+        if file_name.islink() and 'worker' in file_name.basename:
+            last_token = file_name.readlink().split('/')[-1]
+            assert last_token in worker_session_ids
+            assert os.path.isdir(file_name.readlink())
+
+def test_parallel_interactive_fails(parallel_suite):
+    summary = parallel_suite.run(additional_args=['-i'], verify=False)
+    results = list(summary.session.results.iter_all_results())
+    assert len(results) == 1
+    error = results[0].get_errors()[0]
+    assert error.exception_type == InteractiveParallelNotAllowed
+
+def test_children_session_ids(parallel_suite):
+    summary = parallel_suite.run()
+    assert summary.session.results.is_success()
+    session_ids = summary.session.parallel_manager.server.worker_session_ids
+    expected_session_ids = ["{}_1".format(summary.session.id.split('_')[0])]
+    assert session_ids == expected_session_ids
+
+def test_timeout_no_request_to_server(config_override, runnable_test_dir):
+    config_override("parallel.no_request_timeout", 1)
+    with Session():
+        runnables = Loader().get_runnables(str(runnable_test_dir))
+        parallel_manager = ParallelManager([])
+        parallel_manager.start_server_in_thread(runnables)
+        parallel_manager.server.state = ServerStates.SERVE_TESTS
+
+        with slash.assert_raises(ParallelTimeout) as caught:
+            parallel_manager.start()
+        assert 'No request sent to server' in caught.exception.args[0]
+
+def test_children_not_connected_timeout(runnable_test_dir, config_override):
+    config_override("parallel.worker_connect_timeout", 0)
+    config_override("parallel.num_workers", 1)
+    with Session():
+        runnables = Loader().get_runnables(str(runnable_test_dir))
+        parallel_manager = ParallelManager([])
+        parallel_manager.start_server_in_thread(runnables)
+        time.sleep(0.1)
+        with slash.assert_raises(ParallelTimeout) as caught:
+            parallel_manager.wait_all_workers_to_connect()
+        assert caught.exception.args[0] == 'Not all clients connected'
+
+def test_worker_error_logs(parallel_suite, config_override):
+    config_override("parallel.communication_timeout_secs", 2)
+    parallel_suite[0].when_run.interrupt()
+    summary = parallel_suite.run(num_workers=1, verify=False)
+    [interrupted_result] = summary.get_all_results_for_test(parallel_suite[0])
+    assert interrupted_result.is_interrupted()
+    for result in summary.session.results:
+        if result != interrupted_result:
+            assert result.is_success() or result.is_not_run()
+    file_path = os.path.join(summary.session.parallel_manager.workers_error_dircetory, 'errors-worker-1.log')
+    assert os.path.isfile(file_path)
+    with open(file_path) as error_file:
+        line = error_file.readline()
+        assert 'interrupted' in line
diff --git a/tests/test_parametrization_ordering.py b/tests/test_parametrization_ordering.py
new file mode 100755
index 0000000000..66031f7a26
--- /dev/null
+++ b/tests/test_parametrization_ordering.py
@@ -0,0 +1,62 @@
+import pytest
+import slash
+
+import itertools
+from .utils import run_tests_in_session
+
+
+@pytest.mark.parametrize('on_fixture', [True, False])
+def test_stable_ordering(on_fixture):
+    """Make sure that cartesian products in parametrizations are stable, even when changing the order of the parametrization decorators
+    """
+    params = [('a', [1, 2, 3]), ('b', [True, False]), ('c', [4, 5, 6])]
+    permutations = list(itertools.permutations(params))
+
+    def parametrize(permutation):
+        def decorator(thing):
+            for param_name, values in permutation:
+                thing = slash.parametrize(param_name, values)(thing)
+            return thing
+        return decorator
+
+    def generate_session_and_test(permutation):
+
+        s = slash.Session()
+
+        if on_fixture:
+
+            @parametrize(permutation)
+            def some_fixture(a, b, c):
+                return {'a': a, 'b': b, 'c': c}
+
+            def test_something(some_fixture):
+                slash.context.result.data['params'] = some_fixture
+        else:
+            @parametrize(permutation)
+            def test_something(a, b, c):
+                slash.context.result.data['params'] = {'a': a, 'b': b, 'c': c}
+
+
+        if on_fixture:
+            s.fixture_store.add_fixture(slash.fixture(some_fixture))
+
+        s.fixture_store.resolve()
+
+        return s, test_something
+
+    results_by_permutation = []
+    for p in permutations:
+        session, test = generate_session_and_test(p)
+        with session, session.get_started_context():
+            run_tests_in_session(test, session=session)
+        assert session.results.is_success(), 'run failed'
+        results_by_permutation.append(session.results)
+
+    param_values = {}
+    for results in results_by_permutation:
+        for index, result in enumerate(results):
+            for param_name, param_value in result.data['params'].items():
+                param_values.setdefault((param_name, index), []).append(param_value)
+
+    for (param_name, index), values in param_values.items():
+        assert len(set(values)) == 1, '{}#{} is not stable: {}'.format(param_name, index, values)
diff --git a/tests/test_pattern_matching.py b/tests/test_pattern_matching.py
new file mode 100755
index 0000000000..f59acff228
--- /dev/null
+++ b/tests/test_pattern_matching.py
@@ -0,0 +1,79 @@
+from slash.utils.pattern_matching import Matcher
+from slash.core.tagging import NO_TAGS, Tags
+
+
+def test_string_patterns(suite, config_override):
+    selected_test = suite[len(suite) // 2]
+
+    config_override("run.filter_strings", [selected_test.id])
+
+    for i, test in enumerate(suite):  # pylint: disable=unused-variable
+        if test is not selected_test:
+            test.expect_deselect()
+
+    suite.run()
+
+
+def test_string_patterns_and(suite, config_override):
+    selected_test = suite[len(suite) // 2]
+    other_test = suite[-1]
+
+    config_override("run.filter_strings", [selected_test.id, other_test.id])
+
+    for i, test in enumerate(suite):  # pylint: disable=unused-variable
+        test.expect_deselect()
+
+    result = suite.run(expect_session_errors=True).session.results.global_result
+    assert len(result.get_errors()) == 1
+    assert 'no tests could be collected' in str(result.get_errors()[0]).lower()
+
+
+def test_matcher():
+    for pattern, matching, not_matching in [
+            ('xy', ['blapxy'], ['blap']),
+            ('not x', ['blap', 'yyy'], ['blapx', 'xy']),
+            ('x and y', ['xy', 'yx', 'x kjfldkjfd y'], ['x', 'y', 'xx']),
+            ('(x and some.string) and not z', ['xysome.string', 'some.stringyx'], ['z', 'xysome.stringz']),
+            ('exact(x=y)(y=z)', ['exact(x=y)(y=z)'], ['exlact(x=y)(y=z)']),
+    ]:
+
+        matcher = Matcher(pattern)
+        for string in matching:
+            assert matcher.matches(FakeMetadata(string))
+        for string in not_matching:
+            assert not matcher.matches(FakeMetadata(string))
+
+
+def test_test_name_matcher():
+    test_name = '/path/to/testfile.py:TestName'
+    m = FakeMetadata(test_name)
+    assert not Matcher('not {}'.format(test_name)).matches(m)
+    assert Matcher(test_name).matches(m)
+
+
+def test_matches_tag():
+    assert Matcher('bla').matches(FakeMetadata('something', {'bla': 2}))
+    assert not Matcher('bla').matches(FakeMetadata('something', {'bloop': 2}))
+    assert Matcher('substring').matches(FakeMetadata('something', {'xxxxsubstringxxx': 2}))
+
+
+def test_matches_tag_exclusively():
+    assert Matcher('tag:bla').matches(FakeMetadata('something', {'bla': 2}))
+    assert not Matcher('tag:bla').matches(FakeMetadata('bla', {'bloop': 2}))
+
+
+def test_matches_values():
+    assert Matcher('tag:bla=2').matches(FakeMetadata('something', {'bla': 2}))
+    assert not Matcher('tag:bla=2').matches(FakeMetadata('something', {'bla': 3}))
+    assert Matcher('tag:bla=hello').matches(FakeMetadata('something', {'bla': 'hello'}))
+    assert not Matcher('tag:bla=bye').matches(FakeMetadata('something', {'bla': 'hello'}))
+
+
+class FakeMetadata(object):
+
+    def __init__(self, address, tags=NO_TAGS):
+        super(FakeMetadata, self).__init__()
+        if isinstance(tags, dict):
+            tags = Tags(tags)
+        self.address = address
+        self.tags = tags
diff --git a/tests/test_plugin_activation.py b/tests/test_plugin_activation.py
new file mode 100755
index 0000000000..2948d04b54
--- /dev/null
+++ b/tests/test_plugin_activation.py
@@ -0,0 +1,199 @@
+# pylint: disable=superfluous-parens,protected-access
+import re
+
+import pytest
+
+from slash import plugins
+from slash import hooks
+from slash.plugins import PluginInterface, IncompatiblePlugin, UnknownPlugin
+from .utils import CustomException
+
+
+def test_get_active_plugins(plugin):
+    plugins.manager.install(plugin)
+    assert plugins.manager.get_active_plugins() == {}
+    plugins.manager.activate(plugin)
+    assert plugins.manager.get_active_plugins() == {plugin.get_name(): plugin}
+    plugins.manager.deactivate(plugin)
+    assert plugins.manager.get_active_plugins() == {}
+
+
+def test_deactivaion_no_activation(plugin):
+    plugins.manager.install(plugin)
+    assert (not plugin._deactivate_called)
+    plugins.manager.uninstall(plugin)
+    assert not plugin._deactivate_called, 'Deactivate called even though plugin not activated'
+
+
+def test_activation_exception(plugin):
+    plugin.activate = CustomException.do_raise
+    plugins.manager.install(plugin)
+
+    with pytest.raises(CustomException):
+        plugins.manager.activate(plugin)
+
+    # make sure no registrations are in effect...
+    _assert_hooks_not_registered(plugin)
+
+    plugins.manager.deactivate(plugin)
+    assert (not plugin._deactivate_called), 'Deactivate unexpectedly called!'
+
+
+def test_deactivation_exception(plugin):
+    plugin.deactivate = CustomException.do_raise
+    plugins.manager.install(plugin, activate=True)
+
+    with pytest.raises(CustomException):
+        plugins.manager.deactivate(plugin)
+    _assert_hooks_not_registered(plugin)
+
+
+def test_activate_called(plugin):
+    plugins.manager.install(plugin)
+    assert (not plugin._activate_called)
+    plugins.manager.activate(plugin)
+    assert plugin._activate_called
+
+
+def test_deactivate_called_on_deactivate(plugin):
+    plugins.manager.install(plugin)
+    assert (not plugin._deactivate_called)
+    plugins.manager.activate(plugin)
+    assert (not plugin._deactivate_called)
+    plugins.manager.deactivate(plugin)
+    assert plugin._deactivate_called
+
+
+def test_hook_registration(plugin):
+    plugins.manager.install(plugin)
+    _assert_hooks_not_registered(plugin)
+    plugins.manager.activate(plugin)
+    hooks.session_start()  # pylint: disable=no-member
+    assert plugin.session_start_call_count == 1
+    plugins.manager.deactivate(plugin)
+    hooks.session_start()  # pylint: disable=no-member
+    assert plugin.session_start_call_count == 1
+
+
+def test_install_and_activate(plugin):
+    """test plugins.manager.install(..., activate=True)"""
+    plugins.manager.install(plugin, activate=True)
+    assert plugin.get_name() in plugins.manager.get_active_plugins()
+
+
+def test_uninstall_also_deactivates(plugin):
+    plugins.manager.install(plugin)
+    plugins.manager.activate(plugin)
+    plugins.manager.uninstall(plugin)
+    hooks.session_start()  # pylint: disable=no-member
+    assert plugin.session_start_call_count == 0
+
+
+def test_cannot_activate_uninstalled_plugin():
+    class Plugin(PluginInterface):
+
+        def get_name(self):
+            return "Test plugin"
+    with pytest.raises(ValueError) as caught:
+        plugins.manager.activate(Plugin())
+    assert re.search(r".*Unknown plugin: Test plugin.*", str(caught.value))
+
+
+def test_unknown_hook_names(request):
+    "Make sure that plugins with unknown hook names get discarded"
+    class Plugin(PluginInterface):
+
+        def get_name(self):
+            return "Test plugin"
+
+        def unknown_hook_1(self):
+            pass
+
+    plugin = Plugin()
+    plugins.manager.install(plugin)
+
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        plugins.manager.uninstall(plugin)
+
+    with pytest.raises(IncompatiblePlugin) as caught:
+        plugins.manager.activate(plugin)
+
+    assert re.search(r"\bUnknown hooks\b.*", str(caught.value))
+
+
+def test_custom_hook_names(request):
+    "Make sure that plugins with unknown hook names get discarded"
+    class Plugin(PluginInterface):
+
+        def get_name(self):
+            return "Test plugin"
+
+        def custom_hook(self):
+            pass
+
+    hooks.add_custom_hook("custom_hook")
+
+    @request.addfinalizer
+    def cleanup():  # pylint: disable=unused-variable
+        hooks.remove_custom_hook("custom_hook")
+    plugin = Plugin()
+    plugins.manager.install(plugin, activate=True)
+    plugins.manager.uninstall(plugin)
+
+
+def test_pending_activation(plugin):
+    plugins.manager.install(plugin)
+    assert not plugins.manager.get_active_plugins()
+    plugins.manager.activate_later(plugin)
+    assert not plugins.manager.get_active_plugins()
+    plugins.manager.activate_pending_plugins()
+    assert plugin.get_name() in plugins.manager.get_active_plugins()
+    assert plugin._activate_called
+
+
+def test_pending_activation_deactivation(plugin):
+    plugins.manager.install(plugin)
+    plugins.manager.activate_later(plugin)
+    plugins.manager.deactivate_later(plugin)
+    assert plugin.get_name() in plugins.manager._pending_activation
+    assert plugin.get_name() in plugins.manager._pending_deactivation
+    plugins.manager.activate_pending_plugins()
+    assert not plugin._activate_called
+
+
+def test_install_activate_later(plugin):
+    plugins.manager.install(plugin, activate_later=True)
+    assert plugin.get_name() in plugins.manager._pending_activation
+
+
+@pytest.mark.parametrize('activate_later_first', [True, False])
+def test_deactivate_later_already_activated(plugin, activate_later_first):
+    plugins.manager.install(plugin, activate=True)
+    if activate_later_first:
+        plugins.manager.activate_later(plugin)
+    plugins.manager.deactivate_later(plugin)
+    plugins.manager.activate_pending_plugins()
+    assert plugin.get_name() not in plugins.manager.get_active_plugins()
+    assert plugin._activate_called
+    assert plugin._deactivate_called
+
+def test_pending_activation_not_exists(plugin):
+    with pytest.raises(UnknownPlugin):
+        plugins.manager.activate_later(plugin)
+    with pytest.raises(UnknownPlugin):
+        plugins.manager.activate_later(plugin.get_name())
+
+
+
+def test_pending_deactivation_not_exists(plugin):
+    with pytest.raises(UnknownPlugin):
+        plugins.manager.deactivate_later(plugin)
+    with pytest.raises(UnknownPlugin):
+        plugins.manager.deactivate_later(plugin.get_name())
+
+
+
+def _assert_hooks_not_registered(plugin):
+    hooks.session_start()  # pylint: disable=no-member
+    assert plugin.session_start_call_count == 0, 'Hook unexpectedly registered!'
diff --git a/tests/test_plugin_commandline.py b/tests/test_plugin_commandline.py
new file mode 100755
index 0000000000..257accf6ad
--- /dev/null
+++ b/tests/test_plugin_commandline.py
@@ -0,0 +1,8 @@
+import pytest
+
+
+@pytest.mark.parametrize('with_without', ['with', 'without'])
+def test_with_without_nonexisting_plugin(suite, with_without):
+
+    summary = suite.run(additional_args=['--{0}-nonexisting-plugin'.format(with_without)], verify=False)
+    assert summary.exit_code != 0
diff --git a/tests/test_plugin_config.py b/tests/test_plugin_config.py
new file mode 100755
index 0000000000..4d9c32e6fd
--- /dev/null
+++ b/tests/test_plugin_config.py
@@ -0,0 +1,36 @@
+import pytest
+import slash
+from slash.plugins import PluginInterface
+
+
+@pytest.fixture(autouse=True)
+def restore_plugins(request):
+    request.addfinalizer(slash.plugins.manager.install_builtin_plugins)
+    request.addfinalizer(slash.plugins.manager.uninstall_all)
+
+
+def test_plugin_config():
+
+    assert 'sample' not in slash.config['plugin_config']
+    value = object()
+
+    class Plugin(PluginInterface):
+
+        def get_name(self):
+            return 'sample'
+
+        def get_default_config(self):
+            return {
+                'values': {
+                    'value_1': value,
+                }}
+
+    plugin = Plugin()
+    slash.plugins.manager.install(plugin)
+
+    assert slash.config.root.plugin_config.sample.values.value_1 is value
+    assert plugin.current_config.values.value_1 is value
+
+    slash.plugins.manager.uninstall('sample')
+
+    assert 'sample' not in slash.config['plugin_config']
diff --git a/tests/test_plugin_dependency.py b/tests/test_plugin_dependency.py
new file mode 100755
index 0000000000..6f80339073
--- /dev/null
+++ b/tests/test_plugin_dependency.py
@@ -0,0 +1,578 @@
+import pytest
+import slash.plugins
+from .conftest import Checkpoint
+from slash.plugins import PluginInterface
+from gossip.exceptions import CannotResolveDependencies
+
+
+@pytest.mark.parametrize('needs_decorate_method', [True, False])
+@pytest.mark.parametrize('provides_decorate_method', [True, False])
+def test_needs_provides_plugin_name(needs_decorate_method, provides_decorate_method, checkpoint1, checkpoint2):
+
+    @slash.plugins.active  # pylint: disable=abstract-method, unused-variable
+    @_maybe_decorate(slash.plugins.needs('p'), not needs_decorate_method)
+    @autoname
+    class NeedsPlugin(PluginInterface):
+
+        @_maybe_decorate(slash.plugins.needs('p'), needs_decorate_method)
+        def session_start(self):
+            checkpoint2()
+
+    @slash.plugins.active  # pylint: disable=abstract-method, unused-variable
+    @_maybe_decorate(slash.plugins.provides('p'), not provides_decorate_method)
+    @autoname
+    class ProvidesPlugin(PluginInterface):
+
+        @_maybe_decorate(slash.plugins.provides('p'), provides_decorate_method)
+        def session_start(self):
+            checkpoint1()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+
+def test_provides_globally_needs_globally(checkpoint1, checkpoint2):
+    '''
+    Plugin A: Provides x at class level
+    Plugin B: Needs x at class level
+    '''
+    @slash.plugins.provides('x')
+    class PluginA(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        def session_start(self):
+            checkpoint1()
+
+        def test_start(self):
+            pass
+
+
+    @slash.plugins.needs('x')
+    class PluginB(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        def session_start(self):
+            checkpoint2()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+def test_provides_globally_needs_specific_hook(checkpoint1, checkpoint2):
+    '''
+    Plugin A: Provides x at class level
+    Plugin B: Needs x for specific hook
+    '''
+    @slash.plugins.provides('x')
+    class PluginA(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        def session_start(self):
+            checkpoint1()
+
+        def test_start(self):
+            pass
+
+
+    class PluginB(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        @slash.plugins.needs('x')
+        def session_start(self):
+            checkpoint2()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+def test_provides_globally_needs_specific_hook_which_does_not_exist_at_a(checkpoint2):
+    '''
+    Plugin A: Provides x at class level
+    Plugin B: Needs x for specific hook, this hook does not definied in A
+
+    Expectations:
+    Should work in the empty sense
+    all non-needing hooks should work, even when missing from A, the specific hook needs to happen in A before B.
+    '''
+    @slash.plugins.provides('x')
+    class PluginA(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        def test_start(self):
+            pass
+
+
+    class PluginB(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        @slash.plugins.needs('x')
+        def session_start(self):
+            checkpoint2()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint2.called
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+def test_provides_specific_hook_needs_globally(checkpoint1, checkpoint2):
+    '''
+    Plugin A: Provides x on a specific hook
+    Plugin B: Needs x at class level
+
+    Expectations:
+    This case should fail, because logically the other hooks don't have anyone to provide X for them
+    '''
+    class PluginA(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        @slash.plugins.provides('x')
+        def session_start(self):
+            checkpoint1()
+
+        def test_start(self):
+            pass
+
+
+    @slash.plugins.needs('x')
+    class PluginB(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        def session_start(self):
+            checkpoint2()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+def test_provides_specific_hook_needs_globally_with_this_hook_only(checkpoint1, checkpoint2):
+    '''
+    Plugin A: Provides x on a specific hook
+    Plugin B: Needs x at class level, but only has one hook (the one provided by A)
+    '''
+    class PluginA(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        @slash.plugins.provides('x')
+        def session_start(self):
+            checkpoint1()
+
+        def test_start(self):
+            pass
+
+
+    @slash.plugins.needs('x')
+    class PluginB(slash.plugins.interface.PluginInterface):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        def session_start(self):
+            checkpoint2()
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+@pytest.mark.parametrize('needs_parent_level', [True, False])
+@pytest.mark.parametrize('provides_parent_level', [True, False])
+def test_provides_needs_with_inheritence_on_class_level(checkpoint, checkpoint1, checkpoint2, needs_parent_level, provides_parent_level):
+    '''
+    Plugin A: Provides x in class level (by it self or by inheritence)
+    Plugin b: Needs x in class level (by it self or by inheritence)
+    '''
+    # pylint: disable=abstract-method
+
+    @_maybe_decorate(slash.plugins.provides('x'), provides_parent_level)
+    class PluginAParent(slash.plugins.interface.PluginInterface):
+
+        def test_start(self):
+            pass
+
+    @_maybe_decorate(slash.plugins.provides('x'), not provides_parent_level)
+    class PluginA(PluginAParent):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        def session_start(self):
+            checkpoint1()
+
+
+    @_maybe_decorate(slash.plugins.needs('x'), needs_parent_level)
+    class PluginBParent(slash.plugins.interface.PluginInterface):
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            checkpoint()
+
+
+    @_maybe_decorate(slash.plugins.needs('x'), not needs_parent_level)
+    class PluginB(PluginBParent):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        def session_start(self):
+            checkpoint2()
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    # session_start hook should be provided the PluginA.session_start method
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+    # error_added hook should be provided by empty registration of pluginA
+    slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert checkpoint.called
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.error_added()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+    # Ensure only hooks required by PluginB fails
+    slash.hooks.test_end()  # pylint: disable=no-member
+
+
+def test_provides_needs_in_both_inheritence_levels(checkpoint, checkpoint1, checkpoint2):
+    # pylint: disable=abstract-method
+
+    @slash.plugins.provides('x')
+    class PluginAParent(slash.plugins.interface.PluginInterface):
+
+        def test_start(self):
+            pass
+
+    @slash.plugins.provides('y')
+    class PluginA(PluginAParent):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        def session_start(self):
+            checkpoint1()
+
+
+    @slash.plugins.needs('x')
+    class PluginBParent(slash.plugins.interface.PluginInterface):
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            checkpoint()
+
+
+    @slash.plugins.needs('y')
+    class PluginB(PluginBParent):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        def session_start(self):
+            checkpoint2()
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    # session_start hook should be provided the PluginA.session_start method
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert checkpoint1.timestamp < checkpoint2.timestamp
+
+    # error_added hook should be provided by empty registration of pluginA
+    slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert checkpoint.called
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.error_added()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    # Ensure only hooks required by PluginB fails
+    slash.hooks.test_end()  # pylint: disable=no-member
+
+
+def test_provides_needs_with_inheritence_on_method_level(checkpoint):
+    '''
+    Plugin A: Provides x in method level (by it self or by inheritence) to test_start & session_start
+    Plugin b: Needs x in method level (by it self or by inheritence) on test_start & session_start
+    '''
+    # pylint: disable=abstract-method
+    session_start_a = Checkpoint()
+    session_start_b = Checkpoint()
+    test_start_a = Checkpoint()
+    test_start_b = Checkpoint()
+
+    class PluginAParent(slash.plugins.interface.PluginInterface):
+
+        @slash.plugins.provides('x')
+        def test_start(self):
+            test_start_a()
+
+    class PluginA(PluginAParent):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        @slash.plugins.provides('x')
+        def session_start(self):
+            session_start_a()
+
+
+    class PluginBParent(slash.plugins.interface.PluginInterface):
+
+        @slash.plugins.needs('x')
+        def session_start(self):
+            session_start_b()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            checkpoint()
+
+
+    class PluginB(PluginBParent):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        @slash.plugins.needs('x')
+        def test_start(self):
+            test_start_b()
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert session_start_a.timestamp < session_start_b.timestamp
+
+    slash.hooks.test_start()  # pylint: disable=no-member
+    assert test_start_a.timestamp < test_start_b.timestamp
+
+    # error_added hook should not need anything
+    slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert checkpoint.called
+
+    slash.plugins.manager.deactivate('plugin_a')
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.test_start()  # pylint: disable=no-member
+    slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x'])
+
+
+def test_provides_needs_with_child_overrides():
+    # pylint: disable=line-too-long
+    '''
+    | Hook Name     | Plugin A                                                                | Plugin B                                                               |
+    |---------------+-------------------------------------------------------------------------+------------------------------------------------------------------------|
+    | session_start | Child Provides x in method level, overrides parent's empty registration | Needs x (Parent) & y (Child) in class level                            |
+    | test_start    | Child Provides x in method level, overrides parent's real registration  | Needs x (Parent) & y (Child) in class level                            |
+    | error_added   | x is not provided, overrides parent's real registration                 | Needs x (Parent) & y (Child) in class level                            |
+    | test_end      | x is not provided, overrides parent's empty registration                | Needs x (Parent) & y (Child) in class level                            |
+    | session_end   | Parent provides x, child provides y - both in class level               | Needs x (Parent) & y (Child) in class level, z in (child) method level |
+    '''
+    # pylint: disable=abstract-method
+    session_start_a = Checkpoint()
+    session_start_b = Checkpoint()
+    test_start_a = Checkpoint()
+    test_start_b = Checkpoint()
+
+    @slash.plugins.provides('x')
+    class PluginAParent(slash.plugins.interface.PluginInterface):
+
+        def test_start(self):
+            test_start_a()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+        def session_end(self):
+            pass
+
+    @slash.plugins.provides('y')
+    class PluginA(PluginAParent):
+
+        def get_name(self):
+            return 'plugin_a'
+
+        @slash.plugins.provides('x')
+        def session_start(self):
+            # Overrides empty registration of PluginAParent
+            session_start_a()
+
+        @slash.plugins.provides('x')
+        def test_start(self):
+            # Overrides "real" registration of PluginAParent
+            test_start_a()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            # Overrides "real" registration of PluginAParent
+            pass
+
+        def test_end(self):
+            # Overrides empty registration of PluginAParent
+            pass
+
+
+    @slash.plugins.needs('x')
+    class PluginBParent(slash.plugins.interface.PluginInterface):
+
+        def session_start(self):
+            session_start_b()
+
+        def error_added(self, result, error): # pylint: disable=unused-argument
+            pass
+
+        def test_start(self):
+            test_start_b()
+
+        def test_end(self):
+            pass
+
+
+    @slash.plugins.needs('y')
+    class PluginB(PluginBParent):
+
+        def get_name(self):
+            return 'plugin_b'
+
+        @slash.plugins.needs('z')
+        def session_end(self):
+            pass
+
+
+    for plugin_cls in [PluginA, PluginB]:
+        slash.plugins.manager.install(plugin_cls(), activate_later=True)
+    slash.plugins.manager.activate_pending_plugins()
+
+    slash.hooks.session_start()  # pylint: disable=no-member
+    assert session_start_a.timestamp < session_start_b.timestamp
+
+    slash.hooks.test_start()  # pylint: disable=no-member
+    assert test_start_a.timestamp < test_start_b.timestamp
+
+    slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+
+    slash.hooks.test_end()  # pylint: disable=no-member
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_end()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['z'])
+
+
+    slash.plugins.manager.deactivate('plugin_a')
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.test_start()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.error_added(result=None, error=None)  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.test_end()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y'])
+
+    with pytest.raises(CannotResolveDependencies) as caught:
+        slash.hooks.session_end()  # pylint: disable=no-member
+    assert caught.value.unmet_dependencies == set(['x', 'y', 'z'])
+
+def _maybe_decorate(decorator, flag):
+
+    def returned(func):
+        if flag:
+            func = decorator(func)
+        return func
+    return returned
+
+
+def autoname(plugin):
+    def get_name(self):
+        return type(self).__name__.lower()
+    plugin.get_name = get_name
+    return plugin
diff --git a/tests/test_plugin_discovery.py b/tests/test_plugin_discovery.py
new file mode 100755
index 0000000000..d129c0ccc0
--- /dev/null
+++ b/tests/test_plugin_discovery.py
@@ -0,0 +1,56 @@
+# pylint: disable=redefined-outer-name
+import os
+
+from slash import plugins
+
+import pytest
+
+
+def test_plugin_discovery(no_plugins, root_path, expected_names, config_override):  # pylint: disable=unused-argument
+    config_override("plugins.search_paths", [root_path])
+    plugins.manager.discover()
+    assert set(plugins.manager.get_installed_plugins().keys()) == expected_names
+
+
+@pytest.fixture
+def root_path(tmpdir):
+    return str(tmpdir.join('root_path'))
+
+@pytest.fixture
+def expected_names(root_path):
+    returned = set()
+    for index, path in enumerate([
+            "a/b/p1.py",
+            "a/b/p2.py",
+            "a/p3.py",
+            "a/b/c/p4.py",
+    ]):
+        plugin_name = "auto_plugin_{0}".format(index)
+        path = os.path.join(root_path, path)
+        if not os.path.isdir(os.path.dirname(path)):
+            os.makedirs(os.path.dirname(path))
+        with open(path, "w") as f:
+            f.write("""
+import slash.plugins
+from slash.plugins.interface import PluginInterface
+
+class {name}(PluginInterface):
+    def get_name(self):
+        return {name!r}
+
+def install_plugins():
+""".format(name=plugin_name))
+            if index % 2 == 0:
+                # don't install
+                f.write("     pass")
+            else:
+                returned.add(plugin_name)
+                f.write("     slash.plugins.manager.install({name}())".format(name=plugin_name))
+    for junk_file in [
+            "a/junk1.p",
+            "a/b/junk2",
+            "a/b/c/junk3",
+    ]:
+        with open(os.path.join(root_path, junk_file), "w") as f:
+            f.write("---JUNK----")
+    return returned
diff --git a/tests/test_plugin_errors.py b/tests/test_plugin_errors.py
new file mode 100755
index 0000000000..b8316dbfac
--- /dev/null
+++ b/tests/test_plugin_errors.py
@@ -0,0 +1,72 @@
+# pylint: disable=unused-argument, unused-variable, redefined-outer-name
+import slash
+import gossip
+import pytest
+
+from .utils import NamedPlugin, CustomException, make_runnable_tests
+
+
+@pytest.mark.parametrize('has_start', [True, False])
+def test_plugin_end_not_called_when_start_not_called(gossip_raise_immediately, has_start, checkpoint, restore_plugins_on_cleanup):
+    errors = []
+
+    class CustomPlugin(NamedPlugin):
+        pass
+
+    class RaisingPlugin(NamedPlugin):
+        pass
+
+    if has_start:
+        def start(self):
+            errors.append('start hook called')
+        setattr(CustomPlugin, 'session_start', start)
+
+    def end(self):
+        errors.append('end hook called')
+    setattr(CustomPlugin, 'session_end', end)
+
+    def do_raise(self):
+        checkpoint()
+        raise CustomException()
+    setattr(RaisingPlugin, 'session_start', do_raise)
+
+
+    slash.plugins.manager.install(RaisingPlugin(), activate=True)
+    slash.plugins.manager.install(CustomPlugin(), activate=True)
+
+
+    with slash.Session() as s:
+        with pytest.raises(CustomException):
+            with s.get_started_context():
+                def test_something():
+                    pass
+                slash.runner.run_tests(make_runnable_tests(test_something))
+
+    assert checkpoint.called
+    assert not errors
+
+
+def test_plugin_with_no_session_start_gets_called_session_end(checkpoint):
+
+    @slash.plugins.active
+    class MyPlugin(NamedPlugin):
+
+        def session_end(self):
+            checkpoint()
+
+    with slash.Session() as s:
+        with s.get_started_context():
+            pass
+
+    assert checkpoint.called
+
+
+@pytest.yield_fixture
+def gossip_raise_immediately():
+    g = gossip.get_group('slash')
+    prev = g.get_exception_policy()
+    g.set_exception_policy(gossip.RaiseImmediately())
+    try:
+        yield
+    finally:
+        g.set_exception_policy(prev)
diff --git a/tests/test_plugins.py b/tests/test_plugins.py
new file mode 100755
index 0000000000..34d690977e
--- /dev/null
+++ b/tests/test_plugins.py
@@ -0,0 +1,285 @@
+# pylint: disable=unused-argument
+import os
+
+import gossip
+import pytest
+import slash
+from slash._compat import PY2
+from slash import hooks, plugins
+from slash.plugins import IncompatiblePlugin, PluginInterface
+
+from .utils import NamedPlugin
+
+
+
+def test_registers_on_none(restore_plugins_on_cleanup, checkpoint):
+
+    @slash.plugins.active  # pylint: disable=unused-variable
+    class SamplePlugin(PluginInterface):
+
+        def get_name(self):
+            return 'sample'
+
+        @plugins.registers_on(None)
+        def some_method_here(self):
+            checkpoint()
+
+    gossip.trigger('slash.some_method_here')
+    assert not checkpoint.called
+
+
+
+def test_registers_on_with_private_methods(restore_plugins_on_cleanup, checkpoint):
+
+    @slash.plugins.active  # pylint: disable=unused-variable
+    class SamplePlugin(PluginInterface):
+
+        def get_name(self):
+            return 'sample'
+
+        @plugins.registers_on('some_hook')
+        def _handler(self):
+            checkpoint()
+
+    assert not checkpoint.called
+    gossip.trigger('some_hook')
+    assert checkpoint.called
+
+
+def test_class_variables_allowed(restore_plugins_on_cleanup):
+    @slash.plugins.active  # pylint: disable=unused-variable
+    class SamplePlugin(PluginInterface):
+
+        ATTRIBUTE = 'some_value'
+
+        def get_name(self):
+            return 'sample'
+
+
+def test_active_decorator(restore_plugins_on_cleanup):
+
+    plugins.manager.uninstall_all()
+
+    @slash.plugins.active
+    class SamplePlugin(PluginInterface):
+
+        def get_name(self):
+            return 'sample'
+
+    assert isinstance(SamplePlugin, type)
+    assert issubclass(SamplePlugin, PluginInterface)
+    [active] = plugins.manager.get_active_plugins().values()
+    assert isinstance(active, SamplePlugin)
+
+
+@pytest.mark.parametrize('is_internal', [True, False])
+def test_custom_hook_registration(request, is_internal):
+
+    hook_name = 'some_hook'
+    with pytest.raises(LookupError):
+        gossip.get_hook(hook_name)
+
+    class MyPlugin(PluginInterface):
+
+        def get_name(self):
+            return "plugin"
+
+        @plugins.registers_on(hook_name)
+        def unknown(self):
+            pass
+    p = MyPlugin()
+    plugins.manager.install(p, activate=True, is_internal=is_internal)
+
+    @request.addfinalizer
+    def cleanup():              # pylint: disable=unused-variable
+        plugins.manager.uninstall(p)
+
+    registrations = gossip.get_hook(hook_name).get_registrations()
+    assert len(registrations) == 1
+    [r] = registrations
+    if PY2:
+        assert r.func.__func__ is MyPlugin.unknown.__func__  # pylint: disable=no-member
+    else:
+        assert r.func.__func__ is MyPlugin.unknown
+
+    # make sure we deactivate properly as well
+    plugins.manager.deactivate(p)
+    assert not gossip.get_hook(hook_name).get_registrations()
+
+
+def test_multiple_registers_on(request):
+    hook_names = ['some_hook_{}'.format(i) for i in range(2)]
+
+    class MyPlugin(PluginInterface):
+
+        def get_name(self):
+            return "plugin"
+
+        @plugins.registers_on(hook_names[0])
+        @plugins.registers_on(hook_names[1])
+        def unknown(self):
+            pass
+
+    expected_func = MyPlugin.unknown.__func__ if PY2 else MyPlugin.unknown
+    p = MyPlugin()
+    plugins.manager.install(p, activate=True)
+    @request.addfinalizer
+    def cleanup():              # pylint: disable=unused-variable
+        plugins.manager.uninstall(p)
+
+    for hook_name in hook_names:
+        registrations = gossip.get_hook(hook_name).get_registrations()
+        assert len(registrations) == 1
+        assert registrations[0].func.__func__ is expected_func
+
+    plugins.manager.deactivate(p)
+
+    for hook_name in hook_names:
+        assert not gossip.get_hook(hook_name).get_registrations()
+
+def test_register_invalid_hook():
+
+    initially_installed = list(plugins.manager.get_installed_plugins())
+
+    class MyPlugin(PluginInterface):
+
+        def get_name(self):
+            return "plugin"
+
+        def unknown(self):
+            pass
+
+    with pytest.raises(IncompatiblePlugin):
+        plugins.manager.install(MyPlugin(), activate=True)
+
+    assert set(plugins.manager.get_installed_plugins()) == set(initially_installed)
+
+
+def test_register_custom_hooks_strict_group():
+
+    initially_installed = list(plugins.manager.get_installed_plugins())
+
+    hook_name = "some_group.some_hook"
+    gossip.get_or_create_group("some_group").set_strict()
+
+    class MyPlugin(PluginInterface):
+
+        def get_name(self):
+            return "plugin"
+
+        @plugins.registers_on(hook_name)
+        def unknown(self):
+            pass
+
+    with pytest.raises(IncompatiblePlugin):
+        plugins.manager.install(MyPlugin(), activate=True)
+
+    assert list(plugins.manager.get_installed_plugins()) == initially_installed
+
+
+def test_builtin_plugins_hooks_start_condition():
+    "make sure that all hooks are either empty, or contain callbacks marked with `slash.<identifier>`"
+    for hook_name, hook in hooks.get_all_hooks():  # pylint: disable=unused-variable
+        for registration in hook.get_registrations():
+            assert registration.token.startswith('slash.'), 'Callback {0} is not a builtin!'.format(hook.full_name)
+
+def test_builtin_plugins_are_installed():
+    installed = plugins.manager.get_installed_plugins()
+    assert installed
+    for filename in os.listdir(os.path.join(os.path.dirname(plugins.__file__), "builtin")):
+        if filename.startswith("_") or filename.startswith(".") or not filename.endswith(".py"):
+            continue
+        assert filename[:(-3)] in installed
+
+
+def test_get_installed_plugins():
+
+    class CustomPlugin(PluginInterface):
+        def __init__(self, name):
+            super(CustomPlugin, self).__init__()
+            self._name = name
+
+        def get_name(self):
+            return self._name
+
+    some_plugin = CustomPlugin('some-plugin')
+    internal_plugin = CustomPlugin('internal-plugin')
+    plugins.manager.install(some_plugin)
+    plugins.manager.install(internal_plugin, is_internal=True)
+
+    assert some_plugin.get_name() in plugins.manager.get_installed_plugins(include_internals=True)
+    assert some_plugin.get_name() in plugins.manager.get_installed_plugins(include_internals=False)
+    assert internal_plugin.get_name() in plugins.manager.get_installed_plugins(include_internals=True)
+    assert internal_plugin.get_name() not in plugins.manager.get_installed_plugins(include_internals=False)
+
+def test_cannot_install_incompatible_subclasses(no_plugins):
+
+    class Incompatible(object):
+        pass
+    for invalid in (Incompatible, Incompatible(), PluginInterface, object(), 1, "string"):
+        with pytest.raises(IncompatiblePlugin):
+            plugins.manager.install(invalid)
+    assert plugins.manager.get_installed_plugins() == {}
+
+
+def test_install_uninstall(no_plugins):
+    plugin_name = "some_plugin_name"
+
+    class CustomPlugin(PluginInterface):
+
+        def get_name(self):
+            return plugin_name
+    with pytest.raises(LookupError):
+        plugins.manager.get_plugin(plugin_name)
+    plugin = CustomPlugin()
+    plugins.manager.install(plugin)
+    assert plugins.manager.get_plugin(plugin_name) is plugin
+    plugins.manager.uninstall(plugin)
+    with pytest.raises(LookupError):
+        plugins.manager.get_plugin(plugin_name)
+
+
+
+@pytest.mark.parametrize('cond', [True, False])
+def test_register_if(no_plugins, checkpoint, cond):
+
+    @slash.plugins.active  # pylint: disable=unused-variable
+    class CustomPlugin(NamedPlugin):
+
+        @slash.plugins.register_if(cond)
+        def test_start(self):
+            checkpoint()
+
+    slash.hooks.test_start()  # pylint: disable=no-member
+
+    assert checkpoint.called == cond
+
+
+def test_register_if_nonexistent_hook(no_plugins, checkpoint):
+
+    @slash.plugins.active  # pylint: disable=unused-variable
+    class CustomPlugin(NamedPlugin):
+
+        @slash.plugins.register_if(False)
+        def nonexistent_hook(self):
+            checkpoint()
+
+
+def test_restoring_state_context():
+
+    class CustomPlugin(NamedPlugin):
+        pass
+
+    @slash.plugins.active
+    class OtherPlugin(NamedPlugin):
+        pass
+
+    manager = slash.plugins.manager
+    installed = manager.get_installed_plugins().copy()
+
+
+    with manager.restoring_state_context():
+        manager.uninstall(OtherPlugin)
+        manager.install(CustomPlugin())
+        assert set(manager.get_installed_plugins()) == (set(installed) | {'CustomPlugin'}) - {'OtherPlugin'}
+    assert manager.get_installed_plugins() == installed
diff --git a/tests/test_preliminary_errors.py b/tests/test_preliminary_errors.py
new file mode 100755
index 0000000000..4e81c3ef3a
--- /dev/null
+++ b/tests/test_preliminary_errors.py
@@ -0,0 +1,46 @@
+# pylint: disable=redefined-outer-name
+import pytest
+
+import slash
+from slash._compat import cStringIO
+from slash.frontend.slash_run import slash_run
+
+
+def test_errors_during_initialization_hoook(suite, init_hook):
+
+    @init_hook.register
+    def callback():  # pylint: disable=unused-variable
+        raise slash.exceptions.SlashException('some error')
+
+    exit_code, output = _console_run(suite)
+    assert 'some error' in output
+    assert exit_code != 0
+
+
+def test_slashrc_errors(suite):
+    @suite.slashrc.include
+    def __code__():  # pylint: disable=unused-variable
+        1 / 0  # pylint: disable=pointless-statement
+
+    exit_code, output = _console_run(suite)
+    assert exit_code != 0
+    output = output.lower()
+    assert 'unexpected error' in output
+    assert 'division' in output
+    assert 'zero' in output
+
+
+@pytest.fixture(params=[
+    slash.hooks.session_start,  # pylint: disable=no-member
+    slash.hooks.configure,  # pylint: disable=no-member
+])
+def init_hook(request):
+    return request.param
+
+
+def _console_run(suite):
+    suite.disable_debug_info()
+    path = suite.commit()
+    stream = cStringIO()
+    exit_code = slash_run([path], report_stream=stream, working_directory=path)
+    return exit_code, stream.getvalue()
diff --git a/tests/test_project_customization.py b/tests/test_project_customization.py
new file mode 100755
index 0000000000..c73c23ef24
--- /dev/null
+++ b/tests/test_project_customization.py
@@ -0,0 +1,77 @@
+# pylint: disable=redefined-outer-name,unused-argument,unused-variable,undefined-variable
+import pytest
+
+
+def test_plugin_activation_forcing_via_activate(customized_suite, suite_test):
+
+    @customized_suite.slashrc.include
+    def __code__():
+        slash.plugins.manager.activate('custom')
+
+    result = customized_suite.run().session.results.global_result
+    assert result.data['customized']
+
+
+def test_plugin_activation_deactivate_via_commandline(customized_suite, suite_test):
+
+    @customized_suite.slashrc.include
+    def __code__():
+        slash.plugins.manager.activate_later('custom')
+
+    result = customized_suite.run(additional_args=['--without-custom']).session.results.global_result
+    assert 'customized' not in result.data
+
+
+def test_plugin_activation_from_configure_hook(customized_suite, suite_test):
+
+    @customized_suite.slashrc.include
+    def __code__():
+        @slash.hooks.configure.register
+        def configure_hook():
+            slash.plugins.manager.activate_later('custom')
+
+    result = customized_suite.run().session.results.global_result
+    assert 'customized' in result.data
+
+
+def test_plugin_deactivation_override_configure_hook(customized_suite, suite_test):
+
+    @customized_suite.slashrc.include
+    def __code__():
+        @slash.hooks.configure.register
+        def configure_hook():
+            slash.plugins.manager.activate_later('custom')
+
+    result = customized_suite.run(additional_args=['--without-custom']).session.results.global_result
+    assert 'customized' not in result.data
+
+def test_configure_hook_depends_on_configuration_cmdline(customized_suite, suite_test):
+
+    @customized_suite.slashrc.include
+    def __code__():
+        slash.config.extend({
+            'some_config': 1 // slash.conf.Cmdline(arg='--some-config'),
+        })
+
+        @slash.hooks.configure.register
+        def configure_hook():
+            assert slash.config.root.some_config == 1000
+
+    result = customized_suite.run(additional_args=['--some-config=1000']).session.results.global_result
+
+
+@pytest.fixture
+def customized_suite(suite):
+
+    @suite.slashrc.include
+    def __code__():
+        class CustomPlugin(slash.plugins.PluginInterface):
+
+            def get_name(self):
+                return 'custom'
+
+            def session_start(self):
+                slash.session.results.global_result.data['customized'] = True
+        slash.plugins.manager.install(CustomPlugin())
+
+    return suite
diff --git a/tests/test_python_utils.py b/tests/test_python_utils.py
new file mode 100755
index 0000000000..daed99885a
--- /dev/null
+++ b/tests/test_python_utils.py
@@ -0,0 +1,37 @@
+# pylint: disable=redefined-outer-name
+import pytest
+
+from slash.utils.python import call_all_raise_first
+
+
+def test_call_all_raise_first(funcs):
+    exc_type = funcs[2].raise_when_called()
+
+    with pytest.raises(exc_type):
+        call_all_raise_first(funcs)
+
+    for index, func in enumerate(funcs):  # pylint: disable=unused-variable
+        assert func.called_count == 1
+
+
+@pytest.fixture
+def funcs():
+
+    class Func(object):
+
+        called_count = 0
+        exc_type = None
+
+        def __call__(self):
+            self.called_count += 1
+            if self.exc_type is not None:
+                raise self.exc_type()
+
+        def raise_when_called(self):
+            class CustomException(Exception):
+                pass
+
+            self.exc_type = CustomException
+            return self.exc_type
+
+    return [Func() for _ in range(10)]
diff --git a/tests/test_repeat.py b/tests/test_repeat.py
new file mode 100755
index 0000000000..599bdd094f
--- /dev/null
+++ b/tests/test_repeat.py
@@ -0,0 +1,57 @@
+import pytest
+
+
+@pytest.mark.parametrize('parametrize', [True, False])
+def test_repeating_each_test(suite, suite_test, parametrize):
+    num_repetitions = 5
+    suite_test.repeat(num_repetitions)
+
+    if parametrize:
+        param = suite_test.add_parameter()
+
+    summary = suite.run()
+    results = summary.get_all_results_for_test(suite_test)
+    if parametrize:
+        assert len(results) == num_repetitions * len(param.values)
+    else:
+        assert len(results) == num_repetitions
+    assert len(set(result.test_metadata.id for result in results)) == len(results)
+
+
+def test_repeat_each_global(suite, config_override):
+    num_repetitions = 5
+    config_override('run.repeat_each', num_repetitions)
+    for test in suite:
+        test.expect_repetition(num_repetitions)
+    assert suite.run().ok()
+
+
+def test_repeat_all_global(suite, config_override):
+    num_repetitions = 5
+    config_override('run.repeat_all', num_repetitions)
+    for index, test in enumerate(suite):
+        test.append_line('slash.context.result.data["index"]={}'.format(index))
+
+    for test in suite:
+        test.expect_repetition(num_repetitions)
+
+    summary = suite.run()
+
+    indices = [res.data['index'] for res in summary.session.results.iter_test_results()]
+    assert indices == [x for x in range(len(suite)) for _ in range(num_repetitions)]
+
+
+@pytest.mark.parametrize('repeat_mode', ['repeat_each', 'repeat_all'])
+def test_repeat_isolation(suite, suite_test, config_override, repeat_mode):
+    num_repetitions = 5
+    config_override('run.{}'.format(repeat_mode), num_repetitions)
+    suite_test.append_line('import time')
+    suite_test.append_line('slash.context.result.data["time"] = time.time()')
+
+    for test in suite:
+        test.expect_repetition(num_repetitions)
+
+    summary = suite.run()
+    results = summary.get_all_results_for_test(suite_test)
+    assert len(results) == num_repetitions
+    assert len({result.data['time'] for result in results}) == len(results)
diff --git a/tests/test_reporters.py b/tests/test_reporters.py
new file mode 100755
index 0000000000..cc8f87a97b
--- /dev/null
+++ b/tests/test_reporters.py
@@ -0,0 +1,37 @@
+import pytest
+from slash.reporting.console_reporter import ConsoleReporter
+from slash.reporting.null_reporter import NullReporter
+from slash.reporting.reporter_interface import ReporterInterface
+from slash.utils.python import get_underlying_func, get_arguments
+
+# pylint: disable=redefined-outer-name
+
+
+@pytest.fixture(params=[NullReporter, ConsoleReporter])
+def reporter_class(request):
+    return request.param
+
+def test_reporters_inherit_from_interface(reporter_class):
+    assert issubclass(reporter_class, ReporterInterface)
+
+def test_reporters_conform_to_interface(reporter_class):
+    def _dir(cls):
+        return set(name for name in dir(cls) if not name.startswith("_"))
+
+    assert _dir(reporter_class) <= _dir(ReporterInterface)
+
+def test_parameter_lists_conform_to_interface(reporter_class):
+    for method_name in dir(reporter_class):
+        if method_name.startswith("_"):
+            continue
+
+        derived_method = _get_method(reporter_class, method_name)
+        base_method = _get_method(ReporterInterface, method_name)
+
+        argpsec = [argument.name for argument in get_arguments(derived_method)]
+        expected = [argument.name for argument in get_arguments(base_method)]
+        assert argpsec == expected
+
+def _get_method(cls, method_name):
+    returned = getattr(cls, method_name)
+    return get_underlying_func(returned)
diff --git a/tests/test_requirements.py b/tests/test_requirements.py
new file mode 100755
index 0000000000..588f3f7ab7
--- /dev/null
+++ b/tests/test_requirements.py
@@ -0,0 +1,211 @@
+# pylint: disable=redefined-outer-name
+
+import gossip
+import pytest
+import slash
+import slash.core.requirements
+from .utils import make_runnable_tests
+from .utils.suite_writer.suite import Suite
+from .utils.code_formatter import CodeFormatter
+from slash._compat import ExitStack
+
+_UNMET_REQ_DECORATOR = 'slash.requires(lambda: False)'
+_MET_REQ_DECORATOR = 'slash.requires(lambda: True)'
+
+def test_requirements_mismatch_session_success(suite, suite_test):
+    suite_test.add_decorator('slash.requires(False)')
+    suite_test.expect_skip()
+    summary = suite.run()
+    assert summary.session.results.is_success(allow_skips=True)
+
+
+@pytest.mark.parametrize('requirement_fullfilled', [True, False])
+@pytest.mark.parametrize('use_message', [True, False])
+@pytest.mark.parametrize('use_fixtures', [True, False])
+@pytest.mark.parametrize('message_in_retval', [True, False])
+def test_requirements(suite, suite_test, requirement_fullfilled, use_fixtures, use_message, message_in_retval):
+
+    message = "requires something very important"
+    if use_message and message_in_retval:
+        retval = '({}, {!r})'.format(requirement_fullfilled, message)
+    else:
+        retval = requirement_fullfilled
+
+    suite_test.add_decorator('slash.requires((lambda: {0}), {1!r})'.format(retval, message if use_message and not message_in_retval else ''))
+    if not requirement_fullfilled:
+        suite_test.expect_skip()
+
+    if use_fixtures:
+        suite_test.depend_on_fixture(
+            suite.slashconf.add_fixture())
+    results = suite.run()
+    if requirement_fullfilled:
+        assert results[suite_test].is_success()
+    else:
+        assert not results[suite_test].is_started()
+        assert results[suite_test].is_skip()
+        if use_message:
+            [skip] = results[suite_test].get_skips()
+            assert message in skip
+
+
+def test_requirements_functions_no_message(suite, suite_test):
+    suite_test.add_decorator(_UNMET_REQ_DECORATOR)
+    suite_test.expect_skip()
+    results = suite.run()
+    result = results[suite_test]
+    [skip] = result.get_skips()
+    assert 'lambda' in skip
+
+
+def test_requirements_on_class():
+
+    def req1():
+        pass
+
+    def req2():
+        pass
+
+    @slash.requires(req1)
+    class Test(slash.Test):
+
+        @slash.requires(req2)
+        def test_something(self):
+            pass
+
+    with slash.Session():
+        [test] = make_runnable_tests(Test)  # pylint: disable=unbalanced-tuple-unpacking
+
+
+    assert set([r._req for r in test.get_requirements()]) == set([req1, req2])  # pylint: disable=protected-access
+
+
+@pytest.fixture
+def filename_test_fixture(tmpdir):
+    returned = str(tmpdir.join('testfile.py'))
+
+    with open(returned, 'w') as f:
+        with ExitStack() as stack:
+            code = CodeFormatter(f)
+
+            code.writeln('import slash')
+            code.writeln('@slash.fixture')
+            code.writeln('@slash.requires({}, {})'.format(_UNMET_REQ_DECORATOR, '"msg1"'))
+            code.writeln('def fixture():')
+            with code.indented():
+                code.writeln('return 1')
+
+            code.writeln('@slash.fixture(autouse=True)')
+            code.writeln('@slash.requires({}, {})'.format(_MET_REQ_DECORATOR, '"msg2"'))
+            code.writeln('def fixture1():')
+            with code.indented():
+                code.writeln('return 1')
+
+            code.writeln('class Test(slash.Test):')
+            stack.enter_context(code.indented())
+
+            code.write('def test_1(')
+            code.write('self, ')
+            code.writeln('fixture):')
+            with code.indented():
+                code.writeln('pass')
+    return returned
+
+
+def test_requirements_on_class_with_fixture_and_autouse_fixture(filename_test_fixture):
+    with slash.Session():
+        [test] = make_runnable_tests(filename_test_fixture)  # pylint: disable=unbalanced-tuple-unpacking
+    assert sorted([str(r) for r in test.get_requirements()]) == ['msg1', 'msg2']
+
+
+def test_unmet_requirements_trigger_avoided_test_hook(suite, suite_test):
+
+    suite_test.add_decorator(_UNMET_REQ_DECORATOR)
+    suite_test.expect_skip()
+
+
+    @gossip.register('slash.test_avoided')
+    def test_avoided(reason):  # pylint: disable=unused-variable
+        slash.context.result.data['avoided'] = {'reason': reason,
+                                                'test_name': slash.context.test.__slash__.address}
+
+    summary = suite.run()
+    avoided_result = summary[suite_test]
+
+
+    for r in summary.session.results.iter_all_results():
+        if r is avoided_result:
+            assert 'avoided' in r.data
+            assert 'lambda' in r.data['avoided']['reason']
+            assert 'unmet requirement' in r.data['avoided']['reason'].lower()
+            assert r.data['avoided']['test_name'].split('_')[-1] == suite_test.id
+        else:
+            assert 'avoided' not in r.data
+
+
+def test_adding_requirement_objects():
+
+    class MyRequirement(slash.core.requirements.Requirement):
+        pass
+
+    req = MyRequirement('bla')
+
+    @slash.requires(req)
+    def test_something():
+        pass
+
+    with slash.Session():
+        [test] = make_runnable_tests(test_something) # pylint: disable=unbalanced-tuple-unpacking
+
+    reqs = test.get_requirements()
+    assert len(reqs) == 1 and reqs[0] is req
+
+
+def test_cannot_specify_message_with_requirement_object():
+
+    class MyRequirement(slash.core.requirements.Requirement):
+        pass
+
+    with pytest.raises(AssertionError) as caught:
+        slash.requires(MyRequirement(''), 'message')
+
+    assert 'specify message' in str(caught.value)
+
+@pytest.mark.parametrize('is_fixture_requirement_unmet', [True, False])
+def test_fixture_and_test_requirements(suite, suite_test, is_fixture_requirement_unmet):
+    suite_test.depend_on_fixture(suite.slashconf.add_fixture())
+    if is_fixture_requirement_unmet:
+        suite_test._fixtures[0][1].add_decorator(_UNMET_REQ_DECORATOR) # pylint: disable=protected-access
+        suite_test.add_decorator(_MET_REQ_DECORATOR)
+    else:
+        suite_test._fixtures[0][1].add_decorator(_MET_REQ_DECORATOR) # pylint: disable=protected-access
+        suite_test.add_decorator(_UNMET_REQ_DECORATOR)
+
+    suite_test.expect_skip()
+    results = suite.run()
+    assert results[suite_test].is_skip()
+    result = results[suite_test]
+    [skip] = result.get_skips()
+    assert 'lambda' in skip
+
+def test_fixture_of_fixture_requirement(suite, suite_test):
+    suite_test.add_decorator(_UNMET_REQ_DECORATOR)
+    suite_test.depend_on_fixture(suite.slashconf.add_fixture())
+    suite_test._fixtures[0][1].add_decorator(_MET_REQ_DECORATOR) # pylint: disable=protected-access
+    suite_test.expect_skip()
+    results = suite.run()
+    assert results[suite_test].is_skip()
+
+    result = results[suite_test]
+    [skip] = result.get_skips()
+    assert 'lambda' in skip
+
+
+def test_autouse_fixture_requirement():
+    suite = Suite()
+    for _ in range(5):
+        test = suite.add_test(type='function')
+        test.expect_skip()
+    fixture = suite.get_last_file().add_fixture(autouse=True)
+    fixture.add_decorator(_UNMET_REQ_DECORATOR)
+    suite.run()
diff --git a/tests/test_result.py b/tests/test_result.py
new file mode 100755
index 0000000000..7f6e615112
--- /dev/null
+++ b/tests/test_result.py
@@ -0,0 +1,225 @@
+import gc
+
+import pytest
+import slash
+from slash import Session
+from slash.core.result import Result, SessionResults
+
+from .utils import TestCase, run_tests_assert_success
+
+
+@pytest.mark.parametrize('use_error', [True, False])
+def test_result_add_exception_multiple_times(result, use_error):
+    with slash.Session():
+        second_result = type(result)()
+        second_result.mark_started()
+        try:
+            if use_error:
+                1 / 0               # pylint: disable=pointless-statement
+            else:
+                assert 1 + 1 == 3
+        except:
+            for _ in range(3):
+                result.add_exception()
+            second_result.add_exception()
+
+    assert result.is_error() == use_error
+    assert result.is_failure() == (not use_error)
+    assert len(result.get_errors()
+               if use_error else result.get_failures()) == 1
+    assert second_result.is_success()
+
+
+def test_result_summary_some_not_run(suite):
+    suite[2].add_decorator('slash.requires(False)')
+    suite[2].expect_skip()
+    results = suite.run().session.results
+    assert results.is_success(allow_skips=True)
+
+
+def test_get_num_skips_no_not_run(suite, suite_test):
+    suite_test.add_decorator('slash.requires(False)')
+    suite_test.expect_skip()
+    results = suite.run().session.results
+    assert results.get_num_skipped(include_not_run=False) == 0
+    assert results.get_num_skipped(include_not_run=True) == 1
+    assert results.get_num_skipped() == 1
+
+
+def test_result_summary(suite):
+
+    suite[2].when_run.fail()
+    suite[3].when_run.raise_exception()
+    suite[4].when_run.raise_exception()
+    suite[5].when_run.skip()
+
+    results = suite.run().session.results
+
+    assert results.get_num_errors() == 2
+    assert results.get_num_failures() == 1
+    assert results.get_num_skipped() == 1
+    assert results.get_num_successful() == len(suite) - 4
+    assert results.get_num_not_run() == 0
+
+
+def test_result_not_run(suite, suite_test, is_last_test):
+    suite_test.when_run.fail()
+
+    for test in suite.iter_all_after(suite_test, assert_has_more=not is_last_test):
+        test.expect_not_run()
+
+    summary = suite.run(additional_args=['-x'])
+
+    num_not_run = summary.session.results.get_num_not_run()
+    if is_last_test:
+        assert num_not_run == 0
+    else:
+        assert 0 < num_not_run < len(suite)
+
+
+def test_result_not_run_zero_when_all_success(suite):
+    summary = suite.run()
+    assert summary.session.results.get_num_not_run() == 0
+
+
+def test_has_errors_or_failures(suite):
+    suite[2].when_run.fail()
+    suite[3].when_run.raise_exception()
+    results = suite.run().session.results
+    assert not results[0].has_errors_or_failures()
+    assert results[2].has_errors_or_failures()
+    assert results[3].has_errors_or_failures()
+
+
+def test_has_skips(suite):
+    suite[1].when_run.skip()
+    results = suite.run().session.results
+    assert not results[0].has_skips()
+    assert results[1].has_skips()
+
+
+def test_result_data_is_unique():
+
+    class SampleTest(slash.Test):
+
+        def test_1(self):
+            pass
+
+        def test_2(self):
+            pass
+
+    session = run_tests_assert_success(SampleTest)
+    [result1, result2] = session.results
+    assert result1.data is not result2.data
+
+
+def test_result_test_garbage_collected(gc_marker):
+
+    class SomeTest(slash.Test):
+
+        def test_something(self):
+            pass
+
+    # we have to run another test at the end to make sure Slash's internal _last_test
+    # doesn't refer to our test
+    class OtherTest(slash.Test):
+
+        def test_something(self):
+            pass
+
+    marks = []
+    runnable_tests = []
+    test_funcs = [SomeTest, OtherTest]
+
+    @slash.hooks.register
+    def tests_loaded(tests): # pylint: disable=unused-variable
+        runnable_tests.extend(tests)
+        marks.extend(list(gc_marker.mark(t) for t in runnable_tests[:-1]))
+
+    with slash.Session() as s:  # pylint: disable=unused-variable
+        session = run_tests_assert_success(test_funcs)  # pylint: disable=unused-variable
+        del runnable_tests[:]
+
+    gc.collect()
+    for mark in marks:
+        assert mark.destroyed
+
+
+def test_add_error_traceback_for_manually_added_errors(suite, suite_test):
+    suite_test.append_line('slash.add_error("msg")')
+    suite_test.expect_error()
+
+    [result] = suite.run().get_all_results_for_test(suite_test)
+    [err] = result.get_errors()
+    assert err.traceback
+
+
+def test_is_global_result(suite, suite_test):
+    suite_test.append_line('assert not slash.context.result.is_global_result()')
+    result = suite.run()
+    assert result.session.results.global_result.is_global_result()
+
+
+@pytest.mark.parametrize('log_path', [None, 'a/b/c'])
+@pytest.mark.parametrize('config_path', ['log.errors_subpath', 'log.highlights_subpath'])
+@pytest.mark.parametrize('log_subpath', [None, 'my_errors.log'])
+def test_log_paths(log_path, log_subpath, config_path, config_override, logs_dir):
+    # pylint: disable=protected-access
+    extra_logs = ['/my/extra/log_{}'.format(i) for i in range(2)]
+
+    config_override(config_path, log_subpath)
+    with slash.Session() as curr_session:
+        result = curr_session.results.global_result
+        result.set_log_path(log_path)
+        expected_logs = [log_path] if log_path else []
+        if log_subpath:
+            expected_logs.append(logs_dir.join('files').join(log_subpath))
+        assert result.get_log_path() is log_path
+        assert result.get_log_paths() == expected_logs
+        for extra_log in extra_logs:
+            result.add_extra_log_path(extra_log)
+        assert result.get_log_paths() == expected_logs + extra_logs
+
+
+
+class SessionResultTest(TestCase):
+
+    def setUp(self):
+        super(SessionResultTest, self).setUp()
+        self.results = [
+            Result() for _ in range(10)
+        ]
+        for r in self.results:
+            r.mark_started()
+        # one result with both errors and failures
+        try:
+            1 / 0
+        except:
+            self.results[1].add_error()
+            self.results[1].add_failure()
+            # one result with failure
+            self.results[2].add_failure()
+            # one result with error
+            self.results[3].add_error()
+            self.results[5].add_error()
+
+        # one result will skip
+        self.results[4].add_skip("Reason")
+
+        # and one result will skip with error
+        self.results[5].add_skip("Reason")
+        num_finished = 7
+
+        for result in self.results[:num_finished]:
+            result.mark_finished()
+        self.result = SessionResults(Session())
+        for index, r in enumerate(self.results):
+            self.result._results_dict[index] = r  # pylint: disable=protected-access
+
+    def test_counts(self):
+        self.assertEqual(self.result.get_num_results(), len(self.results))
+        self.assertEqual(self.result.get_num_successful(), 2)
+        # errors take precedence over failures
+        self.assertEqual(self.result.get_num_errors(), 3)
+        self.assertEqual(self.result.get_num_skipped(), 2)
+        self.assertEqual(self.result.get_num_failures(), 1)
diff --git a/tests/test_result_details.py b/tests/test_result_details.py
new file mode 100755
index 0000000000..6ee01dc284
--- /dev/null
+++ b/tests/test_result_details.py
@@ -0,0 +1,35 @@
+import pytest
+
+
+def test_set_test_detail(result):
+    result.set_test_detail('x', 'y')
+    assert result.details.all() == {'x': 'y'}
+
+
+def test_set(result):
+    result.details.set('x', 'y')
+    assert result.details.all() == {'x': 'y'}
+
+
+def test_append(result):
+    result.details.append('x', 'y')
+    assert result.details.all() == {'x': ['y']}
+
+
+def test_append_invalid_type(result):
+    result.details.set('x', 'y')
+    with pytest.raises(TypeError):
+        result.details.append('x', 'y')
+    assert result.details.all() == {'x': 'y'}
+
+def test_bool(result):
+    assert not result.details
+    assert not bool(result.details)
+    result.details.set('x', 'y')
+    assert result.details
+    assert bool(result.details)
+
+def test_contains(result):
+    assert 'x' not in result.details
+    result.details.set('x', 'y')
+    assert 'x' in result.details
diff --git a/tests/test_retained_logs_handler.py b/tests/test_retained_logs_handler.py
new file mode 100755
index 0000000000..84f2a629d6
--- /dev/null
+++ b/tests/test_retained_logs_handler.py
@@ -0,0 +1,21 @@
+# pylint: disable=unused-argument
+import slash
+import logbook
+
+def test_retained_logs_handler(unique_string1):
+
+    with slash.log.RetainedLogHandler() as handler:
+        slash.logger.info(unique_string1)
+
+    other_handler = logbook.TestHandler()
+    handler.flush_to_handler(other_handler)
+
+    [r] = other_handler.records # pylint: disable=unbalanced-tuple-unpacking
+    assert unique_string1 in r.message
+
+
+def test_disable():
+    with slash.log.RetainedLogHandler() as handler:
+        handler.disable()
+        slash.logger.info('hey')
+    assert not handler.records
diff --git a/tests/test_running.py b/tests/test_running.py
new file mode 100755
index 0000000000..be531e1121
--- /dev/null
+++ b/tests/test_running.py
@@ -0,0 +1,171 @@
+# pylint: disable=attribute-defined-outside-init,redefined-outer-name
+import functools
+
+import pytest
+import slash
+from slash.exceptions import NoActiveSession
+from slash.runner import run_tests
+
+
+@pytest.mark.parametrize('adder', ['add_failure', 'add_error'])
+def test_stop_on_error_with_error_and_skip(suite, adder):
+    suite_test = suite[2]
+    suite_test.append_line('slash.{0}("err")'.format(adder))
+    suite_test.append_line('slash.skip_test()')
+    suite_test.expect_skip()
+
+    for test in suite.iter_all_after(suite_test, assert_has_more=True):
+        test.expect_not_run()
+
+    summary = suite.run(additional_args=['-x'])
+    [result] = summary.get_all_results_for_test(suite_test)
+
+    assert result.has_skips()
+    assert result.has_errors_or_failures()
+
+
+@pytest.mark.parametrize('adder', ['add_failure', 'add_error'])
+def test_stop_on_error_from_previous_run(suite, adder):
+    test_a = suite[2]
+    test_b = suite[4]
+
+    # avoid slash.ctx here, because the stored object would be a proxy
+    test_a.append_line('slash.g.inject_to_result = slash.context.session.results.current')
+    test_b.append_line('slash.g.inject_to_result.{}("injected")'.format(adder))
+
+    if adder == 'add_error':
+        test_a.expect_error()
+    elif adder == 'add_failure':
+        test_a.expect_failure()
+    else:
+        raise NotImplementedError() # pragma: no cover
+
+    all_after = list(suite.iter_all_after(test_b))
+    assert all_after
+    for test in all_after:
+        test.expect_not_run()
+
+    suite.run(additional_args=['-x'])
+
+
+def test_run_tests_fails_without_active_session():
+    with pytest.raises(NoActiveSession):
+        run_tests([])
+
+
+def test_simple_run(suite):
+    suite.run()
+
+
+def test_iter_results_ordering(suite):
+    for index, test in enumerate(suite):
+        test.append_line('slash.context.result.data["index"] = {0}'.format(index))
+
+    results = list(suite.run().session.results.iter_test_results())
+
+    for index, result in enumerate(results):
+        assert result.data['index'] == index
+
+
+def test_failed(suite, suite_test):
+    suite_test.when_run.fail()
+    result = suite.run()[suite_test]
+    assert result.is_failure()
+    assert not result.is_error()
+    assert not result.is_success()
+
+
+def test_error(suite, suite_test):
+    suite_test.when_run.error()
+    result = suite.run()[suite_test]
+    assert result.is_error()
+    assert not result.is_failure()
+    assert not result.is_success()
+
+
+def test_skip(suite, suite_test):
+    suite_test.when_run.skip()
+    result = suite.run()[suite_test]
+    assert result.is_skip()
+    assert not result.is_error()
+    assert not result.is_failure()
+    assert not result.is_success()
+
+
+def test_stop_on_fatal_exception(suite, suite_test, fatal_error_adder):
+    fatal_error_adder(suite_test)
+    for remaining_test in suite.iter_all_after(suite_test):
+        remaining_test.expect_not_run()
+
+    suite.run()
+
+
+@pytest.mark.parametrize('stop_through_config', [True, False])
+def test_stop_on_error(suite, suite_test, failure_type, stop_through_config, config_override):
+    if failure_type == 'error':
+        suite_test.when_run.error()
+    elif failure_type == 'failure':
+        suite_test.when_run.fail()
+    else:
+        raise NotImplementedError()  # pragma: no cover
+
+    for test in suite.iter_all_after(suite_test):
+        test.expect_not_run()
+
+    if stop_through_config:
+        config_override('run.stop_on_error', True)
+        kwargs = {}
+    else:
+        config_override('run.stop_on_error', False)
+        kwargs = {'additional_args': ['-x']}
+    suite.run(**kwargs)
+
+
+def test_stop_on_error_unaffected_by_skips(suite, suite_test):
+    suite_test.when_run.skip()
+    summary = suite.run(additional_args=['-x'])
+    for test in suite.iter_all_after(suite_test):
+        for res in summary.get_all_results_for_test(test):
+            assert res.is_success()
+
+
+
+def test_debug_if_needed(request, config_override, suite, suite_test):
+    suite_test.when_run.fail()
+
+    debugged = {'value': False}
+
+    def _debug_if_needed(exc_info):  # pylint: disable=unused-argument
+        debugged['value'] = True
+
+    # pylint: disable=protected-access
+    request.addfinalizer(functools.partial(
+        setattr, slash.utils.debug, '_KNOWN_DEBUGGERS', slash.utils.debug._KNOWN_DEBUGGERS))
+    slash.utils.debug._KNOWN_DEBUGGERS = [_debug_if_needed]
+
+    config_override('debug.enabled', True)
+
+    suite.run()
+
+    assert debugged['value']
+
+@pytest.fixture(params=['raising', 'adding'])
+def fatal_error_adder(request, failure_type):
+
+    def adder(test):
+        if request.param == 'raising':
+            test.append_line(
+                'from slash.exception_handling import mark_exception_fatal')
+            test.append_line('raise mark_exception_fatal({0}())'.format('AssertionError' if failure_type == 'failure' else 'Exception'))
+        elif request.param == 'adding':
+            test.append_line('slash.add_{0}("msg").mark_fatal()'.format(failure_type))
+        else:
+            raise NotImplementedError() # pragma: no cover
+
+        getattr(test, 'expect_{0}'.format(failure_type))()
+    return adder
+
+
+@pytest.fixture(params=['failure', 'error'])
+def failure_type(request):
+    return request.param
diff --git a/tests/test_running_ad_hoc_tests.py b/tests/test_running_ad_hoc_tests.py
new file mode 100755
index 0000000000..6493274eb1
--- /dev/null
+++ b/tests/test_running_ad_hoc_tests.py
@@ -0,0 +1,24 @@
+"""Slash should support running ad-hoc test objects, that were not loaded from a file
+"""
+import pytest
+import slash
+
+
+@pytest.mark.parametrize('is_class', [True, False])
+def test_ad_hoc_test_running(checkpoint, is_class):
+
+    if is_class:
+        class test_sample(slash.Test):
+
+            def test_something(self):
+                checkpoint()
+
+    else:
+        def test_sample():
+            checkpoint()
+
+    with slash.Session() as session:
+        with session.get_started_context():
+            slash.runner.run_tests(slash.loader.Loader().get_runnables(test_sample))
+    assert session.results.is_success()
+    assert checkpoint.called
diff --git a/tests/test_scope_manager.py b/tests/test_scope_manager.py
new file mode 100755
index 0000000000..82c575b4cc
--- /dev/null
+++ b/tests/test_scope_manager.py
@@ -0,0 +1,122 @@
+# pylint: disable=redefined-outer-name
+import collections
+import functools
+import itertools
+
+import pytest
+import slash
+from slash._compat import iteritems
+from slash.core.scope_manager import ScopeManager
+from .utils import make_runnable_tests
+from .utils.suite_writer import Suite
+
+
+def test_requirement_mismatch_end_of_module():
+    """Test that unmet requirements at end of file(module) still enable scope manager to detect the end and properly pop contextx"""
+
+    suite = Suite()
+
+    num_files = 3
+    num_tests_per_file = 5
+
+    for i in range(num_files):  # pylint: disable=unused-variable
+        file1 = suite.add_file()
+
+        for j in range(num_tests_per_file):  # pylint: disable=unused-variable
+            file1.add_function_test()
+
+        t = file1.add_function_test()
+        t.add_decorator('slash.requires(lambda: False)')
+        t.expect_skip()
+
+    suite.run()
+
+
+def test_scope_manager(dummy_fixture_store, scope_manager, tests_by_module):
+    # pylint: disable=protected-access
+    last_scopes = None
+    for module_index, tests in enumerate(tests_by_module):
+        for test_index, test in enumerate(tests):
+            scope_manager.begin_test(test)
+            assert dummy_fixture_store._scopes == ['session', 'module', 'test']
+            expected = _increment_scope(
+                last_scopes,
+                test=1,
+                module=1 if test_index == 0 else 0,
+                session=1 if test_index == 0 and module_index == 0 else 0)
+            assert dummy_fixture_store._scope_ids == expected
+            # make sure the dict is copied
+            assert expected is not dummy_fixture_store._scope_ids
+            last_scopes = expected
+            scope_manager.end_test(test)
+            assert dummy_fixture_store._scopes == ['session', 'module']
+            assert dummy_fixture_store._scope_ids == last_scopes
+
+    scope_manager.flush_remaining_scopes()
+    assert not dummy_fixture_store._scopes
+
+
+@pytest.fixture
+def scope_manager(dummy_fixture_store, forge):
+    session = slash.Session()
+    forge.replace_with(session, 'fixture_store', dummy_fixture_store)
+    return ScopeManager(session)
+
+
+@pytest.fixture
+def dummy_fixture_store():
+    return DummyFixtureStore()
+
+
+@pytest.fixture
+def tests_by_module():
+
+    def test_func():
+        pass
+
+    num_modules = 5
+    num_tests_per_module = 3
+    returned = []
+
+    with slash.Session():
+        for module_index in range(num_modules):
+            module_name = '__module_{0}'.format(module_index)
+            returned.append([])
+            for test_index in range(num_tests_per_module):  # pylint: disable=unused-variable
+                [test] = make_runnable_tests(test_func)  # pylint: disable=unbalanced-tuple-unpacking
+                assert test.__slash__.module_name
+                test.__slash__.module_name = module_name
+                returned[-1].append(test)
+    return returned
+
+
+def _increment_scope(prev_scopes, **increments):
+    if not prev_scopes:
+        returned = {}
+    else:
+        returned = prev_scopes.copy()
+    for key, value in iteritems(increments):
+        if value == 0:
+            continue
+        if key not in returned:
+            returned[key] = 0
+        returned[key] += value
+    return returned
+
+
+class DummyFixtureStore(object):
+
+    def __init__(self):
+        super(DummyFixtureStore, self).__init__()
+        self._scopes = []
+        self._counters = collections.defaultdict(
+            functools.partial(itertools.count, 1))
+        self._scope_ids = {}
+
+    def push_scope(self, scope):
+        self._scopes.append(scope)
+        self._scope_ids[scope] = next(self._counters[scope])
+
+    def pop_scope(self, scope):
+        latest_scope = self._scopes.pop()
+        assert latest_scope == scope
diff --git a/tests/test_scoped_cleanups.py b/tests/test_scoped_cleanups.py
new file mode 100755
index 0000000000..2b0cc3a857
--- /dev/null
+++ b/tests/test_scoped_cleanups.py
@@ -0,0 +1,119 @@
+# pylint: disable=redefined-outer-name,unused-variable,unused-argument
+import pytest
+
+
+import slash
+from slash.loader import Loader
+
+from .utils.suite_writer import Suite
+
+_MODULE_SCOPE_ADDER = 'slash.add_cleanup({0}, scope="module")'
+
+
+def test_cleanups_from_test_start(suite):
+
+    num_tests = 5
+    for _ in range(num_tests):
+        suite.add_test()
+
+    events = []
+    test_ids = []
+
+    @slash.hooks.register
+    def test_start():
+        test_id = slash.context.test.__slash__.id
+        test_ids.append(test_id)
+        events.append(('test_start', test_id))
+
+        @slash.add_cleanup
+        def cleanup():
+            events.append(('test_cleanup', test_id))
+
+    suite.run()
+
+    assert len(events) == len(suite) * 2 == num_tests * 2
+    expected = []
+    for test_id in test_ids:
+        expected.append(('test_start', test_id))
+        expected.append(('test_cleanup', test_id))
+    assert events == expected
+
+
+def test_module_scope(scoped_suite, file1_tests, file2_tests):
+    file1_test = file1_tests[0]
+    file1_end = file1_tests[-1].add_deferred_event(decorator='slash.add_cleanup')
+    file1_test_cleanup = file1_test.add_deferred_event(adder=_MODULE_SCOPE_ADDER)
+
+    summary = scoped_suite.run()
+    assert summary.events[file1_end].timestamp < summary.events[file1_test_cleanup].timestamp
+
+
+
+def test_cleanups_without_session_start_never_called(checkpoint):
+    assert not checkpoint.called
+    with slash.Session():
+        slash.add_cleanup(checkpoint)
+        assert not checkpoint.called
+    assert not checkpoint.called
+
+
+def test_cleanups_before_session_start_get_deferred(checkpoint):
+    with slash.Session() as s:
+        slash.add_cleanup(checkpoint)
+        with s.get_started_context():
+            assert not checkpoint.called
+        assert checkpoint.called_count == 1
+
+
+def test_cleanups_within_cleanups_preserve_scope(checkpoint1):
+    """Cleanups added from within other cleanups should happen within the scope of the parent cleanups
+    """
+
+    @slash.parametrize('x', [1, 2])
+    def test_something(x):
+        pass
+
+    with slash.Session() as s:
+        [fake_test1, fake_test2] = Loader().get_runnables(test_something)  # pylint: disable=unbalanced-tuple-unpacking
+
+        s.scope_manager.begin_test(fake_test1)
+
+        def cleanup():
+            slash.add_cleanup(checkpoint1)
+
+        slash.add_cleanup(cleanup)
+
+        assert not checkpoint1.called
+        s.scope_manager.end_test(fake_test1)
+
+        assert checkpoint1.called
+
+
+def test_errors_associated_with_correct_result(scoped_suite, file1_tests, file2_tests):
+    file1_test = file1_tests[0]
+    file1_test_cleanup = file1_test.add_deferred_event(adder=_MODULE_SCOPE_ADDER, extra_code=['assert 1 == 2'])
+    file1_test.expect_failure()
+
+    scoped_suite.run()
+
+
+@pytest.fixture
+def scoped_suite(suite, file1_tests, file2_tests):
+    return suite
+
+
+@pytest.fixture
+def suite():
+    return Suite()
+
+
+@pytest.fixture
+def file1_tests(suite):
+    file1 = suite.add_file()
+    return [file1.add_function_test() for i in range(5)]
+
+
+@pytest.fixture
+def file2_tests(suite):
+    file2 = suite.add_file()
+    return [file2.add_function_test() for i in range(3)]
diff --git a/tests/test_site_customization.py b/tests/test_site_customization.py
new file mode 100755
index 0000000000..71c1d04c7c
--- /dev/null
+++ b/tests/test_site_customization.py
@@ -0,0 +1,102 @@
+# pylint: disable=global-statement,global-variable-not-assigned
+from .utils import TestCase
+import os
+import sys
+from tempfile import mktemp
+import slash
+import slash.site
+from slash._compat import cStringIO
+from slash.frontend import slash_run
+import requests
+import pkg_resources
+
+
+class SlashRunSiteCustomizationTest(TestCase):
+    "Make sure ``slash run`` calls site.load()"
+
+    def setUp(self):
+        super(SlashRunSiteCustomizationTest, self).setUp()
+        self.forge.replace(slash.site, "load")
+        self.forge.replace_with(sys, "stderr", cStringIO())
+
+    def test_slash_run_calls_site_load(self):
+        slash.site.load(working_directory=None)
+        self.forge.replay()
+        app = slash_run.slash_run([])
+        assert app.exit_code != 0
+
+_customization_index = 0
+_loaded_customizations = []
+
+
+def _apply_customization(index=0):
+    _loaded_customizations.append(index)
+
+
+class CustomizationTest(TestCase):
+
+    def setUp(self):
+        super(CustomizationTest, self).setUp()
+        global _loaded_customizations
+        global _customization_index
+        _customization_index = 0
+        _loaded_customizations = []
+
+    def get_customization_source(self):
+        global _customization_index
+        returned = "import {0}; {0}._apply_customization({1})".format(__name__, _customization_index)
+        _customization_index += 1
+        return returned
+
+    def test_customize_via_local_and_global_slashrc(self):
+        self._test_customize_via_local_slashrc(also_use_global=True)
+
+    def test_customize_via_local_slashrc(self):
+        self._test_customize_via_local_slashrc(also_use_global=False)
+
+    def _test_customize_via_local_slashrc(self, also_use_global):
+        if also_use_global:
+            global_slashrc_path = os.path.join(self.get_new_path(), "slashrc")
+            self.override_config("run.user_customization_file_path", global_slashrc_path)
+            with open(global_slashrc_path, "w") as f:
+                f.write(self.get_customization_source())
+
+        self.addCleanup(os.chdir, os.path.abspath("."))
+        os.chdir(self.get_new_path())
+        with open(".slashrc", "w") as f:
+            f.write(self.get_customization_source())
+        self.assert_customization_loaded()
+
+    def test_customize_via_env_var(self):
+        os.environ["SLASH_SETTINGS"] = custom_filename = mktemp()
+        self.addCleanup(os.environ.pop, "SLASH_SETTINGS")
+        with open(custom_filename, "w") as f:
+            f.write(self.get_customization_source())
+        self.assert_customization_loaded()
+
+    def test_customize_via_url(self):
+        url = "http://nonexistent.com/some/path/to/custom/file.py"
+        self.forge.replace(requests, "get")
+        fake_response = self.forge.create_mock(requests.Response)
+        fake_response.raise_for_status().whenever()
+        fake_response.content = self.get_customization_source()
+        requests.get(url).and_return(fake_response)
+        os.environ["SLASH_SETTINGS"] = url
+        self.addCleanup(os.environ.pop, "SLASH_SETTINGS")
+        self.forge.replay()
+        self.assert_customization_loaded()
+
+    def test_customize_via_pkgutil_entry_point(self):
+        self.forge.replace(pkg_resources, "iter_entry_points")
+        entry_point = self.forge.create_wildcard_mock()
+        pkg_resources.iter_entry_points("slash.site.customize").and_return(iter([entry_point]))
+        unused = self.get_customization_source()  # expect a single customization  # pylint: disable=unused-variable
+        entry_point.load().and_return(_apply_customization)
+        self.forge.replay()
+        self.assert_customization_loaded()
+
+    def assert_customization_loaded(self):
+        global _loaded_customizations
+        global _customization_index
+        slash.site.load()
+        self.assertEqual(_loaded_customizations, list(range(_customization_index)))
diff --git a/tests/test_skips.py b/tests/test_skips.py
new file mode 100755
index 0000000000..d7d5b7a1c4
--- /dev/null
+++ b/tests/test_skips.py
@@ -0,0 +1,87 @@
+import pytest
+import slash
+
+from .utils import run_tests_in_session
+
+
+@pytest.mark.parametrize("args", [(), ("message",)])
+def test_skip_test(args):
+    "Make sure the skip_test function raises a SkipTest exception"
+    with pytest.raises(slash.exceptions.SkipTest) as caught:
+        slash.skip_test(*args)
+    if args:
+        assert caught.value.reason == args[0]
+
+
+def test_skip_with_before_after_test(checkpoint):
+    "Make sure that after() is called for Test even if we skip"
+    class MyTest(slash.Test):
+
+        def test(self):
+            slash.skip_test("!")
+
+        def after(self):
+            checkpoint()
+
+    _assert_skips(MyTest, reason="!")
+    assert checkpoint.called
+
+
+def test_method_without_reason():
+    class Test(slash.Test):
+
+        @slash.skipped
+        def test(self):
+            pass
+
+    _assert_skips(Test)
+
+
+def test_method_with_reason():
+
+    class Test(slash.Test):
+
+        @slash.skipped("reason")
+        def test(self):
+            pass
+    _assert_skips(Test, "reason")
+
+
+def test_class_decorator(suite):
+
+    cls = suite.classes[1]
+
+    cls.add_decorator('slash.skipped("reason")')
+
+    for test in cls.tests:
+        test.expect_skip()
+
+    results = suite.run()
+
+    for test in cls.tests:
+        result = results[test]
+        assert 'reason' in result.get_skips()
+
+
+def test_custom_skip_exception():
+    reason = 'blabla'
+
+    class MyCustomSkipException(Exception):
+
+        def __repr__(self):
+            return reason
+        __str__ = __repr__
+
+
+    def test_skip():
+        slash.register_skip_exception(MyCustomSkipException)
+        raise MyCustomSkipException()
+
+    _assert_skips(test_skip, reason=reason)
+
+
+def _assert_skips(thing, reason=None):
+    session = run_tests_in_session(thing)
+    for res in session.results:
+        assert res.is_skip()
+        assert res.get_skips() == [reason]
diff --git a/tests/test_slash_list.py b/tests/test_slash_list.py
new file mode 100755
index 0000000000..8d52be3c59
--- /dev/null
+++ b/tests/test_slash_list.py
@@ -0,0 +1,133 @@
+from __future__ import print_function
+import functools
+import os
+import re
+
+from slash.frontend.slash_list import slash_list
+from slash._compat import StringIO
+from .utils.suite_writer import Suite
+
+import pytest
+
+
+@pytest.mark.parametrize('flag', ["--only-fixtures", "--only-tests", None])
+def test_slash_list(suite, flag):
+    suite.debug_info = False
+    _ = suite.slashconf.add_fixture()
+    path = suite.commit()
+    report_stream = StringIO()
+
+    args = [path]
+    if flag is not None:
+        args.append(flag)
+    slash_list(args, report_stream)
+    assert report_stream.getvalue()
+
+
+@pytest.mark.parametrize('allow_empty', [True, False])
+def test_slash_list_without_any_tests(allow_empty):
+    empty_suite = Suite()
+    empty_suite.debug_info = False
+    path = empty_suite.commit()
+    report_stream = StringIO()
+    args = [path]
+    if allow_empty:
+        args.append('--allow-empty')
+    rc = slash_list(args, report_stream)
+    expected_rc = 0 if allow_empty else 1
+    assert rc == expected_rc
+
+
+def test_slash_list_tests_without_tags(suite):
+    suite.debug_info = False
+    path = suite.commit()
+    report_stream = StringIO()
+    args = [path, '--show-tags', '--no-output']
+    slash_list(args, report_stream)
+    output = report_stream.getvalue()
+    assert not output
+
+
+@pytest.mark.parametrize('should_show_tags', [True, False])
+def test_slash_list_tests_with_or_without_tags(suite, should_show_tags, suite_test):
+    suite_test.add_decorator('slash.tag("bla")')
+    suite.debug_info = False
+    path = suite.commit()
+    report_stream = StringIO()
+    args = [path, '--only-tests']
+    if should_show_tags:
+        args.append('--show-tags')
+    slash_list(args, report_stream)
+    output = report_stream.getvalue()
+    assert ('Tags' in output) == (should_show_tags)
+
+
+@pytest.mark.parametrize('relative', [True, False])
+def test_slash_list_tests_relative_or_not(suite, relative):
+    suite.debug_info = False
+    path = suite.commit()
+    report_stream = StringIO()
+    args = [path]
+    if relative:
+        args.append('--relative-paths')
+    slash_list(args, report_stream)
+    output_lines = {
+        _strip(line)
+        for line in report_stream.getvalue().splitlines()
+    } - {"Tests", "Fixtures"}
+    assert output_lines
+    for filename in output_lines:
+        assert os.path.isabs(filename) == (not relative)
+
+
+@pytest.mark.parametrize('invalid', [None, 'test', 'method'])
+@pytest.mark.parametrize('allow_empty', [True, False])
+def test_slash_list_suite_file_incorrect_names(tmpdir, invalid, allow_empty):
+
+    with tmpdir.join('test_file.py').open('w') as f:
+        _print = functools.partial(print, file=f)
+
+        _print('import slash')
+        _print('class TestSomething(slash.Test):')
+        _print('    def test_method(self):')
+        _print('        pass')
+        _print()
+        _print('def test_function():')
+        _print('    pass')
+
+    function_name_remainder = method_name_remainder = ''
+
+    if invalid == 'test':
+        function_name_remainder = 'f'
+    elif invalid == 'method':
+        method_name_remainder = 'm'
+    elif invalid is not None:
+        raise NotImplementedError() # pragma: no cover
+
+    error_stream = StringIO()
+
+    with tmpdir.join('suitefile').open('w') as suite_file:
+        _print = functools.partial(print, file=suite_file)
+        _print('{}:TestSomething.test_method{}'.format(f.name, method_name_remainder))
+        _print('{}:test_function{}'.format(f.name, function_name_remainder))
+
+    args = ['-f', suite_file.name]
+    if allow_empty:
+        args.append('--allow-empty') # make sure allow-empty does not affect invalid name lookup
+    result = slash_list(args, error_stream=error_stream)
+
+    if invalid is None:
+        assert result == 0
+    else:
+        assert result != 0
+        assert 'Could not load tests' in error_stream.getvalue()
+        if invalid == 'test':
+            assert 'test_functionf' in error_stream.getvalue()
+        elif invalid == 'method':
+            assert 'test_methodm' in error_stream.getvalue()
+        else:
+            raise NotImplementedError() # pragma: no cover
+
+
+def _strip(line):
+    return re.sub(r'\x1b\[.+?m', '', line).strip()
diff --git a/tests/test_slash_resume.py b/tests/test_slash_resume.py
new file mode 100755
index 0000000000..256423e5d4
--- /dev/null
+++ b/tests/test_slash_resume.py
@@ -0,0 +1,62 @@
+# pylint: disable=redefined-outer-name
+import pytest
+import slash.resuming
+from slash.resuming import (CannotResume, get_last_resumeable_session_id, get_tests_to_resume)
+
+
+def test_resume_no_session():
+    with pytest.raises(CannotResume):
+        get_tests_to_resume("nonexisting_session")
+
+def test_get_last_resumeable_session(suite):
+    suite[len(suite) // 2].when_run.fail()
+    prev_id = None
+    for i in range(5):  # pylint: disable=unused-variable
+        results = suite.run()
+        assert results.session.id != prev_id
+        prev_id = results.session.id
+        assert get_last_resumeable_session_id() == results.session.id
+
+def test_resume(suite):
+    fail_index = len(suite) // 2
+    suite[fail_index].when_run.fail()
+    for index, test in enumerate(suite):
+        if index > fail_index:
+            test.expect_not_run()
+    result = suite.run(additional_args=['-x'])
+    resumed = get_tests_to_resume(result.session.id)
+
+    assert len(resumed) + result.session.results.get_num_started() - 1 == len(suite)
+
+def test_resume_with_parametrization(suite, suite_test):
+    num_values1 = 3
+    num_values2 = 5
+    suite_test.add_parameter(num_values=num_values1)
+    suite_test.add_parameter(num_values=num_values2)
+    fail_index = len(suite) // 2
+    suite[fail_index].when_run.fail()
+    summary = suite.run()
+    resumed = get_tests_to_resume(summary.session.id)
+
+    assert len(summary.get_all_results_for_test(suite_test)) == num_values1 * num_values2
+    assert len(resumed) == 1
+    assert resumed[0].function_name == suite[fail_index].name
+
+def test_different_folder_no_resume_session_id(suite, tmpdir):  # pylint: disable=unused-argument
+    fail_index = len(suite) // 2
+    suite[fail_index].when_run.fail()
+    suite.run()
+    sessoin_id = get_last_resumeable_session_id()
+
+    assert sessoin_id
+    with tmpdir.ensure_dir().as_cwd():
+        with pytest.raises(CannotResume):
+            sessoin_id = get_last_resumeable_session_id()
+
+def test_delete_old_sessions(suite):
+    result = suite.run()
+    assert result.session.id == get_last_resumeable_session_id()
+    slash.resuming._MAX_DAYS_SAVED_SESSIONS = 0 # pylint: disable=protected-access
+    result = suite.run()
+    with pytest.raises(CannotResume):
+        get_last_resumeable_session_id()
diff --git a/tests/test_slash_run.py b/tests/test_slash_run.py
new file mode 100755
index 0000000000..991384d5e6
--- /dev/null
+++ b/tests/test_slash_run.py
@@ -0,0 +1,193 @@
+# pylint: disable=redefined-outer-name
+from __future__ import print_function
+
+import os
+import sys
+
+import pytest
+import slash
+from slash import config, site
+from slash._compat import StringIO
+from slash.frontend import slash_run
+from slash.frontend.main import main_entry_point
+
+from .utils import no_op, NullFile, TestCase
+
+
+def test_slash_run_fails_fast_for_missing_files():
+    result = slash_run.slash_run(
+        ["/non/existing/path"], report_stream=NullFile())
+    assert result.exit_code != 0, "slash run unexpectedly succeeded for a missing path"
+
+
+def test_slash_run_filter_strings(suite, suite_test):
+    for test in suite:
+        if test is not suite_test:
+            test.expect_deselect()
+
+    suite.run(additional_args=['-k', suite_test.name])
+
+
+################################################################################
+
+
+class ArgumentParsingTest(TestCase):
+
+    def setUp(self):
+        super(ArgumentParsingTest, self).setUp()
+        self.stderr = StringIO()
+        self.stdout = StringIO()
+        self.addCleanup(setattr, sys, "stderr", sys.stderr)
+        self.forge.replace_with(sys, "stderr", self.stderr)
+        self.addCleanup(setattr, sys, "stdout", sys.stdout)
+        self.forge.replace_with(sys, "stdout", self.stdout)
+
+    callback_success = False
+
+    def _collect_tests_stub(self, app, args):  # pylint: disable=unused-argument
+        self.assertTrue(config.root.debug.enabled)
+        self.assertEqual(app.positional_args, ["test1.py", "test2.py"])
+        # this must be last to make sure the stub ran successfully
+        self.callback_success = True
+        return []
+
+    def test_interspersed_positional_arguments(self):
+
+        self.forge.replace_with(
+            slash_run, "_collect_tests", self._collect_tests_stub)
+
+        self.forge.replace_with(
+            sys, "argv", "/path/to/slash run -vv test1.py -x test2.py --pdb".split())
+        with self.assertRaises(SystemExit) as caught:
+            main_entry_point()
+        self.assertTrue(self.callback_success)
+        if isinstance(caught.exception, int):
+            # python 2.6
+            code = caught.exception
+        else:
+            code = caught.exception.code
+        self.assertEqual(code, 0)
+
+
+class SlashHelpTest(ArgumentParsingTest):
+
+    def _fake_execute(self, argv):
+        prev_argv = list(sys.argv)
+        sys.argv = argv[:]
+        try:
+            main_entry_point()
+        finally:
+            sys.argv = prev_argv
+
+    def test_slash_run_help(self):
+
+        with self.assertRaises(SystemExit):
+            self._fake_execute(["slash", "run", "-h"])
+
+        self.assertTrue(self.stdout.getvalue().startswith("usage: slash run "))
+        self.assertIn("TEST [TEST ", self.stdout.getvalue())
+
+    def test_slash_help(self):
+
+        with self.assertRaises(SystemExit):
+            self._fake_execute(["slash", "-h"])
+
+        self.assertTrue(self.stdout.getvalue().startswith(
+            "usage: slash command..."), self.stdout.getvalue())
+
+
+def test_slash_run_directory_success(suite):
+    assert suite.run().exit_code == 0
+
+
+def test_slash_run_default_directory(config_override, suite, suite_path):
+    config_override("run.default_sources", [suite_path])
+    suite.run(args=[], commit=False)
+
+
+def test_slash_run_success_if_skips(suite):
+    suite[1].when_run.skip()
+    assert suite.run().exit_code == 0
+
+
+def test_slash_run_from_file(tmpdir, suite):
+
+    for _ in range(20):
+        suite.add_test()
+
+    suite_path = suite.commit()
+
+    assert len(suite.files) > 2
+    file1 = suite.files[0]
+    file2 = suite.files[-1]
+
+    deselected = [t for t in suite if t.file not in (file1, file2)]
+    assert deselected
+    for d in deselected:
+        d.expect_deselect()
+
+    assert os.path.isdir(suite_path)
+
+    filename1 = str(tmpdir.join("file1.txt"))
+    filename2 = str(tmpdir.join("file2.txt"))
+
+    for suite_file, filename in zip((file1, file2), (filename1, filename2)):
+        with open(filename, "w") as f:
+            print("# this is a comment", file=f)
+            f_name = os.path.join(suite_path, suite_file.get_relative_path())
+            assert os.path.isdir(suite_path)
+            assert os.path.exists(f_name)
+            print(f_name, file=f)
+
+    suite.run(args=["-f", filename1, "-f", filename2], commit=False)
+
+
+@pytest.mark.parametrize('failure_type', ['fail', 'error'])
+def test_slash_run_directory_failure(suite, failure_type):
+    getattr(suite[1].when_run, failure_type)()
+    path = suite.commit()  # pylint: disable=unused-variable
+    assert suite.run().exit_code != 0
+
+
+def test_slash_run_specific_file(suite):
+
+    for _ in range(5):
+        suite.add_test()
+    suite_path = suite.commit()
+
+    assert len(suite.files) > 1
+
+    file = suite.files[1]
+
+    deselected = [t for t in suite if t.file != file]
+    assert deselected
+    for t in deselected:
+        t.expect_deselect()
+
+    suite.run(args=[os.path.join(suite_path, file.get_relative_path())], commit=False)
+
+
+def test_session_host_variables():
+    with slash.Session() as session:
+        with session.get_started_context():
+            assert session.host_fqdn is not None
+            assert session.host_name is not None
+            assert session.host_fqdn.startswith(session.host_name)
+
+
+@pytest.fixture(autouse=True)
+def no_site_load(forge):
+    forge.replace_with(site, 'load', no_op)
+
+
+@pytest.fixture
+def suite_path(suite):
+    returned = suite.commit()
+    assert os.path.isdir(returned)
+    return returned
+
+@pytest.fixture(autouse=True)
+def session_state_path(config_override, tmpdir):
+    path = tmpdir.join('session_state_dir').join('session_data')
+    config_override("run.session_state_path", str(path))
+    return path
diff --git a/tests/test_suite_files.py b/tests/test_suite_files.py
new file mode 100755
index 0000000000..9de2e34fe6
--- /dev/null
+++ b/tests/test_suite_files.py
@@ -0,0 +1,196 @@
+# pylint: disable=redefined-outer-name
+from __future__ import print_function
+
+import os
+import shutil
+from tempfile import mkdtemp
+
+import pytest
+from slash.utils import suite_files
+
+
+def test_iter_suite_paths_files_abspaths(filename, paths):
+    with open(filename, 'w') as f:
+        f.write('\n'.join(paths))
+
+    assert [p for p, _ in suite_files.iter_suite_file_paths([filename])] == paths
+
+
+def test_iter_suite_paths_files_relpath(filename, paths):
+    with open(filename, 'w') as f:
+        for path in paths:
+            relpath = os.path.relpath(path, os.path.dirname(filename))
+            assert not os.path.isabs(relpath)
+            f.write(relpath)
+            f.write('\n')
+
+    assert [p for p, _ in suite_files.iter_suite_file_paths([filename])] == [os.path.abspath(p) for p in paths]
+
+
+def test_suite_files(suite, suite_test, suite_file):  # pylint: disable=unused-argument
+    suite.run(args=[])
+
+
+def test_suite_file_with_filter(suite, suite_test, suite_file):
+    path = suite.commit()
+    with suite_file.open('w') as f:
+        print(path, '# filter:', suite_test.name, file=f)
+    suite.run(args=[])
+
+
+def test_parse_filter_string():
+    suite_entry = suite_files._parse_path_filter_and_repeat('some_path.py # filter: bla')  # pylint: disable=protected-access
+    assert suite_entry.path == 'some_path.py'
+    assert suite_entry.matcher is not None
+    assert suite_entry.matcher.matches('bla')
+    assert not suite_entry.matcher.matches('blooop')
+
+
+@pytest.mark.parametrize("string", [
+    'some_path.py #',
+    'some_path.py # bbb',
+    'some_path.py#'
+])
+def test_parse_filter_string_no_filter(string):
+    suite_entry = suite_files._parse_path_filter_and_repeat(string)  # pylint: disable=protected-access
+    assert suite_entry.path == 'some_path.py'
+    assert suite_entry.matcher is None
+
+
+def test_iter_suite_file_paths_nested_filter(tmpdir):
+
+    test_filename = '/some/test/file.py'
+    suite_file1 = tmpdir.join('file1.txt')
+    suite_file2 = tmpdir.join('file2.txt')
+
+    with suite_file1.open('w') as f:
+        print(suite_file2, '# filter: not blue', file=f)
+
+    with suite_file2.open('w') as f:
+        print(test_filename, '# filter: green', file=f)
+
+    [(item, matcher)] = suite_files.iter_suite_file_paths([str(suite_file1)])
+    assert item == test_filename
+    assert matcher.matches('green')
+    assert not matcher.matches('blue')
+    assert not matcher.matches('green blue')
+
+
+def test_parse_repeat_string():
+    suite_entry = suite_files._parse_path_filter_and_repeat('some_path.py # repeat: 5')  # pylint: disable=protected-access
+    assert suite_entry.path == 'some_path.py'
+    assert suite_entry.matcher is None
+    assert suite_entry.repeat == 5
+
+
+@pytest.mark.parametrize("string", [
+    'some_path.py # filter: bla, repeat: 5',
+    'some_path.py # repeat: 5, filter: bla',
+])
+def test_parse_repeat_string_with_filter(string):
+    suite_entry = suite_files._parse_path_filter_and_repeat(string)  # pylint: disable=protected-access
+    assert suite_entry.path == 'some_path.py'
+    assert suite_entry.matcher is not None
+    assert suite_entry.matcher.matches('bla')
+    assert not suite_entry.matcher.matches('blooop')
+    assert suite_entry.matcher is not None
+    assert suite_entry.repeat == 5
+
+
+@pytest.fixture
+def suite_file(tmpdir, suite, suite_test, config_override):
+    path = suite.commit()
+    suite_file_path = tmpdir.join('suite.txt')
+    with suite_file_path.open('w') as f:
+        f.write(suite_test.get_full_address(path))
+    suite.deselect_all(exclude=[suite_test])
+    config_override('run.suite_files', [str(suite_file_path)])
+    return suite_file_path
+
+
+@pytest.mark.parametrize('use_relpath', [True, False])
+def test_files_containing_files(filename, paths, use_relpath):
+    filename2 = os.path.join(os.path.dirname(filename), 'file2.txt')
+
+    with open(filename2, 'w') as f:
+        f.write('\n'.join(paths[::-1]))
+
+    if use_relpath:
+        filename2 = os.path.basename(filename2)
+
+    with open(filename, 'w') as f:
+        f.write('\n'.join(paths))
+        f.write('\n')
+        f.write(filename2)
+
+    assert [p for p, _ in suite_files.iter_suite_file_paths([filename])] == paths + paths[::-1]
+
+
+def test_slash_run_with_suite_file(suite, suite_test, tmpdir):
+    path = suite.commit()
+    with tmpdir.join('suitefile').open('w') as suite_file:  # pylint: disable=redefined-outer-name
+        _fill_suite_file(path, [suite_test], suite_file=suite_file)
+
+    for t in suite:
+        if t is not suite_test:
+            t.expect_deselect()
+
+    suite.run(args=[], additional_args=['-f', suite_file.name])
+
+
+def test_slash_run_with_suite_file_invalid_test(suite, suite_test, tmpdir):
+    path = suite.commit()
+
+    additional_test = suite[0]
+    assert additional_test is not suite_test
+
+    with tmpdir.join('suitefile').open('w') as suite_file:  # pylint: disable=redefined-outer-name
+        _fill_suite_file(path, [additional_test], suite_file=suite_file, corrupt=False)
+        _fill_suite_file(path, [suite_test], suite_file=suite_file, corrupt=True)
+
+    for t in suite:
+        t.expect_deselect()
+
+    summary = suite.run(args=[], additional_args=['-f', suite_file.name], expect_session_errors=True)
+    assert summary.exit_code != 0
+    assert 'Cannot find test' in summary.get_console_output()
+    assert 'CORRUPT' in summary.get_console_output()
+
+
+def _fill_suite_file(root_path, tests, suite_file, corrupt=False):  # pylint: disable=redefined-outer-name
+    for test in tests:
+        suite_file.write(test.get_full_address(root_path))
+        if corrupt:
+            suite_file.write('CORRUPT')
+        suite_file.write('\n')
+
+
+@pytest.fixture
+def filename(tmpdir):
+    return str(tmpdir.join('filename.txt'))
+
+
+@pytest.fixture
+def paths(request, tmpdir, use_relpath_for_dir): # pylint: disable=redefined-outer-name
+    basenames = ['file{0}.py'.format(i) for i in range(10)]
+    basenames.extend(['file100.py:SomeClass',
+                      'file101.py:Someclass.test_method'])
+    returned = [os.path.join(os.path.abspath(str(tmpdir)), b) for b in basenames]
+
+    if use_relpath_for_dir:
+        dirname = str(tmpdir.join('dirname'))
+        os.makedirs(dirname)
+    else:
+        dirname = mkdtemp()
+
+        @request.addfinalizer
+        def cleanup():  # pylint: disable=unused-variable
+            shutil.rmtree(dirname)
+    returned.append(dirname)
+
+    return returned
+
+
+@pytest.fixture(params=[True, False])
+def use_relpath_for_dir(request):
+    return request.param
diff --git a/tests/test_suite_writer.py b/tests/test_suite_writer.py
new file mode 100755
index 0000000000..3430563ec8
--- /dev/null
+++ b/tests/test_suite_writer.py
@@ -0,0 +1,24 @@
+import pytest
+
+from .utils.suite_writer import Suite
+
+
+@pytest.mark.parametrize('num_tests', [1, 10])
+def test_len(num_tests):
+    s = Suite()
+    for _ in range(num_tests):
+        s.add_test()
+
+    assert len(s) == num_tests
+
+
+def test_no_debug_info():
+    s = Suite()
+    s.debug_info = False
+
+    for _ in range(10):
+        s.add_test()
+
+    f = s.slashconf.add_fixture()
+    s[3].depend_on_fixture(f)
+    assert s.run().ok()
diff --git a/tests/test_suite_writer_factories.py b/tests/test_suite_writer_factories.py
new file mode 100755
index 0000000000..2e93289d5b
--- /dev/null
+++ b/tests/test_suite_writer_factories.py
@@ -0,0 +1,8 @@
+from .utils.suite_writer import Suite
+
+def test_default_factory_balanced_between_methods_and_functions():
+    suite = Suite()
+    assert suite.num_method_tests == suite.num_function_tests == 0
+    suite.add_test()
+    suite.add_test()
+    assert suite.num_method_tests == suite.num_function_tests == 1
diff --git a/tests/test_suite_writer_fixtures.py b/tests/test_suite_writer_fixtures.py
new file mode 100755
index 0000000000..b6eb287632
--- /dev/null
+++ b/tests/test_suite_writer_fixtures.py
@@ -0,0 +1,49 @@
+# pylint: disable=redefined-outer-name
+import pytest
+
+from .utils.suite_writer import Suite
+
+
+def test_fixture(suite):
+    f = suite.slashconf.add_fixture()
+    test = suite[1]
+    test.depend_on_fixture(f)
+    result = suite.run()
+    result.events.assert_consecutive([
+        ('fixture_start', f.id),
+        ('test_start', test.id),
+        ('test_end', test.id),
+        ('fixture_end', f.id),
+        ])
+
+def test_parametrized_fixture():
+    suite = Suite()
+    test = suite.add_test()
+    f1 = suite.slashconf.add_fixture()
+    p = f1.add_parameter()
+    test.depend_on_fixture(f1)
+    summary = suite.run()
+    assert summary.ok()
+    assert len(summary.session.results) == len(p.values)
+
+def test_regular_test_parametrization(suite, test):
+    # pylint: disable=unused-variable
+    p = test.add_parameter()
+    res = suite.run()
+
+@pytest.fixture
+def test(suite, is_method):
+    if is_method:
+        return suite.method_tests[0]
+    return suite.function_tests[0]
+
+@pytest.fixture(params=[True, False])
+def is_method(request):
+    return request.param
+
+@pytest.fixture
+def suite():
+    s = Suite()
+    for _ in range(10):
+        s.add_test()
+    return s
diff --git a/tests/test_suite_writer_negative.py b/tests/test_suite_writer_negative.py
new file mode 100755
index 0000000000..444165a9cb
--- /dev/null
+++ b/tests/test_suite_writer_negative.py
@@ -0,0 +1,37 @@
+from .utils.suite_writer import Suite
+
+from contextlib import contextmanager
+
+import pytest
+
+# pylint: disable=redefined-outer-name
+
+
+def test_expect_failure_not_met(suite, test):
+    test.expect_failure()
+    with _raises_assertion('Test did not fail as expected'):
+        suite.run()
+
+def test_expect_error_not_met(suite, test):
+    test.expect_error()
+    with _raises_assertion('Test did not issue error as expected'):
+        suite.run()
+
+
+
+@contextmanager
+def _raises_assertion(msg):
+    with pytest.raises(AssertionError) as caught:
+        yield
+    assert str(caught.value) == msg
+
+@pytest.fixture
+def test(suite):
+    return suite[len(suite) // 2]
+
+@pytest.fixture
+def suite():
+    s = Suite()
+    for _ in range(10):
+        s.add_test()
+    return s
diff --git a/tests/test_suite_writer_running.py b/tests/test_suite_writer_running.py
new file mode 100755
index 0000000000..b811372927
--- /dev/null
+++ b/tests/test_suite_writer_running.py
@@ -0,0 +1,47 @@
+# pylint: disable=redefined-outer-name
+import pytest
+
+from .utils.suite_writer import Suite
+from .utils.suite_writer.slash_run_result import Events
+
+
+def test_run_suite_normal(suite):
+    result = suite.run()
+    assert result.session.results.get_num_successful() == len(suite)
+
+
+def test_suite_events(suite):
+    test1, test2 = suite[2], suite[3]
+    result = suite.run()
+    assert result.events['test_start', test1.id].is_before(result.events['test_start', test2.id])
+
+
+def test_events_non_tuple():
+    events = Events()
+    events.add('a')
+    assert 'a' in events
+    assert 'b' not in events
+    assert events.has_event('a')
+    assert not events.has_event('b')
+
+
+def test_events_tuple():
+    events = Events()
+    events.add('a', 'b', 'c')
+    assert 'a' not in events
+    assert 'b' not in events
+    assert ('a', 'b', 'c') in events
+    assert ('a',) not in events
+    assert events.has_event('a', 'b', 'c')
+    assert not events.has_event('a')
+
+
+
+
+
+@pytest.fixture
+def suite():
+    s = Suite()
+    for _ in range(10):
+        s.add_test()
+    return s
diff --git a/tests/test_tagging.py b/tests/test_tagging.py
new file mode 100755
index 0000000000..05a488fbc9
--- /dev/null
+++ b/tests/test_tagging.py
@@ -0,0 +1,135 @@
+# pylint: disable=redefined-outer-name
+import itertools
+
+import pytest
+import slash
+from sentinels import NOTHING
+from slash.core.tagging import NO_TAGS, Tags, get_tags
+from slash.loader import Loader
+
+from .utils.suite_writer.method_test import MethodTest
+
+
+def test_setting_getting_tags(taggable):
+
+    slash.tag('tagname')(taggable)
+
+    assert 'tagname' in get_tags(taggable)
+    assert 'other_tags' not in get_tags(taggable)
+
+
+def test_no_tags_contains(taggable):
+    assert 'bla' not in get_tags(taggable)
+
+
+def test_tags_addition_no_tags_no_tags():
+    assert NO_TAGS + NO_TAGS is NO_TAGS
+
+
+def test_tags_addition_no_tags_regular():
+    tags = Tags({'a': 'b'})
+    assert NO_TAGS + tags is tags
+    assert tags + NO_TAGS is tags
+
+
+def test_tags_addition_regular():
+    tags1 = Tags({'a': 'b'})
+    tags2 = Tags({'c': 'd'})
+    tags3 = tags1 + tags2
+    assert tags3 is not tags1
+    assert tags3 is not tags2
+
+    # pylint: disable=protected-access
+    assert tags1._tags == {'a': 'b'}
+    assert tags2._tags == {'c': 'd'}
+    assert tags3._tags == {'a': 'b', 'c': 'd'}
+
+
+def test_setting_getting_tags_on_metadata(taggable):
+
+    slash.tag('tagname')(taggable)
+
+    with slash.Session() as s:  # pylint: disable=unused-variable
+        tests = Loader().get_runnables(taggable)
+    assert tests
+    for t in tests:
+        assert 'tagname' in t.__slash__.tags
+
+
+def test_metadata_tags(suite, suite_test, tagging_strategy, tags):
+    tagging_strategy(suite_test, tags)
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    for tag_name, tag_value in tags:
+        assert result.test_metadata.tags.has_tag(tag_name)
+        assert result.test_metadata.tags[tag_name] == tag_value
+
+# more tags in test_pattern_matching.py
+
+_tagging_strategies = []
+
+
+def _tagging_strategy(func):
+    _tagging_strategies.append(func)
+    return func
+
+
+@_tagging_strategy
+def _simple_tagging_strategy(taggable, tags):
+    for tag_name, tag_value in tags:
+        taggable.add_decorator(_get_slash_tag_string(tag_name, tag_value))
+
+
+@_tagging_strategy
+def _tag_class_only(taggable, tags):
+    if isinstance(taggable, MethodTest):
+        _simple_tagging_strategy(taggable.cls, tags)
+    else:
+        _simple_tagging_strategy(taggable, tags)
+
+
+@_tagging_strategy
+def _tag_class_and_method(taggable, tags):
+    if not isinstance(taggable, MethodTest):
+        return _simple_tagging_strategy(taggable, tags)
+
+    for (tag_name, tag_value), taggable in zip(tags, itertools.cycle([taggable.cls, taggable])):
+        taggable.add_decorator(_get_slash_tag_string(tag_name, tag_value))
+
+
+def _get_slash_tag_string(tag_name, tag_value):
+    returned = 'slash.tag({0!r}'.format(tag_name)
+    if tag_value is not NOTHING:
+        returned += ', {0!r}'.format(tag_value)
+    returned += ')'
+    return returned
+
+
+@pytest.fixture(params=_tagging_strategies)
+def tagging_strategy(request):
+    return request.param
+
+
+@pytest.fixture(params=[
+    {'simple_tag_without_value': NOTHING},
+    {'single_tag': 'string_value'},
+    {'multiple_tags_1': 1.0, 'multiple_tags_2': True, 'multiple_tags_3': ['list', 'of', 'things']},
+])
+def tags(request):
+    return list(request.param.items())
+
+
+@pytest.fixture(params=['class', 'function'])
+def taggable(request):
+    if request.param == 'class':
+        class TaggableTest(slash.Test):
+
+            def test_1():  # pylint: disable=no-method-argument
+                pass
+        return TaggableTest
+    elif request.param == 'function':
+        def test_1():
+            pass
+        return test_1
+
+    raise NotImplementedError()  # pragma: no cover
diff --git a/tests/test_terminal_writer_wrapper.py b/tests/test_terminal_writer_wrapper.py
new file mode 100755
index 0000000000..df889b8c6a
--- /dev/null
+++ b/tests/test_terminal_writer_wrapper.py
@@ -0,0 +1,25 @@
+# pylint: disable=redefined-outer-name
+import pytest
+from slash._compat import StringIO
+from slash.reporting.console_reporter import TerminalWriterWrapper
+
+
+def test_line_in_progress_no_newline(tw):
+    tw.write('.')
+    tw.write('.')
+    assert tw._line == '..'  # pylint: disable=protected-access
+
+
+def test_line_in_progress_with_newline(tw):
+    tw.write('this is \n a half line')
+    assert tw._line == ' a half line'  # pylint: disable=protected-access
+
+
+def test_line_in_progress_with_end(tw):
+    tw.write('line here\n')
+    assert tw._line == ''  # pylint: disable=protected-access
+
+
+@pytest.fixture
+def tw():
+    return TerminalWriterWrapper(StringIO())
diff --git a/tests/test_test.py b/tests/test_test.py
new file mode 100755
index 0000000000..2a8f32e1ff
--- /dev/null
+++ b/tests/test_test.py
@@ -0,0 +1,126 @@
+from .utils import (
+    TestCase,
+    CustomException,
+    run_tests_in_session,
+    make_runnable_tests,
+    )
+import itertools
+import slash
+
+
+class TestTest(TestCase):
+    """
+    Test the :class:`Test` class, which is the quickest way to create test classes in Slash
+    """
+    def test_test_class(self):
+        events = []
+        class Test(slash.Test):
+            def before(self):
+                events.append("before")
+            def after(self):
+                events.append("after")
+            def test_1(self):
+                events.append("test_1")
+            def test_2(self):
+                events.append("test_2")
+        with slash.Session():
+            tests = make_runnable_tests(Test)
+        for test in tests:
+            self.assertIsInstance(test, Test)
+        self.assertEqual(len(tests), 2)
+        tests.sort(key=lambda test: test._test_method_name)  # pylint: disable=protected-access
+        for test in tests:
+            test.run()
+        self.assertEqual(events, ["before", "test_1", "after", "before", "test_2", "after"])
+
+    def test_before_failures(self):
+        "Check that exceptions during before() prevent after() from happening"
+        events = []
+        class Test(slash.Test):
+            def before(self):
+                raise CustomException()
+            def test(self):
+                events.append("test")
+            def after(self):
+                events.append("after")
+        with slash.Session():
+            [test] = make_runnable_tests(Test)  # pylint: disable=unbalanced-tuple-unpacking
+        with self.assertRaises(CustomException):
+            test.run()
+        self.assertEqual(events, [])
+
+    def test_after_failures(self):
+        class Test(slash.Test):
+            def test(self):
+                assert False, "msg1"
+
+            def after(self):
+                assert False, "msg2"
+
+        session = run_tests_in_session(Test)
+        self.assertFalse(session.results.is_success())
+        [result] = session.results.iter_test_results()
+        self.assertEqual(len(result.get_failures()), 2)
+
+    def test_after_gets_called(self):
+        "If before() is successful, after() always gets called"
+        events = []
+        class Test(slash.Test):
+            def before(self):
+                events.append("before")
+            def test_1(self):
+                events.append("test")
+                raise CustomException(1)
+            def after(self):
+                events.append("after")
+        with slash.Session():
+            [test] = make_runnable_tests(Test)  # pylint: disable=unbalanced-tuple-unpacking
+            with self.assertRaises(CustomException):
+                test.run()
+        self.assertEqual(events, ["before", "test", "after"])
+
+class AbstractTestTest(TestCase):
+    def test_abstract_tests(self):
+        @slash.abstract_test_class
+        class Abstract(slash.Test):
+            def test1(self):
+                pass
+            def test2(self):
+                pass
+            def test3(self):
+                pass
+        with slash.Session():
+            self.assertEqual(list(make_runnable_tests(Abstract)), [])
+        class Derived(Abstract):
+            pass
+        with slash.Session():
+            self.assertEqual(len(list(make_runnable_tests(Derived))), 3)
+
+class TestParametersTest(TestCase):
+    def test_parameters(self):
+        variations = []
+        a_values = [1, 2]
+        b_values = [3, 4]
+        c_values = [5, 6]
+        d_values = [7, 8]
+        class Parameterized(slash.Test):
+            @slash.parameters.iterate(a=a_values)
+            def before(self, a):  # pylint: disable=arguments-differ
+                variations.append([a])
+            @slash.parameters.iterate(b=b_values, c=c_values)
+            def test(self, b, c):
+                variations[-1].extend([b, c])
+            @slash.parameters.iterate(d=d_values)
+            def after(self, d):  # pylint: disable=arguments-differ
+                variations[-1].append(d)
+        with slash.Session():
+            for test in make_runnable_tests(Parameterized):
+                test.run()
+        self.assertEqual(
+            set(tuple(x) for x in variations),
+            set(itertools.product(
+                a_values,
+                b_values,
+                c_values,
+                d_values
+            )))
diff --git a/tests/test_test_loading.py b/tests/test_test_loading.py
new file mode 100755
index 0000000000..1c6d6b5a2d
--- /dev/null
+++ b/tests/test_test_loading.py
@@ -0,0 +1,72 @@
+# pylint: disable=redefined-outer-name, unused-argument
+from __future__ import print_function
+
+import functools
+import os
+import random
+from uuid import uuid4
+
+import pytest
+
+import slash
+
+
+def test_normal_sorting(test_dir, names):
+    assert get_file_names(load(test_dir)) == names
+
+def test_custom_ordering(test_dir, names, indices):
+    @slash.hooks.tests_loaded.register # pylint: disable=no-member
+    def tests_loaded(tests):                # pylint: disable=unused-variable
+        for index, (test, new_index) in enumerate(zip(tests, indices)):
+            assert test.__slash__.file_path.endswith(names[index]), 'Tests are loaded in incorrect order'
+            test.__slash__.set_sort_key(new_index)
+    assert get_file_names(load(test_dir)) == _sorted_by_indices(names, indices)
+
+################################################################################
+## Utils and fixtures
+
+def get_file_names(tests):
+    returned = []
+    for t in tests:
+        file_path = t.__slash__.file_path
+        assert os.path.isabs(file_path)
+        returned.append(os.path.join(
+            os.path.basename(os.path.dirname(file_path)),
+            os.path.basename(file_path)))
+    return returned
+
+def load(source):
+    with slash.Session():
+        return slash.loader.Loader().get_runnables([source])
+
+@pytest.fixture
+def test_dir(tmpdir, names, indices):
+    returned = tmpdir.join(str(uuid4()))
+    indices = range(len(names))[::-1]
+    for index, name in zip(indices, names):
+        with returned.join(name).open('w', ensure=True) as f:
+            _print = functools.partial(print, file=f)
+            _print('import slash')
+            _print('@slash.tag("index", {})'.format(index))
+            _print('def test_something():')
+            _print('    pass')
+    return str(returned)
+
+@pytest.fixture
+def names():
+    return ['a/test_a_b.py', 'a/test_b_a.py', 'b/test_a_a.py', 'b/test_a_b.py']
+
+def _sorted_by_indices(items, indices):
+    returned = [None for _ in items]
+    for index, item in zip(indices, items):
+        returned[index] = item
+    return returned
+
+def _randomized(l):
+    indices = list(range(len(l)))
+    random.shuffle(indices)
+    return [l[index] for index in indices]
+
+@pytest.fixture(params=[reversed, _randomized])
+def indices(request, names):
+    return [names.index(name) for name in request.param(names)]
diff --git a/tests/test_test_metadata.py b/tests/test_test_metadata.py
new file mode 100755
index 0000000000..a80555795e
--- /dev/null
+++ b/tests/test_test_metadata.py
@@ -0,0 +1,161 @@
+from .utils import TestCase
+from .utils import run_tests_assert_success
+import itertools
+import os
+import slash
+from slash._compat import izip_longest
+import pytest
+
+from .utils.suite_writer import Suite
+
+
+@pytest.mark.parametrize('parametrize', [True, False])
+def test_class_name(suite, suite_test, test_type, parametrize):
+    if parametrize:
+        suite_test.add_parameter(num_values=3)
+    summary = suite.run()
+    for result in summary.get_all_results_for_test(suite_test):
+        if test_type == 'method':
+            assert result.test_metadata.class_name.startswith('Test')
+            assert '(' not in result.test_metadata.class_name
+        elif test_type == 'function':
+            assert result.test_metadata.class_name is None
+        else:
+            raise NotImplementedError()  # pragma: no cover
+
+
+@pytest.mark.parametrize('parametrize', [True, False])
+def test_function_name(suite, suite_test, parametrize):
+    if parametrize:
+        suite_test.add_parameter(num_values=3)
+
+    summary = suite.run()
+    for result in summary.get_all_results_for_test(suite_test):
+        function_name = result.test_metadata.function_name
+        assert function_name.startswith('test_')
+        assert '.' not in result.test_metadata.function_name
+        assert '(' not in result.test_metadata.function_name
+
+
+def test_variation(suite, suite_test):
+    fixture = suite.slashconf.add_fixture()
+    param = fixture.add_parameter()  # pylint: disable=unused-variable
+    suite_test.depend_on_fixture(fixture)
+    suite_test.append_line('slash.context.result.data["variation"] = slash.context.test.__slash__.variation.values.copy()')
+    summary = suite.run()
+    for result in summary.get_all_results_for_test(suite_test):
+        assert len(result.data['variation']) == 1
+        assert fixture.name not in result.data['variation']
+        assert '{}.{}'.format(fixture.name, param.name) in result.data['variation']
+
+
+def test_function_name_with_special_parameters(test_type):
+    suite = Suite()
+    assert len(suite) == 0  # pylint: disable=len-as-condition
+    suite_test = suite.add_test(type=test_type)
+    values = ['a.b', 'a(b']
+    suite_test.add_parameter(values=values)
+
+    # we can't verify result because we would not be able to parse the function properly
+    # TODO: this will change once we properly support variations metadata  # pylint: disable=fixme
+    summary = suite.run(verify=False, sort=False)
+    for result, value in izip_longest(summary.session.results, values):
+        function_name = result.test_metadata.function_name
+        assert value not in function_name
+        assert '.' not in result.test_metadata.function_name
+        assert '(' not in result.test_metadata.function_name
+        assert function_name.startswith('test_')
+
+
+def test_module_name_not_none_or_empty_string(suite):
+    for result in suite.run().session.results:
+        assert result.test_metadata.module_name
+
+
+def test_test_index(suite):
+    index = None
+    session = suite.run().session
+    for index, result in enumerate(session.results):
+        assert result.test_metadata.test_index0 == index
+        assert result.test_metadata.test_index1 == index + 1
+    assert index > 0
+
+
+def test_set_test_name(suite, suite_test):
+    result = suite.run()[suite_test]
+    metadata = result.test_metadata
+    assert metadata.file_path in str(metadata)
+    custom_name = 'some_custom_name'
+    metadata.set_test_full_name(custom_name)
+    assert str(metadata) == '<{0}>'.format(custom_name)
+
+
+def test_class_name_with_dot_parameters():
+
+    # pylint: disable=unused-argument
+
+    @slash.parametrize('path', ['x.y'])
+    def test_something(path):
+        pass
+
+    with slash.Session() as s:  # pylint: disable=unused-variable
+        loader = slash.loader.Loader()
+        [test] = loader.get_runnables(test_something)  # pylint: disable=unbalanced-tuple-unpacking
+        assert test.__slash__.class_name is None
+
+
+class TestMetadataTest(TestCase):
+    loaded_tests = []
+
+    def setUp(self):
+        @slash.hooks.register
+        def tests_loaded(tests): # pylint: disable=unused-variable
+            TestMetadataTest.loaded_tests = tests
+
+        super(TestMetadataTest, self).setUp()
+        self.root = self.get_new_path()
+        self.filename = os.path.join(self.root, "testfile.py")
+        with open(self.filename, "w") as f:
+            f.write(_TEST_FILE_TEMPLATE)
+
+        with slash.Session() as s:
+            self.session = run_tests_assert_success(self.filename, session=s)
+            self.tests = self.loaded_tests
+        self.results = list(self.session.results.iter_test_results())
+        self.results.sort(key=lambda result: str(result.test_metadata))
+
+    def test_tests_have_correct_metadata(self):
+        for test, result in zip(self.tests, self.session.results.iter_test_results()):
+            self.assertIs(test.__slash__, result.test_metadata)
+
+    def test_simple_test_address(self):
+        self.assertEqual(self.results[0].test_metadata.address, "{0}:T001.test_method".format(self.filename))
+
+    def test_parameterized_test_address(self):
+        parameterized = set(x.test_metadata.address for x in self.results[1:])
+
+        self.assertEqual(parameterized, set(
+            "{0}:T002.test_parameters(after:c={2},b={3},before:a={1})".format(self.filename, a, c, b)
+            for a, b, c in itertools.product([1, 2], [3, 4], [5, 6])))
+
+_TEST_FILE_TEMPLATE = """
+import slash
+
+class T001(slash.Test):
+    def test_method(self):
+        pass
+
+class T002(slash.Test):
+
+    @slash.parameters.iterate(a=[1, 2])
+    def before(self, a):
+        pass
+
+    @slash.parameters.iterate(b=[3, 4])
+    def test_parameters(self, b):
+        pass
+
+    @slash.parameters.iterate(c=[5, 6])
+    def after(self, c):
+        pass
+"""
diff --git a/tests/test_test_parameters.py b/tests/test_test_parameters.py
new file mode 100755
index 0000000000..36dd86d6e8
--- /dev/null
+++ b/tests/test_test_parameters.py
@@ -0,0 +1,173 @@
+import copy
+import sys
+
+import pytest
+import slash
+from slash._compat import PY2
+
+from .utils import run_tests_assert_success, run_tests_in_session
+from .utils.suite_writer import Suite
+
+
+def test_test_parametrization(test_type):
+    suite = Suite()
+    num_values1 = 3
+    num_values2 = 5
+    test = suite.add_test(type=test_type)
+    test.add_parameter(num_values=num_values1)
+    test.add_parameter(num_values=num_values2)
+    summary = suite.run()
+    assert len(summary.get_all_results_for_test(test)) == num_values1 * num_values2
+
+
+def test_parameters_toggle():
+
+    @slash.parameters.toggle('param')
+    def test_example(param):
+        _set('param', param)
+
+    session = run_tests_assert_success(test_example)
+
+    assert [False, True] == sorted(result.data['param'] for result in session.results)
+
+
+def test_dict_parameter_values():
+
+    values = [{'value': 1}, {'value': 2}]
+
+    @slash.parametrize('param', copy.deepcopy(values))
+    def test_example(param):
+        _set('param', param)
+
+    session = run_tests_assert_success(test_example)
+    assert values == sorted((result.data['param'] for result in session.results), key=values.index)
+
+
+def test_duplicate_parameters():
+
+    values = ["a", "b", "a"]
+
+    @slash.parametrize('param', copy.deepcopy(values))
+    def test_example(param):
+        _set('param', param)
+
+    session = run_tests_assert_success(test_example)
+    assert sorted(values) == sorted(result.data['param'] for result in session.results)
+
+
+
+def test_before_after_parameters(cartesian):
+
+    class Parameterized(slash.Test):
+
+        @slash.parameters.iterate(a=cartesian.before_a.make_set())
+        def before(self, a):  # pylint: disable=arguments-differ
+            _set("before_a", a)
+
+        @slash.parameters.iterate(b=cartesian.b.make_set(), c=cartesian.c.make_set())
+        def test(self, b, c):
+            _set("b", b)
+            _set("c", c)
+
+        @slash.parameters.iterate(d=cartesian.after_d.make_set())
+        def after(self, d):  # pylint: disable=arguments-differ
+            _set("after_d", d)
+
+    session = run_tests_assert_success(Parameterized)
+    assert len(session.results) == len(cartesian)
+    cartesian.check(result.data for result in session.results)
+
+
+@pytest.mark.parametrize('with_override', [True, False])
+def test_before_parameters_inheritence(cartesian, with_override):
+
+    class BaseTest(slash.Test):
+
+        @slash.parameters.iterate(a=cartesian.before_1_a.make_set())
+        def before(self, a):  # pylint: disable=arguments-differ
+            _set("before_1_a", a)
+
+    class DerivedTest(BaseTest):
+
+        @slash.parameters.iterate(a=cartesian.before_2_a.make_set(), b=cartesian.before_2_b.make_set())
+        def before(self, a, b):  # pylint: disable=arguments-differ
+            if with_override:
+                super(DerivedTest, self).before(a=a)
+            else:
+                super(DerivedTest, self).before()
+            _set("before_2_a", a)
+            _set("before_2_b", b)
+
+        def test(self):
+            pass
+
+    session = run_tests_assert_success(DerivedTest)
+    assert len(session.results) == len(cartesian)
+    if with_override:
+        cartesian.assign_all(
+            source_name='before_2_a', target_name='before_1_a')
+    cartesian.check(result.data for result in session.results)
+
+
+def test_parametrization_tuples():
+
+    @slash.parametrize(('a', 'b'), [(1, 2), (11, 22)])
+    @slash.parametrize('c', [3, 33])
+    def test_something(a, b, c):
+        _set("params", (a, b, c))
+
+    session = run_tests_assert_success(test_something)
+    results = [result.data['params'] for result in session.results.iter_test_results()]
+    expected = set([
+        (1, 2, 3), (1, 2, 33), (11, 22, 3), (11, 22, 33)
+        ])
+    assert len(expected) == len(results)
+    assert expected == set(results)
+
+def test_parametrization_tuples_invalid_length():
+
+    with pytest.raises(RuntimeError) as caught:
+        # pylint: disable=unused-argument, unused-variable
+        @slash.parametrize(('a', 'b'), [(1, 2), (1,), (11, 22)])
+        def test_something(a, b, c):
+            pass
+    assert 'Invalid parametrization value' in str(caught.value)
+    assert 'invalid length' in str(caught.value)
+
+
+def test_parametrization_tuples_invalid_type():
+
+    with pytest.raises(RuntimeError) as caught:
+        # pylint: disable=unused-argument, unused-variable
+        @slash.parametrize(('a', 'b'), [(1, 2), 200, (11, 22)])
+        def test_something(a, b, c):
+            pass
+    assert 'Invalid parametrization value' in str(caught.value)
+    assert 'expected sequence' in str(caught.value)
+
+
+def test_parametrizing_function_without_arg(checkpoint):
+
+    @slash.parameters.toggle('param')
+    def test_example():
+        checkpoint()
+
+    session = run_tests_in_session(test_example)
+    assert session.results.global_result.get_errors() == []
+    results = list(session.results.iter_test_results())
+    assert len(results) == 2
+
+    for result in results:
+        [err] = result.get_errors()
+        if PY2 or hasattr(sys, 'pypy_version_info'):
+            assert "test_example() takes no arguments" in str(err)
+        else:
+            assert "unexpected keyword argument 'param'" in str(err)
+
+    assert not checkpoint.called
+
+
+def _set(param, value):
+    data = slash.session.results.current.data
+    assert param not in data
+    data[param] = value
diff --git a/tests/test_traceback_utils.py b/tests/test_traceback_utils.py
new file mode 100755
index 0000000000..520ebcbcc4
--- /dev/null
+++ b/tests/test_traceback_utils.py
@@ -0,0 +1,49 @@
+import sys
+
+import emport
+
+from slash.core.error import Error
+
+
+
+def test_traceback_line_numbers(tmpdir):
+    filename = tmpdir.join('filename.py')
+
+    with filename.open('w') as f:
+        f.write('''from contextlib import contextmanager
+def f():
+    with context():
+        a = 1
+        b = 2
+        g()
+        c = 3
+        d = 4
+
+def g():
+    1/0
+
+@contextmanager
+def context():
+    yield
+''')
+
+    mod = emport.import_file(str(filename))
+    try:
+        mod.f()
+    except ZeroDivisionError:
+        err = Error(exc_info=sys.exc_info())
+    else:
+        assert False, 'did not fail'
+
+    assert err.traceback.frames[-2].lineno == 6
+
+
+def test_is_test_code(suite, suite_test):
+    suite_test.when_run.error()
+    summary = suite.run()
+    [result] = summary.get_all_results_for_test(suite_test)
+    [err] = result.get_errors()
+    assert err.traceback.frames[-1].is_in_test_code()
+
+    error_json = err.traceback.to_list()
+    assert error_json[-1]['is_in_test_code']
diff --git a/tests/test_unified_session_log.py b/tests/test_unified_session_log.py
new file mode 100755
index 0000000000..2dfb39cb44
--- /dev/null
+++ b/tests/test_unified_session_log.py
@@ -0,0 +1,41 @@
+# pylint: disable=redefined-outer-name
+from uuid import uuid4
+
+import pytest
+
+
+def test_unified_session_log_has_test_log(unified_log, log_marker):
+    with open(unified_log) as f:
+        assert log_marker in f.read()
+
+def test_unified_session_log_failure_log_still_in_test_log(unified_run, test_result, log_marker):  # pylint: disable=unused-argument
+    with open(test_result.get_log_path()) as f:
+        assert log_marker in f.read()
+
+def test_warnings_propagation(unified_run):
+    assert len(unified_run.session.warnings) > 0  # pylint: disable=len-as-condition
+
+
+@pytest.fixture  # pylint: disable=unused-argument
+def unified_log(unified_run, tmpdir):  # pylint: disable=unused-argument
+    return str(tmpdir.join('session.log'))
+
+@pytest.fixture
+def test_result(unified_run, suite_test):
+    [returned] = unified_run.get_all_results_for_test(suite_test)
+    return returned
+
+
+@pytest.fixture
+def unified_run(suite, suite_test, tmpdir, config_override, log_marker):
+    config_override('log.unified_session_log', True)
+    config_override('log.root', str(tmpdir))
+    config_override('log.session_subpath', 'session.log')
+    suite_test.append_line('slash.logger.info({0!r})'.format(log_marker))
+    suite_test.append_line('slash.logger.warning({0!r})'.format('warning'))
+    return suite.run()
+
+
+@pytest.fixture
+def log_marker():
+    return 'log_marker_{0}'.format(uuid4())
diff --git a/tests/test_ut_utils.py b/tests/test_ut_utils.py
new file mode 100755
index 0000000000..9de09701be
--- /dev/null
+++ b/tests/test_ut_utils.py
@@ -0,0 +1,37 @@
+# pylint: disable=unused-argument,redefined-outer-name
+import gc
+
+import pytest
+from slash.utils.python import get_arguments
+
+
+def test_gc_marker(gc_marker):
+
+    class Obj(object):
+        pass
+
+    obj = Obj()
+    marker = gc_marker.mark(obj)
+    assert not marker.destroyed
+    del obj
+    gc.collect()
+    assert marker.destroyed
+
+
+def test_get_arguments(func):
+    args = get_arguments(func)
+    assert [a.name for a in args] == ['a', 'b', 'c']
+
+
+
+class SampleClass(object):
+
+    def example_func(self, a, b, c):
+        pass
+
+def example_func(a, b, c):
+    pass
+
+@pytest.fixture(params=[SampleClass.example_func, SampleClass().example_func, example_func])
+def func(request):
+    return request.param
diff --git a/tests/test_utils.py b/tests/test_utils.py
new file mode 100755
index 0000000000..9f23570d8a
--- /dev/null
+++ b/tests/test_utils.py
@@ -0,0 +1,20 @@
+import pytest
+import slash
+import time
+import logbook
+from slash.utils.interactive import notify_if_slow_context
+from slash.reporting.console_reporter import ConsoleReporter
+from slash._compat import StringIO
+
+
+@pytest.mark.parametrize('show_duration', [True, False])
+def test_notify_if_slow_context(show_duration):
+    output_stream = StringIO()
+    reporter = ConsoleReporter(logbook.TRACE, output_stream)
+    with slash.Session(console_stream=output_stream, reporter=reporter):
+        with notify_if_slow_context('message', slow_seconds=0.1, end_message='End', show_duration=show_duration):
+            time.sleep(1)
+    output = output_stream.getvalue()
+    assert 'message' in output
+    assert 'End' in output
+    assert ('took 0:00:01' in output) == show_duration
diff --git a/tests/test_variation_info.py b/tests/test_variation_info.py
new file mode 100755
index 0000000000..8e896f0605
--- /dev/null
+++ b/tests/test_variation_info.py
@@ -0,0 +1,228 @@
+# pylint: disable=unused-variable, unused-argument, redefined-outer-name
+import collections
+import copy
+from uuid import uuid4
+
+import gossip
+import pytest
+import slash
+from munch import Munch
+
+from .utils import make_runnable_tests
+
+
+def test_variation_info_without_params_is_none(results):
+    assert len(results.test_no_params) == 1
+    for res in results.test_no_params:
+        assert res.test_metadata.variation.values == {}
+
+
+def test_variation_info_single_value_id_none(results):
+    assert len(results.test_single_param_fixture) == 1
+    for res in results.test_single_param_fixture:
+        assert res.test_metadata.variation.id is not None
+        assert res.test_metadata.variation.values == {}
+        assert 'fixture' not in res.data['captured_values']
+
+def test_unique_variation_ids(results):
+    all_results = [res for result_set in results.values() for res in result_set]
+    ids = {_freeze(res.test_metadata.variation.id) for res in all_results}
+    assert len(ids) == len(all_results) - 1 # we subtract one because no params and a single fixture have the same id
+    assert None not in ids
+
+
+def test_parametrization_info_availabe_on_test_start(checkpoint):
+    param_value = str(uuid4())
+
+    @gossip.register('slash.test_start')
+    def test_start_hook():
+        assert slash.context.test.__slash__.variation.values['param'] == param_value
+        assert 'fixture' not in slash.context.test.__slash__.variation.values
+        checkpoint()
+
+    @slash.parametrize('param', [param_value])
+    def test_something(param, fixture):
+        pass
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        def fixture():
+            pass
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+
+    assert s.results.is_success(allow_skips=False)
+    assert checkpoint.called
+
+
+
+def test_parametrization_info_values_include_nested_fixture_values():
+
+    value1 = str(uuid4())
+    value2 = str(uuid4())
+
+    @gossip.register('slash.test_start')
+    def test_start_hook():
+        slash.context.result.data['variation_values'] = slash.context.test.__slash__.variation.values.copy()
+
+    @slash.parametrize('param', ['some_value'])
+    def test_something(param, some_fixture):
+        pass
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        @slash.parametrize('value', [value1, value2])
+        def some_fixture(value):
+            pass
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+
+    assert s.results.is_success(allow_skips=False)
+    all_values = []
+    for result in s.results.iter_test_results():
+        values = result.data['variation_values']
+        all_values.append(values['some_fixture.value'])
+
+    assert len(all_values) == 2
+    assert set(all_values) == {value1, value2}
+
+
+def test_variation_identification():
+    value1 = str(uuid4())
+    value2 = str(uuid4())
+
+    @gossip.register('slash.test_start')
+    def test_start_hook():
+        variation = slash.context.test.__slash__.variation
+        slash.context.result.data['variation_info'] = {
+            'id': variation.id.copy(),
+            'values': variation.values.copy(),
+        }
+
+
+    @slash.parametrize('param', ['some_value'])
+    def test_something(param, some_fixture):
+        pass
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        @slash.parametrize('value', [value1])
+        def some_fixture(value):
+            return value2
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+
+    assert s.results.is_success(allow_skips=False)
+    [info] = [result.data['variation_info'] for result in s.results.iter_test_results()]
+    assert info['id']['param'] == 0
+    assert info['values']['param'] == 'some_value'
+    assert info['id']['some_fixture.value'] == 0
+    assert 'some_fixture' not in info['values']
+    assert info['values']['some_fixture.value'] == value1
+
+
+
+
+
+def _freeze(dictionary):
+    return frozenset(dictionary.items())
+
+def test_variation_tuples(results):
+    [res] = results.test_parametrization_tuple
+    values = res.data['captured_values']
+    assert values['x'] == 1
+    assert values['y'] == 2
+
+def test_nested_fixture_ids(results):
+    ids = {res.data['captured_values']['outer_fixture.outer_param'] for res in results.test_nested_fixture}
+    assert ids == {666}
+    for res in results.test_nested_fixture:
+        assert 'outer_fixture' not in res.data['captured_values']
+
+def test_fixture_and_toggle(results):
+    assert len(results.test_fixture_and_toggle) == 2
+
+
+@pytest.fixture
+def results():
+
+    tests = []
+    def include(f):
+        tests.append(f)
+        return f
+
+    @include
+    def test_no_params():
+        pass
+
+    @include
+    def test_single_param_fixture(fixture):
+        _capture_arguments()
+
+    @include
+    def test_nested_fixture(outer_fixture):
+        _capture_arguments()
+
+    @include
+    @slash.parametrize(('x', 'y'), [(1, 2)])
+    def test_parametrization_tuple(x, y):
+        _capture_arguments()
+
+    @include
+    @slash.parameters.toggle('toggle')
+    def test_fixture_and_toggle(fixture, toggle):
+        _capture_arguments()
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        def fixture():
+            return _object1
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        @slash.parametrize('x', [1, 2, 3])
+        def inner_fixture(x):
+            return 'inner{}'.format(x)
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        @slash.parametrize('outer_param', [666])
+        def outer_fixture(inner_fixture, outer_param):
+            return 'outer_{}'.format(inner_fixture)
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(tests))
+    assert s.results.is_success(allow_skips=False)
+
+    returned = collections.defaultdict(list)
+    for res in s.results.iter_test_results():
+        returned[res.test_metadata.function_name].append(res)
+    return Munch(returned)
+
+# helpers ################################################################################
+
+_object1 = object()
+
+
+def _capture_arguments():
+    values = copy.copy(slash.context.result.test_metadata.variation.values)
+    slash.context.result.data['captured_values'] = values
diff --git a/tests/test_warning_capture.py b/tests/test_warning_capture.py
new file mode 100755
index 0000000000..9108880ded
--- /dev/null
+++ b/tests/test_warning_capture.py
@@ -0,0 +1,67 @@
+import warnings
+
+import pytest
+
+import slash
+from slash import Session
+
+from slash.utils.warning_capture import warning_callback_context
+
+def test_warning_capture_context():
+    captured = []
+
+    def callback(*args, **kwargs):
+        captured.append(Warning(*args, **kwargs))
+
+    with warning_callback_context(callback):
+        warnings.warn('some warning')
+
+    assert len(captured) == 1
+    [w] = captured # pylint: disable=unbalanced-tuple-unpacking
+    assert w.args[0].args[0] == 'some warning'
+
+
+def test_session_adds_simple_filter(request):
+    @request.addfinalizer
+    def cleanup():              # pylint: disable=unused-variable
+        warnings.simplefilter('default')
+    warnings.simplefilter('ignore')
+    with Session() as s:
+        warnings.warn('bla')
+
+    assert len(s.warnings.warnings) == 1
+
+def test_session_warning_calls_hook():
+    notified = []
+
+    @slash.hooks.warning_added.register # pylint: disable=no-member
+    def warning_added(warning):         # pylint: disable=unused-variable
+        notified.append(warning)
+
+    with Session() as session:
+        warnings.warn('bla')
+
+    assert list(session.warnings) == notified != []
+
+
+def test_cant_reenter_twice():
+    ctx = warning_callback_context(no_op)
+    with ctx:
+        with pytest.raises(RuntimeError):
+            with ctx:
+                pass
+
+def test_cant_exit_no_enter():
+    ctx = warning_callback_context(no_op)
+    with pytest.raises(RuntimeError):
+        ctx.__exit__(None, None, None)
+
+
+def no_op(*args, **kwargs):     # pylint: disable=unused-argument
+    pass
+
+class Warning(object):
+
+    def __init__(self, *args, **kwargs):
+        self.args = args
+        self.kwargs = kwargs
diff --git a/tests/test_warnings.py b/tests/test_warnings.py
new file mode 100755
index 0000000000..8e43e98ea7
--- /dev/null
+++ b/tests/test_warnings.py
@@ -0,0 +1,105 @@
+# pylint: disable=unused-variable,redefined-outer-name
+import collections
+import warnings
+from contextlib import contextmanager
+from uuid import uuid4
+from vintage import deprecated
+
+import logbook
+import pytest
+
+import slash
+
+from .utils import run_tests_assert_success, without_pyc
+
+
+@pytest.mark.parametrize('reprify', [repr, str])
+def test_str_repr(warning, reprify):
+    assert 'this is a warning' in reprify(warning)
+
+
+def test_location(warning):
+    assert warning.details['filename'] == without_pyc(__file__)
+
+
+def test_to_dict(warning):
+    assert isinstance(warning.to_dict(), dict)
+
+
+def test_warning_added_hook(suite, suite_test):
+
+    captured = []
+
+    @slash.hooks.register
+    def warning_added(warning):
+        captured.append(warning)
+
+    suite_test.append_line('slash.logger.warning("message {}", "here")')
+    suite.run()
+    assert captured
+    [w] = captured # pylint: disable=unbalanced-tuple-unpacking
+    assert w.message == 'message here'
+    assert isinstance(w.lineno, int)
+    assert isinstance(w.filename, str)
+    assert w.lineno
+    assert w.filename
+    assert w.filename.rsplit('/', 1)[-1] == suite_test.file.get_relative_path()
+    warning_type = w.details['type']
+    assert isinstance(warning_type, str)
+    assert warning_type == 'LogbookWarning'
+
+
+def test_native_warnings(message):
+
+    def test_example():
+        with logbook.TestHandler() as handler:
+            warnings.warn(message)
+        assert len(handler.records) == 1
+        assert handler.records[0].message == message
+
+    s = run_tests_assert_success(test_example)
+
+    assert len(s.warnings) == 1
+    [w] = s.warnings
+    assert w.message == message
+
+
+def test_deprecation(message):
+    @deprecated(message=message)
+    def deprecated_func():
+        pass
+    with capturing_native_warnings() as handlers:
+        deprecated_func()
+    assert len(handlers.native_warnings) == 1
+    native_warning = handlers.native_warnings[0]
+    warning_message = native_warning.message.args[0]
+    assert message in warning_message
+
+
+@pytest.fixture
+def message():
+    return 'some message here {}'.format(uuid4())
+
+
+@pytest.fixture
+def warning():
+    class SampleTest(slash.Test):
+
+        def test(self):
+            slash.logger.warning("this is a warning. Param: {0}", 1)
+
+    session = run_tests_assert_success(SampleTest)
+
+    assert len(session.warnings) == 1
+
+    [warning] = session.warnings
+    return warning
+
+
+@contextmanager
+def capturing_native_warnings():
+    with logbook.TestHandler() as log_handler:
+        with warnings.catch_warnings(record=True) as recorded:
+            warnings.simplefilter('always')
+            handlers = collections.namedtuple('Handlers', ('log', 'native_warnings'))(log_handler, recorded)
+            yield handlers
diff --git a/tests/test_xunit_plugin.py b/tests/test_xunit_plugin.py
new file mode 100755
index 0000000000..79d216bbb1
--- /dev/null
+++ b/tests/test_xunit_plugin.py
@@ -0,0 +1,146 @@
+# pylint: disable=redefined-outer-name
+import os
+
+import pytest
+import slash
+
+from xml.etree import ElementTree
+
+
+def test_xunit_plugin(results, xunit_filename): # pylint: disable=unused-argument
+    assert os.path.exists(xunit_filename), 'xunit file not created'
+
+    validate_xml(xunit_filename)
+
+
+def test_session_errors(suite, xunit_filename):
+    # pylint: disable=unused-argument
+
+    @suite.slashconf.append_body
+    def __code__():  # pylint: disable=unused-variable
+        1/0  # pylint: disable=pointless-statement
+
+    for test in suite:
+        # tests are not going to even be loaded
+        test.expect_deselect()
+
+    summary = suite.run(expect_session_errors=True)
+
+    assert 'ZeroDivision' in summary.get_console_output()
+
+
+
+def test_xunit_plugin_test_details(suite, suite_test, xunit_filename, details):
+    for key, value in details.items():
+        suite_test.append_line('slash.context.result.set_test_detail({0!r}, {1!r})'.format(key, value))
+
+    suite.run()
+    testcase_xml = _get_testcase_xml(suite_test, xunit_filename)
+
+    saved_details = dict((d.attrib['name'], d.attrib['value']) for d in testcase_xml.findall('detail'))
+    assert saved_details
+
+
+@pytest.mark.parametrize('errtype', ['error', 'failure'])
+def test_xunit_plugin_add_failure_error(suite, suite_test, xunit_filename, errtype):
+    num_errors = 3
+    for _ in range(num_errors):
+        suite_test.append_line('slash.add_{0}("some message")'.format(errtype))
+    if errtype == 'error':
+        suite_test.expect_error()
+    else:
+        suite_test.expect_failure()
+
+    suite.run()
+    testcase_xml = _get_testcase_xml(suite_test, xunit_filename)
+    errors = testcase_xml.findall(errtype)
+    assert len(errors) == num_errors
+    for error in errors:
+        assert error.attrib['message'] == 'some message'
+        assert error.attrib['type'] == errtype
+    assert errors
+
+
+
+def _get_testcase_xml(suite_test, filename):
+    with open(filename) as f:
+        xml = ElementTree.parse(f)
+    match = [testcase for testcase in list(xml.getroot()) if testcase.get('name').split('_')[-1] == suite_test.id]
+    assert len(match) == 1
+    return match[0]
+
+
+@pytest.fixture
+def details():
+    return {'detail1': 'value1', 'detail2': 'value2'}
+
+
+@pytest.fixture  # pylint: disable=unused-argument
+def results(suite, suite_test, test_event, xunit_filename): # pylint: disable=unused-argument
+    test_event(suite_test)
+    summary = suite.run()
+    assert 'Traceback' not in summary.get_console_output()
+
+@pytest.fixture(params=['normal', 'skip_decorator_without_reason', 'skip_without_reason', 'skip_with_reason',
+                        'error', 'failure', 'add_error', 'add_failure'])
+def test_event(request):
+    flavor = request.param
+
+    def func(test):
+        if flavor != 'normal':
+            if flavor == 'skip_without_reason':
+                test.when_run.skip(with_reason=False)
+            elif flavor == 'skip_decorator_without_reason':
+                test.when_run.skip(with_reason=False, decorator=True)
+            elif flavor == 'skip_with_reason':
+                test.when_run.skip(with_reason=True)
+            elif flavor == 'error':
+                test.when_run.error()
+            elif flavor == 'failure':
+                test.when_run.fail()
+            elif flavor == 'add_error':
+                test.append_line('slash.add_error("error")')
+                test.expect_error()
+            elif flavor == 'add_failure':
+                test.append_line('slash.add_failure("failure")')
+                test.expect_failure()
+            else:
+                raise NotImplementedError()  # pragma: no cover
+    return func
+
+
+@pytest.fixture  # pylint: disable=unused-argument
+def xunit_filename(tmpdir, request, config_override):  # pylint: disable=unused-argument
+    xunit_filename = str(tmpdir.join('xunit.xml'))
+    slash.plugins.manager.activate('xunit')
+
+    slash.config.root.plugin_config.xunit.filename = xunit_filename
+
+    @request.addfinalizer
+    def deactivate():  # pylint: disable=unused-variable
+        slash.plugins.manager.deactivate('xunit')
+
+    return xunit_filename
+
+
+def validate_xml(xml_filename):
+    with open(xml_filename) as f:
+        etree = ElementTree.parse(f)
+
+    root = etree.getroot()
+    assert root.tag == 'testsuite'
+
+    _validate_counters(root)
+
+    for child in list(root):
+        assert child.tag == 'testcase'
+        assert child.get('name')
+        assert child.get('time')
+
+        for subchild in child.getchildren():
+            assert subchild.tag in ['skipped', 'error', 'failure']
+
+
+def _validate_counters(element):
+    for number in ['errors', 'failures', 'skipped']:
+        _ = int(element.get(number))
diff --git a/tests/test_yield_fixture.py b/tests/test_yield_fixture.py
new file mode 100755
index 0000000000..b709d76819
--- /dev/null
+++ b/tests/test_yield_fixture.py
@@ -0,0 +1,84 @@
+# pylint: disable=unused-argument, unused-variable
+from uuid import uuid4
+
+import slash
+
+from .conftest import Checkpoint
+from .utils import make_runnable_tests
+
+
+def test_yield_fixture(yield_fixture_decorator):
+    iterations = [uuid4() for i in range(3)]
+    start_checkpoints, end_checkpoints = [
+        {iteration: Checkpoint() for iteration in iterations}
+        for i in range(2)]
+    value = uuid4()
+    inner_fixture_value = uuid4()
+
+    with slash.Session() as s:
+
+        @s.fixture_store.add_fixture
+        @slash.fixture
+        def other_fixture():
+            return inner_fixture_value
+
+
+        @s.fixture_store.add_fixture
+        @slash.parametrize('iteration', list(iterations))
+        @yield_fixture_decorator
+        def fixture(iteration, other_fixture):
+            assert other_fixture == inner_fixture_value
+            start_checkpoints[iteration]()
+            yield value
+            end_checkpoints[iteration]()
+
+        def test_something(fixture):
+            assert fixture == value
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+        assert s.results.is_success(allow_skips=False)
+
+
+def test_yield_fixture_with_this_argument(yield_fixture_decorator):
+    iterations = [uuid4() for i in range(3)]
+    value = uuid4()
+
+    with slash.Session() as s:
+
+
+        @s.fixture_store.add_fixture
+        @slash.parametrize('iteration', list(iterations))
+        @yield_fixture_decorator
+        def fixture(this, iteration):
+            yield value
+
+        def test_something(fixture):
+            assert fixture == value
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
+
+
+def test_yield_fixture_with_scope_argument(yield_fixture_decorator):
+    value = str(uuid4())
+
+    with slash.Session() as s:
+
+
+        @s.fixture_store.add_fixture
+        @yield_fixture_decorator(scope='session')
+        def fixture():
+            yield value
+
+        def test_something(fixture):
+            assert fixture == value
+
+        s.fixture_store.resolve()
+
+        with s.get_started_context():
+            slash.runner.run_tests(make_runnable_tests(test_something))
diff --git a/tests/utils/__init__.py b/tests/utils/__init__.py
new file mode 100755
index 0000000000..2cc15fb12d
--- /dev/null
+++ b/tests/utils/__init__.py
@@ -0,0 +1,170 @@
+from types import FunctionType
+from contextlib import contextmanager
+import itertools
+import platform
+import shutil
+import sys
+import tempfile
+
+import forge
+import logbook
+from logbook.compat import LoggingHandler
+import pytest
+
+import gossip
+import slash
+from slash._compat import PY2, PYPY
+from slash.conf import config
+from slash._compat import ExitStack
+from slash.core.runnable_test import RunnableTest
+from slash.core.test import TestTestFactory
+from slash.core.function_test import FunctionTestFactory
+from slash.plugins import PluginInterface
+
+import unittest
+
+
+_logger = logbook.Logger(__name__)
+
+
+class TestCase(unittest.TestCase):
+
+    def setUp(self):
+        super(TestCase, self).setUp()
+        self._handler = LoggingHandler()
+        self._handler.push_application()
+        self.addCleanup(self._handler.pop_application)
+        gossip.get_group('slash').set_exception_policy(gossip.RaiseImmediately())
+        self.override_config("log.console_level", 10000)  # silence console in tests
+
+    def override_config(self, path, value):
+        self.addCleanup(config.assign_path, path, config.get_path(path))
+        config.assign_path(path, value)
+
+    def get_new_path(self):
+        returned = tempfile.mkdtemp()
+        self.addCleanup(shutil.rmtree, returned)
+        return returned
+
+    _forge = None
+
+    @property
+    def forge(self):
+        if self._forge is None:
+            self._forge = forge.Forge()
+        return self._forge
+    _events = None
+
+    @property
+    def events(self):
+        if self._events is None:
+            self._events = self.forge.create_wildcard_mock()
+        return self._events
+
+    def tearDown(self):
+        if self._forge is not None:
+            self._forge.restore_all_replacements()
+            self._forge.verify()
+        super(TestCase, self).tearDown()
+
+
+class NullFile(object):
+
+    def write(self, s):
+        pass
+
+    def isatty(self):
+        return False
+
+    def flush(self):
+        pass
+
+
+class CustomException(Exception):
+
+    @classmethod
+    def do_raise(cls):
+        raise cls("Custom exception")
+
+
+class NamedPlugin(PluginInterface):
+
+    def get_name(self):
+        return type(self).__name__
+
+
+def no_op(*args, **kwargs):  # pylint: disable=unused-argument
+    pass
+
+
+def run_tests_in_session(test_class_path_or_iterator, session=None):
+    with ExitStack() as stack:
+        if session is None:
+            session = slash.Session()
+            stack.enter_context(session)
+
+        test_class_path_or_iterator = make_runnable_tests(test_class_path_or_iterator)
+
+        with session.get_started_context():
+            slash.runner.run_tests(test_class_path_or_iterator)
+    for result in session.results.iter_test_results():
+        for err in itertools.chain(result.get_errors(), result.get_failures(), result.get_skips()):
+            _logger.debug("Unsuccessful result: {0}", err)
+    return session
+run_tests_in_session.__test__ = False
+
+
+def run_tests_assert_success(test_class_path_or_iterator, session=None):
+    session = run_tests_in_session(test_class_path_or_iterator, session=session)
+    assert session.results.is_success(), "Run did not succeed"
+    return session
+
+run_tests_assert_success.__test__ = False
+
+def make_runnable_tests(thing):
+    return slash.loader.Loader().get_runnables(thing)
+
+
+def resolve_and_run(thing):
+    slash.context.session.fixture_store.resolve()
+    with slash.context.session.get_started_context():
+        tests = make_runnable_tests(thing)
+        slash.runner.run_tests(tests)
+
+    return list(slash.context.session.results.iter_test_results())
+
+
+def without_pyc(filename):
+    if filename.endswith('.pyc'):
+        return filename[:-1]
+    return filename
+
+
+def raises_maybe(exc, cond):
+    @contextmanager
+    def noop():
+        yield
+
+    if cond:
+        return pytest.raises(exc)
+    return noop()
+
+_noop = lambda f: f
+
+if PY2:
+    skip_on_py2 = pytest.mark.skip
+else:
+    skip_on_py2 = _noop
+
+if PYPY:
+    skip_on_pypy = pytest.mark.skip
+else:
+    skip_on_pypy = _noop
+
+
+class Unprintable(object):
+
+    def __repr__(self):
+        1/0                     # pylint: disable=pointless-statement
+
+    __str__ = __repr__
diff --git a/tests/utils/cartesian.py b/tests/utils/cartesian.py
new file mode 100755
index 0000000000..7b0b3f31bc
--- /dev/null
+++ b/tests/utils/cartesian.py
@@ -0,0 +1,58 @@
+import itertools
+
+from slash._compat import itervalues
+
+
+class Cartesian(object):
+
+    def __init__(self):
+        super(Cartesian, self).__init__()
+        self.sets = {}
+        self._assigns = []
+
+    def assign_all(self, source_name, target_name):
+        """
+        For every expected combination, assigns one key from the other
+        """
+        self._assigns.append((source_name, target_name))
+
+    def __getattr__(self, attr):
+        if attr.startswith("_"):
+            raise AttributeError(attr)
+        return SetMaker(self, attr)
+
+    def __len__(self):
+        if not self.sets:
+            return 0
+
+        returned = 1
+        for x in itervalues(self.sets):
+            returned *= len(x)
+        return returned
+
+    def check(self, iterator):
+        names = list(self.sets)
+        sets = [self.sets[name] for name in names]
+        expected = sorted((self._build_combination(names, combination) for combination in itertools.product(*sets)), key=lambda d: sorted(d.items()))
+        got = sorted(iterator, key=lambda d: sorted(d.items()))
+        assert got == expected
+
+    def _build_combination(self, names, combination):
+        returned = {}
+        for name, value in zip(names, combination):
+            returned[name] = value
+        for assign_source, assign_target in self._assigns:
+            returned[assign_target] = returned[assign_source]
+        return returned
+
+class SetMaker(object):
+
+    def __init__(self, cartesian, name):
+        super(SetMaker, self).__init__()
+        self.cartesian = cartesian
+        self.name = name
+
+    def make_set(self, size=3):
+        assert self.name not in self.cartesian.sets
+        returned = self.cartesian.sets[self.name] = ["{0}{1}".format(self.name, i) for i in range(size)]
+        return returned
diff --git a/tests/utils/code_formatter.py b/tests/utils/code_formatter.py
new file mode 100755
index 0000000000..30d951cc2a
--- /dev/null
+++ b/tests/utils/code_formatter.py
@@ -0,0 +1,6 @@
+from slash.utils.formatter import Formatter
+
+class CodeFormatter(Formatter):
+
+    def __init__(self, stream):
+        super(CodeFormatter, self).__init__(stream, ' ' * 4)
diff --git a/tests/utils/event_recorder.py b/tests/utils/event_recorder.py
new file mode 100755
index 0000000000..5a179ce6f4
--- /dev/null
+++ b/tests/utils/event_recorder.py
@@ -0,0 +1,18 @@
+class EventRecorder(object):
+    def __init__(self):
+        super(EventRecorder, self).__init__()
+        self.events = {}
+        self.timestamp = 0
+    def record(self, event_name, **kwargs):
+        assert event_name not in self.events, "Event {0} already recorded".format(event_name)
+        self.timestamp += 1
+        self.events[event_name] = Event(self.timestamp, kwargs)
+    def __getitem__(self, event_name):
+        return self.events[event_name]
+
+class Event(object):
+    happened = True
+    def __init__(self, timestamp, info):
+        super(Event, self).__init__()
+        self.timestamp = timestamp
+        self.info = info
diff --git a/tests/utils/garbage_collection.py b/tests/utils/garbage_collection.py
new file mode 100755
index 0000000000..3584ec8921
--- /dev/null
+++ b/tests/utils/garbage_collection.py
@@ -0,0 +1,27 @@
+import weakref
+
+class GarbageCollectionMarker(object):
+
+    def mark(self, obj):
+        marker = _Marker(obj)
+        obj.__marker__ = _MarkerAnchor(marker)
+        return marker
+
+
+class _Marker(object):
+
+    destroyed = False
+
+    def __init__(self, obj):
+        super(_Marker, self).__init__()
+        self._weakref = weakref.proxy(obj)
+
+
+class _MarkerAnchor(object):
+
+    def __init__(self, marker):
+        super(_MarkerAnchor, self).__init__()
+        self._marker = marker
+
+    def __del__(self):
+        self._marker.destroyed = True
diff --git a/tests/utils/suite_writer/__init__.py b/tests/utils/suite_writer/__init__.py
new file mode 100755
index 0000000000..4edd8b9638
--- /dev/null
+++ b/tests/utils/suite_writer/__init__.py
@@ -0,0 +1 @@
+from .suite import Suite
diff --git a/tests/utils/suite_writer/code_element.py b/tests/utils/suite_writer/code_element.py
new file mode 100755
index 0000000000..2a7e6b5086
--- /dev/null
+++ b/tests/utils/suite_writer/code_element.py
@@ -0,0 +1,58 @@
+import py.code  # pylint: disable=no-name-in-module, import-error
+
+from slash._compat import StringIO
+from .element import Element
+from ..code_formatter import CodeFormatter
+
+from contextlib import contextmanager
+
+
+class CodeElement(Element):
+
+    def __init__(self, suite):
+        super(CodeElement, self).__init__(suite)
+        self.suite = suite
+        self._body = []
+
+    def append_line(self, line):
+        self._body.append(line)
+
+    def prepend_line(self, line):
+        self._body.insert(0, line)
+
+    def write(self, code_formatter):
+        with self._body_context(code_formatter):
+            self._write_body(code_formatter)
+
+    def append_body(self, code_element):
+        """An easier way to write multiline injected code:
+
+        @code_element.append_body
+        def __code__():
+            some_code_line()
+            for i in range(20):
+                some_other_code()
+        """
+        source_lines = str(py.code.Code(code_element).source()).splitlines()  # pylint: disable=no-member
+        assert source_lines[0].startswith('@')
+        assert source_lines[1].startswith('def ')
+        assert source_lines[2][0].isspace()
+        for line in str(py.code.Source('\n'.join(source_lines[2:])).deindent()).splitlines():  # pylint: disable=no-member
+            self._body.append(line)
+
+    include = append_body
+
+    @contextmanager  # pylint: disable=unused-argument
+    def _body_context(self, code_formatter):  # pylint: disable=unused-argument
+        yield
+
+    def _write_body(self, code_formatter):
+        for line in self._body:
+            code_formatter.writeln(line)
+
+    @property
+    def source(self):
+        buff = StringIO()
+        f = CodeFormatter(buff)
+        self.write(f)
+        return buff.getvalue()
diff --git a/tests/utils/suite_writer/element.py b/tests/utils/suite_writer/element.py
new file mode 100755
index 0000000000..38ed1ae5c6
--- /dev/null
+++ b/tests/utils/suite_writer/element.py
@@ -0,0 +1,14 @@
+import itertools
+
+_id_allocator = itertools.count()
+
+
+class Element(object):
+
+    def __init__(self, suite):
+        super(Element, self).__init__()
+        self.suite = suite
+        self.id = '{0:05}'.format(next(_id_allocator))
+
+    def __repr__(self):
+        return '<{0} {1}>'.format(type(self).__name__, self.id)
diff --git a/tests/utils/suite_writer/file.py b/tests/utils/suite_writer/file.py
new file mode 100755
index 0000000000..4387feb016
--- /dev/null
+++ b/tests/utils/suite_writer/file.py
@@ -0,0 +1,82 @@
+import os
+from uuid import uuid4
+import itertools
+from contextlib import contextmanager
+
+from .code_element import CodeElement
+from .fixture import Fixture
+from .generator_fixture import GeneratorFixture
+from .nonmethod_test import NonMethodTest
+from .test_class import Class
+from .test_container import TestContainer
+
+
+class File(TestContainer, CodeElement):
+
+    def __init__(self, suite, relpath=None):
+        super(File, self).__init__(suite)
+        self._classes = []
+        self._fixtures = []
+
+        if relpath is None:
+            relpath = 'test_{0}.py'.format(self.id)
+        self._relpath = relpath
+
+    @property
+    def name(self):
+        return os.path.basename(self._relpath)
+
+    def add_hook_event(self, hook_name, extra_args=(), evt_name='evt'):
+        self.append_line('@slash.hooks.{0}.register'.format(hook_name))
+        event_code = '{0}_{1}'.format(evt_name, uuid4())
+        self.append_line('def _hook():')
+        self.append_line('    __ut__.events.add({0!r}, {1})'.format(
+            event_code, ', '.join(extra_args)))
+        return event_code
+
+    @property
+    def classes(self):
+        return list(self._classes)
+
+    def add_fixture(self, **kw):
+        returned = Fixture(self.suite, self, **kw)
+        self._fixtures.append(returned)
+        return returned
+
+    def add_generator_fixture(self):
+        returned = GeneratorFixture(self.suite, self)
+        self._fixtures.append(returned)
+        return returned
+
+    def get_relative_path(self):
+        return self._relpath
+
+    def add_class(self):
+        cls = Class(self.suite, self)
+        self._classes.append(cls)
+        return cls
+
+    def get_last_class(self):
+        if not self._classes:
+            return None
+        return self._classes[-1]
+
+    def add_function_test(self):
+        returned = NonMethodTest(self.suite, self)
+        self._tests.append(returned)
+        self.suite.notify_test_added(returned)
+        return returned
+
+    @contextmanager
+    def _body_context(self, code_formatter):
+        with super(File, self)._body_context(code_formatter):
+            if self.suite.debug_info:
+                code_formatter.writeln('import __ut__')
+            code_formatter.writeln('import slash')
+            code_formatter.writeln()
+            yield None
+
+    def _write_body(self, code_formatter):
+        super(File, self)._write_body(code_formatter)
+        for thing in itertools.chain(self._classes, self._tests, self._fixtures):
+            thing.write(code_formatter)
diff --git a/tests/utils/suite_writer/fixture.py b/tests/utils/suite_writer/fixture.py
new file mode 100755
index 0000000000..a33ea7e420
--- /dev/null
+++ b/tests/utils/suite_writer/fixture.py
@@ -0,0 +1,76 @@
+from uuid import uuid4
+import itertools
+
+from .function import Function
+
+
+class Fixture(Function):
+
+    def __init__(self, suite, file, scope=None, autouse=False, name=None):
+        if name is None:
+            name = 'fx_{}'.format(str(uuid4()).replace('-', '')[:6])
+        super(Fixture, self).__init__(suite, name=name)
+        self.file = file
+        self.scope = scope
+        self.autouse = autouse
+
+    def is_generator_fixture(self):
+        return False
+
+    def add_cleanup(self, **kwargs):
+        return self.add_deferred_event('this.add_cleanup', name='fixture_cleanup', **kwargs)
+
+    def _write_decorators(self, code_formatter):
+        self._write_fixture_decorator(code_formatter)
+        super(Fixture, self)._write_decorators(code_formatter)
+
+    def _write_prologue(self, code_formatter):
+        if not self.suite.debug_info:
+            return
+
+        self._write_event(code_formatter, 'fixture_start')
+        code_formatter.writeln(
+            '__ut__.notify_fixture_start({0!r}, {1})'.format(self.id, self.get_value_string()))
+        code_formatter.writeln('@this.add_cleanup')
+        code_formatter.writeln('def cleanup():')
+        with code_formatter.indented():
+            self._write_event(code_formatter, 'fixture_end')
+            code_formatter.writeln(
+                '__ut__.notify_fixture_end({0!r})'.format(self.id))
+
+        super(Fixture, self)._write_prologue(code_formatter)
+
+    def _write_return(self, code_formatter):
+        code_formatter.writeln(
+            'return {0}'.format(self.get_value_string()))
+
+    def _write_fixture_decorator(self, code_formatter):
+
+        params = {}
+        if self.scope is not None:
+            params['scope'] = self.scope
+        if self.autouse:
+            params['autouse'] = True
+
+        code_formatter.write('@slash.fixture')
+        if params:
+            code_formatter.write('({0})'.format(', '.join(
+                '{0}={1!r}'.format(k, v) for k, v in params.items())))
+        code_formatter.writeln()
+
+    def get_value_string(self):
+        returned = '{{"value": {0!r}, "params": {{'.format(self.name)
+
+        for name, param in itertools.chain(
+                ((p.name, p) for p in self._parameters),
+                ((alias or f.name, f) for alias, f, _ in self._fixtures),
+        ):
+            returned += '{0!r}: {1},'.format(param.id, name)
+        returned += '} }'
+        return returned
+
+    def _get_argument_strings(self):
+        return itertools.chain(['this'], super(Fixture, self)._get_argument_strings())
+
+    def __repr__(self):
+        return '<Fixture {0}>'.format(self.name)
diff --git a/tests/utils/suite_writer/function.py b/tests/utils/suite_writer/function.py
new file mode 100755
index 0000000000..54df110d6b
--- /dev/null
+++ b/tests/utils/suite_writer/function.py
@@ -0,0 +1,168 @@
+import collections
+import itertools
+from contextlib import contextmanager
+from uuid import uuid4
+from .code_element import CodeElement
+from .parameter import Parameter
+
+
+_FixtureSpec = collections.namedtuple('_FixtureSpec', ['alias_name', 'fixture', 'alias_with_attribute'])
+
+
+class Function(CodeElement):
+
+    def __init__(self, suite, name=None):
+        super(Function, self).__init__(suite)
+        self._name = name
+        self._decorators = []
+        self._parameters = []
+        self._additional_parameter_string = ""
+        self._fixtures = []
+        self._events = []
+        self._deferred_events = []
+
+    def add_parameter_string(self, s):
+        self._additional_parameter_string += s
+
+    def add_decorator(self, decorator_string):
+        self._decorators.append(decorator_string)
+
+    def get_fixtures(self):
+        return [f for _, f, _ in self._fixtures]
+
+    def get_parameters(self):
+        return self._parameters
+
+    def add_parameter(self, *args, **kwargs):
+        returned = Parameter(self.suite, *args, **kwargs)
+        self._parameters.append(returned)
+        return returned
+
+    def depend_on_fixture(self, f, alias=False, alias_with_attribute=False):
+        alias_name = 'alias_{}'.format(str(uuid4()).replace('-', '')) if alias else None
+        self._fixtures.append(_FixtureSpec(alias_name, f, alias_with_attribute))
+        return f
+
+    def _write_event(self, code_formatter, eventcode):
+        if self.suite.debug_info:
+            code_formatter.writeln(
+                '__ut__.events.add({0!r}, {1!r})'.format(
+                    eventcode, self.id))
+
+    def add_deferred_event(self, decorator=None, name='deferred', extra_code=(), adder=None):
+        event = '{0}_{1}'.format(name, uuid4())
+        self._deferred_events.append({
+            'decorator': decorator, 'event': event, 'extra_code': extra_code, 'adder': adder})
+        return event
+
+    def add_event(self, name='event'):
+        event = '{0}_{1}'.format(name, uuid4())
+        self._events.append(event)
+        return (event, self.id)
+
+    @contextmanager
+    def _body_context(self, code_formatter):
+        self._write_decorators(code_formatter)
+        code_formatter.writeln('def {0}({1}):'.format(
+            self._get_function_name(),
+            self._get_parameter_string()))
+
+        with code_formatter.indented():
+            if not self.suite.debug_info:
+                code_formatter.writeln('pass')
+            self._write_parameter_values(code_formatter)
+            self._write_immediate_events(code_formatter)
+            self._write_deferred_events(code_formatter)
+            self._write_prologue(code_formatter)
+            yield
+            self._write_epilogue(code_formatter)
+            self._write_return(code_formatter)
+        code_formatter.writeln()
+
+    def _get_parameter_string(self):
+        returned = ', '.join(self._get_argument_strings())
+        if returned and self._additional_parameter_string:
+            returned += ', '
+        returned += self._additional_parameter_string
+        return returned
+
+    def _write_prologue(self, code_formatter):
+        pass
+
+    def _write_epilogue(self, code_formatter):
+        pass
+
+    def _write_immediate_events(self, code_formatter):
+        for event in self._events:
+            self._write_event(code_formatter, event)
+
+    def _write_deferred_events(self, code_formatter):
+        if not self.suite.debug_info:
+            return
+        for index, deferred in enumerate(self._deferred_events, 1):
+            deferred_func_name = '_deferred{0}'.format(index)
+            adder = deferred['adder']
+            if adder is None:
+                code_formatter.writeln('@{0[decorator]}'.format(deferred))
+            code_formatter.writeln('def {0}():'.format(deferred_func_name))
+            with code_formatter.indented():
+                code_formatter.writeln('__ut__.events.add({0[event]!r})'.format(deferred))
+                for line in deferred['extra_code']:
+                    code_formatter.writeln(line)
+            if adder is not None:
+                code_formatter.write(adder.format(deferred_func_name))
+            code_formatter.writeln()
+
+    def _write_return(self, code_formatter):
+        pass
+
+    def _write_decorators(self, code_formatter):
+        for d in self._decorators:
+            code_formatter.write('@')
+            code_formatter.writeln(d)
+        for p in self._parameters:
+            p.write_decorator(code_formatter)
+
+    def _write_parameter_values(self, code_formatter):
+        if (not self.suite.debug_info) and (not self.suite.is_parallel):
+            return
+
+        for p in self._iter_notify_parameters():
+            if self.suite.is_parallel:
+                code_formatter.writeln("slash.context.result.data.setdefault('param_values', {{}})[{0!r}] = {1}".format(
+                    p.id, p.name))
+            else:
+                code_formatter.writeln('__ut__.notify_parameter_value({0!r}, {1})'.format(
+                    p.id, p.name))
+
+    def _iter_notify_parameters(self):
+        return itertools.chain(
+            self._parameters,
+            (f for _, f, _ in self._fixtures if f.is_generator_fixture()))
+
+    def _get_function_name(self):
+        if self._name is None:
+            raise NotImplementedError()  # pragma: no cover
+        return self._name
+
+    @property
+    def name(self):
+        return self._get_function_name()
+
+    def _get_argument_strings(self):
+        for p in self._parameters:
+            yield p.name
+        for alias, f, alias_with_attribute in self._fixtures:
+            if alias is not None:
+                if alias_with_attribute:
+                    yield '{}: slash.use.{}'.format(alias, f.name)
+                else:
+                    yield '{}: slash.use({!r})'.format(alias, f.name)
+            else:
+                yield f.name
+
+
+class Method(Function):
+
+    def _get_argument_strings(self):
+        return itertools.chain(['self'], super(Method, self)._get_argument_strings())
diff --git a/tests/utils/suite_writer/generator_fixture.py b/tests/utils/suite_writer/generator_fixture.py
new file mode 100755
index 0000000000..a12abd6b4b
--- /dev/null
+++ b/tests/utils/suite_writer/generator_fixture.py
@@ -0,0 +1,32 @@
+from uuid import uuid4
+
+from .function import Function
+
+
+class GeneratorFixture(Function):
+
+    def __init__(self, suite, file, num_values=3):
+        super(GeneratorFixture, self).__init__(suite)
+        self.file = file
+        self.values = [str(uuid4()) for _ in range(num_values)]
+
+    def is_generator_fixture(self):
+        return True
+
+    def _write_decorators(self, code_formatter):
+        code_formatter.writeln('@slash.generator_fixture')
+        super(GeneratorFixture, self)._write_decorators(code_formatter)
+
+    def _get_function_name(self):
+        return 'fx_{0}'.format(self.id)
+
+    def _write_return(self, code_formatter):
+        for value in self.values:
+            code_formatter.writeln(
+                'yield {0!r}'.format(value))
+
+    def _get_argument_strings(self):
+        return []
+
+    def __repr__(self):
+        return '<Generator Fixture {0}>'.format(self.name)
diff --git a/tests/utils/suite_writer/method_test.py b/tests/utils/suite_writer/method_test.py
new file mode 100755
index 0000000000..d4208c205f
--- /dev/null
+++ b/tests/utils/suite_writer/method_test.py
@@ -0,0 +1,16 @@
+import itertools
+
+from .test import Test
+
+
+class MethodTest(Test):  # pylint: disable=abstract-method
+
+    def __init__(self, suite, cls):
+        super(MethodTest, self).__init__(suite, cls.file)
+        self.cls = cls
+
+    def is_method_test(self):
+        return True
+
+    def _get_argument_strings(self):
+        return itertools.chain(['self'], super(MethodTest, self)._get_argument_strings())
diff --git a/tests/utils/suite_writer/nonmethod_test.py b/tests/utils/suite_writer/nonmethod_test.py
new file mode 100755
index 0000000000..5f289b30c9
--- /dev/null
+++ b/tests/utils/suite_writer/nonmethod_test.py
@@ -0,0 +1,12 @@
+from .test import Test
+
+
+class NonMethodTest(Test):  # pylint: disable=abstract-method
+
+    cls = None
+
+    def __init__(self, suite, file):  # pylint: disable=useless-super-delegation
+        super(NonMethodTest, self).__init__(suite, file)
+
+    def is_method_test(self):
+        return False
diff --git a/tests/utils/suite_writer/parameter.py b/tests/utils/suite_writer/parameter.py
new file mode 100755
index 0000000000..1fbe491567
--- /dev/null
+++ b/tests/utils/suite_writer/parameter.py
@@ -0,0 +1,17 @@
+from uuid import uuid4
+
+from .element import Element
+
+
+class Parameter(Element):
+
+    def __init__(self, suite, num_values=3, values=None):
+        super(Parameter, self).__init__(suite)
+        self.name = 'param_{0}'.format(self.id)
+        if values is None:
+            values = [str(uuid4()) for _ in range(num_values)]
+        self.values = values
+
+    def write_decorator(self, code_formatter):
+        code_formatter.writeln('@slash.parametrize({0!r}, {1!r})'.format(
+            self.name, self.values))
diff --git a/tests/utils/suite_writer/slash_run_result.py b/tests/utils/suite_writer/slash_run_result.py
new file mode 100755
index 0000000000..9cb48f4329
--- /dev/null
+++ b/tests/utils/suite_writer/slash_run_result.py
@@ -0,0 +1,125 @@
+import copy
+import itertools
+
+import logbook
+
+import slash
+
+from .validation import get_test_id_from_test_address
+
+_timestamps = itertools.count()
+
+_logger = logbook.Logger(__name__)
+
+
+class SlashRunResult(object):
+
+    _console_output = None
+
+    def __init__(self, report_stream):
+        super(SlashRunResult, self).__init__()
+        self._report_stream = report_stream
+        self.exit_code = 0
+        self.error_message = None
+        self.session = None
+        self.tracker = Tracker()
+
+    @property
+    def events(self):
+        return self.tracker.events
+
+    def ok(self):
+        return self.session.results.is_success()
+
+    def get_console_output(self):
+        if self._console_output is None:
+            self._console_output = self._report_stream.getvalue()
+        return self._console_output
+
+    def get_all_results_for_test(self, test):
+        returned = []
+        for result in self.session.results:
+            if get_test_id_from_test_address(result.test_metadata.address) == test.id:
+                returned.append(result)
+        return returned
+
+    def __getitem__(self, test):
+        matching = self.get_all_results_for_test(test)
+        assert len(matching) == 1
+        return matching[0]
+
+    def __repr__(self):
+        return '<Summary ({0})>'.format(self.session.results)
+
+
+class Tracker(object):
+
+    def __init__(self):
+        super(Tracker, self).__init__()
+        self.events = Events()
+        self.active_fixtures = {}
+
+    def notify_fixture_start(self, f_id, value):
+        _logger.debug('started fixture {0}', f_id)
+        assert f_id not in self.active_fixtures
+        self.active_fixtures[f_id] = value
+
+    def notify_fixture_end(self, f_id):
+        _logger.debug('ended fixture {0}', f_id)
+        self.active_fixtures.pop(f_id)
+
+    def notify_parameter_value(self, p_id, value):
+        slash.context.result.data.setdefault('param_values', {})[p_id] = value
+
+    def get_fixture_memento(self):
+        return copy.deepcopy(self.active_fixtures)
+
+
+class Event(object):
+
+    def __init__(self, args):
+        super(Event, self).__init__()
+        self.args = args
+        self.timestamp = next(_timestamps)
+
+    def is_before(self, other_event):
+        return self.timestamp < other_event.timestamp
+
+    def __repr__(self):
+        return '<Event #{0}: {1}>'.format(self.timestamp, self.args)
+
+
+class Events(object):
+
+    def __init__(self):
+        super(Events, self).__init__()
+        self._events = []
+        self._events_by_args = {}
+
+    def add(self, *args):
+        self._events.append(Event(args))
+        self._events_by_args[args] = self._events[-1]
+
+    def assert_consecutive(self, evts):
+        seq = [self[x] for x in evts]
+        timestamps = [e.timestamp for e in seq]
+        begin = seq[0].timestamp
+        assert timestamps == [begin + i for i in range(len(seq))]
+
+    def __getitem__(self, args):
+        return self._events_by_args[self._normalize_key(args)]
+
+    def __contains__(self, args):
+        return self._normalize_key(args) in self._events_by_args
+        # return self.has_event(*args)
+
+    def has_event(self, *args):
+        return args in self
+
+    def _normalize_key(self, args):
+        if not isinstance(args, tuple):
+            args = (args,)
+        return args
+
+    def __repr__(self):
+        return '<Events>'
diff --git a/tests/utils/suite_writer/suite.py b/tests/utils/suite_writer/suite.py
new file mode 100755
index 0000000000..d870a291d1
--- /dev/null
+++ b/tests/utils/suite_writer/suite.py
@@ -0,0 +1,237 @@
+import itertools
+import os
+import sys
+import tempfile
+from contextlib import contextmanager
+
+import gossip
+
+from slash._compat import StringIO
+from slash.conf import config
+from slash.frontend.slash_run import slash_run
+
+from ..code_formatter import CodeFormatter
+from .file import File
+from .slash_run_result import SlashRunResult
+from .suite_strategy import BalancedStrategy
+from .validation import validate_run, get_test_id_from_test_address
+
+
+class Suite(object):
+
+    def __init__(self, strategy=BalancedStrategy(), path=None, debug_info=True, is_parallel=False):
+        super(Suite, self).__init__()
+        self._path = path
+        self._last_committed_path = None
+        self.strategy = strategy
+        self.debug_info = debug_info
+        self.is_parallel = is_parallel
+        self.clear()
+
+    def disable_debug_info(self):
+        self.debug_info = False
+
+    def deselect_all(self, exclude=()):
+        for test in self:
+            if test in exclude:
+                continue
+            test.expect_deselect()
+
+    def populate(self, num_tests=10):
+        for _ in range(num_tests):
+            self.add_test()
+
+    def clear(self):
+        self._files = []
+        self._notified = []
+        self._num_method_tests = self._num_function_tests = 0
+        self._slashconf = self._slashrc = None
+
+    def iter_all_after(self, test, assert_has_more=False):
+        found = had_more = False
+        for t in self:
+            if t == test:
+                found = True
+            elif found:
+                had_more = True
+                yield t
+        if assert_has_more:
+            assert had_more
+        assert found
+
+    @property
+    def classes(self):
+        return [cls for file in self._files for cls in file.classes]
+
+    @property
+    def files(self):
+        return list(self._files)
+
+    @property
+    def slashconf(self):
+        if self._slashconf is None:
+            self._slashconf = File(self, relpath='slashconf.py')
+        return self._slashconf
+
+    @property
+    def slashrc(self):
+        if self._slashrc is None:
+            self._slashrc = File(self, relpath='.slashrc')
+        return self._slashrc
+
+    def add_test(self, type=None, file=None):  # pylint: disable=unused-argument
+        if type is None:
+            type = self.strategy.get_test_type()
+        if type == 'function':
+            returned = self.add_function_test()
+        elif type == 'method':
+            returned = self.add_method_test()
+        else:
+            raise NotImplementedError('Unknown test type {0!r}'.format(type))  # pragma: no cover
+        assert returned in self._notified
+        return returned
+
+    def add_method_test(self):
+        cls = self.strategy.get_class_for_test(
+            self.strategy.get_file_for_test(self))
+        return cls.add_method_test()
+
+    def add_function_test(self):
+        return self.strategy.get_file_for_test(self).add_function_test()
+
+    def notify_test_added(self, test):
+        self._notified.append(test)
+        if test.is_method_test():
+            self._num_method_tests += 1
+        else:
+            self._num_function_tests += 1
+
+    def add_file(self):
+        returned = File(self)
+        self._files.append(returned)
+        return returned
+
+    def get_last_file(self):
+        if not self._files:
+            return None
+        return self._files[-1]
+
+    def __len__(self):
+        return len(self._notified)
+
+    def __getitem__(self, idx):
+        return self._notified[idx]
+
+    def run(self, verify=True, expect_interruption=False, additional_args=(), args=None, commit=True, sort=True, num_workers=1,
+            expect_session_errors=False):
+        if commit:
+            self.commit()
+        path = self._last_committed_path
+        assert path is not None
+        report_stream = StringIO()
+        returned = SlashRunResult(report_stream=report_stream)
+        captured = []
+        if args is None:
+            args = [path]
+        args.extend(additional_args)
+        if self.is_parallel:
+            args.extend(['--parallel', str(num_workers), '-vvvvv', '--parallel-addr', 'localhost'])
+            sort = False
+        with self._capture_events(returned), self._custom_sorting(sort):
+            with self._custom_slashrc(path):
+                app = slash_run(
+                    args, report_stream=report_stream,
+                    app_callback=captured.append,
+                )
+                returned.exit_code = app.exit_code
+            if app.interrupted:
+                assert expect_interruption, 'Unexpectedly interrupted'
+            else:
+                assert not expect_interruption, 'Session was not interrupted as expected'
+
+        if captured:
+            assert len(captured) == 1
+            returned.session = captured[0].session
+
+        if verify:
+            validate_run(self, returned, expect_interruption=expect_interruption, expect_session_errors=expect_session_errors)
+        return returned
+
+    @contextmanager
+    def _custom_sorting(self, do_sort):
+        @gossip.register('slash.tests_loaded')
+        def tests_loaded(tests):
+            if do_sort:
+                for test in tests:
+                    if not test.__slash__.is_interactive():
+                        test.__slash__.set_sort_key(int(self._get_test_id_from_runnable(test)))
+        try:
+            yield
+        finally:
+            tests_loaded.gossip.unregister()
+
+
+    def _get_test_id_from_runnable(self, test):
+        return get_test_id_from_test_address(test.__slash__.address)
+
+    @contextmanager
+    def _custom_slashrc(self, path):
+        if self._slashrc is None:
+            yield
+            return
+        prev = config.root.run.user_customization_file_path
+        config.root.run.user_customization_file_path = os.path.join(path, self._slashrc.get_relative_path())
+        try:
+            yield
+        finally:
+            config.root.run.user_customization_file_path = prev
+
+    @contextmanager
+    def _capture_events(self, summary):
+
+        sys.modules['__ut__'] = summary.tracker
+        try:
+            yield
+        finally:
+            sys.modules.pop('__ut__')
+
+    def commit(self):
+        path = self._path
+        if path is None:
+            path = tempfile.mkdtemp()
+        elif not os.path.isdir(path):
+            os.makedirs(path)
+
+        files = self._files
+        if self._slashconf is not None:
+            files = itertools.chain(files, [self._slashconf])
+        if self._slashrc is not None:
+            files = itertools.chain(files, [self._slashrc])
+
+
+        # TODO: clean up paths  # pylint: disable=fixme
+        for file in files:
+            with open(os.path.join(path, file.get_relative_path()), 'w') as f:
+                formatter = CodeFormatter(f)
+                file.write(formatter)
+
+        self._last_committed_path = path
+        return path
+
+    # Shortcuts
+
+    @property
+    def num_method_tests(self):
+        return self._num_method_tests
+
+    @property
+    def num_function_tests(self):
+        return self._num_function_tests
+
+    @property
+    def method_tests(self):
+        return [test for test in self._notified if test.is_method_test()]
+
+    @property
+    def function_tests(self):
+        return [test for test in self._notified if not test.is_method_test()]
diff --git a/tests/utils/suite_writer/suite_strategy.py b/tests/utils/suite_writer/suite_strategy.py
new file mode 100755
index 0000000000..aa584b1b94
--- /dev/null
+++ b/tests/utils/suite_writer/suite_strategy.py
@@ -0,0 +1,25 @@
+import itertools
+
+
+class BalancedStrategy(object):
+
+    def __init__(self, max_tests_per_file=5, max_tests_per_class=3):
+        super(BalancedStrategy, self).__init__()
+        self._max_tests_per_file = max_tests_per_file
+        self._max_tests_per_class = max_tests_per_class
+        self._type_gen = itertools.cycle(['function', 'method'])
+
+    def get_test_type(self):
+        return next(self._type_gen)
+
+    def get_file_for_test(self, suite):
+        candidate = suite.get_last_file()
+        if candidate is not None and candidate.get_num_tests() < self._max_tests_per_file:
+            return candidate
+        return suite.add_file()
+
+    def get_class_for_test(self, file):
+        candidate = file.get_last_class()
+        if candidate is not None and candidate.get_num_tests() < self._max_tests_per_class:
+            return candidate
+        return file.add_class()
diff --git a/tests/utils/suite_writer/test.py b/tests/utils/suite_writer/test.py
new file mode 100755
index 0000000000..9f781e37f8
--- /dev/null
+++ b/tests/utils/suite_writer/test.py
@@ -0,0 +1,122 @@
+import os
+
+from .element import Element
+from .function import Function
+
+_SUCCESS, _FAIL, _ERROR, _INTERRUPT, _SKIP, _NOT_RUN = ['SUCCESS', 'FAIL', 'ERROR', 'INTERRUPT', 'SKIP', 'NOT_RUN']
+
+class Test(Function, Element):
+
+    cls = None
+
+    def __init__(self, suite, file):
+        super(Test, self).__init__(suite)
+        self.file = file
+        self._expected_result = _SUCCESS
+        self._selected = True
+        self.when_run = WhenRunHelper(self)
+        self._repetitions = 1
+        self.excluded_param_values = frozenset()
+
+    def exclude_param_value(self, param_name, param_value):
+        self.excluded_param_values |= {(param_name, param_value)}
+
+    def get_full_address(self, root_path):
+        filepath = os.path.join(root_path, self.file.name)
+        name = self.name
+        if self.cls is not None:
+            name = '{.name}.{}'.format(self.cls, name) # pylint: disable=missing-format-attribute
+        return '{}:{}'.format(filepath, name)
+
+    def repeat(self, num_repetitions):
+        self.add_decorator('slash.repeat({})'.format(num_repetitions))
+        self.expect_repetition(num_repetitions)
+
+    def expect_repetition(self, num_repetitions):
+        self._repetitions *= num_repetitions
+
+    def get_num_expected_repetitions(self):
+        return self._repetitions
+
+    def add_cleanup(self, **kw):
+        return self.add_deferred_event('slash.add_cleanup', name='test_cleanup', **kw)
+
+    def expect_failure(self):
+        self._expect(_FAIL)
+
+    def expect_error(self):
+        self._expect(_ERROR)
+
+    def expect_interruption(self):
+        self._expect(_INTERRUPT)
+
+    def expect_skip(self):
+        self._expect(_SKIP)
+
+    def expect_not_run(self):
+        self._expect(_NOT_RUN)
+
+    def expect_deselect(self):
+        self._selected = False
+
+    def is_selected(self):
+        return self._selected
+
+    def _expect(self, expected_result):
+        if self._expected_result != _SUCCESS:
+            raise NotImplementedError() # pragma: no cover
+        self._expected_result = expected_result
+
+    def get_expected_result(self):
+        return self._expected_result
+
+    def is_method_test(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def is_function_test(self):
+        raise NotImplementedError() # pragma: no cover
+
+    def _write_prologue(self, code_formatter):
+        self._write_event(code_formatter, 'test_start')
+        super(Test, self)._write_prologue(code_formatter)
+
+    def _write_epilogue(self, code_formatter):
+        self._write_event(code_formatter, 'test_end')
+        super(Test, self)._write_epilogue(code_formatter)
+
+    def _get_function_name(self):
+        return 'test_{0}'.format(self.id)
+
+
+class WhenRunHelper(object):
+
+    def __init__(self, test):
+        super(WhenRunHelper, self).__init__()
+        self.test = test
+
+    def raise_exception(self):
+        self.test.append_line('raise Exception("Test exception")')
+        self.test.expect_error()
+
+    error = raise_exception
+
+    def fail(self):
+        self.test.append_line('assert False')
+        self.test.expect_failure()
+
+    def interrupt(self):
+        self.test.append_line('raise KeyboardInterrupt()')
+        self.test.expect_interruption()
+
+    def skip(self, with_reason=True, decorator=False):
+        if decorator:
+            if with_reason:
+                self.test.add_decorator('slash.skipped("reason")')
+            else:
+                self.test.add_decorator('slash.skipped')
+        else:
+            if with_reason:
+                self.test.append_line('slash.skip_test("reason")')
+            else:
+                self.test.append_line('slash.skip_test()')
+        self.test.expect_skip()
diff --git a/tests/utils/suite_writer/test_class.py b/tests/utils/suite_writer/test_class.py
new file mode 100755
index 0000000000..2efe1dea91
--- /dev/null
+++ b/tests/utils/suite_writer/test_class.py
@@ -0,0 +1,56 @@
+from contextlib import contextmanager
+
+from .function import CodeElement, Method
+from .element import Element
+from .method_test import MethodTest
+from .test_container import TestContainer
+
+
+class Class(TestContainer, CodeElement, Element):
+
+    def __init__(self, suite, file):
+        super(Class, self).__init__(suite)
+        self._decorators = []
+        self.file = file
+        self.suite = file.suite
+        self.name = 'Test{0}'.format(self.id)
+        self.before = self.after = None
+
+    def add_before_method(self):
+        assert self.before is None
+        self.before = Method(self.suite, name='before')
+        return self.before
+
+    def add_after_method(self):
+        assert self.after is None
+        self.after = Method(self.suite, name='after')
+        return self.after
+
+    def add_decorator(self, decorator_string):
+        self._decorators.append(decorator_string)
+
+    def add_method_test(self):
+        returned = MethodTest(self.suite, self)
+        self._tests.append(returned)
+        self.suite.notify_test_added(returned)
+        return returned
+
+    @contextmanager
+    def _body_context(self, code_formatter):
+        for d in self._decorators:
+            code_formatter.write('@')
+            code_formatter.writeln(d)
+        code_formatter.writeln('class {0}(slash.Test):'.format(self.name))
+        with code_formatter.indented():
+
+            if self.before is not None:
+                self.before.write(code_formatter)
+            if self.after is not None:
+                self.after.write(code_formatter)
+
+            yield
+
+    def _write_body(self, code_formatter):
+        super(Class, self)._write_body(code_formatter)
+        for test in self._tests:
+            test.write(code_formatter)
diff --git a/tests/utils/suite_writer/test_container.py b/tests/utils/suite_writer/test_container.py
new file mode 100755
index 0000000000..b45cd8895e
--- /dev/null
+++ b/tests/utils/suite_writer/test_container.py
@@ -0,0 +1,15 @@
+from .element import Element
+
+
+class TestContainer(Element):
+
+    def __init__(self, suite):
+        super(TestContainer, self).__init__(suite)
+        self._tests = []
+
+    @property
+    def tests(self):
+        return list(self._tests)
+
+    def get_num_tests(self):
+        return len(self._tests)
diff --git a/tests/utils/suite_writer/validation.py b/tests/utils/suite_writer/validation.py
new file mode 100755
index 0000000000..ca090700bc
--- /dev/null
+++ b/tests/utils/suite_writer/validation.py
@@ -0,0 +1,141 @@
+import itertools
+import re
+
+import logbook
+
+from slash._compat import iteritems, itervalues, xrange
+
+from .generator_fixture import GeneratorFixture
+
+_logger = logbook.Logger(__name__)
+
+
+def validate_run(suite, run_result, expect_interruption, expect_session_errors):
+    if expect_interruption or not run_result.session.results.is_success(allow_skips=True):
+        assert run_result.exit_code != 0, '`slash run` unexpectedly returned 0'
+    else:
+        assert run_result.exit_code == 0, '`slash run` unexpectedly returned {}. Output: {}'.format(
+            run_result.exit_code, run_result.get_console_output())
+
+    global_result = run_result.session.results.global_result
+    errors = global_result.get_errors() + global_result.get_failures()
+    if expect_session_errors:
+        assert errors, 'Expected session errors but found none'
+    else:
+        assert not errors, 'Sessions errors were not expected (Got {})'.format(errors)
+
+    for test, results in iteritems(_group_results_by_test_id(suite, run_result)):
+        _validate_single_test(test, results)
+
+
+def _validate_single_test(test, results):
+
+    param_names = {p.id: p.name for p in _find_all_parameters(test)}
+
+    for param_values in _iter_param_value_sets(test):
+
+        is_excluded = any((param_names[param_id], value) in test.excluded_param_values for param_id, value in param_values.items())
+
+        for repetition in xrange(test.get_num_expected_repetitions()):  # pylint: disable=unused-variable
+
+            for index, result in enumerate(results):
+
+                if _result_matches(result, param_values):
+
+                    results.pop(index)
+
+                    if is_excluded:
+                        assert result.is_skip()
+                    else:
+                        _validate_single_test_result(test, result)
+
+                    break
+            else:
+                assert False, 'Could not find parameter set {0}'.format(
+                    param_values)
+
+    assert not results, 'Unmatched results exist'
+
+
+def _iter_param_value_sets(test):
+    params = _find_all_parameters(test)
+    param_ids = [p.id for p in params]
+    for combination in itertools.product(*(param.values for param in params)):
+        yield dict(zip(param_ids, combination))
+
+
+def _find_all_parameters(func):
+    params = []
+    stack = [func]
+    while stack:
+        f = stack.pop()
+        for subfixture in f.get_fixtures():
+            if isinstance(subfixture, GeneratorFixture):
+                params.append(subfixture)
+                continue
+            else:
+                stack.append(subfixture)
+        params.extend(f.get_parameters())
+    return list(itervalues({p.id: p for p in params}))
+
+
+def _result_matches(result, param_values):
+    values = result.test_metadata.variation.values.copy()
+    for param_name in list(values):
+        # handle the case of a fixture with a single param, which is logically a parameter by itself
+        if re.match(r'^fx_\d+.param$', param_name):
+            values_name = param_name.split('_')[1].split('.')[0]
+        else:
+            values_name = param_name.rsplit('_', 1)[-1]
+
+        values[values_name] = values.pop(param_name)
+
+    return values == param_values
+
+
+def _validate_single_test_result(test, result):
+    expected = test.get_expected_result()
+    if expected == 'ERROR':
+        assert result.is_error(), 'Test did not issue error as expected'
+    elif expected == 'FAIL':
+        assert result.is_failure(), 'Test did not fail as expected'
+    elif expected == 'SUCCESS':
+        assert result.is_success(), 'Test {0} unexpectedly unsuccessful:\n{1}'.format(
+            test.id, list(itertools.chain(result.get_errors(), result.get_failures())))
+    elif expected == 'INTERRUPT':
+        assert result.is_interrupted(), 'Test did not get interrupted as expected'
+    elif expected == 'SKIP':
+        assert result.is_skip()
+    elif expected == 'NOT_RUN':
+        assert result.is_not_run()
+    else:
+        raise NotImplementedError(
+            'Unknown expected result: {0!r}'.format(expected))  # pragma: no cover
+
+
+def _group_results_by_test_id(suite, run_result):
+    tests_by_id = dict((t.id, t) for t in suite)
+    unseen = tests_by_id.copy()
+
+    groups = {}
+
+    for result in run_result.session.results:
+        if result.test_metadata.is_interactive():
+            continue
+        test_id = get_test_id_from_test_address(result.test_metadata.address)
+        assert tests_by_id[test_id].is_selected(), 'Test {} appears in results, although not expected!'.format(test_id)
+        groups.setdefault(tests_by_id[test_id], []).append(result)
+        unseen.pop(test_id, None)
+
+    for test_id, test in list(iteritems(unseen)):
+        if not test.is_selected():
+            unseen.pop(test_id, None)
+
+    assert not unseen, 'Expected results not found ({0})'.format(unseen)
+
+    return groups
+
+
+def get_test_id_from_test_address(addr):
+    _, addr = addr.split(':', 1)
+    return addr.split('_')[1].split('(')[0]
diff --git a/tox.ini b/tox.ini
new file mode 100755
index 0000000000..8596f97818
--- /dev/null
+++ b/tox.ini
@@ -0,0 +1,9 @@
+[tox]
+envlist = py27,py33,py34,py35,py36
+
+[testenv]
+commands=
+	pylint -j 4 --rcfile=.pylintrc tests setup.py slash
+        py.test tests
+extras = testing
+changedir = {toxinidir}
