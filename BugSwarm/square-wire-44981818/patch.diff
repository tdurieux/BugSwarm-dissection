diff --git a/checkstyle.xml b/checkstyle.xml
index ab2b00bb..285c6bc2 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -65,10 +65,6 @@
       <property name="max" value="100"/>
     </module>
     <module name="MethodLength"/>
-    <module name="ParameterNumber">
-      <property name="max" value="10"/>
-      <property name="tokens" value="CTOR_DEF"/>
-    </module>
 
 
     <!-- Checks for whitespace                               -->
diff --git a/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java b/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java
new file mode 100644
index 00000000..1e70b722
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/CommandLineOptions.java
@@ -0,0 +1,168 @@
+package com.squareup.wire;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Scanner;
+import java.util.Set;
+
+final class CommandLineOptions {
+  public static final String PROTO_PATH_FLAG = "--proto_path=";
+  public static final String JAVA_OUT_FLAG = "--java_out=";
+  public static final String FILES_FLAG = "--files=";
+  public static final String ROOTS_FLAG = "--roots=";
+  public static final String REGISTRY_CLASS_FLAG = "--registry_class=";
+  public static final String NO_OPTIONS_FLAG = "--no_options";
+  public static final String ENUM_OPTIONS_FLAG = "--enum_options=";
+  public static final String SERVICE_WRITER_FLAG = "--service_writer=";
+  public static final String SERVICE_WRITER_OPT_FLAG = "--service_writer_opt=";
+  public static final String QUIET_FLAG = "--quiet";
+  public static final String DRY_RUN_FLAG = "--dry_run";
+
+  final String protoPath;
+  final String javaOut;
+  final List<String> sourceFileNames;
+  final List<String> roots;
+  final String registryClass;
+  final boolean emitOptions;
+  final Set<String> enumOptions;
+  final String serviceWriter;
+  final List<String> serviceWriterOptions;
+  final boolean quiet;
+  final boolean dryRun;
+
+  CommandLineOptions(String protoPath, String javaOut,
+      List<String> sourceFileNames, List<String> roots,
+      String registryClass, boolean emitOptions,
+      Set<String> enumOptions,
+      String serviceWriter,
+      List<String> serviceWriterOptions,
+      boolean quiet,
+      boolean dryRun) {
+    this.protoPath = protoPath;
+    this.javaOut = javaOut;
+    this.sourceFileNames = sourceFileNames;
+    this.roots = roots;
+    this.registryClass = registryClass;
+    this.emitOptions = emitOptions;
+    this.enumOptions = enumOptions;
+    this.serviceWriter = serviceWriter;
+    this.serviceWriterOptions = serviceWriterOptions;
+    this.quiet = quiet;
+    this.dryRun = dryRun;
+  }
+
+  /**
+   * Usage:
+   *
+   * <pre>
+   * java WireCompiler --proto_path=&lt;path&gt; --java_out=&lt;path&gt;
+   *     [--files=&lt;protos.include&gt;] [--roots=&lt;message_name&gt;[,&lt;message_name&gt;...]]
+   *     [--registry_class=&lt;class_name&gt;] [--no_options]
+   *     [--enum_options=&lt;option_name&gt;[,&lt;option_name&gt;...]]
+   *     [--service_writer=&lt;class_name&gt;]
+   *     [--service_writer_opt=&lt;value&gt;] [--service_writer_opt=&lt;value&gt;]...]
+   *     [--quiet] [--dry_run]
+   *     [file [file...]]
+   * </pre>
+   *
+   * If the {@code --roots} flag is present, its argument must be a comma-separated list
+   * of fully-qualified message or enum names. The output will be limited to those messages
+   * and enums that are (transitive) dependencies of the listed names.  If you are using
+   * {@code --service_writer} to generate an interface for a Service, your roots can also take the
+   * form 'fully.qualified.Service#MethodName` to limit what endpoints are generated.
+   * <p>
+   * If the {@code --registry_class} flag is present, its argument must be a Java class name. A
+   * class with the given name will be generated, containing a constant list of all extension
+   * classes generated during the compile. This list is suitable for passing to Wire's constructor
+   * at runtime for constructing its internal extension registry.
+   * <p>
+   * Unless the {@code --no_options} flag is supplied, code will be emitted for options on messages
+   * and fields.  The presence of options on a message will result in a static member named
+   * "MESSAGE_OPTIONS", initialized with the options and their values.   The presence of options on
+   * a field (other than the standard options "default", "deprecated", and "packed") will result in
+   * a static member named "FIELD_OPTIONS_&lt;field name&gt;" in the generated code, initialized
+   * with the field option values.
+   * <p>
+   * Regardless of the value of the {@code --no_options} flag, code will be emitted for all
+   * enum value options listed in the {@code --enum_options} flag. The resulting code will contain
+   * a public static field for each option used within a particular enum type.
+   * </p>
+   * <p>
+   * If {@code --quiet} is specified, diagnostic messages to stdout are suppressed.
+   * </p>
+   * <p>
+   * The {@code --dry_run} flag causes the compile to just emit the names of the source files that
+   * would be generated to stdout.
+   */
+  CommandLineOptions(String... args) throws WireException {
+    int index = 0;
+
+    List<String> sourceFileNames = new ArrayList<String>();
+    List<String> serviceWriterOptions = new ArrayList<String>();
+    List<String> roots = new ArrayList<String>();
+    boolean emitOptions = true;
+    String protoPath = null;
+    String javaOut = null;
+    String registryClass = null;
+    List<String> enumOptionsList = new ArrayList<String>();
+    String serviceWriter = null;
+    boolean quiet = false;
+    boolean dryRun = false;
+
+    while (index < args.length) {
+      if (args[index].startsWith(PROTO_PATH_FLAG)) {
+        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
+      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
+        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
+      } else if (args[index].startsWith(FILES_FLAG)) {
+        File files = new File(args[index].substring(FILES_FLAG.length()));
+        String[] fileNames;
+        try {
+          fileNames = new Scanner(files, "UTF-8").useDelimiter("\\A").next().split("\n");
+        } catch (FileNotFoundException ex) {
+          throw new WireException("Error processing argument " + args[index], ex);
+        }
+        sourceFileNames.addAll(Arrays.asList(fileNames));
+      } else if (args[index].startsWith(ROOTS_FLAG)) {
+        roots.addAll(splitArg(args[index], ROOTS_FLAG.length()));
+      } else if (args[index].startsWith(REGISTRY_CLASS_FLAG)) {
+        registryClass = args[index].substring(REGISTRY_CLASS_FLAG.length());
+      } else if (args[index].equals(NO_OPTIONS_FLAG)) {
+        emitOptions = false;
+      } else if (args[index].startsWith(ENUM_OPTIONS_FLAG)) {
+        enumOptionsList.addAll(splitArg(args[index], ENUM_OPTIONS_FLAG.length()));
+      } else if (args[index].startsWith(SERVICE_WRITER_FLAG)) {
+        serviceWriter = args[index].substring(SERVICE_WRITER_FLAG.length());
+      } else if (args[index].startsWith(SERVICE_WRITER_OPT_FLAG)) {
+        serviceWriterOptions.add(args[index].substring(SERVICE_WRITER_OPT_FLAG.length()));
+      } else if (args[index].startsWith(QUIET_FLAG)) {
+        quiet = true;
+      } else if (args[index].startsWith(DRY_RUN_FLAG)) {
+        dryRun = true;
+      } else {
+        sourceFileNames.add(args[index]);
+      }
+      index++;
+    }
+
+    this.protoPath = protoPath;
+    this.javaOut = javaOut;
+    this.sourceFileNames = sourceFileNames;
+    this.roots = roots;
+    this.registryClass = registryClass;
+    this.emitOptions = emitOptions;
+    this.enumOptions = new LinkedHashSet<String>(enumOptionsList);
+    this.serviceWriter = serviceWriter;
+    this.serviceWriterOptions = serviceWriterOptions;
+    this.quiet = quiet;
+    this.dryRun = dryRun;
+  }
+
+  private static List<String> splitArg(String arg, int flagLength) {
+    return Arrays.asList(arg.substring(flagLength).split(","));
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/IO.java b/wire-compiler/src/main/java/com/squareup/wire/IO.java
index f968656a..5e801520 100644
--- a/wire-compiler/src/main/java/com/squareup/wire/IO.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/IO.java
@@ -5,7 +5,6 @@
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.ProtoSchemaParser;
 
-import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -29,9 +28,10 @@
    *   <output directory>/<java package converted to slashed form>/<className>.java
    * }</pre>
    */
-  JavaWriter getJavaWriter(String outputDirectory, String javaPackage, String className)
+  JavaWriter getJavaWriter(OutputArtifact outputArtifact)
       throws IOException;
 
+
   /**
    * Concrete implementation of the IO interface that proxies to the file system.
    */
@@ -45,18 +45,10 @@ public ProtoFile parse(String filename) throws IOException {
     }
 
     @Override
-    public JavaWriter getJavaWriter(String outputDirectory, String javaPackage, String className)
+    public JavaWriter getJavaWriter(OutputArtifact artifact)
         throws IOException {
-      String directory = outputDirectory + File.separator
-          + javaPackage.replace(".", File.separator);
-      boolean created = new File(directory).mkdirs();
-      if (created) {
-        System.out.println("Created output directory " + directory);
-      }
-
-      String fileName = directory + File.separator + className + ".java";
-      System.out.println("Writing generated code to " + fileName);
-      return new JavaWriter(new OutputStreamWriter(new FileOutputStream(fileName), UTF_8));
+      artifact.dir().mkdirs();
+      return new JavaWriter(new OutputStreamWriter(new FileOutputStream(artifact.file()), UTF_8));
     }
   }
 }
diff --git a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
index f112c246..defdf546 100644
--- a/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/MessageWriter.java
@@ -39,11 +39,9 @@
           "throw", "throws", "transient", "try", "void", "volatile", "while"));
   private static final String URL_CHARS = "[-!#$%&'()*+,./0-9:;=?@A-Z\\[\\]_a-z~]";
   private final WireCompiler compiler;
-  private final JavaWriter writer;
 
   public MessageWriter(WireCompiler compiler) {
     this.compiler = compiler;
-    this.writer = compiler.getWriter();
   }
 
   public static void emitDocumentation(JavaWriter writer, String documentation) throws IOException {
@@ -67,7 +65,7 @@ static String sanitizeJavadoc(String documentation) {
     return documentation;
   }
 
-  public void emitHeader(Set<String> imports,
+  public void emitHeader(JavaWriter writer, Set<String> imports,
       Collection<Message.Datatype> datatypes, Collection<Message.Label> labels) throws IOException {
     writer.emitImports(imports);
 
@@ -96,13 +94,14 @@ public void emitHeader(Set<String> imports,
     }
   }
 
-  public void emitType(Type type, String currentType, Map<String, ?> optionsMap, boolean topLevel)
+  public void emitType(JavaWriter writer, Type type, String currentType, Map<String, ?> optionsMap,
+      boolean topLevel)
       throws IOException {
     writer.emitEmptyLine();
     if (type instanceof MessageType) {
-      emitAll((MessageType) type, optionsMap, topLevel);
+      emitAll(writer, (MessageType) type, optionsMap, topLevel);
       for (Type nestedType : type.getNestedTypes()) {
-        emitType(nestedType, currentType + nestedType.getName() + ".", optionsMap, false);
+        emitType(writer, nestedType, currentType + nestedType.getName() + ".", optionsMap, false);
       }
       writer.endType();
     } else if (type instanceof EnumType) {
@@ -125,8 +124,8 @@ public void emitType(Type type, String currentType, Map<String, ?> optionsMap, b
             (i == count - 1));
       }
 
-      if (compiler.emitOptions()) {
-        emitEnumOptions(mapMaker.createEnumOptionsMap(enumType));
+      if (compiler.shouldEmitOptions()) {
+        emitEnumOptions(writer, mapMaker.createEnumOptionsMap(enumType));
       }
 
       // Output Private tag field
@@ -168,7 +167,7 @@ public void emitType(Type type, String currentType, Map<String, ?> optionsMap, b
 
   private List<EnumValueOptionInfo> getEnumValueOptions(EnumType enumType,
       OptionsMapMaker mapMaker) {
-    if (!compiler.emitOptions() && compiler.enumOptions().isEmpty()) {
+    if (!compiler.shouldEmitOptions() && compiler.enumOptions().isEmpty()) {
       return Collections.emptyList();
     }
 
@@ -240,7 +239,8 @@ private String join(List<String> values, String separator) {
     return sb.toString();
   }
 
-  private void emitAll(MessageType messageType, Map<String, ?> optionsMap, boolean topLevel)
+  private void emitAll(JavaWriter writer, MessageType messageType, Map<String, ?> optionsMap,
+      boolean topLevel)
       throws IOException {
     Set<Modifier> modifiers = EnumSet.of(PUBLIC, FINAL);
     if (!topLevel) {
@@ -252,20 +252,20 @@ private void emitAll(MessageType messageType, Map<String, ?> optionsMap, boolean
     writer.beginType(name, "class", modifiers,
         compiler.hasExtensions(messageType) ? "ExtendableMessage<" + name + ">" : "Message");
 
-    emitMessageOptions(optionsMap);
-    if (compiler.emitOptions()) {
-      emitMessageFieldOptions(messageType);
+    emitMessageOptions(writer, optionsMap);
+    if (compiler.shouldEmitOptions()) {
+      emitMessageFieldOptions(writer, messageType);
     }
-    emitMessageFieldDefaults(messageType);
-    emitMessageFields(messageType);
-    emitMessageFieldsConstructor(messageType);
-    emitMessageBuilderConstructor(messageType);
-    emitMessageEquals(messageType);
-    emitMessageHashCode(messageType);
-    emitBuilder(messageType);
+    emitMessageFieldDefaults(writer, messageType);
+    emitMessageFields(writer, messageType);
+    emitMessageFieldsConstructor(writer, messageType);
+    emitMessageBuilderConstructor(writer, messageType);
+    emitMessageEquals(writer, messageType);
+    emitMessageHashCode(writer, messageType);
+    emitBuilder(writer, messageType);
   }
 
-  private void emitMessageOptions(Map<String, ?> optionsMap) throws IOException {
+  private void emitMessageOptions(JavaWriter writer, Map<String, ?> optionsMap) throws IOException {
     if (optionsMap != null) {
       StringBuilder sb = new StringBuilder();
       sb.append("new MessageOptions.Builder()");
@@ -284,7 +284,7 @@ private void emitMessageOptions(Map<String, ?> optionsMap) throws IOException {
     }
   }
 
-  private void emitEnumOptions(Map<String, ?> optionsMap) throws IOException {
+  private void emitEnumOptions(JavaWriter writer, Map<String, ?> optionsMap) throws IOException {
     if (optionsMap != null) {
       StringBuilder sb = new StringBuilder();
       sb.append("new EnumOptions.Builder()");
@@ -303,7 +303,8 @@ private void emitEnumOptions(Map<String, ?> optionsMap) throws IOException {
     }
   }
 
-  private void emitMessageFieldOptions(MessageType messageType) throws IOException {
+  private void emitMessageFieldOptions(JavaWriter writer, MessageType messageType)
+      throws IOException {
     Map<String, List<Option>> fieldOptions = new LinkedHashMap<String, List<Option>>();
 
     for (Field field : messageType.getFields()) {
@@ -327,11 +328,12 @@ private void emitMessageFieldOptions(MessageType messageType) throws IOException
     for (Map.Entry<String, List<Option>> entry : fieldOptions.entrySet()) {
       Map<String, ?> fieldOptionsMap =
           compiler.getOptionsMapMaker().createFieldOptionsMap(messageType, entry.getValue());
-      emitFieldOptions(entry.getKey(), fieldOptionsMap);
+      emitFieldOptions(writer, entry.getKey(), fieldOptionsMap);
     }
   }
 
-  private void emitFieldOptions(String fieldName, Map<String, ?> optionsMap) throws IOException {
+  private void emitFieldOptions(JavaWriter writer, String fieldName, Map<String, ?> optionsMap)
+      throws IOException {
     if (optionsMap == null) return;
 
     StringBuilder sb = new StringBuilder();
@@ -356,7 +358,8 @@ private void emitFieldOptions(String fieldName, Map<String, ?> optionsMap) throw
   //
   // public static final Integer DEFAULT_OPT_INT32 = 123;
   //
-  private void emitMessageFieldDefaults(MessageType messageType) throws IOException {
+  private void emitMessageFieldDefaults(JavaWriter writer, MessageType messageType)
+      throws IOException {
     List<Field> defaultFields = new ArrayList<Field>();
     for (Field field : messageType.getFields()) {
       // Message types cannot have defaults
@@ -393,7 +396,7 @@ private void emitMessageFieldDefaults(MessageType messageType) throws IOExceptio
   // )
   // public final Integer optional_int32;
   //
-  private void emitMessageFields(MessageType messageType) throws IOException {
+  private void emitMessageFields(JavaWriter writer, MessageType messageType) throws IOException {
     for (Field field : messageType.getFields()) {
       int tag = field.getTag();
 
@@ -452,7 +455,8 @@ private void emitMessageFields(MessageType messageType) throws IOException {
   //   this.optional_int64 = optional_int64;
   // }
   //
-  private void emitMessageFieldsConstructor(MessageType messageType) throws IOException {
+  private void emitMessageFieldsConstructor(JavaWriter writer, MessageType messageType)
+      throws IOException {
     List<String> params = new ArrayList<String>();
     for (Field field : messageType.getFields()) {
       String javaName = getJavaFieldType(messageType, field);
@@ -480,7 +484,8 @@ private void emitMessageFieldsConstructor(MessageType messageType) throws IOExce
   //   setBuilder(builder);
   // }
   //
-  private void emitMessageBuilderConstructor(MessageType messageType) throws IOException {
+  private void emitMessageBuilderConstructor(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.beginMethod(null, messageType.getName(), EnumSet.of(PRIVATE), "Builder", "builder");
     StringBuilder params = new StringBuilder();
@@ -508,7 +513,7 @@ private void emitMessageBuilderConstructor(MessageType messageType) throws IOExc
   //   if (!Wire.equals(optional_int32, o.optional_int32)) return false;
   //   return true;
   //
-  private void emitMessageEquals(MessageType messageType) throws IOException {
+  private void emitMessageEquals(JavaWriter writer, MessageType messageType) throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod("boolean", "equals", EnumSet.of(PUBLIC), "Object", "other");
@@ -560,7 +565,8 @@ private void emitMessageEquals(MessageType messageType) throws IOException {
   // For repeated fields, the final "0" in the example above changes to a "1"
   // in order to be the same as the system hash code for an empty list.
   //
-  private void emitMessageHashCode(MessageType messageType) throws IOException {
+  private void emitMessageHashCode(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod("int", "hashCode", EnumSet.of(PUBLIC));
@@ -608,21 +614,21 @@ private int nullHashValue(Field field) {
     return FieldInfo.isRepeated(field) ? 1 : 0;
   }
 
-  private void emitBuilder(MessageType messageType) throws IOException {
+  private void emitBuilder(JavaWriter writer, MessageType messageType) throws IOException {
     writer.emitEmptyLine();
     writer.beginType("Builder", "class", EnumSet.of(PUBLIC, STATIC, FINAL),
         (compiler.hasExtensions(messageType) ? "ExtendableBuilder<" : "Message.Builder<")
             + messageType.getName()
             + ">");
-    emitBuilderFields(messageType);
-    emitBuilderConstructors(messageType);
-    emitBuilderSetters(messageType);
-    if (compiler.hasExtensions(messageType)) emitBuilderSetExtension(messageType);
-    emitBuilderBuild(messageType);
+    emitBuilderFields(writer, messageType);
+    emitBuilderConstructors(writer, messageType);
+    emitBuilderSetters(writer, messageType);
+    if (compiler.hasExtensions(messageType)) emitBuilderSetExtension(writer, messageType);
+    emitBuilderBuild(writer, messageType);
     writer.endType();
   }
 
-  private void emitBuilderFields(MessageType messageType) throws IOException {
+  private void emitBuilderFields(JavaWriter writer, MessageType messageType) throws IOException {
     List<Field> fields = messageType.getFields();
 
     if (!fields.isEmpty()) writer.emitEmptyLine();
@@ -644,7 +650,8 @@ private void emitBuilderFields(MessageType messageType) throws IOException {
   //   ...
   // }
   //
-  private void emitBuilderConstructors(MessageType messageType) throws IOException {
+  private void emitBuilderConstructors(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.beginMethod(null, "Builder", EnumSet.of(PUBLIC));
     writer.endMethod();
@@ -665,7 +672,7 @@ private void emitBuilderConstructors(MessageType messageType) throws IOException
     writer.endMethod();
   }
 
-  private void emitBuilderSetters(MessageType messageType) throws IOException {
+  private void emitBuilderSetters(JavaWriter writer, MessageType messageType) throws IOException {
     for (Field field : messageType.getFields()) {
       String javaName = getJavaFieldType(messageType, field);
       List<String> args = new ArrayList<String>();
@@ -700,7 +707,8 @@ private void emitBuilderSetters(MessageType messageType) throws IOException {
   //   return this;
   // }
   //
-  private void emitBuilderSetExtension(MessageType messageType) throws IOException {
+  private void emitBuilderSetExtension(JavaWriter writer, MessageType messageType)
+      throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod("<E> Builder", "setExtension", EnumSet.of(PUBLIC),
@@ -721,7 +729,7 @@ private void emitBuilderSetExtension(MessageType messageType) throws IOException
   // The call to checkRequiredFields will be emitted only if the message has
   // required fields.
   //
-  private void emitBuilderBuild(MessageType messageType) throws IOException {
+  private void emitBuilderBuild(JavaWriter writer, MessageType messageType) throws IOException {
     writer.emitEmptyLine();
     writer.emitAnnotation(Override.class);
     writer.beginMethod(messageType.getName(), "build", EnumSet.of(PUBLIC));
diff --git a/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java b/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java
new file mode 100644
index 00000000..e73a1b89
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/OutputArtifact.java
@@ -0,0 +1,45 @@
+package com.squareup.wire;
+
+import java.io.File;
+
+/**
+ * A container class that represents an artifact output from the compiler.
+ */
+public final class OutputArtifact {
+  private final String outputDirectory;
+  private final String className;
+  private final String javaPackage;
+
+  public OutputArtifact(String outputDirectory, String javaPackage, String className) {
+    this.outputDirectory = outputDirectory;
+    this.className = className;
+    this.javaPackage = javaPackage;
+  }
+
+
+  public String outputDirectory() {
+    return outputDirectory;
+  }
+
+  public String className() {
+    return className;
+  }
+
+  public String javaPackage() {
+    return javaPackage;
+  }
+
+  public File file() {
+    String dir = outputDirectory + File.separator
+        + javaPackage.replace(".", File.separator);
+    return new File(dir, className + ".java");
+  }
+
+  public File dir() {
+    return file().getParentFile();
+  }
+
+  public String fullClassName() {
+    return javaPackage + "." + className;
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java b/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
index 1d72ac39..f61fd03e 100644
--- a/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
+++ b/wire-compiler/src/main/java/com/squareup/wire/WireCompiler.java
@@ -23,6 +23,8 @@
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.Service;
 import com.squareup.protoparser.Type;
+import com.squareup.wire.logger.ConsoleWireLogger;
+import com.squareup.wire.logger.WireLogger;
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
@@ -36,7 +38,6 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Scanner;
 import java.util.Set;
 import java.util.TreeSet;
 import okio.ByteString;
@@ -60,20 +61,10 @@
       new LinkedHashSet<String>(Arrays.asList("default", "deprecated", "packed"));
 
   private static final Charset ISO_8859_1 = Charset.forName("ISO_8859_1");
-  private static final String PROTO_PATH_FLAG = "--proto_path=";
-  private static final String JAVA_OUT_FLAG = "--java_out=";
-  private static final String FILES_FLAG = "--files=";
-  private static final String REGISTRY_CLASS_FLAG = "--registry_class=";
-  private static final String ROOTS_FLAG = "--roots=";
-  private static final String NO_OPTIONS_FLAG = "--no_options";
-  private static final String ENUM_OPTIONS_FLAG = "--enum_options=";
-  private static final String SERVICE_WRITER_FLAG = "--service_writer=";
-  private static final String SERVICE_WRITER_OPT_FLAG = "--service_writer_opt=";
   private static final String CODE_GENERATED_BY_WIRE =
       "Code generated by Wire protocol buffer compiler, do not edit.";
 
   private final String repoPath;
-  private final List<String> sourceFileNames;
   private final IO io;
   private final Set<String> typesToEmit = new LinkedHashSet<String>();
   private final Map<String, String> javaSymbolMap = new LinkedHashMap<String, String>();
@@ -83,179 +74,112 @@
   private final Map<String, ExtensionInfo> extensionInfo =
       new LinkedHashMap<String, ExtensionInfo>();
   private final Map<String, FieldInfo> fieldMap = new LinkedHashMap<String, FieldInfo>();
-  private final String outputDirectory;
-  private final String registryClass;
+
   private final List<String> extensionClasses = new ArrayList<String>();
   private final OptionsMapMaker optionsMapMaker = new OptionsMapMaker(this);
+  private final CommandLineOptions options;
+
+  private final WireLogger log;
 
   private ProtoFile protoFile;
-  private JavaWriter writer;
   private String sourceFileName;
   private String protoFileName;
   private String typeBeingGenerated = "";
-  private boolean emitOptions = false;
-  private Set<String> enumOptions;
 
   private Constructor<?> serviceWriterConstructor;
-  private List<String> serviceWriterOptions;
 
   /**
-   * Runs the compiler. Usage:
-   *
-   * <pre>
-   * java WireCompiler --proto_path=&lt;path&gt; --java_out=&lt;path&gt;
-   *     [--files=&lt;protos.include&gt;] [--roots=&lt;message_name&gt;[,&lt;message_name&gt;...]]
-   *     [--registry_class=&lt;class_name&gt;] [--no_options]
-   *     [--enum_options=&lt;option_name&gt;[,&lt;option_name&gt;...]]
-   *     [--service_writer=&lt;class_name&gt;]
-   *     [--service_writer_opt=&lt;value&gt;] [--service_writer_opt=&lt;value&gt;]...]
-   *     [file [file...]]
-   * </pre>
-   *
-   * If the {@code --roots} flag is present, its argument must be a comma-separated list
-   * of fully-qualified message or enum names. The output will be limited to those messages
-   * and enums that are (transitive) dependencies of the listed names.  If you are using
-   * {@code --service_writer} to generate an interface for a Service, your roots can also take the
-   * form 'fully.qualified.Service#MethodName` to limit what endpoints are generated.
-   * <p>
-   * If the {@code --registry_class} flag is present, its argument must be a Java class name. A
-   * class with the given name will be generated, containing a constant list of all extension
-   * classes generated during the compile. This list is suitable for passing to Wire's constructor
-   * at runtime for constructing its internal extension registry.
-   * <p>
-   * Unless the {@code --no_options} flag is supplied, code will be emitted for options on messages
-   * and fields.  The presence of options on a message will result in a static member named
-   * "MESSAGE_OPTIONS", initialized with the options and their values.   The presence of options on
-   * a field (other than the standard options "default", "deprecated", and "packed") will result in
-   * a static member named "FIELD_OPTIONS_&lt;field name&gt;" in the generated code, initialized
-   * with the field option values.
-   * <p>
-   * Regardless of the value of the {@code --no_options} flag, code will be emitted for all
-   * enum value options listed in the {@code --enum_options} flag. The resulting code will contain
-   * a public static field for each option used within a particular enum type.
-   * </p>
+   * Runs the compiler.  See {@link CommandLineOptions} for command line options.
    */
-  public static void main(String... args) throws Exception {
-    String protoPath = null;
-    String javaOut = null;
-    String registryClass = null;
-    List<String> sourceFileNames = new ArrayList<String>();
-    List<String> roots = new ArrayList<String>();
-    boolean emitOptions = true;
-    List<String> enumOptions = new ArrayList<String>();
-    Constructor<?> serviceWriterConstructor = null;
-    List<String> serviceWriterOptions = new ArrayList<String>();
-
-    int index = 0;
-    while (index < args.length) {
-      if (args[index].startsWith(PROTO_PATH_FLAG)) {
-        protoPath = args[index].substring(PROTO_PATH_FLAG.length());
-      } else if (args[index].startsWith(JAVA_OUT_FLAG)) {
-        javaOut = args[index].substring(JAVA_OUT_FLAG.length());
-      } else if (args[index].startsWith(FILES_FLAG)) {
-        File files = new File(args[index].substring(FILES_FLAG.length()));
-        String[] fileNames = new Scanner(files, "UTF-8").useDelimiter("\\A").next().split("\n");
-        sourceFileNames.addAll(Arrays.asList(fileNames));
-      } else if (args[index].startsWith(ROOTS_FLAG)) {
-        roots.addAll(splitArg(args[index], ROOTS_FLAG.length()));
-      } else if (args[index].startsWith(REGISTRY_CLASS_FLAG)) {
-        registryClass = args[index].substring(REGISTRY_CLASS_FLAG.length());
-      } else if (args[index].equals(NO_OPTIONS_FLAG)) {
-        emitOptions = false;
-      } else if (args[index].startsWith(ENUM_OPTIONS_FLAG)) {
-        enumOptions.addAll(splitArg(args[index], ENUM_OPTIONS_FLAG.length()));
-      } else if (args[index].startsWith(SERVICE_WRITER_FLAG)) {
-        serviceWriterConstructor =
-            loadServiceWriter(args[index].substring(SERVICE_WRITER_FLAG.length()));
-      } else if (args[index].startsWith(SERVICE_WRITER_OPT_FLAG)) {
-        serviceWriterOptions.add(args[index].substring(SERVICE_WRITER_OPT_FLAG.length()));
-      } else {
-        sourceFileNames.add(args[index]);
-      }
-      index++;
-    }
-    if (javaOut == null) {
-      System.err.println("Must specify " + JAVA_OUT_FLAG + " flag");
+  public static void main(String... args) {
+    try {
+      new WireCompiler(new CommandLineOptions(args)).compile();
+    } catch (WireException e) {
+      System.err.print("Fatal: ");
+      e.printStackTrace(System.err);
       System.exit(1);
     }
-    if (protoPath == null) {
-      protoPath = System.getProperty("user.dir");
-      System.err.println(PROTO_PATH_FLAG + " flag not specified, using current dir " + protoPath);
-    }
-    WireCompiler wireCompiler =
-        new WireCompiler(protoPath, sourceFileNames, roots, javaOut, registryClass, emitOptions,
-            enumOptions, serviceWriterConstructor, serviceWriterOptions);
-    wireCompiler.compile();
-  }
-
-  private static List<String> splitArg(String arg, int flagLength) {
-    return Arrays.asList(arg.substring(flagLength).split(","));
   }
 
-  private static Constructor<?> loadServiceWriter(String serviceWriterClassName) {
+  private static Constructor<?> loadServiceWriter(String serviceWriterClassName)
+      throws WireException {
     Class<?> serviceWriterClass = null;
     try {
       serviceWriterClass = Class.forName(serviceWriterClassName);
     } catch (ClassNotFoundException e) {
-      System.err.println("Unable to load ServiceWriter class " + serviceWriterClassName + ".");
-      System.exit(1);
+      throw new WireException("Unable to load ServiceWriter class "
+          + serviceWriterClassName + ".", e);
     }
 
     if (!ServiceWriter.class.isAssignableFrom(serviceWriterClass)) {
-      System.err.println(
+      throw new WireException(
           "Class " + serviceWriterClassName + " does not implement ServiceWriter interface.");
-      System.exit(0);
     }
 
     try {
       return serviceWriterClass.getConstructor(JavaWriter.class, List.class);
     } catch (NoSuchMethodException e) {
-      System.err.println("ServiceWriter class "
+      throw new WireException("ServiceWriter class "
           + serviceWriterClassName
           + " needs a constructor 'public "
           + serviceWriterClassName
-          + "(JavaWriter writer, List<String> options)'.");
-      System.exit(1);
+          + "(JavaWriter writer, List<String> options)'.", e);
     }
-
-    return null;
   }
 
+  @Deprecated
   public WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
       String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
-      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions) {
-    this(protoPath, sourceFileNames, roots, outputDirectory, registryClass, emitOptions,
-        enumOptions, serviceWriterConstructor, serviceWriterOptions, new IO.FileIO());
+      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions)
+      throws WireException {
+    this(new CommandLineOptions(protoPath, outputDirectory, sourceFileNames, roots,  registryClass,
+        emitOptions,  new LinkedHashSet<String>(enumOptions), serviceWriterConstructor.getName(),
+        serviceWriterOptions, false, false));
   }
 
-  WireCompiler(String protoPath, List<String> sourceFileNames, List<String> roots,
-      String outputDirectory, String registryClass, boolean emitOptions, List<String> enumOptions,
-      Constructor<?> serviceWriterConstructor, List<String> serviceWriterOptions, IO io) {
-    this.repoPath = protoPath;
-    this.typesToEmit.addAll(roots);
-    this.sourceFileNames = sourceFileNames;
-    this.outputDirectory = outputDirectory;
-    this.registryClass = registryClass;
-    this.emitOptions = emitOptions;
-    this.enumOptions = new LinkedHashSet<String>(enumOptions);
-    this.serviceWriterConstructor = serviceWriterConstructor;
-    this.serviceWriterOptions = serviceWriterOptions;
+  public WireCompiler(CommandLineOptions options) throws WireException {
+    this(options, new IO.FileIO(), new ConsoleWireLogger(options.quiet));
+  }
+
+  WireCompiler(CommandLineOptions options, IO io, WireLogger logger) throws WireException {
+    this.options = options;
     this.io = io;
+    this.log = logger;
+
+    String protoPath = options.protoPath;
+    if (options.javaOut == null) {
+      throw new WireException("Must specify " + CommandLineOptions.JAVA_OUT_FLAG + " flag");
+    }
+    if (options.protoPath == null) {
+      protoPath = System.getProperty("user.dir");
+      System.err.println(
+          CommandLineOptions.PROTO_PATH_FLAG + " flag not specified, using current dir "
+              + protoPath);
+    }
+    if (options.serviceWriter != null) {
+      serviceWriterConstructor =
+          WireCompiler.loadServiceWriter(options.serviceWriter);
+    }
+    this.repoPath = protoPath;
+    this.typesToEmit.addAll(options.roots);
   }
 
-  public void compile() throws IOException {
+  public void compile() throws WireException {
     Map<String, ProtoFile> parsedFiles = new LinkedHashMap<String, ProtoFile>();
 
-    for (String sourceFilename : sourceFileNames) {
+    for (String sourceFilename : options.sourceFileNames) {
       String sourcePath = repoPath + File.separator + sourceFilename;
-      ProtoFile protoFile = io.parse(sourcePath);
-      parsedFiles.put(sourcePath, protoFile);
-
-      loadSymbols(protoFile);
+      try {
+        ProtoFile protoFile = io.parse(sourcePath);
+        parsedFiles.put(sourcePath, protoFile);
+        loadSymbols(protoFile);
+      } catch (IOException e) {
+        throw new WireException("Error loading symbols for " + sourcePath, e);
+      }
     }
 
     if (!typesToEmit.isEmpty()) {
-      System.out.println("Analyzing dependencies of root types.");
+      log.info("Analyzing dependencies of root types.");
       findDependencies(parsedFiles.values());
     }
 
@@ -263,21 +187,36 @@ public void compile() throws IOException {
       this.sourceFileName = entry.getKey();
       this.protoFile = entry.getValue();
       this.protoFileName = protoFileName(protoFile.getFileName());
-      System.out.println("Compiling proto source file " + sourceFileName);
-      compileOne();
+      log.info("Compiling proto source file " + sourceFileName);
+      try {
+        compileOne();
+      } catch (IOException e) {
+        throw new WireException("Error compiling " + entry.getKey(), e);
+      }
     }
 
-    if (registryClass != null) {
-      emitRegistry();
+    if (options.registryClass != null) {
+      int packageClassSep = options.registryClass.lastIndexOf(".");
+      String javaPackage = options.registryClass.substring(0, packageClassSep);
+      String className = options.registryClass.substring(packageClassSep + 1);
+      OutputArtifact artifact = new OutputArtifact(options.javaOut, javaPackage, className);
+      log.artifact(artifact);
+      if (!options.dryRun) {
+        try {
+          emitRegistry(artifact);
+        } catch (IOException e) {
+          throw new WireException("Error emitting registry class " + options.registryClass, e);
+        }
+      }
     }
   }
 
-  boolean emitOptions() {
-    return emitOptions;
+  boolean shouldEmitOptions() {
+    return options.emitOptions;
   }
 
   Set<String> enumOptions() {
-    return enumOptions;
+    return options.enumOptions;
   }
 
   ProtoFile getProtoFile() {
@@ -288,10 +227,6 @@ OptionsMapMaker getOptionsMapMaker() {
     return optionsMapMaker;
   }
 
-  JavaWriter getWriter() {
-    return writer;
-  }
-
   String getEnumDefault(String fullyQualifiedName) {
     return enumDefaults.get(fullyQualifiedName);
   }
@@ -397,19 +332,13 @@ private void compileOne() throws IOException {
     typeBeingGenerated = "";
 
     if (hasExtends()) {
-      try {
-        String className = "Ext_" + protoFileName;
-        String javaPackage = getJavaPackage();
-        writer = io.getJavaWriter(outputDirectory, javaPackage, className);
-        emitExtensionClass();
-
-        String extensionClass = javaPackage + "." + className;
-        System.out.println("wrote extension class " + extensionClass);
-        extensionClasses.add(extensionClass);
-      } finally {
-        if (writer != null) {
-          writer.close();
-        }
+      OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
+          "Ext_" + protoFileName);
+      log.artifact(artifact);
+
+      if (!options.dryRun) {
+        emitExtensionClass(artifact);
+        extensionClasses.add(artifact.fullClassName());
       }
     }
 
@@ -417,7 +346,12 @@ private void compileOne() throws IOException {
       if (shouldEmitType(type.getFullyQualifiedName())) {
         String savedType = typeBeingGenerated;
         typeBeingGenerated += type.getName() + ".";
-        emitMessageClass(type);
+        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
+            type.getName());
+        log.artifact(artifact);
+        if (!options.dryRun) {
+          emitMessageClass(type, artifact);
+        }
         typeBeingGenerated = savedType;
       }
     }
@@ -432,7 +366,12 @@ private void compileOne() throws IOException {
         }
         Service limitedService = new Service(service.getName(), service.getFullyQualifiedName(),
             service.getDocumentation(), service.getOptions(), limitedMethods);
-        emitServiceInterface(limitedService);
+        OutputArtifact artifact = new OutputArtifact(options.javaOut, getJavaPackage(),
+            service.getName());
+        log.artifact(artifact);
+        if (!options.dryRun) {
+          emitServiceInterface(limitedService, artifact);
+        }
       }
     }
   }
@@ -477,14 +416,12 @@ private void getTypes(Type parent, List<Type> types) {
     }
   }
 
-  private void emitRegistry() throws IOException {
-    int packageClassSep = registryClass.lastIndexOf(".");
-    String javaPackage = registryClass.substring(0, packageClassSep);
-    String className = registryClass.substring(packageClassSep + 1);
+  private void emitRegistry(OutputArtifact artifact) throws IOException {
+    JavaWriter writer = null;
     try {
-      writer = io.getJavaWriter(outputDirectory, javaPackage, className);
+      writer = io.getJavaWriter(artifact);
       writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
-      writer.emitPackage(javaPackage);
+      writer.emitPackage(artifact.javaPackage());
 
       writer.emitImports("java.util.List");
       writer.emitEmptyLine();
@@ -497,7 +434,7 @@ private void emitRegistry() throws IOException {
             "java.util.Collections.unmodifiableList");
       }
       writer.emitEmptyLine();
-      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
+      writer.beginType(artifact.className(), "class", EnumSet.of(PUBLIC, FINAL));
       writer.emitEmptyLine();
 
       String classes;
@@ -521,7 +458,7 @@ private void emitRegistry() throws IOException {
       writer.emitEmptyLine();
 
       // Private no-args constructor
-      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
+      writer.beginMethod(null, artifact.className(), EnumSet.of(PRIVATE));
       writer.endMethod();
       writer.endType();
     } finally {
@@ -556,7 +493,7 @@ private boolean shouldEmitServiceMethod(String serviceName, String method) {
         || typesToEmit.contains(serviceName + "#" + method);
   }
 
-  private void findDependencies(Collection<ProtoFile> protoFiles) throws IOException {
+  private void findDependencies(Collection<ProtoFile> protoFiles) throws WireException {
     Set<String> loadedDependencies = new LinkedHashSet<String>();
     int count = typesToEmit.size();
     while (true) {
@@ -572,13 +509,17 @@ private void findDependencies(Collection<ProtoFile> protoFiles) throws IOExcepti
   }
 
   private void findDependenciesHelper(ProtoFile protoFile, Set<String> loadedDependencies)
-      throws IOException {
+      throws WireException {
     // Load symbols from imports
     for (String dependency : protoFile.getDependencies()) {
       if (!loadedDependencies.contains(dependency)) {
         String dep = repoPath + File.separator + dependency;
-        ProtoFile dependencyFile = io.parse(dep);
-        loadSymbols(dependencyFile);
+        try {
+          ProtoFile dependencyFile = io.parse(dep);
+          loadSymbols(dependencyFile);
+        } catch (IOException e) {
+          throw new WireException("Error loading symbols for " + dep, e);
+        }
         loadedDependencies.add(dependency);
       }
     }
@@ -808,9 +749,10 @@ private String protoFileName(String path) {
     return path;
   }
 
-  private void emitMessageClass(Type type) throws IOException {
+  private void emitMessageClass(Type type, OutputArtifact artifact) throws IOException {
+    JavaWriter writer = null;
     try {
-      writer = io.getJavaWriter(outputDirectory, getJavaPackage(), type.getName());
+      writer = io.getJavaWriter(artifact);
       writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
       writer.emitSingleLineComment("Source file: %s", sourceFileName);
       writer.emitPackage(getJavaPackage());
@@ -843,7 +785,7 @@ private void emitMessageClass(Type type) throws IOException {
         imports.add("com.squareup.wire.ExtendableMessage");
         imports.add("com.squareup.wire.Extension");
       }
-      if (emitOptions) {
+      if (options.emitOptions) {
         if (hasFieldOption(types)) {
           imports.add("com.google.protobuf.FieldOptions");
         }
@@ -859,7 +801,7 @@ private void emitMessageClass(Type type) throws IOException {
       getExternalTypes(type, externalTypes);
 
       Map<String, ?> optionsMap = null;
-      if (emitOptions) {
+      if (options.emitOptions) {
         if (type instanceof MessageType) {
           optionsMap = optionsMapMaker.createMessageOptionsMap((MessageType) type);
           optionsMapMaker.getOptionTypes(optionsMap, externalTypes);
@@ -881,8 +823,8 @@ private void emitMessageClass(Type type) throws IOException {
       labels.remove(Label.OPTIONAL);
 
       MessageWriter messageWriter = new MessageWriter(this);
-      messageWriter.emitHeader(imports, datatypes, labels);
-      messageWriter.emitType(type, protoFile.getPackageName() + ".", optionsMap, true);
+      messageWriter.emitHeader(writer, imports, datatypes, labels);
+      messageWriter.emitType(writer, type, protoFile.getPackageName() + ".", optionsMap, true);
     } finally {
       if (writer != null) {
         writer.close();
@@ -890,15 +832,15 @@ private void emitMessageClass(Type type) throws IOException {
     }
   }
 
-  private void emitServiceInterface(Service service) throws IOException {
+  private void emitServiceInterface(Service service, OutputArtifact artifact) throws IOException {
     if (serviceWriterConstructor == null) return;
-
+    JavaWriter writer = null;
     try {
-      writer = io.getJavaWriter(outputDirectory, getJavaPackage(), service.getName());
+      writer = io.getJavaWriter(artifact);
       ServiceWriter serviceWriter;
       try {
-        List<String> options = new ArrayList<String>(serviceWriterOptions);
-        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer, options);
+        serviceWriter = (ServiceWriter) serviceWriterConstructor.newInstance(writer,
+            new ArrayList<String>(options.serviceWriterOptions));
       } catch (Exception e) {
         throw new IllegalStateException(
             "Unable to construct an instance of " + serviceWriterConstructor.getDeclaringClass()
@@ -907,7 +849,7 @@ private void emitServiceInterface(Service service) throws IOException {
 
       writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
       writer.emitSingleLineComment("Source file: %s", sourceFileName);
-      writer.emitPackage(getJavaPackage());
+      writer.emitPackage(artifact.javaPackage());
 
       Set<String> imports = new LinkedHashSet<String>();
       List<String> externalTypes = new ArrayList<String>();
@@ -987,7 +929,7 @@ private String getPackageFromFullyQualifiedJavaName(String fqName) {
 
   private boolean hasExtends() {
     List<ExtendDeclaration> declarations = protoFile.getExtendDeclarations();
-    if (!emitOptions()) {
+    if (!shouldEmitOptions()) {
       for (ExtendDeclaration declaration : declarations) {
         String name = declaration.getFullyQualifiedName();
         if (!(isFieldOptions(name) || isMessageOptions(name))) {
@@ -998,50 +940,59 @@ private boolean hasExtends() {
     return !declarations.isEmpty();
   }
 
-  private void emitExtensionClass() throws IOException {
-    writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
-    writer.emitSingleLineComment("Source file: %s", sourceFileName);
-    writer.emitPackage(getJavaPackage());
+  private void emitExtensionClass(OutputArtifact artifact) throws IOException {
+    JavaWriter writer = null;
+    try {
+      writer = io.getJavaWriter(artifact);
 
-    Set<String> imports = new LinkedHashSet<String>();
-    if (hasByteStringExtension()) {
-      imports.add("okio.ByteString");
-    }
-    imports.add("com.squareup.wire.Extension");
-    if (hasRepeatedExtension()) {
-      imports.add("java.util.List");
-    }
-    List<String> extensionTypes = getExtensionTypes();
+      writer.emitSingleLineComment(CODE_GENERATED_BY_WIRE);
+      writer.emitSingleLineComment("Source file: %s", sourceFileName);
+      writer.emitPackage(getJavaPackage());
 
-    if (emitOptions()) {
-      imports.addAll(extensionTypes);
-    } else {
-      for (String extensionType : extensionTypes) {
-        if (!isOptionType(extensionType)) {
-          imports.add(extensionType);
+      Set<String> imports = new LinkedHashSet<String>();
+      if (hasByteStringExtension()) {
+        imports.add("okio.ByteString");
+      }
+      imports.add("com.squareup.wire.Extension");
+      if (hasRepeatedExtension()) {
+        imports.add("java.util.List");
+      }
+      List<String> extensionTypes = getExtensionTypes();
+
+      if (shouldEmitOptions()) {
+        imports.addAll(extensionTypes);
+      } else {
+        for (String extensionType : extensionTypes) {
+          if (!isOptionType(extensionType)) {
+            imports.add(extensionType);
+          }
         }
       }
-    }
-    writer.emitImports(imports);
-    writer.emitEmptyLine();
+      writer.emitImports(imports);
+      writer.emitEmptyLine();
 
-    String className = "Ext_" + protoFileName;
-    writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
-    writer.emitEmptyLine();
+      String className = "Ext_" + protoFileName;
+      writer.beginType(className, "class", EnumSet.of(PUBLIC, FINAL));
+      writer.emitEmptyLine();
 
-    // Private no-args constructor
-    writer.beginMethod(null, className, EnumSet.of(PRIVATE));
-    writer.endMethod();
-    writer.emitEmptyLine();
+      // Private no-args constructor
+      writer.beginMethod(null, className, EnumSet.of(PRIVATE));
+      writer.endMethod();
+      writer.emitEmptyLine();
 
-    emitExtensions();
-    writer.endType();
+      emitExtensions(writer);
+      writer.endType();
+    } finally {
+      if (writer != null) {
+        writer.close();
+      }
+    }
   }
 
-  private void emitExtensions() throws IOException {
+  private void emitExtensions(JavaWriter writer) throws IOException {
     for (ExtendDeclaration extend : protoFile.getExtendDeclarations()) {
       String fullyQualifiedName = extend.getFullyQualifiedName();
-      if (!emitOptions() && isOptionType(fullyQualifiedName)) {
+      if (!shouldEmitOptions() && isOptionType(fullyQualifiedName)) {
         continue;
       }
       String javaName = javaName(null, fullyQualifiedName);
diff --git a/wire-compiler/src/main/java/com/squareup/wire/WireException.java b/wire-compiler/src/main/java/com/squareup/wire/WireException.java
new file mode 100644
index 00000000..be42ec24
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/WireException.java
@@ -0,0 +1,11 @@
+package com.squareup.wire;
+
+public class WireException extends Exception {
+  public WireException(String message) {
+    super(message);
+  }
+
+  public WireException(String message, Throwable throwable) {
+    super(message, throwable);
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java b/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java
new file mode 100644
index 00000000..5143c9e7
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/logger/ConsoleWireLogger.java
@@ -0,0 +1,32 @@
+package com.squareup.wire.logger;
+
+import com.squareup.wire.OutputArtifact;
+
+
+public final class ConsoleWireLogger implements WireLogger {
+  private final boolean isQuiet;
+
+  public ConsoleWireLogger(boolean quiet) {
+    this.isQuiet = quiet;
+  }
+
+  public void info(String message) {
+    if (!isQuiet) {
+      System.out.println(message);
+    }
+  }
+
+  public void artifact(OutputArtifact artifact) {
+    String msg;
+    if (isQuiet) {
+      msg = artifact.file().toString();
+    } else {
+      msg = "Writing generated code to " + artifact.file().toString();
+    }
+    System.out.println(msg);
+  }
+
+  public void error(String message) {
+    System.err.println(message);
+  }
+}
diff --git a/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java b/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java
new file mode 100644
index 00000000..fdc1e357
--- /dev/null
+++ b/wire-compiler/src/main/java/com/squareup/wire/logger/WireLogger.java
@@ -0,0 +1,9 @@
+package com.squareup.wire.logger;
+
+import com.squareup.wire.OutputArtifact;
+
+public interface WireLogger {
+  void error(String message);
+  void artifact(OutputArtifact artifact);
+  void info(String message);
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java b/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java
new file mode 100644
index 00000000..935cf581
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/CommandLineOptionsTest.java
@@ -0,0 +1,132 @@
+package com.squareup.wire;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public class CommandLineOptionsTest {
+
+  @Test public void protoPath() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.protoPath);
+
+    options = new CommandLineOptions("--proto_path=foo/bar");
+    assertEquals("foo/bar", options.protoPath);
+  }
+
+  @Test public void javaOut() throws Exception{
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.javaOut);
+
+    options = new CommandLineOptions("--java_out=baz/qux");
+    assertEquals("baz/qux", options.javaOut);
+  }
+
+  @Test public void sourceFileNames() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.sourceFileNames.isEmpty());
+
+    List<String> expected = new ArrayList<String>();
+    options = new CommandLineOptions("baz", "qux");
+    expected.add("baz");
+    expected.add("qux");
+    assertEquals(expected, options.sourceFileNames);
+  }
+
+  @Test public void sourceFileNamesFromInclude() throws Exception {
+    File tmpFile = File.createTempFile("proto", ".include");
+    try {
+      PrintWriter out = new PrintWriter(new FileOutputStream(tmpFile));
+      out.println("foo");
+      out.println("bar");
+      out.close();
+
+      CommandLineOptions options = new CommandLineOptions("--files=" + tmpFile.getAbsolutePath());
+      List<String> expected = new ArrayList<String>();
+      expected.add("foo");
+      expected.add("bar");
+      assertEquals(expected, options.sourceFileNames);
+
+      // Test both --files and bare filenames together
+      options = new CommandLineOptions("--files=" + tmpFile.getAbsolutePath(), "baz");
+      expected.add("baz");
+      assertEquals(expected, options.sourceFileNames);
+    } finally {
+      tmpFile.delete();
+    }
+  }
+
+  @Test public void roots() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.roots.isEmpty());
+
+    options = new CommandLineOptions("--roots=com.example.foo");
+    List<String> expected = new ArrayList<String>();
+    expected.add("com.example.foo");
+    assertEquals(expected, options.roots);
+    options = new CommandLineOptions("--roots=com.example.foo,com.example.bar");
+    expected.add("com.example.bar");
+    assertEquals(expected, options.roots);
+  }
+
+  @Test public void registryClass() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.registryClass);
+    options = new CommandLineOptions("--registry_class=com.example.RegistryClass");
+    assertEquals("com.example.RegistryClass", options.registryClass);
+  }
+
+  @Test public void  emitOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.emitOptions);
+
+    options = new CommandLineOptions("--no_options");
+    assertFalse(options.emitOptions);
+  }
+
+  @Test public void enumOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.enumOptions.isEmpty());
+
+    options = new CommandLineOptions("--enum_options=foo");
+    Set<String> expected = new HashSet<String>();
+    expected.add("foo");
+    assertEquals(expected, options.enumOptions);
+    options = new CommandLineOptions("--enum_options=foo,bar");
+    expected.add("bar");
+    assertEquals(expected, options.enumOptions);
+  }
+
+  @Test public void serviceWriter() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertNull(options.serviceWriter);
+
+    String name = SimpleServiceWriter.class.getName();
+    options = new CommandLineOptions("--service_writer=" + name);
+    assertEquals("com.squareup.wire.SimpleServiceWriter", options.serviceWriter);
+  }
+
+  @Test public void serviceWriterOptions() throws Exception {
+    CommandLineOptions options = new CommandLineOptions();
+    assertTrue(options.serviceWriterOptions.isEmpty());
+
+    options = new CommandLineOptions("--service_writer_opt=foo");
+    List<String> expected = new ArrayList<String>();
+    expected.add("foo");
+    assertEquals(expected, options.serviceWriterOptions);
+    options = new CommandLineOptions("--service_writer_opt=foo", "--service_writer_opt=bar");
+    expected.add("bar");
+    assertEquals(expected, options.serviceWriterOptions);
+  }
+
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java b/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java
new file mode 100644
index 00000000..3a8ac61e
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/OutputArtifactTest.java
@@ -0,0 +1,18 @@
+package com.squareup.wire;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class OutputArtifactTest {
+
+  @Test public void testOutputArtifact() {
+    OutputArtifact artifact = new OutputArtifact("foo/bar", "com.company", "Foo");
+    assertEquals("foo/bar", artifact.outputDirectory());
+    assertEquals("com.company", artifact.javaPackage());
+    assertEquals("Foo", artifact.className());
+    assertEquals("foo/bar/com/company", artifact.dir().toString());
+    assertEquals("foo/bar/com/company/Foo.java", artifact.file().toString());
+    assertEquals("com.company.Foo", artifact.fullClassName());
+  }
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
index e3b8bc1d..10f121ab 100644
--- a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerErrorTest.java
@@ -18,6 +18,7 @@
 import com.squareup.javawriter.JavaWriter;
 import com.squareup.protoparser.ProtoFile;
 import com.squareup.protoparser.ProtoSchemaParser;
+import com.squareup.wire.logger.MockWireLogger;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.StringReader;
@@ -56,10 +57,10 @@ public ProtoFile parse(String filename) throws IOException {
     }
 
     @Override
-    public JavaWriter getJavaWriter(String javaOut, String javaPackage, String className)
+    public JavaWriter getJavaWriter(OutputArtifact outputArtifact)
         throws IOException {
       StringWriter writer = new StringWriter();
-      writers.put(javaPackage + "." + className, writer);
+      writers.put(outputArtifact.fullClassName(), writer);
       return new JavaWriter(writer);
     }
 
@@ -79,13 +80,14 @@ public JavaWriter getJavaWriter(String javaOut, String javaPackage, String class
   private Map<String, String> compile(String source) {
     StringIO io = new StringIO("test.proto", source);
 
-    @SuppressWarnings("unchecked")
-    WireCompiler compiler = new WireCompiler(".", Arrays.asList("test.proto"),
-        new ArrayList<String>(), ".", null, true, Collections.EMPTY_LIST, null,
-        Collections.EMPTY_LIST, io);
+    CommandLineOptions options = new CommandLineOptions(".",  ".", Arrays.asList("test.proto"),
+        new ArrayList<String>(), null, true, Collections.<String>emptySet(), null,
+        Collections.<String>emptyList(), false, false);
+
+
     try {
-      compiler.compile();
-    } catch (IOException e) {
+      new WireCompiler(options, io, new MockWireLogger()).compile();
+    } catch (WireException e) {
       fail();
     }
     return io.getOutput();
diff --git a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
index 4f0fb963..d8ba21b8 100644
--- a/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
+++ b/wire-compiler/src/test/java/com/squareup/wire/WireCompilerTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.javawriter.JavaWriter;
 import com.squareup.protoparser.Service;
+import com.squareup.wire.logger.StringWireLogger;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -34,7 +35,7 @@
 import static org.junit.Assert.fail;
 
 public class WireCompilerTest {
-
+  private StringWireLogger logger;
   private File testDir;
 
   @Before public void setUp() {
@@ -87,7 +88,7 @@ private void testProto(String[] sources, String[] outputs, String serviceWriter,
     }
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(filesAfter.toString(), outputs.length, filesAfter.size());
@@ -107,7 +108,7 @@ private void testProtoNoOptions(String[] sources, String[] outputs) throws Excep
     args[3] = "--java_out=" + testDir.getAbsolutePath();
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(outputs.length, filesAfter.size());
@@ -126,7 +127,7 @@ private void testProtoWithRegistry(String[] sources, String registryClass, Strin
     args[2] = "--registry_class=" + registryClass;
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(outputs.length, filesAfter.size());
@@ -138,18 +139,29 @@ private void testProtoWithRegistry(String[] sources, String registryClass, Strin
 
   private void testProtoWithRoots(String[] sources, String roots, String[] outputs)
       throws Exception {
+    String[] extraArgs = {};
+    this.testProtoWithRoots(sources, roots, outputs, extraArgs);
+  }
+
+  private void testProtoWithRoots(String[] sources, String roots, String[] outputs,
+      String[] extraArgs)
+      throws Exception {
     int numFlags = 4;
-    String[] args = new String[numFlags + sources.length];
-    args[0] = "--proto_path=../wire-runtime/src/test/proto";
-    args[1] = "--java_out=" + testDir.getAbsolutePath();
-    args[2] = "--service_writer=com.squareup.wire.SimpleServiceWriter";
-    args[3] = "--roots=" + roots;
-    System.arraycopy(sources, 0, args, numFlags, sources.length);
+    String[] args = new String[numFlags + sources.length + extraArgs.length];
+    int index = 0;
+    args[index++] = "--proto_path=../wire-runtime/src/test/proto";
+    args[index++] = "--java_out=" + testDir.getAbsolutePath();
+    args[index++] = "--service_writer=com.squareup.wire.SimpleServiceWriter";
+    args[index++] = "--roots=" + roots;
+    for (int i = 0; i < extraArgs.length; i++) {
+      args[index++] = extraArgs[i];
+    }
+    System.arraycopy(sources, 0, args, index, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
-    assertEquals(outputs.length, filesAfter.size());
+    assertEquals("Wrong number of files written", outputs.length, filesAfter.size());
 
     for (String output : outputs) {
       assertFilesMatch(testDir, output);
@@ -167,7 +179,7 @@ private void testLimitedServiceGeneration(String[] sources, String roots, String
     args[4] = "--roots=" + roots;
     System.arraycopy(sources, 0, args, numFlags, sources.length);
 
-    WireCompiler.main(args);
+    invokeCompiler(args);
 
     List<String> filesAfter = getAllFiles(testDir);
     assertEquals(filesAfter.toString(), outputs.length, filesAfter.size());
@@ -177,6 +189,7 @@ private void testLimitedServiceGeneration(String[] sources, String roots, String
     }
   }
 
+
   @Test public void testPerson() throws Exception {
     String[] sources = {
         "person.proto"
@@ -587,6 +600,26 @@ public TestServiceWriter(JavaWriter writer, List<String> options) {
     testProtoWithRoots(sources, roots, outputs);
   }
 
+  @Test public void testDryRun() throws Exception {
+    String[] sources = {
+        "service_root.proto"
+    };
+
+    String[] outputs = { };
+    String roots = "squareup.wire.protos.roots.TheService";
+    // When running with the --dry_run flag and --quiet, only the names of the output
+    // files should be printed to the log.
+    String[] extraArgs = {
+        "--dry_run",
+        "--quiet"
+    };
+    testProtoWithRoots(sources, roots, outputs, extraArgs);
+    assertEquals(testDir.getAbsolutePath().toString() + "/com/squareup/wire/protos/roots/TheRequest.java\n"
+            + testDir.getAbsolutePath().toString() + "/com/squareup/wire/protos/roots/TheResponse.java\n"
+            + testDir.getAbsolutePath().toString() + "/com/squareup/wire/protos/roots/TheService.java\n",
+        logger.getLog());
+  }
+
   @Test public void sanitizeJavadocStripsTrailingWhitespace() {
     String input = "The quick brown fox  \nJumps over  \n\t \t\nThe lazy dog  ";
     String expected = "The quick brown fox\nJumps over\n\nThe lazy dog";
@@ -649,6 +682,12 @@ private void getAllFilesHelper(File root, List<String> files) {
     }
   }
 
+  private void invokeCompiler(String[] args) throws WireException {
+    CommandLineOptions options = new CommandLineOptions(args);
+    logger = new StringWireLogger(options.quiet);
+    new WireCompiler(options, new IO.FileIO(), logger).compile();
+  }
+
   private void assertFilesMatch(File outputDir, String path) throws FileNotFoundException {
     File expectedFile = new File("../wire-runtime/src/test/java/" + path);
     File actualFile = new File(outputDir, path);
diff --git a/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java b/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java
new file mode 100644
index 00000000..d0e21b96
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/logger/MockWireLogger.java
@@ -0,0 +1,16 @@
+package com.squareup.wire.logger;
+
+import com.squareup.wire.OutputArtifact;
+
+
+public class MockWireLogger implements WireLogger {
+
+  @Override public void error(String message) {
+  }
+
+  @Override public void artifact(OutputArtifact artifact) {
+  }
+
+  @Override public void info(String message) {
+  }
+}
diff --git a/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java b/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java
new file mode 100644
index 00000000..2dd89ee2
--- /dev/null
+++ b/wire-compiler/src/test/java/com/squareup/wire/logger/StringWireLogger.java
@@ -0,0 +1,34 @@
+package com.squareup.wire.logger;
+
+import com.squareup.wire.OutputArtifact;
+
+
+public final class StringWireLogger implements WireLogger {
+  private final boolean isQuiet;
+  private StringBuilder buffer = new StringBuilder();
+
+  public StringWireLogger(boolean quiet) {
+    this.isQuiet = quiet;
+  }
+
+  @Override public void error(String message) {
+    buffer.append(message);
+    buffer.append('\n');
+  }
+
+  @Override public void artifact(OutputArtifact artifact) {
+    buffer.append(artifact.file().toString());
+    buffer.append('\n');
+  }
+
+  @Override public void info(String message) {
+    if (!isQuiet) {
+      buffer.append(message);
+      buffer.append('\n');
+    }
+  }
+
+  public String getLog() {
+    return buffer.toString();
+  }
+}
