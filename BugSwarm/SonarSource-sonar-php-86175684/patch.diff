diff --git a/its/ruling/src/test/resources/expected/php-S1808.json b/its/ruling/src/test/resources/expected/php-S1808.json
index 62d1f0643f..ef5bec9376 100755
--- a/its/ruling/src/test/resources/expected/php-S1808.json
+++ b/its/ruling/src/test/resources/expected/php-S1808.json
@@ -7288,47 +7288,6 @@
 71,
 92,
 ],
-'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/containers/container10.php':[
-10,
-10,
-],
-'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/containers/container11.php':[
-8,
-8,
-],
-'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/containers/container12.php':[
-8,
-8,
-10,
-],
-'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/containers/container13.php':[
-8,
-8,
-12,
-12,
-],
-'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/containers/container9.php':[
-13,
-13,
-14,
-15,
-20,
-25,
-25,
-31,
-31,
-37,
-37,
-49,
-49,
-51,
-52,
-53,
-54,
-55,
-58,
-58,
-],
 'project:symfony/Symfony/Component/DependencyInjection/Tests/Fixtures/includes/createphar.php':[
 9,
 ],
@@ -7448,14 +7407,10 @@
 'project:symfony/Symfony/Component/Form/Extension/Core/Type/FormType.php':[
 88,
 ],
-'project:symfony/Symfony/Component/Form/Extension/Core/Type/MoneyType.php':[
-32,
-],
 'project:symfony/Symfony/Component/Form/Extension/Core/Type/TimeType.php':[
 135,
 ],
 'project:symfony/Symfony/Component/Form/Extension/Csrf/Type/FormTypeCsrfExtension.php':[
-87,
 111,
 ],
 'project:symfony/Symfony/Component/Form/Extension/DependencyInjection/DependencyInjectionExtension.php':[
@@ -8088,7 +8043,6 @@
 317,
 338,
 358,
-373,
 382,
 404,
 ],
@@ -8109,17 +8063,12 @@
 'project:symfony/Symfony/Component/Form/Tests/Extension/Validator/Constraints/FormValidatorTest.php':[
 174,
 219,
-228,
-242,
 258,
 268,
-282,
-307,
 424,
 429,
 452,
 457,
-603,
 712,
 715,
 ],
@@ -8143,17 +8092,6 @@
 24,
 28,
 ],
-'project:symfony/Symfony/Component/Form/Tests/FormFactoryTest.php':[
-401,
-410,
-452,
-480,
-488,
-513,
-521,
-546,
-554,
-],
 'project:symfony/Symfony/Component/Form/Tests/FormRegistryTest.php':[
 65,
 68,
@@ -8802,9 +8740,6 @@
 184,
 233,
 ],
-'project:symfony/Symfony/Component/Security/Http/Tests/Firewall/AnonymousAuthenticationListenerTest.php':[
-47,
-],
 'project:symfony/Symfony/Component/Security/Http/Tests/Firewall/BasicAuthenticationListenerTest.php':[
 25,
 71,
diff --git a/php-checks/src/main/java/org/sonar/php/checks/FormattingStandardCheck.java b/php-checks/src/main/java/org/sonar/php/checks/FormattingStandardCheck.java
index 7620f06fc2..1253c7eff9 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/FormattingStandardCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/FormattingStandardCheck.java
@@ -19,69 +19,51 @@
  */
 package org.sonar.php.checks;
 
-import com.sonar.sslr.api.AstNode;
+import com.google.common.collect.ImmutableList;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
-import org.sonar.php.api.PHPPunctuator;
+import org.sonar.php.api.PHPKeyword;
 import org.sonar.php.checks.formatting.ControlStructureSpacingCheck;
 import org.sonar.php.checks.formatting.CurlyBraceCheck;
 import org.sonar.php.checks.formatting.ExtendsImplementsLineCheck;
+import org.sonar.php.checks.formatting.FormattingCheck;
 import org.sonar.php.checks.formatting.FunctionSpacingCheck;
 import org.sonar.php.checks.formatting.IndentationCheck;
 import org.sonar.php.checks.formatting.NamespaceAndUseStatementCheck;
 import org.sonar.php.checks.formatting.PunctuatorSpacingCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.checks.utils.CheckUtils;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.expression.ExpressionTree;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
 import org.sonar.squidbridge.annotations.SqaleSubCharacteristic;
-import org.sonar.squidbridge.checks.SquidCheck;
-import org.sonar.sslr.grammar.GrammarRuleKey;
-import org.sonar.sslr.parser.LexerlessGrammar;
 
-import javax.annotation.Nullable;
-
-import java.util.Arrays;
+import java.util.List;
 
 @Rule(
-  key = "S1808",
+  key = FormattingStandardCheck.KEY,
   name = "Source code should comply with formatting standards",
   priority = Priority.MINOR,
   tags = {Tags.CONVENTION, Tags.PSR2})
 @SqaleSubCharacteristic(RulesDefinition.SubCharacteristics.READABILITY)
 @SqaleConstantRemediation("1min")
-public class FormattingStandardCheck extends SquidCheck<LexerlessGrammar> {
-
-  private static final GrammarRuleKey[] CLASS_AND_FUNCTION = {
-    PHPGrammar.CLASS_DECLARATION,
-    PHPGrammar.INTERFACE_DECLARATION,
-    PHPGrammar.TRAIT_ADAPTATIONS,
-    PHPGrammar.METHOD_DECLARATION,
-    PHPGrammar.FUNCTION_DECLARATION
-  };
-
-  private static final GrammarRuleKey[] CONTROL_STRUCTURE = {
-    PHPGrammar.IF_STATEMENT,
-    PHPGrammar.ELSEIF_CLAUSE,
-    PHPGrammar.ELSE_CLAUSE,
-    PHPGrammar.DO_WHILE_STATEMENT,
-    PHPGrammar.WHILE_STATEMENT,
-    PHPGrammar.FOR_STATEMENT,
-    PHPGrammar.FOREACH_STATEMENT,
-    PHPGrammar.SWITCH_STATEMENT,
-    PHPGrammar.TRY_STATEMENT,
-    PHPGrammar.CATCH_STATEMENT,
-    PHPGrammar.FINALLY_STATEMENT
+public class FormattingStandardCheck extends PHPVisitorCheck {
+
+  public static final String KEY = "S1808";
+
+  private static final FormattingCheck[] SUB_CHECKS = {
+    new NamespaceAndUseStatementCheck(),
+    new CurlyBraceCheck(),
+    new PunctuatorSpacingCheck(),
+    new FunctionSpacingCheck(),
+    new ControlStructureSpacingCheck(),
+    new IndentationCheck(),
+    new ExtendsImplementsLineCheck()
   };
 
-  private final NamespaceAndUseStatementCheck namespaceAndUseStatementCheck = new NamespaceAndUseStatementCheck();
-  private final CurlyBraceCheck curlyBraceCheck = new CurlyBraceCheck();
-  private final PunctuatorSpacingCheck punctuatorSpacingCheck = new PunctuatorSpacingCheck();
-  private final FunctionSpacingCheck functionSpacingCheck = new FunctionSpacingCheck();
-  private final ControlStructureSpacingCheck controlStructureSpacingCheck = new ControlStructureSpacingCheck();
-  private final IndentationCheck indentationCheck = new IndentationCheck();
-  private final ExtendsImplementsLineCheck extendsImplementsLineCheck = new ExtendsImplementsLineCheck();
-
   /**
    * Namespace and use statement
    */
@@ -205,44 +187,34 @@
     type = "BOOLEAN")
   public boolean isExtendsAndImplementsLine = true;
 
-  @Override
-  public void init() {
-    subscribeTo(
-      PHPGrammar.NAMESPACE_STATEMENT,
-      PHPGrammar.PARAMETER_LIST,
-      PHPGrammar.FUNCTION_CALL_PARAMETER_LIST,
-      PHPGrammar.FUNCTION_EXPRESSION,
-      PHPGrammar.USE_STATEMENT);
-    subscribeTo(CLASS_AND_FUNCTION);
-    subscribeTo(CONTROL_STRUCTURE);
-    subscribeTo(PHPPunctuator.RPARENTHESIS);
+  private static final List<String> INTERNAL_FUNCTIONS = ImmutableList.of(
+    PHPKeyword.ECHO.getValue(),
+    PHPKeyword.ISSET.getValue(),
+    PHPKeyword.EMPTY.getValue(),
+    PHPKeyword.INCLUDE_ONCE.getValue(),
+    PHPKeyword.INCLUDE.getValue(),
+    PHPKeyword.EVAL.getValue(),
+    PHPKeyword.REQUIRE.getValue(),
+    PHPKeyword.REQUIRE_ONCE.getValue(),
+    PHPKeyword.CLONE.getValue(),
+    PHPKeyword.PRINT.getValue(),
+    PHPKeyword.HALT_COMPILER.getValue()
+  );
+
+  public boolean isInternalFunction(ExpressionTree callee) {
+    String calleeString = CheckUtils.asString(callee);
+    return INTERNAL_FUNCTIONS.contains(calleeString);
   }
 
   @Override
-  public void visitNode(AstNode astNode) {
-    namespaceAndUseStatementCheck.visitNode(this, astNode);
-    curlyBraceCheck.visitNode(this, astNode);
-    punctuatorSpacingCheck.visitNode(this, astNode);
-    functionSpacingCheck.visitNode(this, astNode);
-    controlStructureSpacingCheck.visitNode(this, astNode);
-    indentationCheck.visitNode(this, astNode);
-    extendsImplementsLineCheck.visitNode(this, astNode);
+  public void visitScript(ScriptTree tree) {
+    for (FormattingCheck subCheck : SUB_CHECKS) {
+      subCheck.checkFormat(this, tree);
+    }
   }
 
-  @Override
-  public void leaveFile(@Nullable AstNode astNode) {
-    namespaceAndUseStatementCheck.leaveFile();
+  public void reportIssue(String msg, Tree tree) {
+    context().newIssue(KEY, msg).tree(tree);
   }
 
-  public void reportIssue(String msg, AstNode node) {
-    getContext().createLineViolation(this, msg, node);
-  }
-
-  public static GrammarRuleKey[] getClassAndFunctionNodes() {
-    return Arrays.copyOf(CLASS_AND_FUNCTION, CLASS_AND_FUNCTION.length);
-  }
-
-  public static GrammarRuleKey[] getControlStructureNodes() {
-    return Arrays.copyOf(CONTROL_STRUCTURE, CONTROL_STRUCTURE.length);
-  }
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/ControlStructureSpacingCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/ControlStructureSpacingCheck.java
index e8d661ea7a..9a8cb8ab23 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/ControlStructureSpacingCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/ControlStructureSpacingCheck.java
@@ -19,89 +19,160 @@
  */
 package org.sonar.php.checks.formatting;
 
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.Token;
+import com.google.common.collect.ImmutableList;
 import org.sonar.php.api.PHPKeyword;
 import org.sonar.php.api.PHPPunctuator;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.checks.utils.TokenVisitor;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.TryStatementTree;
+import org.sonar.plugins.php.api.visitors.PHPSubscriptionCheck;
 
-public class ControlStructureSpacingCheck extends SpacingCheck {
+import javax.annotation.Nullable;
+import java.util.Iterator;
+import java.util.List;
+
+public class ControlStructureSpacingCheck extends PHPSubscriptionCheck implements FormattingCheck {
+
+  private static final String CONTROL_STRUCTURES_KEYWORD_MESSAGE = "between this \"%s\" keyword and the opening %s";
+  private static final String FOR_SEMICOLON_MESSAGE = "Put exactly one space after each \";\" character in the \"for\" statement.";
+  private static final String FOREACH_MESSAGE = "Put exactly one space after and before %s in \"foreach\" statement.";
+  private static final Kind[] CONTROL_STRUCTURES = {
+    Kind.IF_STATEMENT,
+    Kind.ELSEIF_CLAUSE,
+    Kind.ELSE_CLAUSE,
+    Kind.DO_WHILE_STATEMENT,
+    Kind.WHILE_STATEMENT,
+    Kind.FOR_STATEMENT,
+    Kind.FOREACH_STATEMENT,
+    Kind.SWITCH_STATEMENT,
+    Kind.TRY_STATEMENT,
+    Kind.CATCH_BLOCK
+  };
+
+  private FormattingStandardCheck check;
 
   @Override
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (formattingCheck.isOneSpaceBetweenKeywordAndNextToken && node.is(FormattingStandardCheck.getControlStructureNodes())) {
-      checkSpaceBetweenKeywordAndNextNode(formattingCheck, node);
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    this.scanTree(scriptTree);
+  }
+
+  @Override
+  public List<Kind> nodesToVisit() {
+    return ImmutableList.copyOf(CONTROL_STRUCTURES);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (check.isOneSpaceBetweenKeywordAndNextToken) {
+      checkSpaceBetweenKeywordAndNextNode(new TokenVisitor(tree), tree);
     }
-    if (formattingCheck.isOneSpaceAfterForLoopSemicolon && node.is(PHPGrammar.FOR_STATEMENT)) {
-      checkSpaceForStatement(formattingCheck, node);
+    if (check.isOneSpaceAfterForLoopSemicolon && tree.is(Kind.FOR_STATEMENT)) {
+      checkSpaceForStatement(tree);
     }
-    if (formattingCheck.isSpaceForeachStatement && node.is(PHPGrammar.FOREACH_STATEMENT)) {
-      checkForeachStatement(formattingCheck, node);
+    if (check.isSpaceForeachStatement && tree.is(Kind.FOREACH_STATEMENT)) {
+      ForEachStatementTree foreachLoop = (ForEachStatementTree) tree;
+      checkForeachStatement(new TokenVisitor(tree), foreachLoop, foreachLoop.asToken(), foreachLoop.doubleArrowToken());
     }
   }
 
   /**
    * Check there is exactly one space around "as" keyword and "=>" punctuator in foreach statement.
    */
-  private void checkForeachStatement(FormattingStandardCheck formattingCheck, AstNode node) {
-    AstNode foreachExpr = node.getFirstChild(PHPGrammar.FOREACH_EXPR);
-    AstNode asKeyword = foreachExpr.getFirstChild(PHPKeyword.AS);
-    AstNode doubleArrow = foreachExpr.getFirstChild(PHPPunctuator.DOUBLEARROW);
+  private void checkForeachStatement(TokenVisitor tokenVisitor, ForEachStatementTree foreachLoop, SyntaxToken asKeyword, @Nullable SyntaxToken doubleArrow) {
+
+    boolean isSpaceCorrectAs = isExactlyOneSpaceAround(tokenVisitor, asKeyword);
+    boolean isSpaceCorrectDoubleArrow = doubleArrow == null || isExactlyOneSpaceAround(tokenVisitor, doubleArrow);
 
-    boolean isSpaceCorrectAs = isSpaceAround(asKeyword, 1 /* space before*/, 1/* space after */);
-    boolean isSpaceCorrectDoubleArrow = doubleArrow == null || isSpaceAround(doubleArrow, 1/* space before*/, 1/* space after */);
+    String messageDetail = null;
 
-    String keyword = null;
     if (!isSpaceCorrectAs && isSpaceCorrectDoubleArrow) {
-      keyword = "\"" + asKeyword.getTokenOriginalValue() + "\"";
+      messageDetail = "\"as\"";
+
     } else if (isSpaceCorrectAs && !isSpaceCorrectDoubleArrow) {
-      keyword = "\"" + doubleArrow.getTokenOriginalValue() + "\"";
+      messageDetail = "\"=>\"";
+
     } else if (!isSpaceCorrectAs && !isSpaceCorrectDoubleArrow) {
-      keyword = "\"" + asKeyword.getTokenOriginalValue() + "\" and \"" + doubleArrow.getTokenOriginalValue() + "\"";
+     messageDetail = "\"as\" and \"=>\"";
     }
 
-    if (keyword != null) {
-      formattingCheck.reportIssue("Put exactly one space after and before " + keyword + " in \"foreach\" statement.", node);
+    if (messageDetail != null) {
+      check.reportIssue(String.format(FOREACH_MESSAGE, messageDetail), foreachLoop);
     }
   }
 
+  private static boolean isExactlyOneSpaceAround(TokenVisitor tokenVisitor, SyntaxToken token) {
+    return TokenUtils.getNbSpaceBetween(tokenVisitor.prevToken(token), token) == 1
+      && TokenUtils.getNbSpaceBetween(token,tokenVisitor.nextToken(token)) == 1;
+  }
+
   /**
    * Check there is exactly one space after each ";" in for statement.
    */
-  private void checkSpaceForStatement(FormattingStandardCheck formattingCheck, AstNode node) {
-    boolean shouldReportIssue = false;
+  private void checkSpaceForStatement(Tree tree) {
+    Iterator<Tree> iterator = ((PHPTree) tree).childrenIterator();
+    Tree next;
+    Tree previous = null;
+
+    while (iterator.hasNext()) {
+      next = iterator.next();
 
-    for (AstNode semicolon : node.getChildren(PHPPunctuator.SEMICOLON)) {
-      Token semicolonToken = semicolon.getToken();
-      Token nextToken = semicolon.getNextAstNode().getToken();
-      int nbSpace = getNbSpaceBetween(semicolonToken, nextToken);
+      if (isSemicolon(previous)) {
+        SyntaxToken semicolonToken = (SyntaxToken) previous;
+        SyntaxToken nextToken = ((PHPTree) next).getFirstToken();
+        int nbSpace = TokenUtils.getNbSpaceBetween(semicolonToken, nextToken);
 
-      if (nbSpace != 1 && isOnSameLine(semicolonToken, nextToken)) {
-        shouldReportIssue = true;
+        if (nbSpace != 1 && TokenUtils.isOnSameLine(semicolonToken, nextToken)) {
+          check.reportIssue(FOR_SEMICOLON_MESSAGE, tree);
+          break;
+        }
       }
+
+      previous = next;
     }
 
-    if (shouldReportIssue) {
-      formattingCheck.reportIssue("Put exactly one space after each \";\" character in the \"for\" statement.", node);
+  }
+
+  private static boolean isSemicolon(@Nullable Tree tree) {
+    return tree != null && tree.is(Kind.TOKEN) && TokenUtils.isType((SyntaxToken) tree, PHPPunctuator.SEMICOLON);
+  }
+
+  private void checkSpaceBetweenKeywordAndNextNode(TokenVisitor tokenVisitor, Tree tree) {
+    SyntaxToken keyword = tokenVisitor.tokenByValue(PHPKeyword.getKeywordValues());
+
+    if (tree.is(Kind.TRY_STATEMENT)) {
+      TryStatementTree tryStatement = (TryStatementTree) tree;
+
+      if (tryStatement.finallyToken() != null) {
+        SyntaxToken finallyKeyword = tryStatement.finallyToken();
+        checkSpaceBetweenKeywordAndNextNode(finallyKeyword, tokenVisitor.nextToken(finallyKeyword));
+      }
     }
+
+    checkSpaceBetweenKeywordAndNextNode(keyword, tokenVisitor.nextToken(keyword));
   }
 
   /**
    * Check that there is exactly one space between a control structure keyword and a opening parenthesis or curly brace.
    */
-  private void checkSpaceBetweenKeywordAndNextNode(FormattingStandardCheck formattingCheck, AstNode controlStructure) {
-    AstNode keyword = controlStructure.getFirstChild(PHPKeyword.values());
-    Token nextToken = keyword.getNextAstNode().getToken();
-
-    if (isType(nextToken, PHPPunctuator.LCURLYBRACE, PHPPunctuator.LPARENTHESIS) && isOnSameLine(keyword.getToken(), nextToken)) {
-      int nbSpace = getNbSpaceBetween(keyword.getToken(), nextToken);
+  private void checkSpaceBetweenKeywordAndNextNode(SyntaxToken keyword, SyntaxToken nextToken) {
+    if (TokenUtils.isType(nextToken, PHPPunctuator.LCURLYBRACE, PHPPunctuator.LPARENTHESIS) && TokenUtils.isOnSameLine(keyword, nextToken)) {
+      int nbSpace = TokenUtils.getNbSpaceBetween(keyword, nextToken);
 
       if (nbSpace != 1) {
-        String endMsg = "between this \"" + keyword.getTokenOriginalValue() + "\" keyword and the opening "
-          + (isType(nextToken, PHPPunctuator.LPARENTHESIS) ? "parenthesis." : "curly brace.");
-        formattingCheck.reportIssue(buildIssueMsg(nbSpace, endMsg), keyword);
+        String endMessage = String.format(
+          CONTROL_STRUCTURES_KEYWORD_MESSAGE,
+          keyword.text(),
+          TokenUtils.isType(nextToken, PHPPunctuator.LPARENTHESIS) ? "parenthesis." : "curly brace.");
+        check.reportIssue(TokenUtils.buildIssueMsg(nbSpace, endMessage), keyword);
       }
+
     }
   }
 
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/CurlyBraceCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/CurlyBraceCheck.java
index 270b22cff1..c3637f234f 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/CurlyBraceCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/CurlyBraceCheck.java
@@ -19,99 +19,215 @@
  */
 package org.sonar.php.checks.formatting;
 
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.Token;
-import org.sonar.php.api.PHPKeyword;
 import org.sonar.php.api.PHPPunctuator;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.checks.utils.TokenVisitor;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.declaration.ClassDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.FunctionDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.MethodDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.ParameterListTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.statement.BlockTree;
+import org.sonar.plugins.php.api.tree.statement.CatchBlockTree;
+import org.sonar.plugins.php.api.tree.statement.DoWhileStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ElseClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ElseifClauseTree;
+import org.sonar.plugins.php.api.tree.statement.ForEachStatementTree;
+import org.sonar.plugins.php.api.tree.statement.ForStatementTree;
+import org.sonar.plugins.php.api.tree.statement.IfStatementTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.tree.statement.SwitchStatementTree;
+import org.sonar.plugins.php.api.tree.statement.TryStatementTree;
+import org.sonar.plugins.php.api.tree.statement.WhileStatementTree;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
 import javax.annotation.Nullable;
+import java.util.List;
 
-public class CurlyBraceCheck {
+public class CurlyBraceCheck extends PHPVisitorCheck implements FormattingCheck {
 
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (node.is(FormattingStandardCheck.getClassAndFunctionNodes()) && formattingCheck.isOpenCurlyBraceForClassAndFunction) {
-      checkLCurlyForClassAndFunction(formattingCheck, getLeftCurlyBraceNode(node));
-    }
-    if (node.is(FormattingStandardCheck.getControlStructureNodes()) && formattingCheck.isOpenCurlyBraceForControlStructures) {
-      checkLCurlyForControlStructure(formattingCheck, getLeftCurlyBraceNode(node));
-    }
-    if (node.is(PHPGrammar.ELSE_CLAUSE, PHPGrammar.CATCH_STATEMENT, PHPGrammar.FINALLY_STATEMENT) && formattingCheck.isClosingCurlyNextToKeyword) {
-      checkRCurlyBraceOnSameLine(formattingCheck, node);
-    }
+  private static final String DECLARATIONS_OPEN_CURLY_MESSAGE = "Move this open curly brace to the beginning of the next line.";
+  private static final String CONTROL_STRUCTURES_OPEN_CURLY_MESSAGE = "Move this open curly brace to the end of the previous line.";
+  private static final String KEYWORD_MESSAGE = "Move this \"%s\" to the same line as the previous closing curly brace.";
+
+  private FormattingStandardCheck check = null;
+
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    super.visitScript(scriptTree);
   }
 
   /**
-   * Check that else, catch or finally keywords are on the same line as the previous closing curly brace.
+   * Class & function declarations open curly brace
    */
-  private void checkRCurlyBraceOnSameLine(FormattingStandardCheck formattingCheck, AstNode node) {
-    Token previsouToken = node.getPreviousAstNode().getLastToken();
-    String keyword = node.getFirstChild(PHPKeyword.ELSE, PHPKeyword.CATCH, PHPKeyword.FINALLY).getTokenOriginalValue();
 
-    if (previsouToken.getType().equals(PHPPunctuator.RCURLYBRACE) && previsouToken.getLine() != node.getTokenLine()) {
-      formattingCheck.reportIssue("Move this \"" + keyword + "\" to the same line as the previous closing curly brace.", node);
+  @Override
+  public void visitClassDeclaration(ClassDeclarationTree tree) {
+    SyntaxToken previousToken = new TokenVisitor(tree).prevToken(tree.openCurlyBraceToken());
+    checkDeclarationOpenCurly(previousToken, tree.openCurlyBraceToken());
+
+    super.visitClassDeclaration(tree);
+  }
+
+  @Override
+  public void visitMethodDeclaration(MethodDeclarationTree tree) {
+    if (tree.body().is(Tree.Kind.BLOCK)) {
+      checkDeclarationOpenCurly(getPreviousToken(tree.parameters()), ((BlockTree) tree.body()).openCurlyBraceToken());
     }
+
+    super.visitMethodDeclaration(tree);
+  }
+
+  @Override
+  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
+    checkDeclarationOpenCurly(getPreviousToken(tree.parameters()), tree.body().openCurlyBraceToken());
+    super.visitFunctionDeclaration(tree);
   }
 
   /**
-   * Check that control structure opening curly brace ends line.
+   *
+   * Returns token previous to closing parenthesis token.
+   * It is required to cover case (which should not raise issues):
+   * <code>
+   *  function g($p1, $p2,
+   *           $p3, $p4
+   *  ) {
+   *  }
+   * </code>
    */
-  private void checkLCurlyForControlStructure(FormattingStandardCheck formattingCheck, @Nullable AstNode leftCurlyBrace) {
-    if (leftCurlyBrace != null && !endsLine(leftCurlyBrace)) {
-      formattingCheck.reportIssue("Move this open curly brace to the end of the previous line.", leftCurlyBrace);
-    }
+  private SyntaxToken getPreviousToken(ParameterListTree parameterList) {
+    return new TokenVisitor(parameterList).prevToken(parameterList.closeParenthesisToken());
   }
 
   /**
-   * Check that class and function opening curly brace starts line.
+   * Control structures open curly brace
    */
-  private void checkLCurlyForClassAndFunction(FormattingStandardCheck formattingCheck, @Nullable AstNode leftCurlyBrace) {
-    if (leftCurlyBrace != null && !isFirstOnline(leftCurlyBrace)) {
-      formattingCheck.reportIssue("Move this open curly brace to the beginning of the next line.", leftCurlyBrace);
+
+  @Override
+  public void visitElseifClause(ElseifClauseTree tree) {
+    checkControlStructureOpenCurly(tree.condition().closeParenthesis(), getOpenCurlyIfBlock(tree.statements()));
+    super.visitElseifClause(tree);
+  }
+
+
+  @Override
+  public void visitIfStatement(IfStatementTree tree) {
+    checkControlStructureOpenCurly(tree.condition().closeParenthesis(), getOpenCurlyIfBlock(tree.statements()));
+
+    // Check else keyword
+    ElseClauseTree elseClause = tree.elseClause();
+    if (elseClause != null) {
+      checkCloseCurlyNextToKeyword(new TokenVisitor(tree).prevToken(elseClause.elseToken()), elseClause.elseToken());
     }
+    super.visitIfStatement(tree);
+  }
+
+  @Override
+  public void visitElseClause(ElseClauseTree tree) {
+    checkControlStructureOpenCurly(tree.elseToken(), getOpenCurlyIfBlock(tree.statements()));
+    super.visitElseClause(tree);
   }
 
-  private boolean isFirstOnline(AstNode curlyBrace) {
-    Token previousToken = curlyBrace.getPreviousAstNode().getLastToken();
+  @Override
+  public void visitWhileStatement(WhileStatementTree tree) {
+    checkControlStructureOpenCurly(tree.condition().closeParenthesis(), getOpenCurlyIfBlock(tree.statements()));
+    super.visitWhileStatement(tree);
+  }
 
-    // In one case, clonsing parenthesis can be on the same line as the opening curly brace
-    if (previousToken.getType().equals(PHPPunctuator.RPARENTHESIS)) {
-      previousToken = curlyBrace.getPreviousAstNode().getPreviousAstNode().getLastToken();
+  @Override
+  public void visitDoWhileStatement(DoWhileStatementTree tree) {
+    if (tree.statement().is(Tree.Kind.BLOCK)) {
+      checkControlStructureOpenCurly(tree.doToken(), ((BlockTree) tree.statement()).openCurlyBraceToken());
     }
+    super.visitDoWhileStatement(tree);
+  }
 
-    return previousToken.getLine() != curlyBrace.getTokenLine();
+  @Override
+  public void visitForStatement(ForStatementTree tree) {
+    checkControlStructureOpenCurly(tree.closeParenthesisToken(), getOpenCurlyIfBlock(tree.statements()));
+    super.visitForStatement(tree);
   }
 
-  private boolean endsLine(AstNode curlyBrace) {
-    return curlyBrace.getPreviousAstNode().getLastToken().getLine() == curlyBrace.getTokenLine();
+  @Override
+  public void visitForEachStatement(ForEachStatementTree tree) {
+    checkControlStructureOpenCurly(tree.closeParenthesisToken(), getOpenCurlyIfBlock(tree.statements()));
+    super.visitForEachStatement(tree);
+  }
+
+  @Override
+  public void visitCatchBlock(CatchBlockTree tree) {
+    checkControlStructureOpenCurly(tree.closeParenthesisToken(), tree.block().openCurlyBraceToken());
+    super.visitCatchBlock(tree);
+  }
+
+  @Override
+  public void visitTryStatement(TryStatementTree tree) {
+    checkControlStructureOpenCurly(tree.tryToken(), tree.block().openCurlyBraceToken());
+    TokenVisitor tokenVisitor = new TokenVisitor(tree);
+
+    // Check catch keyword
+    for (CatchBlockTree catchBlock : tree.catchBlocks()) {
+      checkCloseCurlyNextToKeyword(tokenVisitor.prevToken(catchBlock.catchToken()), catchBlock.catchToken());
+    }
+
+    // Check finally keyword
+    if (tree.finallyBlock() != null) {
+      checkCloseCurlyNextToKeyword(tokenVisitor.prevToken(tree.finallyToken()), tree.finallyToken());
+    }
+    super.visitTryStatement(tree);
+  }
+
+  @Override
+  public void visitSwitchStatement(SwitchStatementTree tree) {
+    checkControlStructureOpenCurly(tree.expression().closeParenthesis(), tree.openCurlyBraceToken());
+    super.visitSwitchStatement(tree);
+  }
+
+  private void checkDeclarationOpenCurly(@Nullable SyntaxToken previousToken, @Nullable SyntaxToken openCurly) {
+    if (!check.isOpenCurlyBraceForClassAndFunction || previousToken == null || openCurly == null) {
+      return;
+    }
+    if (TokenUtils.isOnSameLine(previousToken, openCurly)) {
+      reportIssue(openCurly, DECLARATIONS_OPEN_CURLY_MESSAGE);
+    }
+  }
+
+  private void checkControlStructureOpenCurly(@Nullable SyntaxToken previousToken, @Nullable SyntaxToken openCurly) {
+    if (!check.isOpenCurlyBraceForControlStructures || previousToken == null || openCurly == null) {
+      return;
+    }
+    if (!TokenUtils.isOnSameLine(previousToken, openCurly)) {
+      reportIssue(openCurly, CONTROL_STRUCTURES_OPEN_CURLY_MESSAGE);
+    }
+  }
+
+  private void checkCloseCurlyNextToKeyword(@Nullable SyntaxToken previousToken, @Nullable SyntaxToken keyword) {
+    if (!check.isClosingCurlyNextToKeyword || previousToken == null || keyword == null) {
+      return;
+    }
+    if (isCloseCurly(previousToken) && !TokenUtils.isOnSameLine(previousToken, keyword)) {
+      reportIssue(keyword, String.format(KEYWORD_MESSAGE, keyword.text()));
+    }
+  }
+
+  private static boolean isCloseCurly(SyntaxToken token) {
+    return PHPPunctuator.RCURLYBRACE.getValue().equals(token.text());
   }
 
   @Nullable
-  private AstNode getLeftCurlyBraceNode(AstNode node) {
-    AstNode lcurlyBrace = null;
-    AstNode child = node.getFirstChild(PHPPunctuator.LCURLYBRACE, PHPGrammar.BLOCK, PHPGrammar.STATEMENT, PHPGrammar.METHOD_BODY, PHPGrammar.SWITCH_CASE_LIST);
-
-    if (child == null) {
-      // do nothing
-    } else if (child.is(PHPGrammar.BLOCK, PHPGrammar.SWITCH_CASE_LIST)) {
-      lcurlyBrace = child.getFirstChild(PHPPunctuator.LCURLYBRACE);
-
-    } else if (child.is(PHPGrammar.STATEMENT)) {
-      AstNode stmtChild = child.getFirstChild();
-      if (stmtChild.is(PHPGrammar.BLOCK)) {
-        lcurlyBrace = stmtChild.getFirstChild(PHPPunctuator.LCURLYBRACE);
-      }
-
-    } else if (child.is(PHPGrammar.METHOD_BODY)) {
-      AstNode body = child.getFirstChild(PHPGrammar.BLOCK);
-      if (body != null) {
-        lcurlyBrace = body.getFirstChild(PHPPunctuator.LCURLYBRACE);
-      }
-    } else {
-      lcurlyBrace = child;
+  private SyntaxToken getOpenCurlyIfBlock(List<StatementTree> statements) {
+    if (!statements.isEmpty()) {
+      StatementTree firstStmt = statements.get(0);
+      return firstStmt.is(Tree.Kind.BLOCK) ? ((BlockTree) firstStmt).openCurlyBraceToken() : null;
     }
+    return null;
+  }
 
-    return lcurlyBrace;
+  private void reportIssue(Tree tree, String message) {
+    check.reportIssue(message, tree);
   }
+
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheck.java
index 1c3842e028..d13b8a7bc6 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheck.java
@@ -19,53 +19,56 @@
  */
 package org.sonar.php.checks.formatting;
 
-import com.sonar.sslr.api.AstNode;
-import org.sonar.php.api.PHPKeyword;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.declaration.ClassDeclarationTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
 import javax.annotation.Nullable;
 
-public class ExtendsImplementsLineCheck {
+public class ExtendsImplementsLineCheck extends PHPVisitorCheck implements FormattingCheck {
 
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (formattingCheck.isExtendsAndImplementsLine && node.is(PHPGrammar.CLASS_DECLARATION)) {
-      checkExtendsAndImplementsLine(formattingCheck, node);
+  private static final String MESSAGE = "Move %s to the same line as the declaration of its class name, \"%s\".";
+  private FormattingStandardCheck check;
+
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    super.visitScript(scriptTree);
+  }
+
+  @Override
+  public void visitClassDeclaration(ClassDeclarationTree tree) {
+    if (check.isExtendsAndImplementsLine && tree.is(Kind.CLASS_DECLARATION)) {
+      checkExtendsAndImplementsLine(tree);
     }
+    super.visitClassDeclaration(tree);
   }
 
-  private void checkExtendsAndImplementsLine(FormattingStandardCheck formattingCheck, AstNode node) {
-    AstNode identifier = node.getFirstChild(PHPGrammar.IDENTIFIER);
-    String className = identifier.getTokenOriginalValue();
-    int classNameLine = identifier.getTokenLine();
+  private void checkExtendsAndImplementsLine(ClassDeclarationTree tree) {
+    SyntaxToken classNameToken = tree.name().token();
+    int nameLine = classNameToken.line();
 
-    boolean isExtendsOnClassNameLine = isExtendsOnClassNameLine(node, classNameLine);
-    boolean isImplementsOnClassNameLine = isImplementsOnClassNameLine(node, classNameLine);
+    boolean isExtendsOnClassNameLine = isExtendsOnClassNameLine(tree, nameLine);
+    boolean isImplementsOnClassNameLine = isImplementsOnClassNameLine(tree, nameLine);
 
-    String msg = getIssueMessage(isExtendsOnClassNameLine, isImplementsOnClassNameLine);
+    String partialMessage = getIssuePartialMessage(isExtendsOnClassNameLine, isImplementsOnClassNameLine);
 
-    if (msg != null) {
-      formattingCheck.reportIssue("Move " + msg + " to the same line as the declaration of its class name, \"" + className + "\".", node);
+    if (partialMessage != null) {
+      check.reportIssue(String.format(MESSAGE, partialMessage, classNameToken.text()), tree);
     }
   }
 
-  private boolean isExtendsOnClassNameLine(AstNode classDeclaration, int classNameLine) {
-    AstNode extendsNode = classDeclaration.getFirstChild(PHPGrammar.EXTENDS_FROM);
-    if (extendsNode != null) {
-      return classNameLine == extendsNode.getFirstChild(PHPKeyword.EXTENDS).getTokenLine();
-    }
-
-    return true;
+  private boolean isExtendsOnClassNameLine(ClassDeclarationTree classDeclaration, int classNameLine) {
+    SyntaxToken extendsToken = classDeclaration.extendsToken();
+    return extendsToken == null || classNameLine == extendsToken.line();
   }
 
-  private boolean isImplementsOnClassNameLine(AstNode classDeclaration, int classNameLine) {
-    AstNode implementsNode = classDeclaration.getFirstChild(PHPGrammar.IMPLEMENTS_LIST);
-
-    if (implementsNode != null) {
-      return classNameLine == implementsNode.getFirstChild(PHPKeyword.IMPLEMENTS).getTokenLine();
-    }
-
-    return true;
+  private boolean isImplementsOnClassNameLine(ClassDeclarationTree classDeclaration, int classNameLine) {
+    SyntaxToken implementsToken = classDeclaration.implementsToken();
+    return implementsToken == null || classNameLine == implementsToken.line();
   }
 
   /**
@@ -74,17 +77,22 @@ private boolean isImplementsOnClassNameLine(AstNode classDeclaration, int classN
    * Return null if there is not issue to report.
    */
   @Nullable
-  private String getIssueMessage(boolean isExtendsOnClassNameLine, boolean isImplementsOnClassNameLine) {
+  private String getIssuePartialMessage(boolean isExtendsOnClassNameLine, boolean isImplementsOnClassNameLine) {
     String msg = null;
 
     if (!isExtendsOnClassNameLine && !isImplementsOnClassNameLine) {
       msg = "\"extends\" and \"implements\" keywords";
-    } else if (!isExtendsOnClassNameLine && isImplementsOnClassNameLine) {
+    }
+
+    if (!isExtendsOnClassNameLine && isImplementsOnClassNameLine) {
       msg = "\"extends\" keyword";
-    } else if (isExtendsOnClassNameLine && !isImplementsOnClassNameLine) {
+    }
+
+    if (isExtendsOnClassNameLine && !isImplementsOnClassNameLine) {
       msg = "\"implements\" keyword";
     }
 
     return msg;
   }
+
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/FormattingCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/FormattingCheck.java
new file mode 100755
index 0000000000..92a30042b7
--- /dev/null
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/FormattingCheck.java
@@ -0,0 +1,29 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.checks.formatting;
+
+import org.sonar.php.checks.FormattingStandardCheck;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+
+public interface FormattingCheck {
+
+  void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree);
+
+}
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/FunctionSpacingCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/FunctionSpacingCheck.java
index 3d8872c480..d5abae3b9b 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/FunctionSpacingCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/FunctionSpacingCheck.java
@@ -19,85 +19,133 @@
  */
 package org.sonar.php.checks.formatting;
 
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.Token;
-import org.sonar.php.api.PHPKeyword;
-import org.sonar.php.api.PHPPunctuator;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.checks.utils.TokenVisitor;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.declaration.FunctionDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.MethodDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.ParameterListTree;
+import org.sonar.plugins.php.api.tree.expression.FunctionCallTree;
+import org.sonar.plugins.php.api.tree.expression.FunctionExpressionTree;
+import org.sonar.plugins.php.api.tree.expression.LexicalVariablesTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
-public class FunctionSpacingCheck extends SpacingCheck {
+import javax.annotation.Nullable;
+import java.util.List;
 
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (formattingCheck.isOneSpaceAfterComma && node.is(PHPGrammar.PARAMETER_LIST, PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
-      checkSpaceForComma(formattingCheck, node);
-    }
-    if (formattingCheck.isNoSpaceAfterMethodName && node.is(PHPGrammar.FUNCTION_DECLARATION, PHPGrammar.METHOD_DECLARATION, PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
-      checkSpaceAfterFunctionName(formattingCheck, node);
-    }
-    if (formattingCheck.isClosureSpacing && node.is(PHPGrammar.FUNCTION_EXPRESSION)) {
-      checkClosureSpacing(formattingCheck, node);
-    }
+public class FunctionSpacingCheck extends PHPVisitorCheck implements FormattingCheck {
+
+  private static final String METHOD_NAME_SPACES_MESSAGE = "Remove all space between the method name \"%s\" and the opening parenthesis.";
+  private static final String CLOSURE_SPACES_MESSAGE = "Put exactly one space between the \"function\" keyword and the opening parenthesis.";
+  private static final String CLOSURE_LEXICAL_VARS_SPACES_MESSAGE = "Put exactly one space before and after the \"use\" keyword.";
+  private static final String[] COMMA_SPACES_MESSAGE = {
+    "Remove any space before comma separated arguments.",
+    "Put exactly one space after comma separated arguments.",
+    "Remove any space before comma separated arguments and put exactly one space after comma separated arguments."
+  };
+
+  private FormattingStandardCheck check;
+
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    super.visitScript(scriptTree);
   }
 
-  private void checkClosureSpacing(FormattingStandardCheck formattingCheck, AstNode node) {
-    Token lParenToken = node.getFirstChild(PHPPunctuator.LPARENTHESIS).getToken();
-    Token functionKeyword = node.getFirstChild(PHPKeyword.FUNCTION).getToken();
+  @Override
+  public void visitParameterList(ParameterListTree tree) {
+    checkSpaceForComma(new TokenVisitor(tree), tree.parameters().getSeparators(), tree);
+    super.visitParameterList(tree);
+  }
 
-    if (getNbSpaceBetween(functionKeyword, lParenToken) != 1) {
-      formattingCheck.reportIssue("Put exactly one space between the \"function\" keyword and the opening parenthesis.", node);
+  @Override
+  public void visitFunctionCall(FunctionCallTree tree) {
+    if (!check.isInternalFunction(tree.callee())) {
+      checkSpaceForComma(new TokenVisitor(tree), tree.arguments().getSeparators(), tree.openParenthesisToken());
+      checkSpaceAfterFunctionName(((PHPTree) tree.callee()).getLastToken(), tree.openParenthesisToken());
     }
 
-    AstNode lexicalVars = node.getFirstChild(PHPGrammar.LEXICAL_VARS);
-    if (lexicalVars != null && !isSpaceAround(lexicalVars.getFirstChild(PHPKeyword.USE), 1 /* space before */, 1 /* space after */)) {
-      formattingCheck.reportIssue("Put exactly one space before and after the \"use\" keyword.", lexicalVars);
+    super.visitFunctionCall(tree);
+  }
+
+  @Override
+  public void visitMethodDeclaration(MethodDeclarationTree tree) {
+    checkSpaceAfterFunctionName(tree.name().token(), tree.parameters().openParenthesisToken());
+    super.visitMethodDeclaration(tree);
+  }
+
+  @Override
+  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
+    checkSpaceAfterFunctionName(tree.name().token(), tree.parameters().openParenthesisToken());
+    super.visitFunctionDeclaration(tree);
+  }
+
+  @Override
+  public void visitFunctionExpression(FunctionExpressionTree tree) {
+    checkClosureSpacing(tree.functionToken(), tree.parameters(), tree.lexicalVars());
+    super.visitFunctionExpression(tree);
+  }
+
+  private void checkClosureSpacing(SyntaxToken functionKeyword, ParameterListTree parameters, @Nullable LexicalVariablesTree lexicalVars) {
+    if (check.isClosureSpacing) {
+
+      if (TokenUtils.getNbSpaceBetween(functionKeyword, parameters.openParenthesisToken()) != 1) {
+        check.reportIssue(CLOSURE_SPACES_MESSAGE, functionKeyword);
+      }
+
+      if (lexicalVars != null) {
+        int spaceBeforeUse = TokenUtils.getNbSpaceBetween(parameters.closeParenthesisToken(), lexicalVars.useToken());
+        int spaceAfterUse = TokenUtils.getNbSpaceBetween(lexicalVars.useToken(), lexicalVars.openParenthesisToken());
+
+        if (spaceBeforeUse != 1 || spaceAfterUse != 1) {
+          check.reportIssue(CLOSURE_LEXICAL_VARS_SPACES_MESSAGE, lexicalVars);
+        }
+      }
     }
   }
 
   /**
    * Check there is not space between a function's name and the opening parenthesis.
    */
-  private void checkSpaceAfterFunctionName(FormattingStandardCheck formattingCheck, AstNode node) {
-    Token lParenToken = node.getFirstChild(PHPPunctuator.LPARENTHESIS).getToken();
-    Token funcNameToken = node.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST) ?
-      node.getPreviousAstNode().getLastToken() : node.getFirstChild(PHPGrammar.IDENTIFIER).getToken();
-
-    if (getNbSpaceBetween(funcNameToken, lParenToken) != 0) {
-      formattingCheck.reportIssue("Remove all space between the method name \"" + funcNameToken.getOriginalValue() + "\" and the opening parenthesis.", node);
+  private void checkSpaceAfterFunctionName(SyntaxToken functionName, SyntaxToken openParenthesis) {
+    if (check.isNoSpaceAfterMethodName && TokenUtils.getNbSpaceBetween(functionName, openParenthesis) != 0) {
+      check.reportIssue(String.format(METHOD_NAME_SPACES_MESSAGE, functionName.text()), functionName);
     }
   }
 
   /**
    * Check space around the arguments' comma.
    */
-  private void checkSpaceForComma(FormattingStandardCheck formattingCheck, AstNode node) {
+  private void checkSpaceForComma(TokenVisitor tokenVisitor, List<SyntaxToken> commas, Tree tree) {
+    if (check.isOneSpaceAfterComma) {
+
     int msgIndex = -1;
-    String[] msg = {
-      "Remove any space before comma separated arguments.",
-      "Put exactly one space after comma separated arguments.",
-      "Remove any space before comma separated arguments and put exactly one space after comma separated arguments."
-    };
-    for (AstNode comma : node.getChildren(PHPPunctuator.COMMA)) {
-      Token commaToken = comma.getToken();
-      Token nextToken = comma.getNextSibling().getToken();
-      Token previousToken = comma.getPreviousSibling().getLastToken();
-
-      if (isOnSameLine(previousToken, commaToken, nextToken)) {
-        boolean isSpaceBeforeOK = getNbSpaceBetween(previousToken, commaToken) == 0;
-        boolean isSpaceAfterOK = getNbSpaceBetween(commaToken, nextToken) == 1;
-
-        if (!isSpaceBeforeOK && isSpaceAfterOK && msgIndex < 0) {
-          msgIndex = 0;
-        } else if (isSpaceBeforeOK && !isSpaceAfterOK && msgIndex < 0) {
-          msgIndex = 1;
-        } else if (!isSpaceBeforeOK && !isSpaceAfterOK) {
-          msgIndex = 2;
-          break;
+
+      for (SyntaxToken commaToken : commas) {
+        SyntaxToken nextToken = tokenVisitor.nextToken(commaToken);
+        SyntaxToken previousToken = tokenVisitor.prevToken(commaToken);
+
+        if (TokenUtils.isOnSameLine(previousToken, commaToken, nextToken)) {
+          boolean isSpaceBeforeOK = TokenUtils.getNbSpaceBetween(previousToken, commaToken) == 0;
+          boolean isSpaceAfterOK = TokenUtils.getNbSpaceBetween(commaToken, nextToken) == 1;
+
+          if (!isSpaceBeforeOK && isSpaceAfterOK && msgIndex < 0) {
+            msgIndex = 0;
+          } else if (isSpaceBeforeOK && !isSpaceAfterOK && msgIndex < 0) {
+            msgIndex = 1;
+          } else if (!isSpaceBeforeOK && !isSpaceAfterOK) {
+            msgIndex = 2;
+            break;
+          }
         }
       }
-    }
-    if (msgIndex > -1) {
-      formattingCheck.reportIssue(msg[msgIndex], node);
+      if (msgIndex > -1) {
+        check.reportIssue(COMMA_SPACES_MESSAGE[msgIndex], tree);
+      }
+
     }
   }
 
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/IndentationCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/IndentationCheck.java
index a9e7aa7ec1..6331290763 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/IndentationCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/IndentationCheck.java
@@ -19,118 +19,185 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.AstNodeType;
-import com.sonar.sslr.api.Token;
 import org.sonar.php.api.PHPPunctuator;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
-
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.SeparatedList;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.declaration.ClassDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.FunctionDeclarationTree;
+import org.sonar.plugins.php.api.tree.declaration.MethodDeclarationTree;
+import org.sonar.plugins.php.api.tree.expression.FunctionCallTree;
+import org.sonar.plugins.php.api.tree.expression.FunctionExpressionTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
+
+import javax.annotation.Nullable;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
-public class IndentationCheck extends SpacingCheck {
+public class IndentationCheck extends PHPVisitorCheck implements FormattingCheck {
 
+  private static final String ARGUMENT_LINE_SPLIT_MESSAGE =
+    "Either split this list into multiple lines, aligned at column \"%s\" or put all arguments on line \"%s\".";
+  private static final String ARGUMENT_INDENTATION_MESSAGE = "Align all arguments in this list at column \"%s\".";
   private static final int PSR2_INDENTATION = 4;
+  private static final String FUNCTION_CALL_PARENTHESIS_MESSAGE = "Move the closing parenthesis on the next line.";
+  private static final String FUNCTION_DEC_PARENTHESIS_MESSAGE = "Move the closing parenthesis with the opening brace on the next line.";
+  private static final String INTERFACE_SPLIT_MESSAGE = "Either split this list into multiple lines or move it on the same line \"%s\".";
+  private static final String INTERFACE_INDENTATION = "Align all interfaces in this list at column \"%s\".";
+
+  private FormattingStandardCheck check;
+  private Map<Integer, Integer> startColumnByLine = new HashMap<>();
+
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    this.startColumnByLine.clear();
+
+    super.visitScript(scriptTree);
+  }
 
   @Override
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (formattingCheck.isFunctionCallsArgumentsIndentation && node.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
-      checkArgumentsIndentation(formattingCheck, node, PHPGrammar.PARAMETER_LIST_FOR_CALL);
+  public void visitToken(SyntaxToken token) {
+    if (startColumnByLine.get(token.line()) == null) {
+      startColumnByLine.put(token.line(), token.column());
     }
-    if (formattingCheck.isMethodArgumentsIndentation && node.is(PHPGrammar.PARAMETER_LIST)) {
-      checkArgumentsIndentation(formattingCheck, node, PHPGrammar.PARAMETER);
+
+    super.visitToken(token);
+  }
+
+  @Override
+  public void visitFunctionCall(FunctionCallTree tree) {
+    super.visitFunctionCall(tree);
+
+    if (check.isFunctionCallsArgumentsIndentation && !check.isInternalFunction(tree.callee())) {
+      SyntaxToken calleeLastToken = ((PHPTree) tree.callee()).getLastToken();
+
+      checkArgumentsIndentation(
+        tree.arguments(),
+        calleeLastToken,
+        startColumnForLine(calleeLastToken.line()),
+        tree.closeParenthesisToken(), true);
     }
-    if (formattingCheck.isInterfacesIndentation && node.is(PHPGrammar.CLASS_DECLARATION)) {
-      checkImplementListIndentation(formattingCheck, node);
+  }
+
+  @Override
+  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
+    super.visitFunctionDeclaration(tree);
+
+    if (check.isMethodArgumentsIndentation) {
+      checkArgumentsIndentation(
+        tree.parameters().parameters(),
+        tree.name().token(),
+        startColumnForLine(tree.functionToken().line()),
+        tree.parameters().closeParenthesisToken(), false);
     }
   }
 
-  private void checkImplementListIndentation(FormattingStandardCheck formattingCheck, AstNode node) {
-    AstNode implementList = node.getFirstChild(PHPGrammar.IMPLEMENTS_LIST);
+  @Override
+  public void visitMethodDeclaration(MethodDeclarationTree tree) {
+    super.visitMethodDeclaration(tree);
+
+    if (check.isMethodArgumentsIndentation) {
+      checkArgumentsIndentation(
+        tree.parameters().parameters(),
+        tree.name().token(),
+        startColumnForLine(tree.functionToken().line()),
+        (tree.parameters().closeParenthesisToken()), false);
+    }
+  }
 
-    if (implementList != null) {
-      List<AstNode> interfaceList = implementList.getFirstChild(PHPGrammar.INTERFACE_LIST).getChildren(PHPGrammar.FULLY_QUALIFIED_CLASS_NAME);
-      int classDecLine = node.getTokenLine();
-      int expectedColumn = getLineStartingColumn(node) + PSR2_INDENTATION;
+  @Override
+  public void visitFunctionExpression(FunctionExpressionTree tree) {
+    super.visitFunctionExpression(tree);
+
+    if (check.isMethodArgumentsIndentation) {
+      checkArgumentsIndentation(
+        tree.parameters().parameters(),
+        tree.functionToken(),
+        startColumnForLine(tree.functionToken().line()),
+        (tree.parameters().closeParenthesisToken()), false);
+    }
+  }
 
-      if (!isOnSameLine(node.getToken(), Iterables.getLast(interfaceList).getToken())) {
+  @Override
+  public void visitClassDeclaration(ClassDeclarationTree tree) {
+    super.visitClassDeclaration(tree);
+    checkImplementListIndentation(tree);
+  }
+
+  private void checkImplementListIndentation(ClassDeclarationTree classTree) {
+    if (check.isInterfacesIndentation && classTree.is(Tree.Kind.CLASS_DECLARATION) && !classTree.superInterfaces().isEmpty()) {
+
+      List<Tree> interfaceList = ImmutableList.<Tree>copyOf(classTree.superInterfaces());
+      SyntaxToken classToken = classTree.classEntryTypeToken();
+      SyntaxToken lastInterfaceToken = ((PHPTree) Iterables.getLast(classTree.superInterfaces())).getFirstToken();
+      int expectedColumn = classToken.column() + PSR2_INDENTATION;
+
+      if (!TokenUtils.isOnSameLine(classToken, lastInterfaceToken)) {
+
+        if (!isCorrectlySplitOnLines(classToken.line(), interfaceList)) {
+          check.reportIssue(String.format(INTERFACE_SPLIT_MESSAGE, classToken.line()), classTree.superInterfaces().get(0));
 
-        if (!isCorrectlySplittedOnLines(classDecLine, interfaceList)) {
-          formattingCheck.reportIssue("Either split this list into multiple lines or move it on the same line \"" + classDecLine + "\".",
-            interfaceList.get(0));
         } else if (!isCorrectlyIndented(expectedColumn, interfaceList)) {
-          formattingCheck.reportIssue("Align all interfaces in this list at column \"" + expectedColumn + "\".", interfaceList.get(0));
+          check.reportIssue(String.format(INTERFACE_INDENTATION, expectedColumn), classTree.superInterfaces().get(0));
         }
       }
     }
   }
 
-  private void checkArgumentsIndentation(FormattingStandardCheck formattingCheck, AstNode node, AstNodeType parameterNodeType) {
-    List<AstNode> arguments = node.getChildren(parameterNodeType);
-
+  private void checkArgumentsIndentation(SeparatedList arguments, SyntaxToken functionName, int baseColumn, @Nullable SyntaxToken closeParenthesis, boolean isFunctionCall) {
     if (arguments.size() > 1) {
-      Token lastParam = Iterables.getLast(arguments).getLastToken();
-      AstNode methodName = node.getPreviousAstNode();
-      AstNode firstParam = arguments.get(0);
-      int expectedIndentationColumn = getLineStartingColumn(node.getParent()) + PSR2_INDENTATION;
-      int callingLine = methodName.getTokenLine();
-
-      if (!isOnSameLine(methodName.getToken(), lastParam)) {
-
-        if (!isCorrectlySplittedOnLines(callingLine, arguments)) {
-          formattingCheck.reportIssue("Either split this list into multiple lines, aligned at column \""
-            + expectedIndentationColumn + "\" or put all arguments on line \""
-            + callingLine + "\".", firstParam);
+      SyntaxToken lastArg = ((PHPTree) Iterables.getLast(arguments)).getLastToken();
+      Tree firstArg = (Tree) arguments.get(0);
+
+      int expectedIndentationColumn = baseColumn + PSR2_INDENTATION;
+      int callingLine = functionName.line();
+
+      if (!TokenUtils.isOnSameLine(functionName, lastArg)) {
+
+        if (!isCorrectlySplitOnLines(callingLine, arguments)) {
+          check.reportIssue(String.format(ARGUMENT_LINE_SPLIT_MESSAGE, expectedIndentationColumn, callingLine), firstArg);
+
         } else if (!isCorrectlyIndented(expectedIndentationColumn, arguments)) {
-          formattingCheck.reportIssue("Align all arguments in this list at column \"" + expectedIndentationColumn + "\".", firstParam);
+          check.reportIssue(String.format(ARGUMENT_INDENTATION_MESSAGE, expectedIndentationColumn), firstArg);
         }
-        checkClosingParenthesisLocation(formattingCheck, node, lastParam);
-      }
-    }
-  }
-
-  private void checkClosingParenthesisLocation(FormattingStandardCheck formattingCheck, AstNode paramList, Token lastParam) {
-    AstNode rParenthesis;
-    String msg;
 
-    if (paramList.is(PHPGrammar.FUNCTION_CALL_PARAMETER_LIST)) {
-      rParenthesis = paramList.getFirstChild(PHPPunctuator.RPARENTHESIS);
-      msg = "Move the closing parenthesis on the next line.";
-    } else {
-      rParenthesis = paramList.getParent().getFirstChild(PHPPunctuator.RPARENTHESIS);
-      msg = "Move the closing parenthesis with the opening brace on the next line.";
-    }
-    if (!lastParam.getType().equals(PHPPunctuator.RPARENTHESIS) && isOnSameLine(lastParam, rParenthesis.getToken())) {
-      formattingCheck.reportIssue(msg, rParenthesis);
+        // Checking parenthesis
+        if (closeParenthesis != null) {
+          checkClosingParenthesisLocation((Tree) Iterables.getLast(arguments), closeParenthesis, isFunctionCall);
+        }
+      }
     }
   }
 
-  private int getLineStartingColumn(AstNode node) {
-    int line = node.getTokenLine();
-    AstNode previousNode = node.getPreviousAstNode();
-    int column = node.getToken().getColumn();
-
-    while (previousNode != null && previousNode.getToken().getLine() == line) {
-      column = previousNode.getToken().getColumn();
-      previousNode = previousNode.getParent();
+  private void checkClosingParenthesisLocation(Tree lastArgument, SyntaxToken closeParenthesis, boolean isFunctionCall) {
+    if (!((PHPTree) lastArgument).getLastToken().text().equals(PHPPunctuator.RPARENTHESIS.getValue()) && TokenUtils.isOnSameLine(((PHPTree) lastArgument).getLastToken(), closeParenthesis)) {
+      check.reportIssue(
+        isFunctionCall ? FUNCTION_CALL_PARENTHESIS_MESSAGE : FUNCTION_DEC_PARENTHESIS_MESSAGE,
+        closeParenthesis);
     }
-    return column;
   }
 
-  private boolean isCorrectlyIndented(int expectedColumn, List<AstNode> items) {
-    for (AstNode item : items) {
-      if (item.getToken().getColumn() != expectedColumn) {
+  private boolean isCorrectlyIndented(int expectedColumn, List<Tree> items) {
+    for (Tree item : items) {
+      if (((PHPTree) item).getFirstToken().column() != expectedColumn) {
         return false;
       }
     }
     return true;
   }
 
-  private boolean isCorrectlySplittedOnLines(int referenceLine, List<AstNode> items) {
+  private boolean isCorrectlySplitOnLines(int referenceLine, List<Tree> items) {
     int expectedLine = referenceLine + 1;
-    for (AstNode item : items) {
-      if (item.getTokenLine() < expectedLine) {
+
+    for (Tree item : items) {
+      if (((PHPTree) item).getFirstToken().line() < expectedLine) {
         return false;
       }
       expectedLine++;
@@ -138,4 +205,8 @@ private boolean isCorrectlySplittedOnLines(int referenceLine, List<AstNode> item
     return true;
   }
 
+  private int startColumnForLine(int line) {
+    return startColumnByLine.get(line);
+  }
+
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheck.java
index 5d9578b328..d40ecdb7b8 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheck.java
@@ -21,83 +21,112 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.Token;
-import com.sonar.sslr.api.Trivia;
 import org.sonar.php.checks.FormattingStandardCheck;
-import org.sonar.php.parser.PHPGrammar;
+import org.sonar.php.tree.impl.PHPTree;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.Tree;
+import org.sonar.plugins.php.api.tree.Tree.Kind;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxTrivia;
+import org.sonar.plugins.php.api.tree.statement.NamespaceStatementTree;
+import org.sonar.plugins.php.api.tree.statement.StatementTree;
+import org.sonar.plugins.php.api.tree.statement.UseStatementTree;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
 import java.util.List;
 
-public class NamespaceAndUseStatementCheck {
+public class NamespaceAndUseStatementCheck extends PHPVisitorCheck implements FormattingCheck {
 
-  private List<AstNode> useNodes = Lists.newArrayList();
+  private static final String BLANK_LINE_NAMESPACE_MESSAGE = "Add a blank line after this \"namespace%s\" declaration.";
+  private static final String BLANK_LINE_USE_MESSAGE = "Add a blank line after this \"use\" declaration.";
+  private static final String USE_AFTER_NAMESPACE_MESSAGE = "Move the use declarations after the namespace declarations.";
+  private static final Kind[] USE_KINDS = {
+    Kind.USE_STATEMENT,
+    Kind.USE_CONST_STATEMENT,
+    Kind.USE_FUNCTION_STATEMENT};
 
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (node.is(PHPGrammar.NAMESPACE_STATEMENT)) {
-      checkBlankLineAfterNamespace(formattingCheck, node);
+  private List<UseStatementTree> useStatements = Lists.newArrayList();
+  private StatementTree nextStatement = null;
+  private FormattingStandardCheck check = null;
 
-    } else if (node.is(PHPGrammar.USE_STATEMENT)) {
-      useNodes.add(node);
-      AstNode nextNode = node.getNextAstNode().getFirstChild();
 
-      if (nextNode == null || nextNode.isNot(PHPGrammar.USE_STATEMENT)) {
-        checkUsesAreBeforeNamespace(formattingCheck, nextNode);
-        checkBlankLineAfterUses(formattingCheck, node);
-        useNodes.clear();
-      }
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+
+    this.visitScript(scriptTree);
+
+    nextStatement = null;
+    useStatements.clear();
+  }
+
+  @Override
+  public void visitScript(ScriptTree tree) {
+    List<StatementTree> statements = tree.statements();
+    int nbStatements = statements.size();
+
+    for (int i = 0; i < nbStatements - 1; i++) {
+      nextStatement = statements.get(i + 1);
+      statements.get(i).accept(this);
     }
+
+    nextStatement = null;
+    statements.get(nbStatements - 1).accept(this);
+
   }
 
-  public void leaveFile() {
-    useNodes.clear();
+
+  @Override
+  public void visitNamespaceStatement(NamespaceStatementTree tree) {
+    if (check.hasNamespaceBlankLine && nextStatement != null && !isFollowedWithBlankLine(tree)) {
+      String message = String.format(
+        BLANK_LINE_NAMESPACE_MESSAGE,
+        tree.namespaceName() == null ? "" : " " + tree.namespaceName().fullName());
+      reportIssue(message, tree);
+    }
   }
 
-  private void checkBlankLineAfterUses(FormattingStandardCheck formattingCheck, AstNode useStatement) {
-    if (formattingCheck.hasUseBlankLine && isNotFollowedWithBlankLine(useStatement) && useStatement.getParent().getNextSibling() != null) {
-      formattingCheck.reportIssue("Add a blank line after this \"use\" declaration.", Iterables.getLast(useNodes));
+  @Override
+  public void visitUseStatement(UseStatementTree tree) {
+    useStatements.add(tree);
+
+    if (nextStatement != null && !nextStatement.is(USE_KINDS)) {
+        checkUsesAreBeforeNamespace();
+        checkBlankLineAfterUses(tree);
+        useStatements.clear();
     }
   }
 
-  private void checkUsesAreBeforeNamespace(FormattingStandardCheck formattingCheck, AstNode nextNode) {
-    if (formattingCheck.isUseAfterNamespace && nextNode != null && nextNode.is(PHPGrammar.NAMESPACE_STATEMENT)) {
-      formattingCheck.reportIssue("Move the use declarations after the namespace declarations.", useNodes.get(0));
+  private void checkBlankLineAfterUses(UseStatementTree useStatement) {
+    if (check.hasUseBlankLine && !isFollowedWithBlankLine(useStatement)) {
+      reportIssue(BLANK_LINE_USE_MESSAGE, Iterables.getLast(useStatements));
     }
   }
 
-  private void checkBlankLineAfterNamespace(FormattingStandardCheck formattingCheck, AstNode namespaceNode) {
-    if (formattingCheck.hasNamespaceBlankLine && isNotFollowedWithBlankLine(namespaceNode)) {
-      formattingCheck.reportIssue("Add a blank line after this \"namespace " + getNamespaceName(namespaceNode) + "\" declaration.", namespaceNode);
+  private void checkUsesAreBeforeNamespace() {
+    if (check.isUseAfterNamespace && nextStatement.is(Kind.NAMESPACE_STATEMENT)) {
+      reportIssue(USE_AFTER_NAMESPACE_MESSAGE, useStatements.get(0));
     }
   }
 
+  private void reportIssue(String message, Tree tree) {
+    check.reportIssue(message, tree);
+  }
+
   /**
    * Returns true when there is either token or comment on node's next line.
    */
-  private boolean isNotFollowedWithBlankLine(AstNode node) {
-    int nextNodeLine = node.getTokenLine() + 1;
-    boolean isNotFollowedWithBlankLine = false;
+  private boolean isFollowedWithBlankLine(Tree tree) {
+    int nextLine = ((PHPTree) tree).getLastToken().line() + 1;
+    SyntaxToken nextToken = ((PHPTree) nextStatement).getFirstToken();
+    boolean isFollowedWithBlankLine = true;
 
     // Checking for comment: is allowed on the same line as the node declaration or on next line + 1.
-    for (Trivia t : node.getNextAstNode().getToken().getTrivia()) {
-      int line = t.getToken().getLine();
-      isNotFollowedWithBlankLine |= line == nextNodeLine;
-    }
-
-    return isNotFollowedWithBlankLine || node.getNextAstNode().getTokenLine() == nextNodeLine;
-  }
-
-  private Object getNamespaceName(AstNode namespaceNode) {
-    AstNode namespaceName = namespaceNode.getFirstChild(PHPGrammar.NAMESPACE_NAME);
-    StringBuilder builder = new StringBuilder();
-
-    if (namespaceName != null) {
-      for (Token t : namespaceName.getTokens()) {
-        builder.append(t.getOriginalValue());
-      }
+    for (SyntaxTrivia trivia : nextToken.trivias()) {
+      isFollowedWithBlankLine &= trivia.line() != nextLine;
     }
 
-    return builder.toString();
+    return isFollowedWithBlankLine && nextToken.line() != nextLine;
   }
 
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheck.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheck.java
index 03cf7ceace..739bcc2f06 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheck.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheck.java
@@ -19,57 +19,116 @@
  */
 package org.sonar.php.checks.formatting;
 
-import com.sonar.sslr.api.AstNode;
-import com.sonar.sslr.api.Token;
 import org.sonar.php.api.PHPPunctuator;
 import org.sonar.php.checks.FormattingStandardCheck;
+import org.sonar.plugins.php.api.tree.ScriptTree;
+import org.sonar.plugins.php.api.tree.expression.ExpandableStringCharactersTree;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
-public class PunctuatorSpacingCheck extends SpacingCheck {
+import java.util.ArrayDeque;
+import java.util.Deque;
 
-  @Override
-  public void visitNode(FormattingStandardCheck formattingCheck, AstNode node) {
-    if (formattingCheck.isOneSpaceBetweenRParentAndLCurly && node.is(PHPPunctuator.RPARENTHESIS)) {
-      checkSpaceBetweenRParentAndLCurly(formattingCheck, node);
+public class PunctuatorSpacingCheck extends PHPVisitorCheck implements FormattingCheck {
+
+  private static final String CLOSE_PARENTHESIS_OPEN_CURLY_MESSAGE = "between the closing parenthesis and the opening curly brace.";
+  private static final String OPEN_PARENTHESIS_SPACES_MESSAGE = "Remove all space after the opening parenthesis.";
+  private static final String CLOSE_PARENTHESIS_SPACES_MESSAGE = "Remove all space before the closing parenthesis.";
+  private static final String BOTH_PARENTHESIS_SPACES_MESSAGE = "Remove all space after the opening parenthesis and before the closing parenthesis.";
+
+  private FormattingStandardCheck check;
+  private SyntaxToken previousToken = null;
+  private Deque<OpenParenthesisContext> openParenthesisLevel = new ArrayDeque<>();
+
+  private static class OpenParenthesisContext {
+    final SyntaxToken openParenthesis;
+    final SyntaxToken nextToken;
+
+    public OpenParenthesisContext(SyntaxToken openParenthesis, SyntaxToken nextToken) {
+      this.openParenthesis = openParenthesis;
+      this.nextToken = nextToken;
     }
-    if (formattingCheck.isNoSpaceParenthesis && node.is(PHPPunctuator.RPARENTHESIS)) {
-      checkSpaceInsideParenthesis(formattingCheck, node);
+  }
+
+  @Override
+  public void checkFormat(FormattingStandardCheck formattingCheck, ScriptTree scriptTree) {
+    this.check = formattingCheck;
+    this.previousToken = null;
+    openParenthesisLevel.clear();
+    super.visitScript(scriptTree);
+  }
+
+  @Override
+  public void visitExpandableStringCharacters(ExpandableStringCharactersTree tree) {
+    // do not process string characters
+  }
+
+  @Override
+  public void visitToken(SyntaxToken token) {
+    super.visitToken(token);
+    if (previousToken != null) {
+
+      if (isCloseParenthesis(previousToken) && isOpenCurly(token)) {
+        checkSpaceBetweenCloseParenAndOpenCurly(previousToken, token);
+      }
+
+      if (isOpenParenthesis(previousToken)) {
+        openParenthesisLevel.push(new OpenParenthesisContext(previousToken, token));
+      }
+
+      if (isCloseParenthesis(token)) {
+        checkSpaceInsideParenthesis(openParenthesisLevel.pop(), token, previousToken);
+      }
     }
+
+    previousToken = token;
   }
 
-  /**
-   * Check there is no space after the opening parenthesis and no space before the closing one.
-   */
-  private void checkSpaceInsideParenthesis(FormattingStandardCheck formattingCheck, AstNode rcurly) {
-    AstNode lcurly = rcurly.getParent().getFirstChild(PHPPunctuator.LPARENTHESIS);
-    Token lcurlyNextToken = lcurly.getNextAstNode().getToken();
-    Token rculyPreviousToken = rcurly.getPreviousAstNode().getLastToken();
-
-    boolean isLCurlyOK = !isOnSameLine(lcurlyNextToken, lcurly.getToken()) || getNbSpaceBetween(lcurly.getToken(), lcurlyNextToken) == 0;
-    boolean isRCurlyOK = !isOnSameLine(rculyPreviousToken, rcurly.getToken()) || getNbSpaceBetween(rculyPreviousToken, rcurly.getToken()) == 0;
-
-    if (!isLCurlyOK && isRCurlyOK) {
-      formattingCheck.reportIssue("Remove all space after the opening parenthesis.", lcurly);
-    } else if (isLCurlyOK && !isRCurlyOK) {
-      formattingCheck.reportIssue("Remove all space before the closing parenthesis.", rcurly);
-    } else if (!isLCurlyOK && !isRCurlyOK) {
-      formattingCheck.reportIssue("Remove all space after the opening parenthesis and before the closing parenthesis.", lcurly);
+
+  private void checkSpaceBetweenCloseParenAndOpenCurly(SyntaxToken closeParenthesis, SyntaxToken openCurly) {
+    if (check.isOneSpaceBetweenRParentAndLCurly) {
+      int nbSpace = TokenUtils.getNbSpaceBetween(closeParenthesis, openCurly);
+
+      if (TokenUtils.isOnSameLine(closeParenthesis, openCurly) && nbSpace != 1) {
+        check.reportIssue(TokenUtils.buildIssueMsg(nbSpace, CLOSE_PARENTHESIS_OPEN_CURLY_MESSAGE), closeParenthesis);
+      }
     }
   }
 
   /**
-   * Check that there is exactly one space between a closing parenthesis and a opening curly brace.
+   * Check there is no space after the opening parenthesis and no space before the closing one.
    */
-  private void checkSpaceBetweenRParentAndLCurly(FormattingStandardCheck formattingCheck, AstNode rParenthesis) {
-    Token nextToken = rParenthesis.getNextAstNode().getToken();
-    Token rParenToken = rParenthesis.getToken();
+  private void checkSpaceInsideParenthesis(OpenParenthesisContext openParenthesisContext, SyntaxToken closeParen, SyntaxToken closeParenPreviousToken) {
+    if (check.isNoSpaceParenthesis) {
 
-    if (isType(nextToken, PHPPunctuator.LCURLYBRACE)) {
-      int nbSpace = getNbSpaceBetween(rParenToken, nextToken);
+      SyntaxToken openParen = openParenthesisContext.openParenthesis;
+      SyntaxToken openParenNextToken = openParenthesisContext.nextToken;
 
-      if (nbSpace != 1 && isOnSameLine(rParenToken, nextToken)) {
-        formattingCheck.reportIssue(buildIssueMsg(nbSpace, "between the closing parenthesis and the opening curly brace."), rParenthesis);
+      boolean isLCurlyOK = !TokenUtils.isOnSameLine(openParenNextToken, openParen) || TokenUtils.getNbSpaceBetween(openParen, openParenNextToken) == 0;
+      boolean isRCurlyOK = !TokenUtils.isOnSameLine(closeParenPreviousToken, closeParen) || TokenUtils.getNbSpaceBetween(closeParenPreviousToken, closeParen) == 0;
+
+      if (!isLCurlyOK && isRCurlyOK) {
+        check.reportIssue(OPEN_PARENTHESIS_SPACES_MESSAGE, openParen);
+
+      } else if (isLCurlyOK && !isRCurlyOK) {
+        check.reportIssue(CLOSE_PARENTHESIS_SPACES_MESSAGE, closeParen);
+
+      } else if (!isLCurlyOK && !isRCurlyOK) {
+        check.reportIssue(BOTH_PARENTHESIS_SPACES_MESSAGE, openParen);
       }
     }
   }
 
+  private static boolean isOpenParenthesis(SyntaxToken token) {
+    return TokenUtils.isType(token, PHPPunctuator.LPARENTHESIS);
+  }
+
+  private static boolean isOpenCurly(SyntaxToken token) {
+    return TokenUtils.isType(token, PHPPunctuator.LCURLYBRACE);
+  }
+
+  private static boolean isCloseParenthesis(SyntaxToken token) {
+    return TokenUtils.isType(token, PHPPunctuator.RPARENTHESIS);
+  }
+
 }
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/TokenUtils.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/TokenUtils.java
new file mode 100755
index 0000000000..544aaa0e2a
--- /dev/null
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/TokenUtils.java
@@ -0,0 +1,76 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.php.checks.formatting;
+
+import com.google.common.base.Preconditions;
+import com.sonar.sslr.api.TokenType;
+import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
+
+public class TokenUtils {
+
+  private TokenUtils() {
+  }
+
+  public static String buildIssueMsg(int nbSpace, String end) {
+    return (new StringBuilder()).append("Put ")
+      .append(nbSpace > 1 ? "only " : "")
+      .append("one space ")
+      .append(end).toString();
+  }
+
+  /**
+   * Return true if the given token is one of the given types.
+   */
+  public static boolean isType(SyntaxToken token, TokenType... types) {
+    boolean isOneOfType = false;
+    for (TokenType type : types) {
+      isOneOfType |= type.getValue().equals(token.text());
+    }
+    return isOneOfType;
+  }
+
+  /**
+   * Returns true if all the tokens given as parameters are on the same line.
+   */
+  public static boolean isOnSameLine(SyntaxToken... tokens) {
+    Preconditions.checkArgument(tokens.length > 0);
+
+    int lineRef = tokens[0].line();
+    for (SyntaxToken token : tokens) {
+      if (token.line() != lineRef) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Returns number of space between the 2 tokens.
+   */
+  protected static int getNbSpaceBetween(SyntaxToken token1, SyntaxToken token2) {
+    Preconditions.checkArgument(token1 != null && token2 != null);
+
+    int token1EndColumn = token1.column() + (token1.text().length() - 1);
+    int tok2StartColumn = token2.column();
+
+    return tok2StartColumn - token1EndColumn - 1;
+  }
+
+}
diff --git a/php-checks/src/main/java/org/sonar/php/checks/formatting/package-info.java b/php-checks/src/main/java/org/sonar/php/checks/formatting/package-info.java
new file mode 100755
index 0000000000..8bf9d5279f
--- /dev/null
+++ b/php-checks/src/main/java/org/sonar/php/checks/formatting/package-info.java
@@ -0,0 +1,21 @@
+/*
+ * SonarQube PHP Plugin
+ * Copyright (C) 2010 SonarSource and Akram Ben Aissi
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+@javax.annotation.ParametersAreNonnullByDefault
+package org.sonar.php.checks.formatting;
diff --git a/php-checks/src/main/java/org/sonar/php/checks/utils/TokenVisitor.java b/php-checks/src/main/java/org/sonar/php/checks/utils/TokenVisitor.java
index 6bfca28fae..c95354ca0f 100755
--- a/php-checks/src/main/java/org/sonar/php/checks/utils/TokenVisitor.java
+++ b/php-checks/src/main/java/org/sonar/php/checks/utils/TokenVisitor.java
@@ -19,11 +19,13 @@
  */
 package org.sonar.php.checks.utils;
 
+import org.apache.commons.lang.ArrayUtils;
 import org.sonar.plugins.php.api.tree.Tree;
 import org.sonar.plugins.php.api.tree.Tree.Kind;
 import org.sonar.plugins.php.api.tree.lexical.SyntaxToken;
 import org.sonar.plugins.php.api.visitors.PHPVisitorCheck;
 
+import javax.annotation.Nullable;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -52,6 +54,16 @@ public void visitToken(SyntaxToken token) {
     }
   }
 
+  @Nullable
+  public SyntaxToken tokenByValue(String... tokenValues) {
+    for (SyntaxToken token : tokens) {
+      if (ArrayUtils.contains(tokenValues, token.text())) {
+        return token;
+      }
+    }
+    return null;
+  }
+
   public SyntaxToken prevToken(SyntaxToken token) {
     for (int i = 0; i < tokens.size(); i++) {
       if (token.equals(tokens.get(i))) {
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/ControlStructureSpacingTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/ControlStructureSpacingTest.java
index fcbf0004c7..e248a88c35 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/ControlStructureSpacingTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/ControlStructureSpacingTest.java
@@ -19,12 +19,13 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 import java.io.File;
 
@@ -40,28 +41,12 @@ public void setUp() throws Exception {
   @Test
   public void defaultValue() throws IllegalAccessException {
     activeOnly("isOneSpaceBetweenKeywordAndNextToken", "isOneSpaceAfterForLoopSemicolon", "isSpaceForeachStatement");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(6).withMessage("Put one space between this \"if\" keyword and the opening parenthesis.")
-      .next().atLine(8).withMessage("Put only one space between this \"if\" keyword and the opening parenthesis.")
-      .next().atLine(10).withMessage("Put one space between this \"else\" keyword and the opening curly brace.")
-
-      .next().atLine(29).withMessage("Put exactly one space after each \";\" character in the \"for\" statement.")
-
-      .next().atLine(39).withMessage("Put exactly one space after and before \"as\" in \"foreach\" statement.")
-      .next().atLine(40).withMessage("Put exactly one space after and before \"=>\" in \"foreach\" statement.")
-      .next().atLine(41).withMessage("Put exactly one space after and before \"as\" and \"=>\" in \"foreach\" statement.")
-
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE);
   }
 
   @Test
   public void custom() throws IllegalAccessException {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE, ImmutableList.<Issue>of());
   }
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/CurlyBraceCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/CurlyBraceCheckTest.java
index 91a9a34521..97fbf31ad4 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/CurlyBraceCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/CurlyBraceCheckTest.java
@@ -19,11 +19,12 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 public class CurlyBraceCheckTest extends FormattingStandardCheckTest {
 
@@ -31,37 +32,13 @@
   @Test
   public void defaultValue() throws Exception {
     activeOnly("isOpenCurlyBraceForClassAndFunction", "isOpenCurlyBraceForControlStructures", "isClosingCurlyNextToKeyword");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "CurlyBraceCheck.php"), check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(7).withMessage("Move this open curly brace to the beginning of the next line.")
-      .next().atLine(8)
-      .next().atLine(20)
-      .next().atLine(23)
-      .next().atLine(26)
-
-      .next().atLine(39).withMessage("Move this open curly brace to the end of the previous line.")
-      .next().atLine(43)
-      .next().atLine(48)
-      .next().atLine(52)
-      .next().atLine(56)
-      .next().atLine(60)
-      .next().atLine(64)
-      .next().atLine(66)
-
-      .next().atLine(82).withMessage("Move this \"else\" to the same line as the previous closing curly brace.")
-      .next().atLine(87)
-      .next().atLine(89)
-
-      .noMore();
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "CurlyBraceCheck.php"));
   }
 
   @Test
   public void custom() throws Exception {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "CurlyBraceCheck.php"), check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "CurlyBraceCheck.php"), ImmutableList.<Issue>of());
   }
+
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheckTest.java
index c7fee68d71..6e8ad0f81b 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/ExtendsImplementsLineCheckTest.java
@@ -19,32 +19,24 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
-import org.sonar.squidbridge.checks.CheckMessagesVerifier;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 public class ExtendsImplementsLineCheckTest extends FormattingStandardCheckTest {
 
   @Test
   public void test() throws Exception {
     activeOnly("isExtendsAndImplementsLine");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "ExtendsImplementsLineCheck.php"), check);
-    CheckMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(3).withMessage("Move \"extends\" keyword to the same line as the declaration of its class name, \"KO\".")
-      .next().atLine(9).withMessage("Move \"implements\" keyword to the same line as the declaration of its class name, \"KO\".")
-      .next().atLine(15).withMessage("Move \"extends\" and \"implements\" keywords to the same line as the declaration of its class name, \"KO\".");
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "ExtendsImplementsLineCheck.php"));
   }
 
   @Test
   public void custom() throws Exception {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "ExtendsImplementsLineCheck.php"), check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "ExtendsImplementsLineCheck.php"), ImmutableList.<Issue>of());
   }
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/FunctionSpacingCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/FunctionSpacingCheckTest.java
index e6dce71e5d..751305e342 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/FunctionSpacingCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/FunctionSpacingCheckTest.java
@@ -19,12 +19,13 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 import java.io.File;
 
@@ -40,30 +41,14 @@ public void setUp() throws Exception {
   @Test
   public void defaultValue() throws Exception {
     activeOnly("isOneSpaceAfterComma", "isNoSpaceAfterMethodName", "isClosureSpacing");
+    PHPCheckTest.check(check, TEST_FILE);
 
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(7).withMessage("Remove any space before comma separated arguments.")
-      .next().atLine(8).withMessage("Put exactly one space after comma separated arguments.")
-      .next().atLine(9).withMessage("Remove any space before comma separated arguments and put exactly one space after comma separated arguments.")
-      .next().atLine(10).withMessage("Remove any space before comma separated arguments and put exactly one space after comma separated arguments.")
-      .next().atLine(11)
-
-      .next().atLine(18).withMessage("Remove all space between the method name \"f\" and the opening parenthesis.")
-      .next().atLine(19).withMessage("Remove all space between the method name \"doSomething\" and the opening parenthesis.")
-
-      .next().atLine(27).withMessage("Put exactly one space between the \"function\" keyword and the opening parenthesis.")
-      .next().atLine(28).withMessage("Put exactly one space before and after the \"use\" keyword.")
-
-      .noMore();
   }
 
   @Test
   public void custom() throws Exception {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE, ImmutableList.<Issue>of());
   }
+
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/IndentationCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/IndentationCheckTest.java
index 308c6b698b..cd947d6826 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/IndentationCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/IndentationCheckTest.java
@@ -19,12 +19,13 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 import java.io.File;
 
@@ -40,33 +41,12 @@ public void setUp() throws Exception {
   @Test
   public void defaultValue() throws IllegalAccessException {
     activeOnly("isFunctionCallsArgumentsIndentation", "isMethodArgumentsIndentation", "isInterfacesIndentation");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(6).withMessage("Either split this list into multiple lines, aligned at column \"4\" or put all arguments on line \"6\".")
-      .next().atLine(11).withMessage("Either split this list into multiple lines, aligned at column \"4\" or put all arguments on line \"10\".")
-      .next().atLine(15).withMessage("Align all arguments in this list at column \"4\".")
-      .next().atLine(16).withMessage("Move the closing parenthesis on the next line.")
-      .next().atLine(18)
-
-      .next().atLine(50).withMessage("Either split this list into multiple lines, aligned at column \"4\" or put all arguments on line \"50\".")
-      .next().atLine(56).withMessage("Either split this list into multiple lines, aligned at column \"4\" or put all arguments on line \"55\".")
-      .next().atLine(61).withMessage("Align all arguments in this list at column \"4\".")
-      .next().atLine(62).withMessage("Move the closing parenthesis with the opening brace on the next line.")
-
-      .next().atLine(80).withMessage("Either split this list into multiple lines or move it on the same line \"80\".")
-      .next().atLine(85).withMessage("Either split this list into multiple lines or move it on the same line \"84\".")
-      .next().atLine(89).withMessage("Align all interfaces in this list at column \"4\".")
-
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE);
   }
 
   @Test
   public void custom() throws IllegalAccessException {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE, ImmutableList.<Issue>of());
   }
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheckTest.java
index a20a033139..5d9b33b948 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/NamespaceAndUseStatementCheckTest.java
@@ -19,11 +19,12 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 public class NamespaceAndUseStatementCheckTest extends FormattingStandardCheckTest {
 
@@ -31,24 +32,12 @@
   @Test
   public void defaultValue() throws Exception {
     activeOnly("hasNamespaceBlankLine", "isUseAfterNamespace", "hasUseBlankLine");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "NamespaceAndUseStatementCheck.php"), check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(3).withMessage("Move the use declarations after the namespace declarations.")
-      .next().atLine(4).withMessage("Add a blank line after this \"use\" declaration.")
-      .next().atLine(5).withMessage("Add a blank line after this \"namespace another\\bar\" declaration.")
-      .next().atLine(10).withMessage("Add a blank line after this \"use\" declaration.")
-      .next().atLine(14)
-      .next().atLine(19)
-      .noMore();
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "NamespaceAndUseStatementCheck.php"));
   }
 
   @Test
   public void custom() throws Exception {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TestUtils.getCheckFile(TEST_DIR + "NamespaceAndUseStatementCheck.php"), check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TestUtils.getCheckFile(TEST_DIR + "NamespaceAndUseStatementCheck.php"), ImmutableList.<Issue>of());
   }
 }
diff --git a/php-checks/src/test/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheckTest.java b/php-checks/src/test/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheckTest.java
index c5157f44c0..2987642a92 100755
--- a/php-checks/src/test/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheckTest.java
+++ b/php-checks/src/test/java/org/sonar/php/checks/formatting/PunctuatorSpacingCheckTest.java
@@ -19,12 +19,13 @@
  */
 package org.sonar.php.checks.formatting;
 
+import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
-import org.sonar.php.PHPAstScanner;
 import org.sonar.php.checks.FormattingStandardCheckTest;
 import org.sonar.plugins.php.TestUtils;
-import org.sonar.squidbridge.api.SourceFile;
+import org.sonar.plugins.php.api.tests.PHPCheckTest;
+import org.sonar.plugins.php.api.visitors.Issue;
 
 import java.io.File;
 
@@ -40,25 +41,13 @@ public void setUp() throws Exception {
   @Test
   public void defaultValue() throws IllegalAccessException {
     activeOnly("isOneSpaceBetweenRParentAndLCurly", "isNoSpaceParenthesis");
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .next().atLine(6).withMessage("Put one space between the closing parenthesis and the opening curly brace.")
-      .next().atLine(8).withMessage("Put only one space between the closing parenthesis and the opening curly brace.")
-
-      .next().atLine(24).withMessage("Remove all space after the opening parenthesis.")
-      .next().atLine(25).withMessage("Remove all space before the closing parenthesis.")
-      .next().atLine(26).withMessage("Remove all space after the opening parenthesis and before the closing parenthesis.")
-
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE);
   }
 
   @Test
   public void custom() throws IllegalAccessException {
     deactivateAll();
-
-    SourceFile file = PHPAstScanner.scanSingleFile(TEST_FILE, check);
-    checkMessagesVerifier.verify(file.getCheckMessages())
-      .noMore();
+    PHPCheckTest.check(check, TEST_FILE, ImmutableList.<Issue>of());
   }
+
 }
diff --git a/php-checks/src/test/resources/checks/formattingCheck/ControlStructureSpacingCheck.php b/php-checks/src/test/resources/checks/formattingCheck/ControlStructureSpacingCheck.php
index 3e33178330..220e2c090b 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/ControlStructureSpacingCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/ControlStructureSpacingCheck.php
@@ -3,11 +3,11 @@
 /**
  * Space after control structure keyword
  */
-if($a) {           // NOK
+if($a) {           // NOK {{Put one space between this "if" keyword and the opening parenthesis.}}
 
-} else if  ($b) {  // NOK
+} else if  ($b) {  // NOK {{Put only one space between this "if" keyword and the opening parenthesis.}}
 
-} else{            // NOK
+} else{            // NOK {{Put one space between this "else" keyword and the opening curly brace.}}
 
 }
 
@@ -26,7 +26,7 @@
  * Space after ";" in for statement
  */
 
-for ($i = 0;$i < 3;  $i++) {  // NOK
+for ($i = 0;$i < 3;  $i++) {  // NOK {{Put exactly one space after each ";" character in the "for" statement.}}
 }
 
 for ($i = 0; $i < 3; $i++) {  // OK
@@ -36,8 +36,16 @@
  * Foreach spacing
  */
 
-foreach ($a as  $array) {}          // NOK
-foreach ($a as $map =>  $value) {}  // NOK
-foreach ($a as  $map  =>$value) {}  // NOK
+foreach ($a as  $array) {}          // NOK {{Put exactly one space after and before "as" in "foreach" statement.}}
+foreach ($a as $map =>  $value) {}  // NOK {{Put exactly one space after and before "=>" in "foreach" statement.}}
+foreach ($a as  $map  =>$value) {}  // NOK {{Put exactly one space after and before "as" and "=>" in "foreach" statement.}}
 foreach ($a as $map => $value) {}   // OK
 
+foreach ($tokens as $token) {
+    array(
+      'listener'   => $this->listeners[$listenerClass],
+      'class'      => $listenerClass,
+      'tokenizers' => $tokenizers,
+     );
+
+}
\ No newline at end of file
diff --git a/php-checks/src/test/resources/checks/formattingCheck/CurlyBraceCheck.php b/php-checks/src/test/resources/checks/formattingCheck/CurlyBraceCheck.php
index 8bba062ba4..7b4fc263ac 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/CurlyBraceCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/CurlyBraceCheck.php
@@ -4,13 +4,21 @@
  *  Class and function
  */
 
-class C1 {          // NOK
+abstract class C1 { // NOK {{Move this open curly brace to the beginning of the next line.}}
     function f() {  // NOK
     }
 
     function g()    // OK
     {
     }
+
+    function h();   // OK
+
+    function g($p1, $p2,
+               $p3, $p4
+    ) {              // OK
+    }
+
 }
 
 class C2            // OK
@@ -36,7 +44,7 @@ function g($p1, $p2,
  */
 
 if ($a)
-{                         // NOK
+{                         // NOK {{Move this open curly brace to the end of the previous line.}}
 }
 
 do
@@ -79,7 +87,7 @@ function g($p1, $p2,
  */
 if ($a) {
 }
-else {                  // NOK
+else {                  // NOK {{Move this "else" to the same line as the previous closing curly brace.}}
 }
 
 try {
@@ -91,4 +99,4 @@ function g($p1, $p2,
 
 if ($a) {
 } else {                // OK
-}
\ No newline at end of file
+}
diff --git a/php-checks/src/test/resources/checks/formattingCheck/ExtendsImplementsLineCheck.php b/php-checks/src/test/resources/checks/formattingCheck/ExtendsImplementsLineCheck.php
index a1d3a409b0..6195d49676 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/ExtendsImplementsLineCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/ExtendsImplementsLineCheck.php
@@ -1,18 +1,18 @@
 <?php
 
-class KO
+class KO                     // NOK {{Move "extends" keyword to the same line as the declaration of its class name, "KO".}}
     extends Another
 {
 
 }
 
-class KO
+class KO                     // NOK {{Move "implements" keyword to the same line as the declaration of its class name, "KO".}}
     implements Anotherable
 {
 
 }
 
-class KO
+class KO                     // NOK {{Move "extends" and "implements" keywords to the same line as the declaration of its class name, "KO".}}
     extends Another
     implements Anotherable
 {
diff --git a/php-checks/src/test/resources/checks/formattingCheck/FunctionSpacingCheck.php b/php-checks/src/test/resources/checks/formattingCheck/FunctionSpacingCheck.php
index 3570a237f2..e30fc31855 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/FunctionSpacingCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/FunctionSpacingCheck.php
@@ -4,10 +4,10 @@
  * Space around arguments' comma
  */
 
-function f($p1 , $p2, $p3, $p4) {}  // NOK - space before
-function g($p1,$p2, $p3, $p4) {}    // NOK - no space after
-function h($p1 ,$p2, $p3, $p4) {}   // NOK - space after & no space after
-function i($p1 ,$p2, $p3 ,$p4) {}   // NOK - space after & no space after x2
+function f($p1 , $p2, $p3, $p4) {}  // NOK {{Remove any space before comma separated arguments.}}
+function g($p1,$p2, $p3, $p4) {}    // NOK {{Put exactly one space after comma separated arguments.}}
+function h($p1 ,$p2, $p3, $p4) {}   // NOK {{Remove any space before comma separated arguments and put exactly one space after comma separated arguments.}}
+function i($p1 ,$p2, $p3 ,$p4) {}   // NOK {{Remove any space before comma separated arguments and put exactly one space after comma separated arguments.}}
 doSomething($p1,$p2);               // NOK
 function j($p1, $p2, $p3, $p4) {}   // OK
 
@@ -15,8 +15,8 @@ function j($p1, $p2, $p3, $p4) {}   // OK
  * No space after function's name
  */
 
-function f () {}     // NOK
-$a->doSomething ();  // NOK
+function f () {}     // NOK {{Remove all space between the method name "f" and the opening parenthesis.}}
+$a->doSomething ();  // NOK {{Remove all space between the method name "doSomething" and the opening parenthesis.}}
 function g() {}      // OK
 doSomething();       // OK
 
@@ -24,6 +24,11 @@ function g() {}      // OK
  * Closure spacing
  */
 
-$f = function() {};           // NOK
-$g = function () use($a) {};  // NOK
+$f = function() {};           // NOK {{Put exactly one space between the "function" keyword and the opening parenthesis.}}
+$g = function () use($a) {};  // NOK {{Put exactly one space before and after the "use" keyword.}}
 $h = function () use ($b) {}; // OK
+
+foo->
+  bar($a,$b);    // NOK
+
+echo "la" , "lala";    // OK - internal
\ No newline at end of file
diff --git a/php-checks/src/test/resources/checks/formattingCheck/IndentationCheck.php b/php-checks/src/test/resources/checks/formattingCheck/IndentationCheck.php
index 27acd4578f..43e65d402b 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/IndentationCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/IndentationCheck.php
@@ -3,17 +3,17 @@
 /**
  * Function calls arguments indentation
  */
-doSomething($p1,             // NOK
+doSomething($p1,             // NOK {{Either split this list into multiple lines, aligned at column "4" or put all arguments on line "6".}}
     $p2
 );
 
 doSomething(
-    $p1, $p2                 // NOK
+    $p1, $p2                 // NOK {{Either split this list into multiple lines, aligned at column "4" or put all arguments on line "10".}}
 );
 
 doSomething(
-    $p1,                     // NOK
-   $p2);                     // NOK
+    $p1,                     // NOK {{Align all arguments in this list at column "4".}}
+   $p2);                     // NOK {{Move the closing parenthesis on the next line.}}
 
 doSomething($p1, something(  // NOK
     $p1,
@@ -47,19 +47,19 @@
 /**
  * Method declaration argument indentation
  */
-function f($p1,         // NOK
+function f($p1,         // NOK {{Either split this list into multiple lines, aligned at column "4" or put all arguments on line "50".}}
            $p2
 ) {
 }
 
 function g(
-    $p1, $p2            // NOK
+    $p1, $p2            // NOK {{Either split this list into multiple lines, aligned at column "4" or put all arguments on line "55".}}
 ) {
 }
 
 function h(
-   $p1,                 // NOK
-    $p2)                // NOK - closing parenthesis
+   $p1,                 // NOK {{Align all arguments in this list at column "4".}}
+    $p2)                // NOK {{Move the closing parenthesis with the opening brace on the next line.}}
 {
 }
 
@@ -77,16 +77,16 @@ function k(             // OK
  * Implement list indentation
  */
 
-class C1 implements A,    // NOK
+class C1 implements A,    // NOK {{Either split this list into multiple lines or move it on the same line "80".}}
                     B
 {}
 
 class C2 implements
-        A, B              // NOK
+        A, B              // NOK {{Either split this list into multiple lines or move it on the same line "84".}}
 {}
 
 class C3 implements
-    A,                    // NOK
+    A,                    // NOK {{Align all interfaces in this list at column "4".}}
      B
 {}
 
diff --git a/php-checks/src/test/resources/checks/formattingCheck/NamespaceAndUseStatementCheck.php b/php-checks/src/test/resources/checks/formattingCheck/NamespaceAndUseStatementCheck.php
index 2cffa96b4e..f8b0c62f4f 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/NamespaceAndUseStatementCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/NamespaceAndUseStatementCheck.php
@@ -1,8 +1,12 @@
 <?php
 
-use my\space\AnotherClass;  // NOK - uses are before namespace
-use my\space\MyClass;       // NOK - no blank line after uses
-namespace another\bar;      // NOK - no blank line after namespace
+use my\space\AnotherClass;  // NOK {{Move the use declarations after the namespace declarations.}}
+use my\space\MyClass;       // NOK {{Add a blank line after this "use" declaration.}}
+namespace another\bar;      // NOK {{Add a blank line after this "namespace another\bar" declaration.}}
+{
+}
+
+namespace {}      // NOK {{Add a blank line after this "namespace" declaration.}}
 {
 }
 
@@ -23,7 +27,7 @@
 
 namespace                   // OK
 {
-  use x;                    // OK  
+  use x;                    // OK
 }
 
 namespace foo\bar;          // OK
diff --git a/php-checks/src/test/resources/checks/formattingCheck/PunctuatorSpacingCheck.php b/php-checks/src/test/resources/checks/formattingCheck/PunctuatorSpacingCheck.php
index e28cd55b79..e7a76180d3 100755
--- a/php-checks/src/test/resources/checks/formattingCheck/PunctuatorSpacingCheck.php
+++ b/php-checks/src/test/resources/checks/formattingCheck/PunctuatorSpacingCheck.php
@@ -3,9 +3,9 @@
 /**
  * Space between closing parenthesis and opening curly brace
  */
-if ($a){           // NOK
+if ($a){           // NOK {{Put one space between the closing parenthesis and the opening curly brace.}}
 
-} else if ($b)  {  // NOK
+} else if ($b)  {  // NOK {{Put only one space between the closing parenthesis and the opening curly brace.}}
 
 }
 
@@ -21,9 +21,9 @@ function f()       // OK
  * Spacing inside parenthesis
  */
 
-doSomething( $p1, $p2);   // NOK
-doSomething($p1, $p2 );   // NOK
-doSomething( $p1, $p2 );  // NOK
+doSomething( $p1, $p2);   // NOK {{Remove all space after the opening parenthesis.}}
+doSomething($p1, $p2 );   // NOK {{Remove all space before the closing parenthesis.}}
+doSomething( $p1, $p2 );  // NOK {{Remove all space after the opening parenthesis and before the closing parenthesis.}}
 doSomething($p1, $p2);    // OK
 doSomething(              // OK
     $p1, $p2);
@@ -32,3 +32,7 @@ function f()       // OK
 doSomething(              // OK
     $p1, $p2
 );
+
+$flags = array( preg_match()); // NOK
+
+"{$space1}{$space0}SUM($op)";
\ No newline at end of file
