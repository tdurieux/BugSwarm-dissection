diff --git a/java-checks/src/main/java/org/sonar/java/checks/AbsOnNegativeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AbsOnNegativeCheck.java
index aa85c4dd5c..138d88939a 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AbsOnNegativeCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AbsOnNegativeCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -69,15 +69,15 @@
     MethodMatcher.create()
       .name("hashCode"),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.util.Random"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.util.Random"))
       .name("nextInt"),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.util.Random"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.util.Random"))
       .name("nextLong"),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.lang.Comparable"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.lang.Comparable"))
       .name("compareTo")
-      .addParameter(TypeCriteria.anyType())
+      .addParameter(TypePredicates.anyType())
     );
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AbstractSerializableInnerClassRule.java b/java-checks/src/main/java/org/sonar/java/checks/AbstractSerializableInnerClassRule.java
index 534a1f7d12..331a1746b6 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AbstractSerializableInnerClassRule.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AbstractSerializableInnerClassRule.java
@@ -21,7 +21,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -73,7 +73,7 @@ protected boolean isSerializable(Type type) {
   }
 
   private static boolean directlyImplementsSerializable(Symbol.TypeSymbol symbol) {
-    return Iterables.any(symbol.interfaces(), SyntaxNodePredicates.isType("java.io.Serializable"));
+    return Iterables.any(symbol.interfaces(), TypePredicates.isType("java.io.Serializable"));
   }
 
   protected abstract boolean isMatchingOuterClass(Type outerClass);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
index e67e6cc9ff..e76101e4df 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
@@ -19,13 +19,13 @@
  */
 package org.sonar.java.checks;
 
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.ActivatedByDefault;
@@ -44,7 +44,12 @@
 @SqaleConstantRemediation("5min")
 public class ArrayHashCodeAndToStringCheck extends AbstractMethodDetection {
 
-  private static final TypeCriteria IS_ARRAY = new IsArrayCriteria();
+  private static final Predicate<Type> IS_ARRAY = new Predicate<Type>() {
+    @Override
+    public boolean apply(Type input) {
+      return input.isArray();
+    }
+  };
 
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
@@ -65,13 +70,4 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
     addIssue(mit, "Use \"Arrays." + methodName + "(array)\" instead.");
   }
 
-  private static class IsArrayCriteria extends TypeCriteria {
-
-    @Override
-    public boolean matches(Type type) {
-      return type.isArray();
-    }
-
-  }
-
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
index d73b7a669b..93aca8f4ad 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
@@ -24,7 +24,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.BlockTree;
@@ -75,7 +75,7 @@ private static boolean isRunMethod(MethodTree methodTree) {
     @Override
     public void visitMethodInvocation(MethodInvocationTree tree) {
       Type type = tree.symbol().owner().type();
-      if (Iterables.any(CHECKED_TYPES, SyntaxNodePredicates.typeIs(type))) {
+      if (Iterables.any(CHECKED_TYPES, TypePredicates.typeIs(type))) {
         addIssue(tree, "Remove this assertion.");
       }
       super.visitMethodInvocation(tree);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
index 996f5b2c72..3631903f31 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionsCompletenessCheck.java
@@ -20,13 +20,15 @@
 package org.sonar.java.checks;
 
 import com.google.common.base.Objects;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.methods.MethodMatcher;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -64,19 +66,19 @@
   );
 
   private static MethodMatcher assertThatOnType(String type) {
-    return MethodMatcher.create().typeDefinition(type).name("assertThat").addParameter(TypeCriteria.anyType());
+    return MethodMatcher.create().typeDefinition(type).name("assertThat").addParameter(TypePredicates.anyType());
   }
 
   private static final MethodInvocationMatcherCollection FEST_LIKE_EXCLUSIONS = MethodInvocationMatcherCollection.create(
-    methodWithName(NameCriteria.startsWith("as")),
-    methodWithName(NameCriteria.startsWith("using")),
-    methodWithName(NameCriteria.startsWith("with")),
-    methodWithName(NameCriteria.is("describedAs")),
-    methodWithName(NameCriteria.is("overridingErrorMessage"))
+    methodWithName(NamePredicates.startsWith("as")),
+    methodWithName(NamePredicates.startsWith("using")),
+    methodWithName(NamePredicates.startsWith("with")),
+    methodWithName(Predicates.equalTo("describedAs")),
+    methodWithName(Predicates.equalTo("overridingErrorMessage"))
   );
 
-  private static MethodMatcher methodWithName(NameCriteria nameCriteria) {
-    return MethodMatcher.create().typeDefinition(TypeCriteria.anyType()).name(nameCriteria).withNoParameterConstraint();
+  private static MethodMatcher methodWithName(Predicate<String> nameCriteria) {
+    return MethodMatcher.create().typeDefinition(TypePredicates.anyType()).name(nameCriteria).withNoParameterConstraint();
   }
 
   private Boolean chainedToAnyMethodButFestExclusions = null;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionsInTestsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionsInTestsCheck.java
index 2ad9e1dfdb..e0f068f814 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionsInTestsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionsInTestsCheck.java
@@ -19,13 +19,14 @@
  */
 package org.sonar.java.checks;
 
+import com.google.common.base.Predicates;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -56,31 +57,31 @@
   private static final MethodMatcher ASSERTJ_ASSERT_ALL = MethodMatcher.create()
     .typeDefinition("org.assertj.core.api.SoftAssertions").name("assertAll");
   private static final MethodMatcher ASSERT_THAT = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.anyType()).name("assertThat").addParameter(TypeCriteria.anyType());
+    .typeDefinition(TypePredicates.anyType()).name("assertThat").addParameter(TypePredicates.anyType());
   private static final MethodMatcher FEST_AS_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.anyType()).name("as").withNoParameterConstraint();
+    .typeDefinition(TypePredicates.anyType()).name("as").withNoParameterConstraint();
   private static final MethodMatcher FEST_DESCRIBED_AS_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.anyType()).name("describedAs").withNoParameterConstraint();
+    .typeDefinition(TypePredicates.anyType()).name("describedAs").withNoParameterConstraint();
   private static final MethodMatcher FEST_OVERRIDE_ERROR_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.anyType()).name("overridingErrorMessage").withNoParameterConstraint();
+    .typeDefinition(TypePredicates.anyType()).name("overridingErrorMessage").withNoParameterConstraint();
   private static final MethodInvocationMatcherCollection ASSERTION_INVOCATION_MATCHERS = MethodInvocationMatcherCollection.create(
-    MethodMatcher.create().typeDefinition("org.junit.Assert").name(NameCriteria.startsWith("assert")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.junit.Assert").name(NamePredicates.startsWith("assert")).withNoParameterConstraint(),
     MethodMatcher.create().typeDefinition("org.junit.Assert").name("fail").withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.junit.rules.ExpectedException").name(NameCriteria.startsWith("expect")).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NameCriteria.startsWith("assert")).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.junit.rules.ExpectedException").name(NamePredicates.startsWith("expect")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NamePredicates.startsWith("assert")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
     // fest 1.x
-    MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.fest.assertions.GenericAssert")).name(NameCriteria.any()).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.fest.assertions.Fail").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.fest.assertions.GenericAssert")).name(NamePredicates.any()).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.fest.assertions.Fail").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
     // fest 2.x
-    MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.fest.assertions.api.AbstractAssert")).name(NameCriteria.any()).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.fest.assertions.api.Fail").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.fest.assertions.api.AbstractAssert")).name(NamePredicates.any()).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.fest.assertions.api.Fail").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
     // assertJ
-    MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.assertj.core.api.AbstractAssert")).name(NameCriteria.any()).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.assertj.core.api.Fail").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.assertj.core.api.Fail").name(NameCriteria.is("shouldHaveThrown")).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.assertj.core.api.Assertions").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
-    MethodMatcher.create().typeDefinition("org.assertj.core.api.Assertions").name(NameCriteria.is("shouldHaveThrown")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.assertj.core.api.AbstractAssert")).name(NamePredicates.any()).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.assertj.core.api.Fail").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.assertj.core.api.Fail").name(Predicates.equalTo("shouldHaveThrown")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.assertj.core.api.Assertions").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
+    MethodMatcher.create().typeDefinition("org.assertj.core.api.Assertions").name(Predicates.equalTo("shouldHaveThrown")).withNoParameterConstraint(),
     // Mockito
     MethodMatcher.create().typeDefinition("org.mockito.Mockito").name("verifyNoMoreInteractions").withNoParameterConstraint()
   );
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionsWithoutMessageCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionsWithoutMessageCheck.java
index 6789a8e752..e63bd1e7c3 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionsWithoutMessageCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionsWithoutMessageCheck.java
@@ -24,10 +24,10 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
@@ -55,12 +55,12 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return Lists.newArrayList(
-        MethodMatcher.create().typeDefinition("org.junit.Assert").name(NameCriteria.startsWith("assert")).withNoParameterConstraint(),
+        MethodMatcher.create().typeDefinition("org.junit.Assert").name(NamePredicates.startsWith("assert")).withNoParameterConstraint(),
         MethodMatcher.create().typeDefinition("org.junit.Assert").name("fail").withNoParameterConstraint(),
-        MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NameCriteria.startsWith("assert")).withNoParameterConstraint(),
-        MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
-        MethodMatcher.create().typeDefinition("org.fest.assertions.Fail").name(NameCriteria.startsWith("fail")).withNoParameterConstraint(),
-        MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(GENERIC_ASSERT)).name(NameCriteria.any()).withNoParameterConstraint()
+        MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NamePredicates.startsWith("assert")).withNoParameterConstraint(),
+        MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
+        MethodMatcher.create().typeDefinition("org.fest.assertions.Fail").name(NamePredicates.startsWith("fail")).withNoParameterConstraint(),
+        MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf(GENERIC_ASSERT)).name(NamePredicates.any()).withNoParameterConstraint()
     );
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/BooleanLiteralInAssertionsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/BooleanLiteralInAssertionsCheck.java
index 5b6d6ed763..ce7f34f8f0 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/BooleanLiteralInAssertionsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/BooleanLiteralInAssertionsCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.NamePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -48,9 +48,9 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return Lists.newArrayList(
-      MethodMatcher.create().typeDefinition("org.junit.Assert").name(NameCriteria.startsWith(ASSERT)).withNoParameterConstraint(),
-      MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NameCriteria.startsWith(ASSERT)).withNoParameterConstraint(),
-      MethodMatcher.create().typeDefinition("junit.framework.TestCase").name(NameCriteria.startsWith(ASSERT)).withNoParameterConstraint(),
+      MethodMatcher.create().typeDefinition("org.junit.Assert").name(NamePredicates.startsWith(ASSERT)).withNoParameterConstraint(),
+      MethodMatcher.create().typeDefinition("junit.framework.Assert").name(NamePredicates.startsWith(ASSERT)).withNoParameterConstraint(),
+      MethodMatcher.create().typeDefinition("junit.framework.TestCase").name(NamePredicates.startsWith(ASSERT)).withNoParameterConstraint(),
       MethodMatcher.create().typeDefinition("org.fest.assertions.Assertions").name("assertThat").addParameter("boolean")
       );
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
index 144650f6b3..d77abbd561 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.java.resolve.JavaType.ParametrizedTypeJavaType;
 import org.sonar.java.resolve.JavaType.TypeVariableJavaType;
@@ -38,7 +38,6 @@
 import org.sonar.squidbridge.annotations.SqaleSubCharacteristic;
 
 import javax.annotation.Nullable;
-
 import java.text.MessageFormat;
 import java.util.List;
 
@@ -62,7 +61,7 @@
 
   private static MethodMatcher collectionMethodInvocation(String methodName) {
     return MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.util.Collection"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.util.Collection"))
       .name(methodName)
       .addParameter("java.lang.Object");
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CollectionIsEmptyCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CollectionIsEmptyCheck.java
index ceda86c4ae..c15ebd0712 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/CollectionIsEmptyCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CollectionIsEmptyCheck.java
@@ -22,8 +22,8 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -121,7 +121,7 @@ private static boolean isOne(ExpressionTree tree) {
   }
 
   private static MethodMatcher getSizeMethodInvocationMatcher() {
-    return MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(JAVA_UTIL_COLLECTION)).name("size").withNoParameterConstraint();
+    return MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf(JAVA_UTIL_COLLECTION)).name("size").withNoParameterConstraint();
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
index 77e857313d..ecff83d139 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
@@ -26,9 +26,9 @@
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.JavaPropertiesHelper;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
@@ -78,7 +78,7 @@
         .typeDefinition("java.security.MessageDigest")
         .name("getInstance")
         .addParameter(JAVA_LANG_STRING)
-        .addParameter(TypeCriteria.anyType()))
+        .addParameter(TypePredicates.anyType()))
       .add(MethodMatcher.create()
         .typeDefinition("org.apache.commons.codec.digest.DigestUtils")
         .name("getDigest")
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
index d9bcdba944..40be7e0126 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
 import org.sonar.squidbridge.annotations.SqaleSubCharacteristic;
@@ -44,8 +44,8 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.Class")).name("forName").withNoParameterConstraint(),
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.ClassLoader")).name("loadClass").withNoParameterConstraint()
+      MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.lang.Class")).name("forName").withNoParameterConstraint(),
+      MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.lang.ClassLoader")).name("loadClass").withNoParameterConstraint()
     );
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EqualsArgumentTypeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EqualsArgumentTypeCheck.java
index 6abca4667b..e4827f4a3d 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/EqualsArgumentTypeCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/EqualsArgumentTypeCheck.java
@@ -24,8 +24,8 @@
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.ExpressionsHelper;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
@@ -57,7 +57,7 @@
 
   private static final MethodMatcher EQUALS_MATCHER = MethodMatcher.create()
     .name("equals")
-    .addParameter(TypeCriteria.anyType());
+    .addParameter(TypePredicates.anyType());
 
   private static final MethodMatcher GETCLASS_MATCHER = MethodMatcher.create()
     .name("getClass");
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EqualsNotOverridenWithCompareToCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EqualsNotOverridenWithCompareToCheck.java
index 90e6b98601..15903e8b37 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/EqualsNotOverridenWithCompareToCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/EqualsNotOverridenWithCompareToCheck.java
@@ -24,7 +24,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.model.declaration.MethodTreeImpl;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.ClassTree;
@@ -87,7 +87,7 @@ private static boolean isEqualsMethod(MethodTree method) {
   }
 
   private static boolean isComparable(ClassTree tree) {
-    return Iterables.any(tree.symbol().interfaces(), SyntaxNodePredicates.isType("java.lang.Comparable"));
+    return Iterables.any(tree.symbol().interfaces(), TypePredicates.isType("java.lang.Comparable"));
   }
 
   private static boolean returnsInt(MethodTree tree) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
index 18d6379cc6..df1454080f 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.ActivatedByDefault;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
@@ -53,7 +53,7 @@
 
   private static MethodMatcher equalsInvocationMatcher(String fullyQualifiedName) {
     return MethodMatcher.create()
-      .callSite(TypeCriteria.is(fullyQualifiedName))
+      .callSite(TypePredicates.isType(fullyQualifiedName))
       .name("equals")
       .addParameter("java.lang.Object");
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
index b4131cac7a..5cee613ad3 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
@@ -24,7 +24,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
@@ -77,7 +77,7 @@ public void visitNode(Tree tree) {
 
   private static boolean isCheckedType(MethodInvocationTree mit) {
     Symbol owner = mit.symbol().owner();
-    return Iterables.any(CHECKED_TYPES, SyntaxNodePredicates.typeIs(owner.type()));
+    return Iterables.any(CHECKED_TYPES, TypePredicates.typeIs(owner.type()));
   }
 
   private static boolean returnsVoid(Type methodType) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
index 86d63c7671..673d31b374 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.methods.MethodMatcher;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
@@ -73,7 +73,7 @@ public void visitNode(Tree tree) {
 
   private static MethodMatcher inputStreamInvocationMatcher(String methodName, String parameterType) {
     return MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.io.InputStream"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.io.InputStream"))
       .name(methodName)
       .addParameter(parameterType);
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ImmediateReverseBoxingCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ImmediateReverseBoxingCheck.java
index c26f6c182c..fc7469d0af 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ImmediateReverseBoxingCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ImmediateReverseBoxingCheck.java
@@ -24,9 +24,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.methods.MethodMatcher;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
@@ -204,7 +204,7 @@ private static MethodInvocationMatcherCollection unboxingInvocationMatchers() {
     for (String primitiveType : PRIMITIVE_TYPES_BY_WRAPPER.values()) {
       matchers.add(
         MethodMatcher.create()
-          .callSite("boolean".equals(primitiveType) ? TypeCriteria.is("java.lang.Boolean") : TypeCriteria.subtypeOf("java.lang.Number"))
+          .callSite("boolean".equals(primitiveType) ? TypePredicates.isType("java.lang.Boolean") : TypePredicates.isSubtypeOf("java.lang.Number"))
           .name(primitiveType + "Value"));
     }
     return matchers;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IndexOfWithPositiveNumberCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IndexOfWithPositiveNumberCheck.java
index 948932e5b6..c309272b98 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/IndexOfWithPositiveNumberCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IndexOfWithPositiveNumberCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.methods.MethodMatcher;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -36,7 +36,6 @@
 import org.sonar.squidbridge.annotations.SqaleSubCharacteristic;
 
 import javax.annotation.Nullable;
-
 import java.util.List;
 
 @Rule(
@@ -61,7 +60,7 @@
       .name(INDEXOF)
       .addParameter(String.class.getName()),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.util.List"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.util.List"))
       .name(INDEXOF)
       .addParameter("java.lang.Object")
     );
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
index 439a2223d5..45d428d729 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
@@ -24,9 +24,8 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -54,7 +53,7 @@
 
   private static final MethodMatcher NEXT_INVOCATION_MATCHER =
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.util.Iterator"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.util.Iterator"))
       .name("next");
 
   @Override
@@ -108,7 +107,7 @@ public void visitMethodInvocation(MethodInvocationTree methodInvocation) {
 
     public boolean throwsNoSuchElementException(MethodInvocationTree methodInvocationTree) {
       Symbol symbol = methodInvocationTree.symbol();
-      return symbol.isMethodSymbol() && Iterables.any(((Symbol.MethodSymbol) symbol).thrownTypes(), SyntaxNodePredicates.isType("java.util.NoSuchElementException"));
+      return symbol.isMethodSymbol() && Iterables.any(((Symbol.MethodSymbol) symbol).thrownTypes(), TypePredicates.isType("java.util.NoSuchElementException"));
     }
 
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/KeySetInsteadOfEntrySetCheck.java b/java-checks/src/main/java/org/sonar/java/checks/KeySetInsteadOfEntrySetCheck.java
index d36f7fa9fc..dcd3de1668 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/KeySetInsteadOfEntrySetCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/KeySetInsteadOfEntrySetCheck.java
@@ -24,8 +24,8 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -40,7 +40,6 @@
 import org.sonar.squidbridge.annotations.SqaleSubCharacteristic;
 
 import javax.annotation.CheckForNull;
-
 import java.util.List;
 
 @Rule(
@@ -54,12 +53,12 @@
 public class KeySetInsteadOfEntrySetCheck extends SubscriptionBaseVisitor {
 
   private static final MethodMatcher MAP_GET_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.subtypeOf("java.util.Map"))
+    .typeDefinition(TypePredicates.isSubtypeOf("java.util.Map"))
     .name("get")
     .addParameter("java.lang.Object");
 
   private static final MethodMatcher MAP_KEYSET_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.subtypeOf("java.util.Map"))
+    .typeDefinition(TypePredicates.isSubtypeOf("java.util.Map"))
     .name("keySet");
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/LDAPInjectionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/LDAPInjectionCheck.java
index 6eb632ac91..b572091254 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/LDAPInjectionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/LDAPInjectionCheck.java
@@ -22,8 +22,8 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.NewArrayTree;
@@ -41,7 +41,7 @@
 public class LDAPInjectionCheck extends AbstractInjectionChecker {
 
   private static final MethodMatcher LDAP_SEARCH_MATCHER = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.subtypeOf("javax.naming.directory.DirContext"))
+    .typeDefinition(TypePredicates.isSubtypeOf("javax.naming.directory.DirContext"))
     .name("search").withNoParameterConstraint();
 
   private static final MethodMatcher SEARCH_CONTROLS_MATCHER = MethodMatcher.create()
diff --git a/java-checks/src/main/java/org/sonar/java/checks/MutableMembersUsageCheck.java b/java-checks/src/main/java/org/sonar/java/checks/MutableMembersUsageCheck.java
index 63d8d8bbd7..a2c34b0279 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/MutableMembersUsageCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/MutableMembersUsageCheck.java
@@ -24,7 +24,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -153,7 +153,7 @@ private static boolean isMutableType(Type type) {
   }
 
   private static boolean isNotImmutable(Type type) {
-    return !Iterables.any(IMMUTABLE_TYPES, SyntaxNodePredicates.typeIsSubtypeOf(type));
+    return !Iterables.any(IMMUTABLE_TYPES, TypePredicates.typeIsSubtypeOf(type));
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ObjectCreatedOnlyToCallGetClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ObjectCreatedOnlyToCallGetClassCheck.java
index 268a7656c1..e608d04e5a 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ObjectCreatedOnlyToCallGetClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ObjectCreatedOnlyToCallGetClassCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -56,7 +56,7 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.Object")).name("getClass"));
+      MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.lang.Object")).name("getClass"));
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PreparedStatementAndResultSetCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PreparedStatementAndResultSetCheck.java
index 78796c8cc3..e466fdbe35 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/PreparedStatementAndResultSetCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PreparedStatementAndResultSetCheck.java
@@ -27,10 +27,10 @@
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.ExpressionsHelper;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.java.syntaxtoken.FirstSyntaxTokenFinder;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -75,9 +75,9 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(
-      MethodMatcher.create().typeDefinition("java.sql.PreparedStatement").name(NameCriteria.startsWith("set")).addParameter(INT).addParameter(TypeCriteria.anyType()),
-      MethodMatcher.create().typeDefinition(JAVA_SQL_RESULTSET).name(NameCriteria.startsWith("get")).addParameter(INT),
-      MethodMatcher.create().typeDefinition(JAVA_SQL_RESULTSET).name(NameCriteria.startsWith("get")).addParameter(INT).addParameter(TypeCriteria.anyType()));
+      MethodMatcher.create().typeDefinition("java.sql.PreparedStatement").name(NamePredicates.startsWith("set")).addParameter(INT).addParameter(TypePredicates.anyType()),
+      MethodMatcher.create().typeDefinition(JAVA_SQL_RESULTSET).name(NamePredicates.startsWith("get")).addParameter(INT),
+      MethodMatcher.create().typeDefinition(JAVA_SQL_RESULTSET).name(NamePredicates.startsWith("get")).addParameter(INT).addParameter(TypePredicates.anyType()));
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PrimitiveTypeBoxingWithToStringCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PrimitiveTypeBoxingWithToStringCheck.java
index c51ba1fc5a..83b862824e 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/PrimitiveTypeBoxingWithToStringCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PrimitiveTypeBoxingWithToStringCheck.java
@@ -22,9 +22,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.plugins.java.api.JavaFileScanner;
@@ -76,7 +76,7 @@ private static MethodInvocationMatcherCollection getToStringMatchers(String... t
     MethodInvocationMatcherCollection matchers = MethodInvocationMatcherCollection.create();
     for (String fullyQualifiedName : typeFullyQualifiedNames) {
       matchers.add(MethodMatcher.create()
-        .typeDefinition(TypeCriteria.subtypeOf(fullyQualifiedName))
+        .typeDefinition(TypePredicates.isSubtypeOf(fullyQualifiedName))
         .name("toString"));
     }
     return matchers;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
index 02d193544e..f03380227d 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
@@ -28,11 +28,10 @@
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.ExpressionsHelper;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
@@ -75,15 +74,15 @@
   private static final String DECORATE = "decorate";
   // java.util and apache commons
   private static final MethodInvocationMatcherCollection UNMODIFIABLE_METHOD_CALLS = MethodInvocationMatcherCollection.create()
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.anyType()).name(NameCriteria.startsWith("unmodifiable")).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.anyType()).name(NamePredicates.startsWith("unmodifiable")).withNoParameterConstraint())
       // apache commons 3.X
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections.map.UnmodifiableMap")).name(DECORATE).withNoParameterConstraint())
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections.set.UnmodifiableSet")).name(DECORATE).withNoParameterConstraint())
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections.list.UnmodifiableList")).name(DECORATE).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections.map.UnmodifiableMap")).name(DECORATE).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections.set.UnmodifiableSet")).name(DECORATE).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections.list.UnmodifiableList")).name(DECORATE).withNoParameterConstraint())
       // apache commons 4.X
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections4.map.UnmodifiableMap")).name(DECORATE).withNoParameterConstraint())
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections4.set.UnmodifiableSet")).name(DECORATE).withNoParameterConstraint())
-    .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections4.list.UnmodifiableList")).name(DECORATE).withNoParameterConstraint());
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections4.map.UnmodifiableMap")).name(DECORATE).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections4.set.UnmodifiableSet")).name(DECORATE).withNoParameterConstraint())
+    .add(MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("org.apache.commons.collections4.list.UnmodifiableList")).name(DECORATE).withNoParameterConstraint());
   private static final MethodMatcher ARRAYS_AS_LIST = MethodMatcher.create()
     .typeDefinition("java.util.Arrays").name("asList").withNoParameterConstraint();
 
@@ -151,7 +150,7 @@ public void leaveNode(Tree tree) {
 
   static boolean isMutable(@Nullable ExpressionTree initializer, Type type) {
     if (initializer == null) {
-      return Iterables.any(ALWAYS_MUTABLE_TYPES, SyntaxNodePredicates.typeIsSubtypeOf(type));
+      return Iterables.any(ALWAYS_MUTABLE_TYPES, TypePredicates.typeIsSubtypeOf(type));
     }
     ExpressionTree expression = ExpressionsHelper.skipParentheses(initializer);
     if (expression.is(Tree.Kind.METHOD_INVOCATION)) {
@@ -172,7 +171,7 @@ private static boolean isAcceptedTypeOrUnmodifiableMethodCall(MethodInvocationTr
   }
 
   private static boolean isAcceptedType(Type type, Set<String> accepted) {
-    return Iterables.any(accepted, SyntaxNodePredicates.typeIsSubtypeOf(type));
+    return Iterables.any(accepted, TypePredicates.typeIsSubtypeOf(type));
   }
 
   static boolean isPublicStatic(Symbol symbol) {
@@ -180,6 +179,6 @@ static boolean isPublicStatic(Symbol symbol) {
   }
 
   static boolean isForbiddenType(final Type type) {
-    return type.isArray() || Iterables.any(MUTABLE_TYPES, SyntaxNodePredicates.typeIsSubtypeOf(type));
+    return type.isArray() || Iterables.any(MUTABLE_TYPES, TypePredicates.typeIsSubtypeOf(type));
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ReflectionOnNonRuntimeAnnotationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ReflectionOnNonRuntimeAnnotationCheck.java
index 7814aaaecc..f2e2eadfa6 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ReflectionOnNonRuntimeAnnotationCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ReflectionOnNonRuntimeAnnotationCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.SymbolMetadata;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -55,7 +55,7 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.lang.reflect.AnnotatedElement"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.lang.reflect.AnnotatedElement"))
       .name("isAnnotationPresent").withNoParameterConstraint());
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ScheduledThreadPoolExecutorZeroCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ScheduledThreadPoolExecutorZeroCheck.java
index e01425ed2a..ebf6e47b89 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ScheduledThreadPoolExecutorZeroCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ScheduledThreadPoolExecutorZeroCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.LiteralTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
@@ -50,7 +50,7 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(
-        MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.util.concurrent.ThreadPoolExecutor")).name("setCorePoolSize").addParameter("int"),
+        MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.util.concurrent.ThreadPoolExecutor")).name("setCorePoolSize").addParameter("int"),
         MethodMatcher.create().typeDefinition("java.util.concurrent.ScheduledThreadPoolExecutor").name("<init>").addParameter("int")
     );
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
index 6e9c3c7926..136450638e 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.NamePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.NameCriteria;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.CatchTree;
@@ -54,7 +54,7 @@
 public class ServletMethodsExceptionsThrownCheck extends SubscriptionBaseVisitor {
 
   private static final MethodMatcher IS_SERVLET_DO_METHOD = MethodMatcher.create()
-    .typeDefinition(TypeCriteria.subtypeOf("javax.servlet.http.HttpServlet")).name(NameCriteria.startsWith("do")).withNoParameterConstraint();
+    .typeDefinition(TypePredicates.isSubtypeOf("javax.servlet.http.HttpServlet")).name(NamePredicates.startsWith("do")).withNoParameterConstraint();
 
   private final Deque<Boolean> shouldCheck = new ArrayDeque<>();
   private final Deque<List<Type>> tryCatches = new ArrayDeque<>();
diff --git a/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
index a8e40c58ed..d4a5e9e5c7 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/StaticMethodCheck.java
@@ -22,9 +22,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -54,11 +54,11 @@
   private static final String JAVA_IO_SERIALIZABLE = "java.io.Serializable";
   private static final MethodInvocationMatcherCollection EXCLUDED_SERIALIZABLE_METHODS = MethodInvocationMatcherCollection.create(
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf(JAVA_IO_SERIALIZABLE)).name("readObject").addParameter(TypeCriteria.subtypeOf("java.io.ObjectInputStream")),
+      .typeDefinition(TypePredicates.isSubtypeOf(JAVA_IO_SERIALIZABLE)).name("readObject").addParameter(TypePredicates.isSubtypeOf("java.io.ObjectInputStream")),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf(JAVA_IO_SERIALIZABLE)).name("writeObject").addParameter(TypeCriteria.subtypeOf("java.io.ObjectOutputStream")),
+      .typeDefinition(TypePredicates.isSubtypeOf(JAVA_IO_SERIALIZABLE)).name("writeObject").addParameter(TypePredicates.isSubtypeOf("java.io.ObjectOutputStream")),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf(JAVA_IO_SERIALIZABLE)).name("readObjectNoData")
+      .typeDefinition(TypePredicates.isSubtypeOf(JAVA_IO_SERIALIZABLE)).name("readObjectNoData")
   );
 
   private JavaFileScannerContext context;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/StaticMultithreadedUnsafeFieldsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/StaticMultithreadedUnsafeFieldsCheck.java
index 2a93c66dd8..ce82995c2a 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/StaticMultithreadedUnsafeFieldsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/StaticMultithreadedUnsafeFieldsCheck.java
@@ -25,7 +25,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.model.ModifiersUtils;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
@@ -68,7 +68,7 @@ public void visitNode(Tree tree) {
   }
 
   private static boolean isForbiddenType(Type type) {
-    return Iterables.any(FORBIDDEN_TYPES, SyntaxNodePredicates.typeIsSubtypeOf(type));
+    return Iterables.any(FORBIDDEN_TYPES, TypePredicates.typeIsSubtypeOf(type));
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SynchronizationOnStringOrBoxedCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SynchronizationOnStringOrBoxedCheck.java
index 191083c33e..66dc2e0e33 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/SynchronizationOnStringOrBoxedCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SynchronizationOnStringOrBoxedCheck.java
@@ -24,7 +24,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.SynchronizedStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -71,7 +71,7 @@ public void visitNode(Tree tree) {
   }
 
   private static boolean isForbiddenType(Type expressionType) {
-    return Iterables.any(FORBIDDEN_TYPES, SyntaxNodePredicates.typeIs(expressionType));
+    return Iterables.any(FORBIDDEN_TYPES, TypePredicates.typeIs(expressionType));
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SynchronizedClassUsageCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SynchronizedClassUsageCheck.java
index 71d415b810..af85aa2268 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/SynchronizedClassUsageCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SynchronizedClassUsageCheck.java
@@ -26,7 +26,7 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.SyntaxNodePredicates;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.model.declaration.MethodTreeImpl;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -74,7 +74,7 @@ public void visitNode(Tree tree) {
   }
 
   private static boolean isDeprecatedType(Type symbolType) {
-    return symbolType.isClass() && Iterables.any(REPLACEMENTS.keySet(), SyntaxNodePredicates.typeIs(symbolType));
+    return symbolType.isClass() && Iterables.any(REPLACEMENTS.keySet(), TypePredicates.typeIs(symbolType));
   }
 
   private static boolean isOverriding(MethodTree tree) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
index 1495946775..73a7a8bf06 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
@@ -23,9 +23,9 @@
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.ActivatedByDefault;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
@@ -46,7 +46,7 @@
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
     return ImmutableList.of(
-      MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.Runnable")).name("run").withNoParameterConstraint());
+      MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.lang.Runnable")).name("run").withNoParameterConstraint());
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
index 713892ef42..88c41b4169 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
@@ -19,13 +19,15 @@
  */
 package org.sonar.java.checks;
 
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.ActivatedByDefault;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
@@ -50,7 +52,7 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
 
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
-    TypeCriteria subtypeOfThread = TypeCriteria.subtypeOf("java.lang.Thread");
+    Predicate<Type> subtypeOfThread = TypePredicates.isSubtypeOf("java.lang.Thread");
     return ImmutableList.<MethodMatcher>builder()
         .add(MethodMatcher.create().callSite(subtypeOfThread).name("wait"))
         .add(MethodMatcher.create().callSite(subtypeOfThread).name("wait").addParameter("long"))
diff --git a/java-checks/src/main/java/org/sonar/java/checks/UnusedReturnedDataCheck.java b/java-checks/src/main/java/org/sonar/java/checks/UnusedReturnedDataCheck.java
index 99b79ec854..31b30ea84e 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/UnusedReturnedDataCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/UnusedReturnedDataCheck.java
@@ -24,8 +24,8 @@
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.ExpressionsHelper;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
 import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
@@ -51,10 +51,10 @@
 
   private static final List<MethodMatcher> CHECKED_METHODS = ImmutableList.of(
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.io.BufferedReader"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.io.BufferedReader"))
       .name("readLine"),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("java.io.Reader"))
+      .typeDefinition(TypePredicates.isSubtypeOf("java.io.Reader"))
       .name("read"));
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
index 9a64e01649..26eae34bb9 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
@@ -19,13 +19,15 @@
  */
 package org.sonar.java.checks;
 
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import org.sonar.api.server.rule.RulesDefinition;
 import org.sonar.check.Priority;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.checks.methods.MethodMatcher;
-import org.sonar.java.checks.methods.TypeCriteria;
+import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.squidbridge.annotations.ActivatedByDefault;
 import org.sonar.squidbridge.annotations.SqaleConstantRemediation;
@@ -45,7 +47,7 @@
 
   @Override
   protected List<MethodMatcher> getMethodInvocationMatchers() {
-    TypeCriteria conditionSubType = TypeCriteria.subtypeOf("java.util.concurrent.locks.Condition");
+    Predicate<Type> conditionSubType = TypePredicates.isSubtypeOf("java.util.concurrent.locks.Condition");
     return ImmutableList.<MethodMatcher>builder()
         .add(MethodMatcher.create().callSite(conditionSubType).name("wait"))
         .add(MethodMatcher.create().callSite(conditionSubType).name("wait").addParameter("long"))
diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/NamePredicates.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/NamePredicates.java
new file mode 100644
index 0000000000..1f0a599937
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/NamePredicates.java
@@ -0,0 +1,43 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012 SonarSource
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.java.checks.helpers;
+
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+
+public class NamePredicates {
+
+  private NamePredicates() {
+    // Useful predicates to be used with strings
+  }
+
+  public static Predicate<String> any() {
+    return Predicates.alwaysTrue();
+  }
+
+  public static Predicate<String> startsWith(final String prefix) {
+    return new Predicate<String>() {
+      @Override
+      public boolean apply(String input) {
+        return input.startsWith(prefix);
+      }
+    };
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/SyntaxNodePredicates.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/SyntaxNodePredicates.java
index 5e2f65d2fc..fb9991f758 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/helpers/SyntaxNodePredicates.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/SyntaxNodePredicates.java
@@ -20,7 +20,6 @@
 package org.sonar.java.checks.helpers;
 
 import com.google.common.base.Predicate;
-import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.Tree;
 
 import java.util.Set;
@@ -49,31 +48,4 @@ public boolean apply(Tree input) {
     };
   }
 
-  public static Predicate<String> typeIs(final Type type) {
-    return new Predicate<String>() {
-      @Override
-      public boolean apply(String input) {
-        return type.is(input);
-      }
-    };
-  }
-
-  public static Predicate<String> typeIsSubtypeOf(final Type type) {
-    return new Predicate<String>() {
-      @Override
-      public boolean apply(String input) {
-        return type.isSubtypeOf(input);
-      }
-    };
-  }
-
-  public static Predicate<Type> isType(final String type) {
-    return new Predicate<Type>() {
-      @Override
-      public boolean apply(Type input) {
-        return input.is(type);
-      }
-    };
-  }
-
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/TypePredicates.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/TypePredicates.java
new file mode 100644
index 0000000000..6457d9a568
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/TypePredicates.java
@@ -0,0 +1,72 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012 SonarSource
+ * sonarqube@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
+ */
+package org.sonar.java.checks.helpers;
+
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import org.sonar.plugins.java.api.semantic.Type;
+
+public class TypePredicates {
+
+  private TypePredicates() {
+    // Useful predicates to be used with types
+  }
+
+  public static Predicate<String> typeIs(final Type type) {
+    return new Predicate<String>() {
+      @Override
+      public boolean apply(String input) {
+        return type.is(input);
+      }
+    };
+  }
+
+  public static Predicate<String> typeIsSubtypeOf(final Type type) {
+    return new Predicate<String>() {
+      @Override
+      public boolean apply(String input) {
+        return type.isSubtypeOf(input);
+      }
+    };
+  }
+
+  public static Predicate<Type> isType(final String type) {
+    return new Predicate<Type>() {
+      @Override
+      public boolean apply(Type input) {
+        return input.is(type);
+      }
+    };
+  }
+
+  public static Predicate<Type> isSubtypeOf(final String fullyQualifiedName) {
+    return new Predicate<Type>() {
+      @Override
+      public boolean apply(Type input) {
+        return input.isSubtypeOf(fullyQualifiedName);
+      }
+    };
+  }
+
+  public static Predicate<Type> anyType() {
+    return Predicates.alwaysTrue();
+  }
+
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/methods/MethodMatcher.java b/java-checks/src/main/java/org/sonar/java/checks/methods/MethodMatcher.java
index 060a5cb865..548d5dda3a 100644
--- a/java-checks/src/main/java/org/sonar/java/checks/methods/MethodMatcher.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/methods/MethodMatcher.java
@@ -20,7 +20,10 @@
 package org.sonar.java.checks.methods;
 
 import com.google.common.base.Preconditions;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.Lists;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -36,10 +39,10 @@
 
 public class MethodMatcher {
 
-  private TypeCriteria typeDefinition;
-  private TypeCriteria callSite;
-  private NameCriteria methodName;
-  private List<TypeCriteria> parameterTypes;
+  private Predicate<Type> typeDefinition;
+  private Predicate<Type> callSite;
+  private Predicate<String> methodName;
+  private List<Predicate<Type>> parameterTypes;
 
   MethodMatcher() {
     parameterTypes = Lists.newArrayList();
@@ -50,17 +53,17 @@ public static MethodMatcher create() {
   }
 
   public MethodMatcher name(String methodName) {
-    this.methodName = NameCriteria.is(methodName);
+    this.methodName = Predicates.equalTo(methodName);
     return this;
   }
 
-  public MethodMatcher name(NameCriteria methodName) {
+  public MethodMatcher name(Predicate<String> methodName) {
     Preconditions.checkState(this.methodName == null);
     this.methodName = methodName;
     return this;
   }
 
-  public MethodMatcher typeDefinition(TypeCriteria typeDefinition) {
+  public MethodMatcher typeDefinition(Predicate<Type> typeDefinition) {
     Preconditions.checkState(this.typeDefinition == null);
     this.typeDefinition = typeDefinition;
     return this;
@@ -68,22 +71,22 @@ public MethodMatcher typeDefinition(TypeCriteria typeDefinition) {
 
   public MethodMatcher typeDefinition(String fullyQualifiedTypeName) {
     Preconditions.checkState(typeDefinition == null);
-    this.typeDefinition = TypeCriteria.is(fullyQualifiedTypeName);
+    this.typeDefinition = TypePredicates.isType(fullyQualifiedTypeName);
     return this;
   }
 
-  public MethodMatcher callSite(TypeCriteria callSite) {
+  public MethodMatcher callSite(Predicate<Type> callSite) {
     this.callSite = callSite;
     return this;
   }
 
   public MethodMatcher addParameter(String fullyQualifiedTypeParameterName) {
     Preconditions.checkState(parameterTypes != null);
-    parameterTypes.add(TypeCriteria.is(fullyQualifiedTypeParameterName));
+    parameterTypes.add(TypePredicates.isType(fullyQualifiedTypeParameterName));
     return this;
   }
 
-  public MethodMatcher addParameter(TypeCriteria parameterTypeCriteria) {
+  public MethodMatcher addParameter(Predicate<Type> parameterTypeCriteria) {
     Preconditions.checkState(parameterTypes != null);
     parameterTypes.add(parameterTypeCriteria);
     return this;
@@ -131,16 +134,16 @@ private static Type getCallSiteType(MethodInvocationTree mit) {
   private boolean isSearchedMethod(MethodSymbol symbol, Type callSiteType) {
     boolean result = nameAcceptable(symbol) && parametersAcceptable(symbol);
     if (typeDefinition != null) {
-      result &= typeDefinition.matches(symbol.owner().type());
+      result &= typeDefinition.apply(symbol.owner().type());
     }
     if (callSite != null) {
-      result &= callSiteType != null && callSite.matches(callSiteType);
+      result &= callSiteType != null && callSite.apply(callSiteType);
     }
     return result;
   }
 
   private boolean nameAcceptable(MethodSymbol symbol) {
-    return methodName != null && methodName.matches(symbol.name());
+    return methodName != null && methodName.apply(symbol.name());
   }
 
   private boolean parametersAcceptable(MethodSymbol methodSymbol) {
@@ -148,11 +151,11 @@ private boolean parametersAcceptable(MethodSymbol methodSymbol) {
       return true;
     }
     List<Type> parametersTypes = methodSymbol.parameterTypes();
-    List<TypeCriteria> arguments = parameterTypes;
+    List<Predicate<Type>> arguments = parameterTypes;
     if (parametersTypes.size() == arguments.size()) {
       int i = 0;
       for (Type parameterType : parametersTypes) {
-        if (!arguments.get(i).matches(parameterType)) {
+        if (!arguments.get(i).apply(parameterType)) {
           return false;
         }
         i++;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/methods/NameCriteria.java b/java-checks/src/main/java/org/sonar/java/checks/methods/NameCriteria.java
deleted file mode 100644
index 260c8f4f00..0000000000
--- a/java-checks/src/main/java/org/sonar/java/checks/methods/NameCriteria.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * SonarQube Java
- * Copyright (C) 2012 SonarSource
- * sonarqube@googlegroups.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 3 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
- */
-package org.sonar.java.checks.methods;
-
-public abstract class NameCriteria {
-
-  public abstract boolean matches(String name);
-  public static NameCriteria any() {
-    return new AnyNameCriteria();
-  }
-  public static NameCriteria is(String exactName) {
-    return new ExactNameCriteria(exactName);
-  }
-
-  public static NameCriteria startsWith(String prefix) {
-    return new PrefixNameCriteria(prefix);
-  }
-
-  private static class ExactNameCriteria extends NameCriteria {
-    private String exactName;
-
-    public ExactNameCriteria(String exactName) {
-      this.exactName = exactName;
-    }
-
-    @Override
-    public boolean matches(String name) {
-      return exactName.equals(name);
-    }
-  }
-
-  private static class PrefixNameCriteria extends NameCriteria {
-    private String prefix;
-
-    public PrefixNameCriteria(String prefix) {
-      this.prefix = prefix;
-    }
-
-    @Override
-    public boolean matches(String name) {
-      return name.startsWith(prefix);
-    }
-
-  }
-
-  private static class AnyNameCriteria extends NameCriteria {
-    @Override
-    public boolean matches(String name) {
-      return true;
-    }
-  }
-}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/methods/TypeCriteria.java b/java-checks/src/main/java/org/sonar/java/checks/methods/TypeCriteria.java
deleted file mode 100644
index 5475a63fcf..0000000000
--- a/java-checks/src/main/java/org/sonar/java/checks/methods/TypeCriteria.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * SonarQube Java
- * Copyright (C) 2012 SonarSource
- * sonarqube@googlegroups.com
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 3 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
- */
-package org.sonar.java.checks.methods;
-
-import org.sonar.plugins.java.api.semantic.Type;
-
-public abstract class TypeCriteria {
-  public static TypeCriteria subtypeOf(String fullyQualifiedName) {
-    return new SubtypeTypeCriteria(fullyQualifiedName);
-  }
-
-  public static TypeCriteria is(String fullyQualifiedName) {
-    return new FullyQualifiedNameTypeCriteria(fullyQualifiedName);
-  }
-
-  public static TypeCriteria anyType() {
-    return new AnyTypeCriteria();
-  }
-
-  public abstract boolean matches(Type type);
-
-  private static class FullyQualifiedNameTypeCriteria extends TypeCriteria {
-    private String fullyQualifiedName;
-
-    public FullyQualifiedNameTypeCriteria(String fullyQualifiedName) {
-      this.fullyQualifiedName = fullyQualifiedName;
-    }
-
-    @Override
-    public boolean matches(Type type) {
-      return type.is(fullyQualifiedName);
-    }
-  }
-
-  private static class SubtypeTypeCriteria extends TypeCriteria {
-    private String superTypeName;
-
-    public SubtypeTypeCriteria(String superTypeName) {
-      this.superTypeName = superTypeName;
-    }
-
-    @Override
-    public boolean matches(Type type) {
-      return type.isSubtypeOf(superTypeName);
-    }
-  }
-
-  private static class AnyTypeCriteria extends TypeCriteria {
-
-    @Override
-    public boolean matches(Type type) {
-      return true;
-    }
-  }
-}
diff --git a/java-checks/src/main/java/org/sonar/java/closeresource/CloseableVisitor.java b/java-checks/src/main/java/org/sonar/java/closeresource/CloseableVisitor.java
index ff0c4194ae..49b3d3d1cd 100644
--- a/java-checks/src/main/java/org/sonar/java/closeresource/CloseableVisitor.java
+++ b/java-checks/src/main/java/org/sonar/java/closeresource/CloseableVisitor.java
@@ -19,9 +19,9 @@
  */
 package org.sonar.java.closeresource;
 
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.symexecengine.ExecutionState;
 import org.sonar.java.symexecengine.State;
 import org.sonar.java.symexecengine.SymbolicExecutionCheck;
@@ -53,15 +53,15 @@
 
   private static final MethodInvocationMatcherCollection CLOSE_INVOCATIONS = MethodInvocationMatcherCollection.create(
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf(JAVA_IO_CLOSEABLE))
+      .typeDefinition(TypePredicates.isSubtypeOf(JAVA_IO_CLOSEABLE))
       .name(CLOSE_METHOD_NAME)
       .withNoParameterConstraint(),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf(JAVA_LANG_AUTOCLOSEABLE))
+      .typeDefinition(TypePredicates.isSubtypeOf(JAVA_LANG_AUTOCLOSEABLE))
       .name(CLOSE_METHOD_NAME)
       .withNoParameterConstraint(),
     MethodMatcher.create()
-      .typeDefinition(TypeCriteria.subtypeOf("org.springframework.context.support.AbstractApplicationContext"))
+      .typeDefinition(TypePredicates.isSubtypeOf("org.springframework.context.support.AbstractApplicationContext"))
       .name("registerShutdownHook")
       .withNoParameterConstraint());
 
diff --git a/java-checks/src/main/java/org/sonar/java/locks/LockedVisitor.java b/java-checks/src/main/java/org/sonar/java/locks/LockedVisitor.java
index 8466586dad..2d170418dd 100644
--- a/java-checks/src/main/java/org/sonar/java/locks/LockedVisitor.java
+++ b/java-checks/src/main/java/org/sonar/java/locks/LockedVisitor.java
@@ -20,9 +20,9 @@
 package org.sonar.java.locks;
 
 import com.google.common.collect.Lists;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.checks.methods.MethodMatcher;
 import org.sonar.java.checks.methods.MethodInvocationMatcherCollection;
-import org.sonar.java.checks.methods.TypeCriteria;
 import org.sonar.java.symexecengine.ExecutionState;
 import org.sonar.java.symexecengine.State;
 import org.sonar.java.symexecengine.SymbolicExecutionCheck;
@@ -44,18 +44,18 @@
   private static final String JAVA_LOCK = "java.util.concurrent.locks.Lock";
 
   private static final MethodInvocationMatcherCollection LOCK_INVOCATIONS = lockMethodInvocationMatcher();
-  private static final MethodMatcher UNLOCK_INVOCATION = MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf(JAVA_LOCK)).name("unlock");
+  private static final MethodMatcher UNLOCK_INVOCATION = MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf(JAVA_LOCK)).name("unlock");
 
   private static MethodInvocationMatcherCollection lockMethodInvocationMatcher() {
     return MethodInvocationMatcherCollection.create(
       MethodMatcher.create()
-        .typeDefinition(TypeCriteria.subtypeOf(JAVA_LOCK))
+        .typeDefinition(TypePredicates.isSubtypeOf(JAVA_LOCK))
         .name("lock"),
       MethodMatcher.create()
-        .typeDefinition(TypeCriteria.subtypeOf(JAVA_LOCK))
+        .typeDefinition(TypePredicates.isSubtypeOf(JAVA_LOCK))
         .name("lockInterruptibly"),
       MethodMatcher.create()
-        .typeDefinition(TypeCriteria.subtypeOf(JAVA_LOCK))
+        .typeDefinition(TypePredicates.isSubtypeOf(JAVA_LOCK))
         .name("tryLock")
         .withNoParameterConstraint());
   }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/methods/NameCriteriaTest.java b/java-checks/src/test/java/org/sonar/java/checks/helpers/NamePredicatesTest.java
similarity index 67%
rename from java-checks/src/test/java/org/sonar/java/checks/methods/NameCriteriaTest.java
rename to java-checks/src/test/java/org/sonar/java/checks/helpers/NamePredicatesTest.java
index 806ac88dd3..c3d62391cb 100644
--- a/java-checks/src/test/java/org/sonar/java/checks/methods/NameCriteriaTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/helpers/NamePredicatesTest.java
@@ -17,26 +17,28 @@
  * License along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
  */
-package org.sonar.java.checks.methods;
+package org.sonar.java.checks.helpers;
 
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import org.junit.Test;
 
 import static org.fest.assertions.Assertions.assertThat;
 
-public class NameCriteriaTest {
+public class NamePredicatesTest {
 
   @Test
   public void should_match_exact_name() {
-    NameCriteria nc = NameCriteria.is("equal");
-    assertThat(nc.matches("foo")).isFalse();
-    assertThat(nc.matches("equal")).isTrue();
+    Predicate<String> nc = Predicates.equalTo("equal");
+    assertThat(nc.apply("foo")).isFalse();
+    assertThat(nc.apply("equal")).isTrue();
   }
 
   @Test
   public void should_match_prefix() {
-    NameCriteria nc = NameCriteria.startsWith("get");
-    assertThat(nc.matches("equal")).isFalse();
-    assertThat(nc.matches("get")).isTrue();
-    assertThat(nc.matches("getObject")).isTrue();
+    Predicate<String> nc = NamePredicates.startsWith("get");
+    assertThat(nc.apply("equal")).isFalse();
+    assertThat(nc.apply("get")).isTrue();
+    assertThat(nc.apply("getObject")).isTrue();
   }
 }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/methods/MethodMatcherTest.java b/java-checks/src/test/java/org/sonar/java/checks/methods/MethodMatcherTest.java
index db35580c1a..c0b0ecb31f 100644
--- a/java-checks/src/test/java/org/sonar/java/checks/methods/MethodMatcherTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/methods/MethodMatcherTest.java
@@ -25,6 +25,7 @@
 import org.junit.rules.ExpectedException;
 import org.sonar.java.ast.JavaAstScanner;
 import org.sonar.java.checks.SubscriptionBaseVisitor;
+import org.sonar.java.checks.helpers.TypePredicates;
 import org.sonar.java.model.JavaTree;
 import org.sonar.java.model.VisitorsBridge;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
@@ -62,7 +63,7 @@ public void should_fail_if_withNoParameterConstraint_is_called_after_addParamete
 
   @Test
   public void detected() {
-    MethodMatcher objectToString = MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.Object")).name("toString");
+    MethodMatcher objectToString = MethodMatcher.create().typeDefinition(TypePredicates.isSubtypeOf("java.lang.Object")).name("toString");
     MethodMatcher integerToString = MethodMatcher.create().typeDefinition("java.lang.Integer").name("toString");
 
     Map<MethodMatcher, List<Integer>> matches = new HashMap<>();
